const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CH7L2sk2.js","assets/index-DMdK_k-l.js","assets/index-Bs2EL0Mm.js","assets/index-DAbXUXm9.css","assets/HomePage-D_Hs-RaH.js","assets/use-llm-Kc_COJca.js","assets/routes-Q3DgWzwS.js","assets/use-prevent-pitch-zoom-DzGgDOPg.js","assets/index-Br76-WZb.js","assets/objectWithoutPropertiesLoose-CoJdz_cg.js","assets/folder-open-dIe9OhV5.js","assets/createLucideIcon-DZXM6zSt.js","assets/folder-Dbc0RVEZ.js","assets/file-Cu_wxXYl.js","assets/index-DFEePeEy.js","assets/index-C_vD25Dk.js","assets/index-ZlDJDwwO.js"])))=>i.map(i=>d[i]);
import { r as reactExports, Y as FlowNodeTypeEnum, y as getRepository, j as jsxRuntimeExports, c as createContextScope, f as useComposedRefs, P as Primitive, e as Presence, d as composeEventHandlers, i as useCallbackRef, u as useLayoutEffect2, g as cn, _ as __vitePreload, aA as process$1, ab as logError, L as LazyIcon, __tla as __tla_0 } from "./index-Bs2EL0Mm.js";
import { u as useFlowState, r as useBaseConnectionToHandler, s as parseFileSystemTreeToJSONL, v as clamp, w as Root2, x as Item, y as Trigger2, z as Content2, B as convertToElementsTree, D as parseJSONLToFileSystemTree, E as updateFileContentOfFileSystemTree, F as CreateSourcebaseCard, __tla as __tla_1 } from "./HomePage-D_Hs-RaH.js";
import { u as useInternalNode, __tla as __tla_2 } from "./use-llm-Kc_COJca.js";
import { u as usePreventPitchZoom, __tla as __tla_3 } from "./use-prevent-pitch-zoom-DzGgDOPg.js";
import { u as useWebContainerState, __tla as __tla_4 } from "./index-Br76-WZb.js";
import { _ as _objectWithoutPropertiesLoose, a as _extends } from "./objectWithoutPropertiesLoose-CoJdz_cg.js";
import { u as useDirection, B as Button, __tla as __tla_5 } from "./routes-Q3DgWzwS.js";
import FolderOpen, { __tla as __tla_6 } from "./folder-open-dIe9OhV5.js";
import Folder$1, { __tla as __tla_7 } from "./folder-Dbc0RVEZ.js";
import File$1, { __tla as __tla_8 } from "./file-Cu_wxXYl.js";
let CodeContainerApp$1, DefaultBufferLength, EditorView, IterMode, LanguageSupport, NodeWeakMap, Parser, Tree$1, syntaxTree, EditorSelection, completeFromList, snippetCompletion, LRLanguage, indentNodeProp, continuedIndent, flatIndent, ifNotIn, delimitedIndent, foldNodeProp, foldInside, sublanguageProp, defineLanguageFacet, NodeSet, NodeType, NodeProp, parseMixed, styleTags, tags, bracketMatchingHandle;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_2;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_3;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_4;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_5;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_6;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_7;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_8;
    } catch {
    }
  })()
]).then(async () => {
  const useConnectionToHandler = (id) => {
    const createOrUpdateFlowEdge = useFlowState((state) => state.createOrUpdateFlowEdge);
    const connectionHandler = reactExports.useCallback(async ({ edgeId, source, target, connection }) => {
      try {
        if ((source == null ? void 0 : source.type) === FlowNodeTypeEnum.LLM && (target == null ? void 0 : target.type) === FlowNodeTypeEnum.EditorApp) {
          await createOrUpdateFlowEdge({
            source: connection.source,
            target: connection.target,
            sourceHandle: connection.sourceHandle,
            targetHandle: connection.targetHandle
          });
          return;
        }
        return {
          deleteEdgeId: edgeId
        };
      } catch {
        return {
          deleteEdgeId: edgeId
        };
      }
    }, [
      createOrUpdateFlowEdge
    ]);
    useBaseConnectionToHandler(id, connectionHandler);
  };
  const useActions = (id) => {
    useInternalNode(id);
    const updateCodeContainerData = reactExports.useCallback(async (id2, data) => {
      await getRepository("FlowNode").update(id2, {
        raw: parseFileSystemTreeToJSONL(data)
      });
    }, []);
    return {
      updateCodeContainerData
    };
  };
  const ContainerBrowser = reactExports.memo(({ iframeRef }) => {
    const [url, setURL] = reactExports.useState("");
    const webcontainerInstance = useWebContainerState((state) => state.webcontainerInstance);
    const editorRef = reactExports.useRef(null);
    usePreventPitchZoom(editorRef);
    reactExports.useEffect(() => {
      if (!webcontainerInstance) {
        return;
      }
      const remove2 = webcontainerInstance.on("server-ready", (_, url2) => {
        setURL(url2);
      });
      return () => {
        remove2();
      };
    }, [
      webcontainerInstance
    ]);
    return jsxRuntimeExports.jsxs("div", {
      ref: editorRef,
      className: "flex-1 w-full flex relative max-w-full flex-col",
      children: [
        jsxRuntimeExports.jsx("div", {
          className: "relative flex items-center w-full py-3 px-24 bg-neutral-300",
          children: jsxRuntimeExports.jsx("div", {
            className: "flex justify-center items-center size-full rounded-lg text-[.25rem] sm:text-[.5rem] bg-neutral-200 text-neutral-400 overflow-hidden",
            children: (url == null ? void 0 : url.length) > 42 ? `${url.substring(0, 42)}...` : "No URL"
          })
        }),
        jsxRuntimeExports.jsx("div", {
          className: "bg-background w-full flex-1 nowheel nodrag overflow-auto",
          children: jsxRuntimeExports.jsx("iframe", {
            src: url,
            ref: iframeRef,
            className: "min-h-full w-full",
            allow: "cross-origin-isolated",
            credentialless: true
          })
        })
      ]
    });
  });
  let Text$1 = class Text2 {
    lineAt(pos) {
      if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text.length) text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      [from, to] = clip(this, from, to);
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this) return true;
      if (other.length != this.length || other.lines != this.lines) return false;
      let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start, pos = start; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;
        pos += a.value.length;
        if (a.done || pos >= end) return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null) to = this.lines + 1;
        let start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    constructor() {
    }
    static of(text) {
      if (text.length == 0) throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0]) return Text2.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  class TextLeaf extends Text$1 {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let string2 = this.text[i2], end = offset + string2.length;
        if ((isLine ? line : end) >= target) return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to, text) {
      if (!(text instanceof TextLeaf)) return super.replace(from, to, text);
      [from, to] = clip(this, from, to);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text.length - (to - from);
      if (lines.length <= 32) return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let pos = 0, i2 = 0; pos <= to && i2 < this.text.length; i2++) {
        let line = this.text[i2], end = pos + line.length;
        if (pos > from && i2) result += lineSep;
        if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text) target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1) target.push(new TextLeaf(part, len));
      return target;
    }
  }
  class TextNode extends Text$1 {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children) this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i2 = 0, pos = 0; pos <= to && i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen) target.push(child);
          else child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text) {
      [from, to] = clip(this, from, to);
      if (text.lines < this.lines) for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i2] = updated;
            return new TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
      return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      [from, to] = clip(this, from, to);
      let result = "";
      for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos > from && i2) result += lineSep;
        if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children) child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode)) return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [
        0,
        0,
        this.children.length,
        other.children.length
      ] : [
        this.children.length - 1,
        other.children.length - 1,
        -1,
        -1
      ];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB) return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB) return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children) lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children) ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children) add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk) flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0) return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children) add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  }
  Text$1.empty = new TextLeaf([
    ""
  ], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text) length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to; i2++) {
      let line = text[i2], end = pos + line.length;
      if (end >= from) {
        if (end > to) line = line.slice(0, to - pos);
        if (pos < from) line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [
      ""
    ], from, to);
  }
  class RawTextCursor {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [
        text
      ];
      this.offsets = [
        dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1
      ];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0) this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0) this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  }
  class PartialTextCursor {
    constructor(text, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
      this.pos = start > end ? text.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit) skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0) skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  }
  class LineCursor {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done && this.afterBreak) {
        this.value = "";
        this.afterBreak = false;
      } else if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  }
  if (typeof Symbol != "undefined") {
    Text$1.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  class Line {
    constructor(from, to, number2, text) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  }
  function clip(text, from, to) {
    from = Math.max(0, Math.min(text.length, from));
    return [
      from,
      Math.max(from, Math.min(text.length, to))
    ];
  }
  let extend = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i2 = 1; i2 < extend.length; i2++) extend[i2] += extend[i2 - 1];
  function isExtendingChar(code2) {
    for (let i2 = 1; i2 < extend.length; i2 += 2) if (extend[i2] > code2) return extend[i2 - 1] <= code2;
    return false;
  }
  function isRegionalIndicator(code2) {
    return code2 >= 127462 && code2 <= 127487;
  }
  const ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length) return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i2 = pos - 2;
        while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
          countBefore++;
          i2 -= 2;
        }
        if (countBefore % 2 == 0) break;
        else pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos) return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1)) return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code2) {
    if (code2 <= 65535) return String.fromCharCode(code2);
    code2 -= 65536;
    return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
  }
  function codePointSize(code2) {
    return code2 < 65536 ? 1 : 2;
  }
  const DefaultSplit = /\r\n?|\n/;
  var MapMode = function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  class ChangeDesc {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) result += this.sections[i2];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let ins = this.sections[i2 + 1];
        result += ins < 0 ? this.sections[i2] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0) sections.push(len, ins);
        else sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos) return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;
          if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number")) throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  }
  class ChangeSet extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length) throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
        let len = sections[i2], ins = sections[i2 + 1];
        if (ins >= 0) {
          sections[i2] = ins;
          sections[i2 + 1] = len;
          let index = i2 >> 1;
          while (inserted.length < index) inserted.push(Text$1.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text$1.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done: for (let i2 = 0, pos = 0; ; ) {
        let next = i2 == ranges.length ? 1e9 : ranges[i2++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done) break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i2++];
        while (pos < end) {
          if (iter.done) break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let len = this.sections[i2], ins = this.sections[i2 + 1];
        if (ins < 0) parts.push(len);
        else if (ins == 0) parts.push([
          len
        ]);
        else parts.push([
          len
        ].concat(this.inserted[i2 >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length) return;
        if (pos < length) addSection(sections, length - pos, -1);
        let set = new ChangeSet(sections, inserted);
        total = total ? total.compose(set.map(total)) : set;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec) process(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert2 } = spec;
          if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text$1.empty : typeof insert2 == "string" ? Text$1.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0) return;
          if (from < pos) flush();
          if (from > pos) addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [
        length,
        -1
      ] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json)) throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i2 = 0; i2 < json.length; i2++) {
        let part = json[i2];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i3) => i3 && typeof e != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i2) inserted.push(Text$1.empty);
          inserted[i2] = Text$1.of(part.slice(1));
          sections.push(part[0], inserted[i2].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  }
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0) return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;
    else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0) return;
    let index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index) values.push(Text$1.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
      let len = desc.sections[i2++], ins = desc.sections[i2++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text$1.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted) text = text.append(inserted[i2 - 2 >> 1]);
          if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0) break;
          len = desc.sections[i2++];
          ins = desc.sections[i2++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let inserted = -1; ; ) {
      if (a.ins == -1 && b.ins == -1) {
        let len = Math.min(a.len, b.len);
        addSection(sections, len, -1);
        a.forward(len);
        b.forward(len);
      } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
        let len = b.len;
        addSection(sections, b.ins, -1);
        while (len) {
          let piece = Math.min(a.len, len);
          if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
            addSection(sections, 0, a.ins);
            if (insert2) addInsert(insert2, sections, a.text);
            inserted = a.i;
          }
          a.forward(piece);
          len -= piece;
        }
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, left = a.len;
        while (left) {
          if (b.ins == -1) {
            let piece = Math.min(left, b.len);
            len += piece;
            left -= piece;
            b.forward(piece);
          } else if (b.ins == 0 && b.len < left) {
            left -= b.len;
            b.next();
          } else {
            break;
          }
        }
        addSection(sections, len, inserted < a.i ? a.ins : 0);
        if (insert2 && inserted < a.i) addInsert(insert2, sections, a.text);
        inserted = a.i;
        a.forward(a.len - left);
      } else if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2) addInsert(insert2, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB) addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert2) addInsert(insert2, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off) addInsert(insert2, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  class SectionIter {
    constructor(set) {
      this.set = set;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text$1.empty : inserted[index];
    }
    textBit(len) {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text$1.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len) this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1) this.forward(len);
      else if (len == this.ins) this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  }
  class SelectionRange {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 32 ? this.to : this.from;
    }
    get head() {
      return this.flags & 32 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 7;
      return level == 7 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 6;
      return value == 16777215 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other, includeAssoc = false) {
      return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
    }
    toJSON() {
      return {
        anchor: this.anchor,
        head: this.head
      };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
  }
  EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty) return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other, includeAssoc = false) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;
      for (let i2 = 0; i2 < this.ranges.length; i2++) if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc)) return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([
        this.main
      ], 0);
    }
    addRange(range, main = true) {
      return EditorSelection.create([
        range
      ].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return {
        ranges: this.ranges.map((r) => r.toJSON()),
        main: this.mainIndex
      };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([
        EditorSelection.range(anchor, head)
      ], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0) throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
        let range = ranges[i2];
        if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
    }
    static range(anchor, head, goalColumn, bidiLevel) {
      let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
      return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (let i2 = 1; i2 < ranges.length; i2++) {
        let range = ranges[i2], prev = ranges[i2 - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from = prev.from, to = Math.max(range.to, prev.to);
          if (i2 <= mainIndex) mainIndex--;
          ranges.splice(--i2, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection2, docLength) {
    for (let range of selection2.ranges) if (range.to > docLength) throw new RangeError("Selection points outside of document");
  }
  let nextID = 0;
  class Facet {
    constructor(combine, compareInput, compare2, isStatic, enables) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.id = nextID++;
      this.default = combine([]);
      this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    get reader() {
      return this;
    }
    static define(config2 = {}) {
      return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray$1 : (a, b) => a === b), !!config2.static, config2.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps, get) {
      if (this.isStatic) throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 1, get);
    }
    computeN(deps, get) {
      if (this.isStatic) throw new Error("Can't compute a static facet");
      return new FacetProvider(deps, this, 2, get);
    }
    from(field, get) {
      if (!get) get = (x) => x;
      return this.compute([
        field
      ], (state) => get(state.field(field)));
    }
  }
  function sameArray$1(a, b) {
    return a == b || a.length == b.length && a.every((e, i2) => e === b[i2]);
  }
  class FacetProvider {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc") depDoc = true;
        else if (dep == "selection") depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state) {
          state.values[idx] = getter(state);
          return 1;
        },
        update(state, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
            let newVal = getter(state);
            if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
              state.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state, oldState) => {
          let newVal, oldAddr = oldState.config.address[id];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
            }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
              state.values[idx] = oldVal;
              return 0;
            }
          } else {
            newVal = getter(state);
          }
          state.values[idx] = newVal;
          return 1;
        }
      };
    }
  }
  function compareArray(a, b, compare2) {
    if (a.length != b.length) return false;
    for (let i2 = 0; i2 < a.length; i2++) if (!compare2(a[i2], b[i2])) return false;
    return true;
  }
  function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs) if (ensureAddr(state, addr) & 1) changed = true;
    return changed;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
      let values = [];
      for (let i2 = 0; i2 < providerAddrs.length; i2++) {
        let value = getAddr(state, providerAddrs[i2]);
        if (providerTypes[i2] == 2) for (let val of value) values.push(val);
        else values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state) {
        for (let addr of providerAddrs) ensureAddr(state, addr);
        state.values[idx] = get(state);
        return 1;
      },
      update(state, tr) {
        if (!ensureAll(state, dynamic)) return 0;
        let value = get(state);
        if (facet.compare(value, state.values[idx])) return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure(state, oldState) {
        let depChanged = ensureAll(state, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
          state.values[idx] = oldValue;
          return 0;
        }
        let value = get(state);
        if (facet.compare(value, oldValue)) {
          state.values[idx] = oldValue;
          return 0;
        }
        state.values[idx] = value;
        return 1;
      }
    };
  }
  const initField = Facet.define({
    static: true
  });
  class StateField {
    constructor(id, createF, updateF, compareF, spec) {
      this.id = id;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config2) {
      let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
      if (config2.provide) field.provides = config2.provide(field);
      return field;
    }
    create(state) {
      let init = state.facet(initField).find((i2) => i2.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state) => {
          state.values[idx] = this.create(state);
          return 1;
        },
        update: (state, tr) => {
          let oldVal = state.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value)) return 0;
          state.values[idx] = value;
          return 1;
        },
        reconfigure: (state, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state.values[idx] = oldState.field(this);
            return 0;
          }
          state.values[idx] = this.create(state);
          return 1;
        }
      };
    }
    init(create) {
      return [
        this,
        initField.of({
          field: this,
          create
        })
      ];
    }
    get extension() {
      return this;
    }
  }
  const Prec_ = {
    lowest: 4,
    low: 3,
    default: 2,
    high: 1,
    highest: 0
  };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  const Prec = {
    highest: prec(Prec_.highest),
    high: prec(Prec_.high),
    default: prec(Prec_.default),
    low: prec(Prec_.low),
    lowest: prec(Prec_.lowest)
  };
  class PrecExtension {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  }
  class Compartment {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({
        compartment: this,
        extension: content2
      });
    }
    get(state) {
      return state.config.compartments.get(this);
    }
  }
  class CompartmentInstance {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  }
  class Configuration {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten(base2, compartments, newCompartments)) {
        if (ext instanceof StateField) fields.push(ext);
        else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id in facets) {
        let providers = facets[id], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray$1(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  }
  function flatten(extension, compartments, newCompartments) {
    let result = [
      [],
      [],
      [],
      [],
      []
    ];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2) return;
        let found = result[known].indexOf(ext);
        if (found > -1) result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e of ext) inner(e, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides) inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);
      } else {
        let content2 = ext.extension;
        if (!content2) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state, addr) {
    if (addr & 1) return 2;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4) throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2) return status;
    state.status[idx] = 4;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 | changed;
  }
  function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
  }
  const languageData = Facet.define();
  const allowMultipleSelections = Facet.define({
    combine: (values) => values.some((v) => v),
    static: true
  });
  const lineSeparator = Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  const changeFilter = Facet.define();
  const transactionFilter = Facet.define();
  const transactionExtender = Facet.define();
  const readOnly = Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  class Annotation {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  }
  class AnnotationType {
    of(value) {
      return new Annotation(this, value);
    }
  }
  class StateEffectType {
    constructor(map) {
      this.map = map;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  }
  class StateEffect {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length) return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped) result.push(mapped);
      }
      return result;
    }
  }
  StateEffect.reconfigure = StateEffect.define();
  StateEffect.appendConfig = StateEffect.define();
  class Transaction {
    constructor(startState, changes, selection2, effects, annotations, scrollIntoView2) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection2;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView2;
      this._doc = null;
      this._state = null;
      if (selection2) checkSelection(selection2, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    static create(startState, changes, selection2, effects, annotations, scrollIntoView2) {
      return new Transaction(startState, changes, selection2, effects, annotations, scrollIntoView2);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state) this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations) if (ann.type == type) return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e = this.annotation(Transaction.userEvent);
      return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
  }
  Transaction.time = Annotation.define();
  Transaction.userEvent = Annotation.define();
  Transaction.addToHistory = Annotation.define();
  Transaction.remote = Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else return result;
      if (!result.length || result[result.length - 1] < from) result.push(from, to);
      else if (result[result.length - 1] < to) result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray$1(spec.annotations);
    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray$1(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false) filter = false;
    for (let i2 = 1; i2 < specs.length; i2++) {
      if (specs[i2].filter === false) filter = false;
      let seq = !!specs[i2].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state, specs[i2], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state = tr.startState;
    let result = true;
    for (let filter of state.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
      }
      tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state.facet(transactionFilter);
    for (let i2 = filters.length - 1; i2 >= 0; i2--) {
      let filtered = filters[i2](tr);
      if (filtered instanceof Transaction) tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];
      else tr = resolveTransaction(state, asArray$1(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
      let extension = extenders[i2](tr);
      if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  const none$2 = [];
  function asArray$1(value) {
    return value == null ? none$2 : Array.isArray(value) ? value : [
      value
    ];
  }
  var CharCategory = function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  let wordChar;
  try {
    wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar) return wordChar.test(str);
    for (let i2 = 0; i2 < str.length; i2++) {
      let ch = str[i2];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char)) return CharCategory.Space;
      if (hasWordChar(char)) return CharCategory.Word;
      for (let i2 = 0; i2 < wordChars.length; i2++) if (char.indexOf(wordChars[i2]) > -1) return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  class EditorState {
    constructor(config2, doc2, selection2, values, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection2;
      this.values = values;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr) tr._state = this;
      for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++) ensureAddr(this, i2 << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2) throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key) => compartments.set(key, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray$1(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      let selection2 = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
      new EditorState(conf, tr.newDoc, selection2, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    replaceSelection(text) {
      if (typeof text == "string") text = this.toText(text);
      return this.changeByRange((range) => ({
        changes: {
          from: range.from,
          to: range.to,
          insert: text
        },
        range: EditorSelection.cursor(range.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [
        result1.range
      ];
      let effects = asArray$1(result1.effects);
      for (let i2 = 1; i2 < sel.ranges.length; i2++) {
        let result = f(sel.ranges[i2]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i2; j++) ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet) return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text$1.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null) return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields) for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
      return result;
    }
    static fromJSON(json, config2 = {}, fields) {
      if (!json || typeof json.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields) for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config2.extensions ? fieldInit.concat([
          config2.extensions
        ]) : fieldInit
      });
    }
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config2.doc instanceof Text$1 ? config2.doc : Text$1.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection2, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections)) selection2 = selection2.asSingle();
      return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase2, ...insert2) {
      for (let map of this.facet(EditorState.phrases)) if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
      if (insert2.length) phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i2) => {
        if (i2 == "$") return "$";
        let n = +(i2 || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
      return phrase2;
    }
    languageDataAt(name2, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name2)) values.push(result[name2]);
        }
      }
      return values;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text, from, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from, end = pos - from;
      while (start > 0) {
        let prev = findClusterBreak(text, start, false);
        if (cat(text.slice(prev, start)) != CharCategory.Word) break;
        start = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word) break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
  }
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = StateEffect.define();
  function combineConfig(configs, defaults2, combine = {}) {
    let result = {};
    for (let config2 of configs) for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0) result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);
      else throw new Error("Config merge conflict for field " + key);
    }
    for (let key in defaults2) if (result[key] === void 0) result[key] = defaults2[key];
    return result;
  }
  class RangeValue {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return Range$1.create(from, to, this);
    }
  }
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  let Range$1 = class Range2 {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    static create(from, to, value) {
      return new Range2(from, to, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  class Chunk {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi) return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo) return diff >= 0 ? lo : hi;
        if (diff >= 0) hi = mid;
        else lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i2 = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i2); i2 < e; i2++) if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false) return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i2 = 0; i2 < this.value.length; i2++) {
        let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null) continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom) continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
        if (newPos < 0) newPos = newFrom;
        if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return {
        mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
        pos: newPos
      };
    }
  }
  class RangeSet {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty) return 0;
      let size = this.nextLayer.size;
      for (let chunk of this.chunk) size += chunk.value.length;
      return size;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter) return this;
      if (sort) add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty) return add2.length ? RangeSet.of(add2) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i2 < add2.length) {
        if (i2 < add2.length && (cur2.from - add2[i2].from || cur2.startSide - add2[i2].value.startSide) >= 0) {
          let range = add2[i2++];
          if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i2].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value)) spill.push(Range$1.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({
        add: spill,
        filter,
        filterFrom,
        filterTo
      }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty) return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start = this.chunkPos[i2], chunk = this.chunk[i2];
        let touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty) return;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start = this.chunkPos[i2], chunk = this.chunk[i2];
        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([
        this
      ]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null) to = 1e9 - 1;
      let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
      let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
      if (a.length != b.length) return false;
      if (!a.length) return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;
        if (sideA.to > to) return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let openRanges = cursor2.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor2.to, to);
        if (cursor2.point) {
          let active = cursor2.activeForPoint(cursor2.to);
          let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
          iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
          openRanges = Math.min(cursor2.openEnd(curTo), active.length);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor2.active, openRanges);
          openRanges = cursor2.openEnd(curTo);
        }
        if (cursor2.to > to) return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
        pos = cursor2.to;
        cursor2.next();
      }
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range$1 ? [
        ranges
      ] : sort ? lazySort(ranges) : ranges) build.add(range.from, range.to, range.value);
      return build.finish();
    }
    static join(sets) {
      if (!sets.length) return RangeSet.empty;
      let result = sets[sets.length - 1];
      for (let i2 = sets.length - 2; i2 >= 0; i2--) {
        for (let layer2 = sets[i2]; layer2 != RangeSet.empty; layer2 = layer2.nextLayer) result = new RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
      }
      return result;
    }
  }
  RangeSet.empty = new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1) for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
      let cur2 = ranges[i2];
      if (cmpRange(prev, cur2) > 0) return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  class RangeSetBuilder {
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0) return false;
      if (this.from.length == 250) this.finishChunk(true);
      if (this.chunkStart < 0) this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;
      if (this.from.length) this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length) this.finishChunk(false);
      if (this.chunks.length == 0) return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  }
  function findSharedChunks(a, b, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set of a) for (let i2 = 0; i2 < set.chunk.length; i2++) if (set.chunk[i2].maxPoint <= 0) inA.set(set.chunk[i2], set.chunkPos[i2]);
    let shared = /* @__PURE__ */ new Set();
    for (let set of b) for (let i2 = 0; i2 < set.chunk.length; i2++) {
      let known = inA.get(set.chunk[i2]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i2].length))) shared.add(set.chunk[i2]);
    }
    return shared;
  }
  class LayerCursor {
    constructor(layer2, skip, minPoint, rank = 0) {
      this.layer = layer2;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  }
  class HeapCursor {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i2 = 0; i2 < sets.length; i2++) {
        for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint) heap.push(new LayerCursor(cur2, skip, minPoint, i2));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap) cur2.goto(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--) heapBubble(this.heap, i2);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap) cur2.forward(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--) heapBubble(this.heap, i2);
      if ((this.to - pos || this.value.endSide - side) < 0) this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value) top2.next();
        heapBubble(this.heap, 0);
      }
    }
  }
  function heapBubble(heap, index) {
    for (let cur2 = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length) break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0) break;
      heap[childIndex] = cur2;
      heap[index] = child;
      index = childIndex;
    }
  }
  class SpanCursor {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i2 = 0, { value, to, rank } = this.cursor;
      while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to - this.activeTo[i2]) > 0) i2++;
      insert(this.active, i2, value);
      insert(this.activeTo, i2, to);
      insert(this.activeRank, i2, rank);
      if (trackOpen) insert(trackOpen, i2, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen) remove(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        this.openStart = 0;
        for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from; i2--) this.openStart++;
      }
    }
    activeForPoint(to) {
      if (!this.active.length) return this.active;
      let active = [];
      for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
        if (this.activeRank[i2] < this.pointRank) break;
        if (this.activeTo[i2] > to || this.activeTo[i2] == to && this.active[i2].endSide >= this.point.endSide) active.push(this.active[i2]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to; i2--) open++;
      return open;
    }
  }
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB) break;
      pos = end;
      if (diff <= 0) a.next();
      if (diff >= 0) b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length) return false;
    for (let i2 = 0; i2 < a.length; i2++) if (a[i2] != b[i2] && !a[i2].eq(b[i2])) return false;
    return true;
  }
  function remove(array, index) {
    for (let i2 = index, e = array.length - 1; i2 < e; i2++) array[i2] = array[i2 + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (let i2 = array.length - 1; i2 >= index; i2--) array[i2 + 1] = array[i2];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i2 = 0; i2 < array.length; i2++) if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
      found = i2;
      foundPos = array[i2];
    }
    return found;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n = 0;
    for (let i2 = 0; i2 < to; ) {
      if (string2.charCodeAt(i2) == 9) {
        n += tabSize - n % tabSize;
        i2++;
      } else {
        n++;
        i2 = findClusterBreak(string2, i2);
      }
    }
    return n;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i2 = 0, n = 0; ; ) {
      if (n >= col) return i2;
      if (i2 == string2.length) break;
      n += string2.charCodeAt(i2) == 9 ? tabSize - n % tabSize : 1;
      i2 = findClusterBreak(string2, i2);
    }
    return strict === true ? -1 : string2.length;
  }
  const C = "\u037C";
  const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  class StyleModule {
    constructor(spec, options) {
      this.rules = [];
      let { finish } = options || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [
          selector
        ] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null) return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
          } else if (value && typeof value == "object") {
            if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id = top[COUNT] || 1;
      top[COUNT] = id + 1;
      return C + id.toString(36);
    }
    static mount(root, modules, options) {
      let set = root[SET], nonce = options && options.nonce;
      if (!set) set = new StyleSet(root, nonce);
      else if (nonce) set.setNonce(nonce);
      set.mount(Array.isArray(modules) ? modules : [
        modules
      ], root);
    }
  }
  let adoptedSet = /* @__PURE__ */ new Map();
  class StyleSet {
    constructor(root, nonce) {
      let doc2 = root.ownerDocument || root, win = doc2.defaultView;
      if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
        let adopted = adoptedSet.get(doc2);
        if (adopted) return root[SET] = adopted;
        this.sheet = new win.CSSStyleSheet();
        adoptedSet.set(doc2, this);
      } else {
        this.styleTag = doc2.createElement("style");
        if (nonce) this.styleTag.setAttribute("nonce", nonce);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules, root) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i2 = 0; i2 < modules.length; i2++) {
        let mod = modules[i2], index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index) pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (sheet) {
        if (root.adoptedStyleSheets.indexOf(this.sheet) < 0) root.adoptedStyleSheets = [
          this.sheet,
          ...root.adoptedStyleSheets
        ];
      } else {
        let text = "";
        for (let i2 = 0; i2 < this.modules.length; i2++) text += this.modules[i2].getRules() + "\n";
        this.styleTag.textContent = text;
        let target = root.head || root;
        if (this.styleTag.parentNode != target) target.insertBefore(this.styleTag, target.firstChild);
      }
    }
    setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce) this.styleTag.setAttribute("nonce", nonce);
    }
  }
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
  for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
  for (var i = 65; i <= 90; i++) {
    base[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
  function keyName(event) {
    var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie$1 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name2 == "Esc") name2 = "Escape";
    if (name2 == "Del") name2 = "Delete";
    if (name2 == "Left") name2 = "ArrowLeft";
    if (name2 == "Up") name2 = "ArrowUp";
    if (name2 == "Right") name2 = "ArrowRight";
    if (name2 == "Down") name2 = "ArrowDown";
    return name2;
  }
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function hasSelection(dom, selection2) {
    if (!selection2.anchorNode) return false;
    try {
      return contains(dom, selection2.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom) {
    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1) return dom.getClientRects();
    else return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node) return index;
    }
  }
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff) return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV") return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1) return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false") return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return {
      left: x,
      right: x,
      top: rect.top,
      bottom: rect.bottom
    };
  }
  function windowRect(win) {
    let vp = win.visualViewport;
    if (vp) return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;
    return {
      scaleX,
      scaleY
    };
  }
  function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    for (let cur2 = dom, stop = false; cur2 && !stop; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc2.body;
        let scaleX = 1, scaleY = 1;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position)) stop = true;
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.assignedSlot || cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          ({ scaleX, scaleY } = getScale(cur2, rect2));
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth * scaleX,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight * scaleY
          };
        }
        let moveX = 0, moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            let movedX = 0, movedY = 0;
            if (moveY) {
              let start = cur2.scrollTop;
              cur2.scrollTop += moveY / scaleY;
              movedY = (cur2.scrollTop - start) * scaleY;
            }
            if (moveX) {
              let start = cur2.scrollLeft;
              cur2.scrollLeft += moveX / scaleX;
              movedX = (cur2.scrollLeft - start) * scaleX;
            }
            rect = {
              left: rect.left - movedX,
              top: rect.top - movedY,
              right: rect.right - movedX,
              bottom: rect.bottom - movedY
            };
            if (movedX && Math.abs(movedX - moveX) < 1) x = "nearest";
            if (movedY && Math.abs(movedY - moveY) < 1) y = "nearest";
          }
        }
        if (top2) break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  function scrollableParents(dom) {
    let doc2 = dom.ownerDocument, x, y;
    for (let cur2 = dom.parentNode; cur2; ) {
      if (cur2 == doc2.body || x && y) {
        break;
      } else if (cur2.nodeType == 1) {
        if (!y && cur2.scrollHeight > cur2.clientHeight) y = cur2;
        if (!x && cur2.scrollWidth > cur2.clientWidth) x = cur2;
        cur2 = cur2.assignedSlot || cur2.parentNode;
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
    return {
      x,
      y
    };
  }
  class DOMSelectionState {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      let { anchorNode, focusNode } = range;
      this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  }
  let preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive) return dom.setActive();
    if (preventScrollSupported) return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument) break;
    }
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = {
          preventScroll: true
        };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i2 = 0; i2 < stack.length; ) {
        let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
        if (elt.scrollTop != top2) elt.scrollTop = top2;
        if (elt.scrollLeft != left) elt.scrollLeft = left;
      }
    }
  }
  let scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name2, code2, mods) {
    let options = {
      key: name2,
      code: name2,
      keyCode: code2,
      which: code2,
      cancelable: true
    };
    if (mods) ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);
  }
  function atElementStart(doc2, selection2) {
    let node = selection2.focusNode, offset = selection2.focusOffset;
    if (!node || selection2.anchorNode != node || selection2.anchorOffset != offset) return false;
    offset = Math.min(offset, maxOffset(node));
    for (; ; ) {
      if (offset) {
        if (node.nodeType != 1) return false;
        let prev = node.childNodes[offset - 1];
        if (prev.contentEditable == "false") offset--;
        else {
          node = prev;
          offset = maxOffset(node);
        }
      } else if (node == doc2) {
        return true;
      } else {
        offset = domIndex(node);
        node = node.parentNode;
      }
    }
  }
  function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
  }
  function textNodeBefore(startNode, startOffset) {
    for (let node = startNode, offset = startOffset; ; ) {
      if (node.nodeType == 3 && offset > 0) {
        return {
          node,
          offset
        };
      } else if (node.nodeType == 1 && offset > 0) {
        if (node.contentEditable == "false") return null;
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.parentNode && !isBlockElement(node)) {
        offset = domIndex(node);
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter(startNode, startOffset) {
    for (let node = startNode, offset = startOffset; ; ) {
      if (node.nodeType == 3 && offset < node.nodeValue.length) {
        return {
          node,
          offset
        };
      } else if (node.nodeType == 1 && offset < node.childNodes.length) {
        if (node.contentEditable == "false") return null;
        node = node.childNodes[offset];
        offset = 0;
      } else if (node.parentNode && !isBlockElement(node)) {
        offset = domIndex(node) + 1;
        node = node.parentNode;
      } else {
        return null;
      }
    }
  }
  class DOMPos {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom), precise);
    }
    static after(dom, precise) {
      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
    }
  }
  const noChildren = [];
  class ContentView {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.flags = 2;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view) return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    sync(view, track) {
      if (this.flags & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.flags & 7) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);
            }
            child.sync(view, track);
            child.flags &= ~7;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom) track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom) next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent) track.written = true;
        while (next) next = rm$1(next);
      } else if (this.flags & 1) {
        for (let child of this.children) if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom) break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild) bias = -1;
            else bias = 1;
          }
          node = parent;
        }
        if (bias < 0) after = node;
        else after = node.nextSibling;
      }
      if (after == this.dom.firstChild) return 0;
      while (after && !ContentView.get(after)) after = after.nextSibling;
      if (!after) return this.length;
      for (let i2 = 0, pos = 0; ; i2++) {
        let child = this.children[i2];
        if (child.dom == after) return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos < from && end > to) return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i2;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i2;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.flags |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList) parent.flags |= 2;
        if (parent.flags & 1) return;
        parent.flags |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.flags & 7) this.markParentsDirty(true);
      }
    }
    setDOM(dom) {
      if (this.dom == dom) return;
      if (this.dom) this.dom.cmView = null;
      this.dom = dom;
      dom.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent) return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children = noChildren) {
      this.markDirty();
      for (let i2 = from; i2 < to; i2++) {
        let child = this.children[i2];
        if (child.parent == this && children.indexOf(child) < 0) child.destroy();
      }
      if (children.length < 250) this.children.splice(from, to - from, ...children);
      else this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
      for (let i2 = 0; i2 < children.length; i2++) children[i2].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name2 = this.constructor.name.replace("View", "");
      return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    get isWidget() {
      return false;
    }
    get isHidden() {
      return false;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    canReuseDOM(other) {
      return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
    }
    getSide() {
      return 0;
    }
    destroy() {
      for (let child of this.children) if (child.parent == this) child.destroy();
      this.parent = null;
    }
  }
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
  }
  class ChildCursor {
    constructor(children, pos, i2) {
      this.children = children;
      this.pos = pos;
      this.i = i2;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  }
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd)) return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last) last.breakAfter = 1;
        else breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;
    if (fromI < toI || insert2.length) parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let { i: toI, off: toOff } = cur2.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert2) dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  let nav = typeof navigator != "undefined" ? navigator : {
    userAgent: "",
    vendor: "",
    platform: ""
  };
  let doc = typeof document != "undefined" ? document : {
    documentElement: {
      style: {}
    }
  };
  const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
  const ie_upto10 = /MSIE \d/.test(nav.userAgent);
  const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  const ie = !!(ie_upto10 || ie_11up || ie_edge);
  const gecko = !ie && /gecko\/(\d+)/i.test(nav.userAgent);
  const chrome = !ie && /Chrome\/(\d+)/.exec(nav.userAgent);
  const webkit = "webkitFontSmoothing" in doc.documentElement.style;
  const safari = !ie && /Apple Computer/.test(nav.vendor);
  const ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /Mac/.test(nav.platform),
    windows: /Win/.test(nav.platform),
    linux: /Linux|X11/.test(nav.platform),
    ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [
      0,
      0
    ])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [
      0,
      0
    ])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  const MaxJoinLen = 256;
  class TextView extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
      if (!this.dom) this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom) track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom) {
      if (dom.nodeType == 3) this.createDOM(dom);
    }
    merge(from, to, source) {
      if (this.flags & 8 || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8)) return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      result.flags |= this.flags & 8;
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return {
        from: offset,
        to: offset + this.length,
        startDOM: this.dom,
        endDOM: this.dom.nextSibling
      };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  }
  class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children) ch.setParent(this);
    }
    setAttrs(dom) {
      clearAttributes(dom);
      if (this.mark.class) dom.className = this.mark.class;
      if (this.mark.attrs) for (let name2 in this.mark.attrs) dom.setAttribute(name2, this.mark.attrs[name2]);
      return dom;
    }
    canReuseDOM(other) {
      return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.flags & 4) this.setAttrs(this.dom);
      super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
      mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i2 = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from) result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from) detachFrom = i2;
        off = end;
        i2++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  }
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length) pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0) from--;
      else if (to < length) to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length) return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten2 && rect.width == 0) rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  class WidgetView extends ContentView {
    static create(widget, length, side) {
      return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        if (!this.widget.editable) this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
        if (!this.widget.compare(other.widget)) this.markDirty(true);
        if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0) return Text$1.empty;
      let top2 = this;
      while (top2.parent) top2 = top2.parent;
      let { view } = top2, text = view && view.state.doc, start = this.posAtStart;
      return text ? text.slice(start, start + this.length) : Text$1.empty;
    }
    domAtPos(pos) {
      return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom) return custom;
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length) return null;
      let fromBack = this.side ? this.side < 0 : pos > 0;
      for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
        rect = rects[i2];
        if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom) break;
      }
      return flattenRect(rect, !fromBack);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    get isHidden() {
      return this.widget.isHidden;
    }
    destroy() {
      super.destroy();
      if (this.dom) this.widget.destroy(this.dom);
    }
  }
  class WidgetBufferView extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom = document.createElement("img");
        dom.className = "cm-widgetBuffer";
        dom.setAttribute("aria-hidden", "true");
        this.setDOM(dom);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
      return Text$1.empty;
    }
    get isHidden() {
      return true;
    }
  }
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i2 = 0;
    for (let off = 0; i2 < children.length; i2++) {
      let child = children[i2], end = off + child.length;
      if (end == off && child.getSide() <= 0) continue;
      if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
      if (pos <= off) break;
      off = end;
    }
    for (let j = i2; j > 0; j--) {
      let prev = children[j - 1];
      if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);
    }
    for (let j = i2; j < children.length; j++) {
      let next = children[j];
      if (next.dom.parentNode == dom) return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view2, pos2) {
      for (let i2 = 0, off = 0; i2 < view2.children.length && off <= pos2; i2++) {
        let child = view2.children[i2], end = off + child.length;
        if (end >= pos2) {
          if (child.children.length) {
            scan(child, pos2 - off);
          } else if ((!after || after.isHidden && side > 0) && (end > pos2 || off == end && child.getSide() > 0)) {
            after = child;
            afterPos = pos2 - off;
          } else if (off < pos2 || off == end && child.getSide() < 0 && !child.isHidden) {
            before = child;
            beforePos = pos2 - off;
          }
        }
        off = end;
      }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
  }
  function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last) return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name2 in source) {
      if (name2 == "class" && target.class) target.class += " " + source.class;
      else if (name2 == "style" && target.style) target.style += ";" + source.style;
      else target[name2] = source[name2];
    }
    return target;
  }
  const noAttrs$1 = /* @__PURE__ */ Object.create(null);
  function attrsEq(a, b, ignore) {
    if (a == b) return true;
    if (!a) a = noAttrs$1;
    if (!b) b = noAttrs$1;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;
    for (let key of keysA) {
      if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;
    }
    return true;
  }
  function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev) {
      for (let name2 in prev) if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style") dom.style.cssText = "";
        else dom.removeAttribute(name2);
      }
    }
    if (attrs) {
      for (let name2 in attrs) if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style") dom.style.cssText = attrs[name2];
        else dom.setAttribute(name2, attrs[name2]);
      }
    }
    return changed;
  }
  function getAttrs(dom) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let i2 = 0; i2 < dom.attributes.length; i2++) {
      let attr = dom.attributes[i2];
      attrs[attr.name] = attr.value;
    }
    return attrs;
  }
  class WidgetType {
    eq(widget) {
      return false;
    }
    updateDOM(dom, view) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    get lineBreaks() {
      return 0;
    }
    ignoreEvent(event) {
      return true;
    }
    coordsAt(dom, pos, side) {
      return null;
    }
    get isHidden() {
      return false;
    }
    get editable() {
      return false;
    }
    destroy(dom) {
    }
  }
  var BlockType = function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  class Decoration extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
      side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start, end } = getInclusive(spec, block);
        startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  }
  Decoration.none = RangeSet.empty;
  class MarkDecoration extends Decoration {
    constructor(spec) {
      let { start, end } = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      var _a2, _b;
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a2 = this.attrs) === null || _a2 === void 0 ? void 0 : _a2.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
      if (from >= to) throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  }
  MarkDecoration.prototype.point = false;
  class LineDecoration extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from) throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  }
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from) throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  }
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null) start = spec.inclusive;
    if (end == null) end = spec.inclusive;
    return {
      start: start !== null && start !== void 0 ? start : block,
      end: end !== null && end !== void 0 ? end : block
    };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);
    else ranges.push(from, to);
  }
  class LineView extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView)) return false;
        if (!this.dom) source.transferDOM(this);
      }
      if (hasStart) this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0) return end;
      let { i: i2, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i2].split(off), 0);
        this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
        i2++;
      }
      for (let j = i2; j < this.children.length; j++) end.append(this.children[j], 0);
      while (i2 > 0 && this.children[i2 - 1].length == 0) this.children[--i2].destroy();
      this.children.length = i2;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom) return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls) this.attrs = combineAttrs({
        class: cls
      }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.flags |= 4 | 2;
      }
    }
    sync(view, track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.flags & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(view, track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;
      if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20) return null;
      let totalWidth = 0, textHeight;
      for (let child of this.children) {
        if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1) return null;
        totalWidth += rects[0].width;
        textHeight = rects[0].height;
      }
      return !totalWidth ? null : {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length,
        textHeight
      };
    }
    coordsAt(pos, side) {
      let rect = coordsInChildren(this, pos, side);
      if (!this.children.length && rect && this.parent) {
        let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
        if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
          let dist2 = (height - heightOracle.textHeight) / 2;
          return {
            top: rect.top + dist2,
            bottom: rect.bottom - dist2,
            left: rect.left,
            right: rect.left
          };
        }
      }
      return rect;
    }
    become(other) {
      return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
    }
    covers() {
      return true;
    }
    static find(docView, pos) {
      for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
        let block = docView.children[i2], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView) return block;
          if (end > pos) break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  }
  class BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
      super();
      this.widget = widget;
      this.length = length;
      this.deco = deco;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
      this.length = from + (source ? source.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.deco);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync(view) {
      if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
        if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(view));
        if (!this.widget.editable) this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text$1.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.compare(this.widget)) this.markDirty(true);
        if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.deco = other.deco;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get isEditable() {
      return false;
    }
    get isWidget() {
      return true;
    }
    coordsAt(pos, side) {
      let custom = this.widget.coordsAt(this.dom, pos, side);
      if (custom) return custom;
      if (this.widget instanceof BlockGapWidget) return null;
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    }
    destroy() {
      super.destroy();
      if (this.dom) this.widget.destroy(this.dom);
    }
    covers(side) {
      let { startSide, endSide } = this.deco;
      return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
  }
  class BlockGapWidget extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      elt.className = "cm-gap";
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get editable() {
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
    ignoreEvent() {
      return false;
    }
  }
  class ContentBuilder {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.bufferMarks = [];
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer();
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();
      else this.pendingBuffer = 0;
      if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done) throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered()) this.getLine();
            if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;
            else this.breakAtStart = 1;
            this.flushBuffer();
            this.curLine = null;
            this.atCursorPos = true;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(active.length - openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0) this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block) throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          if (deco.startSide > 0 && !this.posCovered()) this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
        } else {
          let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable) this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
          if (this.pendingBuffer) this.bufferMarks = active.slice();
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0) this.openStart = openStart;
    }
    static build(text, from, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0) builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  }
  function wrapMarks(view, active) {
    for (let mark of active) view = new MarkView(mark, [
      view
    ], view.length);
    return view;
  }
  class NullWidget extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
    get isHidden() {
      return true;
    }
  }
  NullWidget.inline = new NullWidget("span");
  NullWidget.block = new NullWidget("div");
  var Direction = function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  const LTR = Direction.LTR, RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i2 = 0; i2 < str.length; i2++) result.push(1 << +str[i2]);
    return result;
  }
  const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
  for (let p of [
    "()",
    "[]",
    "{}"
  ]) {
    let l = p.charCodeAt(0), r = p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
  }
  const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
  class BidiSpan {
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    forward(forward, dir) {
      return forward == (this.dir == dir);
    }
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i2 = 0; i2 < order.length; i2++) {
        let span = order[i2];
        if (span.from <= index && span.to >= index) {
          if (span.level == level) return i2;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i2;
        }
      }
      if (maybe < 0) throw new RangeError("Index out of range");
      return maybe;
    }
  }
  function isolatesEq(a, b) {
    if (a.length != b.length) return false;
    for (let i2 = 0; i2 < a.length; i2++) {
      let iA = a[i2], iB = b[i2];
      if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;
    }
    return true;
  }
  const types = [];
  function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      let prevType = iI ? 256 : outerType;
      for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to; i2++) {
        let type = charType(line.charCodeAt(i2));
        if (type == 512) type = prev;
        else if (type == 8 && prevStrong == 4) type = 16;
        types[i2] = type == 4 ? 2 : type;
        if (type & 7) prevStrong = type;
        prev = type;
      }
      for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to; i2++) {
        let type = types[i2];
        if (type == 128) {
          if (i2 < to - 1 && prev == types[i2 + 1] && prev & 24) type = types[i2] = prev;
          else types[i2] = 256;
        } else if (type == 64) {
          let end = i2 + 1;
          while (end < to && types[end] == 64) end++;
          let replace2 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
          for (let j = i2; j < end; j++) types[j] = replace2;
          i2 = end - 1;
        } else if (type == 8 && prevStrong == 1) {
          types[i2] = 1;
        }
        prev = type;
        if (type & 7) prevStrong = type;
      }
    }
  }
  function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 ? 2 : 1;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i2 = from, ch, br, type; i2 < to; i2++) {
        if (br = Brackets[ch = line.charCodeAt(i2)]) {
          if (br < 0) {
            for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
              if (BracketStack[sJ + 1] == -br) {
                let flags = BracketStack[sJ + 2];
                let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
                if (type2) types[i2] = types[BracketStack[sJ]] = type2;
                sI = sJ;
                break;
              }
            }
          } else if (BracketStack.length == 189) {
            break;
          } else {
            BracketStack[sI++] = i2;
            BracketStack[sI++] = ch;
            BracketStack[sI++] = context;
          }
        } else if ((type = types[i2]) == 2 || type == 1) {
          let embed = type == outerType;
          context = embed ? 0 : 1;
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            let cur2 = BracketStack[sJ + 2];
            if (cur2 & 2) break;
            if (embed) {
              BracketStack[sJ + 2] |= 2;
            } else {
              if (cur2 & 4) break;
              BracketStack[sJ + 2] |= 4;
            }
          }
        }
      }
    }
  }
  function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
      let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
      for (let i2 = from; i2 < to; ) {
        let type = types[i2];
        if (type == 256) {
          let end = i2 + 1;
          for (; ; ) {
            if (end == to) {
              if (iI == isolates.length) break;
              end = isolates[iI++].to;
              to = iI < isolates.length ? isolates[iI].from : rTo;
            } else if (types[end] == 256) {
              end++;
            } else {
              break;
            }
          }
          let beforeL = prev == 1;
          let afterL = (end < rTo ? types[end] : outerType) == 1;
          let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
          for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
            if (j == fromJ) {
              j = isolates[--jI].from;
              fromJ = jI ? isolates[jI - 1].to : rFrom;
            }
            types[--j] = replace2;
          }
          i2 = end;
        } else {
          prev = type;
          i2++;
        }
      }
    }
  }
  function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 : 1;
    if (level % 2 == baseLevel % 2) {
      for (let iCh = from, iI = 0; iCh < to; ) {
        let sameDir = true, isNum = false;
        if (iI == isolates.length || iCh < isolates[iI].from) {
          let next = types[iCh];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI < isolates.length && iScan == isolates[iI].from) {
            if (isNum) break run;
            let iso = isolates[iI];
            if (!sameDir) for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to) break run;
              if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;
              else if (types[upto] == ourType) break run;
              else break;
            }
            iI++;
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.to;
            }
            iScan = iso.to;
          } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
            break;
          } else {
            iScan++;
          }
        }
        if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
        else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));
        iCh = iScan;
      }
    } else {
      for (let iCh = to, iI = isolates.length; iCh > from; ) {
        let sameDir = true, isNum = false;
        if (!iI || iCh > isolates[iI - 1].to) {
          let next = types[iCh - 1];
          if (next != ourType) {
            sameDir = false;
            isNum = next == 16;
          }
        }
        let recurse = !sameDir && ourType == 1 ? [] : null;
        let localLevel = sameDir ? level : level + 1;
        let iScan = iCh;
        run: for (; ; ) {
          if (iI && iScan == isolates[iI - 1].to) {
            if (isNum) break run;
            let iso = isolates[--iI];
            if (!sameDir) for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from) break run;
              if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType) break run;
              else break;
            }
            if (recurse) {
              recurse.push(iso);
            } else {
              if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));
              let dirSwap = iso.direction == LTR != !(localLevel % 2);
              computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
              iCh = iso.from;
            }
            iScan = iso.from;
          } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
            break;
          } else {
            iScan--;
          }
        }
        if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
        else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));
        iCh = iScan;
      }
    }
  }
  function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = level % 2 ? 2 : 1;
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
  }
  function computeOrder(line, direction, isolates) {
    if (!line) return [
      new BidiSpan(0, 0, direction == RTL ? 1 : 0)
    ];
    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);
    if (isolates.length) while (line.length > types.length) types[types.length] = 256;
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
  }
  function trivialOrder(length) {
    return [
      new BidiSpan(0, length, 0)
    ];
  }
  let movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from;
    let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI], spanEnd = span.side(forward, dir);
    if (startIndex == spanEnd) {
      let nextI = spanI += forward ? 1 : -1;
      if (nextI < 0 || nextI >= order.length) return null;
      span = order[spanI = nextI];
      startIndex = span.side(!forward, dir);
      spanEnd = span.side(forward, dir);
    }
    let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
    if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
  }
  function autoDirection(text, from, to) {
    for (let i2 = from; i2 < to; i2++) {
      let type = charType(text.charCodeAt(i2));
      if (type == 1) return LTR;
      if (type == 2 || type == 4) return RTL;
    }
    return LTR;
  }
  const clickAddsSelectionRange = Facet.define();
  const dragMovesSelection$1 = Facet.define();
  const mouseSelectionStyle = Facet.define();
  const exceptionSink = Facet.define();
  const updateListener = Facet.define();
  const inputHandler$1 = Facet.define();
  const focusChangeEffect = Facet.define();
  const clipboardInputFilter = Facet.define();
  const clipboardOutputFilter = Facet.define();
  const perLineTextDirection = Facet.define({
    combine: (values) => values.some((x) => x)
  });
  const nativeSelectionHidden = Facet.define({
    combine: (values) => values.some((x) => x)
  });
  const scrollHandler = Facet.define();
  class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
      this.range = range;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
      this.isSnapshot = isSnapshot;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
      return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
  }
  const scrollIntoView$1 = StateEffect.define({
    map: (t2, ch) => t2.map(ch)
  });
  const setEditContextFormatting = StateEffect.define();
  function logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length) handler[0](exception);
    else if (window.onerror) window.onerror(String(exception), context, void 0, void 0, exception);
    else if (context) console.error(context + ":", exception);
    else console.error(exception);
  }
  const editable = Facet.define({
    combine: (values) => values.length ? values[0] : true
  });
  let nextPluginID = 0;
  const viewPlugin = Facet.define();
  class ViewPlugin {
    constructor(id, create, domEventHandlers, domEventObservers, buildExtensions) {
      this.id = id;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.domEventObservers = domEventObservers;
      this.extension = buildExtensions(this);
    }
    static define(create, spec) {
      const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin) => {
        let ext = [
          viewPlugin.of(plugin)
        ];
        if (deco) ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
        if (provide) ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  }
  class PluginInstance {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e) {
            logException(view.state, e, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update);
          } catch (e) {
            logException(update.state, e, "CodeMirror plugin crashed");
            if (this.value.destroy) try {
              this.value.destroy();
            } catch (_) {
            }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  }
  const editorAttributes = Facet.define();
  const contentAttributes = Facet.define();
  const decorations = Facet.define();
  const outerDecorations = Facet.define();
  const atomicRanges = Facet.define();
  const bidiIsolatedRanges = Facet.define();
  function getIsolatedRanges(view, line) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length) return isolates;
    let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
    let result = [];
    RangeSet.spans(sets, line.from, line.to, {
      point() {
      },
      span(fromDoc, toDoc, active, open) {
        let from = fromDoc - line.from, to = toDoc - line.from;
        let level = result;
        for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
          let direction = active[i2].spec.bidiIsolate, update;
          if (direction == null) direction = autoDirection(line.text, from, to);
          if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
            update.to = to;
            level = update.inner;
          } else {
            let add2 = {
              from,
              to,
              direction,
              inner: []
            };
            level.push(add2);
            level = add2.inner;
          }
        }
      }
    });
    return result;
  }
  const scrollMargins = Facet.define();
  function getScrollMargins(view) {
    let left = 0, right = 0, top2 = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
      let m = source(view);
      if (m) {
        if (m.left != null) left = Math.max(left, m.left);
        if (m.right != null) right = Math.max(right, m.right);
        if (m.top != null) top2 = Math.max(top2, m.top);
        if (m.bottom != null) bottom = Math.max(bottom, m.bottom);
      }
    }
    return {
      left,
      right,
      top: top2,
      bottom
    };
  }
  const styleModule = Facet.define();
  class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
      let i2 = set.length, me = this;
      for (; i2 > 0; i2--) {
        let range = set[i2 - 1];
        if (range.fromA > me.toA) continue;
        if (range.toA < me.fromA) break;
        me = me.join(range);
        set.splice(i2 - 1, 1);
      }
      set.splice(i2, 0, me);
      return set;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0) return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end) break;
          else rI += 2;
        }
        if (!next) return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  }
  class ViewUpdate {
    constructor(view, state, transactions) {
      this.view = view;
      this.state = state;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions) this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
    }
    static create(view, state, transactions) {
      return new ViewUpdate(view, state, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  }
  class DocView extends ContentView {
    get length() {
      return this.view.state.doc.length;
    }
    constructor(view) {
      super();
      this.view = view;
      this.decorations = [];
      this.dynamicDecorationMap = [
        false
      ];
      this.domChanged = null;
      this.hasComposition = null;
      this.markedForComposition = /* @__PURE__ */ new Set();
      this.editContextFormatting = Decoration.none;
      this.lastCompositionAfterCursor = false;
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [
        new LineView()
      ];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([
        new ChangedRange(0, 0, 0, view.state.doc.length)
      ], 0, null);
    }
    update(update) {
      var _a2;
      let changedRanges = update.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
        }
      }
      this.updateEditContextFormatting(update);
      let readCompositionAt = -1;
      if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
        if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel) readCompositionAt = this.domChanged.newSel.head;
        else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;
      }
      let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
      this.domChanged = null;
      if (this.hasComposition) {
        this.markedForComposition.clear();
        let { from, to } = this.hasComposition;
        changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
      }
      this.hasComposition = composition ? {
        from: composition.range.fromB,
        to: composition.range.toB
      } : null;
      if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (!(this.flags & 7) && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update.startState.doc.length, composition);
        if (update.transactions.length) this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength, composition) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength, composition);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? {
          node: observer.selectionRange.focusNode,
          written: false
        } : void 0;
        this.sync(this.view, track);
        this.flags &= ~7;
        if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;
        this.dom.style.height = "";
      });
      this.markedForComposition.forEach((cView) => cView.flags &= ~8);
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children) if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
      let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
      let cursor2 = this.childCursor(oldLength);
      for (let i2 = ranges.length - 1; ; i2--) {
        let next = i2 >= 0 ? ranges[i2] : null;
        if (!next) break;
        let { fromA, toA, fromB, toB } = next, content2, breakAtStart, openStart, openEnd;
        if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
          let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
          let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
          breakAtStart = before.breakAtStart;
          openStart = before.openStart;
          openEnd = after.openEnd;
          let compLine = this.compositionView(composition);
          if (after.breakAtStart) {
            compLine.breakAfter = 1;
          } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
            compLine.breakAfter = after.content[0].breakAfter;
            after.content.shift();
          }
          if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
            before.content.pop();
          }
          content2 = before.content.concat(compLine).concat(after.content);
        } else {
          ({ content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
        }
        let { i: toI, off: toOff } = cursor2.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor2.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
      if (composition) this.fixCompositionDOM(composition);
    }
    updateEditContextFormatting(update) {
      this.editContextFormatting = this.editContextFormatting.map(update.changes);
      for (let tr of update.transactions) for (let effect of tr.effects) if (effect.is(setEditContextFormatting)) {
        this.editContextFormatting = effect.value;
      }
    }
    compositionView(composition) {
      let cur2 = new TextView(composition.text.nodeValue);
      cur2.flags |= 8;
      for (let { deco } of composition.marks) cur2 = new MarkView(deco, [
        cur2
      ], cur2.length);
      let line = new LineView();
      line.append(cur2, 0);
      return line;
    }
    fixCompositionDOM(composition) {
      let fix = (dom, cView2) => {
        cView2.flags |= 8 | (cView2.children.some((c) => c.flags & 7) ? 1 : 0);
        this.markedForComposition.add(cView2);
        let prev = ContentView.get(dom);
        if (prev && prev != cView2) prev.dom = null;
        cView2.setDOM(dom);
      };
      let pos = this.childPos(composition.range.fromB, 1);
      let cView = this.children[pos.i];
      fix(composition.line, cView);
      for (let i2 = composition.marks.length - 1; i2 >= -1; i2--) {
        pos = cView.childPos(pos.off, 1);
        cView = cView.children[pos.i];
        fix(i2 >= 0 ? composition.marks[i2].node : composition.text, cView);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();
      let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
      let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
      if (!(focused || fromPointer || selectionNotFocus)) return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.moveToLine(this.domAtPos(main.anchor));
      let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
      if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({
              preventScroll: true
            });
          }
          let rawSel = getSelection(this.view.root);
          if (!rawSel) ;
          else if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
                if (text) anchor = new DOMPos(text.node, text.offset);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0) rawSel.caretBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            try {
              rawSel.extend(head.node, head.offset);
            } catch (_) {
            }
          } else {
            let range = document.createRange();
            if (main.anchor > main.head) [anchor, head] = [
              head,
              anchor
            ];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
          if (selectionNotFocus && this.view.root.activeElement == this.dom) {
            this.dom.blur();
            if (activeElt) activeElt.focus();
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    suppressWidgetCursorChange(sel, cursor2) {
      return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
    }
    enforceCursorAssoc() {
      if (this.hasComposition) return;
      let { view } = this, cursor2 = view.state.selection.main;
      let sel = getSelection(view.root);
      let { anchorNode, anchorOffset } = view.observer.selectionRange;
      if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify) return;
      let line = LineView.find(this, cursor2.head);
      if (!line) return;
      let lineStart = line.posAtStart;
      if (cursor2.head == lineStart || cursor2.head == lineStart + line.length) return;
      let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
      if (!before || !after || before.bottom > after.top) return;
      let dom = this.domAtPos(cursor2.head + cursor2.assoc);
      sel.collapse(dom.node, dom.offset);
      sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
      view.observer.readSelectionRange();
      let newRange = view.observer.selectionRange;
      if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from) sel.collapse(anchorNode, anchorOffset);
    }
    moveToLine(pos) {
      let dom = this.dom, newPos;
      if (pos.node != dom) return pos;
      for (let i2 = pos.offset; !newPos && i2 < dom.childNodes.length; i2++) {
        let view = ContentView.get(dom.childNodes[i2]);
        if (view instanceof LineView) newPos = view.domAtPos(0);
      }
      for (let i2 = pos.offset - 1; !newPos && i2 >= 0; i2--) {
        let view = ContentView.get(dom.childNodes[i2]);
        if (view instanceof LineView) newPos = view.domAtPos(view.length);
      }
      return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
      for (let cur2 = dom; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this) return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i: i2, off } = this.childCursor().findPos(pos, -1);
      for (; i2 < this.children.length - 1; ) {
        let child = this.children[i2];
        if (off < child.length || child instanceof LineView) break;
        i2++;
        off = 0;
      }
      return this.children[i2].domAtPos(off);
    }
    coordsAt(pos, side) {
      let best = null, bestPos = 0;
      for (let off = this.length, i2 = this.children.length - 1; i2 >= 0; i2--) {
        let child = this.children[i2], end = off - child.breakAfter, start = end - child.length;
        if (end < pos) break;
        if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
          best = child;
          bestPos = start;
        } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
          if (child.deco.startSide < 0) break;
          else if (i2) best = null;
        }
        off = start;
      }
      return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
      let { i: i2, off } = this.childPos(pos, 1), child = this.children[i2];
      if (!(child instanceof LineView)) return null;
      while (child.children.length) {
        let { i: i3, off: childOff } = child.childPos(off, 1);
        for (; ; i3++) {
          if (i3 == child.children.length) return null;
          if ((child = child.children[i3]).length) break;
        }
        off = childOff;
      }
      if (!(child instanceof TextView)) return null;
      let end = findClusterBreak(child.text, off);
      if (end == off) return null;
      let rects = textRange(child.dom, off, end).getClientRects();
      for (let i3 = 0; i3 < rects.length; i3++) {
        let rect = rects[i3];
        if (i3 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;
      }
      return null;
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (end > to) break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i: i2 } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure) return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
      dummy.className = "cm-line";
      dummy.style.width = "99999px";
      dummy.style.position = "absolute";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        textHeight = rect ? rect.height : lineHeight;
        dummy.remove();
      });
      return {
        lineHeight,
        charWidth,
        textHeight
      };
    }
    childCursor(pos = this.length) {
      let i2 = this.children.length;
      if (i2) pos -= this.children[--i2].length;
      return new ChildCursor(this.children, pos, i2);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i2 = 0; ; i2++) {
        let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next) break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let i2 = 1;
      let allDeco = this.view.state.facet(decorations).map((d) => {
        let dynamic = this.dynamicDecorationMap[i2++] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i3) => {
        let dynamic = typeof d == "function";
        if (dynamic) dynamicOuter = true;
        return dynamic ? d(this.view) : d;
      });
      if (outerDeco.length) {
        this.dynamicDecorationMap[i2++] = dynamicOuter;
        allDeco.push(RangeSet.join(outerDeco));
      }
      this.decorations = [
        this.editContextFormatting,
        ...allDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
      while (i2 < this.decorations.length) this.dynamicDecorationMap[i2++] = false;
      return this.decorations;
    }
    scrollIntoView(target) {
      if (target.isSnapshot) {
        let ref = this.view.viewState.lineBlockAt(target.range.head);
        this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
        this.view.scrollDOM.scrollLeft = target.xMargin;
        return;
      }
      for (let handler of this.view.state.facet(scrollHandler)) {
        try {
          if (handler(this.view, target.range, target)) return true;
        } catch (e) {
          logException(this.view.state, e, "scroll handler");
        }
      }
      let { range } = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect) return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
      let margins = getScrollMargins(this.view);
      let targetRect = {
        left: rect.left - margins.left,
        top: rect.top - margins.top,
        right: rect.right + margins.right,
        bottom: rect.bottom + margins.bottom
      };
      let { offsetWidth, offsetHeight } = this.view.scrollDOM;
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
  }
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    if (!sel.focusNode) return null;
    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
    let textNode = textBefore || textAfter;
    if (textAfter && textBefore && textAfter.node != textBefore.node) {
      let descAfter = ContentView.get(textAfter.node);
      if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
        textNode = textAfter;
      } else if (view.docView.lastCompositionAfterCursor) {
        let descBefore = ContentView.get(textBefore.node);
        if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue)) textNode = textAfter;
      }
    }
    view.docView.lastCompositionAfterCursor = textNode != textBefore;
    if (!textNode) return null;
    let from = headPos - textNode.offset;
    return {
      from,
      to: from + textNode.node.nodeValue.length,
      node: textNode.node
    };
  }
  function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found) return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    if (/[\n\r]/.test(text)) return null;
    if (view.state.doc.sliceString(found.from, found.to) != text) return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks = [];
    for (let parent = textNode.parentNode; ; parent = parent.parentNode) {
      let parentView = ContentView.get(parent);
      if (parentView instanceof MarkView) marks.push({
        node: parent,
        deco: parentView.mark
      });
      else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM) return {
        range,
        text: textNode,
        marks,
        line: parent
      };
      else if (parent != view.contentDOM) marks.push({
        node: parent,
        deco: new MarkDecoration({
          inclusive: true,
          attributes: getAttrs(parent),
          tagName: parent.tagName.toLowerCase()
        })
      });
      else return null;
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1) return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  let DecorationComparator$1 = class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function touchesComposition(changes, composition) {
    let touched = false;
    if (composition) changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from) touched = true;
    });
    return touched;
  }
  function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0) return EditorSelection.cursor(pos);
    if (linePos == 0) bias = 1;
    else if (linePos == line.length) bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0) from = findClusterBreak(line.text, linePos, false);
    else to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat) break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat) break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? {
      top: top2,
      left: rect.left,
      right: rect.right,
      bottom: rect.bottom
    } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? {
      top: rect.top,
      left: rect.left,
      right: rect.right,
      bottom
    } : rect;
  }
  function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y, rect);
        if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
          let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
          closestOverlap = !side || (side > 0 ? i2 < rects.length - 1 : i2 > 0);
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest) return {
      node: parent,
      offset: 0
    };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false") return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return {
      node: parent,
      offset
    };
  }
  function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i2 = 0; i2 < len; i2++) {
      let rects = textRange(node, i2, i2 + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom) continue;
        if (!generalSide) generalSide = x - rect.left;
        let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i2).getBoundingClientRect();
            if (rectBefore.left == rect.right) after = !right;
          }
          if (dy <= 0) return {
            node,
            offset: i2 + (after ? 1 : 0)
          };
          closestOffset = i2 + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return {
      node,
      offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
    };
  }
  function posAtCoords(view, coords, precise, bias = -1) {
    var _a2, _b;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y } = coords, yOffset = y - docTop;
    if (yOffset < 0) return 0;
    if (yOffset > docHeight) return view.state.doc.length;
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text) break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight) break;
        if (bounced) return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element)) element = null;
    if (!element) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element = root.elementFromPoint(x, y);
      if (element && !view.contentDOM.contains(element)) element = null;
    }
    let node, offset = -1;
    if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos) ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x, y);
        if (range) {
          ({ startContainer: node, startOffset: offset } = range);
          if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = void 0;
        }
      }
      if (node) offset = Math.min(maxOffset(node), offset);
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest) return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
      let rect = nearest.dom.getBoundingClientRect();
      return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
    } else {
      return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let textHeight = view.viewState.heightOracle.textHeight;
      let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;
    for (let next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != "BR") return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0) return false;
    for (let cur2 = node; ; ) {
      let parent = cur2.parentNode;
      if (!parent || parent.nodeType != 1 || parent.firstChild != cur2) return false;
      if (parent.classList.contains("cm-line")) break;
      cur2 = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type)) for (let l of line.type) {
      if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;
    }
    return line;
  }
  function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null) return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
  }
  function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur2 = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1)) return cur2;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = view.visualLineSide(line, !forward);
      }
      if (!check) {
        if (!by) return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space) cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0)) return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null) goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist2 + extra) * dir;
      let pos = posAtCoords(view, {
        x: resolvedGoal,
        y: curY
      }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
        let charRect = view.docView.coordsForChar(pos);
        let assoc = !charRect || curY < charRect.top ? -1 : 1;
        return EditorSelection.cursor(pos, assoc, void 0, goal);
      }
    }
  }
  function skipAtomicRanges(atoms, pos, bias) {
    for (; ; ) {
      let moved = 0;
      for (let set of atoms) {
        set.between(pos - 1, pos + 1, (from, to, value) => {
          if (pos > from && pos < to) {
            let side = moved || bias || (pos - from < to - pos ? -1 : 1);
            pos = side < 0 ? from : to;
            moved = side;
          }
        });
      }
      if (!moved) return pos;
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f) => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
  }
  const LineBreakPlaceholder = "\uFFFF";
  class DOMReader {
    constructor(points, state) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start) return this;
      let parent = start.parentNode;
      for (let cur2 = start; ; ) {
        this.findPointBefore(parent, cur2);
        let oldLen = this.text.length;
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end) break;
        let view = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore) && this.text.length > oldLen) this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points) if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m = re.exec(text)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0) break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points) if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore) return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i2 = fromView.iter(); !i2.next().done; ) {
          if (i2.lineBreak) this.lineBreak();
          else this.append(i2.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling) this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points) if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
    }
    findPointInside(node, length) {
      for (let point of this.points) if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
  }
  function isAtEnd(parent, node, offset) {
    for (; ; ) {
      if (!node || offset < maxOffset(node)) return false;
      if (node == parent) return true;
      offset = domIndex(node) + 1;
      node = node.parentNode;
    }
  }
  class DOMPoint {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  }
  class DOMChange {
    constructor(view, start, end, typeOver) {
      this.typeOver = typeOver;
      this.bounds = null;
      this.text = "";
      this.domChanged = start > -1;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      if (view.state.readOnly && start > -1) {
        this.newSel = null;
      } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
        let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
        let reader = new DOMReader(selPoints, view.state);
        reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
        this.text = reader.text;
        this.newSel = selectionFromPoints(selPoints, this.bounds.from);
      } else {
        let domSel = view.observer.selectionRange;
        let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
        let vp = view.viewport;
        if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
          let from = Math.min(head, anchor), to = Math.max(head, anchor);
          let offFrom = vp.from - from, offTo = vp.to - to;
          if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
            head = 0;
            anchor = view.state.doc.length;
          }
        }
        this.newSel = EditorSelection.single(anchor, head);
      }
    }
  }
  function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
      let { from, to } = domChange.bounds;
      let preferredPos = sel.from, preferredSide = null;
      if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text$1.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
      newSel = null;
    }
    if (!change && !newSel) return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, sel.to)
      };
    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
      if (newSel && change.insert.length == 2) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {
        from: sel.from,
        to: sel.to,
        insert: Text$1.of([
          " "
        ])
      };
    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
      if (newSel) newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
      change = {
        from: sel.from,
        to: sel.to,
        insert: Text$1.of([
          " "
        ])
      };
    }
    if (change) {
      return applyDOMChangeInner(view, change, newSel, lastKey);
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView2 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select") scrollIntoView2 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({
        selection: newSel,
        scrollIntoView: scrollIntoView2,
        userEvent
      });
      return true;
    } else {
      return false;
    }
  }
  function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
    if (browser.ios && view.inputState.flushIOSKey(change)) return true;
    let sel = view.state.selection.main;
    if (browser.android && (change.to == sel.to && (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46))) return true;
    let text = change.insert.toString();
    if (view.inputState.composing >= 0) view.inputState.composing++;
    let defaultTr;
    let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
    if (!view.state.facet(inputHandler$1).some((h) => h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());
    return true;
  }
  function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change.from, change.to);
        let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
        if (composition) {
          let dLen = change.insert.length - (change.to - change.from);
          compositionRange = {
            from: composition.from,
            to: composition.to - dLen
          };
        } else {
          compositionRange = view.state.doc.lineAt(sel.head);
        }
        let offset = sel.to - change.to, size = sel.to - sel.from;
        tr = startState.changeByRange((range) => {
          if (range.from == sel.from && range.to == sel.to) return {
            changes,
            range: mainSel || range.map(changes)
          };
          let to = range.to - offset, from = to - replaced.length;
          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || range.to >= compositionRange.from && range.from <= compositionRange.to) return {
            range
          };
          let rangeChanges = startState.changes({
            from,
            to,
            insert: change.insert
          }), selOff = range.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
      view.inputState.compositionPendingChange = false;
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    return startState.update(tr, {
      userEvent,
      scrollIntoView: true
    });
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;
    if (from == minLen && a.length == b.length) return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return {
      from,
      toA,
      toB
    };
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM) return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0) return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  class InputState {
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    constructor(view) {
      this.view = view;
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.lastTouchTime = 0;
      this.lastFocusTime = 0;
      this.lastScrollTop = 0;
      this.lastScrollLeft = 0;
      this.pendingIOSKey = void 0;
      this.tabFocusMode = -1;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.compositionPendingKey = false;
      this.compositionPendingChange = false;
      this.mouseSelection = null;
      this.draggedContent = null;
      this.handleEvent = this.handleEvent.bind(this);
      this.notifiedFocused = view.hasFocus;
      if (browser.safari) view.contentDOM.addEventListener("input", () => null);
      if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
      if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;
      if (event.type == "keydown" && this.keydown(event)) return;
      this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
      let handlers2 = this.handlers[type];
      if (handlers2) {
        for (let observer of handlers2.observers) observer(this.view, event);
        for (let handler of handlers2.handlers) {
          if (event.defaultPrevented) break;
          if (handler(this.view, event)) {
            event.preventDefault();
            break;
          }
        }
      }
    }
    ensureHandlers(plugins) {
      let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
      for (let type in handlers2) if (type != "scroll") {
        let passive = !handlers2[type].handlers.length;
        let exists = prev[type];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type, this.handleEvent);
          exists = null;
        }
        if (!exists) dom.addEventListener(type, this.handleEvent, {
          passive
        });
      }
      for (let type in prev) if (type != "scroll" && !handlers2[type]) dom.removeEventListener(type, this.handleEvent);
      this.handlers = handlers2;
    }
    keydown(event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return true;
      if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.tabFocusMode = -1;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        this.view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
        this.pendingIOSKey = pending || event;
        setTimeout(() => this.flushIOSKey(), 250);
        return true;
      }
      if (event.keyCode != 229) this.view.observer.forceFlush();
      return false;
    }
    flushIOSKey(change) {
      let key = this.pendingIOSKey;
      if (!key) return false;
      if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString())) return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type)) return false;
      if (this.composing > 0) return true;
      if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
        this.compositionPendingKey = false;
        return true;
      }
      return false;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection) this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update) {
      this.view.observer.update(update);
      if (this.mouseSelection) this.mouseSelection.update(update);
      if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);
      if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection) this.mouseSelection.destroy();
    }
  }
  function bindHandler(plugin, handler) {
    return (view, event) => {
      try {
        return handler.call(plugin, event, view);
      } catch (e) {
        logException(view.state, e);
      }
    };
  }
  function computeHandlers(plugins) {
    let result = /* @__PURE__ */ Object.create(null);
    function record(type) {
      return result[type] || (result[type] = {
        observers: [],
        handlers: []
      });
    }
    for (let plugin of plugins) {
      let spec = plugin.spec;
      if (spec && spec.domEventHandlers) for (let type in spec.domEventHandlers) {
        let f = spec.domEventHandlers[type];
        if (f) record(type).handlers.push(bindHandler(plugin.value, f));
      }
      if (spec && spec.domEventObservers) for (let type in spec.domEventObservers) {
        let f = spec.domEventObservers[type];
        if (f) record(type).observers.push(bindHandler(plugin.value, f));
      }
    }
    for (let type in handlers) record(type).handlers.push(handlers[type]);
    for (let type in observers) record(type).observers.push(observers[type]);
    return result;
  }
  const PendingKeys = [
    {
      key: "Backspace",
      keyCode: 8,
      inputType: "deleteContentBackward"
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertParagraph"
    },
    {
      key: "Enter",
      keyCode: 13,
      inputType: "insertLineBreak"
    },
    {
      key: "Delete",
      keyCode: 46,
      inputType: "deleteContentForward"
    }
  ];
  const EmacsyPendingKeys = "dthko";
  const modifierCodes = [
    16,
    17,
    18,
    20,
    91,
    92,
    224,
    225
  ];
  const dragScrollMargin = 6;
  function dragScrollSpeed(dist2) {
    return Math.max(0, dist2) * 0.7 + 8;
  }
  function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
  }
  class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.startEvent = startEvent;
      this.style = style;
      this.mustSelect = mustSelect;
      this.scrollSpeed = {
        x: 0,
        y: 0
      };
      this.scrolling = -1;
      this.lastEvent = startEvent;
      this.scrollParents = scrollableParents(view.contentDOM);
      this.atoms = view.state.facet(atomicRanges).map((f) => f(view));
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
      if (this.dragging === false) this.select(event);
    }
    move(event) {
      if (event.buttons == 0) return this.destroy();
      if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;
      this.select(this.lastEvent = event);
      let sx = 0, sy = 0;
      let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
      if (this.scrollParents.x) ({ left, right } = this.scrollParents.x.getBoundingClientRect());
      if (this.scrollParents.y) ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
      let margins = getScrollMargins(this.view);
      if (event.clientX - margins.left <= left + dragScrollMargin) sx = -dragScrollSpeed(left - event.clientX);
      else if (event.clientX + margins.right >= right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - right);
      if (event.clientY - margins.top <= top2 + dragScrollMargin) sy = -dragScrollSpeed(top2 - event.clientY);
      else if (event.clientY + margins.bottom >= bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - bottom);
      this.setScrollSpeed(sx, sy);
    }
    up(event) {
      if (this.dragging == null) this.select(this.lastEvent);
      if (!this.dragging) event.preventDefault();
      this.destroy();
    }
    destroy() {
      this.setScrollSpeed(0, 0);
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
      this.scrollSpeed = {
        x: sx,
        y: sy
      };
      if (sx || sy) {
        if (this.scrolling < 0) this.scrolling = setInterval(() => this.scroll(), 50);
      } else if (this.scrolling > -1) {
        clearInterval(this.scrolling);
        this.scrolling = -1;
      }
    }
    scroll() {
      let { x, y } = this.scrollSpeed;
      if (x && this.scrollParents.x) {
        this.scrollParents.x.scrollLeft += x;
        x = 0;
      }
      if (y && this.scrollParents.y) {
        this.scrollParents.y.scrollTop += y;
        y = 0;
      }
      if (x || y) this.view.win.scrollBy(x, y);
      if (this.dragging === false) this.select(this.lastEvent);
    }
    skipAtoms(sel) {
      let ranges = null;
      for (let i2 = 0; i2 < sel.ranges.length; i2++) {
        let range = sel.ranges[i2], updated = null;
        if (range.empty) {
          let pos = skipAtomicRanges(this.atoms, range.from, 0);
          if (pos != range.from) updated = EditorSelection.cursor(pos, -1);
        } else {
          let from = skipAtomicRanges(this.atoms, range.from, -1);
          let to = skipAtomicRanges(this.atoms, range.to, 1);
          if (from != range.from || to != range.to) updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
        }
        if (updated) {
          if (!ranges) ranges = sel.ranges.slice();
          ranges[i2] = updated;
        }
      }
      return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
      let { view } = this, selection2 = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
      if (this.mustSelect || !selection2.eq(view.state.selection, this.dragging === false)) this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer"
      });
      this.mustSelect = false;
    }
    update(update) {
      if (update.transactions.some((tr) => tr.isUserEvent("input.type"))) this.destroy();
      else if (this.style.update(update)) setTimeout(() => this.select(this.lastEvent), 20);
    }
  }
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty) return false;
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0) return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles) return true;
    if (event.defaultPrevented) return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;
    return true;
  }
  const handlers = /* @__PURE__ */ Object.create(null);
  const observers = /* @__PURE__ */ Object.create(null);
  const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent) return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function textFilter(state, facet, text) {
    for (let filter of state.facet(facet)) text = filter(text, state);
    return text;
  }
  function doPaste(view, input) {
    input = textFilter(view.state, clipboardInputFilter, input);
    let { state } = view, changes, i2 = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state.changeByRange((range) => {
        let line = state.doc.lineAt(range.from);
        if (line.from == lastLine) return {
          range
        };
        lastLine = line.from;
        let insert2 = state.toText((byLine ? text.line(i2++).text : input) + state.lineBreak);
        return {
          changes: {
            from: line.from,
            insert: insert2
          },
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state.changeByRange((range) => {
        let line = text.line(i2++);
        return {
          changes: {
            from: range.from,
            to: range.to,
            insert: line.text
          },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  observers.scroll = (view) => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
  };
  handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0) view.inputState.tabFocusMode = Date.now() + 2e3;
    return false;
  };
  observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  observers.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2e3) return false;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event);
      if (style) break;
    }
    if (!style && event.button == 0) style = basicMouseSelection(view, event);
    if (style) {
      let mustFocus = !view.hasFocus;
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
      if (mustFocus) view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM)) active.blur();
      });
      let mouseSel = view.inputState.mouseSelection;
      if (mouseSel) {
        mouseSel.start(event);
        return mouseSel.dragging === false;
      }
    }
    return false;
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to) to++;
      return EditorSelection.range(from, to);
    }
  }
  let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line) return 1;
    let off = pos - line.posAtStart;
    if (off == 0) return 1;
    if (off == line.length) return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before)) return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after)) return 1;
    return before && before.bottom >= y ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    }, false);
    return {
      pos,
      bias: findPositionSide(view, pos, event.clientX, event.clientY)
    };
  }
  const BadMouseDetail = browser.ie && browser.ie_version <= 11;
  let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail) return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    return {
      update(update) {
        if (update.docChanged) {
          start.pos = update.changes.mapPos(start.pos);
          startSel = startSel.map(update.changes);
        }
      },
      get(event2, extend2, multiple) {
        let cur2 = queryPos(view, event2), removed;
        let range = rangeForClick(view, cur2.pos, cur2.bias, type);
        if (start.pos != cur2.pos && !extend2) {
          let startRange = rangeForClick(view, start.pos, start.bias, type);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend2) return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos))) return removed;
        else if (multiple) return startSel.addRange(range);
        else return EditorSelection.create([
          range
        ]);
      }
    };
  }
  function removeRangeAround(sel, pos) {
    for (let i2 = 0; i2 < sel.ranges.length; i2++) {
      let { from, to } = sel.ranges[i2];
      if (from <= pos && to >= pos) return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
    }
    return null;
  }
  handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
      let cView = view.docView.nearest(event.target);
      if (cView && cView.isWidget) {
        let from = cView.posAtStart, to = from + cView.length;
        if (from >= range.to || to <= range.from) range = EditorSelection.range(from, to);
      }
    }
    let { inputState } = view;
    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
      event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
  };
  handlers.dragend = (view) => {
    view.inputState.draggedContent = null;
    return false;
  };
  function dropText(view, event, text, direct) {
    text = textFilter(view.state, clipboardInputFilter, text);
    if (!text) return;
    let dropPos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event) ? {
      from: draggedContent.from,
      to: draggedContent.to
    } : null;
    let ins = {
      from: dropPos,
      insert: text
    };
    let changes = view.state.changes(del ? [
      del,
      ins
    ] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: {
        anchor: changes.mapPos(dropPos, -1),
        head: changes.mapPos(dropPos, 1)
      },
      userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
  }
  handlers.drop = (view, event) => {
    if (!event.dataTransfer) return false;
    if (view.state.readOnly) return true;
    let files = event.dataTransfer.files;
    if (files && files.length) {
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length) dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i2 = 0; i2 < files.length; i2++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text[i2] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i2]);
      }
      return true;
    } else {
      let text = event.dataTransfer.getData("Text");
      if (text) {
        dropText(view, event, text, true);
        return true;
      }
    }
    return false;
  };
  handlers.paste = (view, event) => {
    if (view.state.readOnly) return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
      return true;
    } else {
      capturePaste(view);
      return false;
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent) return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges) if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state.selection.ranges) {
        let line = state.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({
            from: line.from,
            to: Math.min(state.doc.length, line.to + 1)
          });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return {
      text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)),
      ranges,
      linewise
    };
  }
  let lastLinewiseCopy = null;
  handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise) return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly) view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      data.clearData();
      data.setData("text/plain", text);
      return true;
    } else {
      captureCopy(view, text);
      return false;
    }
  };
  const isFocusChange = Annotation.define();
  function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
      let effect = getEffect(state, focus);
      if (effect) effects.push(effect);
    }
    return effects ? state.update({
      effects,
      annotations: isFocusChange.of(true)
    }) : null;
  }
  function updateForFocusChange(view) {
    setTimeout(() => {
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        let tr = focusChangeTransaction(view.state, focus);
        if (tr) view.dispatch(tr);
        else view.update([]);
      }
    }, 10);
  }
  observers.focus = (view) => {
    view.inputState.lastFocusTime = Date.now();
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
      view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
      view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
  };
  observers.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  observers.compositionstart = observers.compositionupdate = (view) => {
    if (view.observer.editContext) return;
    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
    }
  };
  observers.compositionend = (view) => {
    if (view.observer.editContext) return;
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
      view.observer.flushSoon();
    } else if (view.inputState.compositionPendingChange) {
      Promise.resolve().then(() => view.observer.flush());
    } else {
      setTimeout(() => {
        if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);
      }, 50);
    }
  };
  observers.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers.beforeinput = (view, event) => {
    var _a2, _b;
    if (event.inputType == "insertReplacementText" && view.observer.editContext) {
      let text = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
      if (text && ranges.length) {
        let r = ranges[0];
        let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);
        applyDOMChangeInner(view, {
          from,
          to,
          insert: view.state.toText(text)
        }, null);
        return true;
      }
    }
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
    if (browser.ios && event.inputType == "deleteContentForward") {
      view.observer.flushSoon();
    }
    if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
      setTimeout(() => observers.compositionend(view, event), 20);
    }
    return false;
  };
  const appliedFirefoxHack = /* @__PURE__ */ new Set();
  function firefoxCopyCutHack(doc2) {
    if (!appliedFirefoxHack.has(doc2)) {
      appliedFirefoxHack.add(doc2);
      doc2.addEventListener("copy", () => {
      });
      doc2.addEventListener("cut", () => {
      });
    }
  }
  const wrappingWhiteSpace = [
    "pre-wrap",
    "normal",
    "pre-line",
    "break-spaces"
  ];
  let heightChangeFlag = false;
  function clearHeightChangeFlag() {
    heightChangeFlag = false;
  }
  class HeightOracle {
    constructor(lineWrapping) {
      this.lineWrapping = lineWrapping;
      this.doc = Text$1.empty;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.textHeight = 14;
      this.lineLength = 30;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping) return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i2 = 0; i2 < lineHeights.length; i2++) {
        let h = lineHeights[i2];
        if (h < 0) {
          i2++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.textHeight = textHeight;
      this.lineLength = lineLength;
      if (changed) {
        this.heightSamples = {};
        for (let i2 = 0; i2 < knownHeights.length; i2++) {
          let h = knownHeights[i2];
          if (h < 0) i2++;
          else this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed;
    }
  }
  class MeasuredHeights {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  }
  class BlockInfo {
    constructor(from, length, top2, height, _content) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this._content = _content;
    }
    get type() {
      return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    get widget() {
      return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    get widgetLineBreaks() {
      return typeof this._content == "number" ? this._content : 0;
    }
    join(other) {
      let content2 = (Array.isArray(this._content) ? this._content : [
        this
      ]).concat(Array.isArray(other._content) ? other._content : [
        other
      ]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
    }
  }
  var QueryType$1 = function(QueryType2) {
    QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
    QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
    QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType2;
  }(QueryType$1 || (QueryType$1 = {}));
  const Epsilon = 1e-3;
  class HeightMap {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this, doc2 = oracle.doc;
      for (let i2 = changes.length - 1; i2 >= 0; i2--) {
        let { fromA, toA, fromB, toB } = changes[i2];
        let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
          fromA = changes[i2 - 1].fromA;
          fromB = changes[i2 - 1].fromB;
          i2--;
          if (fromA < start.from) start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
        me = replace(me, me.replace(fromA, toA, nodes));
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1) return nodes[0];
      let i2 = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i2 == j) {
          if (before > after * 2) {
            let split = nodes[i2 - 1];
            if (split.break) nodes.splice(--i2, 1, split.left, null, split.right);
            else nodes.splice(--i2, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break) nodes.splice(j, 1, split.left, null, split.right);
            else nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i2++];
          if (next) before += next.size;
        } else {
          let next = nodes[--j];
          if (next) after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i2 - 1] == null) {
        brk = 1;
        i2--;
      } else if (nodes[i2] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i2)), brk, HeightMap.of(nodes.slice(j)));
    }
  }
  function replace(old, val) {
    if (old == val) return old;
    if (old.constructor != val.constructor) heightChangeFlag = true;
    return val;
  }
  HeightMap.prototype.size = 1;
  class HeightMapBlock extends HeightMap {
    constructor(length, height, deco) {
      super(length, height);
      this.deco = deco;
    }
    blockAt(_height, _oracle, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top2, offset) {
      return this.blockAt(0, oracle, top2, offset);
    }
    forEachLine(from, to, oracle, top2, offset, f) {
      if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  }
  class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, null);
      this.collapsed = 0;
      this.widgetHeight = 0;
      this.breaks = 0;
    }
    blockAt(_height, _oracle, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);
        else node.height = this.height;
        if (!this.outdated) node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);
      else if (force || this.outdated) this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  }
  class HeightMapGap extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    heightMetrics(oracle, offset) {
      let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
      let lines = lastLine - firstLine + 1;
      let perLine, perChar = 0;
      if (oracle.lineWrapping) {
        let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
        perLine = totalPerLine / lines;
        if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);
      } else {
        perLine = this.height / lines;
      }
      return {
        firstLine,
        lastLine,
        perLine,
        perChar
      };
    }
    blockAt(height, oracle, top2, offset) {
      let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      if (oracle.lineWrapping) {
        let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
        let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
        let lineTop = Math.max(top2, height - lineHeight / 2);
        return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
      } else {
        let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
        let { from, length } = oracle.doc.line(firstLine + line);
        return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
      }
    }
    lineAt(value, type, oracle, top2, offset) {
      if (type == QueryType$1.ByHeight) return this.blockAt(value, oracle, top2, offset);
      if (type == QueryType$1.ByPosNoHeight) {
        let { from, to } = oracle.doc.lineAt(value);
        return new BlockInfo(from, to - from, 0, 0, 0);
      }
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
      let linesAbove = line.number - firstLine;
      let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
      return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top2, offset, f) {
      from = Math.max(from, offset);
      to = Math.min(to, offset + this.length);
      let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
      for (let pos = from, lineTop = top2; pos <= to; ) {
        let line = oracle.doc.lineAt(pos);
        if (pos == from) {
          let linesAbove = line.number - firstLine;
          lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
        }
        let lineHeight = perLine + perChar * line.length;
        f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
        lineTop += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);
        else nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length) nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1) singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) heightChangeFlag = true;
        return replace(this, result);
      } else if (force || this.outdated) {
        this.setHeight(oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  }
  class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, oracle, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType$1.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, oracle, top2, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset)) return base2;
      let subQuery = type == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
      if (left) return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
      else return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
    }
    forEachLine(from, to, oracle, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset) this.left.forEachLine(from, to, oracle, top2, offset, f);
        if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType$1.ByPos, oracle, top2, offset);
        if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f);
        if (mid.to >= from && mid.from <= to) f(mid);
        if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0) this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes) result.push(node);
      if (from > 0) mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left) return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left) result.push(null);
      }
      if (to > left) this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right) return this.right.decomposeRight(from - right, result);
      if (from < left) this.left.decomposeRight(from, result);
      if (this.break && from < right) result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [
        left,
        null,
        right
      ] : [
        left,
        right
      ]);
      this.left = replace(this.left, left);
      this.right = replace(this.right, right);
      this.setHeight(left.height + right.height);
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else right.updateHeight(oracle, rightStart, force);
      if (rebalance) return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  }
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  const relevantWidgetHeight = 5;
  class NodeBuilder {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText) last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        let breaks = deco.widget ? deco.widget.lineBreaks : 0;
        if (height < 0) height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco));
        } else if (len || breaks || height >= relevantWidgetHeight) {
          this.addLineDeco(height, breaks, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1) return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText) return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      let deco = block.deco;
      if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (deco && deco.endSide > 0) this.covering = block;
    }
    addLineDeco(height, breaks, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      line.breaks += breaks;
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  }
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  class DecorationComparator {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);
    }
  }
  function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  class LineGap {
    constructor(from, to, size, displaySize) {
      this.from = from;
      this.to = to;
      this.size = size;
      this.displaySize = displaySize;
    }
    static same(a, b) {
      if (a.length != b.length) return false;
      for (let i2 = 0; i2 < a.length; i2++) {
        let gA = a[i2], gB = b[i2];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
      }
      return true;
    }
    draw(viewState, wrapping) {
      return Decoration.replace({
        widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
      }).range(this.from, this.to);
    }
  }
  class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
      super();
      this.size = size;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  }
  class ViewState {
    constructor(state) {
      this.state = state;
      this.pixelViewport = {
        left: 0,
        right: window.innerWidth,
        top: 0,
        bottom: 0
      };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.scrollTop = 0;
      this.scrolledToBottom = false;
      this.scaleX = 1;
      this.scaleY = 1;
      this.scrollAnchorPos = 0;
      this.scrollAnchorHeight = -1;
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.LTR;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      let guessWrapping = state.facet(contentAttributes).some((v) => typeof v != "function" && v.class == "cm-lineWrapping");
      this.heightOracle = new HeightOracle(guessWrapping);
      this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text$1.empty, this.heightOracle.setDoc(state.doc), [
        new ChangedRange(0, 0, 0, state.doc.length)
      ]);
      for (let i2 = 0; i2 < 2; i2++) {
        this.viewport = this.getViewport(0, null);
        if (!this.updateForViewport()) break;
      }
      this.updateViewportLines();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [
        this.viewport
      ], { main } = this.state.selection;
      for (let i2 = 0; i2 <= 1; i2++) {
        let pos = i2 ? main.head : main.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport$1(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      return this.updateScaler();
    }
    updateScaler() {
      let scaler = this.scaler;
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
      return scaler.eq(this.scaler) ? 0 : 2;
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
        this.viewportLines.push(scaleBlock(block, this.scaler));
      });
    }
    update(update, scrollTarget = null) {
      this.state = update.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
      clearHeightChangeFlag();
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight || heightChangeFlag) update.flags |= 2;
      if (scrollAnchor) {
        this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
        this.scrollAnchorHeight = scrollAnchor.top;
      } else {
        this.scrollAnchorPos = -1;
        this.scrollAnchorHeight = this.heightMap.height;
      }
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);
      let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      update.flags |= this.updateForViewport();
      if (viewportChange || !update.changes.empty || update.flags & 2) this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
      update.flags |= this.computeVisibleRanges();
      if (scrollTarget) this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom = view.contentDOM, style = window.getComputedStyle(dom);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let domRect = dom.getBoundingClientRect();
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
      this.contentDOMHeight = domRect.height;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      if (domRect.width && domRect.height) {
        let { scaleX, scaleY } = getScale(dom, domRect);
        if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
          this.scaleX = scaleX;
          this.scaleY = scaleY;
          result |= 8;
          refresh = measureContent = true;
        }
      }
      let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
      let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping) measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
      if (this.scrollTop != scrollTop) {
        this.scrollAnchorHeight = -1;
        this.scrollTop = scrollTop;
      }
      this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView) measureContent = true;
      }
      if (!this.inView && !this.scrollTarget) return 0;
      let contentWidth = domRect.width;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = domRect.width;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
          refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
        clearHeightChangeFlag();
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text$1.empty, this.heightOracle, [
            new ChangedRange(0, 0, 0, view.state.doc.length)
          ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (heightChangeFlag) result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange) {
        if (result & 2) result |= this.updateScaler();
        this.viewport = this.getViewport(bias, this.scrollTarget);
        result |= this.updateForViewport();
      }
      if (result & 2 || viewportChange) this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map = this.heightMap, oracle = this.heightOracle;
      let { visibleTop, visibleBottom } = this;
      let viewport = new Viewport$1(map.lineAt(visibleTop - marginTop * 1e3, QueryType$1.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType$1.ByHeight, oracle, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map.lineAt(head, QueryType$1.ByPos, oracle, 0, 0), topPos;
          if (scrollTarget.y == "center") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from) topPos = block.top;
          else topPos = block.bottom - viewHeight;
          viewport = new Viewport$1(map.lineAt(topPos - 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport$1(this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0).to);
    }
    viewportIsAppropriate({ from, to }, bias = 0) {
      if (!this.inView) return true;
      let { top: top2 } = this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0);
      let { bottom } = this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty) return gaps;
      let mapped = [];
      for (let gap of gaps) if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
      return mapped;
    }
    ensureLineGaps(current, mayMeasure) {
      let wrapping = this.heightOracle.lineWrapping;
      let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
      if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];
      let gaps = [];
      let addGap = (from, to, line, structure) => {
        if (to - from < halfMargin) return;
        let sel = this.state.selection.main, avoid = [
          sel.from
        ];
        if (!sel.empty) avoid.push(sel.to);
        for (let pos of avoid) {
          if (pos > from && pos < to) {
            addGap(from, pos - 10, line, structure);
            addGap(pos + 10, to, line, structure);
            return;
          }
        }
        let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
        if (!gap) {
          if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to && r.to >= to)) {
            let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
            if (lineStart > from) to = lineStart;
          }
          let size = this.gapSize(line, from, to, structure);
          let displaySize = wrapping || size < 2e6 ? size : 2e6;
          gap = new LineGap(from, to, size, displaySize);
        }
        gaps.push(gap);
      };
      let checkLine = (line) => {
        if (line.length < doubleMargin || line.type != BlockType.Text) return;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < doubleMargin) return;
        let target = this.scrollTarget ? this.scrollTarget.range.head : null;
        let viewFrom, viewTo;
        if (wrapping) {
          let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          let top2, bot;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
            top2 = targetFrac - spaceFrac;
            bot = targetFrac + spaceFrac;
          } else {
            top2 = (this.visibleTop - line.top - marginHeight) / line.height;
            bot = (this.visibleBottom - line.top + marginHeight) / line.height;
          }
          viewFrom = findPosition(structure, top2);
          viewTo = findPosition(structure, bot);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = margin * this.heightOracle.charWidth;
          let horizOffset = 0;
          if (totalWidth > 2e6) for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left) horizOffset = old.size - old.displaySize;
          }
          let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
          let left, right;
          if (target != null) {
            let targetFrac = findFraction(structure, target);
            let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
            left = targetFrac - spaceFrac;
            right = targetFrac + spaceFrac;
          } else {
            left = (pxLeft - marginWidth) / totalWidth;
            right = (pxRight + marginWidth) / totalWidth;
          }
          viewFrom = findPosition(structure, left);
          viewTo = findPosition(structure, right);
        }
        if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);
        if (viewTo < line.to) addGap(viewTo, line.to, line, structure);
      };
      for (let line of this.viewportLines) {
        if (Array.isArray(line.type)) line.type.forEach(checkLine);
        else checkLine(line);
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({
            from,
            to
          });
        },
        point() {
        }
      }, 20);
      let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i2) => r.from != ranges[i2].from || r.to != ranges[i2].to);
      this.visibleRanges = ranges;
      return changed ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType$1.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l) => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType$1.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
      let block = this.lineBlockAtHeight(scrollTop + 8);
      return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  }
  let Viewport$1 = class Viewport {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({
            from: pos,
            to: from2
          });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({
        from: pos,
        to
      });
      total += to - pos;
    }
    return {
      total,
      ranges
    };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0) return ranges[0].from;
    if (ratio >= 1) return ranges[ranges.length - 1].to;
    let dist2 = Math.floor(total * ratio);
    for (let i2 = 0; ; i2++) {
      let { from, to } = ranges[i2], size = to - from;
      if (dist2 <= size) return from + dist2;
      dist2 -= size;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function find(array, f) {
    for (let val of array) if (f(val)) return val;
    return void 0;
  }
  const IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1,
    eq(other) {
      return other == this;
    }
  };
  class BigScaler {
    constructor(oracle, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top2 = heightMap.lineAt(from, QueryType$1.ByPos, oracle, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType$1.ByPos, oracle, 0, 0).bottom;
        vpHeight += bottom - top2;
        return {
          from,
          to,
          top: top2,
          bottom,
          domTop: 0,
          domBottom: 0
        };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n < vp.top) return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom) return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n < vp.domTop) return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom) return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    eq(other) {
      if (!(other instanceof BigScaler)) return false;
      return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i2) => vp.from == other.viewports[i2].from && vp.to == other.viewports[i2].to);
    }
  }
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1) return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
  }
  const theme = Facet.define({
    combine: (strs) => strs.join(" ")
  });
  const darkTheme = Facet.define({
    combine: (values) => values.indexOf(true) > -1
  });
  const baseThemeID = StyleModule.newName(), baseLightID = StyleModule.newName(), baseDarkID = StyleModule.newName();
  const lightDarkIDs = {
    "&light": "." + baseLightID,
    "&dark": "." + baseDarkID
  };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&") return main;
          if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  const baseTheme$1$3 = buildTheme("." + baseThemeID, {
    "&": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0,
      overflowAnchor: "none"
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      flexShrink: 0,
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      minHeight: "100%",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere",
      flexShrink: 1
    },
    "&light .cm-content": {
      caretColor: "black"
    },
    "&dark .cm-content": {
      caretColor: "white"
    },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 6px"
    },
    ".cm-layer": {
      position: "absolute",
      left: 0,
      top: 0,
      contain: "size style",
      "& > *": {
        position: "absolute"
      }
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    "@keyframes cm-blink2": {
      "0%": {},
      "50%": {
        opacity: 0
      },
      "100%": {}
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#ddd"
    },
    ".cm-dropCursor": {
      position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
      display: "block"
    },
    ".cm-iso": {
      unicodeBidi: "isolate"
    },
    ".cm-announced": {
      position: "fixed",
      top: "-10000px"
    },
    "@media print": {
      ".cm-announced": {
        display: "none"
      }
    },
    "&light .cm-activeLine": {
      backgroundColor: "#cceeff44"
    },
    "&dark .cm-activeLine": {
      backgroundColor: "#99eeff33"
    },
    "&light .cm-specialChar": {
      color: "red"
    },
    "&dark .cm-specialChar": {
      color: "#f78"
    },
    ".cm-gutters": {
      flexShrink: 0,
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      insetInlineStart: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0,
      zIndex: 300
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      width: 0,
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-highlightSpace": {
      backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
      backgroundPosition: "center"
    },
    ".cm-highlightTab": {
      backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
      backgroundSize: "auto 100%",
      backgroundPosition: "right 90%",
      backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
      backgroundColor: "#ff332255"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  const useCharData = browser.ie && browser.ie_version <= 11;
  class DOMObserver {
    constructor(view) {
      this.view = view;
      this.active = false;
      this.editContext = null;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
      this.lastChange = 0;
      this.scrollTargets = [];
      this.intersection = null;
      this.resizeScroll = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.printQuery = null;
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations) this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();
        else this.flush();
      });
      if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && !(browser.chrome && browser.chrome_version < 126)) {
        this.editContext = new EditContextManager(view);
        if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext;
      }
      if (useCharData) this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.onResize = this.onResize.bind(this);
      this.onPrint = this.onPrint.bind(this);
      this.onScroll = this.onScroll.bind(this);
      if (window.matchMedia) this.printQuery = window.matchMedia("print");
      if (typeof ResizeObserver == "function") {
        this.resizeScroll = new ResizeObserver(() => {
          var _a2;
          if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75) this.onResize();
        });
        this.resizeScroll.observe(view.scrollDOM);
      }
      this.addWindowListeners(this.win = view.win);
      this.start();
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent("Event"));
          }
        }, {
          threshold: [
            0,
            1e-3
          ]
        });
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
    }
    onScrollChanged(e) {
      this.view.inputState.runHandlers("scroll", e);
      if (this.intersecting) this.view.measure();
    }
    onScroll(e) {
      if (this.intersecting) this.flush(false);
      if (this.editContext) this.view.requestMeasure(this.editContext.measureReq);
      this.onScrollChanged(e);
    }
    onResize() {
      if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
    }
    onPrint(event) {
      if ((event.type == "change" || !event.type) && !event.matches) return;
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps) this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      let wasChanged = this.selectionChanged;
      if (!this.readSelectionRange() || this.delayedAndroidKey) return;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel)) return;
      let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context && context.ignoreEvent(event)) {
        if (!wasChanged) this.selectionChanged = false;
        return;
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();
      else this.flush(false);
    }
    readSelectionRange() {
      let { view } = this;
      let selection2 = getSelection(view.root);
      if (!selection2) return false;
      let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection2) || selection2;
      if (!range || this.selectionRange.eq(range)) return false;
      let local = hasSelection(this.dom, range);
      if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
        this.view.inputState.lastFocusTime = 0;
        view.docView.updateSelection();
        return false;
      }
      this.selectionRange.setRange(range);
      if (local) this.selectionChanged = true;
      return true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i2 = 0, changed = null;
      for (let dom = this.dom; dom; ) {
        if (dom.nodeType == 1) {
          if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom) i2++;
          else if (!changed) changed = this.scrollTargets.slice(0, i2);
          if (changed) changed.push(dom);
          dom = dom.assignedSlot || dom.parentNode;
        } else if (dom.nodeType == 11) {
          dom = dom.host;
        } else {
          break;
        }
      }
      if (i2 < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i2);
      if (changed) {
        for (let dom of this.scrollTargets) dom.removeEventListener("scroll", this.onScroll);
        for (let dom of this.scrollTargets = changed) dom.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active) return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active) return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active) return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key, keyCode) {
      var _a2;
      if (!this.delayedAndroidKey) {
        let flush = () => {
          let key2 = this.delayedAndroidKey;
          if (key2) {
            this.clearDelayedAndroidKey();
            this.view.inputState.lastKeyCode = key2.keyCode;
            this.view.inputState.lastKeyTime = Date.now();
            let flushed = this.flush();
            if (!flushed && key2.force) dispatchKey(this.dom, key2.key, key2.keyCode);
          }
        };
        this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
      }
      if (!this.delayedAndroidKey || key == "Enter") this.delayedAndroidKey = {
        key,
        keyCode,
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
    }
    clearDelayedAndroidKey() {
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      this.delayedAndroidKey = null;
      this.flushingAndroidKey = -1;
    }
    flushSoon() {
      if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        this.view.win.cancelAnimationFrame(this.delayedFlush);
        this.delayedFlush = -1;
      }
      this.flush();
    }
    pendingRecords() {
      for (let mut of this.observer.takeRecords()) this.queue.push(mut);
      return this.queue;
    }
    processRecords() {
      let records = this.pendingRecords();
      if (records.length) this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range) continue;
        if (range.typeOver) typeOver = true;
        if (from == -1) {
          ({ from, to } = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      return {
        from,
        to,
        typeOver
      };
    }
    readChange() {
      let { from, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel) return null;
      if (from > -1) this.lastChange = Date.now();
      this.view.inputState.lastFocusTime = 0;
      this.selectionChanged = false;
      let change = new DOMChange(this.view, from, to, typeOver);
      this.view.docView.domChanged = {
        newSel: change.newSel ? change.newSel.main : null
      };
      return change;
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
      if (readSelection) this.readSelectionRange();
      let domChange = this.readChange();
      if (!domChange) {
        this.view.requestMeasure();
        return false;
      }
      let startState = this.view.state;
      let handled = applyDOMChange(this.view, domChange);
      if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main))) this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec)) return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes") cView.flags |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return {
          from: cView.posAtStart,
          to: cView.posAtEnd,
          typeOver: rec.target.nodeValue == rec.oldValue
        };
      } else {
        return null;
      }
    }
    setWindow(win) {
      if (win != this.win) {
        this.removeWindowListeners(this.win);
        this.win = win;
        this.addWindowListeners(this.win);
      }
    }
    addWindowListeners(win) {
      win.addEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.addEventListener) this.printQuery.addEventListener("change", this.onPrint);
        else this.printQuery.addListener(this.onPrint);
      } else win.addEventListener("beforeprint", this.onPrint);
      win.addEventListener("scroll", this.onScroll);
      win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
      win.removeEventListener("scroll", this.onScroll);
      win.removeEventListener("resize", this.onResize);
      if (this.printQuery) {
        if (this.printQuery.removeEventListener) this.printQuery.removeEventListener("change", this.onPrint);
        else this.printQuery.removeListener(this.onPrint);
      } else win.removeEventListener("beforeprint", this.onPrint);
      win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    update(update) {
      if (this.editContext) {
        this.editContext.update(update);
        if (update.startState.facet(editable) != update.state.facet(editable)) update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom of this.scrollTargets) dom.removeEventListener("scroll", this.onScroll);
      this.removeWindowListeners(this.win);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
      this.win.cancelAnimationFrame(this.delayedFlush);
      this.win.cancelAnimationFrame(this.flushingAndroidKey);
      if (this.editContext) {
        this.view.contentDOM.editContext = null;
        this.editContext.destroy();
      }
    }
  }
  function findChild(cView, dom, dir) {
    while (dom) {
      let curView = ContentView.get(dom);
      if (curView && curView.parent == cView) return curView;
      let parent = dom.parentNode;
      dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
  }
  function buildSelectionRangeFromRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [
      focusNode,
      focusOffset,
      anchorNode,
      anchorOffset
    ];
    return {
      anchorNode,
      anchorOffset,
      focusNode,
      focusOffset
    };
  }
  function safariSelectionRangeHack(view, selection2) {
    if (selection2.getComposedRanges) {
      let range = selection2.getComposedRanges(view.root)[0];
      if (range) return buildSelectionRangeFromRange(view, range);
    }
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    return found ? buildSelectionRangeFromRange(view, found) : null;
  }
  class EditContextManager {
    constructor(view) {
      this.from = 0;
      this.to = 0;
      this.pendingContextChange = null;
      this.handlers = /* @__PURE__ */ Object.create(null);
      this.composing = null;
      this.resetRange(view.state);
      let context = this.editContext = new window.EditContext({
        text: view.state.doc.sliceString(this.from, this.to),
        selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
        selectionEnd: this.toContextPos(view.state.selection.main.head)
      });
      this.handlers.textupdate = (e) => {
        let { anchor } = view.state.selection.main;
        let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);
        if (view.inputState.composing >= 0 && !this.composing) this.composing = {
          contextBase: e.updateRangeStart,
          editorBase: from,
          drifted: false
        };
        let change = {
          from,
          to,
          insert: Text$1.of(e.text.split("\n"))
        };
        if (change.from == this.from && anchor < this.from) change.from = anchor;
        else if (change.to == this.to && anchor > this.to) change.to = anchor;
        if (change.from == change.to && !change.insert.length) return;
        this.pendingContextChange = change;
        if (!view.state.readOnly) applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd)));
        if (this.pendingContextChange) {
          this.revertPending(view.state);
          this.setSelection(view.state);
        }
      };
      this.handlers.characterboundsupdate = (e) => {
        let rects = [], prev = null;
        for (let i2 = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i2 < end; i2++) {
          let rect = view.coordsForChar(i2);
          prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
          rects.push(prev);
        }
        context.updateCharacterBounds(e.rangeStart, rects);
      };
      this.handlers.textformatupdate = (e) => {
        let deco = [];
        for (let format of e.getTextFormats()) {
          let lineStyle = format.underlineStyle, thickness = format.underlineThickness;
          if (lineStyle != "None" && thickness != "None") {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({
              attributes: {
                style
              }
            }).range(this.toEditorPos(format.rangeStart), this.toEditorPos(format.rangeEnd)));
          }
        }
        view.dispatch({
          effects: setEditContextFormatting.of(Decoration.set(deco))
        });
      };
      this.handlers.compositionstart = () => {
        if (view.inputState.composing < 0) {
          view.inputState.composing = 0;
          view.inputState.compositionFirstChange = true;
        }
      };
      this.handlers.compositionend = () => {
        view.inputState.composing = -1;
        view.inputState.compositionFirstChange = null;
        if (this.composing) {
          let { drifted } = this.composing;
          this.composing = null;
          if (drifted) this.reset(view.state);
        }
      };
      for (let event in this.handlers) context.addEventListener(event, this.handlers[event]);
      this.measureReq = {
        read: (view2) => {
          this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
          let sel = getSelection(view2.root);
          if (sel && sel.rangeCount) this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
        }
      };
    }
    applyEdits(update) {
      let off = 0, abort = false, pending = this.pendingContextChange;
      update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
        if (abort) return;
        let dLen = insert2.length - (toA - fromA);
        if (pending && toA >= pending.to) {
          if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
            pending = this.pendingContextChange = null;
            off += dLen;
            this.to += dLen;
            return;
          } else {
            pending = null;
            this.revertPending(update.state);
          }
        }
        fromA += off;
        toA += off;
        if (toA <= this.from) {
          this.from += dLen;
          this.to += dLen;
        } else if (fromA < this.to) {
          if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
            abort = true;
            return;
          }
          this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
          this.to += dLen;
        }
        off += dLen;
      });
      if (pending && !abort) this.revertPending(update.state);
      return !abort;
    }
    update(update) {
      let reverted = this.pendingContextChange;
      if (this.composing && (this.composing.drifted || update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
        this.composing.drifted = true;
        this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
      } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
        this.pendingContextChange = null;
        this.reset(update.state);
      } else if (update.docChanged || update.selectionSet || reverted) {
        this.setSelection(update.state);
      }
      if (update.geometryChanged || update.docChanged || update.selectionSet) update.view.requestMeasure(this.measureReq);
    }
    resetRange(state) {
      let { head } = state.selection.main;
      this.from = Math.max(0, head - 1e4);
      this.to = Math.min(state.doc.length, head + 1e4);
    }
    reset(state) {
      this.resetRange(state);
      this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
      this.setSelection(state);
    }
    revertPending(state) {
      let pending = this.pendingContextChange;
      this.pendingContextChange = null;
      this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
    }
    setSelection(state) {
      let { main } = state.selection;
      let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
      let end = this.toContextPos(main.head);
      if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end) this.editContext.updateSelection(start, end);
    }
    rangeIsValid(state) {
      let { head } = state.selection.main;
      return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
    }
    toEditorPos(contextPos) {
      let c = this.composing;
      return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
    }
    toContextPos(editorPos) {
      let c = this.composing;
      return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
    }
    destroy() {
      for (let event in this.handlers) this.editContext.removeEventListener(event, this.handlers[event]);
    }
  }
  EditorView = class {
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    get root() {
      return this._root;
    }
    get win() {
      return this.dom.ownerDocument.defaultView || window;
    }
    constructor(config2 = {}) {
      var _a2;
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.className = "cm-announced";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      if (config2.parent) config2.parent.appendChild(this.dom);
      let { dispatch } = config2;
      this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
      this.dispatch = this.dispatch.bind(this);
      this._root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create(config2));
      if (config2.scrollTo && config2.scrollTo.is(scrollIntoView$1)) this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins) plugin.update(this);
      this.observer = new DOMObserver(this);
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready) document.fonts.ready.then(() => this.requestMeasure());
    }
    dispatch(...input) {
      let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [
        this.state.update(...input)
      ];
      this.dispatchTransactions(trs, this);
    }
    update(transactions) {
      if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update;
      let state = this.state;
      for (let tr of transactions) {
        if (tr.startState != state) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state;
        return;
      }
      let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
      if (transactions.some((tr) => tr.annotation(isFocusChange))) {
        this.inputState.notifiedFocused = focus;
        focusFlag = 1;
      } else if (focus != this.inputState.notifiedFocused) {
        this.inputState.notifiedFocused = focus;
        dispatchFocus = focusChangeTransaction(state, focus);
        if (!dispatchFocus) focusFlag = 1;
      }
      let pendingKey = this.observer.delayedAndroidKey, domChange = null;
      if (pendingKey) {
        this.observer.clearDelayedAndroidKey();
        domChange = this.observer.readChange();
        if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;
      } else {
        this.observer.clear();
      }
      if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases)) return this.setState(state);
      update = ViewUpdate.create(this, state, transactions);
      update.flags |= focusFlag;
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main } = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e of tr.effects) if (e.is(scrollIntoView$1)) scrollTarget = e.value.clip(this.state);
        }
        this.viewState.update(update, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        redrawn = this.docView.update(update);
        if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();
      if (redrawn) this.docViewUpdate();
      if (!update.empty) for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e) {
          logException(this.state, e, "update listener");
        }
      }
      if (dispatchFocus || domChange) Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
    }
    setState(newState) {
      if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins) plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins) plugin.update(this);
        this.docView.destroy();
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus) this.focus();
      this.requestMeasure();
    }
    updatePlugins(update) {
      let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins) if (plugin.mustUpdate != update) plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
      } else {
        for (let p of this.plugins) p.mustUpdate = update;
      }
      for (let i2 = 0; i2 < this.plugins.length; i2++) this.plugins[i2].update(this);
      if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);
    }
    docViewUpdate() {
      for (let plugin of this.plugins) {
        let val = plugin.value;
        if (val && val.docViewUpdate) {
          try {
            val.docViewUpdate(this);
          } catch (e) {
            logException(this.state, e, "doc view update listener");
          }
        }
      }
    }
    measure(flush = true) {
      if (this.destroyed) return;
      if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
      if (this.observer.delayedAndroidKey) {
        this.measureScheduled = -1;
        this.requestMeasure();
        return;
      }
      this.measureScheduled = 0;
      if (flush) this.observer.forceFlush();
      let updated = null;
      let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
      let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
      if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;
      this.viewState.scrollAnchorHeight = -1;
      try {
        for (let i2 = 0; ; i2++) {
          if (scrollAnchorHeight < 0) {
            if (isScrolledToBottom(sDOM)) {
              scrollAnchorPos = -1;
              scrollAnchorHeight = this.viewState.heightMap.height;
            } else {
              let block = this.viewState.scrollAnchorAt(scrollTop);
              scrollAnchorPos = block.from;
              scrollAnchorHeight = block.top;
            }
          }
          this.updateState = 1;
          let changed = this.viewState.measure(this);
          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
          if (i2 > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed & 4)) [this.measureRequests, measuring] = [
            measuring,
            this.measureRequests
          ];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e) {
              logException(this.state, e);
              return BadMeasure;
            }
          });
          let update = ViewUpdate.create(this, this.state, []), redrawn = false;
          update.flags |= changed;
          if (!updated) updated = update;
          else updated.flags |= changed;
          this.updateState = 2;
          if (!update.empty) {
            this.updatePlugins(update);
            this.inputState.update(update);
            this.updateAttrs();
            redrawn = this.docView.update(update);
            if (redrawn) this.docViewUpdate();
          }
          for (let i3 = 0; i3 < measuring.length; i3++) if (measured[i3] != BadMeasure) {
            try {
              let m = measuring[i3];
              if (m.write) m.write(measured[i3], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
          if (redrawn) this.docView.updateSelection(true);
          if (!update.viewportChanged && this.measureRequests.length == 0) {
            if (this.viewState.editorHeight) {
              if (this.viewState.scrollTarget) {
                this.docView.scrollIntoView(this.viewState.scrollTarget);
                this.viewState.scrollTarget = null;
                scrollAnchorHeight = -1;
                continue;
              } else {
                let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
                let diff = newAnchorHeight - scrollAnchorHeight;
                if (diff > 1 || diff < -1) {
                  scrollTop = scrollTop + diff;
                  sDOM.scrollTop = scrollTop / this.scaleY;
                  scrollAnchorHeight = -1;
                  continue;
                }
              }
            }
            break;
          }
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty) for (let listener of this.state.facet(updateListener)) listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs) for (let effect of tr.effects) if (effect.is(EditorView.announce)) {
        if (first) this.announceDOM.textContent = "";
        first = false;
        let div = this.announceDOM.appendChild(document.createElement("div"));
        div.textContent = effect.value;
      }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      let nonce = this.state.facet(EditorView.cspNonce);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$3).reverse(), nonce ? {
        nonce
      } : void 0);
    }
    readMeasured() {
      if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1) this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
      if (request) {
        if (this.measureRequests.indexOf(request) > -1) return;
        if (request.key != null) for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
          if (this.measureRequests[i2].key === request.key) {
            this.measureRequests[i2] = request;
            return;
          }
        }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return {
        top: this.viewState.paddingTop,
        bottom: this.viewState.paddingBottom
      };
    }
    get scaleX() {
      return this.viewState.scaleX;
    }
    get scaleY() {
      return this.viewState.scaleY;
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    visualLineSide(line, end) {
      let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
      let span = order[end ? order.length - 1 : 0];
      return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right) return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    coordsForChar(pos) {
      this.readMeasured();
      return this.docView.coordsForChar(pos);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine) return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from), isolates;
      for (let entry of this.bidiCache) {
        if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;
      }
      if (!isolates) isolates = getIsolatedRanges(this, line);
      let order = computeOrder(line.text, dir, isolates);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    setRoot(root) {
      if (this._root != root) {
        this._root = root;
        this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
        this.mountStyles();
      }
    }
    destroy() {
      if (this.root.activeElement == this.contentDOM) this.contentDOM.blur();
      for (let plugin of this.plugins) plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.docView.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options = {}) {
      return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    scrollSnapshot() {
      let { scrollTop, scrollLeft } = this.scrollDOM;
      let ref = this.viewState.scrollAnchorAt(scrollTop);
      return scrollIntoView$1.of(new ScrollTarget(EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    setTabFocusMode(to) {
      if (to == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
      else if (typeof to == "boolean") this.inputState.tabFocusMode = to ? 0 : -1;
      else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to;
    }
    static domEventHandlers(handlers2) {
      return ViewPlugin.define(() => ({}), {
        eventHandlers: handlers2
      });
    }
    static domEventObservers(observers2) {
      return ViewPlugin.define(() => ({}), {
        eventObservers: observers2
      });
    }
    static theme(spec, options) {
      let prefix = StyleModule.newName();
      let result = [
        theme.of(prefix),
        styleModule.of(buildTheme(`.${prefix}`, spec))
      ];
      if (options && options.dark) result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    static findFromDOM(dom) {
      var _a2;
      let content2 = dom.querySelector(".cm-content");
      let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
      return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler$1;
  EditorView.clipboardInputFilter = clipboardInputFilter;
  EditorView.clipboardOutputFilter = clipboardOutputFilter;
  EditorView.scrollHandler = scrollHandler;
  EditorView.focusChangeEffect = focusChangeEffect;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.outerDecorations = outerDecorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.cspNonce = Facet.define({
    combine: (values) => values.length ? values[0] : ""
  });
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = EditorView.contentAttributes.of({
    "class": "cm-lineWrapping"
  });
  EditorView.announce = StateEffect.define();
  const MaxBidiLine = 4096;
  const BadMeasure = {};
  class CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.isolates = isolates;
      this.fresh = fresh;
      this.order = order;
    }
    static update(cache, changes) {
      if (changes.empty && !cache.some((c) => c.fresh)) return cache;
      let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
      for (let i2 = Math.max(0, cache.length - 10); i2 < cache.length; i2++) {
        let entry = cache[i2];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
      }
      return result;
    }
  }
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
      let source = sources[i2], value = typeof source == "function" ? source(view) : source;
      if (value) combineAttrs(value, base2);
    }
    return base2;
  }
  const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name2, platform) {
    const parts = name2.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space") result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i2 = 0; i2 < parts.length - 1; ++i2) {
      const mod = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod)) meta2 = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)?$/i.test(mod)) shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac") meta2 = true;
        else ctrl = true;
      } else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) result = "Alt-" + result;
    if (ctrl) result = "Ctrl-" + result;
    if (meta2) result = "Meta-" + result;
    if (shift2) result = "Shift-" + result;
    return result;
  }
  function modifiers(name2, event, shift2) {
    if (event.altKey) name2 = "Alt-" + name2;
    if (event.ctrlKey) name2 = "Ctrl-" + name2;
    if (event.metaKey) name2 = "Meta-" + name2;
    if (shift2 !== false && event.shiftKey) name2 = "Shift-" + name2;
    return name2;
  }
  const handleKeyEvents = Prec.default(EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  }));
  const keymap = Facet.define({
    enables: handleKeyEvents
  });
  const Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state) {
    let bindings = state.facet(keymap);
    let map = Keymaps.get(bindings);
    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
  }
  function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
  }
  let storedPrefix = null;
  const PrefixTimeout = 4e3;
  function buildKeymap(bindings, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name2, is) => {
      let current = isPrefix[name2];
      if (current == null) isPrefix[name2] = is;
      else if (current != is) throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key, command2, preventDefault, stopPropagation) => {
      var _a2, _b;
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i2 = 1; i2 < parts.length; i2++) {
        let prefix = parts.slice(0, i2).join(" ");
        checkPrefix(prefix, true);
        if (!scopeObj[prefix]) scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [
            (view) => {
              let ourObj = storedPrefix = {
                view,
                prefix,
                scope
              };
              setTimeout(() => {
                if (storedPrefix == ourObj) storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }
          ]
        };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = {
        preventDefault: false,
        stopPropagation: false,
        run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
      });
      if (command2) binding.run.push(command2);
      if (preventDefault) binding.preventDefault = true;
      if (stopPropagation) binding.stopPropagation = true;
    };
    for (let b of bindings) {
      let scopes = b.scope ? b.scope.split(" ") : [
        "editor"
      ];
      if (b.any) for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any) scopeObj._any = {
          preventDefault: false,
          stopPropagation: false,
          run: []
        };
        let { any } = b;
        for (let key in scopeObj) scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
      let name2 = b[platform] || b.key;
      if (!name2) continue;
      for (let scope of scopes) {
        add2(scope, name2, b.run, b.preventDefault, b.stopPropagation);
        if (b.shift) add2(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
      }
    }
    return bound;
  }
  let currentKeyEvent = null;
  function runHandlers(map, event, view, scope) {
    currentKeyEvent = event;
    let name2 = keyName(event);
    let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix = storedPrefix.prefix + " ";
      if (modifierCodes.indexOf(event.keyCode) < 0) {
        prevented = true;
        storedPrefix = null;
      }
    }
    let ran = /* @__PURE__ */ new Set();
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.run) if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding.stopPropagation) stopPropagation = true;
            return true;
          }
        }
        if (binding.preventDefault) {
          if (binding.stopPropagation) stopPropagation = true;
          prevented = true;
        }
      }
      return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
        handled = true;
      } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name2) {
        if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
          handled = true;
        } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
          handled = true;
        }
      } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
        handled = true;
      }
      if (!handled && runFor(scopeObj._any)) handled = true;
    }
    if (prevented) handled = true;
    if (handled && stopPropagation) event.stopPropagation();
    currentKeyEvent = null;
    return handled;
  }
  class RectangleMarker {
    constructor(className, left, top2, width, height) {
      this.className = className;
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    update(elt, prev) {
      if (prev.className != this.className) return false;
      this.adjust(elt);
      return true;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width != null) elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
    static forRange(view, className, range) {
      if (range.empty) {
        let pos = view.coordsAtPos(range.head, range.assoc || 1);
        if (!pos) return [];
        let base2 = getBase(view);
        return [
          new RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)
        ];
      } else {
        return rectanglesForRange(view, className, range);
      }
    }
  }
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return {
      left: left - view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - view.scrollDOM.scrollTop * view.scaleY
    };
  }
  function wrappedLine(view, pos, side, inside2) {
    let coords = view.coordsAtPos(pos, side * 2);
    if (!coords) return inside2;
    let editorRect = view.dom.getBoundingClientRect();
    let y = (coords.top + coords.bottom) / 2;
    let left = view.posAtCoords({
      x: editorRect.left + 1,
      y
    });
    let right = view.posAtCoords({
      x: editorRect.right - 1,
      y
    });
    if (left == null || right == null) return inside2;
    return {
      from: Math.max(inside2.from, Math.min(left, right)),
      to: Math.min(inside2.to, Math.max(left, right))
    };
  }
  function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, 1, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, -1, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text) top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new RectangleMarker(className, left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01);
    }
    function pieces({ top: top2, bottom, horizontal }) {
      let pieces2 = [];
      for (let i2 = 0; i2 < horizontal.length; i2 += 2) pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
      return pieces2;
    }
    function drawForLine(from2, to2, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from3, fromOpen, to3, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        if (!fromCoords || !toCoords) return;
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      for (let r of view.visibleRanges) if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos) break;
            if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos) break;
        }
      }
      if (horizontal.length == 0) addSpan(start, from2 == null, end, to2 == null, view.textDirection);
      return {
        top: top2,
        bottom,
        horizontal
      };
    }
    function drawForWidget(block, top2) {
      let y = contentRect.top + (top2 ? block.top : block.bottom);
      return {
        top: y,
        bottom: y,
        horizontal: []
      };
    }
  }
  function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
  }
  class LayerView {
    constructor(view, layer2) {
      this.view = view;
      this.layer = layer2;
      this.drawn = [];
      this.scaleX = 1;
      this.scaleY = 1;
      this.measureReq = {
        read: this.measure.bind(this),
        write: this.draw.bind(this)
      };
      this.dom = view.scrollDOM.appendChild(document.createElement("div"));
      this.dom.classList.add("cm-layer");
      if (layer2.above) this.dom.classList.add("cm-layer-above");
      if (layer2.class) this.dom.classList.add(layer2.class);
      this.scale();
      this.dom.setAttribute("aria-hidden", "true");
      this.setOrder(view.state);
      view.requestMeasure(this.measureReq);
      if (layer2.mount) layer2.mount(this.dom, view);
    }
    update(update) {
      if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);
      if (this.layer.update(update, this.dom) || update.geometryChanged) {
        this.scale();
        update.view.requestMeasure(this.measureReq);
      }
    }
    docViewUpdate(view) {
      if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq);
    }
    setOrder(state) {
      let pos = 0, order = state.facet(layerOrder);
      while (pos < order.length && order[pos] != this.layer) pos++;
      this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
      return this.layer.markers(this.view);
    }
    scale() {
      let { scaleX, scaleY } = this.view;
      if (scaleX != this.scaleX || scaleY != this.scaleY) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
      }
    }
    draw(markers) {
      if (markers.length != this.drawn.length || markers.some((p, i2) => !sameMarker(p, this.drawn[i2]))) {
        let old = this.dom.firstChild, oldI = 0;
        for (let marker of markers) {
          if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
            old = old.nextSibling;
            oldI++;
          } else {
            this.dom.insertBefore(marker.draw(), old);
          }
        }
        while (old) {
          let next = old.nextSibling;
          old.remove();
          old = next;
        }
        this.drawn = markers;
      }
    }
    destroy() {
      if (this.layer.destroy) this.layer.destroy(this.dom, this.view);
      this.dom.remove();
    }
  }
  const layerOrder = Facet.define();
  function layer(config2) {
    return [
      ViewPlugin.define((v) => new LayerView(v, config2)),
      layerOrder.of(config2)
    ];
  }
  const CanHidePrimary = !browser.ios;
  const selectionConfig = Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      cursorLayer,
      selectionLayer,
      hideNativeSelection,
      nativeSelectionHidden.of(true)
    ];
  }
  function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
  }
  const cursorLayer = layer({
    above: true,
    markers(view) {
      let { state } = view, conf = state.facet(selectionConfig);
      let cursors = [];
      for (let r of state.selection.ranges) {
        let prim = r == state.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
          let cursor2 = r.empty ? r : EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
          for (let piece of RectangleMarker.forRange(view, className, cursor2)) cursors.push(piece);
        }
      }
      return cursors;
    },
    update(update, dom) {
      if (update.transactions.some((tr) => tr.selection)) dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      let confChange = configChanged(update);
      if (confChange) setBlinkRate(update.state, dom);
      return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
      setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
  });
  function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
  }
  const selectionLayer = layer({
    above: false,
    markers(view) {
      return view.state.selection.ranges.map((r) => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
      return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
  });
  const themeSpec = {
    ".cm-line": {
      "& ::selection, &::selection": {
        backgroundColor: "transparent !important"
      }
    },
    ".cm-content": {
      "& :focus": {
        caretColor: "initial !important",
        "&::selection, & ::selection": {
          backgroundColor: "Highlight !important"
        }
      }
    }
  };
  if (CanHidePrimary) themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
  const hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
  const setDropCursorPos = StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  const dropCursorPos = StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null) pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e) => e.is(setDropCursorPos) ? e.value : pos2, pos);
    }
  });
  const drawDropCursor = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.cursor = null;
      this.measureReq = {
        read: this.readPos.bind(this),
        write: this.drawCursor.bind(this)
      };
    }
    update(update) {
      var _a2;
      let cursorPos = update.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let { view } = this;
      let pos = view.state.field(dropCursorPos);
      let rect = pos != null && view.coordsAtPos(pos);
      if (!rect) return null;
      let outer = view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
        top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        let { scaleX, scaleY } = this.view;
        if (pos) {
          this.cursor.style.left = pos.left / scaleX + "px";
          this.cursor.style.top = pos.top / scaleY + "px";
          this.cursor.style.height = pos.height / scaleY + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor) this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({
        effects: setDropCursorPos.of(pos)
      });
    }
  }, {
    eventObservers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({
          x: event.clientX,
          y: event.clientY
        }));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [
      dropCursorPos,
      drawDropCursor
    ];
  }
  function iterMatches(doc2, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor2 = doc2.iterRange(from, to), pos = from, m; !cursor2.next().done; pos += cursor2.value.length) {
      if (!cursor2.lineBreak) while (m = re.exec(cursor2.value)) f(pos + m.index, m);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;
    let result = [];
    for (let { from, to } of visible) {
      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
      to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
      if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;
      else result.push({
        from,
        to
      });
    }
    return result;
  }
  class MatchDecorator {
    constructor(config2) {
      const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
      if (!regexp.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      if (decorate) {
        this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
      } else if (typeof decoration == "function") {
        this.addMatch = (match, view, from, add2) => {
          let deco = decoration(match, view, from);
          if (deco) add2(from, from + match[0].length, deco);
        };
      } else if (decoration) {
        this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
      } else {
        throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
      }
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view) {
      let build = new RangeSetBuilder(), add2 = build.add.bind(build);
      for (let { from, to } of matchRanges(view, this.maxLength)) iterMatches(view.state.doc, this.regexp, from, to, (from2, m) => this.addMatch(m, view, from2, add2));
      return build.finish();
    }
    updateDeco(update, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update.docChanged) update.changes.iterChanges((_f, _t, from, to) => {
        if (to > update.view.viewport.from && from < update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
      if (update.viewportChanged || changeTo - changeFrom > 1e3) return this.createDeco(update.view);
      if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r of view.visibleRanges) {
        let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
        if (to > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
          let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
            for (; to < toLine.to; to++) if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
          }
          let ranges = [], m;
          let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
          if (fromLine == toLine) {
            this.regexp.lastIndex = start - fromLine.from;
            while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) this.addMatch(m, view, m.index + fromLine.from, add2);
          } else {
            iterMatches(view.state.doc, this.regexp, start, end, (from2, m2) => this.addMatch(m2, view, from2, add2));
          }
          deco = deco.update({
            filterFrom: start,
            filterTo: end,
            filter: (from2, to2) => from2 < start || to2 > end,
            add: ranges
          });
        }
      }
      return deco;
    }
  }
  const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  const Specials = new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  let _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  const specialCharConfig = Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize()) config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars) config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [
      specialCharConfig.of(config2),
      specialCharPlugin()
    ];
  }
  let _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = /* @__PURE__ */ Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m, view, pos) => {
            let { doc: doc2 } = view.state;
            let code2 = codePointAt(m[0], 0);
            if (code2 == 9) {
              let line = doc2.lineAt(pos);
              let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
              return Decoration.replace({
                widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
              });
            }
            return this.decorationCache[code2] || (this.decorationCache[code2] = Decoration.replace({
              widget: new SpecialCharWidget(conf, code2)
            }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update) {
        let conf = update.state.facet(specialCharConfig);
        if (update.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update.view);
        } else {
          this.decorations = this.decorator.updateDeco(update, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  const DefaultPlaceholder = "\u2022";
  function placeholder$1(code2) {
    if (code2 >= 32) return DefaultPlaceholder;
    if (code2 == 10) return "\u2424";
    return String.fromCharCode(9216 + code2);
  }
  class SpecialCharWidget extends WidgetType {
    constructor(options, code2) {
      super();
      this.options = options;
      this.code = code2;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom) return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  }
  class TabWidget extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  }
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  const lineDeco = Decoration.line({
    class: "cm-activeLine"
  });
  const activeLineHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r of view.state.selection.ranges) {
        let line = view.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  class Placeholder extends WidgetType {
    constructor(content2) {
      super();
      this.content = content2;
    }
    toDOM(view) {
      let wrap = document.createElement("span");
      wrap.className = "cm-placeholder";
      wrap.style.pointerEvents = "none";
      wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
      if (typeof this.content == "string") wrap.setAttribute("aria-label", "placeholder " + this.content);
      else wrap.setAttribute("aria-hidden", "true");
      return wrap;
    }
    coordsAt(dom) {
      let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
      if (!rects.length) return null;
      let style = window.getComputedStyle(dom.parentNode);
      let rect = flattenRect(rects[0], style.direction != "rtl");
      let lineHeight = parseInt(style.lineHeight);
      if (rect.bottom - rect.top > lineHeight * 1.5) return {
        left: rect.left,
        right: rect.right,
        top: rect.top,
        bottom: rect.top + lineHeight
      };
      return rect;
    }
    ignoreEvent() {
      return false;
    }
  }
  function placeholder(content2) {
    return ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.placeholder = content2 ? Decoration.set([
          Decoration.widget({
            widget: new Placeholder(content2),
            side: 1
          }).range(0)
        ]) : Decoration.none;
      }
      get decorations() {
        return this.view.state.doc.length ? Decoration.none : this.placeholder;
      }
    }, {
      decorations: (v) => v.decorations
    });
  }
  const MaxOff = 2e3;
  function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
      let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state.doc.line(i2);
        if (line.length <= endOff) ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state.doc.line(i2);
        let start = findColumn(line.text, startCol, state.tabSize, true);
        if (start < 0) {
          ranges.push(EditorSelection.cursor(line.to));
        } else {
          let end = findColumn(line.text, endCol, state.tabSize);
          ranges.push(EditorSelection.range(line.from + start, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
  }
  function getPos(view, event) {
    let offset = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
    return {
      line: line.number,
      col,
      off
    };
  }
  function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start) return null;
    return {
      update(update) {
        if (update.docChanged) {
          let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
          let newLine = update.state.doc.lineAt(newStart);
          start = {
            line: newLine.number,
            col: start.col,
            off: Math.min(start.off, newLine.length)
          };
          startSel = startSel.map(update.changes);
        }
      },
      get(event2, _extend, multiple) {
        let cur2 = getPos(view, event2);
        if (!cur2) return startSel;
        let ranges = rectangleFor(view.state, start, cur2);
        if (!ranges.length) return startSel;
        if (multiple) return EditorSelection.create(ranges.concat(startSel.ranges));
        else return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options) {
    let filter = (e) => e.altKey && e.button == 0;
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
  }
  const keys = {
    Alt: [
      18,
      (e) => !!e.altKey
    ],
    Control: [
      17,
      (e) => !!e.ctrlKey
    ],
    Shift: [
      16,
      (e) => !!e.shiftKey
    ],
    Meta: [
      91,
      (e) => !!e.metaKey
    ]
  };
  const showCrosshair = {
    style: "cursor: crosshair"
  };
  function crosshairCursor(options = {}) {
    let [code2, getter] = keys[options.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventObservers: {
        keydown(e) {
          this.set(e.keyCode == code2 || getter(e));
        },
        keyup(e) {
          if (e.keyCode == code2 || !getter(e)) this.set(false);
        },
        mousemove(e) {
          this.set(getter(e));
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view) => {
        var _a2;
        return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  const Outside = "-10000px";
  class TooltipViewManager {
    constructor(view, facet, createTooltipView, removeTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.removeTooltipView = removeTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      let prev = null;
      this.tooltipViews = this.tooltips.map((t2) => prev = createTooltipView(t2, prev));
    }
    update(update, above) {
      var _a2;
      let input = update.state.facet(this.facet);
      let tooltips = input.filter((x) => x);
      if (input === this.input) {
        for (let t2 of this.tooltipViews) if (t2.update) t2.update(update);
        return false;
      }
      let tooltipViews = [], newAbove = above ? [] : null;
      for (let i2 = 0; i2 < tooltips.length; i2++) {
        let tip = tooltips[i2], known = -1;
        if (!tip) continue;
        for (let i3 = 0; i3 < this.tooltips.length; i3++) {
          let other = this.tooltips[i3];
          if (other && other.create == tip.create) known = i3;
        }
        if (known < 0) {
          tooltipViews[i2] = this.createTooltipView(tip, i2 ? tooltipViews[i2 - 1] : null);
          if (newAbove) newAbove[i2] = !!tip.above;
        } else {
          let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
          if (newAbove) newAbove[i2] = above[known];
          if (tooltipView.update) tooltipView.update(update);
        }
      }
      for (let t2 of this.tooltipViews) if (tooltipViews.indexOf(t2) < 0) {
        this.removeTooltipView(t2);
        (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
      if (above) {
        newAbove.forEach((val, i2) => above[i2] = val);
        above.length = newAbove.length;
      }
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  }
  function windowSpace(view) {
    let { win } = view;
    return {
      top: 0,
      left: 0,
      bottom: win.innerHeight,
      right: win.innerWidth
    };
  }
  const tooltipConfig = Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  const knownHeight = /* @__PURE__ */ new WeakMap();
  const tooltipPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.above = [];
      this.inView = true;
      this.madeAbsolute = false;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = {
        read: this.readMeasure.bind(this),
        write: this.writeMeasure.bind(this),
        key: this
      };
      this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
      this.manager = new TooltipViewManager(view, showTooltip, (t2, p) => this.createTooltip(t2, p), (t2) => {
        if (this.resizeObserver) this.resizeObserver.unobserve(t2.dom);
        t2.dom.remove();
      });
      this.above = this.manager.tooltips.map((t2) => !!t2.above);
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();
      }, {
        threshold: [
          1
        ]
      }) : null;
      this.observeIntersection();
      view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews) this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0) this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
    }
    update(update) {
      if (update.transactions.length) this.lastTransaction = Date.now();
      let updated = this.manager.update(update, this.above);
      if (updated) this.observeIntersection();
      let shouldMeasure = updated || update.geometryChanged;
      let newConfig = update.state.facet(tooltipConfig);
      if (newConfig.position != this.position && !this.madeAbsolute) {
        this.position = newConfig.position;
        for (let t2 of this.manager.tooltipViews) t2.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent) this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t2 of this.manager.tooltipViews) this.container.appendChild(t2.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure) this.maybeMeasure();
    }
    createTooltip(tooltip, prev) {
      let tooltipView = tooltip.create(this.view);
      let before = prev ? prev.dom : null;
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      tooltipView.dom.style.left = "0px";
      this.container.insertBefore(tooltipView.dom, before);
      if (tooltipView.mount) tooltipView.mount(this.view);
      if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);
      return tooltipView;
    }
    destroy() {
      var _a2, _b, _c;
      this.view.win.removeEventListener("resize", this.measureSoon);
      for (let tooltipView of this.manager.tooltipViews) {
        tooltipView.dom.remove();
        (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
      }
      if (this.parent) this.container.remove();
      (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let scaleX = 1, scaleY = 1, makeAbsolute = false;
      if (this.position == "fixed" && this.manager.tooltipViews.length) {
        let { dom } = this.manager.tooltipViews[0];
        if (browser.gecko) {
          makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
        } else if (dom.style.top == Outside && dom.style.left == "0px") {
          let rect = dom.getBoundingClientRect();
          makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
        }
      }
      if (makeAbsolute || this.position == "absolute") {
        if (this.parent) {
          let rect = this.parent.getBoundingClientRect();
          if (rect.width && rect.height) {
            scaleX = rect.width / this.parent.offsetWidth;
            scaleY = rect.height / this.parent.offsetHeight;
          }
        } else {
          ({ scaleX, scaleY } = this.view.viewState);
        }
      }
      let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
      return {
        visible: {
          left: visible.left + margins.left,
          top: visible.top + margins.top,
          right: visible.right - margins.right,
          bottom: visible.bottom - margins.bottom
        },
        parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
        pos: this.manager.tooltips.map((t2, i2) => {
          let tv = this.manager.tooltipViews[i2];
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
        scaleX,
        scaleY,
        makeAbsolute
      };
    }
    writeMeasure(measured) {
      var _a2;
      if (measured.makeAbsolute) {
        this.madeAbsolute = true;
        this.position = "absolute";
        for (let t2 of this.manager.tooltipViews) t2.dom.style.position = "absolute";
      }
      let { visible, space, scaleX, scaleY } = measured;
      let others = [];
      for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
        let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom } = tView;
        let pos = measured.pos[i2], size = measured.size[i2];
        if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - 0.1 || pos.left > Math.min(visible.right, space.right) + 0.1)) {
          dom.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
        let above = this.above[i2];
        if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i2] = !above;
        let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
        if (spaceVert < height && tView.resize !== false) {
          if (spaceVert < this.view.defaultLineHeight) {
            dom.style.top = Outside;
            continue;
          }
          knownHeight.set(tView, height);
          dom.style.height = (height = spaceVert) / scaleY + "px";
        } else if (dom.style.height) {
          dom.style.height = "";
        }
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r of others) if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2) top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
          dom.style.left = (left - measured.parent.left) / scaleX + "px";
        } else {
          dom.style.top = top2 / scaleY + "px";
          dom.style.left = left / scaleX + "px";
        }
        if (arrow) {
          let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
          arrow.style.left = arrowLeft / scaleX + "px";
        }
        if (tView.overlap !== true) others.push({
          left,
          top: top2,
          right,
          bottom: top2 + height
        });
        dom.classList.toggle("cm-tooltip-above", above);
        dom.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned) tView.positioned(measured.space);
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView) this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView) for (let tv of this.manager.tooltipViews) tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventObservers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  const baseTheme$4 = EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 500,
      boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  const noOffset = {
    x: 0,
    y: 0
  };
  const showTooltip = Facet.define({
    enables: [
      tooltipPlugin,
      baseTheme$4
    ]
  });
  const showHoverTooltip = Facet.define({
    combine: (inputs) => inputs.reduce((a, i2) => a.concat(i2), [])
  });
  class HoverTooltipHost {
    static create(view) {
      return new HoverTooltipHost(view);
    }
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t2, p) => this.createHostedView(t2, p), (t2) => t2.dom.remove());
    }
    createHostedView(tooltip, prev) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
      if (this.mounted && hostedView.mount) hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount) hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned(space) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned) hostedView.positioned(space);
      }
    }
    update(update) {
      this.manager.update(update);
    }
    destroy() {
      var _a2;
      for (let t2 of this.manager.tooltipViews) (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
    }
    passProp(name2) {
      let value = void 0;
      for (let view of this.manager.tooltipViews) {
        let given = view[name2];
        if (given !== void 0) {
          if (value === void 0) value = given;
          else if (value !== given) return void 0;
        }
      }
      return value;
    }
    get offset() {
      return this.passProp("offset");
    }
    get getCoords() {
      return this.passProp("getCoords");
    }
    get overlap() {
      return this.passProp("overlap");
    }
    get resize() {
      return this.passProp("resize");
    }
  }
  const showHoverTooltipHost = showTooltip.compute([
    showHoverTooltip
  ], (state) => {
    let tooltips = state.facet(showHoverTooltip);
    if (tooltips.length === 0) return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.map((t2) => {
        var _a2;
        return (_a2 = t2.end) !== null && _a2 !== void 0 ? _a2 : t2.pos;
      })),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow)
    };
  });
  class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = {
        x: 0,
        y: 0,
        target: view.dom,
        time: 0
      };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active.length) return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { view, lastMove } = this;
      let desc = view.docView.nearest(lastMove.target);
      if (!desc) return;
      let pos, side = 1;
      if (desc instanceof WidgetView) {
        pos = desc.posAtStart;
      } else {
        pos = view.posAtCoords(lastMove);
        if (pos == null) return;
        let posCoords = view.coordsAtPos(pos);
        if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;
        let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
        side = lastMove.x < posCoords.left ? -rtl : rtl;
      }
      let open = this.source(view, pos, side);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = {
          pos
        };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result && !(Array.isArray(result) && !result.length)) view.dispatch({
              effects: this.setHover.of(Array.isArray(result) ? result : [
                result
              ])
            });
          }
        }, (e) => logException(view.state, e, "hover tooltip"));
      } else if (open && !(Array.isArray(open) && !open.length)) {
        view.dispatch({
          effects: this.setHover.of(Array.isArray(open) ? open : [
            open
          ])
        });
      }
    }
    get tooltip() {
      let plugin = this.view.plugin(tooltipPlugin);
      let index = plugin ? plugin.manager.tooltips.findIndex((t2) => t2.create == HoverTooltipHost.create) : -1;
      return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
      var _a2, _b;
      this.lastMove = {
        x: event.clientX,
        y: event.clientY,
        target: event.target,
        time: Date.now()
      };
      if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let { active, tooltip } = this;
      if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
        let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
          this.view.dispatch({
            effects: this.setHover.of([])
          });
          this.pending = null;
        }
      }
    }
    mouseleave(event) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      let { active } = this;
      if (active.length) {
        let { tooltip } = this;
        let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
        if (!inTooltip) this.view.dispatch({
          effects: this.setHover.of([])
        });
        else this.watchTooltipLeave(tooltip.dom);
      }
    }
    watchTooltipLeave(tooltip) {
      let watch = (event) => {
        tooltip.removeEventListener("mouseleave", watch);
        if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({
          effects: this.setHover.of([])
        });
      };
      tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  }
  const tooltipMargin = 4;
  function isInTooltip(tooltip, event) {
    let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
    if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
      let arrowRect = arrow.getBoundingClientRect();
      top2 = Math.min(arrowRect.top, top2);
      bottom = Math.max(arrowRect.bottom, bottom);
    }
    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
  }
  function isOverRange(view, from, to, x, y, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;
    let pos = view.posAtCoords({
      x,
      y
    }, false);
    return pos >= from && pos <= to;
  }
  function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return [];
      },
      update(value, tr) {
        if (value.length) {
          if (options.hideOnChange && (tr.docChanged || tr.selection)) value = [];
          else if (options.hideOn) value = value.filter((v) => !options.hideOn(tr, v));
          if (tr.docChanged) {
            let mapped = [];
            for (let tooltip of value) {
              let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
              if (newPos != null) {
                let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
                copy.pos = newPos;
                if (copy.end != null) copy.end = tr.changes.mapPos(copy.end);
                mapped.push(copy);
              }
            }
            value = mapped;
          }
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover)) value = effect.value;
          if (effect.is(closeHoverTooltipEffect)) value = [];
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f)
    });
    return {
      active: hoverState,
      extension: [
        hoverState,
        ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)),
        showHoverTooltipHost
      ]
    };
  }
  function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin) return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  const closeHoverTooltipEffect = StateEffect.define();
  const panelConfig = Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c of configs) {
        topContainer = topContainer || c.topContainer;
        bottomContainer = bottomContainer || c.bottomContainer;
      }
      return {
        topContainer,
        bottomContainer
      };
    }
  });
  function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
  }
  const panelPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p) => p.top));
      this.bottom.sync(this.panels.filter((p) => !p.top));
      for (let p of this.panels) {
        p.dom.classList.add("cm-panel");
        if (p.mount) p.mount();
      }
    }
    update(update) {
      let conf = update.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x) => x);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update) panel.update(update);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p of mount) {
          p.dom.classList.add("cm-panel");
          if (p.mount) p.mount();
        }
      } else {
        for (let p of this.panels) if (p.update) p.update(update);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && {
        top: value.top.scrollMargin(),
        bottom: value.bottom.scrollMargin()
      };
    })
  });
  class PanelGroup {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p of this.panels) if (p.destroy && panels.indexOf(p) < 0) p.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom) curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM) curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses) return;
      for (let cls of this.classes.split(" ")) if (cls) this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" ")) if (cls) this.container.classList.add(cls);
    }
  }
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  const showPanel = Facet.define({
    enables: panelPlugin
  });
  class GutterMarker extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom) {
    }
  }
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  const gutterLineClass = Facet.define();
  const gutterWidgetClass = Facet.define();
  const defaults$1 = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  const activeGutters = Facet.define();
  function gutter(config2) {
    return [
      gutters(),
      activeGutters.of(Object.assign(Object.assign({}, defaults$1), config2))
    ];
  }
  const unfixGutters = Facet.define({
    combine: (values) => values.some((x) => x)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    return result;
  }
  const gutterView = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters) this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
      if (this.updateGutters(update)) {
        let vpA = this.prevViewport, vpB = update.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update.geometryChanged) {
        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      }
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach) this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        if (classSet.length) classSet = [];
        if (Array.isArray(line.type)) {
          let first = true;
          for (let b of line.type) {
            if (b.type == BlockType.Text && first) {
              advanceCursor(lineClasses, classSet, b.from);
              for (let cx of contexts) cx.line(this.view, b, classSet);
              first = false;
            } else if (b.widget) {
              for (let cx of contexts) cx.widget(this.view, b);
            }
          }
        } else if (line.type == BlockType.Text) {
          advanceCursor(lineClasses, classSet, line.from);
          for (let cx of contexts) cx.line(this.view, line, classSet);
        } else if (line.widget) {
          for (let cx of contexts) cx.widget(this.view, line);
        }
      }
      for (let cx of contexts) cx.finish();
      if (detach) this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
      let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
      let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters) if (gutter2.update(update)) change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters) {
          g.dom.remove();
          if (gutters2.indexOf(g) < 0) g.destroy();
        }
        for (let g of gutters2) this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters) view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed) return null;
      return view.textDirection == Direction.LTR ? {
        left: value.dom.offsetWidth * view.scaleX
      } : {
        right: value.dom.offsetWidth * view.scaleX
      };
    })
  });
  function asArray(val) {
    return Array.isArray(val) ? val : [
      val
    ];
  }
  function advanceCursor(cursor2, collect, pos) {
    while (cursor2.value && cursor2.from <= pos) {
      if (cursor2.from == pos) collect.push(cursor2.value);
      cursor2.next();
    }
  }
  class UpdateContext {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    addElement(view, block, markers) {
      let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, height, above, markers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, height, above, markers);
      }
      this.height = block.bottom;
      this.i++;
    }
    line(view, line, extraMarkers) {
      let localMarkers = [];
      advanceCursor(this.cursor, localMarkers, line.from);
      if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine) localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements) return;
      this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
      let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [
        marker
      ] : null;
      for (let cls of view.state.facet(gutterWidgetClass)) {
        let marker2 = cls(view, block.widget, block);
        if (marker2) (markers || (markers = [])).push(marker2);
      }
      if (markers) this.addElement(view, block, markers);
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
  }
  class SingleGutterView {
    constructor(view, config2) {
      this.view = view;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let target = event.target, y;
          if (target != this.dom && this.dom.contains(target)) {
            while (target.parentNode != this.dom) target = target.parentNode;
            let rect = target.getBoundingClientRect();
            y = (rect.top + rect.bottom) / 2;
          } else {
            y = event.clientY;
          }
          let line = view.lineBlockAtHeight(y - view.documentTop);
          if (config2.domEventHandlers[prop](view, line, event)) event.preventDefault();
        });
      }
      this.markers = asArray(config2.markers(view));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [
          config2.initialSpacer(view)
        ]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update) {
      let prevMarkers = this.markers;
      this.markers = asArray(this.config.markers(update.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update);
        if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [
          updated
        ]);
      }
      let vp = update.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
      for (let elt of this.elements) elt.destroy();
    }
  }
  class GutterElement {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height) {
        this.height = height;
        this.dom.style.height = height + "px";
      }
      if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c = marker.elementClass;
          if (c) cls += " " + c;
          for (let i2 = iOld; i2 < this.markers.length; i2++) if (this.markers[i2].compare(marker)) {
            skipTo = i2;
            matched = true;
            break;
          }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker) break;
        if (marker.toDOM) {
          if (matched) domPos = domPos.nextSibling;
          else this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched) iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  }
  function sameMarkers(a, b) {
    if (a.length != b.length) return false;
    for (let i2 = 0; i2 < a.length; i2++) if (!a[i2].compare(b[i2])) return false;
    return true;
  }
  const lineNumberMarkers = Facet.define();
  const lineNumberWidgetMarker = Facet.define();
  const lineNumberConfig = Facet.define({
    combine(values) {
      return combineConfig(values, {
        formatNumber: String,
        domEventHandlers: {}
      }, {
        domEventHandlers(a, b) {
          let result = Object.assign({}, a);
          for (let event in b) {
            let exists = result[event], add2 = b[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
          }
          return result;
        }
      });
    }
  });
  class NumberMarker extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  }
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  const lineNumberGutter = activeGutters.compute([
    lineNumberConfig
  ], (state) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM)) return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: (view, widget, block) => {
      for (let m of view.state.facet(lineNumberWidgetMarker)) {
        let result = m(view, widget, block);
        if (result) return result;
      }
      return null;
    },
    lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
      let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
      return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last = 9;
    while (last < lines) last = last * 10 + 9;
    return last;
  }
  const activeLineGutterMarker = new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  const activeLineGutterHighlighter = gutterLineClass.compute([
    "selection"
  ], (state) => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
      let linePos = state.doc.lineAt(range.head).from;
      if (linePos > last) {
        last = linePos;
        marks.push(activeLineGutterMarker.range(linePos));
      }
    }
    return RangeSet.of(marks);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }
  DefaultBufferLength = 1024;
  let nextPropID = 0;
  class Range {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  }
  NodeProp = class {
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode) throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function") match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [
          this,
          result
        ];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({
    deserialize: (str) => str.split(" ")
  });
  NodeProp.openedBy = new NodeProp({
    deserialize: (str) => str.split(" ")
  });
  NodeProp.group = new NodeProp({
    deserialize: (str) => str.split(" ")
  });
  NodeProp.isolate = new NodeProp({
    deserialize: (value) => {
      if (value && value != "rtl" && value != "ltr" && value != "auto") throw new RangeError("Invalid value for isolate: " + value);
      return value || "auto";
    }
  });
  NodeProp.contextHash = new NodeProp({
    perNode: true
  });
  NodeProp.lookAhead = new NodeProp({
    perNode: true
  });
  NodeProp.mounted = new NodeProp({
    perNode: true
  });
  class MountedTree {
    constructor(tree, overlay, parser) {
      this.tree = tree;
      this.overlay = overlay;
      this.parser = parser;
    }
    static get(tree) {
      return tree && tree.props && tree.props[NodeProp.mounted.id];
    }
  }
  const noProps = /* @__PURE__ */ Object.create(null);
  NodeType = class {
    constructor(name2, props, id, flags = 0) {
      this.name = name2;
      this.props = props;
      this.id = id;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props) for (let src of spec.props) {
        if (!Array.isArray(src)) src = src(type);
        if (src) {
          if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name2) {
      if (typeof name2 == "string") {
        if (this.name == name2) return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name2) > -1 : false;
      }
      return this.id == name2;
    }
    static match(map) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map) for (let name2 of prop.split(" ")) direct[name2] = map[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
          let found = direct[i2 < 0 ? node.name : groups[i2]];
          if (found) return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  NodeSet = class {
    constructor(types2) {
      this.types = types2;
      for (let i2 = 0; i2 < types2.length; i2++) if (types2[i2].id != i2) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    extend(...props) {
      let newTypes = [];
      for (let type of this.types) {
        let newProps = null;
        for (let source of props) {
          let add2 = source(type);
          if (add2) {
            if (!newProps) newProps = Object.assign({}, type.props);
            newProps[add2[0].id] = add2[1];
          }
        }
        newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
      }
      return new NodeSet(newTypes);
    }
  };
  const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  Tree$1 = class Tree2 {
    constructor(type, children, positions, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props) this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = MountedTree.get(this);
      if (mounted && !mounted.overlay) return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children) children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor2 = new TreeCursor(scope);
      cursor2.moveTo(pos, side);
      CachedNode.set(this, cursor2._tree);
      return cursor2;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    resolveStack(pos, side = 0) {
      return stackIterator(this, pos, side);
    }
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
      for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild()) continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);
          if (c.nextSibling()) break;
          if (!c.parent()) return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props) for (let id in this.props) result.push([
        +id,
        this.props[id]
      ]);
      return result;
    }
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree2(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree2(NodeType.none, children, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree$1.empty = new Tree$1(NodeType.none, [], [], 0);
  class FlatBufferCursor {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  }
  class TreeBuffer {
    constructor(buffer, length, set) {
      this.buffer = buffer;
      this.length = length;
      this.set = set;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id = this.buffer[index], endIndex = this.buffer[index + 3];
      let type = this.set.types[id], result = type.name;
      if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
      index += 4;
      if (endIndex == index) return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
        if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
          pick = i2;
          if (dir > 0) break;
        }
      }
      return pick;
    }
    slice(startI, endI, from) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI), len = 0;
      for (let i2 = startI, j = 0; i2 < endI; ) {
        copy[j++] = b[i2++];
        copy[j++] = b[i2++] - from;
        let to = copy[j++] = b[i2++] - from;
        copy[j++] = b[i2++] - startI;
        len = Math.max(len, to);
      }
      return new TreeBuffer(copy, len, this.set);
    }
  }
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent) return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays) for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from) node = parent;
    }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner) return node;
      node = inner;
    }
  }
  class BaseNode {
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
      return matchNodeContext(this.parent, context);
    }
    enterUnfinishedNodesBefore(pos) {
      let scan = this.childBefore(pos), node = this;
      while (scan) {
        let last = scan.lastChild;
        if (!last || last.to != scan.to) break;
        if (last.type.isError && last.from == last.to) {
          node = scan;
          scan = last.prevSibling;
        } else {
          scan = last;
        }
      }
      return node;
    }
    get node() {
      return this;
    }
    get next() {
      return this.parent;
    }
  }
  class TreeNode extends BaseNode {
    constructor(_tree, from, index, _parent) {
      super();
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i2, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i2 != e; i2 += dir) {
          let next = children[i2], start = positions[i2] + parent.from;
          if (!checkSide(side, pos, start, start + next.length)) continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers) continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index > -1) return new BufferNode(new BufferContext(parent, next, i2, start), null, index);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i2, parent);
            let inner = new TreeNode(next, start, i2, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;
        if (parent.index >= 0) i2 = parent.index + dir;
        else i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent) return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent) val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    toString() {
      return this._tree.toString();
    }
  }
  function getChildren(node, type, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild()) return result;
    if (before != null) for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling()) return result;
    }
    for (; ; ) {
      if (after != null && cur2.type.is(after)) return result;
      if (cur2.type.is(type)) result.push(cur2.node);
      if (!cur2.nextSibling()) return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context, i2 = context.length - 1) {
    for (let p = node; i2 >= 0; p = p.parent) {
      if (!p) return false;
      if (!p.type.isAnonymous) {
        if (context[i2] && context[i2] != p.name) return false;
        i2--;
      }
    }
    return true;
  }
  class BufferContext {
    constructor(parent, buffer, index, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start;
    }
  }
  class BufferNode extends BaseNode {
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    constructor(context, _parent, index) {
      super();
      this.context = context;
      this._parent = _parent;
      this.index = index;
      this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers) return null;
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart) return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1];
        children.push(buffer.slice(startI, endI, from));
        positions.push(0);
      }
      return new Tree$1(this.type, children, positions, this.to - this.from);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
  }
  function iterStack(heads) {
    if (!heads.length) return null;
    let pick = 0, picked = heads[0];
    for (let i2 = 1; i2 < heads.length; i2++) {
      let node = heads[i2];
      if (node.from > picked.from || node.to < picked.to) {
        picked = node;
        pick = i2;
      }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next) newHeads[pick] = next;
    else newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
  }
  class StackIterator {
    constructor(heads, node) {
      this.heads = heads;
      this.node = node;
    }
    get next() {
      return iterStack(this.heads);
    }
  }
  function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
      if (scan.index < 0) {
        let parent = scan.parent;
        (layers || (layers = [
          inner
        ])).push(parent.resolve(pos, side));
        scan = parent;
      } else {
        let mount = MountedTree.get(scan.tree);
        if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
          let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
          (layers || (layers = [
            inner
          ])).push(resolveNode(root, pos, side, false));
        }
      }
    }
    return layers ? iterStack(layers) : inner;
  }
  class TreeCursor {
    get name() {
      return this.type.name;
    }
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    yieldNode(node) {
      if (!node) return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      let { start, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start + buffer.buffer[index + 1];
      this.to = start + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node) return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0) return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length) return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length) return false;
        } else {
          for (let i2 = 0; i2 < this.index; i2++) if (buffer.buffer.buffer[i2 + 3] < this.index) return false;
        }
        ({ index, parent } = buffer);
      } else {
        ({ index, _parent: parent } = this._tree);
      }
      for (; parent; { index, _parent: parent } = parent) {
        if (index > -1) for (let i2 = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i2 != e; i2 += dir) {
          let child = parent._tree.children[i2];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
        }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4)) return true;
      for (; ; ) {
        if (this.sibling(dir)) return true;
        if (this.atLastNode(dir) || !this.parent()) return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer) return this._tree;
      let cache = this.bufferNode, result = null, depth = 0;
      if (cache && cache.context == this.buffer) {
        scan: for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent) if (c.index == index) {
            if (index == this.index) return c;
            result = c;
            depth = d + 1;
            break scan;
          }
          index = this.stack[--d];
        }
      }
      for (let i2 = depth; i2 < this.stack.length; i2++) result = new BufferNode(this.buffer, result, this.stack[i2]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous) mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave) leave(this);
          mustLeave = this.type.isAnonymous;
          if (!depth) return;
          if (this.nextSibling()) break;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context) {
      if (!this.buffer) return matchNodeContext(this.node.parent, context);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i2 = context.length - 1, d = this.stack.length - 1; i2 >= 0; d--) {
        if (d < 0) return matchNodeContext(this._tree, context, i2);
        let type = types2[buffer.buffer[this.stack[d]]];
        if (!type.isAnonymous) {
          if (context[i2] && context[i2] != type.name) return false;
          i2--;
        }
      }
      return true;
    }
  }
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
      let { id, start, end, size } = cursor2;
      let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
      while (size < 0) {
        cursor2.next();
        if (size == -1) {
          let node2 = reused[id];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size == -3) {
          contextHash = id;
          return;
        } else if (size == -4) {
          lookAhead = id;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size}`);
        }
      }
      let type = types2[id], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor2.pos - buffer2.size, index = data2.length;
        while (cursor2.pos > endPos) index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor2.pos - size;
        cursor2.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id >= minRepeatType ? id : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor2.pos > endPos) {
          if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
            if (cursor2.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor2.end;
            }
            cursor2.next();
          } else if (depth > 2500) {
            takeFlatNode(start, endPos, localChildren, localPositions);
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type, contextAtStart);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children2, positions2) {
      let nodes = [];
      let nodeCount = 0, stopAt = -1;
      while (cursor2.pos > minPos) {
        let { id, start, end, size } = cursor2;
        if (size > 4) {
          cursor2.next();
        } else if (stopAt > -1 && start < stopAt) {
          break;
        } else {
          if (stopAt < 0) stopAt = end - maxBufferLength;
          nodes.push(id, start, end);
          nodeCount++;
          cursor2.next();
        }
      }
      if (nodeCount) {
        let buffer2 = new Uint16Array(nodeCount * 4);
        let start = nodes[nodes.length - 2];
        for (let i2 = nodes.length - 3, j = 0; i2 >= 0; i2 -= 3) {
          buffer2[j++] = nodes[i2];
          buffer2[j++] = nodes[i2 + 1] - start;
          buffer2[j++] = nodes[i2 + 2] - start;
          buffer2[j++] = j;
        }
        children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
        positions2.push(start - parentStart);
      }
    }
    function makeBalanced(type, contextHash2) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree$1) {
          if (!lastI && last.type == type && last.length == length2) return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i2, from, to, type, lookAhead2, contextHash2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i2) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
      positions2.push(from - base2);
    }
    function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
      if (contextHash2) {
        let pair = [
          NodeProp.contextHash,
          contextHash2
        ];
        props = props ? [
          pair
        ].concat(props) : [
          pair
        ];
      }
      if (lookAhead2 > 25) {
        let pair = [
          NodeProp.lookAhead,
          lookAhead2
        ];
        props = props ? [
          pair
        ].concat(props) : [
          pair
        ];
      }
      return new Tree$1(type, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor2.fork();
      let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = {
        size: 0,
        start: 0,
        skip: 0
      };
      scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart) break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3) localSkipped += 4;
            else break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart2;
        size += nodeSize2;
        skip += localSkipped;
      }
      if (inRepeat < 0 || size == maxSize) {
        result.size = size;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let { id, start, end, size } = cursor2;
      cursor2.next();
      if (size >= 0 && id < minRepeatType) {
        let startIndex = index;
        if (size > 4) {
          let endPos = cursor2.pos - (size - 4);
          while (cursor2.pos > endPos) index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start - bufferStart;
        buffer2[--index] = id;
      } else if (size == -3) {
        contextHash = id;
      } else if (size == -4) {
        lookAhead = id;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor2.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree$1(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  const nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
      size = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree$1)) {
          size = 1;
          break;
        }
        size += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size);
    }
    return size;
  }
  function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i2 = from; i2 < to; i2++) total += nodeSize(balanceType, children[i2]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i2 = from2; i2 < to2; ) {
        let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
        i2++;
        for (; i2 < to2; i2++) {
          let nextSize = nodeSize(balanceType, children2[i2]);
          if (groupSize + nextSize >= maxChild) break;
          groupSize += nextSize;
        }
        if (i2 == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  NodeWeakMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new WeakMap();
    }
    setBuffer(buffer, index, value) {
      let inner = this.map.get(buffer);
      if (!inner) this.map.set(buffer, inner = /* @__PURE__ */ new Map());
      inner.set(index, value);
    }
    getBuffer(buffer, index) {
      let inner = this.map.get(buffer);
      return inner && inner.get(index);
    }
    set(node, value) {
      if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);
      else if (node instanceof TreeNode) this.map.set(node.tree, value);
    }
    get(node) {
      return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
    }
    cursorSet(cursor2, value) {
      if (cursor2.buffer) this.setBuffer(cursor2.buffer.buffer, cursor2.index, value);
      else this.map.set(cursor2.tree, value);
    }
    cursorGet(cursor2) {
      return cursor2.buffer ? this.getBuffer(cursor2.buffer.buffer, cursor2.index) : this.map.get(cursor2.tree);
    }
  };
  class TreeFragment {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [
        new TreeFragment(0, tree.length, tree, 0, false, partial)
      ];
      for (let f of fragments) if (f.to > tree.length) result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length) return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut) result.push(cut);
          if (nextF.to > nextPos) break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
        if (!nextC) break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  }
  Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string") input = new StringInput(input);
      ranges = !ranges ? [
        new Range(0, input.length)
      ] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [
        new Range(0, 0)
      ];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse.advance();
        if (done) return done;
      }
    }
  };
  class StringInput {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  }
  parseMixed = function(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
  };
  class InnerParse {
    constructor(parser, parse, overlay, target, from) {
      this.parser = parser;
      this.parse = parse;
      this.overlay = overlay;
      this.target = target;
      this.from = from;
    }
  }
  function checkRanges(ranges) {
    if (!ranges.length || ranges.some((r) => r.from >= r.to)) throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
  }
  class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
      this.parser = parser;
      this.predicate = predicate;
      this.mounts = mounts;
      this.index = index;
      this.start = start;
      this.target = target;
      this.prev = prev;
      this.depth = 0;
      this.ranges = [];
    }
  }
  const stoppedInner = new NodeProp({
    perNode: true
  });
  class MixedParse {
    constructor(base2, nest, input, fragments, ranges) {
      this.nest = nest;
      this.input = input;
      this.fragments = fragments;
      this.ranges = ranges;
      this.inner = [];
      this.innerDone = 0;
      this.baseTree = null;
      this.stoppedAt = null;
      this.baseParse = base2;
    }
    advance() {
      if (this.baseParse) {
        let done2 = this.baseParse.advance();
        if (!done2) return null;
        this.baseParse = null;
        this.baseTree = done2;
        this.startInner();
        if (this.stoppedAt != null) for (let inner2 of this.inner) inner2.parse.stopAt(this.stoppedAt);
      }
      if (this.innerDone == this.inner.length) {
        let result = this.baseTree;
        if (this.stoppedAt != null) result = new Tree$1(result.type, result.children, result.positions, result.length, result.propValues.concat([
          [
            stoppedInner,
            this.stoppedAt
          ]
        ]));
        return result;
      }
      let inner = this.inner[this.innerDone], done = inner.parse.advance();
      if (done) {
        this.innerDone++;
        let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
        props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
        inner.target.props = props;
      }
      return null;
    }
    get parsedPos() {
      if (this.baseParse) return 0;
      let pos = this.input.length;
      for (let i2 = this.innerDone; i2 < this.inner.length; i2++) {
        if (this.inner[i2].from < pos) pos = Math.min(pos, this.inner[i2].parse.parsedPos);
      }
      return pos;
    }
    stopAt(pos) {
      this.stoppedAt = pos;
      if (this.baseParse) this.baseParse.stopAt(pos);
      else for (let i2 = this.innerDone; i2 < this.inner.length; i2++) this.inner[i2].parse.stopAt(pos);
    }
    startInner() {
      let fragmentCursor = new FragmentCursor(this.fragments);
      let overlay = null;
      let covered = null;
      let cursor2 = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
      scan: for (let nest, isCovered; ; ) {
        let enter = true, range;
        if (this.stoppedAt != null && cursor2.from >= this.stoppedAt) {
          enter = false;
        } else if (fragmentCursor.hasNode(cursor2)) {
          if (overlay) {
            let match = overlay.mounts.find((m) => m.frag.from <= cursor2.from && m.frag.to >= cursor2.to && m.mount.overlay);
            if (match) for (let r of match.mount.overlay) {
              let from = r.from + match.pos, to = r.to + match.pos;
              if (from >= cursor2.from && to <= cursor2.to && !overlay.ranges.some((r2) => r2.from < to && r2.to > from)) overlay.ranges.push({
                from,
                to
              });
            }
          }
          enter = false;
        } else if (covered && (isCovered = checkCover(covered.ranges, cursor2.from, cursor2.to))) {
          enter = isCovered != 2;
        } else if (!cursor2.type.isAnonymous && (nest = this.nest(cursor2, this.input)) && (cursor2.from < cursor2.to || !nest.overlay)) {
          if (!cursor2.tree) materialize(cursor2);
          let oldMounts = fragmentCursor.findMounts(cursor2.from, nest.parser);
          if (typeof nest.overlay == "function") {
            overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor2.from, cursor2.tree, overlay);
          } else {
            let ranges = punchRanges(this.ranges, nest.overlay || (cursor2.from < cursor2.to ? [
              new Range(cursor2.from, cursor2.to)
            ] : []));
            if (ranges.length) checkRanges(ranges);
            if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map((r) => new Range(r.from - cursor2.from, r.to - cursor2.from)) : null, cursor2.tree, ranges.length ? ranges[0].from : cursor2.from));
            if (!nest.overlay) enter = false;
            else if (ranges.length) covered = {
              ranges,
              depth: 0,
              prev: covered
            };
          }
        } else if (overlay && (range = overlay.predicate(cursor2))) {
          if (range === true) range = new Range(cursor2.from, cursor2.to);
          if (range.from < range.to) {
            let last = overlay.ranges.length - 1;
            if (last >= 0 && overlay.ranges[last].to == range.from) overlay.ranges[last] = {
              from: overlay.ranges[last].from,
              to: range.to
            };
            else overlay.ranges.push(range);
          }
        }
        if (enter && cursor2.firstChild()) {
          if (overlay) overlay.depth++;
          if (covered) covered.depth++;
        } else {
          for (; ; ) {
            if (cursor2.nextSibling()) break;
            if (!cursor2.parent()) break scan;
            if (overlay && !--overlay.depth) {
              let ranges = punchRanges(this.ranges, overlay.ranges);
              if (ranges.length) {
                checkRanges(ranges);
                this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r) => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
              }
              overlay = overlay.prev;
            }
            if (covered && !--covered.depth) covered = covered.prev;
          }
        }
      }
    }
  }
  function checkCover(covered, from, to) {
    for (let range of covered) {
      if (range.from >= to) break;
      if (range.to > from) return range.from <= from && range.to >= to ? 2 : 1;
    }
    return 0;
  }
  function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
      let from = buf.buffer[startI + 1];
      nodes.push(buf.slice(startI, endI, from));
      positions.push(from - off);
    }
  }
  function materialize(cursor2) {
    let { node } = cursor2, stack = [];
    let buffer = node.context.buffer;
    do {
      stack.push(cursor2.index);
      cursor2.parent();
    } while (!cursor2.tree);
    let base2 = cursor2.tree, i2 = base2.children.indexOf(buffer);
    let buf = base2.children[i2], b = buf.buffer, newStack = [
      i2
    ];
    function split(startI, endI, type, innerOffset, length, stackPos) {
      let targetI = stack[stackPos];
      let children = [], positions = [];
      sliceBuf(buf, startI, targetI, children, positions, innerOffset);
      let from = b[targetI + 1], to = b[targetI + 2];
      newStack.push(children.length);
      let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();
      children.push(child);
      positions.push(from - innerOffset);
      sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
      return new Tree$1(type, children, positions, length);
    }
    base2.children[i2] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
    for (let index of newStack) {
      let tree = cursor2.tree.children[index], pos = cursor2.tree.positions[index];
      cursor2.yield(new TreeNode(tree, pos + cursor2.from, index, cursor2._tree));
    }
  }
  class StructureCursor {
    constructor(root, offset) {
      this.offset = offset;
      this.done = false;
      this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    moveTo(pos) {
      let { cursor: cursor2 } = this, p = pos - this.offset;
      while (!this.done && cursor2.from < p) {
        if (cursor2.to >= pos && cursor2.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
        else if (!cursor2.next(false)) this.done = true;
      }
    }
    hasNode(cursor2) {
      this.moveTo(cursor2.from);
      if (!this.done && this.cursor.from + this.offset == cursor2.from && this.cursor.tree) {
        for (let tree = this.cursor.tree; ; ) {
          if (tree == cursor2.tree) return true;
          if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree$1) tree = tree.children[0];
          else break;
        }
      }
      return false;
    }
  }
  class FragmentCursor {
    constructor(fragments) {
      var _a2;
      this.fragments = fragments;
      this.curTo = 0;
      this.fragI = 0;
      if (fragments.length) {
        let first = this.curFrag = fragments[0];
        this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
        this.inner = new StructureCursor(first.tree, -first.offset);
      } else {
        this.curFrag = this.inner = null;
      }
    }
    hasNode(node) {
      while (this.curFrag && node.from >= this.curTo) this.nextFrag();
      return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
      var _a2;
      this.fragI++;
      if (this.fragI == this.fragments.length) {
        this.curFrag = this.inner = null;
      } else {
        let frag = this.curFrag = this.fragments[this.fragI];
        this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
        this.inner = new StructureCursor(frag.tree, -frag.offset);
      }
    }
    findMounts(pos, parser) {
      var _a2;
      let result = [];
      if (this.inner) {
        this.inner.cursor.moveTo(pos, 1);
        for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
          let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
          if (mount && mount.parser == parser) {
            for (let i2 = this.fragI; i2 < this.fragments.length; i2++) {
              let frag = this.fragments[i2];
              if (frag.from >= pos2.to) break;
              if (frag.tree == this.curFrag.tree) result.push({
                frag,
                pos: pos2.from - frag.offset,
                mount
              });
            }
          }
        }
      }
      return result;
    }
  }
  function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i2 = 1, j = 0; i2 < outer.length; i2++) {
      let gapFrom = outer[i2 - 1].to, gapTo = outer[i2].from;
      for (; j < current.length; j++) {
        let r = current[j];
        if (r.from >= gapTo) break;
        if (r.to <= gapFrom) continue;
        if (!copy) current = copy = ranges.slice();
        if (r.from < gapFrom) {
          copy[j] = new Range(r.from, gapFrom);
          if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));
        } else if (r.to > gapTo) {
          copy[j--] = new Range(gapTo, r.to);
        } else {
          copy.splice(j--, 1);
        }
      }
    }
    return current;
  }
  function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (; ; ) {
      let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
      let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
      if (inA != inB) {
        let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
        if (start < end) result.push(new Range(start, end));
      }
      pos = Math.min(nextA, nextB);
      if (pos == 1e9) break;
      if (nextA == pos) {
        if (!inA) inA = true;
        else {
          inA = false;
          iA++;
        }
      }
      if (nextB == pos) {
        if (!inB) inB = true;
        else {
          inB = false;
          iB++;
        }
      }
    }
    return result;
  }
  function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
      let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
      let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
      if (mount.overlay) {
        let overlay = mount.overlay.map((r) => new Range(r.from + pos, r.to + pos));
        let changes = findCoverChanges(ranges, overlay, from, to);
        for (let i2 = 0, pos2 = from; ; i2++) {
          let last = i2 == changes.length, end = last ? to : changes[i2].from;
          if (end > pos2) result.push(new TreeFragment(pos2, end, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end || frag.openEnd));
          if (last) break;
          pos2 = changes[i2].to;
        }
      } else {
        result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
      }
    }
    return result;
  }
  let nextTagID = 0;
  class Tag {
    constructor(name2, set, base2, modified) {
      this.name = name2;
      this.set = set;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    toString() {
      let { name: name2 } = this;
      for (let mod of this.modified) if (mod.name) name2 = `${mod.name}(${name2})`;
      return name2;
    }
    static define(nameOrParent, parent) {
      let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
      if (nameOrParent instanceof Tag) parent = nameOrParent;
      if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error("Can not derive from a modified tag");
      let tag = new Tag(name2, [], null, []);
      tag.set.push(tag);
      if (parent) for (let t2 of parent.set) tag.set.push(t2);
      return tag;
    }
    static defineModifier(name2) {
      let mod = new Modifier(name2);
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1) return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  }
  let nextModifierID = 0;
  class Modifier {
    constructor(name2) {
      this.name = name2;
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length) return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray(mods, t2.modified));
      if (exists) return exists;
      let set = [], tag = new Tag(base2.name, set, base2, mods);
      for (let m of mods) m.instances.push(tag);
      let configs = powerSet(mods);
      for (let parent of base2.set) if (!parent.modified.length) for (let config2 of configs) set.push(Modifier.get(parent, config2));
      return tag;
    }
  }
  function sameArray(a, b) {
    return a.length == b.length && a.every((x, i2) => x == b[i2]);
  }
  function powerSet(array) {
    let sets = [
      []
    ];
    for (let i2 = 0; i2 < array.length; i2++) {
      for (let j = 0, e = sets.length; j < e; j++) {
        sets.push(sets[j].concat(array[i2]));
      }
    }
    return sets.sort((a, b) => b.length - a.length);
  }
  styleTags = function(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2)) tags2 = [
        tags2
      ];
      for (let part of prop.split(" ")) if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m) throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length) break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/") throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner) throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
    }
    return ruleNodeProp.add(byName);
  };
  const ruleNodeProp = new NodeProp();
  class Rule {
    constructor(tags2, mode, context, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context;
      this.next = next;
    }
    get opaque() {
      return this.mode == 0;
    }
    get inherit() {
      return this.mode == 1;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  }
  Rule.empty = new Rule([], 2, null);
  function tagHighlighter(tags2, options) {
    let map = /* @__PURE__ */ Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;
      else for (let tag of style.tag) map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value) result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [
      highlighter
    ], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  class HighlightBuilder {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at) this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class) this.span(this.at, to, this.class);
    }
    highlightRange(cursor2, from, to, inheritedClass, highlighters) {
      let { type, from: start, to: end } = cursor2;
      if (start >= to || end <= from) return;
      if (type.isTop) highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
      let cls = inheritedClass;
      let rule = getStyleTags(cursor2) || Rule.empty;
      let tagCls = highlightTags(highlighters, rule.tags);
      if (tagCls) {
        if (cls) cls += " ";
        cls += tagCls;
        if (rule.mode == 1) inheritedClass += (inheritedClass ? " " : "") + tagCls;
      }
      this.startSpan(Math.max(from, start), cls);
      if (rule.opaque) return;
      let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
        let hasChild2 = cursor2.firstChild();
        for (let i2 = 0, pos = start; ; i2++) {
          let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor2.from < rangeTo) {
              this.highlightRange(cursor2, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(rangeTo, cursor2.to), cls);
              if (cursor2.to >= nextPos || !cursor2.nextSibling()) break;
            }
          }
          if (!next || nextPos > to) break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
            this.startSpan(Math.min(to, pos), cls);
          }
        }
        if (hasChild2) cursor2.parent();
      } else if (cursor2.firstChild()) {
        if (mounted) inheritedClass = "";
        do {
          if (cursor2.to <= from) continue;
          if (cursor2.from >= to) break;
          this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor2.to), cls);
        } while (cursor2.nextSibling());
        cursor2.parent();
      }
    }
  }
  function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;
    return rule || null;
  }
  const t = Tag.define;
  const comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
  tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name,
    variableName: t(name),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name),
    labelName: t(name),
    namespace: t(name),
    macroName: t(name),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier("definition"),
    constant: Tag.defineModifier("constant"),
    function: Tag.defineModifier("function"),
    standard: Tag.defineModifier("standard"),
    local: Tag.defineModifier("local"),
    special: Tag.defineModifier("special")
  };
  for (let name2 in tags) {
    let val = tags[name2];
    if (val instanceof Tag) val.name = name2;
  }
  tagHighlighter([
    {
      tag: tags.link,
      class: "tok-link"
    },
    {
      tag: tags.heading,
      class: "tok-heading"
    },
    {
      tag: tags.emphasis,
      class: "tok-emphasis"
    },
    {
      tag: tags.strong,
      class: "tok-strong"
    },
    {
      tag: tags.keyword,
      class: "tok-keyword"
    },
    {
      tag: tags.atom,
      class: "tok-atom"
    },
    {
      tag: tags.bool,
      class: "tok-bool"
    },
    {
      tag: tags.url,
      class: "tok-url"
    },
    {
      tag: tags.labelName,
      class: "tok-labelName"
    },
    {
      tag: tags.inserted,
      class: "tok-inserted"
    },
    {
      tag: tags.deleted,
      class: "tok-deleted"
    },
    {
      tag: tags.literal,
      class: "tok-literal"
    },
    {
      tag: tags.string,
      class: "tok-string"
    },
    {
      tag: tags.number,
      class: "tok-number"
    },
    {
      tag: [
        tags.regexp,
        tags.escape,
        tags.special(tags.string)
      ],
      class: "tok-string2"
    },
    {
      tag: tags.variableName,
      class: "tok-variableName"
    },
    {
      tag: tags.local(tags.variableName),
      class: "tok-variableName tok-local"
    },
    {
      tag: tags.definition(tags.variableName),
      class: "tok-variableName tok-definition"
    },
    {
      tag: tags.special(tags.variableName),
      class: "tok-variableName2"
    },
    {
      tag: tags.definition(tags.propertyName),
      class: "tok-propertyName tok-definition"
    },
    {
      tag: tags.typeName,
      class: "tok-typeName"
    },
    {
      tag: tags.namespace,
      class: "tok-namespace"
    },
    {
      tag: tags.className,
      class: "tok-className"
    },
    {
      tag: tags.macroName,
      class: "tok-macroName"
    },
    {
      tag: tags.propertyName,
      class: "tok-propertyName"
    },
    {
      tag: tags.operator,
      class: "tok-operator"
    },
    {
      tag: tags.comment,
      class: "tok-comment"
    },
    {
      tag: tags.meta,
      class: "tok-meta"
    },
    {
      tag: tags.invalid,
      class: "tok-invalid"
    },
    {
      tag: tags.punctuation,
      class: "tok-punctuation"
    }
  ]);
  var _a;
  const languageDataProp = new NodeProp();
  defineLanguageFacet = function(baseData) {
    return Facet.define({
      combine: baseData ? (values) => values.concat(baseData) : void 0
    });
  };
  sublanguageProp = new NodeProp();
  class Language {
    constructor(data, parser, extraExtensions = [], name2 = "") {
      this.data = data;
      this.name = name2;
      if (!EditorState.prototype.hasOwnProperty("tree")) Object.defineProperty(EditorState.prototype, "tree", {
        get() {
          return syntaxTree(this);
        }
      });
      this.parser = parser;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state, pos, side) => {
          let top2 = topNodeAt(state, pos, side), data2 = top2.type.prop(languageDataProp);
          if (!data2) return [];
          let base2 = state.facet(data2), sub = top2.type.prop(sublanguageProp);
          if (sub) {
            let innerNode = top2.resolve(pos - top2.from, side);
            for (let sublang of sub) if (sublang.test(innerNode, state)) {
              let data3 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data3 : data3.concat(base2);
            }
          }
          return base2;
        })
      ].concat(extraExtensions);
    }
    isActiveAt(state, pos, side = -1) {
      return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    findRegions(state) {
      let lang = state.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [
        {
          from: 0,
          to: state.doc.length
        }
      ];
      if (!lang || !lang.allowsNesting) return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({
            from,
            to: from + tree.length
          });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay) for (let r of mount.overlay) result.push({
              from: r.from + from,
              to: r.to + from
            });
            else result.push({
              from,
              to: from + tree.length
            });
            return;
          } else if (mount.overlay) {
            let size = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size) return;
          }
        }
        for (let i2 = 0; i2 < tree.children.length; i2++) {
          let ch = tree.children[i2];
          if (ch instanceof Tree$1) explore(ch, tree.positions[i2] + from);
        }
      };
      explore(syntaxTree(state), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  }
  Language.setState = StateEffect.define();
  function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
      for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers)) if (node.type.isTop) tree = node;
    }
    return tree;
  }
  LRLanguage = class extends Language {
    constructor(data, parser, name2) {
      super(data, parser, [], name2);
      this.parser = parser;
    }
    static define(spec) {
      let data = defineLanguageFacet(spec.languageData);
      return new LRLanguage(data, spec.parser.configure({
        props: [
          languageDataProp.add((type) => type.isTop ? data : void 0)
        ]
      }), spec.name);
    }
    configure(options, name2) {
      return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
    }
    get allowsNesting() {
      return this.parser.hasWrappers();
    }
  };
  syntaxTree = function(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : Tree$1.empty;
  };
  class DocInput {
    constructor(doc2) {
      this.doc = doc2;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    get length() {
      return this.doc.length;
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);
      else return this.string.slice(from - stringStart, to - stringStart);
    }
  }
  let currentContext = null;
  class ParseContext {
    constructor(parser, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser;
      this.state = state;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser, state, viewport) {
      return new ParseContext(parser, state, [], Tree$1.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length) upto = void 0;
      if (this.tree != Tree$1.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse) this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();
            else return true;
          }
          if (until()) return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); ) fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({
          fromA,
          toA,
          fromB,
          toB
        }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree$1.empty;
        treeLen = 0;
        viewport = {
          from: changes.mapPos(viewport.from, -1),
          to: changes.mapPos(viewport.to, 1)
        };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from < to) skipped.push({
              from,
              to
            });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i2 = 0; i2 < this.skipped.length; i2++) {
        let { from, to } = this.skipped[i2];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i2--, 1);
        }
      }
      if (this.skipped.length >= startLen) return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({
        from,
        to
      });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges) cx.tempSkipped.push(r);
                if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([
                  cx.scheduleOn,
                  until
                ]) : until;
              }
              this.parsedPos = to;
              return new Tree$1(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  }
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [
      {
        fromA: from,
        toA: to,
        fromB: from,
        toB: to
      }
    ]);
  }
  class LanguageState {
    constructor(context) {
      this.context = context;
      this.tree = context.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree) return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto)) newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state) {
      let vpTo = Math.min(3e3, state.doc.length);
      let parseState = ParseContext.create(state.facet(language).parser, state, {
        from: 0,
        to: vpTo
      });
      if (!parseState.work(20, vpTo)) parseState.takeTree();
      return new LanguageState(parseState);
    }
  }
  Language.state = StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e of tr.effects) if (e.is(Language.setState)) return e.value;
      if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  let requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined") requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(() => {
      idle = requestIdleCallback(callback, {
        timeout: 500 - 100
      });
    }, 100);
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
  const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  const parseWorker = ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();
      if (update.docChanged || update.selectionSet) {
        if (this.view.hasFocus) this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working) return;
      let { state } = this.view, field = state.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0) return;
      let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5)) return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({
          effects: Language.setState.of(new LanguageState(field.context))
        });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working) this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: {
      focus() {
        this.scheduleWork();
      }
    }
  });
  const language = Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: (language2) => [
      Language.state,
      parseWorker,
      EditorView.contentAttributes.compute([
        language2
      ], (state) => {
        let lang = state.facet(language2);
        return lang && lang.name ? {
          "data-language": lang.name
        } : {};
      })
    ]
  });
  LanguageSupport = class {
    constructor(language2, support = []) {
      this.language = language2;
      this.support = support;
      this.extension = [
        language2,
        support
      ];
    }
  };
  const indentService = Facet.define();
  const indentUnit = Facet.define({
    combine: (values) => {
      if (!values.length) return "  ";
      let unit = values[0];
      if (!unit || /\S/.test(unit) || Array.from(unit).some((e) => e != unit[0])) throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return unit;
    }
  });
  function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
  }
  function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "	") {
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
      ch = " ";
    }
    for (let i2 = 0; i2 < cols; i2++) result += ch;
    return result;
  }
  function getIndentation(context, pos) {
    if (context instanceof EditorState) context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
      let result = service(context, pos);
      if (result !== void 0) return result;
    }
    let tree = syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
  }
  class IndentContext {
    constructor(state, options = {}) {
      this.state = state;
      this.options = options;
      this.unit = getIndentUnit(state);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos) return {
          text: "",
          from: pos
        };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {
          text: line.text.slice(simulateBreak - line.from),
          from: simulateBreak
        };
        else return {
          text: line.text.slice(0, simulateBreak - line.from),
          from: line.from
        };
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return "";
      let { text, from } = this.lineAt(pos, bias);
      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1) result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1) return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  }
  indentNodeProp = new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = stack.node.enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
      let add2 = [];
      for (let cur2 = inner; cur2 != stack.node; cur2 = cur2.parent) add2.push(cur2);
      for (let i2 = add2.length - 1; i2 >= 0; i2--) stack = {
        node: add2[i2],
        next: stack
      };
    }
    return indentFor(stack, cx, pos);
  }
  function indentFor(stack, cx, pos) {
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let strategy = indentStrategy(cur2.node);
      if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur2));
    }
    return 0;
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy) return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function topIndent() {
    return 0;
  }
  class TreeIndentContext extends IndentContext {
    constructor(base2, pos, context) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.context = context;
    }
    get node() {
      return this.context.node;
    }
    static create(base2, pos, context) {
      return new TreeIndentContext(base2, pos, context);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      return this.baseIndentFor(this.node);
    }
    baseIndentFor(node) {
      let line = this.state.doc.lineAt(node.from);
      for (; ; ) {
        let atBreak = node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;
        if (isParent(atBreak, node)) break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      return indentFor(this.context.next, this.base, this.pos);
    }
  }
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent) if (parent == cur2) return true;
    return false;
  }
  function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken) return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last) return null;
      if (!next.type.isSkipped) {
        if (next.from >= lineEnd) return null;
        let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
        return {
          from: openToken.from,
          to: openToken.to + space
        };
      }
      pos = next.to;
    }
  }
  delimitedIndent = function({ closing: closing2, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing2);
  };
  function delimitedStrategy(context, align, units, closing2, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
  }
  flatIndent = (context) => context.baseIndent;
  continuedIndent = function({ except, units = 1 } = {}) {
    return (context) => {
      let matchExcept = except && except.test(context.textAfter);
      return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
  };
  const DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete")) return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length) return tr;
      let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond) return tr;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart))) return tr;
      let { state } = tr, last = -1, changes = [];
      for (let { head: head2 } of state.selection.ranges) {
        let line2 = state.doc.lineAt(head2);
        if (line2.from == last) continue;
        last = line2.from;
        let indent = getIndentation(state, line2.from);
        if (indent == null) continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state, indent);
        if (cur2 != norm) changes.push({
          from: line2.from,
          to: line2.from + cur2.length,
          insert: norm
        });
      }
      return changes.length ? [
        tr,
        {
          changes,
          sequential: true
        }
      ] : tr;
    });
  }
  const foldService = Facet.define();
  foldNodeProp = new NodeProp();
  foldInside = function(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? {
      from: first.to,
      to: last.type.isError ? node.to : last.from
    } : null;
  };
  function syntaxFolding(state, start, end) {
    let tree = syntaxTree(state);
    if (tree.length < end) return null;
    let stack = tree.resolveStack(end, 1);
    let found = null;
    for (let iter = stack; iter; iter = iter.next) {
      let cur2 = iter.node;
      if (cur2.to <= end || cur2.from > end) continue;
      if (found && cur2.from < start) break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
        let value = prop(cur2, state);
        if (value && value.from <= end && value.from >= start && value.to > end) found = value;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
      let result = service(state, lineStart, lineEnd);
      if (result) return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
  }
  function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? void 0 : {
      from,
      to
    };
  }
  const foldEffect = StateEffect.define({
    map: mapRange
  });
  const unfoldEffect = StateEffect.define({
    map: mapRange
  });
  function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
      if (lines.some((l) => l.from <= head && l.to >= head)) continue;
      lines.push(view.lineBlockAt(head));
    }
    return lines;
  }
  const foldState = StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e of tr.effects) {
        if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
          let { preparePlaceholder } = tr.state.facet(foldConfig);
          let widget = !preparePlaceholder ? foldWidget : Decoration.replace({
            widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))
          });
          folded = folded.update({
            add: [
              widget.range(e.value.from, e.value.to)
            ]
          });
        } else if (e.is(unfoldEffect)) {
          folded = folded.update({
            filter: (from, to) => e.value.from != from || e.value.to != to,
            filterFrom: e.value.from,
            filterTo: e.value.to
          });
        }
      }
      if (tr.selection) {
        let onSelection = false, { head } = tr.selection.main;
        folded.between(head, head, (a, b) => {
          if (a < head && b > head) onSelection = true;
        });
        if (onSelection) folded = folded.update({
          filterFrom: head,
          filterTo: head,
          filter: (a, b) => b <= head || a >= head
        });
      }
      return folded;
    },
    provide: (f) => EditorView.decorations.from(f),
    toJSON(folded, state) {
      let ranges = [];
      folded.between(0, state.doc.length, (from, to) => {
        ranges.push(from, to);
      });
      return ranges;
    },
    fromJSON(value) {
      if (!Array.isArray(value) || value.length % 2) throw new RangeError("Invalid JSON for fold state");
      let ranges = [];
      for (let i2 = 0; i2 < value.length; ) {
        let from = value[i2++], to = value[i2++];
        if (typeof from != "number" || typeof to != "number") throw new RangeError("Invalid JSON for fold state");
        ranges.push(foldWidget.range(from, to));
      }
      return Decoration.set(ranges, true);
    }
  });
  function findFold(state, from, to) {
    var _a2;
    let found = null;
    (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
      if (!found || found.from > from2) found = {
        from: from2,
        to: to2
      };
    });
    return found;
  }
  function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => {
      if (a == from && b == to) found = true;
    });
    return found;
  }
  function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  const foldCode = (view) => {
    for (let line of selectedLines(view)) {
      let range = foldable(view.state, line.from, line.to);
      if (range) {
        view.dispatch({
          effects: maybeEnable(view.state, [
            foldEffect.of(range),
            announceFold(view, range)
          ])
        });
        return true;
      }
    }
    return false;
  };
  const unfoldCode = (view) => {
    if (!view.state.field(foldState, false)) return false;
    let effects = [];
    for (let line of selectedLines(view)) {
      let folded = findFold(view.state, line.from, line.to);
      if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length) view.dispatch({
      effects
    });
    return effects.length > 0;
  };
  function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
  }
  const foldAll = (view) => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length; ) {
      let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
      if (range) effects.push(foldEffect.of(range));
      pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length) view.dispatch({
      effects: maybeEnable(view.state, effects)
    });
    return !!effects.length;
  };
  const unfoldAll = (view) => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size) return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => {
      effects.push(unfoldEffect.of({
        from,
        to
      }));
    });
    view.dispatch({
      effects
    });
    return true;
  };
  const foldKeymap = [
    {
      key: "Ctrl-Shift-[",
      mac: "Cmd-Alt-[",
      run: foldCode
    },
    {
      key: "Ctrl-Shift-]",
      mac: "Cmd-Alt-]",
      run: unfoldCode
    },
    {
      key: "Ctrl-Alt-[",
      run: foldAll
    },
    {
      key: "Ctrl-Alt-]",
      run: unfoldAll
    }
  ];
  const defaultConfig = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "\u2026"
  };
  const foldConfig = Facet.define({
    combine(values) {
      return combineConfig(values, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [
      foldState,
      baseTheme$1$2
    ];
    return result;
  }
  function widgetToDOM(view, prepared) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
      let line = view.lineBlockAt(view.posAtDOM(event.target));
      let folded = findFold(view.state, line.from, line.to);
      if (folded) view.dispatch({
        effects: unfoldEffect.of(folded)
      });
      event.preventDefault();
    };
    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
  }
  const foldWidget = Decoration.replace({
    widget: new class extends WidgetType {
      toDOM(view) {
        return widgetToDOM(view, null);
      }
    }()
  });
  class PreparedFoldWidget extends WidgetType {
    constructor(value) {
      super();
      this.value = value;
    }
    eq(other) {
      return this.value == other.value;
    }
    toDOM(view) {
      return widgetToDOM(view, this.value);
    }
  }
  const foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
  };
  class FoldMarker extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view) {
      if (this.config.markerDOM) return this.config.markerDOM(this.open);
      let span = document.createElement("span");
      span.textContent = this.open ? this.config.openText : this.config.closedText;
      span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span;
    }
  }
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view) {
        this.from = view.viewport.from;
        this.markers = this.buildMarkers(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);
      }
      buildMarkers(view) {
        let builder = new RangeSetBuilder();
        for (let line of view.viewportLineBlocks) {
          let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
          if (mark) builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let { domEventHandlers } = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view) {
          var _a2;
          return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {
          click: (view, line, event) => {
            if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;
            let folded = findFold(view.state, line.from, line.to);
            if (folded) {
              view.dispatch({
                effects: unfoldEffect.of(folded)
              });
              return true;
            }
            let range = foldable(view.state, line.from, line.to);
            if (range) {
              view.dispatch({
                effects: foldEffect.of(range)
              });
              return true;
            }
            return false;
          }
        })
      }),
      codeFolding()
    ];
  }
  const baseTheme$1$2 = EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  class HighlightStyle {
    constructor(specs, options) {
      this.specs = specs;
      let modSpec;
      function def(spec) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
        return cls;
      }
      const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
      const scopeOpt = options.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(specs.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, {
          tag: null
        }))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options.themeType;
    }
    static define(specs, options) {
      return new HighlightStyle(specs, options || {});
    }
  }
  const highlighterFacet = Facet.define();
  const fallbackHighlighter = Facet.define({
    combine(values) {
      return values.length ? [
        values[0]
      ] : null;
    }
  });
  function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options) {
    let ext = [
      treeHighlighter
    ], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module) ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType) ext.push(highlighterFacet.computeN([
      EditorView.darkTheme
    ], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [
        highlighter
      ] : [];
    }));
    else ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  class TreeHighlighter {
    constructor(view) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
      this.decoratedTo = view.viewport.to;
    }
    update(update) {
      let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
      let styleChange = highlighters != getHighlighters(update.startState);
      let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
      if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
        this.decorations = this.decorations.map(update.changes);
        this.decoratedTo = decoratedToMapped;
      } else if (tree != this.tree || update.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update.view, highlighters);
        this.decoratedTo = viewport.to;
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length) return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from, to } of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to2, style) => {
          builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({
            class: style
          })));
        }, from, to);
      }
      return builder.finish();
    }
  }
  const treeHighlighter = Prec.high(ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  const defaultHighlightStyle = HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#404740"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [
        tags.atom,
        tags.bool,
        tags.url,
        tags.contentSeparator,
        tags.labelName
      ],
      color: "#219"
    },
    {
      tag: [
        tags.literal,
        tags.inserted
      ],
      color: "#164"
    },
    {
      tag: [
        tags.string,
        tags.deleted
      ],
      color: "#a11"
    },
    {
      tag: [
        tags.regexp,
        tags.escape,
        tags.special(tags.string)
      ],
      color: "#e40"
    },
    {
      tag: tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [
        tags.typeName,
        tags.namespace
      ],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [
        tags.special(tags.variableName),
        tags.macroName
      ],
      color: "#256"
    },
    {
      tag: tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  const baseTheme$3 = EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: "#328c8252"
    },
    "&.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bb555544"
    }
  });
  const DefaultScanDist = 1e4, DefaultBrackets = "()[]{}";
  const bracketMatchingConfig = Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  const matchingMark = Decoration.mark({
    class: "cm-matchingBracket"
  }), nonmatchingMark = Decoration.mark({
    class: "cm-nonmatchingBracket"
  });
  function defaultRenderMatch(match) {
    let decorations2 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end) decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  const bracketMatchingState = StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection) return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range of tr.state.selection.ranges) {
        if (!range.empty) continue;
        let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
        if (match) decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  const bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme$3
  ];
  function bracketMatching(config2 = {}) {
    return [
      bracketMatchingConfig.of(config2),
      bracketMatchingUnique
    ];
  }
  bracketMatchingHandle = new NodeProp();
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp) return byProp;
    if (node.name.length == 1) {
      let index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [
        brackets[index + dir]
      ];
    }
    return null;
  }
  function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
  }
  function matchBrackets(state, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches = matchingNodes(cur2.type, dir, brackets);
      if (matches && cur2.from < cur2.to) {
        let handle = findHandle(cur2);
        if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
      }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = {
      from: handle.from,
      to: handle.to
    };
    let depth = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to))) do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return {
            start: firstToken,
            end: endHandle ? {
              from: endHandle.from,
              to: endHandle.to
            } : void 0,
            matched: true
          };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? {
                from: endHandle.from,
                to: endHandle.to
              } : void 0,
              matched: false
            };
          }
          depth--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
    return {
      start: firstToken,
      matched: false
    };
  }
  function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0) return null;
    let startToken = {
      from: dir < 0 ? pos - 1 : pos,
      to: dir > 0 ? pos + 1 : pos
    };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text = iter.value;
      if (dir < 0) distance += text.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text[pos2]);
        if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType) continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return {
            start: startToken,
            end: {
              from: basePos + pos2,
              to: basePos + pos2 + 1
            },
            matched: found >> 1 == bracket2 >> 1
          };
        } else {
          depth--;
        }
      }
      if (dir > 0) distance += text.length;
    }
    return iter.done ? {
      start: startToken,
      matched: false
    } : null;
  }
  const noTokens = /* @__PURE__ */ Object.create(null);
  const typeArray = [
    NodeType.none
  ];
  const warned = [];
  const byTag = /* @__PURE__ */ Object.create(null);
  const defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name2] of [
    [
      "variable",
      "variableName"
    ],
    [
      "variable-2",
      "variableName.special"
    ],
    [
      "string-2",
      "string.special"
    ],
    [
      "def",
      "variableName.definition"
    ],
    [
      "tag",
      "tagName"
    ],
    [
      "attribute",
      "attributeName"
    ],
    [
      "type",
      "typeName"
    ],
    [
      "builtin",
      "variableName.standard"
    ],
    [
      "qualifier",
      "modifier"
    ],
    [
      "error",
      "invalid"
    ],
    [
      "header",
      "heading"
    ],
    [
      "property",
      "propertyName"
    ]
  ]) defaultTable[legacyName] = createTokenType(noTokens, name2);
  function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1) return;
    warned.push(part);
    console.warn(msg);
  }
  function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name3 of tagStr.split(" ")) {
      let found = [];
      for (let part of name3.split(".")) {
        let value = extra[part] || tags[part];
        if (!value) {
          warnForPart(part, `Unknown highlighting tag ${part}`);
        } else if (typeof value == "function") {
          if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);
          else found = found.map(value);
        } else {
          if (found.length) warnForPart(part, `Tag ${part} used as modifier`);
          else found = Array.isArray(value) ? value : [
            value
          ];
        }
      }
      for (let tag of found) tags$1.push(tag);
    }
    if (!tags$1.length) return 0;
    let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t2) => t2.id);
    let known = byTag[key];
    if (known) return known.id;
    let type = byTag[key] = NodeType.define({
      id: typeArray.length,
      name: name2,
      props: [
        styleTags({
          [name2]: tags$1
        })
      ]
    });
    typeArray.push(type);
    return type.id;
  }
  ({
    rtl: Decoration.mark({
      class: "cm-iso",
      inclusive: true,
      attributes: {
        dir: "rtl"
      },
      bidiIsolate: Direction.RTL
    }),
    ltr: Decoration.mark({
      class: "cm-iso",
      inclusive: true,
      attributes: {
        dir: "ltr"
      },
      bidiIsolate: Direction.LTR
    }),
    auto: Decoration.mark({
      class: "cm-iso",
      inclusive: true,
      attributes: {
        dir: "auto"
      },
      bidiIsolate: null
    })
  });
  const toggleComment = (target) => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({ state, dispatch }) => {
      if (state.readOnly) return false;
      let tr = f(option, state);
      if (!tr) return false;
      dispatch(state.update(tr));
      return true;
    };
  }
  const toggleLineComment = command(changeLineComment, 0);
  const toggleBlockComment = command(changeBlockComment, 0);
  const toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  const SearchMargin = 50;
  function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: {
          pos: from - spaceBefore,
          margin: spaceBefore && 1
        },
        close: {
          pos: to + spaceAfter,
          margin: spaceAfter && 1
        }
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state.sliceDoc(from, to);
    } else {
      startText = state.sliceDoc(from, from + SearchMargin);
      endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
      let fromLine = state.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
      if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
      let last = ranges.length - 1;
      if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;
      else ranges.push({
        from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length,
        to: toLine.to
      });
    }
    return ranges;
  }
  function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map((r) => getConfig(state, r.from).block);
    if (!tokens.every((c) => c)) return null;
    let comments = ranges.map((r, i2) => findBlockComment(state, tokens[i2], r.from, r.to));
    if (option != 2 && !comments.every((c) => c)) {
      return {
        changes: state.changes(ranges.map((range, i2) => {
          if (comments[i2]) return [];
          return [
            {
              from: range.from,
              insert: tokens[i2].open + " "
            },
            {
              from: range.to,
              insert: " " + tokens[i2].close
            }
          ];
        }))
      };
    } else if (option != 1 && comments.some((c) => c)) {
      let changes = [];
      for (let i2 = 0, comment2; i2 < comments.length; i2++) if (comment2 = comments[i2]) {
        let token = tokens[i2], { open, close } = comment2;
        changes.push({
          from: open.pos - token.open.length,
          to: open.pos + open.margin
        }, {
          from: close.pos - close.margin,
          to: close.pos + token.close.length
        });
      }
      return {
        changes
      };
    }
    return null;
  }
  function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      let token = getConfig(state, from).line;
      if (!token) continue;
      for (let pos = from; pos <= to; ) {
        let line = state.doc.lineAt(pos);
        if (line.from > prevLine && (from == to || to > line.from)) {
          prevLine = line.from;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent) minIndent = indent;
          lines.push({
            line,
            comment: comment2,
            token,
            indent,
            empty: empty2,
            single: false
          });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i2 = startI; i2 < lines.length; i2++) if (lines[i2].indent < lines[i2].line.text.length) lines[i2].indent = minIndent;
      }
      if (lines.length == startI + 1) lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line, token, indent, empty: empty2, single } of lines) if (single || !empty2) changes.push({
        from: line.from + indent,
        insert: token + " "
      });
      let changeSet = state.changes(changes);
      return {
        changes: changeSet,
        selection: state.selection.map(changeSet, 1)
      };
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines) if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ") to++;
        changes.push({
          from,
          to
        });
      }
      return {
        changes
      };
    }
    return null;
  }
  const fromHistory = Annotation.define();
  const isolateHistory = Annotation.define();
  const invertedEffects = Facet.define();
  const historyConfig = Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500,
        joinToEvent: (_t, isAdjacent2) => isAdjacent2
      }, {
        minDepth: Math.max,
        newGroupDelay: Math.min,
        joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
      });
    }
  });
  const historyField_ = StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
        let other = from == 0 ? state.undone : state.done;
        if (item) other = updateBranch(other, other.length, config2.minDepth, item);
        else other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before") state = state.isolate();
      if (tr.annotation(Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
      if (event) state = state.addChanges(event, time, userEvent, config2, tr);
      else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after") state = state.isolate();
      return state;
    },
    toJSON(value) {
      return {
        done: value.done.map((e) => e.toJSON()),
        undone: value.undone.map((e) => e.toJSON())
      };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e, view) {
          let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
          if (!command2) return false;
          e.preventDefault();
          return command2(view);
        }
      })
    ];
  }
  function cmd(side, selection2) {
    return function({ state, dispatch }) {
      if (!selection2 && state.readOnly) return false;
      let historyState = state.field(historyField_, false);
      if (!historyState) return false;
      let tr = historyState.pop(side, state, selection2);
      if (!tr) return false;
      dispatch(tr);
      return true;
    };
  }
  const undo = cmd(0, false);
  const redo = cmd(1, false);
  const undoSelection = cmd(0, true);
  const redoSelection = cmd(1, true);
  class HistEvent {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection2) {
      let effects = none$1;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length) effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty) return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none$1);
    }
    static selection(selections) {
      return new HistEvent(void 0, none$1, void 0, void 0, selections);
    }
  }
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i2 = 0; i2 < ranges.length; ) {
        let from = ranges[i2++], to = ranges[i2++];
        if (t2 >= from && f <= to) isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i2) => r.empty != b.ranges[i2].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  const none$1 = [];
  const MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection2) {
    if (!branch.length) {
      return [
        HistEvent.selection([
          selection2
        ])
      ];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection2)) return branch;
      sels.push(selection2);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length) return branch;
    let length = branch.length, selections = none$1;
    while (length) {
      let event = mapEvent(branch[length - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [
      HistEvent.selection(selections)
    ] : none$1;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none$1, extraSelections);
    if (!event.changes) return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  const joinableUserEvent = /^(input\.type|delete)($|\.)/;
  class HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, config2, tr) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$1));
      } else {
        done = updateBranch(done, done.length, config2.minDepth, event);
      }
      return new HistoryState(done, none$1, time, userEvent);
    }
    addSelection(selection2, time, userEvent, newGroupDelay) {
      let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$1;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2)) return this;
      return new HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0) return null;
      let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
      if (onlySelection && event.selectionsAfter.length) {
        return state.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({
            side,
            rest: popSelection(branch),
            selection: selection2
          }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none$1 : branch.slice(0, branch.length - 1);
        if (event.mapped) rest = addMappingToBranch(rest, event.mapped);
        return state.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({
            side,
            rest,
            selection: selection2
          }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  }
  HistoryState.empty = new HistoryState(none$1, none$1);
  const historyKeymap = [
    {
      key: "Mod-z",
      run: undo,
      preventDefault: true
    },
    {
      key: "Mod-y",
      mac: "Mod-Shift-z",
      run: redo,
      preventDefault: true
    },
    {
      linux: "Ctrl-Shift-z",
      run: redo,
      preventDefault: true
    },
    {
      key: "Mod-u",
      run: undoSelection,
      preventDefault: true
    },
    {
      key: "Alt-u",
      mac: "Mod-Shift-u",
      run: redoSelection,
      preventDefault: true
    }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state, selection2) {
    return state.update({
      selection: selection2,
      scrollIntoView: true,
      userEvent: "select"
    });
  }
  function moveSel({ state, dispatch }, how) {
    let selection2 = updateSel(state.selection, how);
    if (selection2.eq(state.selection, true)) return false;
    dispatch(setSel(state, selection2));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp)) return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state, start, forward) {
    let pos = syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next) break;
      if (interestingNode(state, next, bracketProp)) pos = next;
      else at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;
    else newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  const cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  const cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function cursorByLine(view, forward) {
    return moveSel(view, (range) => {
      if (!range.empty) return rangeEnd(range, forward);
      let moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  const cursorLineUp = (view) => cursorByLine(view, false);
  const cursorLineDown = (view) => cursorByLine(view, true);
  function pageInfo(view) {
    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
      for (let source of view.state.facet(EditorView.scrollMargins)) {
        let margins = source(view);
        if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
        if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
      }
      height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    } else {
      height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return {
      marginTop,
      marginBottom,
      selfScroll,
      height: Math.max(view.defaultLineHeight, height - 5)
    };
  }
  function cursorByPage(view, forward) {
    let page = pageInfo(view);
    let { state } = view, selection2 = updateSel(state.selection, (range) => {
      return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
    });
    if (selection2.eq(state.selection)) return false;
    let effect;
    if (page.selfScroll) {
      let startPos = view.coordsAtPos(state.selection.main.head);
      let scrollRect = view.scrollDOM.getBoundingClientRect();
      let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
      if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = EditorView.scrollIntoView(selection2.main.head, {
        y: "start",
        yMargin: startPos.top - scrollTop
      });
    }
    view.dispatch(setSel(state, selection2), {
      effects: effect
    });
    return true;
  }
  const cursorPageUp = (view) => cursorByPage(view, false);
  const cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start.head != line.from + space) moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  const cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
  const cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
  const cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  const cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  const cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
  const cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
  function toMatchingBracket(state, dispatch, extend2) {
    let found = false, selection2 = updateSel(state.selection, (range) => {
      let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
      if (!matching || !matching.end) return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return EditorSelection.cursor(head);
    });
    if (!found) return false;
    dispatch(setSel(state, selection2));
    return true;
  }
  const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch);
  function extendSel(target, how) {
    let selection2 = updateSel(target.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
    });
    if (selection2.eq(target.state.selection)) return false;
    target.dispatch(setSel(target.state, selection2));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range) => view.moveByChar(range, forward));
  }
  const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range) => view.moveByGroup(range, forward));
  }
  const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  const selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  const selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function selectByLine(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward));
  }
  const selectLineUp = (view) => selectByLine(view, false);
  const selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
  }
  const selectPageUp = (view) => selectByPage(view, false);
  const selectPageDown = (view) => selectByPage(view, true);
  const selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
  const selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
  const selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
  const selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
  const selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
  const selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
  const cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, {
      anchor: 0
    }));
    return true;
  };
  const cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, {
      anchor: state.doc.length
    }));
    return true;
  };
  const selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, {
      anchor: state.selection.main.anchor,
      head: 0
    }));
    return true;
  };
  const selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, {
      anchor: state.selection.main.anchor,
      head: state.doc.length
    }));
    return true;
  };
  const selectAll = ({ state, dispatch }) => {
    dispatch(state.update({
      selection: {
        anchor: 0,
        head: state.doc.length
      },
      userEvent: "select"
    }));
    return true;
  };
  const selectLine = ({ state, dispatch }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({
      selection: EditorSelection.create(ranges),
      userEvent: "select"
    }));
    return true;
  };
  const selectParentSyntax = ({ state, dispatch }) => {
    let selection2 = updateSel(state.selection, (range) => {
      let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
      if (range.empty) {
        let stackBefore = tree.resolveStack(range.from, -1);
        if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;
      }
      for (let cur2 = stack; cur2; cur2 = cur2.next) {
        let { node } = cur2;
        if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur2.next) return EditorSelection.range(node.to, node.from);
      }
      return range;
    });
    if (selection2.eq(state.selection)) return false;
    dispatch(setSel(state, selection2));
    return true;
  };
  const simplifySelection = ({ state, dispatch }) => {
    let cur2 = state.selection, selection2 = null;
    if (cur2.ranges.length > 1) selection2 = EditorSelection.create([
      cur2.main
    ]);
    else if (!cur2.main.empty) selection2 = EditorSelection.create([
      EditorSelection.cursor(cur2.main.head)
    ]);
    if (!selection2) return false;
    dispatch(setSel(state, selection2));
    return true;
  };
  function deleteBy(target, by) {
    if (target.state.readOnly) return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange((range) => {
      let { from, to } = range;
      if (from == to) {
        let towards = by(range);
        if (towards < from) {
          event = "delete.backward";
          towards = skipAtomic(target, towards, false);
        } else if (towards > from) {
          event = "delete.forward";
          towards = skipAtomic(target, towards, true);
        }
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      } else {
        from = skipAtomic(target, from, false);
        to = skipAtomic(target, to, true);
      }
      return from == to ? {
        range
      } : {
        changes: {
          from,
          to
        },
        range: EditorSelection.cursor(from, from < range.head ? -1 : 1)
      };
    });
    if (changes.changes.empty) return false;
    target.dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: event,
      effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
    }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView) for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target))) ranges.between(pos, pos, (from, to) => {
      if (from < pos && to > pos) pos = forward ? to : from;
    });
    return pos;
  }
  const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	") return pos - 1;
      let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
      for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++) pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;
      else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
  });
  const deleteCharBackward = (view) => deleteByChar(view, false, true);
  const deleteCharForward = (view) => deleteByChar(view, true, false);
  const deleteByGroup = (target, forward) => deleteBy(target, (range) => {
    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat) break;
      if (nextChar2 != " " || pos != range.head) cat = nextCat;
      pos = next;
    }
    return pos;
  });
  const deleteGroupBackward = (target) => deleteByGroup(target, false);
  const deleteGroupForward = (target) => deleteByGroup(target, true);
  const deleteToLineEnd = (view) => deleteBy(view, (range) => {
    let lineEnd = view.lineBlockAt(range.head).to;
    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
  });
  const deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, false).head;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
  });
  const deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
    let lineStart = view.moveToLineBoundary(range, true).head;
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
  });
  const splitLine = ({ state, dispatch }) => {
    if (state.readOnly) return false;
    let changes = state.changeByRange((range) => {
      return {
        changes: {
          from: range.from,
          to: range.to,
          insert: Text$1.of([
            "",
            ""
          ])
        },
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "input"
    }));
    return true;
  };
  const transposeChars = ({ state, dispatch }) => {
    if (state.readOnly) return false;
    let changes = state.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state.doc.length) return {
        range
      };
      let pos = range.from, line = state.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: {
          from,
          to,
          insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
        },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty) return false;
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "move.character"
    }));
    return true;
  };
  function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
      let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
      if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range);
      } else {
        blocks.push({
          from: startLine.from,
          to: endLine.to,
          ranges: [
            range
          ]
        });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state, dispatch, forward) {
    if (state.readOnly) return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward ? block.to == state.doc.length : block.from == 0) continue;
      let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size = nextLine.length + 1;
      if (forward) {
        changes.push({
          from: block.to,
          to: nextLine.to
        }, {
          from: block.from,
          insert: nextLine.text + state.lineBreak
        });
        for (let r of block.ranges) ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
      } else {
        changes.push({
          from: nextLine.from,
          to: block.from
        }, {
          from: block.to,
          insert: state.lineBreak + nextLine.text
        });
        for (let r of block.ranges) ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
      }
    }
    if (!changes.length) return false;
    dispatch(state.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
  const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
  function copyLine(state, dispatch, forward) {
    if (state.readOnly) return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
      if (forward) changes.push({
        from: block.from,
        insert: state.doc.slice(block.from, block.to) + state.lineBreak
      });
      else changes.push({
        from: block.to,
        insert: state.lineBreak + state.doc.slice(block.from, block.to)
      });
    }
    dispatch(state.update({
      changes,
      scrollIntoView: true,
      userEvent: "input.copyline"
    }));
    return true;
  }
  const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
  const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
  const deleteLine = (view) => {
    if (view.state.readOnly) return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
      if (from > 0) from--;
      else if (to < state.doc.length) to++;
      return {
        from,
        to
      };
    }));
    let selection2 = updateSel(state.selection, (range) => {
      let dist2 = void 0;
      if (view.lineWrapping) {
        let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
        if (pos) dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
      }
      return view.moveVertically(range, true, dist2);
    }).map(changes);
    view.dispatch({
      changes,
      selection: selection2,
      scrollIntoView: true,
      userEvent: "delete.line"
    });
    return true;
  };
  function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {
      from: pos,
      to: pos
    };
    let context = syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from))) return {
      from: before.to,
      to: after.from
    };
    return null;
  }
  const insertNewlineAndIndent = newlineAndIndent(false);
  const insertBlankLine = newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
      if (state.readOnly) return false;
      let changes = state.changeByRange((range) => {
        let { from, to } = range, line = state.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state, from);
        if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
        let cx = new IndentContext(state, {
          simulateBreak: from,
          simulateDoubleBreak: !!explode
        });
        let indent = getIndentation(cx, from);
        if (indent == null) indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
        while (to < line.to && /\s/.test(line.text[to - line.from])) to++;
        if (explode) ({ from, to } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
        let insert2 = [
          "",
          indentString(state, indent)
        ];
        if (explode) insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
        return {
          changes: {
            from,
            to,
            insert: Text$1.of(insert2)
          },
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch(state.update(changes, {
        scrollIntoView: true,
        userEvent: "input"
      }));
      return true;
    };
  }
  function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange((range) => {
      let changes = [];
      for (let pos = range.from; pos <= range.to; ) {
        let line = state.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  const indentSelection = ({ state, dispatch }) => {
    if (state.readOnly) return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context = new IndentContext(state, {
      overrideIndentation: (start) => {
        let found = updated[start];
        return found == null ? -1 : found;
      }
    });
    let changes = changeBySelectedLine(state, (line, changes2, range) => {
      let indent = getIndentation(context, line.from);
      if (indent == null) return;
      if (!/\S/.test(line.text)) indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur2 != norm || range.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({
          from: line.from,
          to: line.from + cur2.length,
          insert: norm
        });
      }
    });
    if (!changes.changes.empty) dispatch(state.update(changes, {
      userEvent: "indent"
    }));
    return true;
  };
  const indentMore = ({ state, dispatch }) => {
    if (state.readOnly) return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      changes.push({
        from: line.from,
        insert: state.facet(indentUnit)
      });
    }), {
      userEvent: "input.indent"
    }));
    return true;
  };
  const indentLess = ({ state, dispatch }) => {
    if (state.readOnly) return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space) return;
      let col = countColumn(space, state.tabSize), keep = 0;
      let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
      while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep)) keep++;
      changes.push({
        from: line.from + keep,
        to: line.from + space.length,
        insert: insert2.slice(keep)
      });
    }), {
      userEvent: "delete.dedent"
    }));
    return true;
  };
  const toggleTabFocusMode = (view) => {
    view.setTabFocusMode();
    return true;
  };
  const emacsStyleKeymap = [
    {
      key: "Ctrl-b",
      run: cursorCharLeft,
      shift: selectCharLeft,
      preventDefault: true
    },
    {
      key: "Ctrl-f",
      run: cursorCharRight,
      shift: selectCharRight
    },
    {
      key: "Ctrl-p",
      run: cursorLineUp,
      shift: selectLineUp
    },
    {
      key: "Ctrl-n",
      run: cursorLineDown,
      shift: selectLineDown
    },
    {
      key: "Ctrl-a",
      run: cursorLineStart,
      shift: selectLineStart
    },
    {
      key: "Ctrl-e",
      run: cursorLineEnd,
      shift: selectLineEnd
    },
    {
      key: "Ctrl-d",
      run: deleteCharForward
    },
    {
      key: "Ctrl-h",
      run: deleteCharBackward
    },
    {
      key: "Ctrl-k",
      run: deleteToLineEnd
    },
    {
      key: "Ctrl-Alt-h",
      run: deleteGroupBackward
    },
    {
      key: "Ctrl-o",
      run: splitLine
    },
    {
      key: "Ctrl-t",
      run: transposeChars
    },
    {
      key: "Ctrl-v",
      run: cursorPageDown
    }
  ];
  const standardKeymap = [
    {
      key: "ArrowLeft",
      run: cursorCharLeft,
      shift: selectCharLeft,
      preventDefault: true
    },
    {
      key: "Mod-ArrowLeft",
      mac: "Alt-ArrowLeft",
      run: cursorGroupLeft,
      shift: selectGroupLeft,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowLeft",
      run: cursorLineBoundaryLeft,
      shift: selectLineBoundaryLeft,
      preventDefault: true
    },
    {
      key: "ArrowRight",
      run: cursorCharRight,
      shift: selectCharRight,
      preventDefault: true
    },
    {
      key: "Mod-ArrowRight",
      mac: "Alt-ArrowRight",
      run: cursorGroupRight,
      shift: selectGroupRight,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowRight",
      run: cursorLineBoundaryRight,
      shift: selectLineBoundaryRight,
      preventDefault: true
    },
    {
      key: "ArrowUp",
      run: cursorLineUp,
      shift: selectLineUp,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowUp",
      run: cursorDocStart,
      shift: selectDocStart
    },
    {
      mac: "Ctrl-ArrowUp",
      run: cursorPageUp,
      shift: selectPageUp
    },
    {
      key: "ArrowDown",
      run: cursorLineDown,
      shift: selectLineDown,
      preventDefault: true
    },
    {
      mac: "Cmd-ArrowDown",
      run: cursorDocEnd,
      shift: selectDocEnd
    },
    {
      mac: "Ctrl-ArrowDown",
      run: cursorPageDown,
      shift: selectPageDown
    },
    {
      key: "PageUp",
      run: cursorPageUp,
      shift: selectPageUp
    },
    {
      key: "PageDown",
      run: cursorPageDown,
      shift: selectPageDown
    },
    {
      key: "Home",
      run: cursorLineBoundaryBackward,
      shift: selectLineBoundaryBackward,
      preventDefault: true
    },
    {
      key: "Mod-Home",
      run: cursorDocStart,
      shift: selectDocStart
    },
    {
      key: "End",
      run: cursorLineBoundaryForward,
      shift: selectLineBoundaryForward,
      preventDefault: true
    },
    {
      key: "Mod-End",
      run: cursorDocEnd,
      shift: selectDocEnd
    },
    {
      key: "Enter",
      run: insertNewlineAndIndent,
      shift: insertNewlineAndIndent
    },
    {
      key: "Mod-a",
      run: selectAll
    },
    {
      key: "Backspace",
      run: deleteCharBackward,
      shift: deleteCharBackward
    },
    {
      key: "Delete",
      run: deleteCharForward
    },
    {
      key: "Mod-Backspace",
      mac: "Alt-Backspace",
      run: deleteGroupBackward
    },
    {
      key: "Mod-Delete",
      mac: "Alt-Delete",
      run: deleteGroupForward
    },
    {
      mac: "Mod-Backspace",
      run: deleteLineBoundaryBackward
    },
    {
      mac: "Mod-Delete",
      run: deleteLineBoundaryForward
    }
  ].concat(emacsStyleKeymap.map((b) => ({
    mac: b.key,
    run: b.run,
    shift: b.shift
  })));
  const defaultKeymap = [
    {
      key: "Alt-ArrowLeft",
      mac: "Ctrl-ArrowLeft",
      run: cursorSyntaxLeft,
      shift: selectSyntaxLeft
    },
    {
      key: "Alt-ArrowRight",
      mac: "Ctrl-ArrowRight",
      run: cursorSyntaxRight,
      shift: selectSyntaxRight
    },
    {
      key: "Alt-ArrowUp",
      run: moveLineUp
    },
    {
      key: "Shift-Alt-ArrowUp",
      run: copyLineUp
    },
    {
      key: "Alt-ArrowDown",
      run: moveLineDown
    },
    {
      key: "Shift-Alt-ArrowDown",
      run: copyLineDown
    },
    {
      key: "Escape",
      run: simplifySelection
    },
    {
      key: "Mod-Enter",
      run: insertBlankLine
    },
    {
      key: "Alt-l",
      mac: "Ctrl-l",
      run: selectLine
    },
    {
      key: "Mod-i",
      run: selectParentSyntax,
      preventDefault: true
    },
    {
      key: "Mod-[",
      run: indentLess
    },
    {
      key: "Mod-]",
      run: indentMore
    },
    {
      key: "Mod-Alt-\\",
      run: indentSelection
    },
    {
      key: "Shift-Mod-k",
      run: deleteLine
    },
    {
      key: "Shift-Mod-\\",
      run: cursorMatchingBracket
    },
    {
      key: "Mod-/",
      run: toggleComment
    },
    {
      key: "Alt-A",
      run: toggleBlockComment
    },
    {
      key: "Ctrl-m",
      mac: "Shift-Alt-m",
      run: toggleTabFocusMode
    }
  ].concat(standardKeymap);
  const indentWithTab = {
    key: "Tab",
    run: indentMore,
    shift: indentLess
  };
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string") elt = document.createElement(elt);
    var i2 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
        var value = next[name2];
        if (typeof value == "string") elt.setAttribute(name2, value);
        else if (value != null) elt[name2] = value;
      }
      i2++;
    }
    for (; i2 < arguments.length; i2++) add(elt, arguments[i2]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) ;
    else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i2 = 0; i2 < child.length; i2++) add(elt, child[i2]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }
  const basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
  class SearchCursor {
    constructor(text, query, from = 0, to = text.length, normalize, test) {
      this.test = test;
      this.value = {
        from: 0,
        to: 0
      };
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text.iterRange(from, to);
      this.bufferStart = from;
      this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done) return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length) this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        if (norm.length) for (let i2 = 0, pos = start; ; i2++) {
          let code2 = norm.charCodeAt(i2);
          let match = this.match(code2, pos, this.bufferPos + this.bufferStart);
          if (i2 == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start && i2 < str.length && str.charCodeAt(i2) == code2) pos++;
        }
      }
    }
    match(code2, pos, end) {
      let match = null;
      for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
        let index = this.matches[i2], keep = false;
        if (this.query.charCodeAt(index) == code2) {
          if (index == this.query.length - 1) {
            match = {
              from: this.matches[i2 + 1],
              to: end
            };
          } else {
            this.matches[i2]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i2, 2);
          i2 -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code2) {
        if (this.query.length == 1) match = {
          from: pos,
          to: end
        };
        else this.matches.push(1, pos);
      }
      if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;
      return match;
    }
  }
  if (typeof Symbol != "undefined") SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
  const empty = {
    from: -1,
    to: -1,
    match: /.*/.exec("")
  };
  const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  class RegExpCursor {
    constructor(text, query, options, from = 0, to = text.length) {
      this.text = text;
      this.to = to;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.iter = text.iter();
      let startLine = text.lineAt(from);
      this.curLineStart = startLine.from;
      this.matchPos = toCharEnd(text, from);
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to) this.curLine = "";
      else this.getLine(0);
    }
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from = this.curLineStart + match.index, to = from + match[0].length;
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          if (from == this.curLineStart + this.curLine.length) this.nextLine();
          if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
            this.value = {
              from,
              to,
              match
            };
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  }
  const flattened = /* @__PURE__ */ new WeakMap();
  class FlattenedDoc {
    constructor(from, text) {
      this.from = from;
      this.text = text;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from, to) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to || cached.to <= from) {
        let flat = new FlattenedDoc(from, doc2.sliceString(from, to));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from && cached.to == to) return cached;
      let { text, from: cachedFrom } = cached;
      if (cachedFrom > from) {
        text = doc2.sliceString(from, cachedFrom) + text;
        cachedFrom = from;
      }
      if (cached.to < to) text += doc2.sliceString(cached.to, to);
      flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
  }
  class MultilineRegExpCursor {
    constructor(text, query, options, from, to) {
      this.text = text;
      this.to = to;
      this.done = false;
      this.value = empty;
      this.matchPos = toCharEnd(text, from);
      this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
      this.test = options === null || options === void 0 ? void 0 : options.test;
      this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off) {
          this.re.lastIndex = off + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match) {
          let from = this.flat.from + match.index, to = from + match[0].length;
          if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
            this.value = {
              from,
              to,
              match
            };
            this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
            return this;
          }
        }
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source) {
    try {
      new RegExp(source, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function toCharEnd(text, pos) {
    if (pos >= text.length) return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344) pos++;
    return pos;
  }
  function createLineDialog(view) {
    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
    let input = crelt("input", {
      class: "cm-textfield",
      name: "line",
      value: line
    });
    let dom = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view.dispatch({
            effects: dialogEffect.of(false)
          });
          view.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go();
      }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", {
      class: "cm-button",
      type: "submit"
    }, view.state.phrase("go")));
    function go() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match) return;
      let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
      let [, sign, ln, cl, percent] = match;
      let col = cl ? +cl.slice(1) : 0;
      let line2 = ln ? +ln : startLine.number;
      if (ln && percent) {
        let pc = line2 / 100;
        if (sign) pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
        line2 = Math.round(state.doc.lines * pc);
      } else if (ln && sign) {
        line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
      let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
      view.dispatch({
        effects: [
          dialogEffect.of(false),
          EditorView.scrollIntoView(selection2.from, {
            y: "center"
          })
        ],
        selection: selection2
      });
      view.focus();
    }
    return {
      dom
    };
  }
  const dialogEffect = StateEffect.define();
  const dialogField = StateField.define({
    create() {
      return true;
    },
    update(value, tr) {
      for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  const gotoLine = (view) => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
      let effects = [
        dialogEffect.of(true)
      ];
      if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([
        dialogField,
        baseTheme$1$1
      ]));
      view.dispatch({
        effects
      });
      panel = getPanel(view, createLineDialog);
    }
    if (panel) panel.dom.querySelector("input").select();
    return true;
  };
  const baseTheme$1$1 = EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": {
        fontSize: "80%"
      }
    }
  });
  const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  const highlightConfig = Facet.define({
    combine(options) {
      return combineConfig(options, defaultHighlightOptions, {
        highlightWordAroundCursor: (a, b) => a || b,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options) {
    let ext = [
      defaultTheme,
      matchHighlighter
    ];
    return ext;
  }
  const matchDeco = Decoration.mark({
    class: "cm-selectionMatch"
  });
  const mainMatchDeco = Decoration.mark({
    class: "cm-selectionMatch cm-selectionMatch-main"
  });
  function insideWordBoundaries(check, state, from, to) {
    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
  }
  function insideWord(check, state, from, to) {
    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
  }
  const matchHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update) {
      if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
      let conf = view.state.facet(highlightConfig);
      let { state } = view, sel = state.selection;
      if (sel.ranges.length > 1) return Decoration.none;
      let range = sel.main, query, check = null;
      if (range.empty) {
        if (!conf.highlightWordAroundCursor) return Decoration.none;
        let word = state.wordAt(range.head);
        if (!word) return Decoration.none;
        check = state.charCategorizer(range.head);
        query = state.sliceDoc(word.from, word.to);
      } else {
        let len = range.to - range.from;
        if (len < conf.minSelectionLength || len > 200) return Decoration.none;
        if (conf.wholeWords) {
          query = state.sliceDoc(range.from, range.to);
          check = state.charCategorizer(range.head);
          if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return Decoration.none;
        } else {
          query = state.sliceDoc(range.from, range.to);
          if (!query) return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view.visibleRanges) {
        let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
        while (!cursor2.next().done) {
          let { from, to } = cursor2.value;
          if (!check || insideWordBoundaries(check, state, from, to)) {
            if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));
            else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));
            if (deco.length > conf.maxMatches) return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  const defaultTheme = EditorView.baseTheme({
    ".cm-selectionMatch": {
      backgroundColor: "#99ff7780"
    },
    ".cm-searchMatch .cm-selectionMatch": {
      backgroundColor: "transparent"
    }
  });
  const selectWord = ({ state, dispatch }) => {
    let { selection: selection2 } = state;
    let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
    if (newSel.eq(selection2)) return false;
    dispatch(state.update({
      selection: newSel
    }));
    return true;
  };
  function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor2.next();
      if (cursor2.done) {
        if (cycled) return null;
        cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor2.value.from)) continue;
        if (fullWord) {
          let word2 = state.wordAt(cursor2.value.from);
          if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to) continue;
        }
        return cursor2.value;
      }
    }
  }
  const selectNextOccurrence = ({ state, dispatch }) => {
    let { ranges } = state.selection;
    if (ranges.some((sel) => sel.from === sel.to)) return selectWord({
      state,
      dispatch
    });
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some((r) => state.sliceDoc(r.from, r.to) != searchedText)) return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range) return false;
    dispatch(state.update({
      selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
      effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
  };
  const searchConfigFacet = Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        top: false,
        caseSensitive: false,
        literal: false,
        regexp: false,
        wholeWord: false,
        createPanel: (view) => new SearchPanel(view),
        scrollToMatch: (range) => EditorView.scrollIntoView(range)
      });
    }
  });
  class SearchQuery {
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.literal = !!config2.literal;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = this.unquote(this.search);
      this.wholeWord = !!config2.wholeWord;
    }
    unquote(text) {
      return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(state, from = 0, to) {
      let st = state.doc ? state : EditorState.create({
        doc: state
      });
      if (to == null) to = st.doc.length;
      return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
  }
  class QueryType {
    constructor(spec) {
      this.spec = spec;
    }
  }
  function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
  }
  function stringWordTest(doc2, categorizer) {
    return (from, to, buf, bufPos) => {
      if (bufPos > from || bufPos + buf.length < to) {
        bufPos = Math.max(0, from - 2);
        buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
      }
      return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
    };
  }
  class StringQuery extends QueryType {
    constructor(spec) {
      super(spec);
    }
    nextMatch(state, curFrom, curTo) {
      let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
      if (cursor2.done) {
        let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
        cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
      }
      return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
    }
    prevMatchInRange(state, from, to) {
      for (let pos = to; ; ) {
        let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
        let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
        while (!cursor2.nextOverlapping().done) range = cursor2.value;
        if (range) return range;
        if (start == from) return null;
        pos -= 1e4;
      }
    }
    prevMatch(state, curFrom, curTo) {
      let found = this.prevMatchInRange(state, 0, curFrom);
      if (!found) found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
      return found && (found.from != curFrom || found.to != curTo) ? found : null;
    }
    getReplacement(_result) {
      return this.spec.unquote(this.spec.replace);
    }
    matchAll(state, limit) {
      let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor2.next().done) {
        if (ranges.length >= limit) return null;
        ranges.push(cursor2.value);
      }
      return ranges;
    }
    highlight(state, from, to, add2) {
      let cursor2 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
      while (!cursor2.next().done) add2(cursor2.value.from, cursor2.value.to);
    }
  }
  function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
      ignoreCase: !spec.caseSensitive,
      test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
    }, from, to);
  }
  function charBefore(str, index) {
    return str.slice(findClusterBreak(str, index, false), index);
  }
  function charAfter(str, index) {
    return str.slice(index, findClusterBreak(str, index));
  }
  function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
  }
  class RegExpQuery extends QueryType {
    nextMatch(state, curFrom, curTo) {
      let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
      if (cursor2.done) cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
      return cursor2.done ? null : cursor2.value;
    }
    prevMatchInRange(state, from, to) {
      for (let size = 1; ; size++) {
        let start = Math.max(from, to - size * 1e4);
        let cursor2 = regexpCursor(this.spec, state, start, to), range = null;
        while (!cursor2.next().done) range = cursor2.value;
        if (range && (start == from || range.from > start + 10)) return range;
        if (start == from) return null;
      }
    }
    prevMatch(state, curFrom, curTo) {
      return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
      return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m);
    }
    matchAll(state, limit) {
      let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
      while (!cursor2.next().done) {
        if (ranges.length >= limit) return null;
        ranges.push(cursor2.value);
      }
      return ranges;
    }
    highlight(state, from, to, add2) {
      let cursor2 = regexpCursor(this.spec, state, Math.max(0, from - 250), Math.min(to + 250, state.doc.length));
      while (!cursor2.next().done) add2(cursor2.value.from, cursor2.value.to);
    }
  }
  const setSearchQuery = StateEffect.define();
  const togglePanel$1 = StateEffect.define();
  const searchState = StateField.define({
    create(state) {
      return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel$1)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  class SearchState {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  }
  const matchMark = Decoration.mark({
    class: "cm-searchMatch"
  }), selectedMatchMark = Decoration.mark({
    class: "cm-searchMatch cm-searchMatch-selected"
  });
  const searchHighlighter = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
      let state = update.state.field(searchState);
      if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid) return Decoration.none;
      let { view } = this;
      let builder = new RangeSetBuilder();
      for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
        let { from, to } = ranges[i2];
        while (i2 < l - 1 && to > ranges[i2 + 1].from - 2 * 250) to = ranges[++i2].to;
        query.highlight(view.state, from, to, (from2, to2) => {
          let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
          builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view) => {
      let state = view.state.field(searchState, false);
      return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
  }
  const findNext = searchCommand((view, { query }) => {
    let { to } = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next) return false;
    let selection2 = EditorSelection.single(next.from, next.to);
    let config2 = view.state.facet(searchConfigFacet);
    view.dispatch({
      selection: selection2,
      effects: [
        announceMatch(view, next),
        config2.scrollToMatch(selection2.main, view)
      ],
      userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
  });
  const findPrevious = searchCommand((view, { query }) => {
    let { state } = view, { from } = state.selection.main;
    let prev = query.prevMatch(state, from, from);
    if (!prev) return false;
    let selection2 = EditorSelection.single(prev.from, prev.to);
    let config2 = view.state.facet(searchConfigFacet);
    view.dispatch({
      selection: selection2,
      effects: [
        announceMatch(view, prev),
        config2.scrollToMatch(selection2.main, view)
      ],
      userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
  });
  const selectMatches = searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state, 1e3);
    if (!ranges || !ranges.length) return false;
    view.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  const selectSelectionMatches = ({ state, dispatch }) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty) return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
      if (ranges.length > 1e3) return false;
      if (cur2.value.from == from) main = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch(state.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  const replaceNext = searchCommand((view, { query }) => {
    let { state } = view, { from, to } = state.selection.main;
    if (state.readOnly) return false;
    let match = query.nextMatch(state, from, from);
    if (!match) return false;
    let next = match;
    let changes = [], selection2, replacement;
    let effects = [];
    if (next.from == from && next.to == to) {
      replacement = state.toText(query.getReplacement(next));
      changes.push({
        from: next.from,
        to: next.to,
        insert: replacement
      });
      next = query.nextMatch(state, next.from, next.to);
      effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= match.to ? 0 : match.to - match.from - replacement.length;
      selection2 = EditorSelection.single(next.from - off, next.to - off);
      effects.push(announceMatch(view, next));
      effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
    }
    view.dispatch({
      changes,
      selection: selection2,
      effects,
      userEvent: "input.replace"
    });
    return true;
  });
  const replaceAll = searchCommand((view, { query }) => {
    if (view.state.readOnly) return false;
    let changes = query.matchAll(view.state, 1e9).map((match) => {
      let { from, to } = match;
      return {
        from,
        to,
        insert: query.getReplacement(match)
      };
    });
    if (!changes.length) return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
      changes,
      effects: EditorView.announce.of(announceText),
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
  }
  function defaultQuery(state, fallback) {
    var _a2, _b, _c, _d, _e;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText) return fallback;
    let config2 = state.facet(searchConfigFacet);
    return new SearchQuery({
      search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
      caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
      literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
      regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
      wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
    });
  }
  function getSearchInput(view) {
    let panel = getPanel(view, createSearchPanel);
    return panel && panel.dom.querySelector("[main-field]");
  }
  function selectSearchInput(view) {
    let input = getSearchInput(view);
    if (input && input == view.root.activeElement) input.select();
  }
  const openSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
      let searchInput = getSearchInput(view);
      if (searchInput && searchInput != view.root.activeElement) {
        let query = defaultQuery(view.state, state.query.spec);
        if (query.valid) view.dispatch({
          effects: setSearchQuery.of(query)
        });
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view.dispatch({
        effects: [
          togglePanel$1.of(true),
          state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
        ]
      });
    }
    return true;
  };
  const closeSearchPanel = (view) => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel) return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();
    view.dispatch({
      effects: togglePanel$1.of(false)
    });
    return true;
  };
  const searchKeymap = [
    {
      key: "Mod-f",
      run: openSearchPanel,
      scope: "editor search-panel"
    },
    {
      key: "F3",
      run: findNext,
      shift: findPrevious,
      scope: "editor search-panel",
      preventDefault: true
    },
    {
      key: "Mod-g",
      run: findNext,
      shift: findPrevious,
      scope: "editor search-panel",
      preventDefault: true
    },
    {
      key: "Escape",
      run: closeSearchPanel,
      scope: "editor search-panel"
    },
    {
      key: "Mod-Shift-l",
      run: selectSelectionMatches
    },
    {
      key: "Mod-Alt-g",
      run: gotoLine
    },
    {
      key: "Mod-d",
      run: selectNextOccurrence,
      preventDefault: true
    }
  ];
  class SearchPanel {
    constructor(view) {
      this.view = view;
      let query = this.query = view.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view, "Find"),
        "aria-label": phrase(view, "Find"),
        class: "cm-textfield",
        name: "search",
        form: "",
        "main-field": "true",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view, "Replace"),
        "aria-label": phrase(view, "Replace"),
        class: "cm-textfield",
        name: "replace",
        form: "",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        form: "",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        form: "",
        checked: query.regexp,
        onchange: this.commit
      });
      this.wordField = crelt("input", {
        type: "checkbox",
        name: "word",
        form: "",
        checked: query.wholeWord,
        onchange: this.commit
      });
      function button(name2, onclick, content2) {
        return crelt("button", {
          class: "cm-button",
          name: name2,
          onclick,
          type: "button"
        }, content2);
      }
      this.dom = crelt("div", {
        onkeydown: (e) => this.keydown(e),
        class: "cm-search"
      }, [
        this.searchField,
        button("next", () => findNext(view), [
          phrase(view, "next")
        ]),
        button("prev", () => findPrevious(view), [
          phrase(view, "previous")
        ]),
        button("select", () => selectMatches(view), [
          phrase(view, "all")
        ]),
        crelt("label", null, [
          this.caseField,
          phrase(view, "match case")
        ]),
        crelt("label", null, [
          this.reField,
          phrase(view, "regexp")
        ]),
        crelt("label", null, [
          this.wordField,
          phrase(view, "by word")
        ]),
        ...view.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view), [
            phrase(view, "replace")
          ]),
          button("replaceAll", () => replaceAll(view), [
            phrase(view, "replace all")
          ])
        ],
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view),
          "aria-label": phrase(view, "close"),
          type: "button"
        }, [
          "\xD7"
        ])
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        wholeWord: this.wordField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({
          effects: setSearchQuery.of(query)
        });
      }
    }
    keydown(e) {
      if (runScopeHandlers(this.view, e, "search-panel")) {
        e.preventDefault();
      } else if (e.keyCode == 13 && e.target == this.searchField) {
        e.preventDefault();
        (e.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e.keyCode == 13 && e.target == this.replaceField) {
        e.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update) {
      for (let tr of update.transactions) for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);
      }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
      this.wordField.checked = query.wholeWord;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  }
  function phrase(view, phrase2) {
    return view.state.phrase(phrase2);
  }
  const AnnounceMargin = 30;
  const Break = /[\s\.,:;?!]/;
  function announceMatch(view, { from, to }) {
    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != line.from) {
      for (let i2 = 0; i2 < AnnounceMargin; i2++) if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
        text = text.slice(i2);
        break;
      }
    }
    if (end != lineEnd) {
      for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--) if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
        text = text.slice(0, i2);
        break;
      }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
  }
  const baseTheme$2 = EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": {
      backgroundColor: "#ffff0054"
    },
    "&dark .cm-searchMatch": {
      backgroundColor: "#00ffff8a"
    },
    "&light .cm-searchMatch-selected": {
      backgroundColor: "#ff6a0054"
    },
    "&dark .cm-searchMatch-selected": {
      backgroundColor: "#ff00ff8a"
    }
  });
  const searchExtensions = [
    searchState,
    Prec.low(searchHighlighter),
    baseTheme$2
  ];
  class CompletionContext {
    constructor(state, pos, explicit, view) {
      this.state = state;
      this.pos = pos;
      this.explicit = explicit;
      this.view = view;
      this.abortListeners = [];
      this.abortOnDocChange = false;
    }
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0) token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : {
        from: start + found,
        to: this.pos,
        text: str.slice(found)
      };
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(type, listener, options) {
      if (type == "abort" && this.abortListeners) {
        this.abortListeners.push(listener);
        if (options && options.onDocChange) this.abortOnDocChange = true;
      }
    }
  }
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words) flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options) {
    let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
    for (let { label } of options) {
      first[label[0]] = true;
      for (let i2 = 1; i2 < label.length; i2++) rest[label[i2]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [
      new RegExp("^" + source),
      new RegExp(source)
    ];
  }
  completeFromList = function(list) {
    let options = list.map((o) => typeof o == "string" ? {
      label: o
    } : o);
    let [validFor, match] = options.every((o) => /^\w+$/.test(o.label)) ? [
      /\w*$/,
      /\w+$/
    ] : prefixMatch(options);
    return (context) => {
      let token = context.matchBefore(match);
      return token || context.explicit ? {
        from: token ? token.from : context.pos,
        options,
        validFor
      } : null;
    };
  };
  ifNotIn = function(nodes, source) {
    return (context) => {
      for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
        if (nodes.indexOf(pos.name) > -1) return null;
        if (pos.type.isTop) break;
      }
      return source(context);
    };
  };
  class Option {
    constructor(completion, source, match, score2) {
      this.completion = completion;
      this.source = source;
      this.match = match;
      this.score = score2;
    }
  }
  function cur(state) {
    return state.selection.main.from;
  }
  function ensureAnchor(expr, start) {
    var _a2;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd) return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  const pickedCompletion = Annotation.define();
  function insertCompletionText(state, text, from, to) {
    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
    return Object.assign(Object.assign({}, state.changeByRange((range) => {
      if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {
        range
      };
      let lines = state.toText(text);
      return {
        changes: {
          from: range.from + fromOff,
          to: to == main.from ? range.to : range.from + toOff,
          insert: lines
        },
        range: EditorSelection.cursor(range.from + fromOff + lines.length)
      };
    })), {
      scrollIntoView: true,
      userEvent: "input.complete"
    });
  }
  const SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source)) return source;
    let known = SourceCache.get(source);
    if (!known) SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  const startCompletionEffect = StateEffect.define();
  const closeCompletionEffect = StateEffect.define();
  class FuzzyMatcher {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      this.score = 0;
      this.matched = [];
      for (let p = 0; p < pattern.length; ) {
        let char = codePointAt(pattern, p), size = codePointSize(char);
        this.chars.push(char);
        let part = pattern.slice(p, p + size), upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p += size;
      }
      this.astral = pattern.length != this.chars.length;
    }
    ret(score2, matched) {
      this.score = score2;
      this.matched = matched;
      return this;
    }
    match(word) {
      if (this.pattern.length == 0) return this.ret(-100, []);
      if (word.length < this.pattern.length) return null;
      let { chars, folded, any, precise, byWord } = this;
      if (chars.length == 1) {
        let first = codePointAt(word, 0), firstSize = codePointSize(first);
        let score2 = firstSize == word.length ? 0 : -100;
        if (first == chars[0]) ;
        else if (first == folded[0]) score2 += -200;
        else return null;
        return this.ret(score2, [
          0,
          firstSize
        ]);
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100, [
        0,
        this.pattern.length
      ]);
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i2 = 0, e = Math.min(word.length, 200); i2 < e && anyTo < len; ) {
          let next = codePointAt(word, i2);
          if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i2;
          i2 += codePointSize(next);
        }
        if (anyTo < len) return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i2 = 0, e = Math.min(word.length, 200), prevType = 0; i2 < e && byWordTo < len; ) {
        let next = codePointAt(word, i2);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i2;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0) adjacentStart = i2;
              adjacentEnd = i2 + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i2;
          else if (byWord.length) wordAdjacent = false;
        }
        prevType = type;
        i2 += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [
        0,
        adjacentEnd
      ]);
      if (direct > -1) return this.ret(-700 - word.length, [
        direct,
        direct + this.pattern.length
      ]);
      if (adjacentTo == len) return this.ret(-200 + -700 - word.length, [
        adjacentStart,
        adjacentEnd
      ]);
      if (byWordTo == len) return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score2, positions, word) {
      let result = [], i2 = 0;
      for (let pos of positions) {
        let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
        if (i2 && result[i2 - 1] == pos) result[i2 - 1] = to;
        else {
          result[i2++] = pos;
          result[i2++] = to;
        }
      }
      return this.ret(score2 - word.length, result);
    }
  }
  class StrictMatcher {
    constructor(pattern) {
      this.pattern = pattern;
      this.matched = [];
      this.score = 0;
      this.folded = pattern.toLowerCase();
    }
    match(word) {
      if (word.length < this.pattern.length) return null;
      let start = word.slice(0, this.pattern.length);
      let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
      if (match == null) return null;
      this.matched = [
        0,
        start.length
      ];
      this.score = match + (word.length == this.pattern.length ? 0 : -100);
      return this;
    }
  }
  const completionConfig = Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        activateOnCompletion: () => false,
        activateOnTypingDelay: 100,
        selectOnOpen: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        tooltipClass: () => "",
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: [],
        positionInfo: defaultPositionInfo,
        filterStrict: false,
        compareCompletions: (a, b) => a.label.localeCompare(b.label),
        interactionDelay: 75,
        updateSyncTime: 100
      }, {
        defaultKeymap: (a, b) => a && b,
        closeOnBlur: (a, b) => a && b,
        icons: (a, b) => a && b,
        tooltipClass: (a, b) => (c) => joinClass(a(c), b(c)),
        optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
        addToOptions: (a, b) => a.concat(b),
        filterStrict: (a, b) => a || b
      });
    }
  });
  function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
  }
  function defaultPositionInfo(view, list, option, info, space, tooltip) {
    let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
    let side = "top", offset, maxWidth;
    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;
    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
      offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
      maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
    } else {
      narrow = true;
      maxWidth = Math.min(400, (rtl ? list.right : space.right - list.left) - 30);
      let spaceBelow = space.bottom - list.bottom;
      if (spaceBelow >= infoHeight || spaceBelow > list.top) {
        offset = option.bottom - list.top;
      } else {
        side = "bottom";
        offset = list.bottom - option.top;
      }
    }
    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
    let scaleX = (list.right - list.left) / tooltip.offsetWidth;
    return {
      style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
      class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
    };
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons) content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type) icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
    content2.push({
      render(completion, _s, _v, match) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let label = completion.displayLabel || completion.label, off = 0;
        for (let j = 0; j < match.length; ) {
          let from = match[j++], to = match[j++];
          if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail) return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
  }
  function rangeAroundSelected(total, selected, max) {
    if (total <= max) return {
      from: 0,
      to: total
    };
    if (selected < 0) selected = 0;
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max);
      return {
        from: off2 * max,
        to: (off2 + 1) * max
      };
    }
    let off = Math.floor((total - selected) / max);
    return {
      from: total - (off + 1) * max,
      to: total - off * max
    };
  }
  class CompletionTooltip {
    constructor(view, stateField, applyCompletion2) {
      this.view = view;
      this.stateField = stateField;
      this.applyCompletion = applyCompletion2;
      this.info = null;
      this.infoDestroy = null;
      this.placeInfoReq = {
        read: () => this.measureInfo(),
        write: (pos) => this.placeInfo(pos),
        key: this
      };
      this.space = null;
      this.currentClass = "";
      let cState = view.state.field(stateField);
      let { options, selected } = cState.open;
      let config2 = view.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.tooltipClass = config2.tooltipClass;
      this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.updateTooltipClass(view.state);
      this.dom.addEventListener("mousedown", (e) => {
        let { options: options2 } = view.state.field(stateField).open;
        for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
          if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
            this.applyCompletion(view, options2[+match[1]]);
            e.preventDefault();
            return;
          }
        }
      });
      this.dom.addEventListener("focusout", (e) => {
        let state = view.state.field(this.stateField, false);
        if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({
          effects: closeCompletionEffect.of(null)
        });
      });
      this.showOptions(options, cState.id);
    }
    mount() {
      this.updateSel();
    }
    showOptions(options, id) {
      if (this.list) this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(options, id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info) this.view.requestMeasure(this.placeInfoReq);
      });
    }
    update(update) {
      var _a2;
      let cState = update.state.field(this.stateField);
      let prevState = update.startState.field(this.stateField);
      this.updateTooltipClass(update.state);
      if (cState != prevState) {
        let { options, selected, disabled } = cState.open;
        if (!prevState.open || prevState.open.options != options) {
          this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
          this.showOptions(options, cState.id);
        }
        this.updateSel();
        if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled)) this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
      }
    }
    updateTooltipClass(state) {
      let cls = this.tooltipClass(state);
      if (cls != this.currentClass) {
        for (let c of this.currentClass.split(" ")) if (c) this.dom.classList.remove(c);
        for (let c of cls.split(" ")) if (c) this.dom.classList.add(c);
        this.currentClass = cls;
      }
    }
    positioned(space) {
      this.space = space;
      if (this.info) this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(open.options, cState.id);
      }
      if (this.updateSelectedOption(open.selected)) {
        this.destroyInfo();
        let { completion } = open.options[open.selected];
        let { info } = completion;
        if (!info) return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult) return;
        if ("then" in infoResult) {
          infoResult.then((obj) => {
            if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);
          }).catch((e) => logException(this.view.state, e, "completion info"));
        } else {
          this.addInfoPane(infoResult, completion);
        }
      }
    }
    addInfoPane(content2, completion) {
      this.destroyInfo();
      let wrap = this.info = document.createElement("div");
      wrap.className = "cm-tooltip cm-completionInfo";
      if (content2.nodeType != null) {
        wrap.appendChild(content2);
        this.infoDestroy = null;
      } else {
        let { dom, destroy } = content2;
        wrap.appendChild(dom);
        this.infoDestroy = destroy || null;
      }
      this.dom.appendChild(wrap);
      this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(selected) {
      let set = null;
      for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
        if (opt.nodeName != "LI" || !opt.id) {
          i2--;
        } else if (i2 == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected")) opt.removeAttribute("aria-selected");
        }
      }
      if (set) scrollIntoView(this.list, set);
      return set;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info) return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      let space = this.space;
      if (!space) {
        let win = this.dom.ownerDocument.defaultView || window;
        space = {
          left: 0,
          top: 0,
          right: win.innerWidth,
          bottom: win.innerHeight
        };
      }
      if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;
      return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
    }
    placeInfo(pos) {
      if (this.info) {
        if (pos) {
          if (pos.style) this.info.style.cssText = pos.style;
          this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
        } else {
          this.info.style.cssText = "top: -1e6px";
        }
      }
    }
    createListBox(options, id, range) {
      const ul = document.createElement("ul");
      ul.id = id;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      let curSection = null;
      for (let i2 = range.from; i2 < range.to; i2++) {
        let { completion, match } = options[i2], { section } = completion;
        if (section) {
          let name2 = typeof section == "string" ? section : section.name;
          if (name2 != curSection && (i2 > range.from || range.from == 0)) {
            curSection = name2;
            if (typeof section != "string" && section.header) {
              ul.appendChild(section.header(section));
            } else {
              let header = ul.appendChild(document.createElement("completion-section"));
              header.textContent = name2;
            }
          }
        }
        const li = ul.appendChild(document.createElement("li"));
        li.id = id + "-" + i2;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls) li.className = cls;
        for (let source of this.optionContent) {
          let node = source(completion, this.view.state, this.view, match);
          if (node) li.appendChild(node);
        }
      }
      if (range.from) ul.classList.add("cm-completionListIncompleteTop");
      if (range.to < options.length) ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
    destroyInfo() {
      if (this.info) {
        if (this.infoDestroy) this.infoDestroy();
        this.info.remove();
        this.info = null;
      }
    }
    destroy() {
      this.destroyInfo();
    }
  }
  function completionTooltip(stateField, applyCompletion2) {
    return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
  }
  function scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self2 = element.getBoundingClientRect();
    let scaleY = parent.height / container.offsetHeight;
    if (self2.top < parent.top) container.scrollTop -= (parent.top - self2.top) / scaleY;
    else if (self2.bottom > parent.bottom) container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state) {
    let options = [];
    let sections = null;
    let addOption = (option) => {
      options.push(option);
      let { section } = option.completion;
      if (section) {
        if (!sections) sections = [];
        let name2 = typeof section == "string" ? section : section.name;
        if (!sections.some((s) => s.name == name2)) sections.push(typeof section == "string" ? {
          name: name2
        } : section);
      }
    };
    let conf = state.facet(completionConfig);
    for (let a of active) if (a.hasResult()) {
      let getMatch = a.result.getMatch;
      if (a.result.filter === false) {
        for (let option of a.result.options) {
          addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern = state.sliceDoc(a.from, a.to), match;
        let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);
        for (let option of a.result.options) if (match = matcher.match(option.label)) {
          let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
          addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));
        }
      }
    }
    if (sections) {
      let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
      let cmp = (a, b) => {
        var _a2, _b;
        return ((_a2 = a.rank) !== null && _a2 !== void 0 ? _a2 : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);
      };
      for (let s of sections.sort(cmp)) {
        pos -= 1e5;
        sectionOrder[s.name] = pos;
      }
      for (let option of options) {
        let { section } = option.completion;
        if (section) option.score += sectionOrder[typeof section == "string" ? section : section.name];
      }
    }
    let result = [], prev = null;
    let compare2 = conf.compareCompletions;
    for (let opt of options.sort((a, b) => b.score - a.score || compare2(a.completion, b.completion))) {
      let cur2 = opt.completion;
      if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost) result.push(opt);
      else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  class CompletionDialog {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
      this.options = options;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
      this.disabled = disabled;
    }
    setSelected(selected, id) {
      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id, prev, conf, didSetActive) {
      if (prev && !didSetActive && active.some((s) => s.isPending)) return prev.setDisabled();
      let options = sortOptions(active, state);
      if (!options.length) return prev && active.some((a) => a.isPending) ? prev.setDisabled() : null;
      let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
      if (prev && prev.selected != selected && prev.selected != -1) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i2 = 0; i2 < options.length; i2++) if (options[i2].completion == selectedValue) {
          selected = i2;
          break;
        }
      }
      return new CompletionDialog(options, makeAttrs(id, selected), {
        pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
        create: createTooltip,
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {
        pos: changes.mapPos(this.tooltip.pos)
      }), this.timestamp, this.selected, this.disabled);
    }
    setDisabled() {
      return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
    }
  }
  class CompletionState {
    constructor(active, id, open) {
      this.active = active;
      this.id = id;
      this.open = open;
    }
    static start() {
      return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let { state } = tr, conf = state.facet(completionConfig);
      let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
      let active = sources.map((source) => {
        let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a) => a.state != 0) ? 1 : 0);
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a, i2) => a == this.active[i2])) active = this.active;
      let open = this.open, didSet = tr.effects.some((e) => e.is(setActiveEffect));
      if (open && tr.docChanged) open = open.map(tr.changes);
      if (tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet) open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
      else if (open && open.disabled && !active.some((a) => a.isPending)) open = null;
      if (!open && active.every((a) => !a.isPending) && active.some((a) => a.hasResult())) active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0) : a);
      for (let effect of tr.effects) if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;
    }
  }
  function sameResults(a, b) {
    if (a == b) return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a.length && !a[iA].hasResult()) iA++;
      while (iB < b.length && !b[iB].hasResult()) iB++;
      let endA = iA == a.length, endB = iB == b.length;
      if (endA || endB) return endA == endB;
      if (a[iA++].result != b[iB++].result) return false;
    }
  }
  const baseAttrs = {
    "aria-autocomplete": "list"
  };
  const noAttrs = {};
  function makeAttrs(id, selected) {
    let result = {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-controls": id
    };
    if (selected > -1) result["aria-activedescendant"] = id + "-" + selected;
    return result;
  }
  const none = [];
  function getUpdateType(tr, conf) {
    if (tr.isUserEvent("input.complete")) {
      let completion = tr.annotation(pickedCompletion);
      if (completion && conf.activateOnCompletion(completion)) return 4 | 8;
    }
    let typing = tr.isUserEvent("input.type");
    return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
  }
  class ActiveSource {
    constructor(source, state, explicit = false) {
      this.source = source;
      this.state = state;
      this.explicit = explicit;
    }
    hasResult() {
      return false;
    }
    get isPending() {
      return this.state == 1;
    }
    update(tr, conf) {
      let type = getUpdateType(tr, conf), value = this;
      if (type & 8 || type & 16 && this.touches(tr)) value = new ActiveSource(value.source, 0);
      if (type & 4 && value.state == 0) value = new ActiveSource(this.source, 1);
      value = value.updateFor(tr, type);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1, effect.value);
        else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0);
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value) if (active.source == value.source) value = active;
        }
      }
      return value;
    }
    updateFor(tr, type) {
      return this.map(tr.changes);
    }
    map(changes) {
      return this;
    }
    touches(tr) {
      return tr.changes.touchesRange(cur(tr.state));
    }
  }
  class ActiveResult extends ActiveSource {
    constructor(source, explicit, limit, result, from, to) {
      super(source, 3, explicit);
      this.limit = limit;
      this.result = result;
      this.from = from;
      this.to = to;
    }
    hasResult() {
      return true;
    }
    updateFor(tr, type) {
      var _a2;
      if (!(type & 3)) return this.map(tr.changes);
      let result = this.result;
      if (result.map && !tr.changes.empty) result = result.map(result, tr.changes);
      let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if (pos > to || !result || type & 2 && (cur(tr.startState) == this.from || pos < this.limit)) return new ActiveSource(this.source, type & 4 ? 1 : 0);
      let limit = tr.changes.mapPos(this.limit);
      if (checkValid(result.validFor, tr.state, from, to)) return new ActiveResult(this.source, this.explicit, limit, result, from, to);
      if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false)))) return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, this.explicit);
    }
    map(mapping) {
      if (mapping.empty) return this;
      let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
      if (!result) return new ActiveSource(this.source, 0);
      return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
    touches(tr) {
      return tr.changes.touchesRange(this.from, this.to);
    }
  }
  function checkValid(validFor, state, from, to) {
    if (!validFor) return false;
    let text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
  }
  const setActiveEffect = StateEffect.define({
    map(sources, mapping) {
      return sources.map((s) => s.map(mapping));
    }
  });
  const setSelectedEffect = StateEffect.define();
  const completionState = StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f) => [
      showTooltip.from(f, (val) => val.tooltip),
      EditorView.contentAttributes.from(f, (state) => state.attrs)
    ]
  });
  function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = view.state.field(completionState).active.find((a) => a.source == option.source);
    if (!(result instanceof ActiveResult)) return false;
    if (typeof apply == "string") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {
      annotations: pickedCompletion.of(option.completion)
    }));
    else apply(view, option.completion, result.from, result.to);
    return true;
  }
  const createTooltip = completionTooltip(completionState, applyCompletion);
  function moveCompletionSelection(forward, by = "option") {
    return (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let { length } = cState.open.options;
      let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
      if (selected < 0) selected = by == "page" ? 0 : length - 1;
      else if (selected >= length) selected = by == "page" ? length - 1 : 0;
      view.dispatch({
        effects: setSelectedEffect.of(selected)
      });
      return true;
    };
  }
  const acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;
    return applyCompletion(view, cState.open.options[cState.open.selected]);
  };
  const startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState) return false;
    view.dispatch({
      effects: startCompletionEffect.of(true)
    });
    return true;
  };
  const closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some((a) => a.state != 0)) return false;
    view.dispatch({
      effects: closeCompletionEffect.of(null)
    });
    return true;
  };
  class RunningQuery {
    constructor(active, context) {
      this.active = active;
      this.context = context;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  }
  const MaxUpdateCount = 50, MinAbortTime = 1e3;
  const completionPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.pendingStart = false;
      this.composing = 0;
      for (let active of view.state.field(completionState).active) if (active.isPending) this.startQuery(active);
    }
    update(update) {
      let cState = update.state.field(completionState);
      let conf = update.state.facet(completionConfig);
      if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;
      let doesReset = update.transactions.some((tr) => {
        let type = getUpdateType(tr, conf);
        return type & 8 || (tr.selection || tr.docChanged) && !(type & 3);
      });
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e) {
              logException(this.view.state, e);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i2--, 1);
        } else {
          query.updates.push(...update.transactions);
        }
      }
      if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);
      if (update.transactions.some((tr) => tr.effects.some((e) => e.is(startCompletionEffect)))) this.pendingStart = true;
      let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
      this.debounceUpdate = cState.active.some((a) => a.isPending && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
      if (this.composing != 0) for (let tr of update.transactions) {
        if (tr.isUserEvent("input.type")) this.composing = 2;
        else if (this.composing == 2 && tr.selection) this.composing = 3;
      }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      this.pendingStart = false;
      let { state } = this.view, cState = state.field(completionState);
      for (let active of cState.active) {
        if (active.isPending && !this.running.some((r) => r.active.source == active.source)) this.startQuery(active);
      }
      if (this.running.length && cState.open && cState.open.disabled) this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    startQuery(active) {
      let { state } = this.view, pos = cur(state);
      let context = new CompletionContext(state, pos, active.explicit, this.view);
      let pending = new RunningQuery(active, context);
      this.running.push(pending);
      Promise.resolve(active.source(context)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({
          effects: closeCompletionEffect.of(null)
        });
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0)) this.accept();
      else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    accept() {
      var _a2;
      if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (query.done === void 0) continue;
        this.running.splice(i2--, 1);
        if (query.done) {
          let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
          let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
          let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
          for (let tr of query.updates) active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = cState.active.find((a) => a.source == query.active.source);
        if (current && current.isPending) {
          if (query.done == null) {
            let active = new ActiveSource(query.active.source, 0);
            for (let tr of query.updates) active = active.update(tr, conf);
            if (!active.isPending) updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length || cState.open && cState.open.disabled) this.view.dispatch({
        effects: setActiveEffect.of(updated)
      });
    }
  }, {
    eventHandlers: {
      blur(event) {
        let state = this.view.state.field(completionState, false);
        if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
          let dialog = state.open && getTooltip(this.view, state.open.tooltip);
          if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(() => this.view.dispatch({
            effects: closeCompletionEffect.of(null)
          }), 10);
        }
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({
            effects: startCompletionEffect.of(false)
          }), 20);
        }
        this.composing = 0;
      }
    }
  });
  const windows = typeof navigator == "object" && /Win/.test(navigator.platform);
  const commitCharacters = Prec.highest(EditorView.domEventHandlers({
    keydown(event, view) {
      let field = view.state.field(completionState, false);
      if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey) return false;
      let option = field.open.options[field.open.selected];
      let result = field.active.find((a) => a.source == option.source);
      let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
      if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option);
      return false;
    }
  }));
  const baseTheme$1 = EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        height: "100%",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li, & > completion-section": {
          padding: "1px 3px",
          lineHeight: 1.2
        },
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer"
        },
        "& > completion-section": {
          display: "list-item",
          borderBottom: "1px solid silver",
          paddingLeft: "0.5em",
          opacity: 0.7
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#777"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
      background: "#444"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: `${400}px`,
      boxSizing: "border-box",
      whiteSpace: "pre-line"
    },
    ".cm-completionInfo.cm-completionInfo-left": {
      right: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-right": {
      left: "100%"
    },
    ".cm-completionInfo.cm-completionInfo-left-narrow": {
      right: `${30}px`
    },
    ".cm-completionInfo.cm-completionInfo-right-narrow": {
      left: `${30}px`
    },
    "&light .cm-snippetField": {
      backgroundColor: "#00000022"
    },
    "&dark .cm-snippetField": {
      backgroundColor: "#ffffff22"
    },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      display: "inline-block",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6",
      boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": {
        content: "'\u0192'"
      }
    },
    ".cm-completionIcon-class": {
      "&:after": {
        content: "'\u25CB'"
      }
    },
    ".cm-completionIcon-interface": {
      "&:after": {
        content: "'\u25CC'"
      }
    },
    ".cm-completionIcon-variable": {
      "&:after": {
        content: "'\u{1D465}'"
      }
    },
    ".cm-completionIcon-constant": {
      "&:after": {
        content: "'\u{1D436}'"
      }
    },
    ".cm-completionIcon-type": {
      "&:after": {
        content: "'\u{1D461}'"
      }
    },
    ".cm-completionIcon-enum": {
      "&:after": {
        content: "'\u222A'"
      }
    },
    ".cm-completionIcon-property": {
      "&:after": {
        content: "'\u25A1'"
      }
    },
    ".cm-completionIcon-keyword": {
      "&:after": {
        content: "'\u{1F511}\uFE0E'"
      }
    },
    ".cm-completionIcon-namespace": {
      "&:after": {
        content: "'\u25A2'"
      }
    },
    ".cm-completionIcon-text": {
      "&:after": {
        content: "'abc'",
        fontSize: "50%",
        verticalAlign: "middle"
      }
    }
  });
  class FieldPos {
    constructor(field, line, from, to) {
      this.field = field;
      this.line = line;
      this.from = from;
      this.to = to;
    }
  }
  class FieldRange {
    constructor(field, from, to) {
      this.field = field;
      this.from = from;
      this.to = to;
    }
    map(changes) {
      let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
      let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
      return from == null || to == null ? null : new FieldRange(this.field, from, to);
    }
  }
  class Snippet {
    constructor(lines, fieldPositions) {
      this.lines = lines;
      this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
      let text = [], lineStart = [
        pos
      ];
      let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
      for (let line of this.lines) {
        if (text.length) {
          let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
          for (let i2 = 0; i2 < tabs; i2++) indent += state.facet(indentUnit);
          lineStart.push(pos + indent.length - tabs);
          line = indent + line.slice(tabs);
        }
        text.push(line);
        pos += line.length + 1;
      }
      let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
      return {
        text,
        ranges
      };
    }
    static parse(template) {
      let fields = [];
      let lines = [], positions = [], m;
      for (let line of template.split(/\r\n?|\n/)) {
        while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(line)) {
          let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || "", found = -1;
          let name2 = rawName.replace(/\\[{}]/g, (m2) => m2[1]);
          for (let i2 = 0; i2 < fields.length; i2++) {
            if (seq != null ? fields[i2].seq == seq : name2 ? fields[i2].name == name2 : false) found = i2;
          }
          if (found < 0) {
            let i2 = 0;
            while (i2 < fields.length && (seq == null || fields[i2].seq != null && fields[i2].seq < seq)) i2++;
            fields.splice(i2, 0, {
              seq,
              name: name2
            });
            found = i2;
            for (let pos of positions) if (pos.field >= found) pos.field++;
          }
          positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length));
          line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);
        }
        line = line.replace(/\\([{}])/g, (_, brace, index) => {
          for (let pos of positions) if (pos.line == lines.length && pos.from > index) {
            pos.from--;
            pos.to--;
          }
          return brace;
        });
        lines.push(line);
      }
      return new Snippet(lines, positions);
    }
  }
  let fieldMarker = Decoration.widget({
    widget: new class extends WidgetType {
      toDOM() {
        let span = document.createElement("span");
        span.className = "cm-snippetFieldPosition";
        return span;
      }
      ignoreEvent() {
        return false;
      }
    }()
  });
  let fieldRange = Decoration.mark({
    class: "cm-snippetField"
  });
  class ActiveSnippet {
    constructor(ranges, active) {
      this.ranges = ranges;
      this.active = active;
      this.deco = Decoration.set(ranges.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
      let ranges = [];
      for (let r of this.ranges) {
        let mapped = r.map(changes);
        if (!mapped) return null;
        ranges.push(mapped);
      }
      return new ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
      return sel.ranges.every((range) => this.ranges.some((r) => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
  }
  const setActive = StateEffect.define({
    map(value, changes) {
      return value && value.map(changes);
    }
  });
  const moveToField = StateEffect.define();
  const snippetState = StateField.define({
    create() {
      return null;
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setActive)) return effect.value;
        if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);
      }
      if (value && tr.docChanged) value = value.map(tr.changes);
      if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;
      return value;
    },
    provide: (f) => EditorView.decorations.from(f, (val) => val ? val.deco : Decoration.none)
  });
  function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
  }
  function snippet(template) {
    let snippet2 = Snippet.parse(template);
    return (editor, completion, from, to) => {
      let { text, ranges } = snippet2.instantiate(editor.state, from);
      let spec = {
        changes: {
          from,
          to,
          insert: Text$1.of(text)
        },
        scrollIntoView: true,
        annotations: completion ? [
          pickedCompletion.of(completion),
          Transaction.userEvent.of("input.complete")
        ] : void 0
      };
      if (ranges.length) spec.selection = fieldSelection(ranges, 0);
      if (ranges.some((r) => r.field > 0)) {
        let active = new ActiveSnippet(ranges, 0);
        let effects = spec.effects = [
          setActive.of(active)
        ];
        if (editor.state.field(snippetState, false) === void 0) effects.push(StateEffect.appendConfig.of([
          snippetState,
          addSnippetKeymap,
          snippetPointerHandler,
          baseTheme$1
        ]));
      }
      editor.dispatch(editor.state.update(spec));
    };
  }
  function moveField(dir) {
    return ({ state, dispatch }) => {
      let active = state.field(snippetState, false);
      if (!active || dir < 0 && active.active == 0) return false;
      let next = active.active + dir, last = dir > 0 && !active.ranges.some((r) => r.field == next + dir);
      dispatch(state.update({
        selection: fieldSelection(active.ranges, next),
        effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
        scrollIntoView: true
      }));
      return true;
    };
  }
  const clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active) return false;
    dispatch(state.update({
      effects: setActive.of(null)
    }));
    return true;
  };
  const nextSnippetField = moveField(1);
  const prevSnippetField = moveField(-1);
  const defaultSnippetKeymap = [
    {
      key: "Tab",
      run: nextSnippetField,
      shift: prevSnippetField
    },
    {
      key: "Escape",
      run: clearSnippet
    }
  ];
  const snippetKeymap = Facet.define({
    combine(maps) {
      return maps.length ? maps[0] : defaultSnippetKeymap;
    }
  });
  const addSnippetKeymap = Prec.highest(keymap.compute([
    snippetKeymap
  ], (state) => state.facet(snippetKeymap)));
  snippetCompletion = function(template, completion) {
    return Object.assign(Object.assign({}, completion), {
      apply: snippet(template)
    });
  };
  const snippetPointerHandler = EditorView.domEventHandlers({
    mousedown(event, view) {
      let active = view.state.field(snippetState, false), pos;
      if (!active || (pos = view.posAtCoords({
        x: event.clientX,
        y: event.clientY
      })) == null) return false;
      let match = active.ranges.find((r) => r.from <= pos && r.to >= pos);
      if (!match || match.field == active.active) return false;
      view.dispatch({
        selection: fieldSelection(active.ranges, match.field),
        effects: setActive.of(active.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),
        scrollIntoView: true
      });
      return true;
    }
  });
  const defaults = {
    brackets: [
      "(",
      "[",
      "{",
      "'",
      '"'
    ],
    before: ")]}:;>",
    stringPrefixes: []
  };
  const closeBracketEffect = StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  const closedBracket = new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  const bracketState = StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      value = value.map(tr.changes);
      if (tr.selection) {
        let line = tr.state.doc.lineAt(tr.selection.main.head);
        value = value.update({
          filter: (from) => from >= line.from && from <= line.to
        });
      }
      for (let effect of tr.effects) if (effect.is(closeBracketEffect)) value = value.update({
        add: [
          closedBracket.range(effect.value, effect.value + 1)
        ]
      });
      return value;
    }
  });
  function closeBrackets() {
    return [
      inputHandler,
      bracketState
    ];
  }
  const definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i2 = 0; i2 < definedClosing.length; i2 += 2) if (definedClosing.charCodeAt(i2) == ch) return definedClosing.charAt(i2 + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || defaults;
  }
  const android = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
  const inputHandler = EditorView.inputHandler.of((view, from, to, insert2) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;
    let sel = view.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to) return false;
    let tr = insertBracket(view.state, insert2);
    if (!tr) return false;
    view.dispatch(tr);
    return true;
  });
  const deleteBracketPair = ({ state, dispatch }) => {
    if (state.readOnly) return false;
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    let dont = null, changes = state.changeByRange((range) => {
      if (range.empty) {
        let before = prevChar(state.doc, range.head);
        for (let token of tokens) {
          if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0))) return {
            changes: {
              from: range.head - token.length,
              to: range.head + token.length
            },
            range: EditorSelection.cursor(range.head - token.length)
          };
        }
      }
      return {
        range: dont = range
      };
    });
    if (!dont) dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "delete.backward"
    }));
    return !dont;
  };
  const closeBracketsKeymap = [
    {
      key: "Backspace",
      run: deleteBracketPair
    }
  ];
  function insertBracket(state, bracket2) {
    let conf = config(state, state.selection.main.head);
    let tokens = conf.brackets || defaults.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt(tok, 0));
      if (bracket2 == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);
      if (bracket2 == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, (from) => {
      if (from == pos) found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function prevChar(doc2, pos) {
    let prev = doc2.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty) return {
        changes: [
          {
            insert: open,
            from: range.from
          },
          {
            insert: close,
            from: range.to
          }
        ],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
      let next = nextChar(state.doc, range.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1) return {
        changes: {
          insert: open + close,
          from: range.head
        },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
      return {
        range: dont = range
      };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state, _open, close) {
    let dont = null, changes = state.changeByRange((range) => {
      if (range.empty && nextChar(state.doc, range.head) == close) return {
        changes: {
          from: range.head,
          to: range.head + close.length,
          insert: close
        },
        range: EditorSelection.cursor(range.head + close.length)
      };
      return dont = {
        range
      };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleSame(state, token, allowTriple, config2) {
    let stringPrefixes = config2.stringPrefixes || defaults.stringPrefixes;
    let dont = null, changes = state.changeByRange((range) => {
      if (!range.empty) return {
        changes: [
          {
            insert: token,
            from: range.from
          },
          {
            insert: token,
            from: range.to
          }
        ],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
      let pos = range.head, next = nextChar(state.doc, pos), start;
      if (next == token) {
        if (nodeStart(state, pos)) {
          return {
            changes: {
              insert: token + token,
              from: pos
            },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state, pos)) {
          let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          let content2 = isTriple ? token + token + token : token;
          return {
            changes: {
              from: pos,
              to: pos + content2.length,
              insert: content2
            },
            range: EditorSelection.cursor(pos + content2.length)
          };
        }
      } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
        return {
          changes: {
            insert: token + token + token + token,
            from: pos
          },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
        if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {
          changes: {
            insert: token + token,
            from: pos
          },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      }
      return {
        range: dont = range
      };
    });
    return dont ? null : state.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state, pos) {
    let tree = syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state, pos, quoteToken, prefixes) {
    let node = syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
    for (let i2 = 0; i2 < 5; i2++) {
      let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
      let quotePos = start.indexOf(quoteToken);
      if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
        let first = node.firstChild;
        while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
          if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;
          first = first.firstChild;
        }
        return true;
      }
      let parent = node.to == pos && node.parent;
      if (!parent) break;
      node = parent;
    }
    return false;
  }
  function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word) return pos;
    for (let prefix of prefixes) {
      let start = pos - prefix.length;
      if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word) return start;
    }
    return -1;
  }
  function autocompletion(config2 = {}) {
    return [
      commitCharacters,
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme$1
    ];
  }
  const completionKeymap = [
    {
      key: "Ctrl-Space",
      run: startCompletion
    },
    {
      mac: "Alt-`",
      run: startCompletion
    },
    {
      key: "Escape",
      run: closeCompletion
    },
    {
      key: "ArrowDown",
      run: moveCompletionSelection(true)
    },
    {
      key: "ArrowUp",
      run: moveCompletionSelection(false)
    },
    {
      key: "PageDown",
      run: moveCompletionSelection(true, "page")
    },
    {
      key: "PageUp",
      run: moveCompletionSelection(false, "page")
    },
    {
      key: "Enter",
      run: acceptCompletion
    }
  ];
  const completionKeymapExt = Prec.highest(keymap.computeN([
    completionConfig
  ], (state) => state.facet(completionConfig).defaultKeymap ? [
    completionKeymap
  ] : []));
  class SelectedDiagnostic {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  }
  class LintState {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state.facet(lintConfig).markerFilter;
      if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics, state);
      let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);
      let deco = new RangeSetBuilder(), active = [], pos = 0;
      for (let i2 = 0; ; ) {
        let next = i2 == sorted.length ? null : sorted[i2];
        if (!next && !active.length) break;
        let from, to;
        if (active.length) {
          from = pos;
          to = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from ? next.from : 1e8);
        } else {
          from = next.from;
          to = next.to;
          active.push(next);
          i2++;
        }
        while (i2 < sorted.length) {
          let next2 = sorted[i2];
          if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
            active.push(next2);
            i2++;
            to = Math.min(next2.to, to);
          } else {
            to = Math.min(next2.from, to);
            break;
          }
        }
        let sev = maxSeverity(active);
        if (active.some((d) => d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)) {
          deco.add(from, from, Decoration.widget({
            widget: new DiagnosticWidget(sev),
            diagnostics: active.slice()
          }));
        } else {
          let markClass = active.reduce((c, d) => d.markClass ? c + " " + d.markClass : c, "");
          deco.add(from, to, Decoration.mark({
            class: "cm-lintRange cm-lintRange-" + sev + markClass,
            diagnostics: active.slice(),
            inclusiveEnd: active.some((a) => a.to > to)
          }));
        }
        pos = to;
        for (let i3 = 0; i3 < active.length; i3++) if (active[i3].to <= pos) active.splice(i3--, 1);
      }
      let set = deco.finish();
      return new LintState(set, panel, findDiagnostic(set));
    }
  }
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
      if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0) return;
      if (!found) found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
      else if (spec.diagnostics.indexOf(found.diagnostic) < 0) return false;
      else found = new SelectedDiagnostic(found.from, to, found.diagnostic);
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    let from = tooltip.pos, to = tooltip.end || from;
    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
    if (result != null) return result;
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some((e) => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
  }
  function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
  }
  const setDiagnosticsEffect = StateEffect.define();
  const togglePanel = StateEffect.define();
  const movePanelSelection = StateEffect.define();
  const lintState = StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged && value.diagnostics.size) {
        let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel) panel = null;
        value = new LintState(mapped, panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
          value = LintState.init(effect.value, panel, tr.state);
        } else if (effect.is(togglePanel)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f) => [
      showPanel.from(f, (val) => val.panel),
      EditorView.decorations.from(f, (s) => s.diagnostics)
    ]
  });
  const activeMark = Decoration.mark({
    class: "cm-lintRange cm-lintRange-active"
  });
  function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found, start = -1, end = -1;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found = spec.diagnostics;
        start = from;
        end = to;
        return false;
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (found && diagnosticFilter) found = diagnosticFilter(found, view.state);
    if (!found) return null;
    return {
      pos: start,
      end,
      above: view.state.doc.lineAt(start).to < end,
      create() {
        return {
          dom: diagnosticsTooltip(view, found)
        };
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", {
      class: "cm-tooltip-lint"
    }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
  }
  const openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel) view.dispatch({
      effects: maybeEnableLint(view.state, [
        togglePanel.of(true)
      ])
    });
    let panel = getPanel(view, LintPanel.open);
    if (panel) panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  const closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel) return false;
    view.dispatch({
      effects: togglePanel.of(false)
    });
    return true;
  };
  const nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field) return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to) return false;
    }
    view.dispatch({
      selection: {
        anchor: next.from,
        head: next.to
      },
      scrollIntoView: true
    });
    return true;
  };
  const lintKeymap = [
    {
      key: "Mod-Shift-m",
      run: openLintPanel,
      preventDefault: true
    },
    {
      key: "F8",
      run: nextDiagnostic
    }
  ];
  const lintConfig = Facet.define({
    combine(input) {
      return Object.assign({
        sources: input.map((i2) => i2.source).filter((x) => x != null)
      }, combineConfig(input.map((i2) => i2.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        needsRefresh: (a, b) => !a ? b : !b ? a : (u) => a(u) || b(u)
      }));
    }
  });
  function assignKeys(actions) {
    let assigned = [];
    if (actions) actions: for (let { name: name2 } of actions) {
      for (let i2 = 0; i2 < name2.length; i2++) {
        let ch = name2[i2];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", {
      class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity
    }, crelt("span", {
      class: "cm-diagnosticText"
    }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i2) => {
      let fired = false, click = (e) => {
        e.preventDefault();
        if (fired) return;
        fired = true;
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found) action.apply(view, found.from, found.to);
      };
      let { name: name2 } = action, keyIndex = keys2[i2] ? name2.indexOf(keys2[i2]) : -1;
      let nameElt = keyIndex < 0 ? name2 : [
        name2.slice(0, keyIndex),
        crelt("u", name2.slice(keyIndex, keyIndex + 1)),
        name2.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i2]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", {
      class: "cm-diagnosticSource"
    }, diagnostic.source));
  }
  class DiagnosticWidget extends WidgetType {
    constructor(sev) {
      super();
      this.sev = sev;
    }
    eq(other) {
      return other.sev == this.sev;
    }
    toDOM() {
      return crelt("span", {
        class: "cm-lintPoint cm-lintPoint-" + this.sev
      });
    }
  }
  class PanelItem {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  }
  class LintPanel {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
          for (let i2 = 0; i2 < keys2.length; i2++) if (keys2[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found) diagnostic.actions[i2].apply(view, found.from, found.to);
          }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i2 = 0; i2 < this.items.length; i2++) {
          if (this.items[i2].dom.contains(event.target)) this.moveSelection(i2);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", {
        class: "cm-panel-lint"
      }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected) return -1;
      for (let i2 = 0; i2 < this.items.length; i2++) if (this.items[i2].diagnostic == selected.diagnostic) return i2;
      return -1;
    }
    update() {
      let { diagnostics, selected } = this.view.state.field(lintState);
      let i2 = 0, needsSync = false, newSelectedItem = null;
      let seen = /* @__PURE__ */ new Set();
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        for (let diagnostic of spec.diagnostics) {
          if (seen.has(diagnostic)) continue;
          seen.add(diagnostic);
          let found = -1, item;
          for (let j = i2; j < this.items.length; j++) if (this.items[j].diagnostic == diagnostic) {
            found = j;
            break;
          }
          if (found < 0) {
            item = new PanelItem(this.view, diagnostic);
            this.items.splice(i2, 0, item);
            needsSync = true;
          } else {
            item = this.items[found];
            if (found > i2) {
              this.items.splice(i2, found - i2);
              needsSync = true;
            }
          }
          if (selected && item.diagnostic == selected.diagnostic) {
            if (!item.dom.hasAttribute("aria-selected")) {
              item.dom.setAttribute("aria-selected", "true");
              newSelectedItem = item;
            }
          } else if (item.dom.hasAttribute("aria-selected")) {
            item.dom.removeAttribute("aria-selected");
          }
          i2++;
        }
      });
      while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({
            sel: newSelectedItem.dom.getBoundingClientRect(),
            panel: this.list.getBoundingClientRect()
          }),
          write: ({ sel, panel }) => {
            let scaleY = panel.height / this.list.offsetHeight;
            if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;
            else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync) this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom) rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos) rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0) return;
      let field = this.view.state.field(lintState);
      let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection2) return;
      this.view.dispatch({
        selection: {
          anchor: selection2.from,
          head: selection2.to
        },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection2)
      });
    }
    static open(view) {
      return new LintPanel(view);
    }
  }
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  const baseTheme = EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": {
      borderLeft: "5px solid #d11"
    },
    ".cm-diagnostic-warning": {
      borderLeft: "5px solid orange"
    },
    ".cm-diagnostic-info": {
      borderLeft: "5px solid #999"
    },
    ".cm-diagnostic-hint": {
      borderLeft: "5px solid #66d"
    },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px",
      cursor: "pointer"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": {
      backgroundImage: underline("#d11")
    },
    ".cm-lintRange-warning": {
      backgroundImage: underline("orange")
    },
    ".cm-lintRange-info": {
      backgroundImage: underline("#999")
    },
    ".cm-lintRange-hint": {
      backgroundImage: underline("#66d")
    },
    ".cm-lintRange-active": {
      backgroundColor: "#ffdd9980"
    },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": {
        borderBottomColor: "orange"
      }
    },
    ".cm-lintPoint-info": {
      "&:after": {
        borderBottomColor: "#999"
      }
    },
    ".cm-lintPoint-hint": {
      "&:after": {
        borderBottomColor: "#66d"
      }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": {
            textDecoration: "underline"
          }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": {
          textDecoration: "none"
        },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });
  function severityWeight(sev) {
    return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
  }
  function maxSeverity(diagnostics) {
    let sev = "hint", weight = 1;
    for (let d of diagnostics) {
      let w = severityWeight(d.severity);
      if (w > weight) {
        weight = w;
        sev = d.severity;
      }
    }
    return sev;
  }
  const lintExtensions = [
    lintState,
    EditorView.decorations.compute([
      lintState
    ], (state) => {
      let { selected, panel } = state.field(lintState);
      return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
        activeMark.range(selected.from, selected.to)
      ]);
    }),
    hoverTooltip(lintTooltip, {
      hideOn: hideTooltip
    }),
    baseTheme
  ];
  var basicSetup = function basicSetup2(options) {
    if (options === void 0) {
      options = {};
    }
    var { crosshairCursor: initCrosshairCursor = false } = options;
    var keymaps = [];
    if (options.closeBracketsKeymap !== false) {
      keymaps = keymaps.concat(closeBracketsKeymap);
    }
    if (options.defaultKeymap !== false) {
      keymaps = keymaps.concat(defaultKeymap);
    }
    if (options.searchKeymap !== false) {
      keymaps = keymaps.concat(searchKeymap);
    }
    if (options.historyKeymap !== false) {
      keymaps = keymaps.concat(historyKeymap);
    }
    if (options.foldKeymap !== false) {
      keymaps = keymaps.concat(foldKeymap);
    }
    if (options.completionKeymap !== false) {
      keymaps = keymaps.concat(completionKeymap);
    }
    if (options.lintKeymap !== false) {
      keymaps = keymaps.concat(lintKeymap);
    }
    var extensions = [];
    if (options.lineNumbers !== false) extensions.push(lineNumbers());
    if (options.highlightActiveLineGutter !== false) extensions.push(highlightActiveLineGutter());
    if (options.highlightSpecialChars !== false) extensions.push(highlightSpecialChars());
    if (options.history !== false) extensions.push(history());
    if (options.foldGutter !== false) extensions.push(foldGutter());
    if (options.drawSelection !== false) extensions.push(drawSelection());
    if (options.dropCursor !== false) extensions.push(dropCursor());
    if (options.allowMultipleSelections !== false) extensions.push(EditorState.allowMultipleSelections.of(true));
    if (options.indentOnInput !== false) extensions.push(indentOnInput());
    if (options.syntaxHighlighting !== false) extensions.push(syntaxHighlighting(defaultHighlightStyle, {
      fallback: true
    }));
    if (options.bracketMatching !== false) extensions.push(bracketMatching());
    if (options.closeBrackets !== false) extensions.push(closeBrackets());
    if (options.autocompletion !== false) extensions.push(autocompletion());
    if (options.rectangularSelection !== false) extensions.push(rectangularSelection());
    if (initCrosshairCursor !== false) extensions.push(crosshairCursor());
    if (options.highlightActiveLine !== false) extensions.push(highlightActiveLine());
    if (options.highlightSelectionMatches !== false) extensions.push(highlightSelectionMatches());
    if (options.tabSize && typeof options.tabSize === "number") extensions.push(indentUnit.of(" ".repeat(options.tabSize)));
    return extensions.concat([
      keymap.of(keymaps.flat())
    ]).filter(Boolean);
  };
  const chalky = "#e5c07b", coral = "#e06c75", cyan = "#56b6c2", invalid = "#ffffff", ivory = "#abb2bf", stone = "#7d8799", malibu = "#61afef", sage = "#98c379", whiskey = "#d19a66", violet = "#c678dd", darkBackground = "#21252b", highlightBackground = "#2c313a", background = "#282c34", tooltipBackground = "#353a42", selection = "#3E4451", cursor = "#528bff";
  const oneDarkTheme = EditorView.theme({
    "&": {
      color: ivory,
      backgroundColor: background
    },
    ".cm-content": {
      caretColor: cursor
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: cursor
    },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: selection
    },
    ".cm-panels": {
      backgroundColor: darkBackground,
      color: ivory
    },
    ".cm-panels.cm-panels-top": {
      borderBottom: "2px solid black"
    },
    ".cm-panels.cm-panels-bottom": {
      borderTop: "2px solid black"
    },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": {
      backgroundColor: "#6699ff0b"
    },
    ".cm-selectionMatch": {
      backgroundColor: "#aafe661a"
    },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: background,
      color: stone,
      border: "none"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: highlightBackground,
        color: ivory
      }
    }
  }, {
    dark: true
  });
  const oneDarkHighlightStyle = HighlightStyle.define([
    {
      tag: tags.keyword,
      color: violet
    },
    {
      tag: [
        tags.name,
        tags.deleted,
        tags.character,
        tags.propertyName,
        tags.macroName
      ],
      color: coral
    },
    {
      tag: [
        tags.function(tags.variableName),
        tags.labelName
      ],
      color: malibu
    },
    {
      tag: [
        tags.color,
        tags.constant(tags.name),
        tags.standard(tags.name)
      ],
      color: whiskey
    },
    {
      tag: [
        tags.definition(tags.name),
        tags.separator
      ],
      color: ivory
    },
    {
      tag: [
        tags.typeName,
        tags.className,
        tags.number,
        tags.changed,
        tags.annotation,
        tags.modifier,
        tags.self,
        tags.namespace
      ],
      color: chalky
    },
    {
      tag: [
        tags.operator,
        tags.operatorKeyword,
        tags.url,
        tags.escape,
        tags.regexp,
        tags.link,
        tags.special(tags.string)
      ],
      color: cyan
    },
    {
      tag: [
        tags.meta,
        tags.comment
      ],
      color: stone
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.link,
      color: stone,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      fontWeight: "bold",
      color: coral
    },
    {
      tag: [
        tags.atom,
        tags.bool,
        tags.special(tags.variableName)
      ],
      color: whiskey
    },
    {
      tag: [
        tags.processingInstruction,
        tags.string,
        tags.inserted
      ],
      color: sage
    },
    {
      tag: tags.invalid,
      color: invalid
    }
  ]);
  const oneDark = [
    oneDarkTheme,
    syntaxHighlighting(oneDarkHighlightStyle)
  ];
  var defaultLightThemeOption = EditorView.theme({
    "&": {
      backgroundColor: "#fff"
    }
  }, {
    dark: false
  });
  var getDefaultExtensions = function getDefaultExtensions2(optios) {
    if (optios === void 0) {
      optios = {};
    }
    var { indentWithTab: defaultIndentWithTab = true, editable: editable2 = true, readOnly: readOnly2 = false, theme: theme2 = "light", placeholder: placeholderStr = "", basicSetup: defaultBasicSetup = true } = optios;
    var getExtensions = [];
    if (defaultIndentWithTab) {
      getExtensions.unshift(keymap.of([
        indentWithTab
      ]));
    }
    if (defaultBasicSetup) {
      if (typeof defaultBasicSetup === "boolean") {
        getExtensions.unshift(basicSetup());
      } else {
        getExtensions.unshift(basicSetup(defaultBasicSetup));
      }
    }
    if (placeholderStr) {
      getExtensions.unshift(placeholder(placeholderStr));
    }
    switch (theme2) {
      case "light":
        getExtensions.push(defaultLightThemeOption);
        break;
      case "dark":
        getExtensions.push(oneDark);
        break;
      case "none":
        break;
      default:
        getExtensions.push(theme2);
        break;
    }
    if (editable2 === false) {
      getExtensions.push(EditorView.editable.of(false));
    }
    if (readOnly2) {
      getExtensions.push(EditorState.readOnly.of(true));
    }
    return [
      ...getExtensions
    ];
  };
  var getStatistics = (view) => {
    return {
      line: view.state.doc.lineAt(view.state.selection.main.from),
      lineCount: view.state.doc.lines,
      lineBreak: view.state.lineBreak,
      length: view.state.doc.length,
      readOnly: view.state.readOnly,
      tabSize: view.state.tabSize,
      selection: view.state.selection,
      selectionAsSingle: view.state.selection.asSingle().main,
      ranges: view.state.selection.ranges,
      selectionCode: view.state.sliceDoc(view.state.selection.main.from, view.state.selection.main.to),
      selections: view.state.selection.ranges.map((r) => view.state.sliceDoc(r.from, r.to)),
      selectedText: view.state.selection.ranges.some((r) => !r.empty)
    };
  };
  var External = Annotation.define();
  var emptyExtensions = [];
  function useCodeMirror(props) {
    var { value, selection: selection2, onChange, onStatistics, onCreateEditor, onUpdate, extensions = emptyExtensions, autoFocus, theme: theme2 = "light", height = null, minHeight = null, maxHeight = null, width = null, minWidth = null, maxWidth = null, placeholder: placeholderStr = "", editable: editable2 = true, readOnly: readOnly2 = false, indentWithTab: defaultIndentWithTab = true, basicSetup: defaultBasicSetup = true, root, initialState } = props;
    var [container, setContainer] = reactExports.useState();
    var [view, setView] = reactExports.useState();
    var [state, setState] = reactExports.useState();
    var defaultThemeOption = EditorView.theme({
      "&": {
        height,
        minHeight,
        maxHeight,
        width,
        minWidth,
        maxWidth
      },
      "& .cm-scroller": {
        height: "100% !important"
      }
    });
    var updateListener2 = EditorView.updateListener.of((vu) => {
      if (vu.docChanged && typeof onChange === "function" && !vu.transactions.some((tr) => tr.annotation(External))) {
        var doc2 = vu.state.doc;
        var _value = doc2.toString();
        onChange(_value, vu);
      }
      onStatistics && onStatistics(getStatistics(vu));
    });
    var defaultExtensions = getDefaultExtensions({
      theme: theme2,
      editable: editable2,
      readOnly: readOnly2,
      placeholder: placeholderStr,
      indentWithTab: defaultIndentWithTab,
      basicSetup: defaultBasicSetup
    });
    var getExtensions = [
      updateListener2,
      defaultThemeOption,
      ...defaultExtensions
    ];
    if (onUpdate && typeof onUpdate === "function") {
      getExtensions.push(EditorView.updateListener.of(onUpdate));
    }
    getExtensions = getExtensions.concat(extensions);
    reactExports.useEffect(() => {
      if (container && !state) {
        var config2 = {
          doc: value,
          selection: selection2,
          extensions: getExtensions
        };
        var stateCurrent = initialState ? EditorState.fromJSON(initialState.json, config2, initialState.fields) : EditorState.create(config2);
        setState(stateCurrent);
        if (!view) {
          var viewCurrent = new EditorView({
            state: stateCurrent,
            parent: container,
            root
          });
          setView(viewCurrent);
          onCreateEditor && onCreateEditor(viewCurrent, stateCurrent);
        }
      }
      return () => {
        if (view) {
          setState(void 0);
          setView(void 0);
        }
      };
    }, [
      container,
      state
    ]);
    reactExports.useEffect(() => setContainer(props.container), [
      props.container
    ]);
    reactExports.useEffect(() => () => {
      if (view) {
        view.destroy();
        setView(void 0);
      }
    }, [
      view
    ]);
    reactExports.useEffect(() => {
      if (autoFocus && view) {
        view.focus();
      }
    }, [
      autoFocus,
      view
    ]);
    reactExports.useEffect(() => {
      if (view) {
        view.dispatch({
          effects: StateEffect.reconfigure.of(getExtensions)
        });
      }
    }, [
      theme2,
      extensions,
      height,
      minHeight,
      maxHeight,
      width,
      minWidth,
      maxWidth,
      placeholderStr,
      editable2,
      readOnly2,
      defaultIndentWithTab,
      defaultBasicSetup,
      onChange,
      onUpdate
    ]);
    reactExports.useEffect(() => {
      if (value === void 0) {
        return;
      }
      var currentValue = view ? view.state.doc.toString() : "";
      if (view && value !== currentValue) {
        view.dispatch({
          changes: {
            from: 0,
            to: currentValue.length,
            insert: value || ""
          },
          annotations: [
            External.of(true)
          ]
        });
      }
    }, [
      value,
      view
    ]);
    return {
      state,
      setState,
      view,
      setView,
      container,
      setContainer
    };
  }
  var _excluded = [
    "className",
    "value",
    "selection",
    "extensions",
    "onChange",
    "onStatistics",
    "onCreateEditor",
    "onUpdate",
    "autoFocus",
    "theme",
    "height",
    "minHeight",
    "maxHeight",
    "width",
    "minWidth",
    "maxWidth",
    "basicSetup",
    "placeholder",
    "indentWithTab",
    "editable",
    "readOnly",
    "root",
    "initialState"
  ];
  var ReactCodeMirror = reactExports.forwardRef((props, ref) => {
    var { className, value = "", selection: selection2, extensions = [], onChange, onStatistics, onCreateEditor, onUpdate, autoFocus, theme: theme2 = "light", height, minHeight, maxHeight, width, minWidth, maxWidth, basicSetup: basicSetup2, placeholder: placeholder2, indentWithTab: indentWithTab2, editable: editable2, readOnly: readOnly2, root, initialState } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
    var editor = reactExports.useRef(null);
    var { state, view, container } = useCodeMirror({
      container: editor.current,
      root,
      value,
      autoFocus,
      theme: theme2,
      height,
      minHeight,
      maxHeight,
      width,
      minWidth,
      maxWidth,
      basicSetup: basicSetup2,
      placeholder: placeholder2,
      indentWithTab: indentWithTab2,
      editable: editable2,
      readOnly: readOnly2,
      selection: selection2,
      onChange,
      onStatistics,
      onCreateEditor,
      onUpdate,
      extensions,
      initialState
    });
    reactExports.useImperativeHandle(ref, () => ({
      editor: editor.current,
      state,
      view
    }), [
      editor,
      container,
      state,
      view
    ]);
    if (typeof value !== "string") {
      throw new Error("value must be typeof string but got " + typeof value);
    }
    var defaultClassNames = typeof theme2 === "string" ? "cm-theme-" + theme2 : "cm-theme";
    return jsxRuntimeExports.jsx("div", _extends({
      ref: editor,
      className: "" + defaultClassNames + (className ? " " + className : "")
    }, other));
  });
  ReactCodeMirror.displayName = "CodeMirror";
  function useStateMachine(initialState, machine) {
    return reactExports.useReducer((state, event) => {
      const nextState = machine[state][event];
      return nextState ?? state;
    }, initialState);
  }
  var SCROLL_AREA_NAME = "ScrollArea";
  var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
  var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
  var ScrollArea$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeScrollArea, type = "hover", dir, scrollHideDelay = 600, ...scrollAreaProps } = props;
    const [scrollArea, setScrollArea] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const [content2, setContent] = reactExports.useState(null);
    const [scrollbarX, setScrollbarX] = reactExports.useState(null);
    const [scrollbarY, setScrollbarY] = reactExports.useState(null);
    const [cornerWidth, setCornerWidth] = reactExports.useState(0);
    const [cornerHeight, setCornerHeight] = reactExports.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = reactExports.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = reactExports.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return jsxRuntimeExports.jsx(ScrollAreaProvider, {
      scope: __scopeScrollArea,
      type,
      dir: direction,
      scrollHideDelay,
      scrollArea,
      viewport,
      onViewportChange: setViewport,
      content: content2,
      onContentChange: setContent,
      scrollbarX,
      onScrollbarXChange: setScrollbarX,
      scrollbarXEnabled,
      onScrollbarXEnabledChange: setScrollbarXEnabled,
      scrollbarY,
      onScrollbarYChange: setScrollbarY,
      scrollbarYEnabled,
      onScrollbarYEnabledChange: setScrollbarYEnabled,
      onCornerWidthChange: setCornerWidth,
      onCornerHeightChange: setCornerHeight,
      children: jsxRuntimeExports.jsx(Primitive.div, {
        dir: direction,
        ...scrollAreaProps,
        ref: composedRefs,
        style: {
          position: "relative",
          ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
          ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
          ...props.style
        }
      })
    });
  });
  ScrollArea$1.displayName = SCROLL_AREA_NAME;
  var VIEWPORT_NAME = "ScrollAreaViewport";
  var ScrollAreaViewport = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx("style", {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }),
        jsxRuntimeExports.jsx(Primitive.div, {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          ref: composedRefs,
          style: {
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: jsxRuntimeExports.jsx("div", {
            ref: context.onContentChange,
            style: {
              minWidth: "100%",
              display: "table"
            },
            children
          })
        })
      ]
    });
  });
  ScrollAreaViewport.displayName = VIEWPORT_NAME;
  var SCROLLBAR_NAME = "ScrollAreaScrollbar";
  var ScrollAreaScrollbar = reactExports.forwardRef((props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    reactExports.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [
      isHorizontal,
      onScrollbarXEnabledChange,
      onScrollbarYEnabledChange
    ]);
    return context.type === "hover" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, {
      ...scrollbarProps,
      ref: forwardedRef,
      forceMount
    }) : context.type === "scroll" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, {
      ...scrollbarProps,
      ref: forwardedRef,
      forceMount
    }) : context.type === "auto" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, {
      ...scrollbarProps,
      ref: forwardedRef,
      forceMount
    }) : context.type === "always" ? jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
      ...scrollbarProps,
      ref: forwardedRef
    }) : null;
  });
  ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
  var ScrollAreaScrollbarHover = reactExports.forwardRef((props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const [visible, setVisible] = reactExports.useState(false);
    reactExports.useEffect(() => {
      const scrollArea = context.scrollArea;
      let hideTimer = 0;
      if (scrollArea) {
        const handlePointerEnter = () => {
          window.clearTimeout(hideTimer);
          setVisible(true);
        };
        const handlePointerLeave = () => {
          hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
        };
        scrollArea.addEventListener("pointerenter", handlePointerEnter);
        scrollArea.addEventListener("pointerleave", handlePointerLeave);
        return () => {
          window.clearTimeout(hideTimer);
          scrollArea.removeEventListener("pointerenter", handlePointerEnter);
          scrollArea.removeEventListener("pointerleave", handlePointerLeave);
        };
      }
    }, [
      context.scrollArea,
      context.scrollHideDelay
    ]);
    return jsxRuntimeExports.jsx(Presence, {
      present: forceMount || visible,
      children: jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, {
        "data-state": visible ? "visible" : "hidden",
        ...scrollbarProps,
        ref: forwardedRef
      })
    });
  });
  var ScrollAreaScrollbarScroll = reactExports.forwardRef((props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const isHorizontal = props.orientation === "horizontal";
    const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
    const [state, send] = useStateMachine("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    reactExports.useEffect(() => {
      if (state === "idle") {
        const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
        return () => window.clearTimeout(hideTimer);
      }
    }, [
      state,
      context.scrollHideDelay,
      send
    ]);
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll = () => {
          const scrollPos = viewport[scrollDirection];
          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
          if (hasScrollInDirectionChanged) {
            send("SCROLL");
            debounceScrollEnd();
          }
          prevScrollPos = scrollPos;
        };
        viewport.addEventListener("scroll", handleScroll);
        return () => viewport.removeEventListener("scroll", handleScroll);
      }
    }, [
      context.viewport,
      isHorizontal,
      send,
      debounceScrollEnd
    ]);
    return jsxRuntimeExports.jsx(Presence, {
      present: forceMount || state !== "hidden",
      children: jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
        "data-state": state === "hidden" ? "hidden" : "visible",
        ...scrollbarProps,
        ref: forwardedRef,
        onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
      })
    });
  });
  var ScrollAreaScrollbarAuto = reactExports.forwardRef((props, forwardedRef) => {
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { forceMount, ...scrollbarProps } = props;
    const [visible, setVisible] = reactExports.useState(false);
    const isHorizontal = props.orientation === "horizontal";
    const handleResize = useDebounceCallback(() => {
      if (context.viewport) {
        const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
        const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
        setVisible(isHorizontal ? isOverflowX : isOverflowY);
      }
    }, 10);
    useResizeObserver(context.viewport, handleResize);
    useResizeObserver(context.content, handleResize);
    return jsxRuntimeExports.jsx(Presence, {
      present: forceMount || visible,
      children: jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, {
        "data-state": visible ? "visible" : "hidden",
        ...scrollbarProps,
        ref: forwardedRef
      })
    });
  });
  var ScrollAreaScrollbarVisible = reactExports.forwardRef((props, forwardedRef) => {
    const { orientation = "vertical", ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const thumbRef = reactExports.useRef(null);
    const pointerOffsetRef = reactExports.useRef(0);
    const [sizes, setSizes] = reactExports.useState({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    });
    const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
    const commonProps = {
      ...scrollbarProps,
      sizes,
      onSizesChange: setSizes,
      hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
      onThumbChange: (thumb) => thumbRef.current = thumb,
      onThumbPointerUp: () => pointerOffsetRef.current = 0,
      onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
    };
    function getScrollPosition(pointerPos, dir) {
      return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
    }
    if (orientation === "horizontal") {
      return jsxRuntimeExports.jsx(ScrollAreaScrollbarX, {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      });
    }
    if (orientation === "vertical") {
      return jsxRuntimeExports.jsx(ScrollAreaScrollbarY, {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      });
    }
    return null;
  });
  var ScrollAreaScrollbarX = reactExports.forwardRef((props, forwardedRef) => {
    const { sizes, onSizesChange, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const [computedStyle, setComputedStyle] = reactExports.useState();
    const ref = reactExports.useRef(null);
    const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
    reactExports.useEffect(() => {
      if (ref.current) setComputedStyle(getComputedStyle(ref.current));
    }, [
      ref
    ]);
    return jsxRuntimeExports.jsx(ScrollAreaScrollbarImpl, {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    });
  });
  var ScrollAreaScrollbarY = reactExports.forwardRef((props, forwardedRef) => {
    const { sizes, onSizesChange, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const [computedStyle, setComputedStyle] = reactExports.useState();
    const ref = reactExports.useRef(null);
    const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
    reactExports.useEffect(() => {
      if (ref.current) setComputedStyle(getComputedStyle(ref.current));
    }, [
      ref
    ]);
    return jsxRuntimeExports.jsx(ScrollAreaScrollbarImpl, {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    });
  });
  var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
  var ScrollAreaScrollbarImpl = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeScrollArea, sizes, hasThumb, onThumbChange, onThumbPointerUp, onThumbPointerDown, onThumbPositionChange, onDragScroll, onWheelScroll, onResize, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
    const [scrollbar, setScrollbar] = reactExports.useState(null);
    const composeRefs = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
    const rectRef = reactExports.useRef(null);
    const prevWebkitUserSelectRef = reactExports.useRef("");
    const viewport = context.viewport;
    const maxScrollPos = sizes.content - sizes.viewport;
    const handleWheelScroll = useCallbackRef(onWheelScroll);
    const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);
    const handleResize = useDebounceCallback(onResize, 10);
    function handleDragScroll(event) {
      if (rectRef.current) {
        const x = event.clientX - rectRef.current.left;
        const y = event.clientY - rectRef.current.top;
        onDragScroll({
          x,
          y
        });
      }
    }
    reactExports.useEffect(() => {
      const handleWheel = (event) => {
        const element = event.target;
        const isScrollbarWheel = scrollbar == null ? void 0 : scrollbar.contains(element);
        if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
      };
      document.addEventListener("wheel", handleWheel, {
        passive: false
      });
      return () => document.removeEventListener("wheel", handleWheel, {
        passive: false
      });
    }, [
      viewport,
      scrollbar,
      maxScrollPos,
      handleWheelScroll
    ]);
    reactExports.useEffect(handleThumbPositionChange, [
      sizes,
      handleThumbPositionChange
    ]);
    useResizeObserver(scrollbar, handleResize);
    useResizeObserver(context.content, handleResize);
    return jsxRuntimeExports.jsx(ScrollbarProvider, {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef(onThumbChange),
      onThumbPointerUp: useCallbackRef(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef(onThumbPointerDown),
      children: jsxRuntimeExports.jsx(Primitive.div, {
        ...scrollbarProps,
        ref: composeRefs,
        style: {
          position: "absolute",
          ...scrollbarProps.style
        },
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const mainPointer = 0;
          if (event.button === mainPointer) {
            const element = event.target;
            element.setPointerCapture(event.pointerId);
            rectRef.current = scrollbar.getBoundingClientRect();
            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
            document.body.style.webkitUserSelect = "none";
            if (context.viewport) context.viewport.style.scrollBehavior = "auto";
            handleDragScroll(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const element = event.target;
          if (element.hasPointerCapture(event.pointerId)) {
            element.releasePointerCapture(event.pointerId);
          }
          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
          if (context.viewport) context.viewport.style.scrollBehavior = "";
          rectRef.current = null;
        })
      })
    });
  });
  var THUMB_NAME = "ScrollAreaThumb";
  var ScrollAreaThumb = reactExports.forwardRef((props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
    return jsxRuntimeExports.jsx(Presence, {
      present: forceMount || scrollbarContext.hasThumb,
      children: jsxRuntimeExports.jsx(ScrollAreaThumbImpl, {
        ref: forwardedRef,
        ...thumbProps
      })
    });
  });
  var ScrollAreaThumbImpl = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeScrollArea, style, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(forwardedRef, (node) => scrollbarContext.onThumbChange(node));
    const removeUnlinkedScrollListenerRef = reactExports.useRef();
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    reactExports.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll);
        return () => viewport.removeEventListener("scroll", handleScroll);
      }
    }, [
      scrollAreaContext.viewport,
      debounceScrollEnd,
      onThumbPositionChange
    ]);
    return jsxRuntimeExports.jsx(Primitive.div, {
      "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
      ...thumbProps,
      ref: composedRef,
      style: {
        width: "var(--radix-scroll-area-thumb-width)",
        height: "var(--radix-scroll-area-thumb-height)",
        ...style
      },
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
        const thumb = event.target;
        const thumbRect = thumb.getBoundingClientRect();
        const x = event.clientX - thumbRect.left;
        const y = event.clientY - thumbRect.top;
        scrollbarContext.onThumbPointerDown({
          x,
          y
        });
      }),
      onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
    });
  });
  ScrollAreaThumb.displayName = THUMB_NAME;
  var CORNER_NAME = "ScrollAreaCorner";
  var ScrollAreaCorner = reactExports.forwardRef((props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? jsxRuntimeExports.jsx(ScrollAreaCornerImpl, {
      ...props,
      ref: forwardedRef
    }) : null;
  });
  ScrollAreaCorner.displayName = CORNER_NAME;
  var ScrollAreaCornerImpl = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeScrollArea, ...cornerProps } = props;
    const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
    const [width, setWidth] = reactExports.useState(0);
    const [height, setHeight] = reactExports.useState(0);
    const hasSize = Boolean(width && height);
    useResizeObserver(context.scrollbarX, () => {
      var _a2;
      const height2 = ((_a2 = context.scrollbarX) == null ? void 0 : _a2.offsetHeight) || 0;
      context.onCornerHeightChange(height2);
      setHeight(height2);
    });
    useResizeObserver(context.scrollbarY, () => {
      var _a2;
      const width2 = ((_a2 = context.scrollbarY) == null ? void 0 : _a2.offsetWidth) || 0;
      context.onCornerWidthChange(width2);
      setWidth(width2);
    });
    return hasSize ? jsxRuntimeExports.jsx(Primitive.div, {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }) : null;
  });
  function toInt(value) {
    return value ? parseInt(value, 10) : 0;
  }
  function getThumbRatio(viewportSize, contentSize) {
    const ratio = viewportSize / contentSize;
    return isNaN(ratio) ? 0 : ratio;
  }
  function getThumbSize(sizes) {
    const ratio = getThumbRatio(sizes.viewport, sizes.content);
    const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
    const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
    return Math.max(thumbSize, 18);
  }
  function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
    const thumbSizePx = getThumbSize(sizes);
    const thumbCenter = thumbSizePx / 2;
    const offset = pointerOffset || thumbCenter;
    const thumbOffsetFromEnd = thumbSizePx - offset;
    const minPointerPos = sizes.scrollbar.paddingStart + offset;
    const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
    const maxScrollPos = sizes.content - sizes.viewport;
    const scrollRange = dir === "ltr" ? [
      0,
      maxScrollPos
    ] : [
      maxScrollPos * -1,
      0
    ];
    const interpolate = linearScale([
      minPointerPos,
      maxPointerPos
    ], scrollRange);
    return interpolate(pointerPos);
  }
  function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
    const thumbSizePx = getThumbSize(sizes);
    const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
    const scrollbar = sizes.scrollbar.size - scrollbarPadding;
    const maxScrollPos = sizes.content - sizes.viewport;
    const maxThumbPos = scrollbar - thumbSizePx;
    const scrollClampRange = dir === "ltr" ? [
      0,
      maxScrollPos
    ] : [
      maxScrollPos * -1,
      0
    ];
    const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);
    const interpolate = linearScale([
      0,
      maxScrollPos
    ], [
      0,
      maxThumbPos
    ]);
    return interpolate(scrollWithoutMomentum);
  }
  function linearScale(input, output) {
    return (value) => {
      if (input[0] === input[1] || output[0] === output[1]) return output[0];
      const ratio = (output[1] - output[0]) / (input[1] - input[0]);
      return output[0] + ratio * (value - input[0]);
    };
  }
  function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
    return scrollPos > 0 && scrollPos < maxScrollPos;
  }
  var addUnlinkedScrollListener = (node, handler = () => {
  }) => {
    let prevPosition = {
      left: node.scrollLeft,
      top: node.scrollTop
    };
    let rAF = 0;
    (function loop() {
      const position = {
        left: node.scrollLeft,
        top: node.scrollTop
      };
      const isHorizontalScroll = prevPosition.left !== position.left;
      const isVerticalScroll = prevPosition.top !== position.top;
      if (isHorizontalScroll || isVerticalScroll) handler();
      prevPosition = position;
      rAF = window.requestAnimationFrame(loop);
    })();
    return () => window.cancelAnimationFrame(rAF);
  };
  function useDebounceCallback(callback, delay) {
    const handleCallback = useCallbackRef(callback);
    const debounceTimerRef = reactExports.useRef(0);
    reactExports.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
    return reactExports.useCallback(() => {
      window.clearTimeout(debounceTimerRef.current);
      debounceTimerRef.current = window.setTimeout(handleCallback, delay);
    }, [
      handleCallback,
      delay
    ]);
  }
  function useResizeObserver(element, onResize) {
    const handleResize = useCallbackRef(onResize);
    useLayoutEffect2(() => {
      let rAF = 0;
      if (element) {
        const resizeObserver = new ResizeObserver(() => {
          cancelAnimationFrame(rAF);
          rAF = window.requestAnimationFrame(handleResize);
        });
        resizeObserver.observe(element);
        return () => {
          window.cancelAnimationFrame(rAF);
          resizeObserver.unobserve(element);
        };
      }
    }, [
      element,
      handleResize
    ]);
  }
  var Root = ScrollArea$1;
  var Viewport = ScrollAreaViewport;
  var Corner = ScrollAreaCorner;
  const ScrollArea = reactExports.forwardRef(({ className, children, ...props }, ref) => jsxRuntimeExports.jsxs(Root, {
    ref,
    className: cn("relative overflow-hidden", className),
    ...props,
    children: [
      jsxRuntimeExports.jsx(Viewport, {
        className: "h-full w-full rounded-[inherit]",
        children
      }),
      jsxRuntimeExports.jsx(ScrollBar, {}),
      jsxRuntimeExports.jsx(Corner, {})
    ]
  }));
  ScrollArea.displayName = Root.displayName;
  const ScrollBar = reactExports.forwardRef(({ className, orientation = "vertical", ...props }, ref) => jsxRuntimeExports.jsx(ScrollAreaScrollbar, {
    ref,
    orientation,
    className: cn("flex touch-none select-none transition-colors", orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]", orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]", className),
    ...props,
    children: jsxRuntimeExports.jsx(ScrollAreaThumb, {
      className: "relative flex-1 rounded-full bg-border"
    })
  }));
  ScrollBar.displayName = ScrollAreaScrollbar.displayName;
  const TreeContext = reactExports.createContext(null);
  const useTree = () => {
    const context = reactExports.useContext(TreeContext);
    if (!context) {
      throw new Error("useTree must be used within a TreeProvider");
    }
    return context;
  };
  const Tree = reactExports.forwardRef(({ className, elements, initialSelectedId, initialExpandedItems, children, indicator = true, openIcon, closeIcon, dir, ...props }, ref) => {
    const [selectedId, setSelectedId] = reactExports.useState(initialSelectedId);
    const [expandedItems, setExpandedItems] = reactExports.useState(initialExpandedItems);
    const selectItem = reactExports.useCallback((id) => {
      setSelectedId(id);
    }, []);
    const handleExpand = reactExports.useCallback((id) => {
      setExpandedItems((prev) => {
        if (prev == null ? void 0 : prev.includes(id)) {
          return prev.filter((item) => item !== id);
        }
        return [
          ...prev ?? [],
          id
        ];
      });
    }, []);
    const expandSpecificTargetedElements = reactExports.useCallback((elements2, selectId) => {
      if (!elements2 || !selectId) return;
      const findParent = (currentElement, currentPath = []) => {
        const isSelectable = currentElement.isSelectable ?? true;
        const newPath = [
          ...currentPath,
          currentElement.id
        ];
        if (currentElement.id === selectId) {
          if (isSelectable) {
            setExpandedItems((prev) => [
              ...prev ?? [],
              ...newPath
            ]);
          } else {
            if (newPath.includes(currentElement.id)) {
              newPath.pop();
              setExpandedItems((prev) => [
                ...prev ?? [],
                ...newPath
              ]);
            }
          }
          return;
        }
        if (isSelectable && currentElement.children && currentElement.children.length > 0) {
          currentElement.children.forEach((child) => {
            findParent(child, newPath);
          });
        }
      };
      elements2.forEach((element) => {
        findParent(element);
      });
    }, []);
    reactExports.useEffect(() => {
      if (initialSelectedId) {
        expandSpecificTargetedElements(elements, initialSelectedId);
      }
    }, [
      initialSelectedId,
      elements
    ]);
    const direction = dir === "rtl" ? "rtl" : "ltr";
    return jsxRuntimeExports.jsx(TreeContext.Provider, {
      value: {
        selectedId,
        expandedItems,
        handleExpand,
        selectItem,
        setExpandedItems,
        indicator,
        openIcon,
        closeIcon,
        direction
      },
      children: jsxRuntimeExports.jsx("div", {
        className: cn("size-full", className),
        children: jsxRuntimeExports.jsx(ScrollArea, {
          ref,
          className: "h-full relative px-2",
          dir,
          children: jsxRuntimeExports.jsx(Root2, {
            ...props,
            type: "multiple",
            defaultValue: expandedItems,
            value: expandedItems,
            className: "flex flex-col gap-1",
            onValueChange: (value) => setExpandedItems((prev) => [
              ...prev ?? [],
              value[0]
            ]),
            dir,
            children
          })
        })
      })
    });
  });
  Tree.displayName = "Tree";
  const TreeIndicator = reactExports.forwardRef(({ className, ...props }, ref) => {
    const { direction } = useTree();
    return jsxRuntimeExports.jsx("div", {
      dir: direction,
      ref,
      className: cn("h-full w-px bg-muted absolute left-1.5 rtl:right-1.5 py-3 rounded-md hover:bg-slate-300 duration-300 ease-in-out", className),
      ...props
    });
  });
  TreeIndicator.displayName = "TreeIndicator";
  const Folder = reactExports.forwardRef(({ className, element, value, isSelectable = true, isSelect, children, ...props }) => {
    const { direction, handleExpand, expandedItems, indicator, setExpandedItems, openIcon, closeIcon } = useTree();
    return jsxRuntimeExports.jsxs(Item, {
      ...props,
      value,
      className: "relative overflow-hidden h-full ",
      children: [
        jsxRuntimeExports.jsxs(Trigger2, {
          className: cn(`flex items-center gap-1 text-sm rounded-md`, className, {
            "bg-muted rounded-md": isSelect && isSelectable,
            "cursor-pointer": isSelectable,
            "cursor-not-allowed opacity-50": !isSelectable
          }),
          disabled: !isSelectable,
          onClick: () => handleExpand(value),
          children: [
            (expandedItems == null ? void 0 : expandedItems.includes(value)) ? openIcon ?? jsxRuntimeExports.jsx(FolderOpen, {
              className: "size-4"
            }) : closeIcon ?? jsxRuntimeExports.jsx(Folder$1, {
              className: "size-4"
            }),
            jsxRuntimeExports.jsx("span", {
              children: element
            })
          ]
        }),
        jsxRuntimeExports.jsxs(Content2, {
          className: "text-sm data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down relative overflow-hidden h-full",
          children: [
            element && indicator && jsxRuntimeExports.jsx(TreeIndicator, {
              "aria-hidden": "true"
            }),
            jsxRuntimeExports.jsx(Root2, {
              dir: direction,
              type: "multiple",
              className: "flex flex-col gap-1 py-1 ml-5 rtl:mr-5 ",
              defaultValue: expandedItems,
              value: expandedItems,
              onValueChange: (value2) => {
                setExpandedItems == null ? void 0 : setExpandedItems((prev) => [
                  ...prev ?? [],
                  value2[0]
                ]);
              },
              children
            })
          ]
        })
      ]
    });
  });
  Folder.displayName = "Folder";
  const File = reactExports.forwardRef(({ value, className, isSelectable = true, isSelect, fileIcon, children, onClick, ...props }, ref) => {
    const { direction, selectedId, selectItem } = useTree();
    const isSelected = isSelect ?? selectedId === value;
    return jsxRuntimeExports.jsx(Item, {
      value,
      className: "relative",
      children: jsxRuntimeExports.jsxs(Trigger2, {
        ref,
        ...props,
        dir: direction,
        disabled: !isSelectable,
        "aria-label": "File",
        className: cn("flex items-center gap-1 cursor-pointer text-sm pr-1 rtl:pl-1 rtl:pr-0 rounded-md  duration-200 ease-in-out", {
          "bg-muted": isSelected && isSelectable
        }, isSelectable ? "cursor-pointer" : "opacity-50 cursor-not-allowed", className),
        onClick: (e) => {
          selectItem(value);
          onClick == null ? void 0 : onClick(e);
        },
        children: [
          fileIcon ?? jsxRuntimeExports.jsx(File$1, {
            className: "size-4"
          }),
          children
        ]
      })
    });
  });
  File.displayName = "File";
  const CollapseButton = reactExports.forwardRef(({ elements, expandAll = false, children, ...props }, ref) => {
    const { expandedItems, setExpandedItems } = useTree();
    const expendAllTree = reactExports.useCallback((elements2) => {
      const expandTree = (element) => {
        const isSelectable = element.isSelectable ?? true;
        if (isSelectable && element.children && element.children.length > 0) {
          setExpandedItems == null ? void 0 : setExpandedItems((prev) => [
            ...prev ?? [],
            element.id
          ]);
          element.children.forEach(expandTree);
        }
      };
      elements2.forEach(expandTree);
    }, []);
    const closeAll = reactExports.useCallback(() => {
      setExpandedItems == null ? void 0 : setExpandedItems([]);
    }, []);
    reactExports.useEffect(() => {
      if (expandAll) {
        expendAllTree(elements);
      }
    }, [
      expandAll
    ]);
    return jsxRuntimeExports.jsxs(Button, {
      variant: "ghost",
      className: "h-8 w-fit p-1 absolute bottom-1 right-2",
      onClick: expandedItems && expandedItems.length > 0 ? closeAll : () => expendAllTree(elements),
      ref,
      ...props,
      children: [
        children,
        jsxRuntimeExports.jsx("span", {
          className: "sr-only",
          children: "Toggle"
        })
      ]
    });
  });
  CollapseButton.displayName = "CollapseButton";
  const getLanguageExtension = async (extension) => {
    switch (extension) {
      case "js":
      case "jsx":
        return (await __vitePreload(async () => {
          const { javascript } = await import("./index-CH7L2sk2.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            javascript
          };
        }, true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13]) : void 0)).javascript({
          jsx: true
        });
      case "ts":
      case "tsx":
        return (await __vitePreload(async () => {
          const { javascript } = await import("./index-CH7L2sk2.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            javascript
          };
        }, true ? __vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13]) : void 0)).javascript({
          typescript: true,
          jsx: true
        });
      case "html":
        return (await __vitePreload(async () => {
          const { html } = await import("./index-DFEePeEy.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            html
          };
        }, true ? __vite__mapDeps([14,1,2,3,15,4,5,6,7,8,9,10,11,12,13,0]) : void 0)).html();
      case "css":
        return (await __vitePreload(async () => {
          const { css } = await import("./index-C_vD25Dk.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            css
          };
        }, true ? __vite__mapDeps([15,1,2,3,4,5,6,7,8,9,10,11,12,13]) : void 0)).css();
      case "json":
        return (await __vitePreload(async () => {
          const { json } = await import("./index-ZlDJDwwO.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            json
          };
        }, true ? __vite__mapDeps([16,1,2,3,4,5,6,7,8,9,10,11,12,13]) : void 0)).json();
      case "less":
        return (await __vitePreload(async () => {
          const { css } = await import("./index-C_vD25Dk.js").then(async (m) => {
            await m.__tla;
            return m;
          });
          return {
            css
          };
        }, true ? __vite__mapDeps([15,1,2,3,4,5,6,7,8,9,10,11,12,13]) : void 0)).css();
      default:
        return null;
    }
  };
  const FileSystem = ({ onSelectFile, elements }) => {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: elements.map((element) => jsxRuntimeExports.jsx(ElementRenderer, {
        element,
        onSelectFile
      }, element.id))
    });
  };
  const ElementRenderer = ({ element, onSelectFile }) => {
    if (element.children && element.children.length > 0) {
      return jsxRuntimeExports.jsx(Folder, {
        element: element.name,
        value: element.id,
        children: element.children.map((child) => jsxRuntimeExports.jsx(ElementRenderer, {
          element: child,
          onSelectFile
        }, child.id))
      });
    } else {
      return jsxRuntimeExports.jsx(File, {
        value: element.id,
        onClick: () => {
          onSelectFile(element);
        },
        children: jsxRuntimeExports.jsx("p", {
          children: element.name
        })
      });
    }
  };
  const CodeEditor = reactExports.memo(({ fileSystemTree, updateCodeContainerFile }) => {
    const debouceRef = reactExports.useRef();
    const [elementTree, setElementTree] = reactExports.useState([]);
    const [code2, setCode] = reactExports.useState();
    const [languageExtension, setLanguageExtension] = reactExports.useState(null);
    const editorRef = reactExports.useRef(null);
    usePreventPitchZoom(editorRef);
    const onChangeCode = reactExports.useCallback((val) => {
      if (!(code2 == null ? void 0 : code2.file)) return;
      clearTimeout(debouceRef.current);
      setCode((pre) => pre ? {
        ...pre,
        code: val
      } : pre);
      debouceRef.current = setTimeout(() => {
        updateCodeContainerFile(code2.file, val || "");
      }, 500);
    }, [
      code2 == null ? void 0 : code2.file,
      updateCodeContainerFile
    ]);
    const handleSelectFile = reactExports.useCallback(async (element) => {
      const fileExtension = element.name.split(".").pop();
      const extension = await getLanguageExtension(fileExtension);
      setLanguageExtension(extension);
      setCode({
        file: element.file,
        id: element.id,
        code: element.content || "",
        name: element.name
      });
    }, []);
    reactExports.useEffect(() => {
      if (!fileSystemTree) return;
      setElementTree(convertToElementsTree(fileSystemTree));
    }, [
      !!fileSystemTree
    ]);
    return jsxRuntimeExports.jsxs("div", {
      ref: editorRef,
      className: "flex-1 flex h-full overflow-auto",
      children: [
        jsxRuntimeExports.jsx(Tree, {
          className: "p-2 bg-background w-56",
          initialExpandedItems: elementTree.map((item) => item.id),
          elements: elementTree,
          children: jsxRuntimeExports.jsx(FileSystem, {
            elements: elementTree,
            onSelectFile: handleSelectFile
          })
        }),
        jsxRuntimeExports.jsx(ReactCodeMirror, {
          value: (code2 == null ? void 0 : code2.code) || "",
          className: "flex-1 h-full overflow-auto nodrag nowheel",
          extensions: languageExtension ? [
            languageExtension
          ] : [],
          onChange: onChangeCode,
          height: "600px"
        })
      ]
    });
  });
  var xterm$1 = {
    exports: {}
  };
  (function(module, exports) {
    !function(e, t2) {
      module.exports = t2();
    }(globalThis, () => (() => {
      var e = {
        4567: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.AccessibilityManager = void 0;
          const n = i3(9042), o = i3(9924), a = i3(844), h = i3(4725), c = i3(2585), l = i3(3656);
          let d = t3.AccessibilityManager = class extends a.Disposable {
            constructor(e3, t4, i4, s3) {
              super(), this._terminal = e3, this._coreBrowserService = i4, this._renderService = s3, this._rowColumns = /* @__PURE__ */ new WeakMap(), this._liveRegionLineCount = 0, this._charsToConsume = [], this._charsToAnnounce = "", this._accessibilityContainer = this._coreBrowserService.mainDocument.createElement("div"), this._accessibilityContainer.classList.add("xterm-accessibility"), this._rowContainer = this._coreBrowserService.mainDocument.createElement("div"), this._rowContainer.setAttribute("role", "list"), this._rowContainer.classList.add("xterm-accessibility-tree"), this._rowElements = [];
              for (let e4 = 0; e4 < this._terminal.rows; e4++) this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
              if (this._topBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 0), this._bottomBoundaryFocusListener = (e4) => this._handleBoundaryFocus(e4, 1), this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions(), this._accessibilityContainer.appendChild(this._rowContainer), this._liveRegion = this._coreBrowserService.mainDocument.createElement("div"), this._liveRegion.classList.add("live-region"), this._liveRegion.setAttribute("aria-live", "assertive"), this._accessibilityContainer.appendChild(this._liveRegion), this._liveRegionDebouncer = this.register(new o.TimeBasedDebouncer(this._renderRows.bind(this))), !this._terminal.element) throw new Error("Cannot enable accessibility before Terminal.open");
              this._terminal.element.insertAdjacentElement("afterbegin", this._accessibilityContainer), this.register(this._terminal.onResize((e4) => this._handleResize(e4.rows))), this.register(this._terminal.onRender((e4) => this._refreshRows(e4.start, e4.end))), this.register(this._terminal.onScroll(() => this._refreshRows())), this.register(this._terminal.onA11yChar((e4) => this._handleChar(e4))), this.register(this._terminal.onLineFeed(() => this._handleChar("\n"))), this.register(this._terminal.onA11yTab((e4) => this._handleTab(e4))), this.register(this._terminal.onKey((e4) => this._handleKey(e4.key))), this.register(this._terminal.onBlur(() => this._clearLiveRegion())), this.register(this._renderService.onDimensionsChange(() => this._refreshRowsDimensions())), this.register((0, l.addDisposableDomListener)(document, "selectionchange", () => this._handleSelectionChange())), this.register(this._coreBrowserService.onDprChange(() => this._refreshRowsDimensions())), this._refreshRows(), this.register((0, a.toDisposable)(() => {
                this._accessibilityContainer.remove(), this._rowElements.length = 0;
              }));
            }
            _handleTab(e3) {
              for (let t4 = 0; t4 < e3; t4++) this._handleChar(" ");
            }
            _handleChar(e3) {
              this._liveRegionLineCount < 21 && (this._charsToConsume.length > 0 ? this._charsToConsume.shift() !== e3 && (this._charsToAnnounce += e3) : this._charsToAnnounce += e3, "\n" === e3 && (this._liveRegionLineCount++, 21 === this._liveRegionLineCount && (this._liveRegion.textContent += n.tooMuchOutput)));
            }
            _clearLiveRegion() {
              this._liveRegion.textContent = "", this._liveRegionLineCount = 0;
            }
            _handleKey(e3) {
              this._clearLiveRegion(), new RegExp("\\p{Control}", "u").test(e3) || this._charsToConsume.push(e3);
            }
            _refreshRows(e3, t4) {
              this._liveRegionDebouncer.refresh(e3, t4, this._terminal.rows);
            }
            _renderRows(e3, t4) {
              const i4 = this._terminal.buffer, s3 = i4.lines.length.toString();
              for (let r2 = e3; r2 <= t4; r2++) {
                const e4 = i4.lines.get(i4.ydisp + r2), t5 = [], n2 = (e4 == null ? void 0 : e4.translateToString(true, void 0, void 0, t5)) || "", o2 = (i4.ydisp + r2 + 1).toString(), a2 = this._rowElements[r2];
                a2 && (0 === n2.length ? (a2.innerText = "\xA0", this._rowColumns.set(a2, [
                  0,
                  1
                ])) : (a2.textContent = n2, this._rowColumns.set(a2, t5)), a2.setAttribute("aria-posinset", o2), a2.setAttribute("aria-setsize", s3));
              }
              this._announceCharacters();
            }
            _announceCharacters() {
              0 !== this._charsToAnnounce.length && (this._liveRegion.textContent += this._charsToAnnounce, this._charsToAnnounce = "");
            }
            _handleBoundaryFocus(e3, t4) {
              const i4 = e3.target, s3 = this._rowElements[0 === t4 ? 1 : this._rowElements.length - 2];
              if (i4.getAttribute("aria-posinset") === (0 === t4 ? "1" : `${this._terminal.buffer.lines.length}`)) return;
              if (e3.relatedTarget !== s3) return;
              let r2, n2;
              if (0 === t4 ? (r2 = i4, n2 = this._rowElements.pop(), this._rowContainer.removeChild(n2)) : (r2 = this._rowElements.shift(), n2 = i4, this._rowContainer.removeChild(r2)), r2.removeEventListener("focus", this._topBoundaryFocusListener), n2.removeEventListener("focus", this._bottomBoundaryFocusListener), 0 === t4) {
                const e4 = this._createAccessibilityTreeNode();
                this._rowElements.unshift(e4), this._rowContainer.insertAdjacentElement("afterbegin", e4);
              } else {
                const e4 = this._createAccessibilityTreeNode();
                this._rowElements.push(e4), this._rowContainer.appendChild(e4);
              }
              this._rowElements[0].addEventListener("focus", this._topBoundaryFocusListener), this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._terminal.scrollLines(0 === t4 ? -1 : 1), this._rowElements[0 === t4 ? 1 : this._rowElements.length - 2].focus(), e3.preventDefault(), e3.stopImmediatePropagation();
            }
            _handleSelectionChange() {
              var _a2;
              if (0 === this._rowElements.length) return;
              const e3 = document.getSelection();
              if (!e3) return;
              if (e3.isCollapsed) return void (this._rowContainer.contains(e3.anchorNode) && this._terminal.clearSelection());
              if (!e3.anchorNode || !e3.focusNode) return void console.error("anchorNode and/or focusNode are null");
              let t4 = {
                node: e3.anchorNode,
                offset: e3.anchorOffset
              }, i4 = {
                node: e3.focusNode,
                offset: e3.focusOffset
              };
              if ((t4.node.compareDocumentPosition(i4.node) & Node.DOCUMENT_POSITION_PRECEDING || t4.node === i4.node && t4.offset > i4.offset) && ([t4, i4] = [
                i4,
                t4
              ]), t4.node.compareDocumentPosition(this._rowElements[0]) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING) && (t4 = {
                node: this._rowElements[0].childNodes[0],
                offset: 0
              }), !this._rowContainer.contains(t4.node)) return;
              const s3 = this._rowElements.slice(-1)[0];
              if (i4.node.compareDocumentPosition(s3) & (Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_PRECEDING) && (i4 = {
                node: s3,
                offset: ((_a2 = s3.textContent) == null ? void 0 : _a2.length) ?? 0
              }), !this._rowContainer.contains(i4.node)) return;
              const r2 = ({ node: e4, offset: t5 }) => {
                const i5 = e4 instanceof Text ? e4.parentNode : e4;
                let s4 = parseInt(i5 == null ? void 0 : i5.getAttribute("aria-posinset"), 10) - 1;
                if (isNaN(s4)) return console.warn("row is invalid. Race condition?"), null;
                const r3 = this._rowColumns.get(i5);
                if (!r3) return console.warn("columns is null. Race condition?"), null;
                let n3 = t5 < r3.length ? r3[t5] : r3.slice(-1)[0] + 1;
                return n3 >= this._terminal.cols && (++s4, n3 = 0), {
                  row: s4,
                  column: n3
                };
              }, n2 = r2(t4), o2 = r2(i4);
              if (n2 && o2) {
                if (n2.row > o2.row || n2.row === o2.row && n2.column >= o2.column) throw new Error("invalid range");
                this._terminal.select(n2.column, n2.row, (o2.row - n2.row) * this._terminal.cols - n2.column + o2.column);
              }
            }
            _handleResize(e3) {
              this._rowElements[this._rowElements.length - 1].removeEventListener("focus", this._bottomBoundaryFocusListener);
              for (let e4 = this._rowContainer.children.length; e4 < this._terminal.rows; e4++) this._rowElements[e4] = this._createAccessibilityTreeNode(), this._rowContainer.appendChild(this._rowElements[e4]);
              for (; this._rowElements.length > e3; ) this._rowContainer.removeChild(this._rowElements.pop());
              this._rowElements[this._rowElements.length - 1].addEventListener("focus", this._bottomBoundaryFocusListener), this._refreshRowsDimensions();
            }
            _createAccessibilityTreeNode() {
              const e3 = this._coreBrowserService.mainDocument.createElement("div");
              return e3.setAttribute("role", "listitem"), e3.tabIndex = -1, this._refreshRowDimensions(e3), e3;
            }
            _refreshRowsDimensions() {
              if (this._renderService.dimensions.css.cell.height) {
                this._accessibilityContainer.style.width = `${this._renderService.dimensions.css.canvas.width}px`, this._rowElements.length !== this._terminal.rows && this._handleResize(this._terminal.rows);
                for (let e3 = 0; e3 < this._terminal.rows; e3++) this._refreshRowDimensions(this._rowElements[e3]);
              }
            }
            _refreshRowDimensions(e3) {
              e3.style.height = `${this._renderService.dimensions.css.cell.height}px`;
            }
          };
          t3.AccessibilityManager = d = s2([
            r(1, c.IInstantiationService),
            r(2, h.ICoreBrowserService),
            r(3, h.IRenderService)
          ], d);
        },
        3614: (e2, t3) => {
          function i3(e3) {
            return e3.replace(/\r?\n/g, "\r");
          }
          function s2(e3, t4) {
            return t4 ? "\x1B[200~" + e3 + "\x1B[201~" : e3;
          }
          function r(e3, t4, r2, n2) {
            e3 = s2(e3 = i3(e3), r2.decPrivateModes.bracketedPasteMode && true !== n2.rawOptions.ignoreBracketedPasteMode), r2.triggerDataEvent(e3, true), t4.value = "";
          }
          function n(e3, t4, i4) {
            const s3 = i4.getBoundingClientRect(), r2 = e3.clientX - s3.left - 10, n2 = e3.clientY - s3.top - 10;
            t4.style.width = "20px", t4.style.height = "20px", t4.style.left = `${r2}px`, t4.style.top = `${n2}px`, t4.style.zIndex = "1000", t4.focus();
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.rightClickHandler = t3.moveTextAreaUnderMouseCursor = t3.paste = t3.handlePasteEvent = t3.copyHandler = t3.bracketTextForPaste = t3.prepareTextForTerminal = void 0, t3.prepareTextForTerminal = i3, t3.bracketTextForPaste = s2, t3.copyHandler = function(e3, t4) {
            e3.clipboardData && e3.clipboardData.setData("text/plain", t4.selectionText), e3.preventDefault();
          }, t3.handlePasteEvent = function(e3, t4, i4, s3) {
            e3.stopPropagation(), e3.clipboardData && r(e3.clipboardData.getData("text/plain"), t4, i4, s3);
          }, t3.paste = r, t3.moveTextAreaUnderMouseCursor = n, t3.rightClickHandler = function(e3, t4, i4, s3, r2) {
            n(e3, t4, i4), r2 && s3.rightClickSelect(e3), t4.value = s3.selectionText, t4.select();
          };
        },
        7239: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.ColorContrastCache = void 0;
          const s2 = i3(1505);
          t3.ColorContrastCache = class {
            constructor() {
              this._color = new s2.TwoKeyMap(), this._css = new s2.TwoKeyMap();
            }
            setCss(e3, t4, i4) {
              this._css.set(e3, t4, i4);
            }
            getCss(e3, t4) {
              return this._css.get(e3, t4);
            }
            setColor(e3, t4, i4) {
              this._color.set(e3, t4, i4);
            }
            getColor(e3, t4) {
              return this._color.get(e3, t4);
            }
            clear() {
              this._color.clear(), this._css.clear();
            }
          };
        },
        3656: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.addDisposableDomListener = void 0, t3.addDisposableDomListener = function(e3, t4, i3, s2) {
            e3.addEventListener(t4, i3, s2);
            let r = false;
            return {
              dispose: () => {
                r || (r = true, e3.removeEventListener(t4, i3, s2));
              }
            };
          };
        },
        3551: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Linkifier = void 0;
          const n = i3(3656), o = i3(8460), a = i3(844), h = i3(2585), c = i3(4725);
          let l = t3.Linkifier = class extends a.Disposable {
            get currentLink() {
              return this._currentLink;
            }
            constructor(e3, t4, i4, s3, r2) {
              super(), this._element = e3, this._mouseService = t4, this._renderService = i4, this._bufferService = s3, this._linkProviderService = r2, this._linkCacheDisposables = [], this._isMouseOut = true, this._wasResized = false, this._activeLine = -1, this._onShowLinkUnderline = this.register(new o.EventEmitter()), this.onShowLinkUnderline = this._onShowLinkUnderline.event, this._onHideLinkUnderline = this.register(new o.EventEmitter()), this.onHideLinkUnderline = this._onHideLinkUnderline.event, this.register((0, a.getDisposeArrayDisposable)(this._linkCacheDisposables)), this.register((0, a.toDisposable)(() => {
                var _a2;
                this._lastMouseEvent = void 0, (_a2 = this._activeProviderReplies) == null ? void 0 : _a2.clear();
              })), this.register(this._bufferService.onResize(() => {
                this._clearCurrentLink(), this._wasResized = true;
              })), this.register((0, n.addDisposableDomListener)(this._element, "mouseleave", () => {
                this._isMouseOut = true, this._clearCurrentLink();
              })), this.register((0, n.addDisposableDomListener)(this._element, "mousemove", this._handleMouseMove.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mousedown", this._handleMouseDown.bind(this))), this.register((0, n.addDisposableDomListener)(this._element, "mouseup", this._handleMouseUp.bind(this)));
            }
            _handleMouseMove(e3) {
              this._lastMouseEvent = e3;
              const t4 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
              if (!t4) return;
              this._isMouseOut = false;
              const i4 = e3.composedPath();
              for (let e4 = 0; e4 < i4.length; e4++) {
                const t5 = i4[e4];
                if (t5.classList.contains("xterm")) break;
                if (t5.classList.contains("xterm-hover")) return;
              }
              this._lastBufferCell && t4.x === this._lastBufferCell.x && t4.y === this._lastBufferCell.y || (this._handleHover(t4), this._lastBufferCell = t4);
            }
            _handleHover(e3) {
              if (this._activeLine !== e3.y || this._wasResized) return this._clearCurrentLink(), this._askForLink(e3, false), void (this._wasResized = false);
              this._currentLink && this._linkAtPosition(this._currentLink.link, e3) || (this._clearCurrentLink(), this._askForLink(e3, true));
            }
            _askForLink(e3, t4) {
              var _a2, _b;
              this._activeProviderReplies && t4 || ((_a2 = this._activeProviderReplies) == null ? void 0 : _a2.forEach((e4) => {
                e4 == null ? void 0 : e4.forEach((e5) => {
                  e5.link.dispose && e5.link.dispose();
                });
              }), this._activeProviderReplies = /* @__PURE__ */ new Map(), this._activeLine = e3.y);
              let i4 = false;
              for (const [s3, r2] of this._linkProviderService.linkProviders.entries()) if (t4) {
                const t5 = (_b = this._activeProviderReplies) == null ? void 0 : _b.get(s3);
                t5 && (i4 = this._checkLinkProviderResult(s3, e3, i4));
              } else r2.provideLinks(e3.y, (t5) => {
                var _a3, _b2;
                if (this._isMouseOut) return;
                const r3 = t5 == null ? void 0 : t5.map((e4) => ({
                  link: e4
                }));
                (_a3 = this._activeProviderReplies) == null ? void 0 : _a3.set(s3, r3), i4 = this._checkLinkProviderResult(s3, e3, i4), ((_b2 = this._activeProviderReplies) == null ? void 0 : _b2.size) === this._linkProviderService.linkProviders.length && this._removeIntersectingLinks(e3.y, this._activeProviderReplies);
              });
            }
            _removeIntersectingLinks(e3, t4) {
              const i4 = /* @__PURE__ */ new Set();
              for (let s3 = 0; s3 < t4.size; s3++) {
                const r2 = t4.get(s3);
                if (r2) for (let t5 = 0; t5 < r2.length; t5++) {
                  const s4 = r2[t5], n2 = s4.link.range.start.y < e3 ? 0 : s4.link.range.start.x, o2 = s4.link.range.end.y > e3 ? this._bufferService.cols : s4.link.range.end.x;
                  for (let e4 = n2; e4 <= o2; e4++) {
                    if (i4.has(e4)) {
                      r2.splice(t5--, 1);
                      break;
                    }
                    i4.add(e4);
                  }
                }
              }
            }
            _checkLinkProviderResult(e3, t4, i4) {
              var _a2;
              if (!this._activeProviderReplies) return i4;
              const s3 = this._activeProviderReplies.get(e3);
              let r2 = false;
              for (let t5 = 0; t5 < e3; t5++) this._activeProviderReplies.has(t5) && !this._activeProviderReplies.get(t5) || (r2 = true);
              if (!r2 && s3) {
                const e4 = s3.find((e5) => this._linkAtPosition(e5.link, t4));
                e4 && (i4 = true, this._handleNewLink(e4));
              }
              if (this._activeProviderReplies.size === this._linkProviderService.linkProviders.length && !i4) for (let e4 = 0; e4 < this._activeProviderReplies.size; e4++) {
                const s4 = (_a2 = this._activeProviderReplies.get(e4)) == null ? void 0 : _a2.find((e5) => this._linkAtPosition(e5.link, t4));
                if (s4) {
                  i4 = true, this._handleNewLink(s4);
                  break;
                }
              }
              return i4;
            }
            _handleMouseDown() {
              this._mouseDownLink = this._currentLink;
            }
            _handleMouseUp(e3) {
              if (!this._currentLink) return;
              const t4 = this._positionFromMouseEvent(e3, this._element, this._mouseService);
              t4 && this._mouseDownLink === this._currentLink && this._linkAtPosition(this._currentLink.link, t4) && this._currentLink.link.activate(e3, this._currentLink.link.text);
            }
            _clearCurrentLink(e3, t4) {
              this._currentLink && this._lastMouseEvent && (!e3 || !t4 || this._currentLink.link.range.start.y >= e3 && this._currentLink.link.range.end.y <= t4) && (this._linkLeave(this._element, this._currentLink.link, this._lastMouseEvent), this._currentLink = void 0, (0, a.disposeArray)(this._linkCacheDisposables));
            }
            _handleNewLink(e3) {
              if (!this._lastMouseEvent) return;
              const t4 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
              t4 && this._linkAtPosition(e3.link, t4) && (this._currentLink = e3, this._currentLink.state = {
                decorations: {
                  underline: void 0 === e3.link.decorations || e3.link.decorations.underline,
                  pointerCursor: void 0 === e3.link.decorations || e3.link.decorations.pointerCursor
                },
                isHovered: true
              }, this._linkHover(this._element, e3.link, this._lastMouseEvent), e3.link.decorations = {}, Object.defineProperties(e3.link.decorations, {
                pointerCursor: {
                  get: () => {
                    var _a2, _b;
                    return (_b = (_a2 = this._currentLink) == null ? void 0 : _a2.state) == null ? void 0 : _b.decorations.pointerCursor;
                  },
                  set: (e4) => {
                    var _a2;
                    ((_a2 = this._currentLink) == null ? void 0 : _a2.state) && this._currentLink.state.decorations.pointerCursor !== e4 && (this._currentLink.state.decorations.pointerCursor = e4, this._currentLink.state.isHovered && this._element.classList.toggle("xterm-cursor-pointer", e4));
                  }
                },
                underline: {
                  get: () => {
                    var _a2, _b;
                    return (_b = (_a2 = this._currentLink) == null ? void 0 : _a2.state) == null ? void 0 : _b.decorations.underline;
                  },
                  set: (t5) => {
                    var _a2, _b, _c;
                    ((_a2 = this._currentLink) == null ? void 0 : _a2.state) && ((_c = (_b = this._currentLink) == null ? void 0 : _b.state) == null ? void 0 : _c.decorations.underline) !== t5 && (this._currentLink.state.decorations.underline = t5, this._currentLink.state.isHovered && this._fireUnderlineEvent(e3.link, t5));
                  }
                }
              }), this._linkCacheDisposables.push(this._renderService.onRenderedViewportChange((e4) => {
                if (!this._currentLink) return;
                const t5 = 0 === e4.start ? 0 : e4.start + 1 + this._bufferService.buffer.ydisp, i4 = this._bufferService.buffer.ydisp + 1 + e4.end;
                if (this._currentLink.link.range.start.y >= t5 && this._currentLink.link.range.end.y <= i4 && (this._clearCurrentLink(t5, i4), this._lastMouseEvent)) {
                  const e5 = this._positionFromMouseEvent(this._lastMouseEvent, this._element, this._mouseService);
                  e5 && this._askForLink(e5, false);
                }
              })));
            }
            _linkHover(e3, t4, i4) {
              var _a2;
              ((_a2 = this._currentLink) == null ? void 0 : _a2.state) && (this._currentLink.state.isHovered = true, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t4, true), this._currentLink.state.decorations.pointerCursor && e3.classList.add("xterm-cursor-pointer")), t4.hover && t4.hover(i4, t4.text);
            }
            _fireUnderlineEvent(e3, t4) {
              const i4 = e3.range, s3 = this._bufferService.buffer.ydisp, r2 = this._createLinkUnderlineEvent(i4.start.x - 1, i4.start.y - s3 - 1, i4.end.x, i4.end.y - s3 - 1, void 0);
              (t4 ? this._onShowLinkUnderline : this._onHideLinkUnderline).fire(r2);
            }
            _linkLeave(e3, t4, i4) {
              var _a2;
              ((_a2 = this._currentLink) == null ? void 0 : _a2.state) && (this._currentLink.state.isHovered = false, this._currentLink.state.decorations.underline && this._fireUnderlineEvent(t4, false), this._currentLink.state.decorations.pointerCursor && e3.classList.remove("xterm-cursor-pointer")), t4.leave && t4.leave(i4, t4.text);
            }
            _linkAtPosition(e3, t4) {
              const i4 = e3.range.start.y * this._bufferService.cols + e3.range.start.x, s3 = e3.range.end.y * this._bufferService.cols + e3.range.end.x, r2 = t4.y * this._bufferService.cols + t4.x;
              return i4 <= r2 && r2 <= s3;
            }
            _positionFromMouseEvent(e3, t4, i4) {
              const s3 = i4.getCoords(e3, t4, this._bufferService.cols, this._bufferService.rows);
              if (s3) return {
                x: s3[0],
                y: s3[1] + this._bufferService.buffer.ydisp
              };
            }
            _createLinkUnderlineEvent(e3, t4, i4, s3, r2) {
              return {
                x1: e3,
                y1: t4,
                x2: i4,
                y2: s3,
                cols: this._bufferService.cols,
                fg: r2
              };
            }
          };
          t3.Linkifier = l = s2([
            r(1, c.IMouseService),
            r(2, c.IRenderService),
            r(3, h.IBufferService),
            r(4, c.ILinkProviderService)
          ], l);
        },
        9042: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.tooMuchOutput = t3.promptLabel = void 0, t3.promptLabel = "Terminal input", t3.tooMuchOutput = "Too much output to announce, navigate to rows manually to read";
        },
        3730: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.OscLinkProvider = void 0;
          const n = i3(511), o = i3(2585);
          let a = t3.OscLinkProvider = class {
            constructor(e3, t4, i4) {
              this._bufferService = e3, this._optionsService = t4, this._oscLinkService = i4;
            }
            provideLinks(e3, t4) {
              var _a2;
              const i4 = this._bufferService.buffer.lines.get(e3 - 1);
              if (!i4) return void t4(void 0);
              const s3 = [], r2 = this._optionsService.rawOptions.linkHandler, o2 = new n.CellData(), a2 = i4.getTrimmedLength();
              let c = -1, l = -1, d = false;
              for (let t5 = 0; t5 < a2; t5++) if (-1 !== l || i4.hasContent(t5)) {
                if (i4.loadCell(t5, o2), o2.hasExtendedAttrs() && o2.extended.urlId) {
                  if (-1 === l) {
                    l = t5, c = o2.extended.urlId;
                    continue;
                  }
                  d = o2.extended.urlId !== c;
                } else -1 !== l && (d = true);
                if (d || -1 !== l && t5 === a2 - 1) {
                  const i5 = (_a2 = this._oscLinkService.getLinkData(c)) == null ? void 0 : _a2.uri;
                  if (i5) {
                    const n2 = {
                      start: {
                        x: l + 1,
                        y: e3
                      },
                      end: {
                        x: t5 + (d || t5 !== a2 - 1 ? 0 : 1),
                        y: e3
                      }
                    };
                    let o3 = false;
                    if (!(r2 == null ? void 0 : r2.allowNonHttpProtocols)) try {
                      const e4 = new URL(i5);
                      [
                        "http:",
                        "https:"
                      ].includes(e4.protocol) || (o3 = true);
                    } catch (e4) {
                      o3 = true;
                    }
                    o3 || s3.push({
                      text: i5,
                      range: n2,
                      activate: (e4, t6) => r2 ? r2.activate(e4, t6, n2) : h(0, t6),
                      hover: (e4, t6) => {
                        var _a3;
                        return (_a3 = r2 == null ? void 0 : r2.hover) == null ? void 0 : _a3.call(r2, e4, t6, n2);
                      },
                      leave: (e4, t6) => {
                        var _a3;
                        return (_a3 = r2 == null ? void 0 : r2.leave) == null ? void 0 : _a3.call(r2, e4, t6, n2);
                      }
                    });
                  }
                  d = false, o2.hasExtendedAttrs() && o2.extended.urlId ? (l = t5, c = o2.extended.urlId) : (l = -1, c = -1);
                }
              }
              t4(s3);
            }
          };
          function h(e3, t4) {
            if (confirm(`Do you want to navigate to ${t4}?

WARNING: This link could potentially be dangerous`)) {
              const e4 = window.open();
              if (e4) {
                try {
                  e4.opener = null;
                } catch {
                }
                e4.location.href = t4;
              } else console.warn("Opening link blocked as opener could not be cleared");
            }
          }
          t3.OscLinkProvider = a = s2([
            r(0, o.IBufferService),
            r(1, o.IOptionsService),
            r(2, o.IOscLinkService)
          ], a);
        },
        6193: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.RenderDebouncer = void 0, t3.RenderDebouncer = class {
            constructor(e3, t4) {
              this._renderCallback = e3, this._coreBrowserService = t4, this._refreshCallbacks = [];
            }
            dispose() {
              this._animationFrame && (this._coreBrowserService.window.cancelAnimationFrame(this._animationFrame), this._animationFrame = void 0);
            }
            addRefreshCallback(e3) {
              return this._refreshCallbacks.push(e3), this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh())), this._animationFrame;
            }
            refresh(e3, t4, i3) {
              this._rowCount = i3, e3 = void 0 !== e3 ? e3 : 0, t4 = void 0 !== t4 ? t4 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t4) : t4, this._animationFrame || (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
            }
            _innerRefresh() {
              if (this._animationFrame = void 0, void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return void this._runRefreshCallbacks();
              const e3 = Math.max(this._rowStart, 0), t4 = Math.min(this._rowEnd, this._rowCount - 1);
              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t4), this._runRefreshCallbacks();
            }
            _runRefreshCallbacks() {
              for (const e3 of this._refreshCallbacks) e3(0);
              this._refreshCallbacks = [];
            }
          };
        },
        3236: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Terminal = void 0;
          const s2 = i3(3614), r = i3(3656), n = i3(3551), o = i3(9042), a = i3(3730), h = i3(1680), c = i3(3107), l = i3(5744), d = i3(2950), _ = i3(1296), u = i3(428), f = i3(4269), v = i3(5114), p = i3(8934), g = i3(3230), m = i3(9312), S = i3(4725), C2 = i3(6731), b = i3(8055), w = i3(8969), y = i3(8460), E = i3(844), k = i3(6114), L = i3(8437), D = i3(2584), R = i3(7399), x = i3(5941), A = i3(9074), B = i3(2585), T = i3(5435), M = i3(4567), O = i3(779);
          class P extends w.CoreTerminal {
            get onFocus() {
              return this._onFocus.event;
            }
            get onBlur() {
              return this._onBlur.event;
            }
            get onA11yChar() {
              return this._onA11yCharEmitter.event;
            }
            get onA11yTab() {
              return this._onA11yTabEmitter.event;
            }
            get onWillOpen() {
              return this._onWillOpen.event;
            }
            constructor(e3 = {}) {
              super(e3), this.browser = k, this._keyDownHandled = false, this._keyDownSeen = false, this._keyPressHandled = false, this._unprocessedDeadKey = false, this._accessibilityManager = this.register(new E.MutableDisposable()), this._onCursorMove = this.register(new y.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onKey = this.register(new y.EventEmitter()), this.onKey = this._onKey.event, this._onRender = this.register(new y.EventEmitter()), this.onRender = this._onRender.event, this._onSelectionChange = this.register(new y.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onTitleChange = this.register(new y.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onBell = this.register(new y.EventEmitter()), this.onBell = this._onBell.event, this._onFocus = this.register(new y.EventEmitter()), this._onBlur = this.register(new y.EventEmitter()), this._onA11yCharEmitter = this.register(new y.EventEmitter()), this._onA11yTabEmitter = this.register(new y.EventEmitter()), this._onWillOpen = this.register(new y.EventEmitter()), this._setup(), this._decorationService = this._instantiationService.createInstance(A.DecorationService), this._instantiationService.setService(B.IDecorationService, this._decorationService), this._linkProviderService = this._instantiationService.createInstance(O.LinkProviderService), this._instantiationService.setService(S.ILinkProviderService, this._linkProviderService), this._linkProviderService.registerLinkProvider(this._instantiationService.createInstance(a.OscLinkProvider)), this.register(this._inputHandler.onRequestBell(() => this._onBell.fire())), this.register(this._inputHandler.onRequestRefreshRows((e4, t4) => this.refresh(e4, t4))), this.register(this._inputHandler.onRequestSendFocus(() => this._reportFocus())), this.register(this._inputHandler.onRequestReset(() => this.reset())), this.register(this._inputHandler.onRequestWindowsOptionsReport((e4) => this._reportWindowsOptions(e4))), this.register(this._inputHandler.onColor((e4) => this._handleColorEvent(e4))), this.register((0, y.forwardEvent)(this._inputHandler.onCursorMove, this._onCursorMove)), this.register((0, y.forwardEvent)(this._inputHandler.onTitleChange, this._onTitleChange)), this.register((0, y.forwardEvent)(this._inputHandler.onA11yChar, this._onA11yCharEmitter)), this.register((0, y.forwardEvent)(this._inputHandler.onA11yTab, this._onA11yTabEmitter)), this.register(this._bufferService.onResize((e4) => this._afterResize(e4.cols, e4.rows))), this.register((0, E.toDisposable)(() => {
                var _a2, _b;
                this._customKeyEventHandler = void 0, (_b = (_a2 = this.element) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(this.element);
              }));
            }
            _handleColorEvent(e3) {
              if (this._themeService) for (const t4 of e3) {
                let e4, i4 = "";
                switch (t4.index) {
                  case 256:
                    e4 = "foreground", i4 = "10";
                    break;
                  case 257:
                    e4 = "background", i4 = "11";
                    break;
                  case 258:
                    e4 = "cursor", i4 = "12";
                    break;
                  default:
                    e4 = "ansi", i4 = "4;" + t4.index;
                }
                switch (t4.type) {
                  case 0:
                    const s3 = b.color.toColorRGB("ansi" === e4 ? this._themeService.colors.ansi[t4.index] : this._themeService.colors[e4]);
                    this.coreService.triggerDataEvent(`${D.C0.ESC}]${i4};${(0, x.toRgbString)(s3)}${D.C1_ESCAPED.ST}`);
                    break;
                  case 1:
                    if ("ansi" === e4) this._themeService.modifyColors((e5) => e5.ansi[t4.index] = b.channels.toColor(...t4.color));
                    else {
                      const i5 = e4;
                      this._themeService.modifyColors((e5) => e5[i5] = b.channels.toColor(...t4.color));
                    }
                    break;
                  case 2:
                    this._themeService.restoreColor(t4.index);
                }
              }
            }
            _setup() {
              super._setup(), this._customKeyEventHandler = void 0;
            }
            get buffer() {
              return this.buffers.active;
            }
            focus() {
              this.textarea && this.textarea.focus({
                preventScroll: true
              });
            }
            _handleScreenReaderModeOptionChange(e3) {
              e3 ? !this._accessibilityManager.value && this._renderService && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)) : this._accessibilityManager.clear();
            }
            _handleTextAreaFocus(e3) {
              this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[I"), this.element.classList.add("focus"), this._showCursor(), this._onFocus.fire();
            }
            blur() {
              var _a2;
              return (_a2 = this.textarea) == null ? void 0 : _a2.blur();
            }
            _handleTextAreaBlur() {
              this.textarea.value = "", this.refresh(this.buffer.y, this.buffer.y), this.coreService.decPrivateModes.sendFocus && this.coreService.triggerDataEvent(D.C0.ESC + "[O"), this.element.classList.remove("focus"), this._onBlur.fire();
            }
            _syncTextArea() {
              if (!this.textarea || !this.buffer.isCursorInViewport || this._compositionHelper.isComposing || !this._renderService) return;
              const e3 = this.buffer.ybase + this.buffer.y, t4 = this.buffer.lines.get(e3);
              if (!t4) return;
              const i4 = Math.min(this.buffer.x, this.cols - 1), s3 = this._renderService.dimensions.css.cell.height, r2 = t4.getWidth(i4), n2 = this._renderService.dimensions.css.cell.width * r2, o2 = this.buffer.y * this._renderService.dimensions.css.cell.height, a2 = i4 * this._renderService.dimensions.css.cell.width;
              this.textarea.style.left = a2 + "px", this.textarea.style.top = o2 + "px", this.textarea.style.width = n2 + "px", this.textarea.style.height = s3 + "px", this.textarea.style.lineHeight = s3 + "px", this.textarea.style.zIndex = "-5";
            }
            _initGlobal() {
              this._bindKeys(), this.register((0, r.addDisposableDomListener)(this.element, "copy", (e4) => {
                this.hasSelection() && (0, s2.copyHandler)(e4, this._selectionService);
              }));
              const e3 = (e4) => (0, s2.handlePasteEvent)(e4, this.textarea, this.coreService, this.optionsService);
              this.register((0, r.addDisposableDomListener)(this.textarea, "paste", e3)), this.register((0, r.addDisposableDomListener)(this.element, "paste", e3)), k.isFirefox ? this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => {
                2 === e4.button && (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
              })) : this.register((0, r.addDisposableDomListener)(this.element, "contextmenu", (e4) => {
                (0, s2.rightClickHandler)(e4, this.textarea, this.screenElement, this._selectionService, this.options.rightClickSelectsWord);
              })), k.isLinux && this.register((0, r.addDisposableDomListener)(this.element, "auxclick", (e4) => {
                1 === e4.button && (0, s2.moveTextAreaUnderMouseCursor)(e4, this.textarea, this.screenElement);
              }));
            }
            _bindKeys() {
              this.register((0, r.addDisposableDomListener)(this.textarea, "keyup", (e3) => this._keyUp(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keydown", (e3) => this._keyDown(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "keypress", (e3) => this._keyPress(e3), true)), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionstart", () => this._compositionHelper.compositionstart())), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionupdate", (e3) => this._compositionHelper.compositionupdate(e3))), this.register((0, r.addDisposableDomListener)(this.textarea, "compositionend", () => this._compositionHelper.compositionend())), this.register((0, r.addDisposableDomListener)(this.textarea, "input", (e3) => this._inputEvent(e3), true)), this.register(this.onRender(() => this._compositionHelper.updateCompositionElements()));
            }
            open(e3) {
              var _a2;
              if (!e3) throw new Error("Terminal requires a parent element.");
              if (e3.isConnected || this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"), ((_a2 = this.element) == null ? void 0 : _a2.ownerDocument.defaultView) && this._coreBrowserService) return void (this.element.ownerDocument.defaultView !== this._coreBrowserService.window && (this._coreBrowserService.window = this.element.ownerDocument.defaultView));
              this._document = e3.ownerDocument, this.options.documentOverride && this.options.documentOverride instanceof Document && (this._document = this.optionsService.rawOptions.documentOverride), this.element = this._document.createElement("div"), this.element.dir = "ltr", this.element.classList.add("terminal"), this.element.classList.add("xterm"), e3.appendChild(this.element);
              const t4 = this._document.createDocumentFragment();
              this._viewportElement = this._document.createElement("div"), this._viewportElement.classList.add("xterm-viewport"), t4.appendChild(this._viewportElement), this._viewportScrollArea = this._document.createElement("div"), this._viewportScrollArea.classList.add("xterm-scroll-area"), this._viewportElement.appendChild(this._viewportScrollArea), this.screenElement = this._document.createElement("div"), this.screenElement.classList.add("xterm-screen"), this.register((0, r.addDisposableDomListener)(this.screenElement, "mousemove", (e4) => this.updateCursorStyle(e4))), this._helperContainer = this._document.createElement("div"), this._helperContainer.classList.add("xterm-helpers"), this.screenElement.appendChild(this._helperContainer), t4.appendChild(this.screenElement), this.textarea = this._document.createElement("textarea"), this.textarea.classList.add("xterm-helper-textarea"), this.textarea.setAttribute("aria-label", o.promptLabel), k.isChromeOS || this.textarea.setAttribute("aria-multiline", "false"), this.textarea.setAttribute("autocorrect", "off"), this.textarea.setAttribute("autocapitalize", "off"), this.textarea.setAttribute("spellcheck", "false"), this.textarea.tabIndex = 0, this._coreBrowserService = this.register(this._instantiationService.createInstance(v.CoreBrowserService, this.textarea, e3.ownerDocument.defaultView ?? window, this._document ?? "undefined" != typeof window ? window.document : null)), this._instantiationService.setService(S.ICoreBrowserService, this._coreBrowserService), this.register((0, r.addDisposableDomListener)(this.textarea, "focus", (e4) => this._handleTextAreaFocus(e4))), this.register((0, r.addDisposableDomListener)(this.textarea, "blur", () => this._handleTextAreaBlur())), this._helperContainer.appendChild(this.textarea), this._charSizeService = this._instantiationService.createInstance(u.CharSizeService, this._document, this._helperContainer), this._instantiationService.setService(S.ICharSizeService, this._charSizeService), this._themeService = this._instantiationService.createInstance(C2.ThemeService), this._instantiationService.setService(S.IThemeService, this._themeService), this._characterJoinerService = this._instantiationService.createInstance(f.CharacterJoinerService), this._instantiationService.setService(S.ICharacterJoinerService, this._characterJoinerService), this._renderService = this.register(this._instantiationService.createInstance(g.RenderService, this.rows, this.screenElement)), this._instantiationService.setService(S.IRenderService, this._renderService), this.register(this._renderService.onRenderedViewportChange((e4) => this._onRender.fire(e4))), this.onResize((e4) => this._renderService.resize(e4.cols, e4.rows)), this._compositionView = this._document.createElement("div"), this._compositionView.classList.add("composition-view"), this._compositionHelper = this._instantiationService.createInstance(d.CompositionHelper, this.textarea, this._compositionView), this._helperContainer.appendChild(this._compositionView), this._mouseService = this._instantiationService.createInstance(p.MouseService), this._instantiationService.setService(S.IMouseService, this._mouseService), this.linkifier = this.register(this._instantiationService.createInstance(n.Linkifier, this.screenElement)), this.element.appendChild(t4);
              try {
                this._onWillOpen.fire(this.element);
              } catch {
              }
              this._renderService.hasRenderer() || this._renderService.setRenderer(this._createRenderer()), this.viewport = this._instantiationService.createInstance(h.Viewport, this._viewportElement, this._viewportScrollArea), this.viewport.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent, 1)), this.register(this._inputHandler.onRequestSyncScrollBar(() => this.viewport.syncScrollArea())), this.register(this.viewport), this.register(this.onCursorMove(() => {
                this._renderService.handleCursorMove(), this._syncTextArea();
              })), this.register(this.onResize(() => this._renderService.handleResize(this.cols, this.rows))), this.register(this.onBlur(() => this._renderService.handleBlur())), this.register(this.onFocus(() => this._renderService.handleFocus())), this.register(this._renderService.onDimensionsChange(() => this.viewport.syncScrollArea())), this._selectionService = this.register(this._instantiationService.createInstance(m.SelectionService, this.element, this.screenElement, this.linkifier)), this._instantiationService.setService(S.ISelectionService, this._selectionService), this.register(this._selectionService.onRequestScrollLines((e4) => this.scrollLines(e4.amount, e4.suppressScrollEvent))), this.register(this._selectionService.onSelectionChange(() => this._onSelectionChange.fire())), this.register(this._selectionService.onRequestRedraw((e4) => this._renderService.handleSelectionChanged(e4.start, e4.end, e4.columnSelectMode))), this.register(this._selectionService.onLinuxMouseSelection((e4) => {
                this.textarea.value = e4, this.textarea.focus(), this.textarea.select();
              })), this.register(this._onScroll.event((e4) => {
                this.viewport.syncScrollArea(), this._selectionService.refresh();
              })), this.register((0, r.addDisposableDomListener)(this._viewportElement, "scroll", () => this._selectionService.refresh())), this.register(this._instantiationService.createInstance(c.BufferDecorationRenderer, this.screenElement)), this.register((0, r.addDisposableDomListener)(this.element, "mousedown", (e4) => this._selectionService.handleMouseDown(e4))), this.coreMouseService.areMouseEventsActive ? (this._selectionService.disable(), this.element.classList.add("enable-mouse-events")) : this._selectionService.enable(), this.options.screenReaderMode && (this._accessibilityManager.value = this._instantiationService.createInstance(M.AccessibilityManager, this)), this.register(this.optionsService.onSpecificOptionChange("screenReaderMode", (e4) => this._handleScreenReaderModeOptionChange(e4))), this.options.overviewRulerWidth && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement))), this.optionsService.onSpecificOptionChange("overviewRulerWidth", (e4) => {
                !this._overviewRulerRenderer && e4 && this._viewportElement && this.screenElement && (this._overviewRulerRenderer = this.register(this._instantiationService.createInstance(l.OverviewRulerRenderer, this._viewportElement, this.screenElement)));
              }), this._charSizeService.measure(), this.refresh(0, this.rows - 1), this._initGlobal(), this.bindMouse();
            }
            _createRenderer() {
              return this._instantiationService.createInstance(_.DomRenderer, this, this._document, this.element, this.screenElement, this._viewportElement, this._helperContainer, this.linkifier);
            }
            bindMouse() {
              const e3 = this, t4 = this.element;
              function i4(t5) {
                const i5 = e3._mouseService.getMouseReportCoords(t5, e3.screenElement);
                if (!i5) return false;
                let s4, r2;
                switch (t5.overrideType || t5.type) {
                  case "mousemove":
                    r2 = 32, void 0 === t5.buttons ? (s4 = 3, void 0 !== t5.button && (s4 = t5.button < 3 ? t5.button : 3)) : s4 = 1 & t5.buttons ? 0 : 4 & t5.buttons ? 1 : 2 & t5.buttons ? 2 : 3;
                    break;
                  case "mouseup":
                    r2 = 0, s4 = t5.button < 3 ? t5.button : 3;
                    break;
                  case "mousedown":
                    r2 = 1, s4 = t5.button < 3 ? t5.button : 3;
                    break;
                  case "wheel":
                    if (e3._customWheelEventHandler && false === e3._customWheelEventHandler(t5)) return false;
                    if (0 === e3.viewport.getLinesScrolled(t5)) return false;
                    r2 = t5.deltaY < 0 ? 0 : 1, s4 = 4;
                    break;
                  default:
                    return false;
                }
                return !(void 0 === r2 || void 0 === s4 || s4 > 4) && e3.coreMouseService.triggerMouseEvent({
                  col: i5.col,
                  row: i5.row,
                  x: i5.x,
                  y: i5.y,
                  button: s4,
                  action: r2,
                  ctrl: t5.ctrlKey,
                  alt: t5.altKey,
                  shift: t5.shiftKey
                });
              }
              const s3 = {
                mouseup: null,
                wheel: null,
                mousedrag: null,
                mousemove: null
              }, n2 = {
                mouseup: (e4) => (i4(e4), e4.buttons || (this._document.removeEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.removeEventListener("mousemove", s3.mousedrag)), this.cancel(e4)),
                wheel: (e4) => (i4(e4), this.cancel(e4, true)),
                mousedrag: (e4) => {
                  e4.buttons && i4(e4);
                },
                mousemove: (e4) => {
                  e4.buttons || i4(e4);
                }
              };
              this.register(this.coreMouseService.onProtocolChange((e4) => {
                e4 ? ("debug" === this.optionsService.rawOptions.logLevel && this._logService.debug("Binding to mouse events:", this.coreMouseService.explainEvents(e4)), this.element.classList.add("enable-mouse-events"), this._selectionService.disable()) : (this._logService.debug("Unbinding from mouse events."), this.element.classList.remove("enable-mouse-events"), this._selectionService.enable()), 8 & e4 ? s3.mousemove || (t4.addEventListener("mousemove", n2.mousemove), s3.mousemove = n2.mousemove) : (t4.removeEventListener("mousemove", s3.mousemove), s3.mousemove = null), 16 & e4 ? s3.wheel || (t4.addEventListener("wheel", n2.wheel, {
                  passive: false
                }), s3.wheel = n2.wheel) : (t4.removeEventListener("wheel", s3.wheel), s3.wheel = null), 2 & e4 ? s3.mouseup || (s3.mouseup = n2.mouseup) : (this._document.removeEventListener("mouseup", s3.mouseup), s3.mouseup = null), 4 & e4 ? s3.mousedrag || (s3.mousedrag = n2.mousedrag) : (this._document.removeEventListener("mousemove", s3.mousedrag), s3.mousedrag = null);
              })), this.coreMouseService.activeProtocol = this.coreMouseService.activeProtocol, this.register((0, r.addDisposableDomListener)(t4, "mousedown", (e4) => {
                if (e4.preventDefault(), this.focus(), this.coreMouseService.areMouseEventsActive && !this._selectionService.shouldForceSelection(e4)) return i4(e4), s3.mouseup && this._document.addEventListener("mouseup", s3.mouseup), s3.mousedrag && this._document.addEventListener("mousemove", s3.mousedrag), this.cancel(e4);
              })), this.register((0, r.addDisposableDomListener)(t4, "wheel", (e4) => {
                if (!s3.wheel) {
                  if (this._customWheelEventHandler && false === this._customWheelEventHandler(e4)) return false;
                  if (!this.buffer.hasScrollback) {
                    const t5 = this.viewport.getLinesScrolled(e4);
                    if (0 === t5) return;
                    const i5 = D.C0.ESC + (this.coreService.decPrivateModes.applicationCursorKeys ? "O" : "[") + (e4.deltaY < 0 ? "A" : "B");
                    let s4 = "";
                    for (let e5 = 0; e5 < Math.abs(t5); e5++) s4 += i5;
                    return this.coreService.triggerDataEvent(s4, true), this.cancel(e4, true);
                  }
                  return this.viewport.handleWheel(e4) ? this.cancel(e4) : void 0;
                }
              }, {
                passive: false
              })), this.register((0, r.addDisposableDomListener)(t4, "touchstart", (e4) => {
                if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchStart(e4), this.cancel(e4);
              }, {
                passive: true
              })), this.register((0, r.addDisposableDomListener)(t4, "touchmove", (e4) => {
                if (!this.coreMouseService.areMouseEventsActive) return this.viewport.handleTouchMove(e4) ? void 0 : this.cancel(e4);
              }, {
                passive: false
              }));
            }
            refresh(e3, t4) {
              var _a2;
              (_a2 = this._renderService) == null ? void 0 : _a2.refreshRows(e3, t4);
            }
            updateCursorStyle(e3) {
              var _a2;
              ((_a2 = this._selectionService) == null ? void 0 : _a2.shouldColumnSelect(e3)) ? this.element.classList.add("column-select") : this.element.classList.remove("column-select");
            }
            _showCursor() {
              this.coreService.isCursorInitialized || (this.coreService.isCursorInitialized = true, this.refresh(this.buffer.y, this.buffer.y));
            }
            scrollLines(e3, t4, i4 = 0) {
              var _a2;
              1 === i4 ? (super.scrollLines(e3, t4, i4), this.refresh(0, this.rows - 1)) : (_a2 = this.viewport) == null ? void 0 : _a2.scrollLines(e3);
            }
            paste(e3) {
              (0, s2.paste)(e3, this.textarea, this.coreService, this.optionsService);
            }
            attachCustomKeyEventHandler(e3) {
              this._customKeyEventHandler = e3;
            }
            attachCustomWheelEventHandler(e3) {
              this._customWheelEventHandler = e3;
            }
            registerLinkProvider(e3) {
              return this._linkProviderService.registerLinkProvider(e3);
            }
            registerCharacterJoiner(e3) {
              if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
              const t4 = this._characterJoinerService.register(e3);
              return this.refresh(0, this.rows - 1), t4;
            }
            deregisterCharacterJoiner(e3) {
              if (!this._characterJoinerService) throw new Error("Terminal must be opened first");
              this._characterJoinerService.deregister(e3) && this.refresh(0, this.rows - 1);
            }
            get markers() {
              return this.buffer.markers;
            }
            registerMarker(e3) {
              return this.buffer.addMarker(this.buffer.ybase + this.buffer.y + e3);
            }
            registerDecoration(e3) {
              return this._decorationService.registerDecoration(e3);
            }
            hasSelection() {
              return !!this._selectionService && this._selectionService.hasSelection;
            }
            select(e3, t4, i4) {
              this._selectionService.setSelection(e3, t4, i4);
            }
            getSelection() {
              return this._selectionService ? this._selectionService.selectionText : "";
            }
            getSelectionPosition() {
              if (this._selectionService && this._selectionService.hasSelection) return {
                start: {
                  x: this._selectionService.selectionStart[0],
                  y: this._selectionService.selectionStart[1]
                },
                end: {
                  x: this._selectionService.selectionEnd[0],
                  y: this._selectionService.selectionEnd[1]
                }
              };
            }
            clearSelection() {
              var _a2;
              (_a2 = this._selectionService) == null ? void 0 : _a2.clearSelection();
            }
            selectAll() {
              var _a2;
              (_a2 = this._selectionService) == null ? void 0 : _a2.selectAll();
            }
            selectLines(e3, t4) {
              var _a2;
              (_a2 = this._selectionService) == null ? void 0 : _a2.selectLines(e3, t4);
            }
            _keyDown(e3) {
              if (this._keyDownHandled = false, this._keyDownSeen = true, this._customKeyEventHandler && false === this._customKeyEventHandler(e3)) return false;
              const t4 = this.browser.isMac && this.options.macOptionIsMeta && e3.altKey;
              if (!t4 && !this._compositionHelper.keydown(e3)) return this.options.scrollOnUserInput && this.buffer.ybase !== this.buffer.ydisp && this.scrollToBottom(), false;
              t4 || "Dead" !== e3.key && "AltGraph" !== e3.key || (this._unprocessedDeadKey = true);
              const i4 = (0, R.evaluateKeyboardEvent)(e3, this.coreService.decPrivateModes.applicationCursorKeys, this.browser.isMac, this.options.macOptionIsMeta);
              if (this.updateCursorStyle(e3), 3 === i4.type || 2 === i4.type) {
                const t5 = this.rows - 1;
                return this.scrollLines(2 === i4.type ? -t5 : t5), this.cancel(e3, true);
              }
              return 1 === i4.type && this.selectAll(), !!this._isThirdLevelShift(this.browser, e3) || (i4.cancel && this.cancel(e3, true), !i4.key || !!(e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && 1 === e3.key.length && e3.key.charCodeAt(0) >= 65 && e3.key.charCodeAt(0) <= 90) || (this._unprocessedDeadKey ? (this._unprocessedDeadKey = false, true) : (i4.key !== D.C0.ETX && i4.key !== D.C0.CR || (this.textarea.value = ""), this._onKey.fire({
                key: i4.key,
                domEvent: e3
              }), this._showCursor(), this.coreService.triggerDataEvent(i4.key, true), !this.optionsService.rawOptions.screenReaderMode || e3.altKey || e3.ctrlKey ? this.cancel(e3, true) : void (this._keyDownHandled = true))));
            }
            _isThirdLevelShift(e3, t4) {
              const i4 = e3.isMac && !this.options.macOptionIsMeta && t4.altKey && !t4.ctrlKey && !t4.metaKey || e3.isWindows && t4.altKey && t4.ctrlKey && !t4.metaKey || e3.isWindows && t4.getModifierState("AltGraph");
              return "keypress" === t4.type ? i4 : i4 && (!t4.keyCode || t4.keyCode > 47);
            }
            _keyUp(e3) {
              this._keyDownSeen = false, this._customKeyEventHandler && false === this._customKeyEventHandler(e3) || (function(e4) {
                return 16 === e4.keyCode || 17 === e4.keyCode || 18 === e4.keyCode;
              }(e3) || this.focus(), this.updateCursorStyle(e3), this._keyPressHandled = false);
            }
            _keyPress(e3) {
              let t4;
              if (this._keyPressHandled = false, this._keyDownHandled) return false;
              if (this._customKeyEventHandler && false === this._customKeyEventHandler(e3)) return false;
              if (this.cancel(e3), e3.charCode) t4 = e3.charCode;
              else if (null === e3.which || void 0 === e3.which) t4 = e3.keyCode;
              else {
                if (0 === e3.which || 0 === e3.charCode) return false;
                t4 = e3.which;
              }
              return !(!t4 || (e3.altKey || e3.ctrlKey || e3.metaKey) && !this._isThirdLevelShift(this.browser, e3) || (t4 = String.fromCharCode(t4), this._onKey.fire({
                key: t4,
                domEvent: e3
              }), this._showCursor(), this.coreService.triggerDataEvent(t4, true), this._keyPressHandled = true, this._unprocessedDeadKey = false, 0));
            }
            _inputEvent(e3) {
              if (e3.data && "insertText" === e3.inputType && (!e3.composed || !this._keyDownSeen) && !this.optionsService.rawOptions.screenReaderMode) {
                if (this._keyPressHandled) return false;
                this._unprocessedDeadKey = false;
                const t4 = e3.data;
                return this.coreService.triggerDataEvent(t4, true), this.cancel(e3), true;
              }
              return false;
            }
            resize(e3, t4) {
              e3 !== this.cols || t4 !== this.rows ? super.resize(e3, t4) : this._charSizeService && !this._charSizeService.hasValidSize && this._charSizeService.measure();
            }
            _afterResize(e3, t4) {
              var _a2, _b;
              (_a2 = this._charSizeService) == null ? void 0 : _a2.measure(), (_b = this.viewport) == null ? void 0 : _b.syncScrollArea(true);
            }
            clear() {
              var _a2;
              if (0 !== this.buffer.ybase || 0 !== this.buffer.y) {
                this.buffer.clearAllMarkers(), this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y)), this.buffer.lines.length = 1, this.buffer.ydisp = 0, this.buffer.ybase = 0, this.buffer.y = 0;
                for (let e3 = 1; e3 < this.rows; e3++) this.buffer.lines.push(this.buffer.getBlankLine(L.DEFAULT_ATTR_DATA));
                this._onScroll.fire({
                  position: this.buffer.ydisp,
                  source: 0
                }), (_a2 = this.viewport) == null ? void 0 : _a2.reset(), this.refresh(0, this.rows - 1);
              }
            }
            reset() {
              var _a2, _b;
              this.options.rows = this.rows, this.options.cols = this.cols;
              const e3 = this._customKeyEventHandler;
              this._setup(), super.reset(), (_a2 = this._selectionService) == null ? void 0 : _a2.reset(), this._decorationService.reset(), (_b = this.viewport) == null ? void 0 : _b.reset(), this._customKeyEventHandler = e3, this.refresh(0, this.rows - 1);
            }
            clearTextureAtlas() {
              var _a2;
              (_a2 = this._renderService) == null ? void 0 : _a2.clearTextureAtlas();
            }
            _reportFocus() {
              var _a2;
              ((_a2 = this.element) == null ? void 0 : _a2.classList.contains("focus")) ? this.coreService.triggerDataEvent(D.C0.ESC + "[I") : this.coreService.triggerDataEvent(D.C0.ESC + "[O");
            }
            _reportWindowsOptions(e3) {
              if (this._renderService) switch (e3) {
                case T.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:
                  const e4 = this._renderService.dimensions.css.canvas.width.toFixed(0), t4 = this._renderService.dimensions.css.canvas.height.toFixed(0);
                  this.coreService.triggerDataEvent(`${D.C0.ESC}[4;${t4};${e4}t`);
                  break;
                case T.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:
                  const i4 = this._renderService.dimensions.css.cell.width.toFixed(0), s3 = this._renderService.dimensions.css.cell.height.toFixed(0);
                  this.coreService.triggerDataEvent(`${D.C0.ESC}[6;${s3};${i4}t`);
              }
            }
            cancel(e3, t4) {
              if (this.options.cancelEvents || t4) return e3.preventDefault(), e3.stopPropagation(), false;
            }
          }
          t3.Terminal = P;
        },
        9924: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.TimeBasedDebouncer = void 0, t3.TimeBasedDebouncer = class {
            constructor(e3, t4 = 1e3) {
              this._renderCallback = e3, this._debounceThresholdMS = t4, this._lastRefreshMs = 0, this._additionalRefreshRequested = false;
            }
            dispose() {
              this._refreshTimeoutID && clearTimeout(this._refreshTimeoutID);
            }
            refresh(e3, t4, i3) {
              this._rowCount = i3, e3 = void 0 !== e3 ? e3 : 0, t4 = void 0 !== t4 ? t4 : this._rowCount - 1, this._rowStart = void 0 !== this._rowStart ? Math.min(this._rowStart, e3) : e3, this._rowEnd = void 0 !== this._rowEnd ? Math.max(this._rowEnd, t4) : t4;
              const s2 = Date.now();
              if (s2 - this._lastRefreshMs >= this._debounceThresholdMS) this._lastRefreshMs = s2, this._innerRefresh();
              else if (!this._additionalRefreshRequested) {
                const e4 = s2 - this._lastRefreshMs, t5 = this._debounceThresholdMS - e4;
                this._additionalRefreshRequested = true, this._refreshTimeoutID = window.setTimeout(() => {
                  this._lastRefreshMs = Date.now(), this._innerRefresh(), this._additionalRefreshRequested = false, this._refreshTimeoutID = void 0;
                }, t5);
              }
            }
            _innerRefresh() {
              if (void 0 === this._rowStart || void 0 === this._rowEnd || void 0 === this._rowCount) return;
              const e3 = Math.max(this._rowStart, 0), t4 = Math.min(this._rowEnd, this._rowCount - 1);
              this._rowStart = void 0, this._rowEnd = void 0, this._renderCallback(e3, t4);
            }
          };
        },
        1680: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Viewport = void 0;
          const n = i3(3656), o = i3(4725), a = i3(8460), h = i3(844), c = i3(2585);
          let l = t3.Viewport = class extends h.Disposable {
            constructor(e3, t4, i4, s3, r2, o2, h2, c2) {
              super(), this._viewportElement = e3, this._scrollArea = t4, this._bufferService = i4, this._optionsService = s3, this._charSizeService = r2, this._renderService = o2, this._coreBrowserService = h2, this.scrollBarWidth = 0, this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._wheelPartialScroll = 0, this._refreshAnimationFrame = null, this._ignoreNextScrollEvent = false, this._smoothScrollState = {
                startTime: 0,
                origin: -1,
                target: -1
              }, this._onRequestScrollLines = this.register(new a.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this.scrollBarWidth = this._viewportElement.offsetWidth - this._scrollArea.offsetWidth || 15, this.register((0, n.addDisposableDomListener)(this._viewportElement, "scroll", this._handleScroll.bind(this))), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._renderDimensions = this._renderService.dimensions, this.register(this._renderService.onDimensionsChange((e4) => this._renderDimensions = e4)), this._handleThemeChange(c2.colors), this.register(c2.onChangeColors((e4) => this._handleThemeChange(e4))), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.syncScrollArea())), setTimeout(() => this.syncScrollArea());
            }
            _handleThemeChange(e3) {
              this._viewportElement.style.backgroundColor = e3.background.css;
            }
            reset() {
              this._currentRowHeight = 0, this._currentDeviceCellHeight = 0, this._lastRecordedBufferLength = 0, this._lastRecordedViewportHeight = 0, this._lastRecordedBufferHeight = 0, this._lastTouchY = 0, this._lastScrollTop = 0, this._coreBrowserService.window.requestAnimationFrame(() => this.syncScrollArea());
            }
            _refresh(e3) {
              if (e3) return this._innerRefresh(), void (null !== this._refreshAnimationFrame && this._coreBrowserService.window.cancelAnimationFrame(this._refreshAnimationFrame));
              null === this._refreshAnimationFrame && (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._innerRefresh()));
            }
            _innerRefresh() {
              if (this._charSizeService.height > 0) {
                this._currentRowHeight = this._renderDimensions.device.cell.height / this._coreBrowserService.dpr, this._currentDeviceCellHeight = this._renderDimensions.device.cell.height, this._lastRecordedViewportHeight = this._viewportElement.offsetHeight;
                const e4 = Math.round(this._currentRowHeight * this._lastRecordedBufferLength) + (this._lastRecordedViewportHeight - this._renderDimensions.css.canvas.height);
                this._lastRecordedBufferHeight !== e4 && (this._lastRecordedBufferHeight = e4, this._scrollArea.style.height = this._lastRecordedBufferHeight + "px");
              }
              const e3 = this._bufferService.buffer.ydisp * this._currentRowHeight;
              this._viewportElement.scrollTop !== e3 && (this._ignoreNextScrollEvent = true, this._viewportElement.scrollTop = e3), this._refreshAnimationFrame = null;
            }
            syncScrollArea(e3 = false) {
              if (this._lastRecordedBufferLength !== this._bufferService.buffer.lines.length) return this._lastRecordedBufferLength = this._bufferService.buffer.lines.length, void this._refresh(e3);
              this._lastRecordedViewportHeight === this._renderService.dimensions.css.canvas.height && this._lastScrollTop === this._activeBuffer.ydisp * this._currentRowHeight && this._renderDimensions.device.cell.height === this._currentDeviceCellHeight || this._refresh(e3);
            }
            _handleScroll(e3) {
              if (this._lastScrollTop = this._viewportElement.scrollTop, !this._viewportElement.offsetParent) return;
              if (this._ignoreNextScrollEvent) return this._ignoreNextScrollEvent = false, void this._onRequestScrollLines.fire({
                amount: 0,
                suppressScrollEvent: true
              });
              const t4 = Math.round(this._lastScrollTop / this._currentRowHeight) - this._bufferService.buffer.ydisp;
              this._onRequestScrollLines.fire({
                amount: t4,
                suppressScrollEvent: true
              });
            }
            _smoothScroll() {
              if (this._isDisposed || -1 === this._smoothScrollState.origin || -1 === this._smoothScrollState.target) return;
              const e3 = this._smoothScrollPercent();
              this._viewportElement.scrollTop = this._smoothScrollState.origin + Math.round(e3 * (this._smoothScrollState.target - this._smoothScrollState.origin)), e3 < 1 ? this._coreBrowserService.window.requestAnimationFrame(() => this._smoothScroll()) : this._clearSmoothScrollState();
            }
            _smoothScrollPercent() {
              return this._optionsService.rawOptions.smoothScrollDuration && this._smoothScrollState.startTime ? Math.max(Math.min((Date.now() - this._smoothScrollState.startTime) / this._optionsService.rawOptions.smoothScrollDuration, 1), 0) : 1;
            }
            _clearSmoothScrollState() {
              this._smoothScrollState.startTime = 0, this._smoothScrollState.origin = -1, this._smoothScrollState.target = -1;
            }
            _bubbleScroll(e3, t4) {
              const i4 = this._viewportElement.scrollTop + this._lastRecordedViewportHeight;
              return !(t4 < 0 && 0 !== this._viewportElement.scrollTop || t4 > 0 && i4 < this._lastRecordedBufferHeight) || (e3.cancelable && e3.preventDefault(), false);
            }
            handleWheel(e3) {
              const t4 = this._getPixelsScrolled(e3);
              return 0 !== t4 && (this._optionsService.rawOptions.smoothScrollDuration ? (this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, -1 === this._smoothScrollState.target ? this._smoothScrollState.target = this._viewportElement.scrollTop + t4 : this._smoothScrollState.target += t4, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState()) : this._viewportElement.scrollTop += t4, this._bubbleScroll(e3, t4));
            }
            scrollLines(e3) {
              if (0 !== e3) if (this._optionsService.rawOptions.smoothScrollDuration) {
                const t4 = e3 * this._currentRowHeight;
                this._smoothScrollState.startTime = Date.now(), this._smoothScrollPercent() < 1 ? (this._smoothScrollState.origin = this._viewportElement.scrollTop, this._smoothScrollState.target = this._smoothScrollState.origin + t4, this._smoothScrollState.target = Math.max(Math.min(this._smoothScrollState.target, this._viewportElement.scrollHeight), 0), this._smoothScroll()) : this._clearSmoothScrollState();
              } else this._onRequestScrollLines.fire({
                amount: e3,
                suppressScrollEvent: false
              });
            }
            _getPixelsScrolled(e3) {
              if (0 === e3.deltaY || e3.shiftKey) return 0;
              let t4 = this._applyScrollModifier(e3.deltaY, e3);
              return e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? t4 *= this._currentRowHeight : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t4 *= this._currentRowHeight * this._bufferService.rows), t4;
            }
            getBufferElements(e3, t4) {
              var _a2;
              let i4, s3 = "";
              const r2 = [], n2 = t4 ?? this._bufferService.buffer.lines.length, o2 = this._bufferService.buffer.lines;
              for (let t5 = e3; t5 < n2; t5++) {
                const e4 = o2.get(t5);
                if (!e4) continue;
                const n3 = (_a2 = o2.get(t5 + 1)) == null ? void 0 : _a2.isWrapped;
                if (s3 += e4.translateToString(!n3), !n3 || t5 === o2.length - 1) {
                  const e5 = document.createElement("div");
                  e5.textContent = s3, r2.push(e5), s3.length > 0 && (i4 = e5), s3 = "";
                }
              }
              return {
                bufferElements: r2,
                cursorElement: i4
              };
            }
            getLinesScrolled(e3) {
              if (0 === e3.deltaY || e3.shiftKey) return 0;
              let t4 = this._applyScrollModifier(e3.deltaY, e3);
              return e3.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? (t4 /= this._currentRowHeight + 0, this._wheelPartialScroll += t4, t4 = Math.floor(Math.abs(this._wheelPartialScroll)) * (this._wheelPartialScroll > 0 ? 1 : -1), this._wheelPartialScroll %= 1) : e3.deltaMode === WheelEvent.DOM_DELTA_PAGE && (t4 *= this._bufferService.rows), t4;
            }
            _applyScrollModifier(e3, t4) {
              const i4 = this._optionsService.rawOptions.fastScrollModifier;
              return "alt" === i4 && t4.altKey || "ctrl" === i4 && t4.ctrlKey || "shift" === i4 && t4.shiftKey ? e3 * this._optionsService.rawOptions.fastScrollSensitivity * this._optionsService.rawOptions.scrollSensitivity : e3 * this._optionsService.rawOptions.scrollSensitivity;
            }
            handleTouchStart(e3) {
              this._lastTouchY = e3.touches[0].pageY;
            }
            handleTouchMove(e3) {
              const t4 = this._lastTouchY - e3.touches[0].pageY;
              return this._lastTouchY = e3.touches[0].pageY, 0 !== t4 && (this._viewportElement.scrollTop += t4, this._bubbleScroll(e3, t4));
            }
          };
          t3.Viewport = l = s2([
            r(2, c.IBufferService),
            r(3, c.IOptionsService),
            r(4, o.ICharSizeService),
            r(5, o.IRenderService),
            r(6, o.ICoreBrowserService),
            r(7, o.IThemeService)
          ], l);
        },
        3107: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferDecorationRenderer = void 0;
          const n = i3(4725), o = i3(844), a = i3(2585);
          let h = t3.BufferDecorationRenderer = class extends o.Disposable {
            constructor(e3, t4, i4, s3, r2) {
              super(), this._screenElement = e3, this._bufferService = t4, this._coreBrowserService = i4, this._decorationService = s3, this._renderService = r2, this._decorationElements = /* @__PURE__ */ new Map(), this._altBufferIsActive = false, this._dimensionsChanged = false, this._container = document.createElement("div"), this._container.classList.add("xterm-decoration-container"), this._screenElement.appendChild(this._container), this.register(this._renderService.onRenderedViewportChange(() => this._doRefreshDecorations())), this.register(this._renderService.onDimensionsChange(() => {
                this._dimensionsChanged = true, this._queueRefresh();
              })), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
                this._altBufferIsActive = this._bufferService.buffer === this._bufferService.buffers.alt;
              })), this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh())), this.register(this._decorationService.onDecorationRemoved((e4) => this._removeDecoration(e4))), this.register((0, o.toDisposable)(() => {
                this._container.remove(), this._decorationElements.clear();
              }));
            }
            _queueRefresh() {
              void 0 === this._animationFrame && (this._animationFrame = this._renderService.addRefreshCallback(() => {
                this._doRefreshDecorations(), this._animationFrame = void 0;
              }));
            }
            _doRefreshDecorations() {
              for (const e3 of this._decorationService.decorations) this._renderDecoration(e3);
              this._dimensionsChanged = false;
            }
            _renderDecoration(e3) {
              this._refreshStyle(e3), this._dimensionsChanged && this._refreshXPosition(e3);
            }
            _createElement(e3) {
              var _a2;
              const t4 = this._coreBrowserService.mainDocument.createElement("div");
              t4.classList.add("xterm-decoration"), t4.classList.toggle("xterm-decoration-top-layer", "top" === ((_a2 = e3 == null ? void 0 : e3.options) == null ? void 0 : _a2.layer)), t4.style.width = `${Math.round((e3.options.width || 1) * this._renderService.dimensions.css.cell.width)}px`, t4.style.height = (e3.options.height || 1) * this._renderService.dimensions.css.cell.height + "px", t4.style.top = (e3.marker.line - this._bufferService.buffers.active.ydisp) * this._renderService.dimensions.css.cell.height + "px", t4.style.lineHeight = `${this._renderService.dimensions.css.cell.height}px`;
              const i4 = e3.options.x ?? 0;
              return i4 && i4 > this._bufferService.cols && (t4.style.display = "none"), this._refreshXPosition(e3, t4), t4;
            }
            _refreshStyle(e3) {
              const t4 = e3.marker.line - this._bufferService.buffers.active.ydisp;
              if (t4 < 0 || t4 >= this._bufferService.rows) e3.element && (e3.element.style.display = "none", e3.onRenderEmitter.fire(e3.element));
              else {
                let i4 = this._decorationElements.get(e3);
                i4 || (i4 = this._createElement(e3), e3.element = i4, this._decorationElements.set(e3, i4), this._container.appendChild(i4), e3.onDispose(() => {
                  this._decorationElements.delete(e3), i4.remove();
                })), i4.style.top = t4 * this._renderService.dimensions.css.cell.height + "px", i4.style.display = this._altBufferIsActive ? "none" : "block", e3.onRenderEmitter.fire(i4);
              }
            }
            _refreshXPosition(e3, t4 = e3.element) {
              if (!t4) return;
              const i4 = e3.options.x ?? 0;
              "right" === (e3.options.anchor || "left") ? t4.style.right = i4 ? i4 * this._renderService.dimensions.css.cell.width + "px" : "" : t4.style.left = i4 ? i4 * this._renderService.dimensions.css.cell.width + "px" : "";
            }
            _removeDecoration(e3) {
              var _a2;
              (_a2 = this._decorationElements.get(e3)) == null ? void 0 : _a2.remove(), this._decorationElements.delete(e3), e3.dispose();
            }
          };
          t3.BufferDecorationRenderer = h = s2([
            r(1, a.IBufferService),
            r(2, n.ICoreBrowserService),
            r(3, a.IDecorationService),
            r(4, n.IRenderService)
          ], h);
        },
        5871: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.ColorZoneStore = void 0, t3.ColorZoneStore = class {
            constructor() {
              this._zones = [], this._zonePool = [], this._zonePoolIndex = 0, this._linePadding = {
                full: 0,
                left: 0,
                center: 0,
                right: 0
              };
            }
            get zones() {
              return this._zonePool.length = Math.min(this._zonePool.length, this._zones.length), this._zones;
            }
            clear() {
              this._zones.length = 0, this._zonePoolIndex = 0;
            }
            addDecoration(e3) {
              if (e3.options.overviewRulerOptions) {
                for (const t4 of this._zones) if (t4.color === e3.options.overviewRulerOptions.color && t4.position === e3.options.overviewRulerOptions.position) {
                  if (this._lineIntersectsZone(t4, e3.marker.line)) return;
                  if (this._lineAdjacentToZone(t4, e3.marker.line, e3.options.overviewRulerOptions.position)) return void this._addLineToZone(t4, e3.marker.line);
                }
                if (this._zonePoolIndex < this._zonePool.length) return this._zonePool[this._zonePoolIndex].color = e3.options.overviewRulerOptions.color, this._zonePool[this._zonePoolIndex].position = e3.options.overviewRulerOptions.position, this._zonePool[this._zonePoolIndex].startBufferLine = e3.marker.line, this._zonePool[this._zonePoolIndex].endBufferLine = e3.marker.line, void this._zones.push(this._zonePool[this._zonePoolIndex++]);
                this._zones.push({
                  color: e3.options.overviewRulerOptions.color,
                  position: e3.options.overviewRulerOptions.position,
                  startBufferLine: e3.marker.line,
                  endBufferLine: e3.marker.line
                }), this._zonePool.push(this._zones[this._zones.length - 1]), this._zonePoolIndex++;
              }
            }
            setPadding(e3) {
              this._linePadding = e3;
            }
            _lineIntersectsZone(e3, t4) {
              return t4 >= e3.startBufferLine && t4 <= e3.endBufferLine;
            }
            _lineAdjacentToZone(e3, t4, i3) {
              return t4 >= e3.startBufferLine - this._linePadding[i3 || "full"] && t4 <= e3.endBufferLine + this._linePadding[i3 || "full"];
            }
            _addLineToZone(e3, t4) {
              e3.startBufferLine = Math.min(e3.startBufferLine, t4), e3.endBufferLine = Math.max(e3.endBufferLine, t4);
            }
          };
        },
        5744: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.OverviewRulerRenderer = void 0;
          const n = i3(5871), o = i3(4725), a = i3(844), h = i3(2585), c = {
            full: 0,
            left: 0,
            center: 0,
            right: 0
          }, l = {
            full: 0,
            left: 0,
            center: 0,
            right: 0
          }, d = {
            full: 0,
            left: 0,
            center: 0,
            right: 0
          };
          let _ = t3.OverviewRulerRenderer = class extends a.Disposable {
            get _width() {
              return this._optionsService.options.overviewRulerWidth || 0;
            }
            constructor(e3, t4, i4, s3, r2, o2, h2) {
              var _a2;
              super(), this._viewportElement = e3, this._screenElement = t4, this._bufferService = i4, this._decorationService = s3, this._renderService = r2, this._optionsService = o2, this._coreBrowserService = h2, this._colorZoneStore = new n.ColorZoneStore(), this._shouldUpdateDimensions = true, this._shouldUpdateAnchor = true, this._lastKnownBufferLength = 0, this._canvas = this._coreBrowserService.mainDocument.createElement("canvas"), this._canvas.classList.add("xterm-decoration-overview-ruler"), this._refreshCanvasDimensions(), (_a2 = this._viewportElement.parentElement) == null ? void 0 : _a2.insertBefore(this._canvas, this._viewportElement);
              const c2 = this._canvas.getContext("2d");
              if (!c2) throw new Error("Ctx cannot be null");
              this._ctx = c2, this._registerDecorationListeners(), this._registerBufferChangeListeners(), this._registerDimensionChangeListeners(), this.register((0, a.toDisposable)(() => {
                var _a3;
                (_a3 = this._canvas) == null ? void 0 : _a3.remove();
              }));
            }
            _registerDecorationListeners() {
              this.register(this._decorationService.onDecorationRegistered(() => this._queueRefresh(void 0, true))), this.register(this._decorationService.onDecorationRemoved(() => this._queueRefresh(void 0, true)));
            }
            _registerBufferChangeListeners() {
              this.register(this._renderService.onRenderedViewportChange(() => this._queueRefresh())), this.register(this._bufferService.buffers.onBufferActivate(() => {
                this._canvas.style.display = this._bufferService.buffer === this._bufferService.buffers.alt ? "none" : "block";
              })), this.register(this._bufferService.onScroll(() => {
                this._lastKnownBufferLength !== this._bufferService.buffers.normal.lines.length && (this._refreshDrawHeightConstants(), this._refreshColorZonePadding());
              }));
            }
            _registerDimensionChangeListeners() {
              this.register(this._renderService.onRender(() => {
                this._containerHeight && this._containerHeight === this._screenElement.clientHeight || (this._queueRefresh(true), this._containerHeight = this._screenElement.clientHeight);
              })), this.register(this._optionsService.onSpecificOptionChange("overviewRulerWidth", () => this._queueRefresh(true))), this.register(this._coreBrowserService.onDprChange(() => this._queueRefresh(true))), this._queueRefresh(true);
            }
            _refreshDrawConstants() {
              const e3 = Math.floor(this._canvas.width / 3), t4 = Math.ceil(this._canvas.width / 3);
              l.full = this._canvas.width, l.left = e3, l.center = t4, l.right = e3, this._refreshDrawHeightConstants(), d.full = 0, d.left = 0, d.center = l.left, d.right = l.left + l.center;
            }
            _refreshDrawHeightConstants() {
              c.full = Math.round(2 * this._coreBrowserService.dpr);
              const e3 = this._canvas.height / this._bufferService.buffer.lines.length, t4 = Math.round(Math.max(Math.min(e3, 12), 6) * this._coreBrowserService.dpr);
              c.left = t4, c.center = t4, c.right = t4;
            }
            _refreshColorZonePadding() {
              this._colorZoneStore.setPadding({
                full: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.full),
                left: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.left),
                center: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.center),
                right: Math.floor(this._bufferService.buffers.active.lines.length / (this._canvas.height - 1) * c.right)
              }), this._lastKnownBufferLength = this._bufferService.buffers.normal.lines.length;
            }
            _refreshCanvasDimensions() {
              this._canvas.style.width = `${this._width}px`, this._canvas.width = Math.round(this._width * this._coreBrowserService.dpr), this._canvas.style.height = `${this._screenElement.clientHeight}px`, this._canvas.height = Math.round(this._screenElement.clientHeight * this._coreBrowserService.dpr), this._refreshDrawConstants(), this._refreshColorZonePadding();
            }
            _refreshDecorations() {
              this._shouldUpdateDimensions && this._refreshCanvasDimensions(), this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height), this._colorZoneStore.clear();
              for (const e4 of this._decorationService.decorations) this._colorZoneStore.addDecoration(e4);
              this._ctx.lineWidth = 1;
              const e3 = this._colorZoneStore.zones;
              for (const t4 of e3) "full" !== t4.position && this._renderColorZone(t4);
              for (const t4 of e3) "full" === t4.position && this._renderColorZone(t4);
              this._shouldUpdateDimensions = false, this._shouldUpdateAnchor = false;
            }
            _renderColorZone(e3) {
              this._ctx.fillStyle = e3.color, this._ctx.fillRect(d[e3.position || "full"], Math.round((this._canvas.height - 1) * (e3.startBufferLine / this._bufferService.buffers.active.lines.length) - c[e3.position || "full"] / 2), l[e3.position || "full"], Math.round((this._canvas.height - 1) * ((e3.endBufferLine - e3.startBufferLine) / this._bufferService.buffers.active.lines.length) + c[e3.position || "full"]));
            }
            _queueRefresh(e3, t4) {
              this._shouldUpdateDimensions = e3 || this._shouldUpdateDimensions, this._shouldUpdateAnchor = t4 || this._shouldUpdateAnchor, void 0 === this._animationFrame && (this._animationFrame = this._coreBrowserService.window.requestAnimationFrame(() => {
                this._refreshDecorations(), this._animationFrame = void 0;
              }));
            }
          };
          t3.OverviewRulerRenderer = _ = s2([
            r(2, h.IBufferService),
            r(3, h.IDecorationService),
            r(4, o.IRenderService),
            r(5, h.IOptionsService),
            r(6, o.ICoreBrowserService)
          ], _);
        },
        2950: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CompositionHelper = void 0;
          const n = i3(4725), o = i3(2585), a = i3(2584);
          let h = t3.CompositionHelper = class {
            get isComposing() {
              return this._isComposing;
            }
            constructor(e3, t4, i4, s3, r2, n2) {
              this._textarea = e3, this._compositionView = t4, this._bufferService = i4, this._optionsService = s3, this._coreService = r2, this._renderService = n2, this._isComposing = false, this._isSendingComposition = false, this._compositionPosition = {
                start: 0,
                end: 0
              }, this._dataAlreadySent = "";
            }
            compositionstart() {
              this._isComposing = true, this._compositionPosition.start = this._textarea.value.length, this._compositionView.textContent = "", this._dataAlreadySent = "", this._compositionView.classList.add("active");
            }
            compositionupdate(e3) {
              this._compositionView.textContent = e3.data, this.updateCompositionElements(), setTimeout(() => {
                this._compositionPosition.end = this._textarea.value.length;
              }, 0);
            }
            compositionend() {
              this._finalizeComposition(true);
            }
            keydown(e3) {
              if (this._isComposing || this._isSendingComposition) {
                if (229 === e3.keyCode) return false;
                if (16 === e3.keyCode || 17 === e3.keyCode || 18 === e3.keyCode) return false;
                this._finalizeComposition(false);
              }
              return 229 !== e3.keyCode || (this._handleAnyTextareaChanges(), false);
            }
            _finalizeComposition(e3) {
              if (this._compositionView.classList.remove("active"), this._isComposing = false, e3) {
                const e4 = {
                  start: this._compositionPosition.start,
                  end: this._compositionPosition.end
                };
                this._isSendingComposition = true, setTimeout(() => {
                  if (this._isSendingComposition) {
                    let t4;
                    this._isSendingComposition = false, e4.start += this._dataAlreadySent.length, t4 = this._isComposing ? this._textarea.value.substring(e4.start, e4.end) : this._textarea.value.substring(e4.start), t4.length > 0 && this._coreService.triggerDataEvent(t4, true);
                  }
                }, 0);
              } else {
                this._isSendingComposition = false;
                const e4 = this._textarea.value.substring(this._compositionPosition.start, this._compositionPosition.end);
                this._coreService.triggerDataEvent(e4, true);
              }
            }
            _handleAnyTextareaChanges() {
              const e3 = this._textarea.value;
              setTimeout(() => {
                if (!this._isComposing) {
                  const t4 = this._textarea.value, i4 = t4.replace(e3, "");
                  this._dataAlreadySent = i4, t4.length > e3.length ? this._coreService.triggerDataEvent(i4, true) : t4.length < e3.length ? this._coreService.triggerDataEvent(`${a.C0.DEL}`, true) : t4.length === e3.length && t4 !== e3 && this._coreService.triggerDataEvent(t4, true);
                }
              }, 0);
            }
            updateCompositionElements(e3) {
              if (this._isComposing) {
                if (this._bufferService.buffer.isCursorInViewport) {
                  const e4 = Math.min(this._bufferService.buffer.x, this._bufferService.cols - 1), t4 = this._renderService.dimensions.css.cell.height, i4 = this._bufferService.buffer.y * this._renderService.dimensions.css.cell.height, s3 = e4 * this._renderService.dimensions.css.cell.width;
                  this._compositionView.style.left = s3 + "px", this._compositionView.style.top = i4 + "px", this._compositionView.style.height = t4 + "px", this._compositionView.style.lineHeight = t4 + "px", this._compositionView.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._compositionView.style.fontSize = this._optionsService.rawOptions.fontSize + "px";
                  const r2 = this._compositionView.getBoundingClientRect();
                  this._textarea.style.left = s3 + "px", this._textarea.style.top = i4 + "px", this._textarea.style.width = Math.max(r2.width, 1) + "px", this._textarea.style.height = Math.max(r2.height, 1) + "px", this._textarea.style.lineHeight = r2.height + "px";
                }
                e3 || setTimeout(() => this.updateCompositionElements(true), 0);
              }
            }
          };
          t3.CompositionHelper = h = s2([
            r(2, o.IBufferService),
            r(3, o.IOptionsService),
            r(4, o.ICoreService),
            r(5, n.IRenderService)
          ], h);
        },
        9806: (e2, t3) => {
          function i3(e3, t4, i4) {
            const s2 = i4.getBoundingClientRect(), r = e3.getComputedStyle(i4), n = parseInt(r.getPropertyValue("padding-left")), o = parseInt(r.getPropertyValue("padding-top"));
            return [
              t4.clientX - s2.left - n,
              t4.clientY - s2.top - o
            ];
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.getCoords = t3.getCoordsRelativeToElement = void 0, t3.getCoordsRelativeToElement = i3, t3.getCoords = function(e3, t4, s2, r, n, o, a, h, c) {
            if (!o) return;
            const l = i3(e3, t4, s2);
            return l ? (l[0] = Math.ceil((l[0] + (c ? a / 2 : 0)) / a), l[1] = Math.ceil(l[1] / h), l[0] = Math.min(Math.max(l[0], 1), r + (c ? 1 : 0)), l[1] = Math.min(Math.max(l[1], 1), n), l) : void 0;
          };
        },
        9504: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.moveToCellSequence = void 0;
          const s2 = i3(2584);
          function r(e3, t4, i4, s3) {
            const r2 = e3 - n(e3, i4), a2 = t4 - n(t4, i4), l = Math.abs(r2 - a2) - function(e4, t5, i5) {
              let s4 = 0;
              const r3 = e4 - n(e4, i5), a3 = t5 - n(t5, i5);
              for (let n2 = 0; n2 < Math.abs(r3 - a3); n2++) {
                const a4 = "A" === o(e4, t5) ? -1 : 1, h2 = i5.buffer.lines.get(r3 + a4 * n2);
                (h2 == null ? void 0 : h2.isWrapped) && s4++;
              }
              return s4;
            }(e3, t4, i4);
            return c(l, h(o(e3, t4), s3));
          }
          function n(e3, t4) {
            let i4 = 0, s3 = t4.buffer.lines.get(e3), r2 = s3 == null ? void 0 : s3.isWrapped;
            for (; r2 && e3 >= 0 && e3 < t4.rows; ) i4++, s3 = t4.buffer.lines.get(--e3), r2 = s3 == null ? void 0 : s3.isWrapped;
            return i4;
          }
          function o(e3, t4) {
            return e3 > t4 ? "A" : "B";
          }
          function a(e3, t4, i4, s3, r2, n2) {
            let o2 = e3, a2 = t4, h2 = "";
            for (; o2 !== i4 || a2 !== s3; ) o2 += r2 ? 1 : -1, r2 && o2 > n2.cols - 1 ? (h2 += n2.buffer.translateBufferLineToString(a2, false, e3, o2), o2 = 0, e3 = 0, a2++) : !r2 && o2 < 0 && (h2 += n2.buffer.translateBufferLineToString(a2, false, 0, e3 + 1), o2 = n2.cols - 1, e3 = o2, a2--);
            return h2 + n2.buffer.translateBufferLineToString(a2, false, e3, o2);
          }
          function h(e3, t4) {
            const i4 = t4 ? "O" : "[";
            return s2.C0.ESC + i4 + e3;
          }
          function c(e3, t4) {
            e3 = Math.floor(e3);
            let i4 = "";
            for (let s3 = 0; s3 < e3; s3++) i4 += t4;
            return i4;
          }
          t3.moveToCellSequence = function(e3, t4, i4, s3) {
            const o2 = i4.buffer.x, l = i4.buffer.y;
            if (!i4.buffer.hasScrollback) return function(e4, t5, i5, s4, o3, l2) {
              return 0 === r(t5, s4, o3, l2).length ? "" : c(a(e4, t5, e4, t5 - n(t5, o3), false, o3).length, h("D", l2));
            }(o2, l, 0, t4, i4, s3) + r(l, t4, i4, s3) + function(e4, t5, i5, s4, o3, l2) {
              let d2;
              d2 = r(t5, s4, o3, l2).length > 0 ? s4 - n(s4, o3) : t5;
              const _2 = s4, u = function(e5, t6, i6, s5, o4, a2) {
                let h2;
                return h2 = r(i6, s5, o4, a2).length > 0 ? s5 - n(s5, o4) : t6, e5 < i6 && h2 <= s5 || e5 >= i6 && h2 < s5 ? "C" : "D";
              }(e4, t5, i5, s4, o3, l2);
              return c(a(e4, d2, i5, _2, "C" === u, o3).length, h(u, l2));
            }(o2, l, e3, t4, i4, s3);
            let d;
            if (l === t4) return d = o2 > e3 ? "D" : "C", c(Math.abs(o2 - e3), h(d, s3));
            d = l > t4 ? "D" : "C";
            const _ = Math.abs(l - t4);
            return c(function(e4, t5) {
              return t5.cols - e4;
            }(l > t4 ? e3 : o2, i4) + (_ - 1) * i4.cols + 1 + ((l > t4 ? o2 : e3) - 1), h(d, s3));
          };
        },
        1296: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.DomRenderer = void 0;
          const n = i3(3787), o = i3(2550), a = i3(2223), h = i3(6171), c = i3(6052), l = i3(4725), d = i3(8055), _ = i3(8460), u = i3(844), f = i3(2585), v = "xterm-dom-renderer-owner-", p = "xterm-rows", g = "xterm-fg-", m = "xterm-bg-", S = "xterm-focus", C2 = "xterm-selection";
          let b = 1, w = t3.DomRenderer = class extends u.Disposable {
            constructor(e3, t4, i4, s3, r2, a2, l2, d2, f2, g2, m2, S2, w2) {
              super(), this._terminal = e3, this._document = t4, this._element = i4, this._screenElement = s3, this._viewportElement = r2, this._helperContainer = a2, this._linkifier2 = l2, this._charSizeService = f2, this._optionsService = g2, this._bufferService = m2, this._coreBrowserService = S2, this._themeService = w2, this._terminalClass = b++, this._rowElements = [], this._selectionRenderModel = (0, c.createSelectionRenderModel)(), this.onRequestRedraw = this.register(new _.EventEmitter()).event, this._rowContainer = this._document.createElement("div"), this._rowContainer.classList.add(p), this._rowContainer.style.lineHeight = "normal", this._rowContainer.setAttribute("aria-hidden", "true"), this._refreshRowElements(this._bufferService.cols, this._bufferService.rows), this._selectionContainer = this._document.createElement("div"), this._selectionContainer.classList.add(C2), this._selectionContainer.setAttribute("aria-hidden", "true"), this.dimensions = (0, h.createRenderDimensions)(), this._updateDimensions(), this.register(this._optionsService.onOptionChange(() => this._handleOptionsChanged())), this.register(this._themeService.onChangeColors((e4) => this._injectCss(e4))), this._injectCss(this._themeService.colors), this._rowFactory = d2.createInstance(n.DomRendererRowFactory, document), this._element.classList.add(v + this._terminalClass), this._screenElement.appendChild(this._rowContainer), this._screenElement.appendChild(this._selectionContainer), this.register(this._linkifier2.onShowLinkUnderline((e4) => this._handleLinkHover(e4))), this.register(this._linkifier2.onHideLinkUnderline((e4) => this._handleLinkLeave(e4))), this.register((0, u.toDisposable)(() => {
                this._element.classList.remove(v + this._terminalClass), this._rowContainer.remove(), this._selectionContainer.remove(), this._widthCache.dispose(), this._themeStyleElement.remove(), this._dimensionsStyleElement.remove();
              })), this._widthCache = new o.WidthCache(this._document, this._helperContainer), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
            }
            _updateDimensions() {
              const e3 = this._coreBrowserService.dpr;
              this.dimensions.device.char.width = this._charSizeService.width * e3, this.dimensions.device.char.height = Math.ceil(this._charSizeService.height * e3), this.dimensions.device.cell.width = this.dimensions.device.char.width + Math.round(this._optionsService.rawOptions.letterSpacing), this.dimensions.device.cell.height = Math.floor(this.dimensions.device.char.height * this._optionsService.rawOptions.lineHeight), this.dimensions.device.char.left = 0, this.dimensions.device.char.top = 0, this.dimensions.device.canvas.width = this.dimensions.device.cell.width * this._bufferService.cols, this.dimensions.device.canvas.height = this.dimensions.device.cell.height * this._bufferService.rows, this.dimensions.css.canvas.width = Math.round(this.dimensions.device.canvas.width / e3), this.dimensions.css.canvas.height = Math.round(this.dimensions.device.canvas.height / e3), this.dimensions.css.cell.width = this.dimensions.css.canvas.width / this._bufferService.cols, this.dimensions.css.cell.height = this.dimensions.css.canvas.height / this._bufferService.rows;
              for (const e4 of this._rowElements) e4.style.width = `${this.dimensions.css.canvas.width}px`, e4.style.height = `${this.dimensions.css.cell.height}px`, e4.style.lineHeight = `${this.dimensions.css.cell.height}px`, e4.style.overflow = "hidden";
              this._dimensionsStyleElement || (this._dimensionsStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._dimensionsStyleElement));
              const t4 = `${this._terminalSelector} .${p} span { display: inline-block; height: 100%; vertical-align: top;}`;
              this._dimensionsStyleElement.textContent = t4, this._selectionContainer.style.height = this._viewportElement.style.height, this._screenElement.style.width = `${this.dimensions.css.canvas.width}px`, this._screenElement.style.height = `${this.dimensions.css.canvas.height}px`;
            }
            _injectCss(e3) {
              this._themeStyleElement || (this._themeStyleElement = this._document.createElement("style"), this._screenElement.appendChild(this._themeStyleElement));
              let t4 = `${this._terminalSelector} .${p} { color: ${e3.foreground.css}; font-family: ${this._optionsService.rawOptions.fontFamily}; font-size: ${this._optionsService.rawOptions.fontSize}px; font-kerning: none; white-space: pre}`;
              t4 += `${this._terminalSelector} .${p} .xterm-dim { color: ${d.color.multiplyOpacity(e3.foreground, 0.5).css};}`, t4 += `${this._terminalSelector} span:not(.xterm-bold) { font-weight: ${this._optionsService.rawOptions.fontWeight};}${this._terminalSelector} span.xterm-bold { font-weight: ${this._optionsService.rawOptions.fontWeightBold};}${this._terminalSelector} span.xterm-italic { font-style: italic;}`;
              const i4 = `blink_underline_${this._terminalClass}`, s3 = `blink_bar_${this._terminalClass}`, r2 = `blink_block_${this._terminalClass}`;
              t4 += `@keyframes ${i4} { 50% {  border-bottom-style: hidden; }}`, t4 += `@keyframes ${s3} { 50% {  box-shadow: none; }}`, t4 += `@keyframes ${r2} { 0% {  background-color: ${e3.cursor.css};  color: ${e3.cursorAccent.css}; } 50% {  background-color: inherit;  color: ${e3.cursor.css}; }}`, t4 += `${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-underline { animation: ${i4} 1s step-end infinite;}${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-bar { animation: ${s3} 1s step-end infinite;}${this._terminalSelector} .${p}.${S} .xterm-cursor.xterm-cursor-blink.xterm-cursor-block { animation: ${r2} 1s step-end infinite;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-block { background-color: ${e3.cursor.css}; color: ${e3.cursorAccent.css};}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-block:not(.xterm-cursor-blink) { background-color: ${e3.cursor.css} !important; color: ${e3.cursorAccent.css} !important;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-outline { outline: 1px solid ${e3.cursor.css}; outline-offset: -1px;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-bar { box-shadow: ${this._optionsService.rawOptions.cursorWidth}px 0 0 ${e3.cursor.css} inset;}${this._terminalSelector} .${p} .xterm-cursor.xterm-cursor-underline { border-bottom: 1px ${e3.cursor.css}; border-bottom-style: solid; height: calc(100% - 1px);}`, t4 += `${this._terminalSelector} .${C2} { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}${this._terminalSelector}.focus .${C2} div { position: absolute; background-color: ${e3.selectionBackgroundOpaque.css};}${this._terminalSelector} .${C2} div { position: absolute; background-color: ${e3.selectionInactiveBackgroundOpaque.css};}`;
              for (const [i5, s4] of e3.ansi.entries()) t4 += `${this._terminalSelector} .${g}${i5} { color: ${s4.css}; }${this._terminalSelector} .${g}${i5}.xterm-dim { color: ${d.color.multiplyOpacity(s4, 0.5).css}; }${this._terminalSelector} .${m}${i5} { background-color: ${s4.css}; }`;
              t4 += `${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR} { color: ${d.color.opaque(e3.background).css}; }${this._terminalSelector} .${g}${a.INVERTED_DEFAULT_COLOR}.xterm-dim { color: ${d.color.multiplyOpacity(d.color.opaque(e3.background), 0.5).css}; }${this._terminalSelector} .${m}${a.INVERTED_DEFAULT_COLOR} { background-color: ${e3.foreground.css}; }`, this._themeStyleElement.textContent = t4;
            }
            _setDefaultSpacing() {
              const e3 = this.dimensions.css.cell.width - this._widthCache.get("W", false, false);
              this._rowContainer.style.letterSpacing = `${e3}px`, this._rowFactory.defaultSpacing = e3;
            }
            handleDevicePixelRatioChange() {
              this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
            }
            _refreshRowElements(e3, t4) {
              for (let e4 = this._rowElements.length; e4 <= t4; e4++) {
                const e5 = this._document.createElement("div");
                this._rowContainer.appendChild(e5), this._rowElements.push(e5);
              }
              for (; this._rowElements.length > t4; ) this._rowContainer.removeChild(this._rowElements.pop());
            }
            handleResize(e3, t4) {
              this._refreshRowElements(e3, t4), this._updateDimensions(), this.handleSelectionChanged(this._selectionRenderModel.selectionStart, this._selectionRenderModel.selectionEnd, this._selectionRenderModel.columnSelectMode);
            }
            handleCharSizeChanged() {
              this._updateDimensions(), this._widthCache.clear(), this._setDefaultSpacing();
            }
            handleBlur() {
              this._rowContainer.classList.remove(S), this.renderRows(0, this._bufferService.rows - 1);
            }
            handleFocus() {
              this._rowContainer.classList.add(S), this.renderRows(this._bufferService.buffer.y, this._bufferService.buffer.y);
            }
            handleSelectionChanged(e3, t4, i4) {
              if (this._selectionContainer.replaceChildren(), this._rowFactory.handleSelectionChanged(e3, t4, i4), this.renderRows(0, this._bufferService.rows - 1), !e3 || !t4) return;
              this._selectionRenderModel.update(this._terminal, e3, t4, i4);
              const s3 = this._selectionRenderModel.viewportStartRow, r2 = this._selectionRenderModel.viewportEndRow, n2 = this._selectionRenderModel.viewportCappedStartRow, o2 = this._selectionRenderModel.viewportCappedEndRow;
              if (n2 >= this._bufferService.rows || o2 < 0) return;
              const a2 = this._document.createDocumentFragment();
              if (i4) {
                const i5 = e3[0] > t4[0];
                a2.appendChild(this._createSelectionElement(n2, i5 ? t4[0] : e3[0], i5 ? e3[0] : t4[0], o2 - n2 + 1));
              } else {
                const i5 = s3 === n2 ? e3[0] : 0, h2 = n2 === r2 ? t4[0] : this._bufferService.cols;
                a2.appendChild(this._createSelectionElement(n2, i5, h2));
                const c2 = o2 - n2 - 1;
                if (a2.appendChild(this._createSelectionElement(n2 + 1, 0, this._bufferService.cols, c2)), n2 !== o2) {
                  const e4 = r2 === o2 ? t4[0] : this._bufferService.cols;
                  a2.appendChild(this._createSelectionElement(o2, 0, e4));
                }
              }
              this._selectionContainer.appendChild(a2);
            }
            _createSelectionElement(e3, t4, i4, s3 = 1) {
              const r2 = this._document.createElement("div"), n2 = t4 * this.dimensions.css.cell.width;
              let o2 = this.dimensions.css.cell.width * (i4 - t4);
              return n2 + o2 > this.dimensions.css.canvas.width && (o2 = this.dimensions.css.canvas.width - n2), r2.style.height = s3 * this.dimensions.css.cell.height + "px", r2.style.top = e3 * this.dimensions.css.cell.height + "px", r2.style.left = `${n2}px`, r2.style.width = `${o2}px`, r2;
            }
            handleCursorMove() {
            }
            _handleOptionsChanged() {
              this._updateDimensions(), this._injectCss(this._themeService.colors), this._widthCache.setFont(this._optionsService.rawOptions.fontFamily, this._optionsService.rawOptions.fontSize, this._optionsService.rawOptions.fontWeight, this._optionsService.rawOptions.fontWeightBold), this._setDefaultSpacing();
            }
            clear() {
              for (const e3 of this._rowElements) e3.replaceChildren();
            }
            renderRows(e3, t4) {
              const i4 = this._bufferService.buffer, s3 = i4.ybase + i4.y, r2 = Math.min(i4.x, this._bufferService.cols - 1), n2 = this._optionsService.rawOptions.cursorBlink, o2 = this._optionsService.rawOptions.cursorStyle, a2 = this._optionsService.rawOptions.cursorInactiveStyle;
              for (let h2 = e3; h2 <= t4; h2++) {
                const e4 = h2 + i4.ydisp, t5 = this._rowElements[h2], c2 = i4.lines.get(e4);
                if (!t5 || !c2) break;
                t5.replaceChildren(...this._rowFactory.createRow(c2, e4, e4 === s3, o2, a2, r2, n2, this.dimensions.css.cell.width, this._widthCache, -1, -1));
              }
            }
            get _terminalSelector() {
              return `.${v}${this._terminalClass}`;
            }
            _handleLinkHover(e3) {
              this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, true);
            }
            _handleLinkLeave(e3) {
              this._setCellUnderline(e3.x1, e3.x2, e3.y1, e3.y2, e3.cols, false);
            }
            _setCellUnderline(e3, t4, i4, s3, r2, n2) {
              i4 < 0 && (e3 = 0), s3 < 0 && (t4 = 0);
              const o2 = this._bufferService.rows - 1;
              i4 = Math.max(Math.min(i4, o2), 0), s3 = Math.max(Math.min(s3, o2), 0), r2 = Math.min(r2, this._bufferService.cols);
              const a2 = this._bufferService.buffer, h2 = a2.ybase + a2.y, c2 = Math.min(a2.x, r2 - 1), l2 = this._optionsService.rawOptions.cursorBlink, d2 = this._optionsService.rawOptions.cursorStyle, _2 = this._optionsService.rawOptions.cursorInactiveStyle;
              for (let o3 = i4; o3 <= s3; ++o3) {
                const u2 = o3 + a2.ydisp, f2 = this._rowElements[o3], v2 = a2.lines.get(u2);
                if (!f2 || !v2) break;
                f2.replaceChildren(...this._rowFactory.createRow(v2, u2, u2 === h2, d2, _2, c2, l2, this.dimensions.css.cell.width, this._widthCache, n2 ? o3 === i4 ? e3 : 0 : -1, n2 ? (o3 === s3 ? t4 : r2) - 1 : -1));
              }
            }
          };
          t3.DomRenderer = w = s2([
            r(7, f.IInstantiationService),
            r(8, l.ICharSizeService),
            r(9, f.IOptionsService),
            r(10, f.IBufferService),
            r(11, l.ICoreBrowserService),
            r(12, l.IThemeService)
          ], w);
        },
        3787: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.DomRendererRowFactory = void 0;
          const n = i3(2223), o = i3(643), a = i3(511), h = i3(2585), c = i3(8055), l = i3(4725), d = i3(4269), _ = i3(6171), u = i3(3734);
          let f = t3.DomRendererRowFactory = class {
            constructor(e3, t4, i4, s3, r2, n2, o2) {
              this._document = e3, this._characterJoinerService = t4, this._optionsService = i4, this._coreBrowserService = s3, this._coreService = r2, this._decorationService = n2, this._themeService = o2, this._workCell = new a.CellData(), this._columnSelectMode = false, this.defaultSpacing = 0;
            }
            handleSelectionChanged(e3, t4, i4) {
              this._selectionStart = e3, this._selectionEnd = t4, this._columnSelectMode = i4;
            }
            createRow(e3, t4, i4, s3, r2, a2, h2, l2, _2, f2, p) {
              const g = [], m = this._characterJoinerService.getJoinedCharacters(t4), S = this._themeService.colors;
              let C2, b = e3.getNoBgTrimmedLength();
              i4 && b < a2 + 1 && (b = a2 + 1);
              let w = 0, y = "", E = 0, k = 0, L = 0, D = false, R = 0, x = false, A = 0;
              const B = [], T = -1 !== f2 && -1 !== p;
              for (let M = 0; M < b; M++) {
                e3.loadCell(M, this._workCell);
                let b2 = this._workCell.getWidth();
                if (0 === b2) continue;
                let O = false, P = M, I = this._workCell;
                if (m.length > 0 && M === m[0][0]) {
                  O = true;
                  const t5 = m.shift();
                  I = new d.JoinedCellData(this._workCell, e3.translateToString(true, t5[0], t5[1]), t5[1] - t5[0]), P = t5[1] - 1, b2 = I.getWidth();
                }
                const H = this._isCellInSelection(M, t4), F = i4 && M === a2, W = T && M >= f2 && M <= p;
                let U = false;
                this._decorationService.forEachDecorationAtCell(M, t4, void 0, (e4) => {
                  U = true;
                });
                let N = I.getChars() || o.WHITESPACE_CELL_CHAR;
                if (" " === N && (I.isUnderline() || I.isOverline()) && (N = "\xA0"), A = b2 * l2 - _2.get(N, I.isBold(), I.isItalic()), C2) {
                  if (w && (H && x || !H && !x && I.bg === E) && (H && x && S.selectionForeground || I.fg === k) && I.extended.ext === L && W === D && A === R && !F && !O && !U) {
                    I.isInvisible() ? y += o.WHITESPACE_CELL_CHAR : y += N, w++;
                    continue;
                  }
                  w && (C2.textContent = y), C2 = this._document.createElement("span"), w = 0, y = "";
                } else C2 = this._document.createElement("span");
                if (E = I.bg, k = I.fg, L = I.extended.ext, D = W, R = A, x = H, O && a2 >= M && a2 <= P && (a2 = M), !this._coreService.isCursorHidden && F && this._coreService.isCursorInitialized) {
                  if (B.push("xterm-cursor"), this._coreBrowserService.isFocused) h2 && B.push("xterm-cursor-blink"), B.push("bar" === s3 ? "xterm-cursor-bar" : "underline" === s3 ? "xterm-cursor-underline" : "xterm-cursor-block");
                  else if (r2) switch (r2) {
                    case "outline":
                      B.push("xterm-cursor-outline");
                      break;
                    case "block":
                      B.push("xterm-cursor-block");
                      break;
                    case "bar":
                      B.push("xterm-cursor-bar");
                      break;
                    case "underline":
                      B.push("xterm-cursor-underline");
                  }
                }
                if (I.isBold() && B.push("xterm-bold"), I.isItalic() && B.push("xterm-italic"), I.isDim() && B.push("xterm-dim"), y = I.isInvisible() ? o.WHITESPACE_CELL_CHAR : I.getChars() || o.WHITESPACE_CELL_CHAR, I.isUnderline() && (B.push(`xterm-underline-${I.extended.underlineStyle}`), " " === y && (y = "\xA0"), !I.isUnderlineColorDefault())) if (I.isUnderlineColorRGB()) C2.style.textDecorationColor = `rgb(${u.AttributeData.toColorRGB(I.getUnderlineColor()).join(",")})`;
                else {
                  let e4 = I.getUnderlineColor();
                  this._optionsService.rawOptions.drawBoldTextInBrightColors && I.isBold() && e4 < 8 && (e4 += 8), C2.style.textDecorationColor = S.ansi[e4].css;
                }
                I.isOverline() && (B.push("xterm-overline"), " " === y && (y = "\xA0")), I.isStrikethrough() && B.push("xterm-strikethrough"), W && (C2.style.textDecoration = "underline");
                let $ = I.getFgColor(), j = I.getFgColorMode(), z = I.getBgColor(), K = I.getBgColorMode();
                const q = !!I.isInverse();
                if (q) {
                  const e4 = $;
                  $ = z, z = e4;
                  const t5 = j;
                  j = K, K = t5;
                }
                let V, G, X, J = false;
                switch (this._decorationService.forEachDecorationAtCell(M, t4, void 0, (e4) => {
                  "top" !== e4.options.layer && J || (e4.backgroundColorRGB && (K = 50331648, z = e4.backgroundColorRGB.rgba >> 8 & 16777215, V = e4.backgroundColorRGB), e4.foregroundColorRGB && (j = 50331648, $ = e4.foregroundColorRGB.rgba >> 8 & 16777215, G = e4.foregroundColorRGB), J = "top" === e4.options.layer);
                }), !J && H && (V = this._coreBrowserService.isFocused ? S.selectionBackgroundOpaque : S.selectionInactiveBackgroundOpaque, z = V.rgba >> 8 & 16777215, K = 50331648, J = true, S.selectionForeground && (j = 50331648, $ = S.selectionForeground.rgba >> 8 & 16777215, G = S.selectionForeground)), J && B.push("xterm-decoration-top"), K) {
                  case 16777216:
                  case 33554432:
                    X = S.ansi[z], B.push(`xterm-bg-${z}`);
                    break;
                  case 50331648:
                    X = c.channels.toColor(z >> 16, z >> 8 & 255, 255 & z), this._addStyle(C2, `background-color:#${v((z >>> 0).toString(16), "0", 6)}`);
                    break;
                  default:
                    q ? (X = S.foreground, B.push(`xterm-bg-${n.INVERTED_DEFAULT_COLOR}`)) : X = S.background;
                }
                switch (V || I.isDim() && (V = c.color.multiplyOpacity(X, 0.5)), j) {
                  case 16777216:
                  case 33554432:
                    I.isBold() && $ < 8 && this._optionsService.rawOptions.drawBoldTextInBrightColors && ($ += 8), this._applyMinimumContrast(C2, X, S.ansi[$], I, V, void 0) || B.push(`xterm-fg-${$}`);
                    break;
                  case 50331648:
                    const e4 = c.channels.toColor($ >> 16 & 255, $ >> 8 & 255, 255 & $);
                    this._applyMinimumContrast(C2, X, e4, I, V, G) || this._addStyle(C2, `color:#${v($.toString(16), "0", 6)}`);
                    break;
                  default:
                    this._applyMinimumContrast(C2, X, S.foreground, I, V, G) || q && B.push(`xterm-fg-${n.INVERTED_DEFAULT_COLOR}`);
                }
                B.length && (C2.className = B.join(" "), B.length = 0), F || O || U ? C2.textContent = y : w++, A !== this.defaultSpacing && (C2.style.letterSpacing = `${A}px`), g.push(C2), M = P;
              }
              return C2 && w && (C2.textContent = y), g;
            }
            _applyMinimumContrast(e3, t4, i4, s3, r2, n2) {
              if (1 === this._optionsService.rawOptions.minimumContrastRatio || (0, _.treatGlyphAsBackgroundColor)(s3.getCode())) return false;
              const o2 = this._getContrastCache(s3);
              let a2;
              if (r2 || n2 || (a2 = o2.getColor(t4.rgba, i4.rgba)), void 0 === a2) {
                const e4 = this._optionsService.rawOptions.minimumContrastRatio / (s3.isDim() ? 2 : 1);
                a2 = c.color.ensureContrastRatio(r2 || t4, n2 || i4, e4), o2.setColor((r2 || t4).rgba, (n2 || i4).rgba, a2 ?? null);
              }
              return !!a2 && (this._addStyle(e3, `color:${a2.css}`), true);
            }
            _getContrastCache(e3) {
              return e3.isDim() ? this._themeService.colors.halfContrastCache : this._themeService.colors.contrastCache;
            }
            _addStyle(e3, t4) {
              e3.setAttribute("style", `${e3.getAttribute("style") || ""}${t4};`);
            }
            _isCellInSelection(e3, t4) {
              const i4 = this._selectionStart, s3 = this._selectionEnd;
              return !(!i4 || !s3) && (this._columnSelectMode ? i4[0] <= s3[0] ? e3 >= i4[0] && t4 >= i4[1] && e3 < s3[0] && t4 <= s3[1] : e3 < i4[0] && t4 >= i4[1] && e3 >= s3[0] && t4 <= s3[1] : t4 > i4[1] && t4 < s3[1] || i4[1] === s3[1] && t4 === i4[1] && e3 >= i4[0] && e3 < s3[0] || i4[1] < s3[1] && t4 === s3[1] && e3 < s3[0] || i4[1] < s3[1] && t4 === i4[1] && e3 >= i4[0]);
            }
          };
          function v(e3, t4, i4) {
            for (; e3.length < i4; ) e3 = t4 + e3;
            return e3;
          }
          t3.DomRendererRowFactory = f = s2([
            r(1, l.ICharacterJoinerService),
            r(2, h.IOptionsService),
            r(3, l.ICoreBrowserService),
            r(4, h.ICoreService),
            r(5, h.IDecorationService),
            r(6, l.IThemeService)
          ], f);
        },
        2550: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.WidthCache = void 0, t3.WidthCache = class {
            constructor(e3, t4) {
              this._flat = new Float32Array(256), this._font = "", this._fontSize = 0, this._weight = "normal", this._weightBold = "bold", this._measureElements = [], this._container = e3.createElement("div"), this._container.classList.add("xterm-width-cache-measure-container"), this._container.setAttribute("aria-hidden", "true"), this._container.style.whiteSpace = "pre", this._container.style.fontKerning = "none";
              const i3 = e3.createElement("span");
              i3.classList.add("xterm-char-measure-element");
              const s2 = e3.createElement("span");
              s2.classList.add("xterm-char-measure-element"), s2.style.fontWeight = "bold";
              const r = e3.createElement("span");
              r.classList.add("xterm-char-measure-element"), r.style.fontStyle = "italic";
              const n = e3.createElement("span");
              n.classList.add("xterm-char-measure-element"), n.style.fontWeight = "bold", n.style.fontStyle = "italic", this._measureElements = [
                i3,
                s2,
                r,
                n
              ], this._container.appendChild(i3), this._container.appendChild(s2), this._container.appendChild(r), this._container.appendChild(n), t4.appendChild(this._container), this.clear();
            }
            dispose() {
              this._container.remove(), this._measureElements.length = 0, this._holey = void 0;
            }
            clear() {
              this._flat.fill(-9999), this._holey = /* @__PURE__ */ new Map();
            }
            setFont(e3, t4, i3, s2) {
              e3 === this._font && t4 === this._fontSize && i3 === this._weight && s2 === this._weightBold || (this._font = e3, this._fontSize = t4, this._weight = i3, this._weightBold = s2, this._container.style.fontFamily = this._font, this._container.style.fontSize = `${this._fontSize}px`, this._measureElements[0].style.fontWeight = `${i3}`, this._measureElements[1].style.fontWeight = `${s2}`, this._measureElements[2].style.fontWeight = `${i3}`, this._measureElements[3].style.fontWeight = `${s2}`, this.clear());
            }
            get(e3, t4, i3) {
              let s2 = 0;
              if (!t4 && !i3 && 1 === e3.length && (s2 = e3.charCodeAt(0)) < 256) {
                if (-9999 !== this._flat[s2]) return this._flat[s2];
                const t5 = this._measure(e3, 0);
                return t5 > 0 && (this._flat[s2] = t5), t5;
              }
              let r = e3;
              t4 && (r += "B"), i3 && (r += "I");
              let n = this._holey.get(r);
              if (void 0 === n) {
                let s3 = 0;
                t4 && (s3 |= 1), i3 && (s3 |= 2), n = this._measure(e3, s3), n > 0 && this._holey.set(r, n);
              }
              return n;
            }
            _measure(e3, t4) {
              const i3 = this._measureElements[t4];
              return i3.textContent = e3.repeat(32), i3.offsetWidth / 32;
            }
          };
        },
        2223: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.TEXT_BASELINE = t3.DIM_OPACITY = t3.INVERTED_DEFAULT_COLOR = void 0;
          const s2 = i3(6114);
          t3.INVERTED_DEFAULT_COLOR = 257, t3.DIM_OPACITY = 0.5, t3.TEXT_BASELINE = s2.isFirefox || s2.isLegacyEdge ? "bottom" : "ideographic";
        },
        6171: (e2, t3) => {
          function i3(e3) {
            return 57508 <= e3 && e3 <= 57558;
          }
          function s2(e3) {
            return e3 >= 128512 && e3 <= 128591 || e3 >= 127744 && e3 <= 128511 || e3 >= 128640 && e3 <= 128767 || e3 >= 9728 && e3 <= 9983 || e3 >= 9984 && e3 <= 10175 || e3 >= 65024 && e3 <= 65039 || e3 >= 129280 && e3 <= 129535 || e3 >= 127462 && e3 <= 127487;
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.computeNextVariantOffset = t3.createRenderDimensions = t3.treatGlyphAsBackgroundColor = t3.allowRescaling = t3.isEmoji = t3.isRestrictedPowerlineGlyph = t3.isPowerlineGlyph = t3.throwIfFalsy = void 0, t3.throwIfFalsy = function(e3) {
            if (!e3) throw new Error("value must not be falsy");
            return e3;
          }, t3.isPowerlineGlyph = i3, t3.isRestrictedPowerlineGlyph = function(e3) {
            return 57520 <= e3 && e3 <= 57527;
          }, t3.isEmoji = s2, t3.allowRescaling = function(e3, t4, r, n) {
            return 1 === t4 && r > Math.ceil(1.5 * n) && void 0 !== e3 && e3 > 255 && !s2(e3) && !i3(e3) && !function(e4) {
              return 57344 <= e4 && e4 <= 63743;
            }(e3);
          }, t3.treatGlyphAsBackgroundColor = function(e3) {
            return i3(e3) || function(e4) {
              return 9472 <= e4 && e4 <= 9631;
            }(e3);
          }, t3.createRenderDimensions = function() {
            return {
              css: {
                canvas: {
                  width: 0,
                  height: 0
                },
                cell: {
                  width: 0,
                  height: 0
                }
              },
              device: {
                canvas: {
                  width: 0,
                  height: 0
                },
                cell: {
                  width: 0,
                  height: 0
                },
                char: {
                  width: 0,
                  height: 0,
                  left: 0,
                  top: 0
                }
              }
            };
          }, t3.computeNextVariantOffset = function(e3, t4, i4 = 0) {
            return (e3 - (2 * Math.round(t4) - i4)) % (2 * Math.round(t4));
          };
        },
        6052: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.createSelectionRenderModel = void 0;
          class i3 {
            constructor() {
              this.clear();
            }
            clear() {
              this.hasSelection = false, this.columnSelectMode = false, this.viewportStartRow = 0, this.viewportEndRow = 0, this.viewportCappedStartRow = 0, this.viewportCappedEndRow = 0, this.startCol = 0, this.endCol = 0, this.selectionStart = void 0, this.selectionEnd = void 0;
            }
            update(e3, t4, i4, s2 = false) {
              if (this.selectionStart = t4, this.selectionEnd = i4, !t4 || !i4 || t4[0] === i4[0] && t4[1] === i4[1]) return void this.clear();
              const r = e3.buffers.active.ydisp, n = t4[1] - r, o = i4[1] - r, a = Math.max(n, 0), h = Math.min(o, e3.rows - 1);
              a >= e3.rows || h < 0 ? this.clear() : (this.hasSelection = true, this.columnSelectMode = s2, this.viewportStartRow = n, this.viewportEndRow = o, this.viewportCappedStartRow = a, this.viewportCappedEndRow = h, this.startCol = t4[0], this.endCol = i4[0]);
            }
            isCellSelected(e3, t4, i4) {
              return !!this.hasSelection && (i4 -= e3.buffer.active.viewportY, this.columnSelectMode ? this.startCol <= this.endCol ? t4 >= this.startCol && i4 >= this.viewportCappedStartRow && t4 < this.endCol && i4 <= this.viewportCappedEndRow : t4 < this.startCol && i4 >= this.viewportCappedStartRow && t4 >= this.endCol && i4 <= this.viewportCappedEndRow : i4 > this.viewportStartRow && i4 < this.viewportEndRow || this.viewportStartRow === this.viewportEndRow && i4 === this.viewportStartRow && t4 >= this.startCol && t4 < this.endCol || this.viewportStartRow < this.viewportEndRow && i4 === this.viewportEndRow && t4 < this.endCol || this.viewportStartRow < this.viewportEndRow && i4 === this.viewportStartRow && t4 >= this.startCol);
            }
          }
          t3.createSelectionRenderModel = function() {
            return new i3();
          };
        },
        456: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.SelectionModel = void 0, t3.SelectionModel = class {
            constructor(e3) {
              this._bufferService = e3, this.isSelectAllActive = false, this.selectionStartLength = 0;
            }
            clearSelection() {
              this.selectionStart = void 0, this.selectionEnd = void 0, this.isSelectAllActive = false, this.selectionStartLength = 0;
            }
            get finalSelectionStart() {
              return this.isSelectAllActive ? [
                0,
                0
              ] : this.selectionEnd && this.selectionStart && this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
            }
            get finalSelectionEnd() {
              if (this.isSelectAllActive) return [
                this._bufferService.cols,
                this._bufferService.buffer.ybase + this._bufferService.rows - 1
              ];
              if (this.selectionStart) {
                if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                  const e3 = this.selectionStart[0] + this.selectionStartLength;
                  return e3 > this._bufferService.cols ? e3 % this._bufferService.cols == 0 ? [
                    this._bufferService.cols,
                    this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols) - 1
                  ] : [
                    e3 % this._bufferService.cols,
                    this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)
                  ] : [
                    e3,
                    this.selectionStart[1]
                  ];
                }
                if (this.selectionStartLength && this.selectionEnd[1] === this.selectionStart[1]) {
                  const e3 = this.selectionStart[0] + this.selectionStartLength;
                  return e3 > this._bufferService.cols ? [
                    e3 % this._bufferService.cols,
                    this.selectionStart[1] + Math.floor(e3 / this._bufferService.cols)
                  ] : [
                    Math.max(e3, this.selectionEnd[0]),
                    this.selectionEnd[1]
                  ];
                }
                return this.selectionEnd;
              }
            }
            areSelectionValuesReversed() {
              const e3 = this.selectionStart, t4 = this.selectionEnd;
              return !(!e3 || !t4) && (e3[1] > t4[1] || e3[1] === t4[1] && e3[0] > t4[0]);
            }
            handleTrim(e3) {
              return this.selectionStart && (this.selectionStart[1] -= e3), this.selectionEnd && (this.selectionEnd[1] -= e3), this.selectionEnd && this.selectionEnd[1] < 0 ? (this.clearSelection(), true) : (this.selectionStart && this.selectionStart[1] < 0 && (this.selectionStart[1] = 0), false);
            }
          };
        },
        428: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CharSizeService = void 0;
          const n = i3(2585), o = i3(8460), a = i3(844);
          let h = t3.CharSizeService = class extends a.Disposable {
            get hasValidSize() {
              return this.width > 0 && this.height > 0;
            }
            constructor(e3, t4, i4) {
              super(), this._optionsService = i4, this.width = 0, this.height = 0, this._onCharSizeChange = this.register(new o.EventEmitter()), this.onCharSizeChange = this._onCharSizeChange.event;
              try {
                this._measureStrategy = this.register(new d(this._optionsService));
              } catch {
                this._measureStrategy = this.register(new l(e3, t4, this._optionsService));
              }
              this.register(this._optionsService.onMultipleOptionChange([
                "fontFamily",
                "fontSize"
              ], () => this.measure()));
            }
            measure() {
              const e3 = this._measureStrategy.measure();
              e3.width === this.width && e3.height === this.height || (this.width = e3.width, this.height = e3.height, this._onCharSizeChange.fire());
            }
          };
          t3.CharSizeService = h = s2([
            r(2, n.IOptionsService)
          ], h);
          class c extends a.Disposable {
            constructor() {
              super(...arguments), this._result = {
                width: 0,
                height: 0
              };
            }
            _validateAndSet(e3, t4) {
              void 0 !== e3 && e3 > 0 && void 0 !== t4 && t4 > 0 && (this._result.width = e3, this._result.height = t4);
            }
          }
          class l extends c {
            constructor(e3, t4, i4) {
              super(), this._document = e3, this._parentElement = t4, this._optionsService = i4, this._measureElement = this._document.createElement("span"), this._measureElement.classList.add("xterm-char-measure-element"), this._measureElement.textContent = "W".repeat(32), this._measureElement.setAttribute("aria-hidden", "true"), this._measureElement.style.whiteSpace = "pre", this._measureElement.style.fontKerning = "none", this._parentElement.appendChild(this._measureElement);
            }
            measure() {
              return this._measureElement.style.fontFamily = this._optionsService.rawOptions.fontFamily, this._measureElement.style.fontSize = `${this._optionsService.rawOptions.fontSize}px`, this._validateAndSet(Number(this._measureElement.offsetWidth) / 32, Number(this._measureElement.offsetHeight)), this._result;
            }
          }
          class d extends c {
            constructor(e3) {
              super(), this._optionsService = e3, this._canvas = new OffscreenCanvas(100, 100), this._ctx = this._canvas.getContext("2d");
              const t4 = this._ctx.measureText("W");
              if (!("width" in t4 && "fontBoundingBoxAscent" in t4 && "fontBoundingBoxDescent" in t4)) throw new Error("Required font metrics not supported");
            }
            measure() {
              this._ctx.font = `${this._optionsService.rawOptions.fontSize}px ${this._optionsService.rawOptions.fontFamily}`;
              const e3 = this._ctx.measureText("W");
              return this._validateAndSet(e3.width, e3.fontBoundingBoxAscent + e3.fontBoundingBoxDescent), this._result;
            }
          }
        },
        4269: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CharacterJoinerService = t3.JoinedCellData = void 0;
          const n = i3(3734), o = i3(643), a = i3(511), h = i3(2585);
          class c extends n.AttributeData {
            constructor(e3, t4, i4) {
              super(), this.content = 0, this.combinedData = "", this.fg = e3.fg, this.bg = e3.bg, this.combinedData = t4, this._width = i4;
            }
            isCombined() {
              return 2097152;
            }
            getWidth() {
              return this._width;
            }
            getChars() {
              return this.combinedData;
            }
            getCode() {
              return 2097151;
            }
            setFromCharData(e3) {
              throw new Error("not implemented");
            }
            getAsCharData() {
              return [
                this.fg,
                this.getChars(),
                this.getWidth(),
                this.getCode()
              ];
            }
          }
          t3.JoinedCellData = c;
          let l = t3.CharacterJoinerService = class e3 {
            constructor(e4) {
              this._bufferService = e4, this._characterJoiners = [], this._nextCharacterJoinerId = 0, this._workCell = new a.CellData();
            }
            register(e4) {
              const t4 = {
                id: this._nextCharacterJoinerId++,
                handler: e4
              };
              return this._characterJoiners.push(t4), t4.id;
            }
            deregister(e4) {
              for (let t4 = 0; t4 < this._characterJoiners.length; t4++) if (this._characterJoiners[t4].id === e4) return this._characterJoiners.splice(t4, 1), true;
              return false;
            }
            getJoinedCharacters(e4) {
              if (0 === this._characterJoiners.length) return [];
              const t4 = this._bufferService.buffer.lines.get(e4);
              if (!t4 || 0 === t4.length) return [];
              const i4 = [], s3 = t4.translateToString(true);
              let r2 = 0, n2 = 0, a2 = 0, h2 = t4.getFg(0), c2 = t4.getBg(0);
              for (let e5 = 0; e5 < t4.getTrimmedLength(); e5++) if (t4.loadCell(e5, this._workCell), 0 !== this._workCell.getWidth()) {
                if (this._workCell.fg !== h2 || this._workCell.bg !== c2) {
                  if (e5 - r2 > 1) {
                    const e6 = this._getJoinedRanges(s3, a2, n2, t4, r2);
                    for (let t5 = 0; t5 < e6.length; t5++) i4.push(e6[t5]);
                  }
                  r2 = e5, a2 = n2, h2 = this._workCell.fg, c2 = this._workCell.bg;
                }
                n2 += this._workCell.getChars().length || o.WHITESPACE_CELL_CHAR.length;
              }
              if (this._bufferService.cols - r2 > 1) {
                const e5 = this._getJoinedRanges(s3, a2, n2, t4, r2);
                for (let t5 = 0; t5 < e5.length; t5++) i4.push(e5[t5]);
              }
              return i4;
            }
            _getJoinedRanges(t4, i4, s3, r2, n2) {
              const o2 = t4.substring(i4, s3);
              let a2 = [];
              try {
                a2 = this._characterJoiners[0].handler(o2);
              } catch (e4) {
                console.error(e4);
              }
              for (let t5 = 1; t5 < this._characterJoiners.length; t5++) try {
                const i5 = this._characterJoiners[t5].handler(o2);
                for (let t6 = 0; t6 < i5.length; t6++) e3._mergeRanges(a2, i5[t6]);
              } catch (e4) {
                console.error(e4);
              }
              return this._stringRangesToCellRanges(a2, r2, n2), a2;
            }
            _stringRangesToCellRanges(e4, t4, i4) {
              let s3 = 0, r2 = false, n2 = 0, a2 = e4[s3];
              if (a2) {
                for (let h2 = i4; h2 < this._bufferService.cols; h2++) {
                  const i5 = t4.getWidth(h2), c2 = t4.getString(h2).length || o.WHITESPACE_CELL_CHAR.length;
                  if (0 !== i5) {
                    if (!r2 && a2[0] <= n2 && (a2[0] = h2, r2 = true), a2[1] <= n2) {
                      if (a2[1] = h2, a2 = e4[++s3], !a2) break;
                      a2[0] <= n2 ? (a2[0] = h2, r2 = true) : r2 = false;
                    }
                    n2 += c2;
                  }
                }
                a2 && (a2[1] = this._bufferService.cols);
              }
            }
            static _mergeRanges(e4, t4) {
              let i4 = false;
              for (let s3 = 0; s3 < e4.length; s3++) {
                const r2 = e4[s3];
                if (i4) {
                  if (t4[1] <= r2[0]) return e4[s3 - 1][1] = t4[1], e4;
                  if (t4[1] <= r2[1]) return e4[s3 - 1][1] = Math.max(t4[1], r2[1]), e4.splice(s3, 1), e4;
                  e4.splice(s3, 1), s3--;
                } else {
                  if (t4[1] <= r2[0]) return e4.splice(s3, 0, t4), e4;
                  if (t4[1] <= r2[1]) return r2[0] = Math.min(t4[0], r2[0]), e4;
                  t4[0] < r2[1] && (r2[0] = Math.min(t4[0], r2[0]), i4 = true);
                }
              }
              return i4 ? e4[e4.length - 1][1] = t4[1] : e4.push(t4), e4;
            }
          };
          t3.CharacterJoinerService = l = s2([
            r(0, h.IBufferService)
          ], l);
        },
        5114: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CoreBrowserService = void 0;
          const s2 = i3(844), r = i3(8460), n = i3(3656);
          class o extends s2.Disposable {
            constructor(e3, t4, i4) {
              super(), this._textarea = e3, this._window = t4, this.mainDocument = i4, this._isFocused = false, this._cachedIsFocused = void 0, this._screenDprMonitor = new a(this._window), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._onWindowChange = this.register(new r.EventEmitter()), this.onWindowChange = this._onWindowChange.event, this.register(this.onWindowChange((e4) => this._screenDprMonitor.setWindow(e4))), this.register((0, r.forwardEvent)(this._screenDprMonitor.onDprChange, this._onDprChange)), this._textarea.addEventListener("focus", () => this._isFocused = true), this._textarea.addEventListener("blur", () => this._isFocused = false);
            }
            get window() {
              return this._window;
            }
            set window(e3) {
              this._window !== e3 && (this._window = e3, this._onWindowChange.fire(this._window));
            }
            get dpr() {
              return this.window.devicePixelRatio;
            }
            get isFocused() {
              return void 0 === this._cachedIsFocused && (this._cachedIsFocused = this._isFocused && this._textarea.ownerDocument.hasFocus(), queueMicrotask(() => this._cachedIsFocused = void 0)), this._cachedIsFocused;
            }
          }
          t3.CoreBrowserService = o;
          class a extends s2.Disposable {
            constructor(e3) {
              super(), this._parentWindow = e3, this._windowResizeListener = this.register(new s2.MutableDisposable()), this._onDprChange = this.register(new r.EventEmitter()), this.onDprChange = this._onDprChange.event, this._outerListener = () => this._setDprAndFireIfDiffers(), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._updateDpr(), this._setWindowResizeListener(), this.register((0, s2.toDisposable)(() => this.clearListener()));
            }
            setWindow(e3) {
              this._parentWindow = e3, this._setWindowResizeListener(), this._setDprAndFireIfDiffers();
            }
            _setWindowResizeListener() {
              this._windowResizeListener.value = (0, n.addDisposableDomListener)(this._parentWindow, "resize", () => this._setDprAndFireIfDiffers());
            }
            _setDprAndFireIfDiffers() {
              this._parentWindow.devicePixelRatio !== this._currentDevicePixelRatio && this._onDprChange.fire(this._parentWindow.devicePixelRatio), this._updateDpr();
            }
            _updateDpr() {
              var _a3;
              this._outerListener && ((_a3 = this._resolutionMediaMatchList) == null ? void 0 : _a3.removeListener(this._outerListener), this._currentDevicePixelRatio = this._parentWindow.devicePixelRatio, this._resolutionMediaMatchList = this._parentWindow.matchMedia(`screen and (resolution: ${this._parentWindow.devicePixelRatio}dppx)`), this._resolutionMediaMatchList.addListener(this._outerListener));
            }
            clearListener() {
              this._resolutionMediaMatchList && this._outerListener && (this._resolutionMediaMatchList.removeListener(this._outerListener), this._resolutionMediaMatchList = void 0, this._outerListener = void 0);
            }
          }
        },
        779: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.LinkProviderService = void 0;
          const s2 = i3(844);
          class r extends s2.Disposable {
            constructor() {
              super(), this.linkProviders = [], this.register((0, s2.toDisposable)(() => this.linkProviders.length = 0));
            }
            registerLinkProvider(e3) {
              return this.linkProviders.push(e3), {
                dispose: () => {
                  const t4 = this.linkProviders.indexOf(e3);
                  -1 !== t4 && this.linkProviders.splice(t4, 1);
                }
              };
            }
          }
          t3.LinkProviderService = r;
        },
        8934: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.MouseService = void 0;
          const n = i3(4725), o = i3(9806);
          let a = t3.MouseService = class {
            constructor(e3, t4) {
              this._renderService = e3, this._charSizeService = t4;
            }
            getCoords(e3, t4, i4, s3, r2) {
              return (0, o.getCoords)(window, e3, t4, i4, s3, this._charSizeService.hasValidSize, this._renderService.dimensions.css.cell.width, this._renderService.dimensions.css.cell.height, r2);
            }
            getMouseReportCoords(e3, t4) {
              const i4 = (0, o.getCoordsRelativeToElement)(window, e3, t4);
              if (this._charSizeService.hasValidSize) return i4[0] = Math.min(Math.max(i4[0], 0), this._renderService.dimensions.css.canvas.width - 1), i4[1] = Math.min(Math.max(i4[1], 0), this._renderService.dimensions.css.canvas.height - 1), {
                col: Math.floor(i4[0] / this._renderService.dimensions.css.cell.width),
                row: Math.floor(i4[1] / this._renderService.dimensions.css.cell.height),
                x: Math.floor(i4[0]),
                y: Math.floor(i4[1])
              };
            }
          };
          t3.MouseService = a = s2([
            r(0, n.IRenderService),
            r(1, n.ICharSizeService)
          ], a);
        },
        3230: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.RenderService = void 0;
          const n = i3(6193), o = i3(4725), a = i3(8460), h = i3(844), c = i3(7226), l = i3(2585);
          let d = t3.RenderService = class extends h.Disposable {
            get dimensions() {
              return this._renderer.value.dimensions;
            }
            constructor(e3, t4, i4, s3, r2, o2, l2, d2) {
              super(), this._rowCount = e3, this._charSizeService = s3, this._renderer = this.register(new h.MutableDisposable()), this._pausedResizeTask = new c.DebouncedIdleTask(), this._observerDisposable = this.register(new h.MutableDisposable()), this._isPaused = false, this._needsFullRefresh = false, this._isNextRenderRedrawOnly = true, this._needsSelectionRefresh = false, this._canvasWidth = 0, this._canvasHeight = 0, this._selectionState = {
                start: void 0,
                end: void 0,
                columnSelectMode: false
              }, this._onDimensionsChange = this.register(new a.EventEmitter()), this.onDimensionsChange = this._onDimensionsChange.event, this._onRenderedViewportChange = this.register(new a.EventEmitter()), this.onRenderedViewportChange = this._onRenderedViewportChange.event, this._onRender = this.register(new a.EventEmitter()), this.onRender = this._onRender.event, this._onRefreshRequest = this.register(new a.EventEmitter()), this.onRefreshRequest = this._onRefreshRequest.event, this._renderDebouncer = new n.RenderDebouncer((e4, t5) => this._renderRows(e4, t5), l2), this.register(this._renderDebouncer), this.register(l2.onDprChange(() => this.handleDevicePixelRatioChange())), this.register(o2.onResize(() => this._fullRefresh())), this.register(o2.buffers.onBufferActivate(() => {
                var _a2;
                return (_a2 = this._renderer.value) == null ? void 0 : _a2.clear();
              })), this.register(i4.onOptionChange(() => this._handleOptionsChanged())), this.register(this._charSizeService.onCharSizeChange(() => this.handleCharSizeChanged())), this.register(r2.onDecorationRegistered(() => this._fullRefresh())), this.register(r2.onDecorationRemoved(() => this._fullRefresh())), this.register(i4.onMultipleOptionChange([
                "customGlyphs",
                "drawBoldTextInBrightColors",
                "letterSpacing",
                "lineHeight",
                "fontFamily",
                "fontSize",
                "fontWeight",
                "fontWeightBold",
                "minimumContrastRatio",
                "rescaleOverlappingGlyphs"
              ], () => {
                this.clear(), this.handleResize(o2.cols, o2.rows), this._fullRefresh();
              })), this.register(i4.onMultipleOptionChange([
                "cursorBlink",
                "cursorStyle"
              ], () => this.refreshRows(o2.buffer.y, o2.buffer.y, true))), this.register(d2.onChangeColors(() => this._fullRefresh())), this._registerIntersectionObserver(l2.window, t4), this.register(l2.onWindowChange((e4) => this._registerIntersectionObserver(e4, t4)));
            }
            _registerIntersectionObserver(e3, t4) {
              if ("IntersectionObserver" in e3) {
                const i4 = new e3.IntersectionObserver((e4) => this._handleIntersectionChange(e4[e4.length - 1]), {
                  threshold: 0
                });
                i4.observe(t4), this._observerDisposable.value = (0, h.toDisposable)(() => i4.disconnect());
              }
            }
            _handleIntersectionChange(e3) {
              this._isPaused = void 0 === e3.isIntersecting ? 0 === e3.intersectionRatio : !e3.isIntersecting, this._isPaused || this._charSizeService.hasValidSize || this._charSizeService.measure(), !this._isPaused && this._needsFullRefresh && (this._pausedResizeTask.flush(), this.refreshRows(0, this._rowCount - 1), this._needsFullRefresh = false);
            }
            refreshRows(e3, t4, i4 = false) {
              this._isPaused ? this._needsFullRefresh = true : (i4 || (this._isNextRenderRedrawOnly = false), this._renderDebouncer.refresh(e3, t4, this._rowCount));
            }
            _renderRows(e3, t4) {
              this._renderer.value && (e3 = Math.min(e3, this._rowCount - 1), t4 = Math.min(t4, this._rowCount - 1), this._renderer.value.renderRows(e3, t4), this._needsSelectionRefresh && (this._renderer.value.handleSelectionChanged(this._selectionState.start, this._selectionState.end, this._selectionState.columnSelectMode), this._needsSelectionRefresh = false), this._isNextRenderRedrawOnly || this._onRenderedViewportChange.fire({
                start: e3,
                end: t4
              }), this._onRender.fire({
                start: e3,
                end: t4
              }), this._isNextRenderRedrawOnly = true);
            }
            resize(e3, t4) {
              this._rowCount = t4, this._fireOnCanvasResize();
            }
            _handleOptionsChanged() {
              this._renderer.value && (this.refreshRows(0, this._rowCount - 1), this._fireOnCanvasResize());
            }
            _fireOnCanvasResize() {
              this._renderer.value && (this._renderer.value.dimensions.css.canvas.width === this._canvasWidth && this._renderer.value.dimensions.css.canvas.height === this._canvasHeight || this._onDimensionsChange.fire(this._renderer.value.dimensions));
            }
            hasRenderer() {
              return !!this._renderer.value;
            }
            setRenderer(e3) {
              this._renderer.value = e3, this._renderer.value && (this._renderer.value.onRequestRedraw((e4) => this.refreshRows(e4.start, e4.end, true)), this._needsSelectionRefresh = true, this._fullRefresh());
            }
            addRefreshCallback(e3) {
              return this._renderDebouncer.addRefreshCallback(e3);
            }
            _fullRefresh() {
              this._isPaused ? this._needsFullRefresh = true : this.refreshRows(0, this._rowCount - 1);
            }
            clearTextureAtlas() {
              var _a2, _b;
              this._renderer.value && ((_b = (_a2 = this._renderer.value).clearTextureAtlas) == null ? void 0 : _b.call(_a2), this._fullRefresh());
            }
            handleDevicePixelRatioChange() {
              this._charSizeService.measure(), this._renderer.value && (this._renderer.value.handleDevicePixelRatioChange(), this.refreshRows(0, this._rowCount - 1));
            }
            handleResize(e3, t4) {
              this._renderer.value && (this._isPaused ? this._pausedResizeTask.set(() => {
                var _a2;
                return (_a2 = this._renderer.value) == null ? void 0 : _a2.handleResize(e3, t4);
              }) : this._renderer.value.handleResize(e3, t4), this._fullRefresh());
            }
            handleCharSizeChanged() {
              var _a2;
              (_a2 = this._renderer.value) == null ? void 0 : _a2.handleCharSizeChanged();
            }
            handleBlur() {
              var _a2;
              (_a2 = this._renderer.value) == null ? void 0 : _a2.handleBlur();
            }
            handleFocus() {
              var _a2;
              (_a2 = this._renderer.value) == null ? void 0 : _a2.handleFocus();
            }
            handleSelectionChanged(e3, t4, i4) {
              var _a2;
              this._selectionState.start = e3, this._selectionState.end = t4, this._selectionState.columnSelectMode = i4, (_a2 = this._renderer.value) == null ? void 0 : _a2.handleSelectionChanged(e3, t4, i4);
            }
            handleCursorMove() {
              var _a2;
              (_a2 = this._renderer.value) == null ? void 0 : _a2.handleCursorMove();
            }
            clear() {
              var _a2;
              (_a2 = this._renderer.value) == null ? void 0 : _a2.clear();
            }
          };
          t3.RenderService = d = s2([
            r(2, l.IOptionsService),
            r(3, o.ICharSizeService),
            r(4, l.IDecorationService),
            r(5, l.IBufferService),
            r(6, o.ICoreBrowserService),
            r(7, o.IThemeService)
          ], d);
        },
        9312: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.SelectionService = void 0;
          const n = i3(9806), o = i3(9504), a = i3(456), h = i3(4725), c = i3(8460), l = i3(844), d = i3(6114), _ = i3(4841), u = i3(511), f = i3(2585), v = String.fromCharCode(160), p = new RegExp(v, "g");
          let g = t3.SelectionService = class extends l.Disposable {
            constructor(e3, t4, i4, s3, r2, n2, o2, h2, d2) {
              super(), this._element = e3, this._screenElement = t4, this._linkifier = i4, this._bufferService = s3, this._coreService = r2, this._mouseService = n2, this._optionsService = o2, this._renderService = h2, this._coreBrowserService = d2, this._dragScrollAmount = 0, this._enabled = true, this._workCell = new u.CellData(), this._mouseDownTimeStamp = 0, this._oldHasSelection = false, this._oldSelectionStart = void 0, this._oldSelectionEnd = void 0, this._onLinuxMouseSelection = this.register(new c.EventEmitter()), this.onLinuxMouseSelection = this._onLinuxMouseSelection.event, this._onRedrawRequest = this.register(new c.EventEmitter()), this.onRequestRedraw = this._onRedrawRequest.event, this._onSelectionChange = this.register(new c.EventEmitter()), this.onSelectionChange = this._onSelectionChange.event, this._onRequestScrollLines = this.register(new c.EventEmitter()), this.onRequestScrollLines = this._onRequestScrollLines.event, this._mouseMoveListener = (e4) => this._handleMouseMove(e4), this._mouseUpListener = (e4) => this._handleMouseUp(e4), this._coreService.onUserInput(() => {
                this.hasSelection && this.clearSelection();
              }), this._trimListener = this._bufferService.buffer.lines.onTrim((e4) => this._handleTrim(e4)), this.register(this._bufferService.buffers.onBufferActivate((e4) => this._handleBufferActivate(e4))), this.enable(), this._model = new a.SelectionModel(this._bufferService), this._activeSelectionMode = 0, this.register((0, l.toDisposable)(() => {
                this._removeMouseDownListeners();
              }));
            }
            reset() {
              this.clearSelection();
            }
            disable() {
              this.clearSelection(), this._enabled = false;
            }
            enable() {
              this._enabled = true;
            }
            get selectionStart() {
              return this._model.finalSelectionStart;
            }
            get selectionEnd() {
              return this._model.finalSelectionEnd;
            }
            get hasSelection() {
              const e3 = this._model.finalSelectionStart, t4 = this._model.finalSelectionEnd;
              return !(!e3 || !t4 || e3[0] === t4[0] && e3[1] === t4[1]);
            }
            get selectionText() {
              const e3 = this._model.finalSelectionStart, t4 = this._model.finalSelectionEnd;
              if (!e3 || !t4) return "";
              const i4 = this._bufferService.buffer, s3 = [];
              if (3 === this._activeSelectionMode) {
                if (e3[0] === t4[0]) return "";
                const r2 = e3[0] < t4[0] ? e3[0] : t4[0], n2 = e3[0] < t4[0] ? t4[0] : e3[0];
                for (let o2 = e3[1]; o2 <= t4[1]; o2++) {
                  const e4 = i4.translateBufferLineToString(o2, true, r2, n2);
                  s3.push(e4);
                }
              } else {
                const r2 = e3[1] === t4[1] ? t4[0] : void 0;
                s3.push(i4.translateBufferLineToString(e3[1], true, e3[0], r2));
                for (let r3 = e3[1] + 1; r3 <= t4[1] - 1; r3++) {
                  const e4 = i4.lines.get(r3), t5 = i4.translateBufferLineToString(r3, true);
                  (e4 == null ? void 0 : e4.isWrapped) ? s3[s3.length - 1] += t5 : s3.push(t5);
                }
                if (e3[1] !== t4[1]) {
                  const e4 = i4.lines.get(t4[1]), r3 = i4.translateBufferLineToString(t4[1], true, 0, t4[0]);
                  e4 && e4.isWrapped ? s3[s3.length - 1] += r3 : s3.push(r3);
                }
              }
              return s3.map((e4) => e4.replace(p, " ")).join(d.isWindows ? "\r\n" : "\n");
            }
            clearSelection() {
              this._model.clearSelection(), this._removeMouseDownListeners(), this.refresh(), this._onSelectionChange.fire();
            }
            refresh(e3) {
              this._refreshAnimationFrame || (this._refreshAnimationFrame = this._coreBrowserService.window.requestAnimationFrame(() => this._refresh())), d.isLinux && e3 && this.selectionText.length && this._onLinuxMouseSelection.fire(this.selectionText);
            }
            _refresh() {
              this._refreshAnimationFrame = void 0, this._onRedrawRequest.fire({
                start: this._model.finalSelectionStart,
                end: this._model.finalSelectionEnd,
                columnSelectMode: 3 === this._activeSelectionMode
              });
            }
            _isClickInSelection(e3) {
              const t4 = this._getMouseBufferCoords(e3), i4 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
              return !!(i4 && s3 && t4) && this._areCoordsInSelection(t4, i4, s3);
            }
            isCellInSelection(e3, t4) {
              const i4 = this._model.finalSelectionStart, s3 = this._model.finalSelectionEnd;
              return !(!i4 || !s3) && this._areCoordsInSelection([
                e3,
                t4
              ], i4, s3);
            }
            _areCoordsInSelection(e3, t4, i4) {
              return e3[1] > t4[1] && e3[1] < i4[1] || t4[1] === i4[1] && e3[1] === t4[1] && e3[0] >= t4[0] && e3[0] < i4[0] || t4[1] < i4[1] && e3[1] === i4[1] && e3[0] < i4[0] || t4[1] < i4[1] && e3[1] === t4[1] && e3[0] >= t4[0];
            }
            _selectWordAtCursor(e3, t4) {
              var _a2, _b;
              const i4 = (_b = (_a2 = this._linkifier.currentLink) == null ? void 0 : _a2.link) == null ? void 0 : _b.range;
              if (i4) return this._model.selectionStart = [
                i4.start.x - 1,
                i4.start.y - 1
              ], this._model.selectionStartLength = (0, _.getRangeLength)(i4, this._bufferService.cols), this._model.selectionEnd = void 0, true;
              const s3 = this._getMouseBufferCoords(e3);
              return !!s3 && (this._selectWordAt(s3, t4), this._model.selectionEnd = void 0, true);
            }
            selectAll() {
              this._model.isSelectAllActive = true, this.refresh(), this._onSelectionChange.fire();
            }
            selectLines(e3, t4) {
              this._model.clearSelection(), e3 = Math.max(e3, 0), t4 = Math.min(t4, this._bufferService.buffer.lines.length - 1), this._model.selectionStart = [
                0,
                e3
              ], this._model.selectionEnd = [
                this._bufferService.cols,
                t4
              ], this.refresh(), this._onSelectionChange.fire();
            }
            _handleTrim(e3) {
              this._model.handleTrim(e3) && this.refresh();
            }
            _getMouseBufferCoords(e3) {
              const t4 = this._mouseService.getCoords(e3, this._screenElement, this._bufferService.cols, this._bufferService.rows, true);
              if (t4) return t4[0]--, t4[1]--, t4[1] += this._bufferService.buffer.ydisp, t4;
            }
            _getMouseEventScrollAmount(e3) {
              let t4 = (0, n.getCoordsRelativeToElement)(this._coreBrowserService.window, e3, this._screenElement)[1];
              const i4 = this._renderService.dimensions.css.canvas.height;
              return t4 >= 0 && t4 <= i4 ? 0 : (t4 > i4 && (t4 -= i4), t4 = Math.min(Math.max(t4, -50), 50), t4 /= 50, t4 / Math.abs(t4) + Math.round(14 * t4));
            }
            shouldForceSelection(e3) {
              return d.isMac ? e3.altKey && this._optionsService.rawOptions.macOptionClickForcesSelection : e3.shiftKey;
            }
            handleMouseDown(e3) {
              if (this._mouseDownTimeStamp = e3.timeStamp, (2 !== e3.button || !this.hasSelection) && 0 === e3.button) {
                if (!this._enabled) {
                  if (!this.shouldForceSelection(e3)) return;
                  e3.stopPropagation();
                }
                e3.preventDefault(), this._dragScrollAmount = 0, this._enabled && e3.shiftKey ? this._handleIncrementalClick(e3) : 1 === e3.detail ? this._handleSingleClick(e3) : 2 === e3.detail ? this._handleDoubleClick(e3) : 3 === e3.detail && this._handleTripleClick(e3), this._addMouseDownListeners(), this.refresh(true);
              }
            }
            _addMouseDownListeners() {
              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.addEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.addEventListener("mouseup", this._mouseUpListener)), this._dragScrollIntervalTimer = this._coreBrowserService.window.setInterval(() => this._dragScroll(), 50);
            }
            _removeMouseDownListeners() {
              this._screenElement.ownerDocument && (this._screenElement.ownerDocument.removeEventListener("mousemove", this._mouseMoveListener), this._screenElement.ownerDocument.removeEventListener("mouseup", this._mouseUpListener)), this._coreBrowserService.window.clearInterval(this._dragScrollIntervalTimer), this._dragScrollIntervalTimer = void 0;
            }
            _handleIncrementalClick(e3) {
              this._model.selectionStart && (this._model.selectionEnd = this._getMouseBufferCoords(e3));
            }
            _handleSingleClick(e3) {
              if (this._model.selectionStartLength = 0, this._model.isSelectAllActive = false, this._activeSelectionMode = this.shouldColumnSelect(e3) ? 3 : 0, this._model.selectionStart = this._getMouseBufferCoords(e3), !this._model.selectionStart) return;
              this._model.selectionEnd = void 0;
              const t4 = this._bufferService.buffer.lines.get(this._model.selectionStart[1]);
              t4 && t4.length !== this._model.selectionStart[0] && 0 === t4.hasWidth(this._model.selectionStart[0]) && this._model.selectionStart[0]++;
            }
            _handleDoubleClick(e3) {
              this._selectWordAtCursor(e3, true) && (this._activeSelectionMode = 1);
            }
            _handleTripleClick(e3) {
              const t4 = this._getMouseBufferCoords(e3);
              t4 && (this._activeSelectionMode = 2, this._selectLineAt(t4[1]));
            }
            shouldColumnSelect(e3) {
              return e3.altKey && !(d.isMac && this._optionsService.rawOptions.macOptionClickForcesSelection);
            }
            _handleMouseMove(e3) {
              if (e3.stopImmediatePropagation(), !this._model.selectionStart) return;
              const t4 = this._model.selectionEnd ? [
                this._model.selectionEnd[0],
                this._model.selectionEnd[1]
              ] : null;
              if (this._model.selectionEnd = this._getMouseBufferCoords(e3), !this._model.selectionEnd) return void this.refresh(true);
              2 === this._activeSelectionMode ? this._model.selectionEnd[1] < this._model.selectionStart[1] ? this._model.selectionEnd[0] = 0 : this._model.selectionEnd[0] = this._bufferService.cols : 1 === this._activeSelectionMode && this._selectToWordAt(this._model.selectionEnd), this._dragScrollAmount = this._getMouseEventScrollAmount(e3), 3 !== this._activeSelectionMode && (this._dragScrollAmount > 0 ? this._model.selectionEnd[0] = this._bufferService.cols : this._dragScrollAmount < 0 && (this._model.selectionEnd[0] = 0));
              const i4 = this._bufferService.buffer;
              if (this._model.selectionEnd[1] < i4.lines.length) {
                const e4 = i4.lines.get(this._model.selectionEnd[1]);
                e4 && 0 === e4.hasWidth(this._model.selectionEnd[0]) && this._model.selectionEnd[0] < this._bufferService.cols && this._model.selectionEnd[0]++;
              }
              t4 && t4[0] === this._model.selectionEnd[0] && t4[1] === this._model.selectionEnd[1] || this.refresh(true);
            }
            _dragScroll() {
              if (this._model.selectionEnd && this._model.selectionStart && this._dragScrollAmount) {
                this._onRequestScrollLines.fire({
                  amount: this._dragScrollAmount,
                  suppressScrollEvent: false
                });
                const e3 = this._bufferService.buffer;
                this._dragScrollAmount > 0 ? (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = this._bufferService.cols), this._model.selectionEnd[1] = Math.min(e3.ydisp + this._bufferService.rows, e3.lines.length - 1)) : (3 !== this._activeSelectionMode && (this._model.selectionEnd[0] = 0), this._model.selectionEnd[1] = e3.ydisp), this.refresh();
              }
            }
            _handleMouseUp(e3) {
              const t4 = e3.timeStamp - this._mouseDownTimeStamp;
              if (this._removeMouseDownListeners(), this.selectionText.length <= 1 && t4 < 500 && e3.altKey && this._optionsService.rawOptions.altClickMovesCursor) {
                if (this._bufferService.buffer.ybase === this._bufferService.buffer.ydisp) {
                  const t5 = this._mouseService.getCoords(e3, this._element, this._bufferService.cols, this._bufferService.rows, false);
                  if (t5 && void 0 !== t5[0] && void 0 !== t5[1]) {
                    const e4 = (0, o.moveToCellSequence)(t5[0] - 1, t5[1] - 1, this._bufferService, this._coreService.decPrivateModes.applicationCursorKeys);
                    this._coreService.triggerDataEvent(e4, true);
                  }
                }
              } else this._fireEventIfSelectionChanged();
            }
            _fireEventIfSelectionChanged() {
              const e3 = this._model.finalSelectionStart, t4 = this._model.finalSelectionEnd, i4 = !(!e3 || !t4 || e3[0] === t4[0] && e3[1] === t4[1]);
              i4 ? e3 && t4 && (this._oldSelectionStart && this._oldSelectionEnd && e3[0] === this._oldSelectionStart[0] && e3[1] === this._oldSelectionStart[1] && t4[0] === this._oldSelectionEnd[0] && t4[1] === this._oldSelectionEnd[1] || this._fireOnSelectionChange(e3, t4, i4)) : this._oldHasSelection && this._fireOnSelectionChange(e3, t4, i4);
            }
            _fireOnSelectionChange(e3, t4, i4) {
              this._oldSelectionStart = e3, this._oldSelectionEnd = t4, this._oldHasSelection = i4, this._onSelectionChange.fire();
            }
            _handleBufferActivate(e3) {
              this.clearSelection(), this._trimListener.dispose(), this._trimListener = e3.activeBuffer.lines.onTrim((e4) => this._handleTrim(e4));
            }
            _convertViewportColToCharacterIndex(e3, t4) {
              let i4 = t4;
              for (let s3 = 0; t4 >= s3; s3++) {
                const r2 = e3.loadCell(s3, this._workCell).getChars().length;
                0 === this._workCell.getWidth() ? i4-- : r2 > 1 && t4 !== s3 && (i4 += r2 - 1);
              }
              return i4;
            }
            setSelection(e3, t4, i4) {
              this._model.clearSelection(), this._removeMouseDownListeners(), this._model.selectionStart = [
                e3,
                t4
              ], this._model.selectionStartLength = i4, this.refresh(), this._fireEventIfSelectionChanged();
            }
            rightClickSelect(e3) {
              this._isClickInSelection(e3) || (this._selectWordAtCursor(e3, false) && this.refresh(true), this._fireEventIfSelectionChanged());
            }
            _getWordAt(e3, t4, i4 = true, s3 = true) {
              if (e3[0] >= this._bufferService.cols) return;
              const r2 = this._bufferService.buffer, n2 = r2.lines.get(e3[1]);
              if (!n2) return;
              const o2 = r2.translateBufferLineToString(e3[1], false);
              let a2 = this._convertViewportColToCharacterIndex(n2, e3[0]), h2 = a2;
              const c2 = e3[0] - a2;
              let l2 = 0, d2 = 0, _2 = 0, u2 = 0;
              if (" " === o2.charAt(a2)) {
                for (; a2 > 0 && " " === o2.charAt(a2 - 1); ) a2--;
                for (; h2 < o2.length && " " === o2.charAt(h2 + 1); ) h2++;
              } else {
                let t5 = e3[0], i5 = e3[0];
                0 === n2.getWidth(t5) && (l2++, t5--), 2 === n2.getWidth(i5) && (d2++, i5++);
                const s4 = n2.getString(i5).length;
                for (s4 > 1 && (u2 += s4 - 1, h2 += s4 - 1); t5 > 0 && a2 > 0 && !this._isCharWordSeparator(n2.loadCell(t5 - 1, this._workCell)); ) {
                  n2.loadCell(t5 - 1, this._workCell);
                  const e4 = this._workCell.getChars().length;
                  0 === this._workCell.getWidth() ? (l2++, t5--) : e4 > 1 && (_2 += e4 - 1, a2 -= e4 - 1), a2--, t5--;
                }
                for (; i5 < n2.length && h2 + 1 < o2.length && !this._isCharWordSeparator(n2.loadCell(i5 + 1, this._workCell)); ) {
                  n2.loadCell(i5 + 1, this._workCell);
                  const e4 = this._workCell.getChars().length;
                  2 === this._workCell.getWidth() ? (d2++, i5++) : e4 > 1 && (u2 += e4 - 1, h2 += e4 - 1), h2++, i5++;
                }
              }
              h2++;
              let f2 = a2 + c2 - l2 + _2, v2 = Math.min(this._bufferService.cols, h2 - a2 + l2 + d2 - _2 - u2);
              if (t4 || "" !== o2.slice(a2, h2).trim()) {
                if (i4 && 0 === f2 && 32 !== n2.getCodePoint(0)) {
                  const t5 = r2.lines.get(e3[1] - 1);
                  if (t5 && n2.isWrapped && 32 !== t5.getCodePoint(this._bufferService.cols - 1)) {
                    const t6 = this._getWordAt([
                      this._bufferService.cols - 1,
                      e3[1] - 1
                    ], false, true, false);
                    if (t6) {
                      const e4 = this._bufferService.cols - t6.start;
                      f2 -= e4, v2 += e4;
                    }
                  }
                }
                if (s3 && f2 + v2 === this._bufferService.cols && 32 !== n2.getCodePoint(this._bufferService.cols - 1)) {
                  const t5 = r2.lines.get(e3[1] + 1);
                  if ((t5 == null ? void 0 : t5.isWrapped) && 32 !== t5.getCodePoint(0)) {
                    const t6 = this._getWordAt([
                      0,
                      e3[1] + 1
                    ], false, false, true);
                    t6 && (v2 += t6.length);
                  }
                }
                return {
                  start: f2,
                  length: v2
                };
              }
            }
            _selectWordAt(e3, t4) {
              const i4 = this._getWordAt(e3, t4);
              if (i4) {
                for (; i4.start < 0; ) i4.start += this._bufferService.cols, e3[1]--;
                this._model.selectionStart = [
                  i4.start,
                  e3[1]
                ], this._model.selectionStartLength = i4.length;
              }
            }
            _selectToWordAt(e3) {
              const t4 = this._getWordAt(e3, true);
              if (t4) {
                let i4 = e3[1];
                for (; t4.start < 0; ) t4.start += this._bufferService.cols, i4--;
                if (!this._model.areSelectionValuesReversed()) for (; t4.start + t4.length > this._bufferService.cols; ) t4.length -= this._bufferService.cols, i4++;
                this._model.selectionEnd = [
                  this._model.areSelectionValuesReversed() ? t4.start : t4.start + t4.length,
                  i4
                ];
              }
            }
            _isCharWordSeparator(e3) {
              return 0 !== e3.getWidth() && this._optionsService.rawOptions.wordSeparator.indexOf(e3.getChars()) >= 0;
            }
            _selectLineAt(e3) {
              const t4 = this._bufferService.buffer.getWrappedRangeForLine(e3), i4 = {
                start: {
                  x: 0,
                  y: t4.first
                },
                end: {
                  x: this._bufferService.cols - 1,
                  y: t4.last
                }
              };
              this._model.selectionStart = [
                0,
                t4.first
              ], this._model.selectionEnd = void 0, this._model.selectionStartLength = (0, _.getRangeLength)(i4, this._bufferService.cols);
            }
          };
          t3.SelectionService = g = s2([
            r(3, f.IBufferService),
            r(4, f.ICoreService),
            r(5, h.IMouseService),
            r(6, f.IOptionsService),
            r(7, h.IRenderService),
            r(8, h.ICoreBrowserService)
          ], g);
        },
        4725: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.ILinkProviderService = t3.IThemeService = t3.ICharacterJoinerService = t3.ISelectionService = t3.IRenderService = t3.IMouseService = t3.ICoreBrowserService = t3.ICharSizeService = void 0;
          const s2 = i3(8343);
          t3.ICharSizeService = (0, s2.createDecorator)("CharSizeService"), t3.ICoreBrowserService = (0, s2.createDecorator)("CoreBrowserService"), t3.IMouseService = (0, s2.createDecorator)("MouseService"), t3.IRenderService = (0, s2.createDecorator)("RenderService"), t3.ISelectionService = (0, s2.createDecorator)("SelectionService"), t3.ICharacterJoinerService = (0, s2.createDecorator)("CharacterJoinerService"), t3.IThemeService = (0, s2.createDecorator)("ThemeService"), t3.ILinkProviderService = (0, s2.createDecorator)("LinkProviderService");
        },
        6731: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.ThemeService = t3.DEFAULT_ANSI_COLORS = void 0;
          const n = i3(7239), o = i3(8055), a = i3(8460), h = i3(844), c = i3(2585), l = o.css.toColor("#ffffff"), d = o.css.toColor("#000000"), _ = o.css.toColor("#ffffff"), u = o.css.toColor("#000000"), f = {
            css: "rgba(255, 255, 255, 0.3)",
            rgba: 4294967117
          };
          t3.DEFAULT_ANSI_COLORS = Object.freeze((() => {
            const e3 = [
              o.css.toColor("#2e3436"),
              o.css.toColor("#cc0000"),
              o.css.toColor("#4e9a06"),
              o.css.toColor("#c4a000"),
              o.css.toColor("#3465a4"),
              o.css.toColor("#75507b"),
              o.css.toColor("#06989a"),
              o.css.toColor("#d3d7cf"),
              o.css.toColor("#555753"),
              o.css.toColor("#ef2929"),
              o.css.toColor("#8ae234"),
              o.css.toColor("#fce94f"),
              o.css.toColor("#729fcf"),
              o.css.toColor("#ad7fa8"),
              o.css.toColor("#34e2e2"),
              o.css.toColor("#eeeeec")
            ], t4 = [
              0,
              95,
              135,
              175,
              215,
              255
            ];
            for (let i4 = 0; i4 < 216; i4++) {
              const s3 = t4[i4 / 36 % 6 | 0], r2 = t4[i4 / 6 % 6 | 0], n2 = t4[i4 % 6];
              e3.push({
                css: o.channels.toCss(s3, r2, n2),
                rgba: o.channels.toRgba(s3, r2, n2)
              });
            }
            for (let t5 = 0; t5 < 24; t5++) {
              const i4 = 8 + 10 * t5;
              e3.push({
                css: o.channels.toCss(i4, i4, i4),
                rgba: o.channels.toRgba(i4, i4, i4)
              });
            }
            return e3;
          })());
          let v = t3.ThemeService = class extends h.Disposable {
            get colors() {
              return this._colors;
            }
            constructor(e3) {
              super(), this._optionsService = e3, this._contrastCache = new n.ColorContrastCache(), this._halfContrastCache = new n.ColorContrastCache(), this._onChangeColors = this.register(new a.EventEmitter()), this.onChangeColors = this._onChangeColors.event, this._colors = {
                foreground: l,
                background: d,
                cursor: _,
                cursorAccent: u,
                selectionForeground: void 0,
                selectionBackgroundTransparent: f,
                selectionBackgroundOpaque: o.color.blend(d, f),
                selectionInactiveBackgroundTransparent: f,
                selectionInactiveBackgroundOpaque: o.color.blend(d, f),
                ansi: t3.DEFAULT_ANSI_COLORS.slice(),
                contrastCache: this._contrastCache,
                halfContrastCache: this._halfContrastCache
              }, this._updateRestoreColors(), this._setTheme(this._optionsService.rawOptions.theme), this.register(this._optionsService.onSpecificOptionChange("minimumContrastRatio", () => this._contrastCache.clear())), this.register(this._optionsService.onSpecificOptionChange("theme", () => this._setTheme(this._optionsService.rawOptions.theme)));
            }
            _setTheme(e3 = {}) {
              const i4 = this._colors;
              if (i4.foreground = p(e3.foreground, l), i4.background = p(e3.background, d), i4.cursor = p(e3.cursor, _), i4.cursorAccent = p(e3.cursorAccent, u), i4.selectionBackgroundTransparent = p(e3.selectionBackground, f), i4.selectionBackgroundOpaque = o.color.blend(i4.background, i4.selectionBackgroundTransparent), i4.selectionInactiveBackgroundTransparent = p(e3.selectionInactiveBackground, i4.selectionBackgroundTransparent), i4.selectionInactiveBackgroundOpaque = o.color.blend(i4.background, i4.selectionInactiveBackgroundTransparent), i4.selectionForeground = e3.selectionForeground ? p(e3.selectionForeground, o.NULL_COLOR) : void 0, i4.selectionForeground === o.NULL_COLOR && (i4.selectionForeground = void 0), o.color.isOpaque(i4.selectionBackgroundTransparent)) {
                const e4 = 0.3;
                i4.selectionBackgroundTransparent = o.color.opacity(i4.selectionBackgroundTransparent, e4);
              }
              if (o.color.isOpaque(i4.selectionInactiveBackgroundTransparent)) {
                const e4 = 0.3;
                i4.selectionInactiveBackgroundTransparent = o.color.opacity(i4.selectionInactiveBackgroundTransparent, e4);
              }
              if (i4.ansi = t3.DEFAULT_ANSI_COLORS.slice(), i4.ansi[0] = p(e3.black, t3.DEFAULT_ANSI_COLORS[0]), i4.ansi[1] = p(e3.red, t3.DEFAULT_ANSI_COLORS[1]), i4.ansi[2] = p(e3.green, t3.DEFAULT_ANSI_COLORS[2]), i4.ansi[3] = p(e3.yellow, t3.DEFAULT_ANSI_COLORS[3]), i4.ansi[4] = p(e3.blue, t3.DEFAULT_ANSI_COLORS[4]), i4.ansi[5] = p(e3.magenta, t3.DEFAULT_ANSI_COLORS[5]), i4.ansi[6] = p(e3.cyan, t3.DEFAULT_ANSI_COLORS[6]), i4.ansi[7] = p(e3.white, t3.DEFAULT_ANSI_COLORS[7]), i4.ansi[8] = p(e3.brightBlack, t3.DEFAULT_ANSI_COLORS[8]), i4.ansi[9] = p(e3.brightRed, t3.DEFAULT_ANSI_COLORS[9]), i4.ansi[10] = p(e3.brightGreen, t3.DEFAULT_ANSI_COLORS[10]), i4.ansi[11] = p(e3.brightYellow, t3.DEFAULT_ANSI_COLORS[11]), i4.ansi[12] = p(e3.brightBlue, t3.DEFAULT_ANSI_COLORS[12]), i4.ansi[13] = p(e3.brightMagenta, t3.DEFAULT_ANSI_COLORS[13]), i4.ansi[14] = p(e3.brightCyan, t3.DEFAULT_ANSI_COLORS[14]), i4.ansi[15] = p(e3.brightWhite, t3.DEFAULT_ANSI_COLORS[15]), e3.extendedAnsi) {
                const s3 = Math.min(i4.ansi.length - 16, e3.extendedAnsi.length);
                for (let r2 = 0; r2 < s3; r2++) i4.ansi[r2 + 16] = p(e3.extendedAnsi[r2], t3.DEFAULT_ANSI_COLORS[r2 + 16]);
              }
              this._contrastCache.clear(), this._halfContrastCache.clear(), this._updateRestoreColors(), this._onChangeColors.fire(this.colors);
            }
            restoreColor(e3) {
              this._restoreColor(e3), this._onChangeColors.fire(this.colors);
            }
            _restoreColor(e3) {
              if (void 0 !== e3) switch (e3) {
                case 256:
                  this._colors.foreground = this._restoreColors.foreground;
                  break;
                case 257:
                  this._colors.background = this._restoreColors.background;
                  break;
                case 258:
                  this._colors.cursor = this._restoreColors.cursor;
                  break;
                default:
                  this._colors.ansi[e3] = this._restoreColors.ansi[e3];
              }
              else for (let e4 = 0; e4 < this._restoreColors.ansi.length; ++e4) this._colors.ansi[e4] = this._restoreColors.ansi[e4];
            }
            modifyColors(e3) {
              e3(this._colors), this._onChangeColors.fire(this.colors);
            }
            _updateRestoreColors() {
              this._restoreColors = {
                foreground: this._colors.foreground,
                background: this._colors.background,
                cursor: this._colors.cursor,
                ansi: this._colors.ansi.slice()
              };
            }
          };
          function p(e3, t4) {
            if (void 0 !== e3) try {
              return o.css.toColor(e3);
            } catch {
            }
            return t4;
          }
          t3.ThemeService = v = s2([
            r(0, c.IOptionsService)
          ], v);
        },
        6349: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CircularList = void 0;
          const s2 = i3(8460), r = i3(844);
          class n extends r.Disposable {
            constructor(e3) {
              super(), this._maxLength = e3, this.onDeleteEmitter = this.register(new s2.EventEmitter()), this.onDelete = this.onDeleteEmitter.event, this.onInsertEmitter = this.register(new s2.EventEmitter()), this.onInsert = this.onInsertEmitter.event, this.onTrimEmitter = this.register(new s2.EventEmitter()), this.onTrim = this.onTrimEmitter.event, this._array = new Array(this._maxLength), this._startIndex = 0, this._length = 0;
            }
            get maxLength() {
              return this._maxLength;
            }
            set maxLength(e3) {
              if (this._maxLength === e3) return;
              const t4 = new Array(e3);
              for (let i4 = 0; i4 < Math.min(e3, this.length); i4++) t4[i4] = this._array[this._getCyclicIndex(i4)];
              this._array = t4, this._maxLength = e3, this._startIndex = 0;
            }
            get length() {
              return this._length;
            }
            set length(e3) {
              if (e3 > this._length) for (let t4 = this._length; t4 < e3; t4++) this._array[t4] = void 0;
              this._length = e3;
            }
            get(e3) {
              return this._array[this._getCyclicIndex(e3)];
            }
            set(e3, t4) {
              this._array[this._getCyclicIndex(e3)] = t4;
            }
            push(e3) {
              this._array[this._getCyclicIndex(this._length)] = e3, this._length === this._maxLength ? (this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1)) : this._length++;
            }
            recycle() {
              if (this._length !== this._maxLength) throw new Error("Can only recycle when the buffer is full");
              return this._startIndex = ++this._startIndex % this._maxLength, this.onTrimEmitter.fire(1), this._array[this._getCyclicIndex(this._length - 1)];
            }
            get isFull() {
              return this._length === this._maxLength;
            }
            pop() {
              return this._array[this._getCyclicIndex(this._length-- - 1)];
            }
            splice(e3, t4, ...i4) {
              if (t4) {
                for (let i5 = e3; i5 < this._length - t4; i5++) this._array[this._getCyclicIndex(i5)] = this._array[this._getCyclicIndex(i5 + t4)];
                this._length -= t4, this.onDeleteEmitter.fire({
                  index: e3,
                  amount: t4
                });
              }
              for (let t5 = this._length - 1; t5 >= e3; t5--) this._array[this._getCyclicIndex(t5 + i4.length)] = this._array[this._getCyclicIndex(t5)];
              for (let t5 = 0; t5 < i4.length; t5++) this._array[this._getCyclicIndex(e3 + t5)] = i4[t5];
              if (i4.length && this.onInsertEmitter.fire({
                index: e3,
                amount: i4.length
              }), this._length + i4.length > this._maxLength) {
                const e4 = this._length + i4.length - this._maxLength;
                this._startIndex += e4, this._length = this._maxLength, this.onTrimEmitter.fire(e4);
              } else this._length += i4.length;
            }
            trimStart(e3) {
              e3 > this._length && (e3 = this._length), this._startIndex += e3, this._length -= e3, this.onTrimEmitter.fire(e3);
            }
            shiftElements(e3, t4, i4) {
              if (!(t4 <= 0)) {
                if (e3 < 0 || e3 >= this._length) throw new Error("start argument out of range");
                if (e3 + i4 < 0) throw new Error("Cannot shift elements in list beyond index 0");
                if (i4 > 0) {
                  for (let s4 = t4 - 1; s4 >= 0; s4--) this.set(e3 + s4 + i4, this.get(e3 + s4));
                  const s3 = e3 + t4 + i4 - this._length;
                  if (s3 > 0) for (this._length += s3; this._length > this._maxLength; ) this._length--, this._startIndex++, this.onTrimEmitter.fire(1);
                } else for (let s3 = 0; s3 < t4; s3++) this.set(e3 + s3 + i4, this.get(e3 + s3));
              }
            }
            _getCyclicIndex(e3) {
              return (this._startIndex + e3) % this._maxLength;
            }
          }
          t3.CircularList = n;
        },
        1439: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.clone = void 0, t3.clone = function e3(t4, i3 = 5) {
            if ("object" != typeof t4) return t4;
            const s2 = Array.isArray(t4) ? [] : {};
            for (const r in t4) s2[r] = i3 <= 1 ? t4[r] : t4[r] && e3(t4[r], i3 - 1);
            return s2;
          };
        },
        8055: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.contrastRatio = t3.toPaddedHex = t3.rgba = t3.rgb = t3.css = t3.color = t3.channels = t3.NULL_COLOR = void 0;
          let i3 = 0, s2 = 0, r = 0, n = 0;
          var o, a, h, c, l;
          function d(e3) {
            const t4 = e3.toString(16);
            return t4.length < 2 ? "0" + t4 : t4;
          }
          function _(e3, t4) {
            return e3 < t4 ? (t4 + 0.05) / (e3 + 0.05) : (e3 + 0.05) / (t4 + 0.05);
          }
          t3.NULL_COLOR = {
            css: "#00000000",
            rgba: 0
          }, function(e3) {
            e3.toCss = function(e4, t4, i4, s3) {
              return void 0 !== s3 ? `#${d(e4)}${d(t4)}${d(i4)}${d(s3)}` : `#${d(e4)}${d(t4)}${d(i4)}`;
            }, e3.toRgba = function(e4, t4, i4, s3 = 255) {
              return (e4 << 24 | t4 << 16 | i4 << 8 | s3) >>> 0;
            }, e3.toColor = function(t4, i4, s3, r2) {
              return {
                css: e3.toCss(t4, i4, s3, r2),
                rgba: e3.toRgba(t4, i4, s3, r2)
              };
            };
          }(o || (t3.channels = o = {})), function(e3) {
            function t4(e4, t5) {
              return n = Math.round(255 * t5), [i3, s2, r] = l.toChannels(e4.rgba), {
                css: o.toCss(i3, s2, r, n),
                rgba: o.toRgba(i3, s2, r, n)
              };
            }
            e3.blend = function(e4, t5) {
              if (n = (255 & t5.rgba) / 255, 1 === n) return {
                css: t5.css,
                rgba: t5.rgba
              };
              const a2 = t5.rgba >> 24 & 255, h2 = t5.rgba >> 16 & 255, c2 = t5.rgba >> 8 & 255, l2 = e4.rgba >> 24 & 255, d2 = e4.rgba >> 16 & 255, _2 = e4.rgba >> 8 & 255;
              return i3 = l2 + Math.round((a2 - l2) * n), s2 = d2 + Math.round((h2 - d2) * n), r = _2 + Math.round((c2 - _2) * n), {
                css: o.toCss(i3, s2, r),
                rgba: o.toRgba(i3, s2, r)
              };
            }, e3.isOpaque = function(e4) {
              return 255 == (255 & e4.rgba);
            }, e3.ensureContrastRatio = function(e4, t5, i4) {
              const s3 = l.ensureContrastRatio(e4.rgba, t5.rgba, i4);
              if (s3) return o.toColor(s3 >> 24 & 255, s3 >> 16 & 255, s3 >> 8 & 255);
            }, e3.opaque = function(e4) {
              const t5 = (255 | e4.rgba) >>> 0;
              return [i3, s2, r] = l.toChannels(t5), {
                css: o.toCss(i3, s2, r),
                rgba: t5
              };
            }, e3.opacity = t4, e3.multiplyOpacity = function(e4, i4) {
              return n = 255 & e4.rgba, t4(e4, n * i4 / 255);
            }, e3.toColorRGB = function(e4) {
              return [
                e4.rgba >> 24 & 255,
                e4.rgba >> 16 & 255,
                e4.rgba >> 8 & 255
              ];
            };
          }(a || (t3.color = a = {})), function(e3) {
            let t4, a2;
            try {
              const e4 = document.createElement("canvas");
              e4.width = 1, e4.height = 1;
              const i4 = e4.getContext("2d", {
                willReadFrequently: true
              });
              i4 && (t4 = i4, t4.globalCompositeOperation = "copy", a2 = t4.createLinearGradient(0, 0, 1, 1));
            } catch {
            }
            e3.toColor = function(e4) {
              if (e4.match(/#[\da-f]{3,8}/i)) switch (e4.length) {
                case 4:
                  return i3 = parseInt(e4.slice(1, 2).repeat(2), 16), s2 = parseInt(e4.slice(2, 3).repeat(2), 16), r = parseInt(e4.slice(3, 4).repeat(2), 16), o.toColor(i3, s2, r);
                case 5:
                  return i3 = parseInt(e4.slice(1, 2).repeat(2), 16), s2 = parseInt(e4.slice(2, 3).repeat(2), 16), r = parseInt(e4.slice(3, 4).repeat(2), 16), n = parseInt(e4.slice(4, 5).repeat(2), 16), o.toColor(i3, s2, r, n);
                case 7:
                  return {
                    css: e4,
                    rgba: (parseInt(e4.slice(1), 16) << 8 | 255) >>> 0
                  };
                case 9:
                  return {
                    css: e4,
                    rgba: parseInt(e4.slice(1), 16) >>> 0
                  };
              }
              const h2 = e4.match(/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(,\s*(0|1|\d?\.(\d+))\s*)?\)/);
              if (h2) return i3 = parseInt(h2[1]), s2 = parseInt(h2[2]), r = parseInt(h2[3]), n = Math.round(255 * (void 0 === h2[5] ? 1 : parseFloat(h2[5]))), o.toColor(i3, s2, r, n);
              if (!t4 || !a2) throw new Error("css.toColor: Unsupported css format");
              if (t4.fillStyle = a2, t4.fillStyle = e4, "string" != typeof t4.fillStyle) throw new Error("css.toColor: Unsupported css format");
              if (t4.fillRect(0, 0, 1, 1), [i3, s2, r, n] = t4.getImageData(0, 0, 1, 1).data, 255 !== n) throw new Error("css.toColor: Unsupported css format");
              return {
                rgba: o.toRgba(i3, s2, r, n),
                css: e4
              };
            };
          }(h || (t3.css = h = {})), function(e3) {
            function t4(e4, t5, i4) {
              const s3 = e4 / 255, r2 = t5 / 255, n2 = i4 / 255;
              return 0.2126 * (s3 <= 0.03928 ? s3 / 12.92 : Math.pow((s3 + 0.055) / 1.055, 2.4)) + 0.7152 * (r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4)) + 0.0722 * (n2 <= 0.03928 ? n2 / 12.92 : Math.pow((n2 + 0.055) / 1.055, 2.4));
            }
            e3.relativeLuminance = function(e4) {
              return t4(e4 >> 16 & 255, e4 >> 8 & 255, 255 & e4);
            }, e3.relativeLuminance2 = t4;
          }(c || (t3.rgb = c = {})), function(e3) {
            function t4(e4, t5, i4) {
              const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
              let o2 = t5 >> 24 & 255, a3 = t5 >> 16 & 255, h2 = t5 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
              for (; l2 < i4 && (o2 > 0 || a3 > 0 || h2 > 0); ) o2 -= Math.max(0, Math.ceil(0.1 * o2)), a3 -= Math.max(0, Math.ceil(0.1 * a3)), h2 -= Math.max(0, Math.ceil(0.1 * h2)), l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
              return (o2 << 24 | a3 << 16 | h2 << 8 | 255) >>> 0;
            }
            function a2(e4, t5, i4) {
              const s3 = e4 >> 24 & 255, r2 = e4 >> 16 & 255, n2 = e4 >> 8 & 255;
              let o2 = t5 >> 24 & 255, a3 = t5 >> 16 & 255, h2 = t5 >> 8 & 255, l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
              for (; l2 < i4 && (o2 < 255 || a3 < 255 || h2 < 255); ) o2 = Math.min(255, o2 + Math.ceil(0.1 * (255 - o2))), a3 = Math.min(255, a3 + Math.ceil(0.1 * (255 - a3))), h2 = Math.min(255, h2 + Math.ceil(0.1 * (255 - h2))), l2 = _(c.relativeLuminance2(o2, a3, h2), c.relativeLuminance2(s3, r2, n2));
              return (o2 << 24 | a3 << 16 | h2 << 8 | 255) >>> 0;
            }
            e3.blend = function(e4, t5) {
              if (n = (255 & t5) / 255, 1 === n) return t5;
              const a3 = t5 >> 24 & 255, h2 = t5 >> 16 & 255, c2 = t5 >> 8 & 255, l2 = e4 >> 24 & 255, d2 = e4 >> 16 & 255, _2 = e4 >> 8 & 255;
              return i3 = l2 + Math.round((a3 - l2) * n), s2 = d2 + Math.round((h2 - d2) * n), r = _2 + Math.round((c2 - _2) * n), o.toRgba(i3, s2, r);
            }, e3.ensureContrastRatio = function(e4, i4, s3) {
              const r2 = c.relativeLuminance(e4 >> 8), n2 = c.relativeLuminance(i4 >> 8);
              if (_(r2, n2) < s3) {
                if (n2 < r2) {
                  const n3 = t4(e4, i4, s3), o3 = _(r2, c.relativeLuminance(n3 >> 8));
                  if (o3 < s3) {
                    const t5 = a2(e4, i4, s3);
                    return o3 > _(r2, c.relativeLuminance(t5 >> 8)) ? n3 : t5;
                  }
                  return n3;
                }
                const o2 = a2(e4, i4, s3), h2 = _(r2, c.relativeLuminance(o2 >> 8));
                if (h2 < s3) {
                  const n3 = t4(e4, i4, s3);
                  return h2 > _(r2, c.relativeLuminance(n3 >> 8)) ? o2 : n3;
                }
                return o2;
              }
            }, e3.reduceLuminance = t4, e3.increaseLuminance = a2, e3.toChannels = function(e4) {
              return [
                e4 >> 24 & 255,
                e4 >> 16 & 255,
                e4 >> 8 & 255,
                255 & e4
              ];
            };
          }(l || (t3.rgba = l = {})), t3.toPaddedHex = d, t3.contrastRatio = _;
        },
        8969: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CoreTerminal = void 0;
          const s2 = i3(844), r = i3(2585), n = i3(4348), o = i3(7866), a = i3(744), h = i3(7302), c = i3(6975), l = i3(8460), d = i3(1753), _ = i3(1480), u = i3(7994), f = i3(9282), v = i3(5435), p = i3(5981), g = i3(2660);
          let m = false;
          class S extends s2.Disposable {
            get onScroll() {
              return this._onScrollApi || (this._onScrollApi = this.register(new l.EventEmitter()), this._onScroll.event((e3) => {
                var _a2;
                (_a2 = this._onScrollApi) == null ? void 0 : _a2.fire(e3.position);
              })), this._onScrollApi.event;
            }
            get cols() {
              return this._bufferService.cols;
            }
            get rows() {
              return this._bufferService.rows;
            }
            get buffers() {
              return this._bufferService.buffers;
            }
            get options() {
              return this.optionsService.options;
            }
            set options(e3) {
              for (const t4 in e3) this.optionsService.options[t4] = e3[t4];
            }
            constructor(e3) {
              super(), this._windowsWrappingHeuristics = this.register(new s2.MutableDisposable()), this._onBinary = this.register(new l.EventEmitter()), this.onBinary = this._onBinary.event, this._onData = this.register(new l.EventEmitter()), this.onData = this._onData.event, this._onLineFeed = this.register(new l.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onResize = this.register(new l.EventEmitter()), this.onResize = this._onResize.event, this._onWriteParsed = this.register(new l.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event, this._onScroll = this.register(new l.EventEmitter()), this._instantiationService = new n.InstantiationService(), this.optionsService = this.register(new h.OptionsService(e3)), this._instantiationService.setService(r.IOptionsService, this.optionsService), this._bufferService = this.register(this._instantiationService.createInstance(a.BufferService)), this._instantiationService.setService(r.IBufferService, this._bufferService), this._logService = this.register(this._instantiationService.createInstance(o.LogService)), this._instantiationService.setService(r.ILogService, this._logService), this.coreService = this.register(this._instantiationService.createInstance(c.CoreService)), this._instantiationService.setService(r.ICoreService, this.coreService), this.coreMouseService = this.register(this._instantiationService.createInstance(d.CoreMouseService)), this._instantiationService.setService(r.ICoreMouseService, this.coreMouseService), this.unicodeService = this.register(this._instantiationService.createInstance(_.UnicodeService)), this._instantiationService.setService(r.IUnicodeService, this.unicodeService), this._charsetService = this._instantiationService.createInstance(u.CharsetService), this._instantiationService.setService(r.ICharsetService, this._charsetService), this._oscLinkService = this._instantiationService.createInstance(g.OscLinkService), this._instantiationService.setService(r.IOscLinkService, this._oscLinkService), this._inputHandler = this.register(new v.InputHandler(this._bufferService, this._charsetService, this.coreService, this._logService, this.optionsService, this._oscLinkService, this.coreMouseService, this.unicodeService)), this.register((0, l.forwardEvent)(this._inputHandler.onLineFeed, this._onLineFeed)), this.register(this._inputHandler), this.register((0, l.forwardEvent)(this._bufferService.onResize, this._onResize)), this.register((0, l.forwardEvent)(this.coreService.onData, this._onData)), this.register((0, l.forwardEvent)(this.coreService.onBinary, this._onBinary)), this.register(this.coreService.onRequestScrollToBottom(() => this.scrollToBottom())), this.register(this.coreService.onUserInput(() => this._writeBuffer.handleUserInput())), this.register(this.optionsService.onMultipleOptionChange([
                "windowsMode",
                "windowsPty"
              ], () => this._handleWindowsPtyOptionChange())), this.register(this._bufferService.onScroll((e4) => {
                this._onScroll.fire({
                  position: this._bufferService.buffer.ydisp,
                  source: 0
                }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
              })), this.register(this._inputHandler.onScroll((e4) => {
                this._onScroll.fire({
                  position: this._bufferService.buffer.ydisp,
                  source: 0
                }), this._inputHandler.markRangeDirty(this._bufferService.buffer.scrollTop, this._bufferService.buffer.scrollBottom);
              })), this._writeBuffer = this.register(new p.WriteBuffer((e4, t4) => this._inputHandler.parse(e4, t4))), this.register((0, l.forwardEvent)(this._writeBuffer.onWriteParsed, this._onWriteParsed));
            }
            write(e3, t4) {
              this._writeBuffer.write(e3, t4);
            }
            writeSync(e3, t4) {
              this._logService.logLevel <= r.LogLevelEnum.WARN && !m && (this._logService.warn("writeSync is unreliable and will be removed soon."), m = true), this._writeBuffer.writeSync(e3, t4);
            }
            input(e3, t4 = true) {
              this.coreService.triggerDataEvent(e3, t4);
            }
            resize(e3, t4) {
              isNaN(e3) || isNaN(t4) || (e3 = Math.max(e3, a.MINIMUM_COLS), t4 = Math.max(t4, a.MINIMUM_ROWS), this._bufferService.resize(e3, t4));
            }
            scroll(e3, t4 = false) {
              this._bufferService.scroll(e3, t4);
            }
            scrollLines(e3, t4, i4) {
              this._bufferService.scrollLines(e3, t4, i4);
            }
            scrollPages(e3) {
              this.scrollLines(e3 * (this.rows - 1));
            }
            scrollToTop() {
              this.scrollLines(-this._bufferService.buffer.ydisp);
            }
            scrollToBottom() {
              this.scrollLines(this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
            }
            scrollToLine(e3) {
              const t4 = e3 - this._bufferService.buffer.ydisp;
              0 !== t4 && this.scrollLines(t4);
            }
            registerEscHandler(e3, t4) {
              return this._inputHandler.registerEscHandler(e3, t4);
            }
            registerDcsHandler(e3, t4) {
              return this._inputHandler.registerDcsHandler(e3, t4);
            }
            registerCsiHandler(e3, t4) {
              return this._inputHandler.registerCsiHandler(e3, t4);
            }
            registerOscHandler(e3, t4) {
              return this._inputHandler.registerOscHandler(e3, t4);
            }
            _setup() {
              this._handleWindowsPtyOptionChange();
            }
            reset() {
              this._inputHandler.reset(), this._bufferService.reset(), this._charsetService.reset(), this.coreService.reset(), this.coreMouseService.reset();
            }
            _handleWindowsPtyOptionChange() {
              let e3 = false;
              const t4 = this.optionsService.rawOptions.windowsPty;
              t4 && void 0 !== t4.buildNumber && void 0 !== t4.buildNumber ? e3 = !!("conpty" === t4.backend && t4.buildNumber < 21376) : this.optionsService.rawOptions.windowsMode && (e3 = true), e3 ? this._enableWindowsWrappingHeuristics() : this._windowsWrappingHeuristics.clear();
            }
            _enableWindowsWrappingHeuristics() {
              if (!this._windowsWrappingHeuristics.value) {
                const e3 = [];
                e3.push(this.onLineFeed(f.updateWindowsModeWrappedState.bind(null, this._bufferService))), e3.push(this.registerCsiHandler({
                  final: "H"
                }, () => ((0, f.updateWindowsModeWrappedState)(this._bufferService), false))), this._windowsWrappingHeuristics.value = (0, s2.toDisposable)(() => {
                  for (const t4 of e3) t4.dispose();
                });
              }
            }
          }
          t3.CoreTerminal = S;
        },
        8460: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.runAndSubscribe = t3.forwardEvent = t3.EventEmitter = void 0, t3.EventEmitter = class {
            constructor() {
              this._listeners = [], this._disposed = false;
            }
            get event() {
              return this._event || (this._event = (e3) => (this._listeners.push(e3), {
                dispose: () => {
                  if (!this._disposed) {
                    for (let t4 = 0; t4 < this._listeners.length; t4++) if (this._listeners[t4] === e3) return void this._listeners.splice(t4, 1);
                  }
                }
              })), this._event;
            }
            fire(e3, t4) {
              const i3 = [];
              for (let e4 = 0; e4 < this._listeners.length; e4++) i3.push(this._listeners[e4]);
              for (let s2 = 0; s2 < i3.length; s2++) i3[s2].call(void 0, e3, t4);
            }
            dispose() {
              this.clearListeners(), this._disposed = true;
            }
            clearListeners() {
              this._listeners && (this._listeners.length = 0);
            }
          }, t3.forwardEvent = function(e3, t4) {
            return e3((e4) => t4.fire(e4));
          }, t3.runAndSubscribe = function(e3, t4) {
            return t4(void 0), e3((e4) => t4(e4));
          };
        },
        5435: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.InputHandler = t3.WindowsOptionsReportType = void 0;
          const n = i3(2584), o = i3(7116), a = i3(2015), h = i3(844), c = i3(482), l = i3(8437), d = i3(8460), _ = i3(643), u = i3(511), f = i3(3734), v = i3(2585), p = i3(1480), g = i3(6242), m = i3(6351), S = i3(5941), C2 = {
            "(": 0,
            ")": 1,
            "*": 2,
            "+": 3,
            "-": 1,
            ".": 2
          }, b = 131072;
          function w(e3, t4) {
            if (e3 > 24) return t4.setWinLines || false;
            switch (e3) {
              case 1:
                return !!t4.restoreWin;
              case 2:
                return !!t4.minimizeWin;
              case 3:
                return !!t4.setWinPosition;
              case 4:
                return !!t4.setWinSizePixels;
              case 5:
                return !!t4.raiseWin;
              case 6:
                return !!t4.lowerWin;
              case 7:
                return !!t4.refreshWin;
              case 8:
                return !!t4.setWinSizeChars;
              case 9:
                return !!t4.maximizeWin;
              case 10:
                return !!t4.fullscreenWin;
              case 11:
                return !!t4.getWinState;
              case 13:
                return !!t4.getWinPosition;
              case 14:
                return !!t4.getWinSizePixels;
              case 15:
                return !!t4.getScreenSizePixels;
              case 16:
                return !!t4.getCellSizePixels;
              case 18:
                return !!t4.getWinSizeChars;
              case 19:
                return !!t4.getScreenSizeChars;
              case 20:
                return !!t4.getIconTitle;
              case 21:
                return !!t4.getWinTitle;
              case 22:
                return !!t4.pushTitle;
              case 23:
                return !!t4.popTitle;
              case 24:
                return !!t4.setWinLines;
            }
            return false;
          }
          var y;
          !function(e3) {
            e3[e3.GET_WIN_SIZE_PIXELS = 0] = "GET_WIN_SIZE_PIXELS", e3[e3.GET_CELL_SIZE_PIXELS = 1] = "GET_CELL_SIZE_PIXELS";
          }(y || (t3.WindowsOptionsReportType = y = {}));
          let E = 0;
          class k extends h.Disposable {
            getAttrData() {
              return this._curAttrData;
            }
            constructor(e3, t4, i4, s3, r2, h2, _2, f2, v2 = new a.EscapeSequenceParser()) {
              super(), this._bufferService = e3, this._charsetService = t4, this._coreService = i4, this._logService = s3, this._optionsService = r2, this._oscLinkService = h2, this._coreMouseService = _2, this._unicodeService = f2, this._parser = v2, this._parseBuffer = new Uint32Array(4096), this._stringDecoder = new c.StringToUtf32(), this._utf8Decoder = new c.Utf8ToUtf32(), this._workCell = new u.CellData(), this._windowTitle = "", this._iconName = "", this._windowTitleStack = [], this._iconNameStack = [], this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone(), this._onRequestBell = this.register(new d.EventEmitter()), this.onRequestBell = this._onRequestBell.event, this._onRequestRefreshRows = this.register(new d.EventEmitter()), this.onRequestRefreshRows = this._onRequestRefreshRows.event, this._onRequestReset = this.register(new d.EventEmitter()), this.onRequestReset = this._onRequestReset.event, this._onRequestSendFocus = this.register(new d.EventEmitter()), this.onRequestSendFocus = this._onRequestSendFocus.event, this._onRequestSyncScrollBar = this.register(new d.EventEmitter()), this.onRequestSyncScrollBar = this._onRequestSyncScrollBar.event, this._onRequestWindowsOptionsReport = this.register(new d.EventEmitter()), this.onRequestWindowsOptionsReport = this._onRequestWindowsOptionsReport.event, this._onA11yChar = this.register(new d.EventEmitter()), this.onA11yChar = this._onA11yChar.event, this._onA11yTab = this.register(new d.EventEmitter()), this.onA11yTab = this._onA11yTab.event, this._onCursorMove = this.register(new d.EventEmitter()), this.onCursorMove = this._onCursorMove.event, this._onLineFeed = this.register(new d.EventEmitter()), this.onLineFeed = this._onLineFeed.event, this._onScroll = this.register(new d.EventEmitter()), this.onScroll = this._onScroll.event, this._onTitleChange = this.register(new d.EventEmitter()), this.onTitleChange = this._onTitleChange.event, this._onColor = this.register(new d.EventEmitter()), this.onColor = this._onColor.event, this._parseStack = {
                paused: false,
                cursorStartX: 0,
                cursorStartY: 0,
                decodedLength: 0,
                position: 0
              }, this._specialColors = [
                256,
                257,
                258
              ], this.register(this._parser), this._dirtyRowTracker = new L(this._bufferService), this._activeBuffer = this._bufferService.buffer, this.register(this._bufferService.buffers.onBufferActivate((e4) => this._activeBuffer = e4.activeBuffer)), this._parser.setCsiHandlerFallback((e4, t5) => {
                this._logService.debug("Unknown CSI code: ", {
                  identifier: this._parser.identToString(e4),
                  params: t5.toArray()
                });
              }), this._parser.setEscHandlerFallback((e4) => {
                this._logService.debug("Unknown ESC code: ", {
                  identifier: this._parser.identToString(e4)
                });
              }), this._parser.setExecuteHandlerFallback((e4) => {
                this._logService.debug("Unknown EXECUTE code: ", {
                  code: e4
                });
              }), this._parser.setOscHandlerFallback((e4, t5, i5) => {
                this._logService.debug("Unknown OSC code: ", {
                  identifier: e4,
                  action: t5,
                  data: i5
                });
              }), this._parser.setDcsHandlerFallback((e4, t5, i5) => {
                "HOOK" === t5 && (i5 = i5.toArray()), this._logService.debug("Unknown DCS code: ", {
                  identifier: this._parser.identToString(e4),
                  action: t5,
                  payload: i5
                });
              }), this._parser.setPrintHandler((e4, t5, i5) => this.print(e4, t5, i5)), this._parser.registerCsiHandler({
                final: "@"
              }, (e4) => this.insertChars(e4)), this._parser.registerCsiHandler({
                intermediates: " ",
                final: "@"
              }, (e4) => this.scrollLeft(e4)), this._parser.registerCsiHandler({
                final: "A"
              }, (e4) => this.cursorUp(e4)), this._parser.registerCsiHandler({
                intermediates: " ",
                final: "A"
              }, (e4) => this.scrollRight(e4)), this._parser.registerCsiHandler({
                final: "B"
              }, (e4) => this.cursorDown(e4)), this._parser.registerCsiHandler({
                final: "C"
              }, (e4) => this.cursorForward(e4)), this._parser.registerCsiHandler({
                final: "D"
              }, (e4) => this.cursorBackward(e4)), this._parser.registerCsiHandler({
                final: "E"
              }, (e4) => this.cursorNextLine(e4)), this._parser.registerCsiHandler({
                final: "F"
              }, (e4) => this.cursorPrecedingLine(e4)), this._parser.registerCsiHandler({
                final: "G"
              }, (e4) => this.cursorCharAbsolute(e4)), this._parser.registerCsiHandler({
                final: "H"
              }, (e4) => this.cursorPosition(e4)), this._parser.registerCsiHandler({
                final: "I"
              }, (e4) => this.cursorForwardTab(e4)), this._parser.registerCsiHandler({
                final: "J"
              }, (e4) => this.eraseInDisplay(e4, false)), this._parser.registerCsiHandler({
                prefix: "?",
                final: "J"
              }, (e4) => this.eraseInDisplay(e4, true)), this._parser.registerCsiHandler({
                final: "K"
              }, (e4) => this.eraseInLine(e4, false)), this._parser.registerCsiHandler({
                prefix: "?",
                final: "K"
              }, (e4) => this.eraseInLine(e4, true)), this._parser.registerCsiHandler({
                final: "L"
              }, (e4) => this.insertLines(e4)), this._parser.registerCsiHandler({
                final: "M"
              }, (e4) => this.deleteLines(e4)), this._parser.registerCsiHandler({
                final: "P"
              }, (e4) => this.deleteChars(e4)), this._parser.registerCsiHandler({
                final: "S"
              }, (e4) => this.scrollUp(e4)), this._parser.registerCsiHandler({
                final: "T"
              }, (e4) => this.scrollDown(e4)), this._parser.registerCsiHandler({
                final: "X"
              }, (e4) => this.eraseChars(e4)), this._parser.registerCsiHandler({
                final: "Z"
              }, (e4) => this.cursorBackwardTab(e4)), this._parser.registerCsiHandler({
                final: "`"
              }, (e4) => this.charPosAbsolute(e4)), this._parser.registerCsiHandler({
                final: "a"
              }, (e4) => this.hPositionRelative(e4)), this._parser.registerCsiHandler({
                final: "b"
              }, (e4) => this.repeatPrecedingCharacter(e4)), this._parser.registerCsiHandler({
                final: "c"
              }, (e4) => this.sendDeviceAttributesPrimary(e4)), this._parser.registerCsiHandler({
                prefix: ">",
                final: "c"
              }, (e4) => this.sendDeviceAttributesSecondary(e4)), this._parser.registerCsiHandler({
                final: "d"
              }, (e4) => this.linePosAbsolute(e4)), this._parser.registerCsiHandler({
                final: "e"
              }, (e4) => this.vPositionRelative(e4)), this._parser.registerCsiHandler({
                final: "f"
              }, (e4) => this.hVPosition(e4)), this._parser.registerCsiHandler({
                final: "g"
              }, (e4) => this.tabClear(e4)), this._parser.registerCsiHandler({
                final: "h"
              }, (e4) => this.setMode(e4)), this._parser.registerCsiHandler({
                prefix: "?",
                final: "h"
              }, (e4) => this.setModePrivate(e4)), this._parser.registerCsiHandler({
                final: "l"
              }, (e4) => this.resetMode(e4)), this._parser.registerCsiHandler({
                prefix: "?",
                final: "l"
              }, (e4) => this.resetModePrivate(e4)), this._parser.registerCsiHandler({
                final: "m"
              }, (e4) => this.charAttributes(e4)), this._parser.registerCsiHandler({
                final: "n"
              }, (e4) => this.deviceStatus(e4)), this._parser.registerCsiHandler({
                prefix: "?",
                final: "n"
              }, (e4) => this.deviceStatusPrivate(e4)), this._parser.registerCsiHandler({
                intermediates: "!",
                final: "p"
              }, (e4) => this.softReset(e4)), this._parser.registerCsiHandler({
                intermediates: " ",
                final: "q"
              }, (e4) => this.setCursorStyle(e4)), this._parser.registerCsiHandler({
                final: "r"
              }, (e4) => this.setScrollRegion(e4)), this._parser.registerCsiHandler({
                final: "s"
              }, (e4) => this.saveCursor(e4)), this._parser.registerCsiHandler({
                final: "t"
              }, (e4) => this.windowOptions(e4)), this._parser.registerCsiHandler({
                final: "u"
              }, (e4) => this.restoreCursor(e4)), this._parser.registerCsiHandler({
                intermediates: "'",
                final: "}"
              }, (e4) => this.insertColumns(e4)), this._parser.registerCsiHandler({
                intermediates: "'",
                final: "~"
              }, (e4) => this.deleteColumns(e4)), this._parser.registerCsiHandler({
                intermediates: '"',
                final: "q"
              }, (e4) => this.selectProtected(e4)), this._parser.registerCsiHandler({
                intermediates: "$",
                final: "p"
              }, (e4) => this.requestMode(e4, true)), this._parser.registerCsiHandler({
                prefix: "?",
                intermediates: "$",
                final: "p"
              }, (e4) => this.requestMode(e4, false)), this._parser.setExecuteHandler(n.C0.BEL, () => this.bell()), this._parser.setExecuteHandler(n.C0.LF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.VT, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.FF, () => this.lineFeed()), this._parser.setExecuteHandler(n.C0.CR, () => this.carriageReturn()), this._parser.setExecuteHandler(n.C0.BS, () => this.backspace()), this._parser.setExecuteHandler(n.C0.HT, () => this.tab()), this._parser.setExecuteHandler(n.C0.SO, () => this.shiftOut()), this._parser.setExecuteHandler(n.C0.SI, () => this.shiftIn()), this._parser.setExecuteHandler(n.C1.IND, () => this.index()), this._parser.setExecuteHandler(n.C1.NEL, () => this.nextLine()), this._parser.setExecuteHandler(n.C1.HTS, () => this.tabSet()), this._parser.registerOscHandler(0, new g.OscHandler((e4) => (this.setTitle(e4), this.setIconName(e4), true))), this._parser.registerOscHandler(1, new g.OscHandler((e4) => this.setIconName(e4))), this._parser.registerOscHandler(2, new g.OscHandler((e4) => this.setTitle(e4))), this._parser.registerOscHandler(4, new g.OscHandler((e4) => this.setOrReportIndexedColor(e4))), this._parser.registerOscHandler(8, new g.OscHandler((e4) => this.setHyperlink(e4))), this._parser.registerOscHandler(10, new g.OscHandler((e4) => this.setOrReportFgColor(e4))), this._parser.registerOscHandler(11, new g.OscHandler((e4) => this.setOrReportBgColor(e4))), this._parser.registerOscHandler(12, new g.OscHandler((e4) => this.setOrReportCursorColor(e4))), this._parser.registerOscHandler(104, new g.OscHandler((e4) => this.restoreIndexedColor(e4))), this._parser.registerOscHandler(110, new g.OscHandler((e4) => this.restoreFgColor(e4))), this._parser.registerOscHandler(111, new g.OscHandler((e4) => this.restoreBgColor(e4))), this._parser.registerOscHandler(112, new g.OscHandler((e4) => this.restoreCursorColor(e4))), this._parser.registerEscHandler({
                final: "7"
              }, () => this.saveCursor()), this._parser.registerEscHandler({
                final: "8"
              }, () => this.restoreCursor()), this._parser.registerEscHandler({
                final: "D"
              }, () => this.index()), this._parser.registerEscHandler({
                final: "E"
              }, () => this.nextLine()), this._parser.registerEscHandler({
                final: "H"
              }, () => this.tabSet()), this._parser.registerEscHandler({
                final: "M"
              }, () => this.reverseIndex()), this._parser.registerEscHandler({
                final: "="
              }, () => this.keypadApplicationMode()), this._parser.registerEscHandler({
                final: ">"
              }, () => this.keypadNumericMode()), this._parser.registerEscHandler({
                final: "c"
              }, () => this.fullReset()), this._parser.registerEscHandler({
                final: "n"
              }, () => this.setgLevel(2)), this._parser.registerEscHandler({
                final: "o"
              }, () => this.setgLevel(3)), this._parser.registerEscHandler({
                final: "|"
              }, () => this.setgLevel(3)), this._parser.registerEscHandler({
                final: "}"
              }, () => this.setgLevel(2)), this._parser.registerEscHandler({
                final: "~"
              }, () => this.setgLevel(1)), this._parser.registerEscHandler({
                intermediates: "%",
                final: "@"
              }, () => this.selectDefaultCharset()), this._parser.registerEscHandler({
                intermediates: "%",
                final: "G"
              }, () => this.selectDefaultCharset());
              for (const e4 in o.CHARSETS) this._parser.registerEscHandler({
                intermediates: "(",
                final: e4
              }, () => this.selectCharset("(" + e4)), this._parser.registerEscHandler({
                intermediates: ")",
                final: e4
              }, () => this.selectCharset(")" + e4)), this._parser.registerEscHandler({
                intermediates: "*",
                final: e4
              }, () => this.selectCharset("*" + e4)), this._parser.registerEscHandler({
                intermediates: "+",
                final: e4
              }, () => this.selectCharset("+" + e4)), this._parser.registerEscHandler({
                intermediates: "-",
                final: e4
              }, () => this.selectCharset("-" + e4)), this._parser.registerEscHandler({
                intermediates: ".",
                final: e4
              }, () => this.selectCharset("." + e4)), this._parser.registerEscHandler({
                intermediates: "/",
                final: e4
              }, () => this.selectCharset("/" + e4));
              this._parser.registerEscHandler({
                intermediates: "#",
                final: "8"
              }, () => this.screenAlignmentPattern()), this._parser.setErrorHandler((e4) => (this._logService.error("Parsing error: ", e4), e4)), this._parser.registerDcsHandler({
                intermediates: "$",
                final: "q"
              }, new m.DcsHandler((e4, t5) => this.requestStatusString(e4, t5)));
            }
            _preserveStack(e3, t4, i4, s3) {
              this._parseStack.paused = true, this._parseStack.cursorStartX = e3, this._parseStack.cursorStartY = t4, this._parseStack.decodedLength = i4, this._parseStack.position = s3;
            }
            _logSlowResolvingAsync(e3) {
              this._logService.logLevel <= v.LogLevelEnum.WARN && Promise.race([
                e3,
                new Promise((e4, t4) => setTimeout(() => t4("#SLOW_TIMEOUT"), 5e3))
              ]).catch((e4) => {
                if ("#SLOW_TIMEOUT" !== e4) throw e4;
                console.warn("async parser handler taking longer than 5000 ms");
              });
            }
            _getCurrentLinkId() {
              return this._curAttrData.extended.urlId;
            }
            parse(e3, t4) {
              let i4, s3 = this._activeBuffer.x, r2 = this._activeBuffer.y, n2 = 0;
              const o2 = this._parseStack.paused;
              if (o2) {
                if (i4 = this._parser.parse(this._parseBuffer, this._parseStack.decodedLength, t4)) return this._logSlowResolvingAsync(i4), i4;
                s3 = this._parseStack.cursorStartX, r2 = this._parseStack.cursorStartY, this._parseStack.paused = false, e3.length > b && (n2 = this._parseStack.position + b);
              }
              if (this._logService.logLevel <= v.LogLevelEnum.DEBUG && this._logService.debug("parsing data" + ("string" == typeof e3 ? ` "${e3}"` : ` "${Array.prototype.map.call(e3, (e4) => String.fromCharCode(e4)).join("")}"`), "string" == typeof e3 ? e3.split("").map((e4) => e4.charCodeAt(0)) : e3), this._parseBuffer.length < e3.length && this._parseBuffer.length < b && (this._parseBuffer = new Uint32Array(Math.min(e3.length, b))), o2 || this._dirtyRowTracker.clearRange(), e3.length > b) for (let t5 = n2; t5 < e3.length; t5 += b) {
                const n3 = t5 + b < e3.length ? t5 + b : e3.length, o3 = "string" == typeof e3 ? this._stringDecoder.decode(e3.substring(t5, n3), this._parseBuffer) : this._utf8Decoder.decode(e3.subarray(t5, n3), this._parseBuffer);
                if (i4 = this._parser.parse(this._parseBuffer, o3)) return this._preserveStack(s3, r2, o3, t5), this._logSlowResolvingAsync(i4), i4;
              }
              else if (!o2) {
                const t5 = "string" == typeof e3 ? this._stringDecoder.decode(e3, this._parseBuffer) : this._utf8Decoder.decode(e3, this._parseBuffer);
                if (i4 = this._parser.parse(this._parseBuffer, t5)) return this._preserveStack(s3, r2, t5, 0), this._logSlowResolvingAsync(i4), i4;
              }
              this._activeBuffer.x === s3 && this._activeBuffer.y === r2 || this._onCursorMove.fire();
              const a2 = this._dirtyRowTracker.end + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp), h2 = this._dirtyRowTracker.start + (this._bufferService.buffer.ybase - this._bufferService.buffer.ydisp);
              h2 < this._bufferService.rows && this._onRequestRefreshRows.fire(Math.min(h2, this._bufferService.rows - 1), Math.min(a2, this._bufferService.rows - 1));
            }
            print(e3, t4, i4) {
              let s3, r2;
              const n2 = this._charsetService.charset, o2 = this._optionsService.rawOptions.screenReaderMode, a2 = this._bufferService.cols, h2 = this._coreService.decPrivateModes.wraparound, d2 = this._coreService.modes.insertMode, u2 = this._curAttrData;
              let f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._activeBuffer.x && i4 - t4 > 0 && 2 === f2.getWidth(this._activeBuffer.x - 1) && f2.setCellFromCodepoint(this._activeBuffer.x - 1, 0, 1, u2);
              let v2 = this._parser.precedingJoinState;
              for (let g2 = t4; g2 < i4; ++g2) {
                if (s3 = e3[g2], s3 < 127 && n2) {
                  const e4 = n2[String.fromCharCode(s3)];
                  e4 && (s3 = e4.charCodeAt(0));
                }
                const t5 = this._unicodeService.charProperties(s3, v2);
                r2 = p.UnicodeService.extractWidth(t5);
                const i5 = p.UnicodeService.extractShouldJoin(t5), m2 = i5 ? p.UnicodeService.extractWidth(v2) : 0;
                if (v2 = t5, o2 && this._onA11yChar.fire((0, c.stringFromCodePoint)(s3)), this._getCurrentLinkId() && this._oscLinkService.addLineToLink(this._getCurrentLinkId(), this._activeBuffer.ybase + this._activeBuffer.y), this._activeBuffer.x + r2 - m2 > a2) {
                  if (h2) {
                    const e4 = f2;
                    let t6 = this._activeBuffer.x - m2;
                    for (this._activeBuffer.x = m2, this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData(), true)) : (this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = true), f2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y), m2 > 0 && f2 instanceof l.BufferLine && f2.copyCellsFrom(e4, t6, 0, m2, false); t6 < a2; ) e4.setCellFromCodepoint(t6++, 0, 1, u2);
                  } else if (this._activeBuffer.x = a2 - 1, 2 === r2) continue;
                }
                if (i5 && this._activeBuffer.x) {
                  const e4 = f2.getWidth(this._activeBuffer.x - 1) ? 1 : 2;
                  f2.addCodepointToCell(this._activeBuffer.x - e4, s3, r2);
                  for (let e5 = r2 - m2; --e5 >= 0; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
                } else if (d2 && (f2.insertCells(this._activeBuffer.x, r2 - m2, this._activeBuffer.getNullCell(u2)), 2 === f2.getWidth(a2 - 1) && f2.setCellFromCodepoint(a2 - 1, _.NULL_CELL_CODE, _.NULL_CELL_WIDTH, u2)), f2.setCellFromCodepoint(this._activeBuffer.x++, s3, r2, u2), r2 > 0) for (; --r2; ) f2.setCellFromCodepoint(this._activeBuffer.x++, 0, 0, u2);
              }
              this._parser.precedingJoinState = v2, this._activeBuffer.x < a2 && i4 - t4 > 0 && 0 === f2.getWidth(this._activeBuffer.x) && !f2.hasContent(this._activeBuffer.x) && f2.setCellFromCodepoint(this._activeBuffer.x, 0, 1, u2), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            registerCsiHandler(e3, t4) {
              return "t" !== e3.final || e3.prefix || e3.intermediates ? this._parser.registerCsiHandler(e3, t4) : this._parser.registerCsiHandler(e3, (e4) => !w(e4.params[0], this._optionsService.rawOptions.windowOptions) || t4(e4));
            }
            registerDcsHandler(e3, t4) {
              return this._parser.registerDcsHandler(e3, new m.DcsHandler(t4));
            }
            registerEscHandler(e3, t4) {
              return this._parser.registerEscHandler(e3, t4);
            }
            registerOscHandler(e3, t4) {
              return this._parser.registerOscHandler(e3, new g.OscHandler(t4));
            }
            bell() {
              return this._onRequestBell.fire(), true;
            }
            lineFeed() {
              return this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._optionsService.rawOptions.convertEol && (this._activeBuffer.x = 0), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows ? this._activeBuffer.y = this._bufferService.rows - 1 : this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.x >= this._bufferService.cols && this._activeBuffer.x--, this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._onLineFeed.fire(), true;
            }
            carriageReturn() {
              return this._activeBuffer.x = 0, true;
            }
            backspace() {
              var _a2;
              if (!this._coreService.decPrivateModes.reverseWraparound) return this._restrictCursor(), this._activeBuffer.x > 0 && this._activeBuffer.x--, true;
              if (this._restrictCursor(this._bufferService.cols), this._activeBuffer.x > 0) this._activeBuffer.x--;
              else if (0 === this._activeBuffer.x && this._activeBuffer.y > this._activeBuffer.scrollTop && this._activeBuffer.y <= this._activeBuffer.scrollBottom && ((_a2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y)) == null ? void 0 : _a2.isWrapped)) {
                this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).isWrapped = false, this._activeBuffer.y--, this._activeBuffer.x = this._bufferService.cols - 1;
                const e3 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
                e3.hasWidth(this._activeBuffer.x) && !e3.hasContent(this._activeBuffer.x) && this._activeBuffer.x--;
              }
              return this._restrictCursor(), true;
            }
            tab() {
              if (this._activeBuffer.x >= this._bufferService.cols) return true;
              const e3 = this._activeBuffer.x;
              return this._activeBuffer.x = this._activeBuffer.nextStop(), this._optionsService.rawOptions.screenReaderMode && this._onA11yTab.fire(this._activeBuffer.x - e3), true;
            }
            shiftOut() {
              return this._charsetService.setgLevel(1), true;
            }
            shiftIn() {
              return this._charsetService.setgLevel(0), true;
            }
            _restrictCursor(e3 = this._bufferService.cols - 1) {
              this._activeBuffer.x = Math.min(e3, Math.max(0, this._activeBuffer.x)), this._activeBuffer.y = this._coreService.decPrivateModes.origin ? Math.min(this._activeBuffer.scrollBottom, Math.max(this._activeBuffer.scrollTop, this._activeBuffer.y)) : Math.min(this._bufferService.rows - 1, Math.max(0, this._activeBuffer.y)), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            _setCursor(e3, t4) {
              this._dirtyRowTracker.markDirty(this._activeBuffer.y), this._coreService.decPrivateModes.origin ? (this._activeBuffer.x = e3, this._activeBuffer.y = this._activeBuffer.scrollTop + t4) : (this._activeBuffer.x = e3, this._activeBuffer.y = t4), this._restrictCursor(), this._dirtyRowTracker.markDirty(this._activeBuffer.y);
            }
            _moveCursor(e3, t4) {
              this._restrictCursor(), this._setCursor(this._activeBuffer.x + e3, this._activeBuffer.y + t4);
            }
            cursorUp(e3) {
              const t4 = this._activeBuffer.y - this._activeBuffer.scrollTop;
              return t4 >= 0 ? this._moveCursor(0, -Math.min(t4, e3.params[0] || 1)) : this._moveCursor(0, -(e3.params[0] || 1)), true;
            }
            cursorDown(e3) {
              const t4 = this._activeBuffer.scrollBottom - this._activeBuffer.y;
              return t4 >= 0 ? this._moveCursor(0, Math.min(t4, e3.params[0] || 1)) : this._moveCursor(0, e3.params[0] || 1), true;
            }
            cursorForward(e3) {
              return this._moveCursor(e3.params[0] || 1, 0), true;
            }
            cursorBackward(e3) {
              return this._moveCursor(-(e3.params[0] || 1), 0), true;
            }
            cursorNextLine(e3) {
              return this.cursorDown(e3), this._activeBuffer.x = 0, true;
            }
            cursorPrecedingLine(e3) {
              return this.cursorUp(e3), this._activeBuffer.x = 0, true;
            }
            cursorCharAbsolute(e3) {
              return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
            }
            cursorPosition(e3) {
              return this._setCursor(e3.length >= 2 ? (e3.params[1] || 1) - 1 : 0, (e3.params[0] || 1) - 1), true;
            }
            charPosAbsolute(e3) {
              return this._setCursor((e3.params[0] || 1) - 1, this._activeBuffer.y), true;
            }
            hPositionRelative(e3) {
              return this._moveCursor(e3.params[0] || 1, 0), true;
            }
            linePosAbsolute(e3) {
              return this._setCursor(this._activeBuffer.x, (e3.params[0] || 1) - 1), true;
            }
            vPositionRelative(e3) {
              return this._moveCursor(0, e3.params[0] || 1), true;
            }
            hVPosition(e3) {
              return this.cursorPosition(e3), true;
            }
            tabClear(e3) {
              const t4 = e3.params[0];
              return 0 === t4 ? delete this._activeBuffer.tabs[this._activeBuffer.x] : 3 === t4 && (this._activeBuffer.tabs = {}), true;
            }
            cursorForwardTab(e3) {
              if (this._activeBuffer.x >= this._bufferService.cols) return true;
              let t4 = e3.params[0] || 1;
              for (; t4--; ) this._activeBuffer.x = this._activeBuffer.nextStop();
              return true;
            }
            cursorBackwardTab(e3) {
              if (this._activeBuffer.x >= this._bufferService.cols) return true;
              let t4 = e3.params[0] || 1;
              for (; t4--; ) this._activeBuffer.x = this._activeBuffer.prevStop();
              return true;
            }
            selectProtected(e3) {
              const t4 = e3.params[0];
              return 1 === t4 && (this._curAttrData.bg |= 536870912), 2 !== t4 && 0 !== t4 || (this._curAttrData.bg &= -536870913), true;
            }
            _eraseInBufferLine(e3, t4, i4, s3 = false, r2 = false) {
              const n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
              n2.replaceCells(t4, i4, this._activeBuffer.getNullCell(this._eraseAttrData()), r2), s3 && (n2.isWrapped = false);
            }
            _resetBufferLine(e3, t4 = false) {
              const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e3);
              i4 && (i4.fill(this._activeBuffer.getNullCell(this._eraseAttrData()), t4), this._bufferService.buffer.clearMarkers(this._activeBuffer.ybase + e3), i4.isWrapped = false);
            }
            eraseInDisplay(e3, t4 = false) {
              let i4;
              switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
                case 0:
                  for (i4 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i4), this._eraseInBufferLine(i4++, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t4); i4 < this._bufferService.rows; i4++) this._resetBufferLine(i4, t4);
                  this._dirtyRowTracker.markDirty(i4);
                  break;
                case 1:
                  for (i4 = this._activeBuffer.y, this._dirtyRowTracker.markDirty(i4), this._eraseInBufferLine(i4, 0, this._activeBuffer.x + 1, true, t4), this._activeBuffer.x + 1 >= this._bufferService.cols && (this._activeBuffer.lines.get(i4 + 1).isWrapped = false); i4--; ) this._resetBufferLine(i4, t4);
                  this._dirtyRowTracker.markDirty(0);
                  break;
                case 2:
                  for (i4 = this._bufferService.rows, this._dirtyRowTracker.markDirty(i4 - 1); i4--; ) this._resetBufferLine(i4, t4);
                  this._dirtyRowTracker.markDirty(0);
                  break;
                case 3:
                  const e4 = this._activeBuffer.lines.length - this._bufferService.rows;
                  e4 > 0 && (this._activeBuffer.lines.trimStart(e4), this._activeBuffer.ybase = Math.max(this._activeBuffer.ybase - e4, 0), this._activeBuffer.ydisp = Math.max(this._activeBuffer.ydisp - e4, 0), this._onScroll.fire(0));
              }
              return true;
            }
            eraseInLine(e3, t4 = false) {
              switch (this._restrictCursor(this._bufferService.cols), e3.params[0]) {
                case 0:
                  this._eraseInBufferLine(this._activeBuffer.y, this._activeBuffer.x, this._bufferService.cols, 0 === this._activeBuffer.x, t4);
                  break;
                case 1:
                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._activeBuffer.x + 1, false, t4);
                  break;
                case 2:
                  this._eraseInBufferLine(this._activeBuffer.y, 0, this._bufferService.cols, true, t4);
              }
              return this._dirtyRowTracker.markDirty(this._activeBuffer.y), true;
            }
            insertLines(e3) {
              this._restrictCursor();
              let t4 = e3.params[0] || 1;
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
              const i4 = this._activeBuffer.ybase + this._activeBuffer.y, s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, r2 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3 + 1;
              for (; t4--; ) this._activeBuffer.lines.splice(r2 - 1, 1), this._activeBuffer.lines.splice(i4, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
            }
            deleteLines(e3) {
              this._restrictCursor();
              let t4 = e3.params[0] || 1;
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
              const i4 = this._activeBuffer.ybase + this._activeBuffer.y;
              let s3;
              for (s3 = this._bufferService.rows - 1 - this._activeBuffer.scrollBottom, s3 = this._bufferService.rows - 1 + this._activeBuffer.ybase - s3; t4--; ) this._activeBuffer.lines.splice(i4, 1), this._activeBuffer.lines.splice(s3, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.y, this._activeBuffer.scrollBottom), this._activeBuffer.x = 0, true;
            }
            insertChars(e3) {
              this._restrictCursor();
              const t4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t4 && (t4.insertCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            deleteChars(e3) {
              this._restrictCursor();
              const t4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t4 && (t4.deleteCells(this._activeBuffer.x, e3.params[0] || 1, this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            scrollUp(e3) {
              let t4 = e3.params[0] || 1;
              for (; t4--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 0, this._activeBuffer.getBlankLine(this._eraseAttrData()));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollDown(e3) {
              let t4 = e3.params[0] || 1;
              for (; t4--; ) this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollBottom, 1), this._activeBuffer.lines.splice(this._activeBuffer.ybase + this._activeBuffer.scrollTop, 0, this._activeBuffer.getBlankLine(l.DEFAULT_ATTR_DATA));
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollLeft(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
              const t4 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i4.deleteCells(0, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            scrollRight(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
              const t4 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i4.insertCells(0, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            insertColumns(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
              const t4 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i4.insertCells(this._activeBuffer.x, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            deleteColumns(e3) {
              if (this._activeBuffer.y > this._activeBuffer.scrollBottom || this._activeBuffer.y < this._activeBuffer.scrollTop) return true;
              const t4 = e3.params[0] || 1;
              for (let e4 = this._activeBuffer.scrollTop; e4 <= this._activeBuffer.scrollBottom; ++e4) {
                const i4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + e4);
                i4.deleteCells(this._activeBuffer.x, t4, this._activeBuffer.getNullCell(this._eraseAttrData())), i4.isWrapped = false;
              }
              return this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom), true;
            }
            eraseChars(e3) {
              this._restrictCursor();
              const t4 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y);
              return t4 && (t4.replaceCells(this._activeBuffer.x, this._activeBuffer.x + (e3.params[0] || 1), this._activeBuffer.getNullCell(this._eraseAttrData())), this._dirtyRowTracker.markDirty(this._activeBuffer.y)), true;
            }
            repeatPrecedingCharacter(e3) {
              const t4 = this._parser.precedingJoinState;
              if (!t4) return true;
              const i4 = e3.params[0] || 1, s3 = p.UnicodeService.extractWidth(t4), r2 = this._activeBuffer.x - s3, n2 = this._activeBuffer.lines.get(this._activeBuffer.ybase + this._activeBuffer.y).getString(r2), o2 = new Uint32Array(n2.length * i4);
              let a2 = 0;
              for (let e4 = 0; e4 < n2.length; ) {
                const t5 = n2.codePointAt(e4) || 0;
                o2[a2++] = t5, e4 += t5 > 65535 ? 2 : 1;
              }
              let h2 = a2;
              for (let e4 = 1; e4 < i4; ++e4) o2.copyWithin(h2, 0, a2), h2 += a2;
              return this.print(o2, 0, h2), true;
            }
            sendDeviceAttributesPrimary(e3) {
              return e3.params[0] > 0 || (this._is("xterm") || this._is("rxvt-unicode") || this._is("screen") ? this._coreService.triggerDataEvent(n.C0.ESC + "[?1;2c") : this._is("linux") && this._coreService.triggerDataEvent(n.C0.ESC + "[?6c")), true;
            }
            sendDeviceAttributesSecondary(e3) {
              return e3.params[0] > 0 || (this._is("xterm") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>0;276;0c") : this._is("rxvt-unicode") ? this._coreService.triggerDataEvent(n.C0.ESC + "[>85;95;0c") : this._is("linux") ? this._coreService.triggerDataEvent(e3.params[0] + "c") : this._is("screen") && this._coreService.triggerDataEvent(n.C0.ESC + "[>83;40003;0c")), true;
            }
            _is(e3) {
              return 0 === (this._optionsService.rawOptions.termName + "").indexOf(e3);
            }
            setMode(e3) {
              for (let t4 = 0; t4 < e3.length; t4++) switch (e3.params[t4]) {
                case 4:
                  this._coreService.modes.insertMode = true;
                  break;
                case 20:
                  this._optionsService.options.convertEol = true;
              }
              return true;
            }
            setModePrivate(e3) {
              for (let t4 = 0; t4 < e3.length; t4++) switch (e3.params[t4]) {
                case 1:
                  this._coreService.decPrivateModes.applicationCursorKeys = true;
                  break;
                case 2:
                  this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), this._charsetService.setgCharset(1, o.DEFAULT_CHARSET), this._charsetService.setgCharset(2, o.DEFAULT_CHARSET), this._charsetService.setgCharset(3, o.DEFAULT_CHARSET);
                  break;
                case 3:
                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(132, this._bufferService.rows), this._onRequestReset.fire());
                  break;
                case 6:
                  this._coreService.decPrivateModes.origin = true, this._setCursor(0, 0);
                  break;
                case 7:
                  this._coreService.decPrivateModes.wraparound = true;
                  break;
                case 12:
                  this._optionsService.options.cursorBlink = true;
                  break;
                case 45:
                  this._coreService.decPrivateModes.reverseWraparound = true;
                  break;
                case 66:
                  this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire();
                  break;
                case 9:
                  this._coreMouseService.activeProtocol = "X10";
                  break;
                case 1e3:
                  this._coreMouseService.activeProtocol = "VT200";
                  break;
                case 1002:
                  this._coreMouseService.activeProtocol = "DRAG";
                  break;
                case 1003:
                  this._coreMouseService.activeProtocol = "ANY";
                  break;
                case 1004:
                  this._coreService.decPrivateModes.sendFocus = true, this._onRequestSendFocus.fire();
                  break;
                case 1005:
                  this._logService.debug("DECSET 1005 not supported (see #2507)");
                  break;
                case 1006:
                  this._coreMouseService.activeEncoding = "SGR";
                  break;
                case 1015:
                  this._logService.debug("DECSET 1015 not supported (see #2507)");
                  break;
                case 1016:
                  this._coreMouseService.activeEncoding = "SGR_PIXELS";
                  break;
                case 25:
                  this._coreService.isCursorHidden = false;
                  break;
                case 1048:
                  this.saveCursor();
                  break;
                case 1049:
                  this.saveCursor();
                case 47:
                case 1047:
                  this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                  break;
                case 2004:
                  this._coreService.decPrivateModes.bracketedPasteMode = true;
              }
              return true;
            }
            resetMode(e3) {
              for (let t4 = 0; t4 < e3.length; t4++) switch (e3.params[t4]) {
                case 4:
                  this._coreService.modes.insertMode = false;
                  break;
                case 20:
                  this._optionsService.options.convertEol = false;
              }
              return true;
            }
            resetModePrivate(e3) {
              for (let t4 = 0; t4 < e3.length; t4++) switch (e3.params[t4]) {
                case 1:
                  this._coreService.decPrivateModes.applicationCursorKeys = false;
                  break;
                case 3:
                  this._optionsService.rawOptions.windowOptions.setWinLines && (this._bufferService.resize(80, this._bufferService.rows), this._onRequestReset.fire());
                  break;
                case 6:
                  this._coreService.decPrivateModes.origin = false, this._setCursor(0, 0);
                  break;
                case 7:
                  this._coreService.decPrivateModes.wraparound = false;
                  break;
                case 12:
                  this._optionsService.options.cursorBlink = false;
                  break;
                case 45:
                  this._coreService.decPrivateModes.reverseWraparound = false;
                  break;
                case 66:
                  this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire();
                  break;
                case 9:
                case 1e3:
                case 1002:
                case 1003:
                  this._coreMouseService.activeProtocol = "NONE";
                  break;
                case 1004:
                  this._coreService.decPrivateModes.sendFocus = false;
                  break;
                case 1005:
                  this._logService.debug("DECRST 1005 not supported (see #2507)");
                  break;
                case 1006:
                case 1016:
                  this._coreMouseService.activeEncoding = "DEFAULT";
                  break;
                case 1015:
                  this._logService.debug("DECRST 1015 not supported (see #2507)");
                  break;
                case 25:
                  this._coreService.isCursorHidden = true;
                  break;
                case 1048:
                  this.restoreCursor();
                  break;
                case 1049:
                case 47:
                case 1047:
                  this._bufferService.buffers.activateNormalBuffer(), 1049 === e3.params[t4] && this.restoreCursor(), this._coreService.isCursorInitialized = true, this._onRequestRefreshRows.fire(0, this._bufferService.rows - 1), this._onRequestSyncScrollBar.fire();
                  break;
                case 2004:
                  this._coreService.decPrivateModes.bracketedPasteMode = false;
              }
              return true;
            }
            requestMode(e3, t4) {
              const i4 = this._coreService.decPrivateModes, { activeProtocol: s3, activeEncoding: r2 } = this._coreMouseService, o2 = this._coreService, { buffers: a2, cols: h2 } = this._bufferService, { active: c2, alt: l2 } = a2, d2 = this._optionsService.rawOptions, _2 = (e4) => e4 ? 1 : 2, u2 = e3.params[0];
              return f2 = u2, v2 = t4 ? 2 === u2 ? 4 : 4 === u2 ? _2(o2.modes.insertMode) : 12 === u2 ? 3 : 20 === u2 ? _2(d2.convertEol) : 0 : 1 === u2 ? _2(i4.applicationCursorKeys) : 3 === u2 ? d2.windowOptions.setWinLines ? 80 === h2 ? 2 : 132 === h2 ? 1 : 0 : 0 : 6 === u2 ? _2(i4.origin) : 7 === u2 ? _2(i4.wraparound) : 8 === u2 ? 3 : 9 === u2 ? _2("X10" === s3) : 12 === u2 ? _2(d2.cursorBlink) : 25 === u2 ? _2(!o2.isCursorHidden) : 45 === u2 ? _2(i4.reverseWraparound) : 66 === u2 ? _2(i4.applicationKeypad) : 67 === u2 ? 4 : 1e3 === u2 ? _2("VT200" === s3) : 1002 === u2 ? _2("DRAG" === s3) : 1003 === u2 ? _2("ANY" === s3) : 1004 === u2 ? _2(i4.sendFocus) : 1005 === u2 ? 4 : 1006 === u2 ? _2("SGR" === r2) : 1015 === u2 ? 4 : 1016 === u2 ? _2("SGR_PIXELS" === r2) : 1048 === u2 ? 1 : 47 === u2 || 1047 === u2 || 1049 === u2 ? _2(c2 === l2) : 2004 === u2 ? _2(i4.bracketedPasteMode) : 0, o2.triggerDataEvent(`${n.C0.ESC}[${t4 ? "" : "?"}${f2};${v2}$y`), true;
              var f2, v2;
            }
            _updateAttrColor(e3, t4, i4, s3, r2) {
              return 2 === t4 ? (e3 |= 50331648, e3 &= -16777216, e3 |= f.AttributeData.fromColorRGB([
                i4,
                s3,
                r2
              ])) : 5 === t4 && (e3 &= -50331904, e3 |= 33554432 | 255 & i4), e3;
            }
            _extractColor(e3, t4, i4) {
              const s3 = [
                0,
                0,
                -1,
                0,
                0,
                0
              ];
              let r2 = 0, n2 = 0;
              do {
                if (s3[n2 + r2] = e3.params[t4 + n2], e3.hasSubParams(t4 + n2)) {
                  const i5 = e3.getSubParams(t4 + n2);
                  let o2 = 0;
                  do {
                    5 === s3[1] && (r2 = 1), s3[n2 + o2 + 1 + r2] = i5[o2];
                  } while (++o2 < i5.length && o2 + n2 + 1 + r2 < s3.length);
                  break;
                }
                if (5 === s3[1] && n2 + r2 >= 2 || 2 === s3[1] && n2 + r2 >= 5) break;
                s3[1] && (r2 = 1);
              } while (++n2 + t4 < e3.length && n2 + r2 < s3.length);
              for (let e4 = 2; e4 < s3.length; ++e4) -1 === s3[e4] && (s3[e4] = 0);
              switch (s3[0]) {
                case 38:
                  i4.fg = this._updateAttrColor(i4.fg, s3[1], s3[3], s3[4], s3[5]);
                  break;
                case 48:
                  i4.bg = this._updateAttrColor(i4.bg, s3[1], s3[3], s3[4], s3[5]);
                  break;
                case 58:
                  i4.extended = i4.extended.clone(), i4.extended.underlineColor = this._updateAttrColor(i4.extended.underlineColor, s3[1], s3[3], s3[4], s3[5]);
              }
              return n2;
            }
            _processUnderline(e3, t4) {
              t4.extended = t4.extended.clone(), (!~e3 || e3 > 5) && (e3 = 1), t4.extended.underlineStyle = e3, t4.fg |= 268435456, 0 === e3 && (t4.fg &= -268435457), t4.updateExtended();
            }
            _processSGR0(e3) {
              e3.fg = l.DEFAULT_ATTR_DATA.fg, e3.bg = l.DEFAULT_ATTR_DATA.bg, e3.extended = e3.extended.clone(), e3.extended.underlineStyle = 0, e3.extended.underlineColor &= -67108864, e3.updateExtended();
            }
            charAttributes(e3) {
              if (1 === e3.length && 0 === e3.params[0]) return this._processSGR0(this._curAttrData), true;
              const t4 = e3.length;
              let i4;
              const s3 = this._curAttrData;
              for (let r2 = 0; r2 < t4; r2++) i4 = e3.params[r2], i4 >= 30 && i4 <= 37 ? (s3.fg &= -50331904, s3.fg |= 16777216 | i4 - 30) : i4 >= 40 && i4 <= 47 ? (s3.bg &= -50331904, s3.bg |= 16777216 | i4 - 40) : i4 >= 90 && i4 <= 97 ? (s3.fg &= -50331904, s3.fg |= 16777224 | i4 - 90) : i4 >= 100 && i4 <= 107 ? (s3.bg &= -50331904, s3.bg |= 16777224 | i4 - 100) : 0 === i4 ? this._processSGR0(s3) : 1 === i4 ? s3.fg |= 134217728 : 3 === i4 ? s3.bg |= 67108864 : 4 === i4 ? (s3.fg |= 268435456, this._processUnderline(e3.hasSubParams(r2) ? e3.getSubParams(r2)[0] : 1, s3)) : 5 === i4 ? s3.fg |= 536870912 : 7 === i4 ? s3.fg |= 67108864 : 8 === i4 ? s3.fg |= 1073741824 : 9 === i4 ? s3.fg |= 2147483648 : 2 === i4 ? s3.bg |= 134217728 : 21 === i4 ? this._processUnderline(2, s3) : 22 === i4 ? (s3.fg &= -134217729, s3.bg &= -134217729) : 23 === i4 ? s3.bg &= -67108865 : 24 === i4 ? (s3.fg &= -268435457, this._processUnderline(0, s3)) : 25 === i4 ? s3.fg &= -536870913 : 27 === i4 ? s3.fg &= -67108865 : 28 === i4 ? s3.fg &= -1073741825 : 29 === i4 ? s3.fg &= 2147483647 : 39 === i4 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg) : 49 === i4 ? (s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : 38 === i4 || 48 === i4 || 58 === i4 ? r2 += this._extractColor(e3, r2, s3) : 53 === i4 ? s3.bg |= 1073741824 : 55 === i4 ? s3.bg &= -1073741825 : 59 === i4 ? (s3.extended = s3.extended.clone(), s3.extended.underlineColor = -1, s3.updateExtended()) : 100 === i4 ? (s3.fg &= -67108864, s3.fg |= 16777215 & l.DEFAULT_ATTR_DATA.fg, s3.bg &= -67108864, s3.bg |= 16777215 & l.DEFAULT_ATTR_DATA.bg) : this._logService.debug("Unknown SGR attribute: %d.", i4);
              return true;
            }
            deviceStatus(e3) {
              switch (e3.params[0]) {
                case 5:
                  this._coreService.triggerDataEvent(`${n.C0.ESC}[0n`);
                  break;
                case 6:
                  const e4 = this._activeBuffer.y + 1, t4 = this._activeBuffer.x + 1;
                  this._coreService.triggerDataEvent(`${n.C0.ESC}[${e4};${t4}R`);
              }
              return true;
            }
            deviceStatusPrivate(e3) {
              if (6 === e3.params[0]) {
                const e4 = this._activeBuffer.y + 1, t4 = this._activeBuffer.x + 1;
                this._coreService.triggerDataEvent(`${n.C0.ESC}[?${e4};${t4}R`);
              }
              return true;
            }
            softReset(e3) {
              return this._coreService.isCursorHidden = false, this._onRequestSyncScrollBar.fire(), this._activeBuffer.scrollTop = 0, this._activeBuffer.scrollBottom = this._bufferService.rows - 1, this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._coreService.reset(), this._charsetService.reset(), this._activeBuffer.savedX = 0, this._activeBuffer.savedY = this._activeBuffer.ybase, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, this._coreService.decPrivateModes.origin = false, true;
            }
            setCursorStyle(e3) {
              const t4 = e3.params[0] || 1;
              switch (t4) {
                case 1:
                case 2:
                  this._optionsService.options.cursorStyle = "block";
                  break;
                case 3:
                case 4:
                  this._optionsService.options.cursorStyle = "underline";
                  break;
                case 5:
                case 6:
                  this._optionsService.options.cursorStyle = "bar";
              }
              const i4 = t4 % 2 == 1;
              return this._optionsService.options.cursorBlink = i4, true;
            }
            setScrollRegion(e3) {
              const t4 = e3.params[0] || 1;
              let i4;
              return (e3.length < 2 || (i4 = e3.params[1]) > this._bufferService.rows || 0 === i4) && (i4 = this._bufferService.rows), i4 > t4 && (this._activeBuffer.scrollTop = t4 - 1, this._activeBuffer.scrollBottom = i4 - 1, this._setCursor(0, 0)), true;
            }
            windowOptions(e3) {
              if (!w(e3.params[0], this._optionsService.rawOptions.windowOptions)) return true;
              const t4 = e3.length > 1 ? e3.params[1] : 0;
              switch (e3.params[0]) {
                case 14:
                  2 !== t4 && this._onRequestWindowsOptionsReport.fire(y.GET_WIN_SIZE_PIXELS);
                  break;
                case 16:
                  this._onRequestWindowsOptionsReport.fire(y.GET_CELL_SIZE_PIXELS);
                  break;
                case 18:
                  this._bufferService && this._coreService.triggerDataEvent(`${n.C0.ESC}[8;${this._bufferService.rows};${this._bufferService.cols}t`);
                  break;
                case 22:
                  0 !== t4 && 2 !== t4 || (this._windowTitleStack.push(this._windowTitle), this._windowTitleStack.length > 10 && this._windowTitleStack.shift()), 0 !== t4 && 1 !== t4 || (this._iconNameStack.push(this._iconName), this._iconNameStack.length > 10 && this._iconNameStack.shift());
                  break;
                case 23:
                  0 !== t4 && 2 !== t4 || this._windowTitleStack.length && this.setTitle(this._windowTitleStack.pop()), 0 !== t4 && 1 !== t4 || this._iconNameStack.length && this.setIconName(this._iconNameStack.pop());
              }
              return true;
            }
            saveCursor(e3) {
              return this._activeBuffer.savedX = this._activeBuffer.x, this._activeBuffer.savedY = this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.savedCurAttrData.fg = this._curAttrData.fg, this._activeBuffer.savedCurAttrData.bg = this._curAttrData.bg, this._activeBuffer.savedCharset = this._charsetService.charset, true;
            }
            restoreCursor(e3) {
              return this._activeBuffer.x = this._activeBuffer.savedX || 0, this._activeBuffer.y = Math.max(this._activeBuffer.savedY - this._activeBuffer.ybase, 0), this._curAttrData.fg = this._activeBuffer.savedCurAttrData.fg, this._curAttrData.bg = this._activeBuffer.savedCurAttrData.bg, this._charsetService.charset = this._savedCharset, this._activeBuffer.savedCharset && (this._charsetService.charset = this._activeBuffer.savedCharset), this._restrictCursor(), true;
            }
            setTitle(e3) {
              return this._windowTitle = e3, this._onTitleChange.fire(e3), true;
            }
            setIconName(e3) {
              return this._iconName = e3, true;
            }
            setOrReportIndexedColor(e3) {
              const t4 = [], i4 = e3.split(";");
              for (; i4.length > 1; ) {
                const e4 = i4.shift(), s3 = i4.shift();
                if (/^\d+$/.exec(e4)) {
                  const i5 = parseInt(e4);
                  if (D(i5)) if ("?" === s3) t4.push({
                    type: 0,
                    index: i5
                  });
                  else {
                    const e5 = (0, S.parseColor)(s3);
                    e5 && t4.push({
                      type: 1,
                      index: i5,
                      color: e5
                    });
                  }
                }
              }
              return t4.length && this._onColor.fire(t4), true;
            }
            setHyperlink(e3) {
              const t4 = e3.split(";");
              return !(t4.length < 2) && (t4[1] ? this._createHyperlink(t4[0], t4[1]) : !t4[0] && this._finishHyperlink());
            }
            _createHyperlink(e3, t4) {
              this._getCurrentLinkId() && this._finishHyperlink();
              const i4 = e3.split(":");
              let s3;
              const r2 = i4.findIndex((e4) => e4.startsWith("id="));
              return -1 !== r2 && (s3 = i4[r2].slice(3) || void 0), this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = this._oscLinkService.registerLink({
                id: s3,
                uri: t4
              }), this._curAttrData.updateExtended(), true;
            }
            _finishHyperlink() {
              return this._curAttrData.extended = this._curAttrData.extended.clone(), this._curAttrData.extended.urlId = 0, this._curAttrData.updateExtended(), true;
            }
            _setOrReportSpecialColor(e3, t4) {
              const i4 = e3.split(";");
              for (let e4 = 0; e4 < i4.length && !(t4 >= this._specialColors.length); ++e4, ++t4) if ("?" === i4[e4]) this._onColor.fire([
                {
                  type: 0,
                  index: this._specialColors[t4]
                }
              ]);
              else {
                const s3 = (0, S.parseColor)(i4[e4]);
                s3 && this._onColor.fire([
                  {
                    type: 1,
                    index: this._specialColors[t4],
                    color: s3
                  }
                ]);
              }
              return true;
            }
            setOrReportFgColor(e3) {
              return this._setOrReportSpecialColor(e3, 0);
            }
            setOrReportBgColor(e3) {
              return this._setOrReportSpecialColor(e3, 1);
            }
            setOrReportCursorColor(e3) {
              return this._setOrReportSpecialColor(e3, 2);
            }
            restoreIndexedColor(e3) {
              if (!e3) return this._onColor.fire([
                {
                  type: 2
                }
              ]), true;
              const t4 = [], i4 = e3.split(";");
              for (let e4 = 0; e4 < i4.length; ++e4) if (/^\d+$/.exec(i4[e4])) {
                const s3 = parseInt(i4[e4]);
                D(s3) && t4.push({
                  type: 2,
                  index: s3
                });
              }
              return t4.length && this._onColor.fire(t4), true;
            }
            restoreFgColor(e3) {
              return this._onColor.fire([
                {
                  type: 2,
                  index: 256
                }
              ]), true;
            }
            restoreBgColor(e3) {
              return this._onColor.fire([
                {
                  type: 2,
                  index: 257
                }
              ]), true;
            }
            restoreCursorColor(e3) {
              return this._onColor.fire([
                {
                  type: 2,
                  index: 258
                }
              ]), true;
            }
            nextLine() {
              return this._activeBuffer.x = 0, this.index(), true;
            }
            keypadApplicationMode() {
              return this._logService.debug("Serial port requested application keypad."), this._coreService.decPrivateModes.applicationKeypad = true, this._onRequestSyncScrollBar.fire(), true;
            }
            keypadNumericMode() {
              return this._logService.debug("Switching back to normal keypad."), this._coreService.decPrivateModes.applicationKeypad = false, this._onRequestSyncScrollBar.fire(), true;
            }
            selectDefaultCharset() {
              return this._charsetService.setgLevel(0), this._charsetService.setgCharset(0, o.DEFAULT_CHARSET), true;
            }
            selectCharset(e3) {
              return 2 !== e3.length ? (this.selectDefaultCharset(), true) : ("/" === e3[0] || this._charsetService.setgCharset(C2[e3[0]], o.CHARSETS[e3[1]] || o.DEFAULT_CHARSET), true);
            }
            index() {
              return this._restrictCursor(), this._activeBuffer.y++, this._activeBuffer.y === this._activeBuffer.scrollBottom + 1 ? (this._activeBuffer.y--, this._bufferService.scroll(this._eraseAttrData())) : this._activeBuffer.y >= this._bufferService.rows && (this._activeBuffer.y = this._bufferService.rows - 1), this._restrictCursor(), true;
            }
            tabSet() {
              return this._activeBuffer.tabs[this._activeBuffer.x] = true, true;
            }
            reverseIndex() {
              if (this._restrictCursor(), this._activeBuffer.y === this._activeBuffer.scrollTop) {
                const e3 = this._activeBuffer.scrollBottom - this._activeBuffer.scrollTop;
                this._activeBuffer.lines.shiftElements(this._activeBuffer.ybase + this._activeBuffer.y, e3, 1), this._activeBuffer.lines.set(this._activeBuffer.ybase + this._activeBuffer.y, this._activeBuffer.getBlankLine(this._eraseAttrData())), this._dirtyRowTracker.markRangeDirty(this._activeBuffer.scrollTop, this._activeBuffer.scrollBottom);
              } else this._activeBuffer.y--, this._restrictCursor();
              return true;
            }
            fullReset() {
              return this._parser.reset(), this._onRequestReset.fire(), true;
            }
            reset() {
              this._curAttrData = l.DEFAULT_ATTR_DATA.clone(), this._eraseAttrDataInternal = l.DEFAULT_ATTR_DATA.clone();
            }
            _eraseAttrData() {
              return this._eraseAttrDataInternal.bg &= -67108864, this._eraseAttrDataInternal.bg |= 67108863 & this._curAttrData.bg, this._eraseAttrDataInternal;
            }
            setgLevel(e3) {
              return this._charsetService.setgLevel(e3), true;
            }
            screenAlignmentPattern() {
              const e3 = new u.CellData();
              e3.content = 1 << 22 | "E".charCodeAt(0), e3.fg = this._curAttrData.fg, e3.bg = this._curAttrData.bg, this._setCursor(0, 0);
              for (let t4 = 0; t4 < this._bufferService.rows; ++t4) {
                const i4 = this._activeBuffer.ybase + this._activeBuffer.y + t4, s3 = this._activeBuffer.lines.get(i4);
                s3 && (s3.fill(e3), s3.isWrapped = false);
              }
              return this._dirtyRowTracker.markAllDirty(), this._setCursor(0, 0), true;
            }
            requestStatusString(e3, t4) {
              const i4 = this._bufferService.buffer, s3 = this._optionsService.rawOptions;
              return ((e4) => (this._coreService.triggerDataEvent(`${n.C0.ESC}${e4}${n.C0.ESC}\\`), true))('"q' === e3 ? `P1$r${this._curAttrData.isProtected() ? 1 : 0}"q` : '"p' === e3 ? 'P1$r61;1"p' : "r" === e3 ? `P1$r${i4.scrollTop + 1};${i4.scrollBottom + 1}r` : "m" === e3 ? "P1$r0m" : " q" === e3 ? `P1$r${{
                block: 2,
                underline: 4,
                bar: 6
              }[s3.cursorStyle] - (s3.cursorBlink ? 1 : 0)} q` : "P0$r");
            }
            markRangeDirty(e3, t4) {
              this._dirtyRowTracker.markRangeDirty(e3, t4);
            }
          }
          t3.InputHandler = k;
          let L = class {
            constructor(e3) {
              this._bufferService = e3, this.clearRange();
            }
            clearRange() {
              this.start = this._bufferService.buffer.y, this.end = this._bufferService.buffer.y;
            }
            markDirty(e3) {
              e3 < this.start ? this.start = e3 : e3 > this.end && (this.end = e3);
            }
            markRangeDirty(e3, t4) {
              e3 > t4 && (E = e3, e3 = t4, t4 = E), e3 < this.start && (this.start = e3), t4 > this.end && (this.end = t4);
            }
            markAllDirty() {
              this.markRangeDirty(0, this._bufferService.rows - 1);
            }
          };
          function D(e3) {
            return 0 <= e3 && e3 < 256;
          }
          L = s2([
            r(0, v.IBufferService)
          ], L);
        },
        844: (e2, t3) => {
          function i3(e3) {
            for (const t4 of e3) t4.dispose();
            e3.length = 0;
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.getDisposeArrayDisposable = t3.disposeArray = t3.toDisposable = t3.MutableDisposable = t3.Disposable = void 0, t3.Disposable = class {
            constructor() {
              this._disposables = [], this._isDisposed = false;
            }
            dispose() {
              this._isDisposed = true;
              for (const e3 of this._disposables) e3.dispose();
              this._disposables.length = 0;
            }
            register(e3) {
              return this._disposables.push(e3), e3;
            }
            unregister(e3) {
              const t4 = this._disposables.indexOf(e3);
              -1 !== t4 && this._disposables.splice(t4, 1);
            }
          }, t3.MutableDisposable = class {
            constructor() {
              this._isDisposed = false;
            }
            get value() {
              return this._isDisposed ? void 0 : this._value;
            }
            set value(e3) {
              var _a2;
              this._isDisposed || e3 === this._value || ((_a2 = this._value) == null ? void 0 : _a2.dispose(), this._value = e3);
            }
            clear() {
              this.value = void 0;
            }
            dispose() {
              var _a2;
              this._isDisposed = true, (_a2 = this._value) == null ? void 0 : _a2.dispose(), this._value = void 0;
            }
          }, t3.toDisposable = function(e3) {
            return {
              dispose: e3
            };
          }, t3.disposeArray = i3, t3.getDisposeArrayDisposable = function(e3) {
            return {
              dispose: () => i3(e3)
            };
          };
        },
        1505: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.FourKeyMap = t3.TwoKeyMap = void 0;
          class i3 {
            constructor() {
              this._data = {};
            }
            set(e3, t4, i4) {
              this._data[e3] || (this._data[e3] = {}), this._data[e3][t4] = i4;
            }
            get(e3, t4) {
              return this._data[e3] ? this._data[e3][t4] : void 0;
            }
            clear() {
              this._data = {};
            }
          }
          t3.TwoKeyMap = i3, t3.FourKeyMap = class {
            constructor() {
              this._data = new i3();
            }
            set(e3, t4, s2, r, n) {
              this._data.get(e3, t4) || this._data.set(e3, t4, new i3()), this._data.get(e3, t4).set(s2, r, n);
            }
            get(e3, t4, i4, s2) {
              var _a2;
              return (_a2 = this._data.get(e3, t4)) == null ? void 0 : _a2.get(i4, s2);
            }
            clear() {
              this._data.clear();
            }
          };
        },
        6114: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.isChromeOS = t3.isLinux = t3.isWindows = t3.isIphone = t3.isIpad = t3.isMac = t3.getSafariVersion = t3.isSafari = t3.isLegacyEdge = t3.isFirefox = t3.isNode = void 0, t3.isNode = "undefined" != typeof process$1 && "title" in process$1;
          const i3 = t3.isNode ? "node" : navigator.userAgent, s2 = t3.isNode ? "node" : navigator.platform;
          t3.isFirefox = i3.includes("Firefox"), t3.isLegacyEdge = i3.includes("Edge"), t3.isSafari = /^((?!chrome|android).)*safari/i.test(i3), t3.getSafariVersion = function() {
            if (!t3.isSafari) return 0;
            const e3 = i3.match(/Version\/(\d+)/);
            return null === e3 || e3.length < 2 ? 0 : parseInt(e3[1]);
          }, t3.isMac = [
            "Macintosh",
            "MacIntel",
            "MacPPC",
            "Mac68K"
          ].includes(s2), t3.isIpad = "iPad" === s2, t3.isIphone = "iPhone" === s2, t3.isWindows = [
            "Windows",
            "Win16",
            "Win32",
            "WinCE"
          ].includes(s2), t3.isLinux = s2.indexOf("Linux") >= 0, t3.isChromeOS = /\bCrOS\b/.test(i3);
        },
        6106: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.SortedList = void 0;
          let i3 = 0;
          t3.SortedList = class {
            constructor(e3) {
              this._getKey = e3, this._array = [];
            }
            clear() {
              this._array.length = 0;
            }
            insert(e3) {
              0 !== this._array.length ? (i3 = this._search(this._getKey(e3)), this._array.splice(i3, 0, e3)) : this._array.push(e3);
            }
            delete(e3) {
              if (0 === this._array.length) return false;
              const t4 = this._getKey(e3);
              if (void 0 === t4) return false;
              if (i3 = this._search(t4), -1 === i3) return false;
              if (this._getKey(this._array[i3]) !== t4) return false;
              do {
                if (this._array[i3] === e3) return this._array.splice(i3, 1), true;
              } while (++i3 < this._array.length && this._getKey(this._array[i3]) === t4);
              return false;
            }
            *getKeyIterator(e3) {
              if (0 !== this._array.length && (i3 = this._search(e3), !(i3 < 0 || i3 >= this._array.length) && this._getKey(this._array[i3]) === e3)) do {
                yield this._array[i3];
              } while (++i3 < this._array.length && this._getKey(this._array[i3]) === e3);
            }
            forEachByKey(e3, t4) {
              if (0 !== this._array.length && (i3 = this._search(e3), !(i3 < 0 || i3 >= this._array.length) && this._getKey(this._array[i3]) === e3)) do {
                t4(this._array[i3]);
              } while (++i3 < this._array.length && this._getKey(this._array[i3]) === e3);
            }
            values() {
              return [
                ...this._array
              ].values();
            }
            _search(e3) {
              let t4 = 0, i4 = this._array.length - 1;
              for (; i4 >= t4; ) {
                let s2 = t4 + i4 >> 1;
                const r = this._getKey(this._array[s2]);
                if (r > e3) i4 = s2 - 1;
                else {
                  if (!(r < e3)) {
                    for (; s2 > 0 && this._getKey(this._array[s2 - 1]) === e3; ) s2--;
                    return s2;
                  }
                  t4 = s2 + 1;
                }
              }
              return t4;
            }
          };
        },
        7226: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.DebouncedIdleTask = t3.IdleTaskQueue = t3.PriorityTaskQueue = void 0;
          const s2 = i3(6114);
          class r {
            constructor() {
              this._tasks = [], this._i = 0;
            }
            enqueue(e3) {
              this._tasks.push(e3), this._start();
            }
            flush() {
              for (; this._i < this._tasks.length; ) this._tasks[this._i]() || this._i++;
              this.clear();
            }
            clear() {
              this._idleCallback && (this._cancelCallback(this._idleCallback), this._idleCallback = void 0), this._i = 0, this._tasks.length = 0;
            }
            _start() {
              this._idleCallback || (this._idleCallback = this._requestCallback(this._process.bind(this)));
            }
            _process(e3) {
              this._idleCallback = void 0;
              let t4 = 0, i4 = 0, s3 = e3.timeRemaining(), r2 = 0;
              for (; this._i < this._tasks.length; ) {
                if (t4 = Date.now(), this._tasks[this._i]() || this._i++, t4 = Math.max(1, Date.now() - t4), i4 = Math.max(t4, i4), r2 = e3.timeRemaining(), 1.5 * i4 > r2) return s3 - t4 < -20 && console.warn(`task queue exceeded allotted deadline by ${Math.abs(Math.round(s3 - t4))}ms`), void this._start();
                s3 = r2;
              }
              this.clear();
            }
          }
          class n extends r {
            _requestCallback(e3) {
              return setTimeout(() => e3(this._createDeadline(16)));
            }
            _cancelCallback(e3) {
              clearTimeout(e3);
            }
            _createDeadline(e3) {
              const t4 = Date.now() + e3;
              return {
                timeRemaining: () => Math.max(0, t4 - Date.now())
              };
            }
          }
          t3.PriorityTaskQueue = n, t3.IdleTaskQueue = !s2.isNode && "requestIdleCallback" in window ? class extends r {
            _requestCallback(e3) {
              return requestIdleCallback(e3);
            }
            _cancelCallback(e3) {
              cancelIdleCallback(e3);
            }
          } : n, t3.DebouncedIdleTask = class {
            constructor() {
              this._queue = new t3.IdleTaskQueue();
            }
            set(e3) {
              this._queue.clear(), this._queue.enqueue(e3);
            }
            flush() {
              this._queue.flush();
            }
          };
        },
        9282: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.updateWindowsModeWrappedState = void 0;
          const s2 = i3(643);
          t3.updateWindowsModeWrappedState = function(e3) {
            const t4 = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y - 1), i4 = t4 == null ? void 0 : t4.get(e3.cols - 1), r = e3.buffer.lines.get(e3.buffer.ybase + e3.buffer.y);
            r && i4 && (r.isWrapped = i4[s2.CHAR_DATA_CODE_INDEX] !== s2.NULL_CELL_CODE && i4[s2.CHAR_DATA_CODE_INDEX] !== s2.WHITESPACE_CELL_CODE);
          };
        },
        3734: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.ExtendedAttrs = t3.AttributeData = void 0;
          class i3 {
            constructor() {
              this.fg = 0, this.bg = 0, this.extended = new s2();
            }
            static toColorRGB(e3) {
              return [
                e3 >>> 16 & 255,
                e3 >>> 8 & 255,
                255 & e3
              ];
            }
            static fromColorRGB(e3) {
              return (255 & e3[0]) << 16 | (255 & e3[1]) << 8 | 255 & e3[2];
            }
            clone() {
              const e3 = new i3();
              return e3.fg = this.fg, e3.bg = this.bg, e3.extended = this.extended.clone(), e3;
            }
            isInverse() {
              return 67108864 & this.fg;
            }
            isBold() {
              return 134217728 & this.fg;
            }
            isUnderline() {
              return this.hasExtendedAttrs() && 0 !== this.extended.underlineStyle ? 1 : 268435456 & this.fg;
            }
            isBlink() {
              return 536870912 & this.fg;
            }
            isInvisible() {
              return 1073741824 & this.fg;
            }
            isItalic() {
              return 67108864 & this.bg;
            }
            isDim() {
              return 134217728 & this.bg;
            }
            isStrikethrough() {
              return 2147483648 & this.fg;
            }
            isProtected() {
              return 536870912 & this.bg;
            }
            isOverline() {
              return 1073741824 & this.bg;
            }
            getFgColorMode() {
              return 50331648 & this.fg;
            }
            getBgColorMode() {
              return 50331648 & this.bg;
            }
            isFgRGB() {
              return 50331648 == (50331648 & this.fg);
            }
            isBgRGB() {
              return 50331648 == (50331648 & this.bg);
            }
            isFgPalette() {
              return 16777216 == (50331648 & this.fg) || 33554432 == (50331648 & this.fg);
            }
            isBgPalette() {
              return 16777216 == (50331648 & this.bg) || 33554432 == (50331648 & this.bg);
            }
            isFgDefault() {
              return 0 == (50331648 & this.fg);
            }
            isBgDefault() {
              return 0 == (50331648 & this.bg);
            }
            isAttributeDefault() {
              return 0 === this.fg && 0 === this.bg;
            }
            getFgColor() {
              switch (50331648 & this.fg) {
                case 16777216:
                case 33554432:
                  return 255 & this.fg;
                case 50331648:
                  return 16777215 & this.fg;
                default:
                  return -1;
              }
            }
            getBgColor() {
              switch (50331648 & this.bg) {
                case 16777216:
                case 33554432:
                  return 255 & this.bg;
                case 50331648:
                  return 16777215 & this.bg;
                default:
                  return -1;
              }
            }
            hasExtendedAttrs() {
              return 268435456 & this.bg;
            }
            updateExtended() {
              this.extended.isEmpty() ? this.bg &= -268435457 : this.bg |= 268435456;
            }
            getUnderlineColor() {
              if (268435456 & this.bg && ~this.extended.underlineColor) switch (50331648 & this.extended.underlineColor) {
                case 16777216:
                case 33554432:
                  return 255 & this.extended.underlineColor;
                case 50331648:
                  return 16777215 & this.extended.underlineColor;
                default:
                  return this.getFgColor();
              }
              return this.getFgColor();
            }
            getUnderlineColorMode() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 & this.extended.underlineColor : this.getFgColorMode();
            }
            isUnderlineColorRGB() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 50331648 == (50331648 & this.extended.underlineColor) : this.isFgRGB();
            }
            isUnderlineColorPalette() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 16777216 == (50331648 & this.extended.underlineColor) || 33554432 == (50331648 & this.extended.underlineColor) : this.isFgPalette();
            }
            isUnderlineColorDefault() {
              return 268435456 & this.bg && ~this.extended.underlineColor ? 0 == (50331648 & this.extended.underlineColor) : this.isFgDefault();
            }
            getUnderlineStyle() {
              return 268435456 & this.fg ? 268435456 & this.bg ? this.extended.underlineStyle : 1 : 0;
            }
            getUnderlineVariantOffset() {
              return this.extended.underlineVariantOffset;
            }
          }
          t3.AttributeData = i3;
          class s2 {
            get ext() {
              return this._urlId ? -469762049 & this._ext | this.underlineStyle << 26 : this._ext;
            }
            set ext(e3) {
              this._ext = e3;
            }
            get underlineStyle() {
              return this._urlId ? 5 : (469762048 & this._ext) >> 26;
            }
            set underlineStyle(e3) {
              this._ext &= -469762049, this._ext |= e3 << 26 & 469762048;
            }
            get underlineColor() {
              return 67108863 & this._ext;
            }
            set underlineColor(e3) {
              this._ext &= -67108864, this._ext |= 67108863 & e3;
            }
            get urlId() {
              return this._urlId;
            }
            set urlId(e3) {
              this._urlId = e3;
            }
            get underlineVariantOffset() {
              const e3 = (3758096384 & this._ext) >> 29;
              return e3 < 0 ? 4294967288 ^ e3 : e3;
            }
            set underlineVariantOffset(e3) {
              this._ext &= 536870911, this._ext |= e3 << 29 & 3758096384;
            }
            constructor(e3 = 0, t4 = 0) {
              this._ext = 0, this._urlId = 0, this._ext = e3, this._urlId = t4;
            }
            clone() {
              return new s2(this._ext, this._urlId);
            }
            isEmpty() {
              return 0 === this.underlineStyle && 0 === this._urlId;
            }
          }
          t3.ExtendedAttrs = s2;
        },
        9092: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Buffer = t3.MAX_BUFFER_SIZE = void 0;
          const s2 = i3(6349), r = i3(7226), n = i3(3734), o = i3(8437), a = i3(4634), h = i3(511), c = i3(643), l = i3(4863), d = i3(7116);
          t3.MAX_BUFFER_SIZE = 4294967295, t3.Buffer = class {
            constructor(e3, t4, i4) {
              this._hasScrollback = e3, this._optionsService = t4, this._bufferService = i4, this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.tabs = {}, this.savedY = 0, this.savedX = 0, this.savedCurAttrData = o.DEFAULT_ATTR_DATA.clone(), this.savedCharset = d.DEFAULT_CHARSET, this.markers = [], this._nullCell = h.CellData.fromCharData([
                0,
                c.NULL_CELL_CHAR,
                c.NULL_CELL_WIDTH,
                c.NULL_CELL_CODE
              ]), this._whitespaceCell = h.CellData.fromCharData([
                0,
                c.WHITESPACE_CELL_CHAR,
                c.WHITESPACE_CELL_WIDTH,
                c.WHITESPACE_CELL_CODE
              ]), this._isClearing = false, this._memoryCleanupQueue = new r.IdleTaskQueue(), this._memoryCleanupPosition = 0, this._cols = this._bufferService.cols, this._rows = this._bufferService.rows, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
            }
            getNullCell(e3) {
              return e3 ? (this._nullCell.fg = e3.fg, this._nullCell.bg = e3.bg, this._nullCell.extended = e3.extended) : (this._nullCell.fg = 0, this._nullCell.bg = 0, this._nullCell.extended = new n.ExtendedAttrs()), this._nullCell;
            }
            getWhitespaceCell(e3) {
              return e3 ? (this._whitespaceCell.fg = e3.fg, this._whitespaceCell.bg = e3.bg, this._whitespaceCell.extended = e3.extended) : (this._whitespaceCell.fg = 0, this._whitespaceCell.bg = 0, this._whitespaceCell.extended = new n.ExtendedAttrs()), this._whitespaceCell;
            }
            getBlankLine(e3, t4) {
              return new o.BufferLine(this._bufferService.cols, this.getNullCell(e3), t4);
            }
            get hasScrollback() {
              return this._hasScrollback && this.lines.maxLength > this._rows;
            }
            get isCursorInViewport() {
              const e3 = this.ybase + this.y - this.ydisp;
              return e3 >= 0 && e3 < this._rows;
            }
            _getCorrectBufferLength(e3) {
              if (!this._hasScrollback) return e3;
              const i4 = e3 + this._optionsService.rawOptions.scrollback;
              return i4 > t3.MAX_BUFFER_SIZE ? t3.MAX_BUFFER_SIZE : i4;
            }
            fillViewportRows(e3) {
              if (0 === this.lines.length) {
                void 0 === e3 && (e3 = o.DEFAULT_ATTR_DATA);
                let t4 = this._rows;
                for (; t4--; ) this.lines.push(this.getBlankLine(e3));
              }
            }
            clear() {
              this.ydisp = 0, this.ybase = 0, this.y = 0, this.x = 0, this.lines = new s2.CircularList(this._getCorrectBufferLength(this._rows)), this.scrollTop = 0, this.scrollBottom = this._rows - 1, this.setupTabStops();
            }
            resize(e3, t4) {
              const i4 = this.getNullCell(o.DEFAULT_ATTR_DATA);
              let s3 = 0;
              const r2 = this._getCorrectBufferLength(t4);
              if (r2 > this.lines.maxLength && (this.lines.maxLength = r2), this.lines.length > 0) {
                if (this._cols < e3) for (let t5 = 0; t5 < this.lines.length; t5++) s3 += +this.lines.get(t5).resize(e3, i4);
                let n2 = 0;
                if (this._rows < t4) for (let s4 = this._rows; s4 < t4; s4++) this.lines.length < t4 + this.ybase && (this._optionsService.rawOptions.windowsMode || void 0 !== this._optionsService.rawOptions.windowsPty.backend || void 0 !== this._optionsService.rawOptions.windowsPty.buildNumber ? this.lines.push(new o.BufferLine(e3, i4)) : this.ybase > 0 && this.lines.length <= this.ybase + this.y + n2 + 1 ? (this.ybase--, n2++, this.ydisp > 0 && this.ydisp--) : this.lines.push(new o.BufferLine(e3, i4)));
                else for (let e4 = this._rows; e4 > t4; e4--) this.lines.length > t4 + this.ybase && (this.lines.length > this.ybase + this.y + 1 ? this.lines.pop() : (this.ybase++, this.ydisp++));
                if (r2 < this.lines.maxLength) {
                  const e4 = this.lines.length - r2;
                  e4 > 0 && (this.lines.trimStart(e4), this.ybase = Math.max(this.ybase - e4, 0), this.ydisp = Math.max(this.ydisp - e4, 0), this.savedY = Math.max(this.savedY - e4, 0)), this.lines.maxLength = r2;
                }
                this.x = Math.min(this.x, e3 - 1), this.y = Math.min(this.y, t4 - 1), n2 && (this.y += n2), this.savedX = Math.min(this.savedX, e3 - 1), this.scrollTop = 0;
              }
              if (this.scrollBottom = t4 - 1, this._isReflowEnabled && (this._reflow(e3, t4), this._cols > e3)) for (let t5 = 0; t5 < this.lines.length; t5++) s3 += +this.lines.get(t5).resize(e3, i4);
              this._cols = e3, this._rows = t4, this._memoryCleanupQueue.clear(), s3 > 0.1 * this.lines.length && (this._memoryCleanupPosition = 0, this._memoryCleanupQueue.enqueue(() => this._batchedMemoryCleanup()));
            }
            _batchedMemoryCleanup() {
              let e3 = true;
              this._memoryCleanupPosition >= this.lines.length && (this._memoryCleanupPosition = 0, e3 = false);
              let t4 = 0;
              for (; this._memoryCleanupPosition < this.lines.length; ) if (t4 += this.lines.get(this._memoryCleanupPosition++).cleanupMemory(), t4 > 100) return true;
              return e3;
            }
            get _isReflowEnabled() {
              const e3 = this._optionsService.rawOptions.windowsPty;
              return e3 && e3.buildNumber ? this._hasScrollback && "conpty" === e3.backend && e3.buildNumber >= 21376 : this._hasScrollback && !this._optionsService.rawOptions.windowsMode;
            }
            _reflow(e3, t4) {
              this._cols !== e3 && (e3 > this._cols ? this._reflowLarger(e3, t4) : this._reflowSmaller(e3, t4));
            }
            _reflowLarger(e3, t4) {
              const i4 = (0, a.reflowLargerGetLinesToRemove)(this.lines, this._cols, e3, this.ybase + this.y, this.getNullCell(o.DEFAULT_ATTR_DATA));
              if (i4.length > 0) {
                const s3 = (0, a.reflowLargerCreateNewLayout)(this.lines, i4);
                (0, a.reflowLargerApplyNewLayout)(this.lines, s3.layout), this._reflowLargerAdjustViewport(e3, t4, s3.countRemoved);
              }
            }
            _reflowLargerAdjustViewport(e3, t4, i4) {
              const s3 = this.getNullCell(o.DEFAULT_ATTR_DATA);
              let r2 = i4;
              for (; r2-- > 0; ) 0 === this.ybase ? (this.y > 0 && this.y--, this.lines.length < t4 && this.lines.push(new o.BufferLine(e3, s3))) : (this.ydisp === this.ybase && this.ydisp--, this.ybase--);
              this.savedY = Math.max(this.savedY - i4, 0);
            }
            _reflowSmaller(e3, t4) {
              const i4 = this.getNullCell(o.DEFAULT_ATTR_DATA), s3 = [];
              let r2 = 0;
              for (let n2 = this.lines.length - 1; n2 >= 0; n2--) {
                let h2 = this.lines.get(n2);
                if (!h2 || !h2.isWrapped && h2.getTrimmedLength() <= e3) continue;
                const c2 = [
                  h2
                ];
                for (; h2.isWrapped && n2 > 0; ) h2 = this.lines.get(--n2), c2.unshift(h2);
                const l2 = this.ybase + this.y;
                if (l2 >= n2 && l2 < n2 + c2.length) continue;
                const d2 = c2[c2.length - 1].getTrimmedLength(), _ = (0, a.reflowSmallerGetNewLineLengths)(c2, this._cols, e3), u = _.length - c2.length;
                let f;
                f = 0 === this.ybase && this.y !== this.lines.length - 1 ? Math.max(0, this.y - this.lines.maxLength + u) : Math.max(0, this.lines.length - this.lines.maxLength + u);
                const v = [];
                for (let e4 = 0; e4 < u; e4++) {
                  const e5 = this.getBlankLine(o.DEFAULT_ATTR_DATA, true);
                  v.push(e5);
                }
                v.length > 0 && (s3.push({
                  start: n2 + c2.length + r2,
                  newLines: v
                }), r2 += v.length), c2.push(...v);
                let p = _.length - 1, g = _[p];
                0 === g && (p--, g = _[p]);
                let m = c2.length - u - 1, S = d2;
                for (; m >= 0; ) {
                  const e4 = Math.min(S, g);
                  if (void 0 === c2[p]) break;
                  if (c2[p].copyCellsFrom(c2[m], S - e4, g - e4, e4, true), g -= e4, 0 === g && (p--, g = _[p]), S -= e4, 0 === S) {
                    m--;
                    const e5 = Math.max(m, 0);
                    S = (0, a.getWrappedLineTrimmedLength)(c2, e5, this._cols);
                  }
                }
                for (let t5 = 0; t5 < c2.length; t5++) _[t5] < e3 && c2[t5].setCell(_[t5], i4);
                let C2 = u - f;
                for (; C2-- > 0; ) 0 === this.ybase ? this.y < t4 - 1 ? (this.y++, this.lines.pop()) : (this.ybase++, this.ydisp++) : this.ybase < Math.min(this.lines.maxLength, this.lines.length + r2) - t4 && (this.ybase === this.ydisp && this.ydisp++, this.ybase++);
                this.savedY = Math.min(this.savedY + u, this.ybase + t4 - 1);
              }
              if (s3.length > 0) {
                const e4 = [], t5 = [];
                for (let e5 = 0; e5 < this.lines.length; e5++) t5.push(this.lines.get(e5));
                const i5 = this.lines.length;
                let n2 = i5 - 1, o2 = 0, a2 = s3[o2];
                this.lines.length = Math.min(this.lines.maxLength, this.lines.length + r2);
                let h2 = 0;
                for (let c3 = Math.min(this.lines.maxLength - 1, i5 + r2 - 1); c3 >= 0; c3--) if (a2 && a2.start > n2 + h2) {
                  for (let e5 = a2.newLines.length - 1; e5 >= 0; e5--) this.lines.set(c3--, a2.newLines[e5]);
                  c3++, e4.push({
                    index: n2 + 1,
                    amount: a2.newLines.length
                  }), h2 += a2.newLines.length, a2 = s3[++o2];
                } else this.lines.set(c3, t5[n2--]);
                let c2 = 0;
                for (let t6 = e4.length - 1; t6 >= 0; t6--) e4[t6].index += c2, this.lines.onInsertEmitter.fire(e4[t6]), c2 += e4[t6].amount;
                const l2 = Math.max(0, i5 + r2 - this.lines.maxLength);
                l2 > 0 && this.lines.onTrimEmitter.fire(l2);
              }
            }
            translateBufferLineToString(e3, t4, i4 = 0, s3) {
              const r2 = this.lines.get(e3);
              return r2 ? r2.translateToString(t4, i4, s3) : "";
            }
            getWrappedRangeForLine(e3) {
              let t4 = e3, i4 = e3;
              for (; t4 > 0 && this.lines.get(t4).isWrapped; ) t4--;
              for (; i4 + 1 < this.lines.length && this.lines.get(i4 + 1).isWrapped; ) i4++;
              return {
                first: t4,
                last: i4
              };
            }
            setupTabStops(e3) {
              for (null != e3 ? this.tabs[e3] || (e3 = this.prevStop(e3)) : (this.tabs = {}, e3 = 0); e3 < this._cols; e3 += this._optionsService.rawOptions.tabStopWidth) this.tabs[e3] = true;
            }
            prevStop(e3) {
              for (null == e3 && (e3 = this.x); !this.tabs[--e3] && e3 > 0; ) ;
              return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
            }
            nextStop(e3) {
              for (null == e3 && (e3 = this.x); !this.tabs[++e3] && e3 < this._cols; ) ;
              return e3 >= this._cols ? this._cols - 1 : e3 < 0 ? 0 : e3;
            }
            clearMarkers(e3) {
              this._isClearing = true;
              for (let t4 = 0; t4 < this.markers.length; t4++) this.markers[t4].line === e3 && (this.markers[t4].dispose(), this.markers.splice(t4--, 1));
              this._isClearing = false;
            }
            clearAllMarkers() {
              this._isClearing = true;
              for (let e3 = 0; e3 < this.markers.length; e3++) this.markers[e3].dispose(), this.markers.splice(e3--, 1);
              this._isClearing = false;
            }
            addMarker(e3) {
              const t4 = new l.Marker(e3);
              return this.markers.push(t4), t4.register(this.lines.onTrim((e4) => {
                t4.line -= e4, t4.line < 0 && t4.dispose();
              })), t4.register(this.lines.onInsert((e4) => {
                t4.line >= e4.index && (t4.line += e4.amount);
              })), t4.register(this.lines.onDelete((e4) => {
                t4.line >= e4.index && t4.line < e4.index + e4.amount && t4.dispose(), t4.line > e4.index && (t4.line -= e4.amount);
              })), t4.register(t4.onDispose(() => this._removeMarker(t4))), t4;
            }
            _removeMarker(e3) {
              this._isClearing || this.markers.splice(this.markers.indexOf(e3), 1);
            }
          };
        },
        8437: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferLine = t3.DEFAULT_ATTR_DATA = void 0;
          const s2 = i3(3734), r = i3(511), n = i3(643), o = i3(482);
          t3.DEFAULT_ATTR_DATA = Object.freeze(new s2.AttributeData());
          let a = 0;
          class h {
            constructor(e3, t4, i4 = false) {
              this.isWrapped = i4, this._combined = {}, this._extendedAttrs = {}, this._data = new Uint32Array(3 * e3);
              const s3 = t4 || r.CellData.fromCharData([
                0,
                n.NULL_CELL_CHAR,
                n.NULL_CELL_WIDTH,
                n.NULL_CELL_CODE
              ]);
              for (let t5 = 0; t5 < e3; ++t5) this.setCell(t5, s3);
              this.length = e3;
            }
            get(e3) {
              const t4 = this._data[3 * e3 + 0], i4 = 2097151 & t4;
              return [
                this._data[3 * e3 + 1],
                2097152 & t4 ? this._combined[e3] : i4 ? (0, o.stringFromCodePoint)(i4) : "",
                t4 >> 22,
                2097152 & t4 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : i4
              ];
            }
            set(e3, t4) {
              this._data[3 * e3 + 1] = t4[n.CHAR_DATA_ATTR_INDEX], t4[n.CHAR_DATA_CHAR_INDEX].length > 1 ? (this._combined[e3] = t4[1], this._data[3 * e3 + 0] = 2097152 | e3 | t4[n.CHAR_DATA_WIDTH_INDEX] << 22) : this._data[3 * e3 + 0] = t4[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | t4[n.CHAR_DATA_WIDTH_INDEX] << 22;
            }
            getWidth(e3) {
              return this._data[3 * e3 + 0] >> 22;
            }
            hasWidth(e3) {
              return 12582912 & this._data[3 * e3 + 0];
            }
            getFg(e3) {
              return this._data[3 * e3 + 1];
            }
            getBg(e3) {
              return this._data[3 * e3 + 2];
            }
            hasContent(e3) {
              return 4194303 & this._data[3 * e3 + 0];
            }
            getCodePoint(e3) {
              const t4 = this._data[3 * e3 + 0];
              return 2097152 & t4 ? this._combined[e3].charCodeAt(this._combined[e3].length - 1) : 2097151 & t4;
            }
            isCombined(e3) {
              return 2097152 & this._data[3 * e3 + 0];
            }
            getString(e3) {
              const t4 = this._data[3 * e3 + 0];
              return 2097152 & t4 ? this._combined[e3] : 2097151 & t4 ? (0, o.stringFromCodePoint)(2097151 & t4) : "";
            }
            isProtected(e3) {
              return 536870912 & this._data[3 * e3 + 2];
            }
            loadCell(e3, t4) {
              return a = 3 * e3, t4.content = this._data[a + 0], t4.fg = this._data[a + 1], t4.bg = this._data[a + 2], 2097152 & t4.content && (t4.combinedData = this._combined[e3]), 268435456 & t4.bg && (t4.extended = this._extendedAttrs[e3]), t4;
            }
            setCell(e3, t4) {
              2097152 & t4.content && (this._combined[e3] = t4.combinedData), 268435456 & t4.bg && (this._extendedAttrs[e3] = t4.extended), this._data[3 * e3 + 0] = t4.content, this._data[3 * e3 + 1] = t4.fg, this._data[3 * e3 + 2] = t4.bg;
            }
            setCellFromCodepoint(e3, t4, i4, s3) {
              268435456 & s3.bg && (this._extendedAttrs[e3] = s3.extended), this._data[3 * e3 + 0] = t4 | i4 << 22, this._data[3 * e3 + 1] = s3.fg, this._data[3 * e3 + 2] = s3.bg;
            }
            addCodepointToCell(e3, t4, i4) {
              let s3 = this._data[3 * e3 + 0];
              2097152 & s3 ? this._combined[e3] += (0, o.stringFromCodePoint)(t4) : 2097151 & s3 ? (this._combined[e3] = (0, o.stringFromCodePoint)(2097151 & s3) + (0, o.stringFromCodePoint)(t4), s3 &= -2097152, s3 |= 2097152) : s3 = t4 | 1 << 22, i4 && (s3 &= -12582913, s3 |= i4 << 22), this._data[3 * e3 + 0] = s3;
            }
            insertCells(e3, t4, i4) {
              if ((e3 %= this.length) && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), t4 < this.length - e3) {
                const s3 = new r.CellData();
                for (let i5 = this.length - e3 - t4 - 1; i5 >= 0; --i5) this.setCell(e3 + t4 + i5, this.loadCell(e3 + i5, s3));
                for (let s4 = 0; s4 < t4; ++s4) this.setCell(e3 + s4, i4);
              } else for (let t5 = e3; t5 < this.length; ++t5) this.setCell(t5, i4);
              2 === this.getWidth(this.length - 1) && this.setCellFromCodepoint(this.length - 1, 0, 1, i4);
            }
            deleteCells(e3, t4, i4) {
              if (e3 %= this.length, t4 < this.length - e3) {
                const s3 = new r.CellData();
                for (let i5 = 0; i5 < this.length - e3 - t4; ++i5) this.setCell(e3 + i5, this.loadCell(e3 + t4 + i5, s3));
                for (let e4 = this.length - t4; e4 < this.length; ++e4) this.setCell(e4, i4);
              } else for (let t5 = e3; t5 < this.length; ++t5) this.setCell(t5, i4);
              e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), 0 !== this.getWidth(e3) || this.hasContent(e3) || this.setCellFromCodepoint(e3, 0, 1, i4);
            }
            replaceCells(e3, t4, i4, s3 = false) {
              if (s3) for (e3 && 2 === this.getWidth(e3 - 1) && !this.isProtected(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), t4 < this.length && 2 === this.getWidth(t4 - 1) && !this.isProtected(t4) && this.setCellFromCodepoint(t4, 0, 1, i4); e3 < t4 && e3 < this.length; ) this.isProtected(e3) || this.setCell(e3, i4), e3++;
              else for (e3 && 2 === this.getWidth(e3 - 1) && this.setCellFromCodepoint(e3 - 1, 0, 1, i4), t4 < this.length && 2 === this.getWidth(t4 - 1) && this.setCellFromCodepoint(t4, 0, 1, i4); e3 < t4 && e3 < this.length; ) this.setCell(e3++, i4);
            }
            resize(e3, t4) {
              if (e3 === this.length) return 4 * this._data.length * 2 < this._data.buffer.byteLength;
              const i4 = 3 * e3;
              if (e3 > this.length) {
                if (this._data.buffer.byteLength >= 4 * i4) this._data = new Uint32Array(this._data.buffer, 0, i4);
                else {
                  const e4 = new Uint32Array(i4);
                  e4.set(this._data), this._data = e4;
                }
                for (let i5 = this.length; i5 < e3; ++i5) this.setCell(i5, t4);
              } else {
                this._data = this._data.subarray(0, i4);
                const t5 = Object.keys(this._combined);
                for (let i5 = 0; i5 < t5.length; i5++) {
                  const s4 = parseInt(t5[i5], 10);
                  s4 >= e3 && delete this._combined[s4];
                }
                const s3 = Object.keys(this._extendedAttrs);
                for (let t6 = 0; t6 < s3.length; t6++) {
                  const i5 = parseInt(s3[t6], 10);
                  i5 >= e3 && delete this._extendedAttrs[i5];
                }
              }
              return this.length = e3, 4 * i4 * 2 < this._data.buffer.byteLength;
            }
            cleanupMemory() {
              if (4 * this._data.length * 2 < this._data.buffer.byteLength) {
                const e3 = new Uint32Array(this._data.length);
                return e3.set(this._data), this._data = e3, 1;
              }
              return 0;
            }
            fill(e3, t4 = false) {
              if (t4) for (let t5 = 0; t5 < this.length; ++t5) this.isProtected(t5) || this.setCell(t5, e3);
              else {
                this._combined = {}, this._extendedAttrs = {};
                for (let t5 = 0; t5 < this.length; ++t5) this.setCell(t5, e3);
              }
            }
            copyFrom(e3) {
              this.length !== e3.length ? this._data = new Uint32Array(e3._data) : this._data.set(e3._data), this.length = e3.length, this._combined = {};
              for (const t4 in e3._combined) this._combined[t4] = e3._combined[t4];
              this._extendedAttrs = {};
              for (const t4 in e3._extendedAttrs) this._extendedAttrs[t4] = e3._extendedAttrs[t4];
              this.isWrapped = e3.isWrapped;
            }
            clone() {
              const e3 = new h(0);
              e3._data = new Uint32Array(this._data), e3.length = this.length;
              for (const t4 in this._combined) e3._combined[t4] = this._combined[t4];
              for (const t4 in this._extendedAttrs) e3._extendedAttrs[t4] = this._extendedAttrs[t4];
              return e3.isWrapped = this.isWrapped, e3;
            }
            getTrimmedLength() {
              for (let e3 = this.length - 1; e3 >= 0; --e3) if (4194303 & this._data[3 * e3 + 0]) return e3 + (this._data[3 * e3 + 0] >> 22);
              return 0;
            }
            getNoBgTrimmedLength() {
              for (let e3 = this.length - 1; e3 >= 0; --e3) if (4194303 & this._data[3 * e3 + 0] || 50331648 & this._data[3 * e3 + 2]) return e3 + (this._data[3 * e3 + 0] >> 22);
              return 0;
            }
            copyCellsFrom(e3, t4, i4, s3, r2) {
              const n2 = e3._data;
              if (r2) for (let r3 = s3 - 1; r3 >= 0; r3--) {
                for (let e4 = 0; e4 < 3; e4++) this._data[3 * (i4 + r3) + e4] = n2[3 * (t4 + r3) + e4];
                268435456 & n2[3 * (t4 + r3) + 2] && (this._extendedAttrs[i4 + r3] = e3._extendedAttrs[t4 + r3]);
              }
              else for (let r3 = 0; r3 < s3; r3++) {
                for (let e4 = 0; e4 < 3; e4++) this._data[3 * (i4 + r3) + e4] = n2[3 * (t4 + r3) + e4];
                268435456 & n2[3 * (t4 + r3) + 2] && (this._extendedAttrs[i4 + r3] = e3._extendedAttrs[t4 + r3]);
              }
              const o2 = Object.keys(e3._combined);
              for (let s4 = 0; s4 < o2.length; s4++) {
                const r3 = parseInt(o2[s4], 10);
                r3 >= t4 && (this._combined[r3 - t4 + i4] = e3._combined[r3]);
              }
            }
            translateToString(e3, t4, i4, s3) {
              t4 = t4 ?? 0, i4 = i4 ?? this.length, e3 && (i4 = Math.min(i4, this.getTrimmedLength())), s3 && (s3.length = 0);
              let r2 = "";
              for (; t4 < i4; ) {
                const e4 = this._data[3 * t4 + 0], i5 = 2097151 & e4, a2 = 2097152 & e4 ? this._combined[t4] : i5 ? (0, o.stringFromCodePoint)(i5) : n.WHITESPACE_CELL_CHAR;
                if (r2 += a2, s3) for (let e5 = 0; e5 < a2.length; ++e5) s3.push(t4);
                t4 += e4 >> 22 || 1;
              }
              return s3 && s3.push(t4), r2;
            }
          }
          t3.BufferLine = h;
        },
        4841: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.getRangeLength = void 0, t3.getRangeLength = function(e3, t4) {
            if (e3.start.y > e3.end.y) throw new Error(`Buffer range end (${e3.end.x}, ${e3.end.y}) cannot be before start (${e3.start.x}, ${e3.start.y})`);
            return t4 * (e3.end.y - e3.start.y) + (e3.end.x - e3.start.x + 1);
          };
        },
        4634: (e2, t3) => {
          function i3(e3, t4, i4) {
            if (t4 === e3.length - 1) return e3[t4].getTrimmedLength();
            const s2 = !e3[t4].hasContent(i4 - 1) && 1 === e3[t4].getWidth(i4 - 1), r = 2 === e3[t4 + 1].getWidth(0);
            return s2 && r ? i4 - 1 : i4;
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.getWrappedLineTrimmedLength = t3.reflowSmallerGetNewLineLengths = t3.reflowLargerApplyNewLayout = t3.reflowLargerCreateNewLayout = t3.reflowLargerGetLinesToRemove = void 0, t3.reflowLargerGetLinesToRemove = function(e3, t4, s2, r, n) {
            const o = [];
            for (let a = 0; a < e3.length - 1; a++) {
              let h = a, c = e3.get(++h);
              if (!c.isWrapped) continue;
              const l = [
                e3.get(a)
              ];
              for (; h < e3.length && c.isWrapped; ) l.push(c), c = e3.get(++h);
              if (r >= a && r < h) {
                a += l.length - 1;
                continue;
              }
              let d = 0, _ = i3(l, d, t4), u = 1, f = 0;
              for (; u < l.length; ) {
                const e4 = i3(l, u, t4), r2 = e4 - f, o2 = s2 - _, a2 = Math.min(r2, o2);
                l[d].copyCellsFrom(l[u], f, _, a2, false), _ += a2, _ === s2 && (d++, _ = 0), f += a2, f === e4 && (u++, f = 0), 0 === _ && 0 !== d && 2 === l[d - 1].getWidth(s2 - 1) && (l[d].copyCellsFrom(l[d - 1], s2 - 1, _++, 1, false), l[d - 1].setCell(s2 - 1, n));
              }
              l[d].replaceCells(_, s2, n);
              let v = 0;
              for (let e4 = l.length - 1; e4 > 0 && (e4 > d || 0 === l[e4].getTrimmedLength()); e4--) v++;
              v > 0 && (o.push(a + l.length - v), o.push(v)), a += l.length - 1;
            }
            return o;
          }, t3.reflowLargerCreateNewLayout = function(e3, t4) {
            const i4 = [];
            let s2 = 0, r = t4[s2], n = 0;
            for (let o = 0; o < e3.length; o++) if (r === o) {
              const i5 = t4[++s2];
              e3.onDeleteEmitter.fire({
                index: o - n,
                amount: i5
              }), o += i5 - 1, n += i5, r = t4[++s2];
            } else i4.push(o);
            return {
              layout: i4,
              countRemoved: n
            };
          }, t3.reflowLargerApplyNewLayout = function(e3, t4) {
            const i4 = [];
            for (let s2 = 0; s2 < t4.length; s2++) i4.push(e3.get(t4[s2]));
            for (let t5 = 0; t5 < i4.length; t5++) e3.set(t5, i4[t5]);
            e3.length = t4.length;
          }, t3.reflowSmallerGetNewLineLengths = function(e3, t4, s2) {
            const r = [], n = e3.map((s3, r2) => i3(e3, r2, t4)).reduce((e4, t5) => e4 + t5);
            let o = 0, a = 0, h = 0;
            for (; h < n; ) {
              if (n - h < s2) {
                r.push(n - h);
                break;
              }
              o += s2;
              const c = i3(e3, a, t4);
              o > c && (o -= c, a++);
              const l = 2 === e3[a].getWidth(o - 1);
              l && o--;
              const d = l ? s2 - 1 : s2;
              r.push(d), h += d;
            }
            return r;
          }, t3.getWrappedLineTrimmedLength = i3;
        },
        5295: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferSet = void 0;
          const s2 = i3(8460), r = i3(844), n = i3(9092);
          class o extends r.Disposable {
            constructor(e3, t4) {
              super(), this._optionsService = e3, this._bufferService = t4, this._onBufferActivate = this.register(new s2.EventEmitter()), this.onBufferActivate = this._onBufferActivate.event, this.reset(), this.register(this._optionsService.onSpecificOptionChange("scrollback", () => this.resize(this._bufferService.cols, this._bufferService.rows))), this.register(this._optionsService.onSpecificOptionChange("tabStopWidth", () => this.setupTabStops()));
            }
            reset() {
              this._normal = new n.Buffer(true, this._optionsService, this._bufferService), this._normal.fillViewportRows(), this._alt = new n.Buffer(false, this._optionsService, this._bufferService), this._activeBuffer = this._normal, this._onBufferActivate.fire({
                activeBuffer: this._normal,
                inactiveBuffer: this._alt
              }), this.setupTabStops();
            }
            get alt() {
              return this._alt;
            }
            get active() {
              return this._activeBuffer;
            }
            get normal() {
              return this._normal;
            }
            activateNormalBuffer() {
              this._activeBuffer !== this._normal && (this._normal.x = this._alt.x, this._normal.y = this._alt.y, this._alt.clearAllMarkers(), this._alt.clear(), this._activeBuffer = this._normal, this._onBufferActivate.fire({
                activeBuffer: this._normal,
                inactiveBuffer: this._alt
              }));
            }
            activateAltBuffer(e3) {
              this._activeBuffer !== this._alt && (this._alt.fillViewportRows(e3), this._alt.x = this._normal.x, this._alt.y = this._normal.y, this._activeBuffer = this._alt, this._onBufferActivate.fire({
                activeBuffer: this._alt,
                inactiveBuffer: this._normal
              }));
            }
            resize(e3, t4) {
              this._normal.resize(e3, t4), this._alt.resize(e3, t4), this.setupTabStops(e3);
            }
            setupTabStops(e3) {
              this._normal.setupTabStops(e3), this._alt.setupTabStops(e3);
            }
          }
          t3.BufferSet = o;
        },
        511: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CellData = void 0;
          const s2 = i3(482), r = i3(643), n = i3(3734);
          class o extends n.AttributeData {
            constructor() {
              super(...arguments), this.content = 0, this.fg = 0, this.bg = 0, this.extended = new n.ExtendedAttrs(), this.combinedData = "";
            }
            static fromCharData(e3) {
              const t4 = new o();
              return t4.setFromCharData(e3), t4;
            }
            isCombined() {
              return 2097152 & this.content;
            }
            getWidth() {
              return this.content >> 22;
            }
            getChars() {
              return 2097152 & this.content ? this.combinedData : 2097151 & this.content ? (0, s2.stringFromCodePoint)(2097151 & this.content) : "";
            }
            getCode() {
              return this.isCombined() ? this.combinedData.charCodeAt(this.combinedData.length - 1) : 2097151 & this.content;
            }
            setFromCharData(e3) {
              this.fg = e3[r.CHAR_DATA_ATTR_INDEX], this.bg = 0;
              let t4 = false;
              if (e3[r.CHAR_DATA_CHAR_INDEX].length > 2) t4 = true;
              else if (2 === e3[r.CHAR_DATA_CHAR_INDEX].length) {
                const i4 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0);
                if (55296 <= i4 && i4 <= 56319) {
                  const s3 = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(1);
                  56320 <= s3 && s3 <= 57343 ? this.content = 1024 * (i4 - 55296) + s3 - 56320 + 65536 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22 : t4 = true;
                } else t4 = true;
              } else this.content = e3[r.CHAR_DATA_CHAR_INDEX].charCodeAt(0) | e3[r.CHAR_DATA_WIDTH_INDEX] << 22;
              t4 && (this.combinedData = e3[r.CHAR_DATA_CHAR_INDEX], this.content = 2097152 | e3[r.CHAR_DATA_WIDTH_INDEX] << 22);
            }
            getAsCharData() {
              return [
                this.fg,
                this.getChars(),
                this.getWidth(),
                this.getCode()
              ];
            }
          }
          t3.CellData = o;
        },
        643: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.WHITESPACE_CELL_CODE = t3.WHITESPACE_CELL_WIDTH = t3.WHITESPACE_CELL_CHAR = t3.NULL_CELL_CODE = t3.NULL_CELL_WIDTH = t3.NULL_CELL_CHAR = t3.CHAR_DATA_CODE_INDEX = t3.CHAR_DATA_WIDTH_INDEX = t3.CHAR_DATA_CHAR_INDEX = t3.CHAR_DATA_ATTR_INDEX = t3.DEFAULT_EXT = t3.DEFAULT_ATTR = t3.DEFAULT_COLOR = void 0, t3.DEFAULT_COLOR = 0, t3.DEFAULT_ATTR = 256 | t3.DEFAULT_COLOR << 9, t3.DEFAULT_EXT = 0, t3.CHAR_DATA_ATTR_INDEX = 0, t3.CHAR_DATA_CHAR_INDEX = 1, t3.CHAR_DATA_WIDTH_INDEX = 2, t3.CHAR_DATA_CODE_INDEX = 3, t3.NULL_CELL_CHAR = "", t3.NULL_CELL_WIDTH = 1, t3.NULL_CELL_CODE = 0, t3.WHITESPACE_CELL_CHAR = " ", t3.WHITESPACE_CELL_WIDTH = 1, t3.WHITESPACE_CELL_CODE = 32;
        },
        4863: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Marker = void 0;
          const s2 = i3(8460), r = i3(844);
          class n {
            get id() {
              return this._id;
            }
            constructor(e3) {
              this.line = e3, this.isDisposed = false, this._disposables = [], this._id = n._nextId++, this._onDispose = this.register(new s2.EventEmitter()), this.onDispose = this._onDispose.event;
            }
            dispose() {
              this.isDisposed || (this.isDisposed = true, this.line = -1, this._onDispose.fire(), (0, r.disposeArray)(this._disposables), this._disposables.length = 0);
            }
            register(e3) {
              return this._disposables.push(e3), e3;
            }
          }
          t3.Marker = n, n._nextId = 1;
        },
        7116: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.DEFAULT_CHARSET = t3.CHARSETS = void 0, t3.CHARSETS = {}, t3.DEFAULT_CHARSET = t3.CHARSETS.B, t3.CHARSETS[0] = {
            "`": "\u25C6",
            a: "\u2592",
            b: "\u2409",
            c: "\u240C",
            d: "\u240D",
            e: "\u240A",
            f: "\xB0",
            g: "\xB1",
            h: "\u2424",
            i: "\u240B",
            j: "\u2518",
            k: "\u2510",
            l: "\u250C",
            m: "\u2514",
            n: "\u253C",
            o: "\u23BA",
            p: "\u23BB",
            q: "\u2500",
            r: "\u23BC",
            s: "\u23BD",
            t: "\u251C",
            u: "\u2524",
            v: "\u2534",
            w: "\u252C",
            x: "\u2502",
            y: "\u2264",
            z: "\u2265",
            "{": "\u03C0",
            "|": "\u2260",
            "}": "\xA3",
            "~": "\xB7"
          }, t3.CHARSETS.A = {
            "#": "\xA3"
          }, t3.CHARSETS.B = void 0, t3.CHARSETS[4] = {
            "#": "\xA3",
            "@": "\xBE",
            "[": "ij",
            "\\": "\xBD",
            "]": "|",
            "{": "\xA8",
            "|": "f",
            "}": "\xBC",
            "~": "\xB4"
          }, t3.CHARSETS.C = t3.CHARSETS[5] = {
            "[": "\xC4",
            "\\": "\xD6",
            "]": "\xC5",
            "^": "\xDC",
            "`": "\xE9",
            "{": "\xE4",
            "|": "\xF6",
            "}": "\xE5",
            "~": "\xFC"
          }, t3.CHARSETS.R = {
            "#": "\xA3",
            "@": "\xE0",
            "[": "\xB0",
            "\\": "\xE7",
            "]": "\xA7",
            "{": "\xE9",
            "|": "\xF9",
            "}": "\xE8",
            "~": "\xA8"
          }, t3.CHARSETS.Q = {
            "@": "\xE0",
            "[": "\xE2",
            "\\": "\xE7",
            "]": "\xEA",
            "^": "\xEE",
            "`": "\xF4",
            "{": "\xE9",
            "|": "\xF9",
            "}": "\xE8",
            "~": "\xFB"
          }, t3.CHARSETS.K = {
            "@": "\xA7",
            "[": "\xC4",
            "\\": "\xD6",
            "]": "\xDC",
            "{": "\xE4",
            "|": "\xF6",
            "}": "\xFC",
            "~": "\xDF"
          }, t3.CHARSETS.Y = {
            "#": "\xA3",
            "@": "\xA7",
            "[": "\xB0",
            "\\": "\xE7",
            "]": "\xE9",
            "`": "\xF9",
            "{": "\xE0",
            "|": "\xF2",
            "}": "\xE8",
            "~": "\xEC"
          }, t3.CHARSETS.E = t3.CHARSETS[6] = {
            "@": "\xC4",
            "[": "\xC6",
            "\\": "\xD8",
            "]": "\xC5",
            "^": "\xDC",
            "`": "\xE4",
            "{": "\xE6",
            "|": "\xF8",
            "}": "\xE5",
            "~": "\xFC"
          }, t3.CHARSETS.Z = {
            "#": "\xA3",
            "@": "\xA7",
            "[": "\xA1",
            "\\": "\xD1",
            "]": "\xBF",
            "{": "\xB0",
            "|": "\xF1",
            "}": "\xE7"
          }, t3.CHARSETS.H = t3.CHARSETS[7] = {
            "@": "\xC9",
            "[": "\xC4",
            "\\": "\xD6",
            "]": "\xC5",
            "^": "\xDC",
            "`": "\xE9",
            "{": "\xE4",
            "|": "\xF6",
            "}": "\xE5",
            "~": "\xFC"
          }, t3.CHARSETS["="] = {
            "#": "\xF9",
            "@": "\xE0",
            "[": "\xE9",
            "\\": "\xE7",
            "]": "\xEA",
            "^": "\xEE",
            _: "\xE8",
            "`": "\xF4",
            "{": "\xE4",
            "|": "\xF6",
            "}": "\xFC",
            "~": "\xFB"
          };
        },
        2584: (e2, t3) => {
          var i3, s2, r;
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.C1_ESCAPED = t3.C1 = t3.C0 = void 0, function(e3) {
            e3.NUL = "\0", e3.SOH = "", e3.STX = "", e3.ETX = "", e3.EOT = "", e3.ENQ = "", e3.ACK = "", e3.BEL = "\x07", e3.BS = "\b", e3.HT = "	", e3.LF = "\n", e3.VT = "\v", e3.FF = "\f", e3.CR = "\r", e3.SO = "", e3.SI = "", e3.DLE = "", e3.DC1 = "", e3.DC2 = "", e3.DC3 = "", e3.DC4 = "", e3.NAK = "", e3.SYN = "", e3.ETB = "", e3.CAN = "", e3.EM = "", e3.SUB = "", e3.ESC = "\x1B", e3.FS = "", e3.GS = "", e3.RS = "", e3.US = "", e3.SP = " ", e3.DEL = "\x7F";
          }(i3 || (t3.C0 = i3 = {})), function(e3) {
            e3.PAD = "\x80", e3.HOP = "\x81", e3.BPH = "\x82", e3.NBH = "\x83", e3.IND = "\x84", e3.NEL = "\x85", e3.SSA = "\x86", e3.ESA = "\x87", e3.HTS = "\x88", e3.HTJ = "\x89", e3.VTS = "\x8A", e3.PLD = "\x8B", e3.PLU = "\x8C", e3.RI = "\x8D", e3.SS2 = "\x8E", e3.SS3 = "\x8F", e3.DCS = "\x90", e3.PU1 = "\x91", e3.PU2 = "\x92", e3.STS = "\x93", e3.CCH = "\x94", e3.MW = "\x95", e3.SPA = "\x96", e3.EPA = "\x97", e3.SOS = "\x98", e3.SGCI = "\x99", e3.SCI = "\x9A", e3.CSI = "\x9B", e3.ST = "\x9C", e3.OSC = "\x9D", e3.PM = "\x9E", e3.APC = "\x9F";
          }(s2 || (t3.C1 = s2 = {})), function(e3) {
            e3.ST = `${i3.ESC}\\`;
          }(r || (t3.C1_ESCAPED = r = {}));
        },
        7399: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.evaluateKeyboardEvent = void 0;
          const s2 = i3(2584), r = {
            48: [
              "0",
              ")"
            ],
            49: [
              "1",
              "!"
            ],
            50: [
              "2",
              "@"
            ],
            51: [
              "3",
              "#"
            ],
            52: [
              "4",
              "$"
            ],
            53: [
              "5",
              "%"
            ],
            54: [
              "6",
              "^"
            ],
            55: [
              "7",
              "&"
            ],
            56: [
              "8",
              "*"
            ],
            57: [
              "9",
              "("
            ],
            186: [
              ";",
              ":"
            ],
            187: [
              "=",
              "+"
            ],
            188: [
              ",",
              "<"
            ],
            189: [
              "-",
              "_"
            ],
            190: [
              ".",
              ">"
            ],
            191: [
              "/",
              "?"
            ],
            192: [
              "`",
              "~"
            ],
            219: [
              "[",
              "{"
            ],
            220: [
              "\\",
              "|"
            ],
            221: [
              "]",
              "}"
            ],
            222: [
              "'",
              '"'
            ]
          };
          t3.evaluateKeyboardEvent = function(e3, t4, i4, n) {
            const o = {
              type: 0,
              cancel: false,
              key: void 0
            }, a = (e3.shiftKey ? 1 : 0) | (e3.altKey ? 2 : 0) | (e3.ctrlKey ? 4 : 0) | (e3.metaKey ? 8 : 0);
            switch (e3.keyCode) {
              case 0:
                "UIKeyInputUpArrow" === e3.key ? o.key = t4 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A" : "UIKeyInputLeftArrow" === e3.key ? o.key = t4 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D" : "UIKeyInputRightArrow" === e3.key ? o.key = t4 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C" : "UIKeyInputDownArrow" === e3.key && (o.key = t4 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B");
                break;
              case 8:
                o.key = e3.ctrlKey ? "\b" : s2.C0.DEL, e3.altKey && (o.key = s2.C0.ESC + o.key);
                break;
              case 9:
                if (e3.shiftKey) {
                  o.key = s2.C0.ESC + "[Z";
                  break;
                }
                o.key = s2.C0.HT, o.cancel = true;
                break;
              case 13:
                o.key = e3.altKey ? s2.C0.ESC + s2.C0.CR : s2.C0.CR, o.cancel = true;
                break;
              case 27:
                o.key = s2.C0.ESC, e3.altKey && (o.key = s2.C0.ESC + s2.C0.ESC), o.cancel = true;
                break;
              case 37:
                if (e3.metaKey) break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "D", o.key === s2.C0.ESC + "[1;3D" && (o.key = s2.C0.ESC + (i4 ? "b" : "[1;5D"))) : o.key = t4 ? s2.C0.ESC + "OD" : s2.C0.ESC + "[D";
                break;
              case 39:
                if (e3.metaKey) break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "C", o.key === s2.C0.ESC + "[1;3C" && (o.key = s2.C0.ESC + (i4 ? "f" : "[1;5C"))) : o.key = t4 ? s2.C0.ESC + "OC" : s2.C0.ESC + "[C";
                break;
              case 38:
                if (e3.metaKey) break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "A", i4 || o.key !== s2.C0.ESC + "[1;3A" || (o.key = s2.C0.ESC + "[1;5A")) : o.key = t4 ? s2.C0.ESC + "OA" : s2.C0.ESC + "[A";
                break;
              case 40:
                if (e3.metaKey) break;
                a ? (o.key = s2.C0.ESC + "[1;" + (a + 1) + "B", i4 || o.key !== s2.C0.ESC + "[1;3B" || (o.key = s2.C0.ESC + "[1;5B")) : o.key = t4 ? s2.C0.ESC + "OB" : s2.C0.ESC + "[B";
                break;
              case 45:
                e3.shiftKey || e3.ctrlKey || (o.key = s2.C0.ESC + "[2~");
                break;
              case 46:
                o.key = a ? s2.C0.ESC + "[3;" + (a + 1) + "~" : s2.C0.ESC + "[3~";
                break;
              case 36:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "H" : t4 ? s2.C0.ESC + "OH" : s2.C0.ESC + "[H";
                break;
              case 35:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "F" : t4 ? s2.C0.ESC + "OF" : s2.C0.ESC + "[F";
                break;
              case 33:
                e3.shiftKey ? o.type = 2 : e3.ctrlKey ? o.key = s2.C0.ESC + "[5;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[5~";
                break;
              case 34:
                e3.shiftKey ? o.type = 3 : e3.ctrlKey ? o.key = s2.C0.ESC + "[6;" + (a + 1) + "~" : o.key = s2.C0.ESC + "[6~";
                break;
              case 112:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "P" : s2.C0.ESC + "OP";
                break;
              case 113:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "Q" : s2.C0.ESC + "OQ";
                break;
              case 114:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "R" : s2.C0.ESC + "OR";
                break;
              case 115:
                o.key = a ? s2.C0.ESC + "[1;" + (a + 1) + "S" : s2.C0.ESC + "OS";
                break;
              case 116:
                o.key = a ? s2.C0.ESC + "[15;" + (a + 1) + "~" : s2.C0.ESC + "[15~";
                break;
              case 117:
                o.key = a ? s2.C0.ESC + "[17;" + (a + 1) + "~" : s2.C0.ESC + "[17~";
                break;
              case 118:
                o.key = a ? s2.C0.ESC + "[18;" + (a + 1) + "~" : s2.C0.ESC + "[18~";
                break;
              case 119:
                o.key = a ? s2.C0.ESC + "[19;" + (a + 1) + "~" : s2.C0.ESC + "[19~";
                break;
              case 120:
                o.key = a ? s2.C0.ESC + "[20;" + (a + 1) + "~" : s2.C0.ESC + "[20~";
                break;
              case 121:
                o.key = a ? s2.C0.ESC + "[21;" + (a + 1) + "~" : s2.C0.ESC + "[21~";
                break;
              case 122:
                o.key = a ? s2.C0.ESC + "[23;" + (a + 1) + "~" : s2.C0.ESC + "[23~";
                break;
              case 123:
                o.key = a ? s2.C0.ESC + "[24;" + (a + 1) + "~" : s2.C0.ESC + "[24~";
                break;
              default:
                if (!e3.ctrlKey || e3.shiftKey || e3.altKey || e3.metaKey) if (i4 && !n || !e3.altKey || e3.metaKey) !i4 || e3.altKey || e3.ctrlKey || e3.shiftKey || !e3.metaKey ? e3.key && !e3.ctrlKey && !e3.altKey && !e3.metaKey && e3.keyCode >= 48 && 1 === e3.key.length ? o.key = e3.key : e3.key && e3.ctrlKey && ("_" === e3.key && (o.key = s2.C0.US), "@" === e3.key && (o.key = s2.C0.NUL)) : 65 === e3.keyCode && (o.type = 1);
                else {
                  const t5 = r[e3.keyCode], i5 = t5 == null ? void 0 : t5[e3.shiftKey ? 1 : 0];
                  if (i5) o.key = s2.C0.ESC + i5;
                  else if (e3.keyCode >= 65 && e3.keyCode <= 90) {
                    const t6 = e3.ctrlKey ? e3.keyCode - 64 : e3.keyCode + 32;
                    let i6 = String.fromCharCode(t6);
                    e3.shiftKey && (i6 = i6.toUpperCase()), o.key = s2.C0.ESC + i6;
                  } else if (32 === e3.keyCode) o.key = s2.C0.ESC + (e3.ctrlKey ? s2.C0.NUL : " ");
                  else if ("Dead" === e3.key && e3.code.startsWith("Key")) {
                    let t6 = e3.code.slice(3, 4);
                    e3.shiftKey || (t6 = t6.toLowerCase()), o.key = s2.C0.ESC + t6, o.cancel = true;
                  }
                }
                else e3.keyCode >= 65 && e3.keyCode <= 90 ? o.key = String.fromCharCode(e3.keyCode - 64) : 32 === e3.keyCode ? o.key = s2.C0.NUL : e3.keyCode >= 51 && e3.keyCode <= 55 ? o.key = String.fromCharCode(e3.keyCode - 51 + 27) : 56 === e3.keyCode ? o.key = s2.C0.DEL : 219 === e3.keyCode ? o.key = s2.C0.ESC : 220 === e3.keyCode ? o.key = s2.C0.FS : 221 === e3.keyCode && (o.key = s2.C0.GS);
            }
            return o;
          };
        },
        482: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Utf8ToUtf32 = t3.StringToUtf32 = t3.utf32ToString = t3.stringFromCodePoint = void 0, t3.stringFromCodePoint = function(e3) {
            return e3 > 65535 ? (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10)) + String.fromCharCode(e3 % 1024 + 56320)) : String.fromCharCode(e3);
          }, t3.utf32ToString = function(e3, t4 = 0, i3 = e3.length) {
            let s2 = "";
            for (let r = t4; r < i3; ++r) {
              let t5 = e3[r];
              t5 > 65535 ? (t5 -= 65536, s2 += String.fromCharCode(55296 + (t5 >> 10)) + String.fromCharCode(t5 % 1024 + 56320)) : s2 += String.fromCharCode(t5);
            }
            return s2;
          }, t3.StringToUtf32 = class {
            constructor() {
              this._interim = 0;
            }
            clear() {
              this._interim = 0;
            }
            decode(e3, t4) {
              const i3 = e3.length;
              if (!i3) return 0;
              let s2 = 0, r = 0;
              if (this._interim) {
                const i4 = e3.charCodeAt(r++);
                56320 <= i4 && i4 <= 57343 ? t4[s2++] = 1024 * (this._interim - 55296) + i4 - 56320 + 65536 : (t4[s2++] = this._interim, t4[s2++] = i4), this._interim = 0;
              }
              for (let n = r; n < i3; ++n) {
                const r2 = e3.charCodeAt(n);
                if (55296 <= r2 && r2 <= 56319) {
                  if (++n >= i3) return this._interim = r2, s2;
                  const o = e3.charCodeAt(n);
                  56320 <= o && o <= 57343 ? t4[s2++] = 1024 * (r2 - 55296) + o - 56320 + 65536 : (t4[s2++] = r2, t4[s2++] = o);
                } else 65279 !== r2 && (t4[s2++] = r2);
              }
              return s2;
            }
          }, t3.Utf8ToUtf32 = class {
            constructor() {
              this.interim = new Uint8Array(3);
            }
            clear() {
              this.interim.fill(0);
            }
            decode(e3, t4) {
              const i3 = e3.length;
              if (!i3) return 0;
              let s2, r, n, o, a = 0, h = 0, c = 0;
              if (this.interim[0]) {
                let s3 = false, r2 = this.interim[0];
                r2 &= 192 == (224 & r2) ? 31 : 224 == (240 & r2) ? 15 : 7;
                let n2, o2 = 0;
                for (; (n2 = 63 & this.interim[++o2]) && o2 < 4; ) r2 <<= 6, r2 |= n2;
                const h2 = 192 == (224 & this.interim[0]) ? 2 : 224 == (240 & this.interim[0]) ? 3 : 4, l2 = h2 - o2;
                for (; c < l2; ) {
                  if (c >= i3) return 0;
                  if (n2 = e3[c++], 128 != (192 & n2)) {
                    c--, s3 = true;
                    break;
                  }
                  this.interim[o2++] = n2, r2 <<= 6, r2 |= 63 & n2;
                }
                s3 || (2 === h2 ? r2 < 128 ? c-- : t4[a++] = r2 : 3 === h2 ? r2 < 2048 || r2 >= 55296 && r2 <= 57343 || 65279 === r2 || (t4[a++] = r2) : r2 < 65536 || r2 > 1114111 || (t4[a++] = r2)), this.interim.fill(0);
              }
              const l = i3 - 4;
              let d = c;
              for (; d < i3; ) {
                for (; !(!(d < l) || 128 & (s2 = e3[d]) || 128 & (r = e3[d + 1]) || 128 & (n = e3[d + 2]) || 128 & (o = e3[d + 3])); ) t4[a++] = s2, t4[a++] = r, t4[a++] = n, t4[a++] = o, d += 4;
                if (s2 = e3[d++], s2 < 128) t4[a++] = s2;
                else if (192 == (224 & s2)) {
                  if (d >= i3) return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (h = (31 & s2) << 6 | 63 & r, h < 128) {
                    d--;
                    continue;
                  }
                  t4[a++] = h;
                } else if (224 == (240 & s2)) {
                  if (d >= i3) return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (d >= i3) return this.interim[0] = s2, this.interim[1] = r, a;
                  if (n = e3[d++], 128 != (192 & n)) {
                    d--;
                    continue;
                  }
                  if (h = (15 & s2) << 12 | (63 & r) << 6 | 63 & n, h < 2048 || h >= 55296 && h <= 57343 || 65279 === h) continue;
                  t4[a++] = h;
                } else if (240 == (248 & s2)) {
                  if (d >= i3) return this.interim[0] = s2, a;
                  if (r = e3[d++], 128 != (192 & r)) {
                    d--;
                    continue;
                  }
                  if (d >= i3) return this.interim[0] = s2, this.interim[1] = r, a;
                  if (n = e3[d++], 128 != (192 & n)) {
                    d--;
                    continue;
                  }
                  if (d >= i3) return this.interim[0] = s2, this.interim[1] = r, this.interim[2] = n, a;
                  if (o = e3[d++], 128 != (192 & o)) {
                    d--;
                    continue;
                  }
                  if (h = (7 & s2) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & o, h < 65536 || h > 1114111) continue;
                  t4[a++] = h;
                }
              }
              return a;
            }
          };
        },
        225: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.UnicodeV6 = void 0;
          const s2 = i3(1480), r = [
            [
              768,
              879
            ],
            [
              1155,
              1158
            ],
            [
              1160,
              1161
            ],
            [
              1425,
              1469
            ],
            [
              1471,
              1471
            ],
            [
              1473,
              1474
            ],
            [
              1476,
              1477
            ],
            [
              1479,
              1479
            ],
            [
              1536,
              1539
            ],
            [
              1552,
              1557
            ],
            [
              1611,
              1630
            ],
            [
              1648,
              1648
            ],
            [
              1750,
              1764
            ],
            [
              1767,
              1768
            ],
            [
              1770,
              1773
            ],
            [
              1807,
              1807
            ],
            [
              1809,
              1809
            ],
            [
              1840,
              1866
            ],
            [
              1958,
              1968
            ],
            [
              2027,
              2035
            ],
            [
              2305,
              2306
            ],
            [
              2364,
              2364
            ],
            [
              2369,
              2376
            ],
            [
              2381,
              2381
            ],
            [
              2385,
              2388
            ],
            [
              2402,
              2403
            ],
            [
              2433,
              2433
            ],
            [
              2492,
              2492
            ],
            [
              2497,
              2500
            ],
            [
              2509,
              2509
            ],
            [
              2530,
              2531
            ],
            [
              2561,
              2562
            ],
            [
              2620,
              2620
            ],
            [
              2625,
              2626
            ],
            [
              2631,
              2632
            ],
            [
              2635,
              2637
            ],
            [
              2672,
              2673
            ],
            [
              2689,
              2690
            ],
            [
              2748,
              2748
            ],
            [
              2753,
              2757
            ],
            [
              2759,
              2760
            ],
            [
              2765,
              2765
            ],
            [
              2786,
              2787
            ],
            [
              2817,
              2817
            ],
            [
              2876,
              2876
            ],
            [
              2879,
              2879
            ],
            [
              2881,
              2883
            ],
            [
              2893,
              2893
            ],
            [
              2902,
              2902
            ],
            [
              2946,
              2946
            ],
            [
              3008,
              3008
            ],
            [
              3021,
              3021
            ],
            [
              3134,
              3136
            ],
            [
              3142,
              3144
            ],
            [
              3146,
              3149
            ],
            [
              3157,
              3158
            ],
            [
              3260,
              3260
            ],
            [
              3263,
              3263
            ],
            [
              3270,
              3270
            ],
            [
              3276,
              3277
            ],
            [
              3298,
              3299
            ],
            [
              3393,
              3395
            ],
            [
              3405,
              3405
            ],
            [
              3530,
              3530
            ],
            [
              3538,
              3540
            ],
            [
              3542,
              3542
            ],
            [
              3633,
              3633
            ],
            [
              3636,
              3642
            ],
            [
              3655,
              3662
            ],
            [
              3761,
              3761
            ],
            [
              3764,
              3769
            ],
            [
              3771,
              3772
            ],
            [
              3784,
              3789
            ],
            [
              3864,
              3865
            ],
            [
              3893,
              3893
            ],
            [
              3895,
              3895
            ],
            [
              3897,
              3897
            ],
            [
              3953,
              3966
            ],
            [
              3968,
              3972
            ],
            [
              3974,
              3975
            ],
            [
              3984,
              3991
            ],
            [
              3993,
              4028
            ],
            [
              4038,
              4038
            ],
            [
              4141,
              4144
            ],
            [
              4146,
              4146
            ],
            [
              4150,
              4151
            ],
            [
              4153,
              4153
            ],
            [
              4184,
              4185
            ],
            [
              4448,
              4607
            ],
            [
              4959,
              4959
            ],
            [
              5906,
              5908
            ],
            [
              5938,
              5940
            ],
            [
              5970,
              5971
            ],
            [
              6002,
              6003
            ],
            [
              6068,
              6069
            ],
            [
              6071,
              6077
            ],
            [
              6086,
              6086
            ],
            [
              6089,
              6099
            ],
            [
              6109,
              6109
            ],
            [
              6155,
              6157
            ],
            [
              6313,
              6313
            ],
            [
              6432,
              6434
            ],
            [
              6439,
              6440
            ],
            [
              6450,
              6450
            ],
            [
              6457,
              6459
            ],
            [
              6679,
              6680
            ],
            [
              6912,
              6915
            ],
            [
              6964,
              6964
            ],
            [
              6966,
              6970
            ],
            [
              6972,
              6972
            ],
            [
              6978,
              6978
            ],
            [
              7019,
              7027
            ],
            [
              7616,
              7626
            ],
            [
              7678,
              7679
            ],
            [
              8203,
              8207
            ],
            [
              8234,
              8238
            ],
            [
              8288,
              8291
            ],
            [
              8298,
              8303
            ],
            [
              8400,
              8431
            ],
            [
              12330,
              12335
            ],
            [
              12441,
              12442
            ],
            [
              43014,
              43014
            ],
            [
              43019,
              43019
            ],
            [
              43045,
              43046
            ],
            [
              64286,
              64286
            ],
            [
              65024,
              65039
            ],
            [
              65056,
              65059
            ],
            [
              65279,
              65279
            ],
            [
              65529,
              65531
            ]
          ], n = [
            [
              68097,
              68099
            ],
            [
              68101,
              68102
            ],
            [
              68108,
              68111
            ],
            [
              68152,
              68154
            ],
            [
              68159,
              68159
            ],
            [
              119143,
              119145
            ],
            [
              119155,
              119170
            ],
            [
              119173,
              119179
            ],
            [
              119210,
              119213
            ],
            [
              119362,
              119364
            ],
            [
              917505,
              917505
            ],
            [
              917536,
              917631
            ],
            [
              917760,
              917999
            ]
          ];
          let o;
          t3.UnicodeV6 = class {
            constructor() {
              if (this.version = "6", !o) {
                o = new Uint8Array(65536), o.fill(1), o[0] = 0, o.fill(0, 1, 32), o.fill(0, 127, 160), o.fill(2, 4352, 4448), o[9001] = 2, o[9002] = 2, o.fill(2, 11904, 42192), o[12351] = 1, o.fill(2, 44032, 55204), o.fill(2, 63744, 64256), o.fill(2, 65040, 65050), o.fill(2, 65072, 65136), o.fill(2, 65280, 65377), o.fill(2, 65504, 65511);
                for (let e3 = 0; e3 < r.length; ++e3) o.fill(0, r[e3][0], r[e3][1] + 1);
              }
            }
            wcwidth(e3) {
              return e3 < 32 ? 0 : e3 < 127 ? 1 : e3 < 65536 ? o[e3] : function(e4, t4) {
                let i4, s3 = 0, r2 = t4.length - 1;
                if (e4 < t4[0][0] || e4 > t4[r2][1]) return false;
                for (; r2 >= s3; ) if (i4 = s3 + r2 >> 1, e4 > t4[i4][1]) s3 = i4 + 1;
                else {
                  if (!(e4 < t4[i4][0])) return true;
                  r2 = i4 - 1;
                }
                return false;
              }(e3, n) ? 0 : e3 >= 131072 && e3 <= 196605 || e3 >= 196608 && e3 <= 262141 ? 2 : 1;
            }
            charProperties(e3, t4) {
              let i4 = this.wcwidth(e3), r2 = 0 === i4 && 0 !== t4;
              if (r2) {
                const e4 = s2.UnicodeService.extractWidth(t4);
                0 === e4 ? r2 = false : e4 > i4 && (i4 = e4);
              }
              return s2.UnicodeService.createPropertyValue(0, i4, r2);
            }
          };
        },
        5981: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.WriteBuffer = void 0;
          const s2 = i3(8460), r = i3(844);
          class n extends r.Disposable {
            constructor(e3) {
              super(), this._action = e3, this._writeBuffer = [], this._callbacks = [], this._pendingData = 0, this._bufferOffset = 0, this._isSyncWriting = false, this._syncCalls = 0, this._didUserInput = false, this._onWriteParsed = this.register(new s2.EventEmitter()), this.onWriteParsed = this._onWriteParsed.event;
            }
            handleUserInput() {
              this._didUserInput = true;
            }
            writeSync(e3, t4) {
              if (void 0 !== t4 && this._syncCalls > t4) return void (this._syncCalls = 0);
              if (this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(void 0), this._syncCalls++, this._isSyncWriting) return;
              let i4;
              for (this._isSyncWriting = true; i4 = this._writeBuffer.shift(); ) {
                this._action(i4);
                const e4 = this._callbacks.shift();
                e4 && e4();
              }
              this._pendingData = 0, this._bufferOffset = 2147483647, this._isSyncWriting = false, this._syncCalls = 0;
            }
            write(e3, t4) {
              if (this._pendingData > 5e7) throw new Error("write data discarded, use flow control to avoid losing data");
              if (!this._writeBuffer.length) {
                if (this._bufferOffset = 0, this._didUserInput) return this._didUserInput = false, this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t4), void this._innerWrite();
                setTimeout(() => this._innerWrite());
              }
              this._pendingData += e3.length, this._writeBuffer.push(e3), this._callbacks.push(t4);
            }
            _innerWrite(e3 = 0, t4 = true) {
              const i4 = e3 || Date.now();
              for (; this._writeBuffer.length > this._bufferOffset; ) {
                const e4 = this._writeBuffer[this._bufferOffset], s3 = this._action(e4, t4);
                if (s3) {
                  const e5 = (e6) => Date.now() - i4 >= 12 ? setTimeout(() => this._innerWrite(0, e6)) : this._innerWrite(i4, e6);
                  return void s3.catch((e6) => (queueMicrotask(() => {
                    throw e6;
                  }), Promise.resolve(false))).then(e5);
                }
                const r2 = this._callbacks[this._bufferOffset];
                if (r2 && r2(), this._bufferOffset++, this._pendingData -= e4.length, Date.now() - i4 >= 12) break;
              }
              this._writeBuffer.length > this._bufferOffset ? (this._bufferOffset > 50 && (this._writeBuffer = this._writeBuffer.slice(this._bufferOffset), this._callbacks = this._callbacks.slice(this._bufferOffset), this._bufferOffset = 0), setTimeout(() => this._innerWrite())) : (this._writeBuffer.length = 0, this._callbacks.length = 0, this._pendingData = 0, this._bufferOffset = 0), this._onWriteParsed.fire();
            }
          }
          t3.WriteBuffer = n;
        },
        5941: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.toRgbString = t3.parseColor = void 0;
          const i3 = /^([\da-f])\/([\da-f])\/([\da-f])$|^([\da-f]{2})\/([\da-f]{2})\/([\da-f]{2})$|^([\da-f]{3})\/([\da-f]{3})\/([\da-f]{3})$|^([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})$/, s2 = /^[\da-f]+$/;
          function r(e3, t4) {
            const i4 = e3.toString(16), s3 = i4.length < 2 ? "0" + i4 : i4;
            switch (t4) {
              case 4:
                return i4[0];
              case 8:
                return s3;
              case 12:
                return (s3 + s3).slice(0, 3);
              default:
                return s3 + s3;
            }
          }
          t3.parseColor = function(e3) {
            if (!e3) return;
            let t4 = e3.toLowerCase();
            if (0 === t4.indexOf("rgb:")) {
              t4 = t4.slice(4);
              const e4 = i3.exec(t4);
              if (e4) {
                const t5 = e4[1] ? 15 : e4[4] ? 255 : e4[7] ? 4095 : 65535;
                return [
                  Math.round(parseInt(e4[1] || e4[4] || e4[7] || e4[10], 16) / t5 * 255),
                  Math.round(parseInt(e4[2] || e4[5] || e4[8] || e4[11], 16) / t5 * 255),
                  Math.round(parseInt(e4[3] || e4[6] || e4[9] || e4[12], 16) / t5 * 255)
                ];
              }
            } else if (0 === t4.indexOf("#") && (t4 = t4.slice(1), s2.exec(t4) && [
              3,
              6,
              9,
              12
            ].includes(t4.length))) {
              const e4 = t4.length / 3, i4 = [
                0,
                0,
                0
              ];
              for (let s3 = 0; s3 < 3; ++s3) {
                const r2 = parseInt(t4.slice(e4 * s3, e4 * s3 + e4), 16);
                i4[s3] = 1 === e4 ? r2 << 4 : 2 === e4 ? r2 : 3 === e4 ? r2 >> 4 : r2 >> 8;
              }
              return i4;
            }
          }, t3.toRgbString = function(e3, t4 = 16) {
            const [i4, s3, n] = e3;
            return `rgb:${r(i4, t4)}/${r(s3, t4)}/${r(n, t4)}`;
          };
        },
        5770: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.PAYLOAD_LIMIT = void 0, t3.PAYLOAD_LIMIT = 1e7;
        },
        6351: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.DcsHandler = t3.DcsParser = void 0;
          const s2 = i3(482), r = i3(8742), n = i3(5770), o = [];
          t3.DcsParser = class {
            constructor() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._active = o, this._ident = 0, this._handlerFb = () => {
              }, this._stack = {
                paused: false,
                loopPosition: 0,
                fallThrough: false
              };
            }
            dispose() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._active = o;
            }
            registerHandler(e3, t4) {
              void 0 === this._handlers[e3] && (this._handlers[e3] = []);
              const i4 = this._handlers[e3];
              return i4.push(t4), {
                dispose: () => {
                  const e4 = i4.indexOf(t4);
                  -1 !== e4 && i4.splice(e4, 1);
                }
              };
            }
            clearHandler(e3) {
              this._handlers[e3] && delete this._handlers[e3];
            }
            setHandlerFallback(e3) {
              this._handlerFb = e3;
            }
            reset() {
              if (this._active.length) for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3) this._active[e3].unhook(false);
              this._stack.paused = false, this._active = o, this._ident = 0;
            }
            hook(e3, t4) {
              if (this.reset(), this._ident = e3, this._active = this._handlers[e3] || o, this._active.length) for (let e4 = this._active.length - 1; e4 >= 0; e4--) this._active[e4].hook(t4);
              else this._handlerFb(this._ident, "HOOK", t4);
            }
            put(e3, t4, i4) {
              if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e3, t4, i4);
              else this._handlerFb(this._ident, "PUT", (0, s2.utf32ToString)(e3, t4, i4));
            }
            unhook(e3, t4 = true) {
              if (this._active.length) {
                let i4 = false, s3 = this._active.length - 1, r2 = false;
                if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i4 = t4, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i4) {
                  for (; s3 >= 0 && (i4 = this._active[s3].unhook(e3), true !== i4); s3--) if (i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i4;
                  s3--;
                }
                for (; s3 >= 0; s3--) if (i4 = this._active[s3].unhook(false), i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i4;
              } else this._handlerFb(this._ident, "UNHOOK", e3);
              this._active = o, this._ident = 0;
            }
          };
          const a = new r.Params();
          a.addParam(0), t3.DcsHandler = class {
            constructor(e3) {
              this._handler = e3, this._data = "", this._params = a, this._hitLimit = false;
            }
            hook(e3) {
              this._params = e3.length > 1 || e3.params[0] ? e3.clone() : a, this._data = "", this._hitLimit = false;
            }
            put(e3, t4, i4) {
              this._hitLimit || (this._data += (0, s2.utf32ToString)(e3, t4, i4), this._data.length > n.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
            }
            unhook(e3) {
              let t4 = false;
              if (this._hitLimit) t4 = false;
              else if (e3 && (t4 = this._handler(this._data, this._params), t4 instanceof Promise)) return t4.then((e4) => (this._params = a, this._data = "", this._hitLimit = false, e4));
              return this._params = a, this._data = "", this._hitLimit = false, t4;
            }
          };
        },
        2015: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.EscapeSequenceParser = t3.VT500_TRANSITION_TABLE = t3.TransitionTable = void 0;
          const s2 = i3(844), r = i3(8742), n = i3(6242), o = i3(6351);
          class a {
            constructor(e3) {
              this.table = new Uint8Array(e3);
            }
            setDefault(e3, t4) {
              this.table.fill(e3 << 4 | t4);
            }
            add(e3, t4, i4, s3) {
              this.table[t4 << 8 | e3] = i4 << 4 | s3;
            }
            addMany(e3, t4, i4, s3) {
              for (let r2 = 0; r2 < e3.length; r2++) this.table[t4 << 8 | e3[r2]] = i4 << 4 | s3;
            }
          }
          t3.TransitionTable = a;
          const h = 160;
          t3.VT500_TRANSITION_TABLE = function() {
            const e3 = new a(4095), t4 = Array.apply(null, Array(256)).map((e4, t5) => t5), i4 = (e4, i5) => t4.slice(e4, i5), s3 = i4(32, 127), r2 = i4(0, 24);
            r2.push(25), r2.push.apply(r2, i4(28, 32));
            const n2 = i4(0, 14);
            let o2;
            for (o2 in e3.setDefault(1, 0), e3.addMany(s3, 0, 2, 0), n2) e3.addMany([
              24,
              26,
              153,
              154
            ], o2, 3, 0), e3.addMany(i4(128, 144), o2, 3, 0), e3.addMany(i4(144, 152), o2, 3, 0), e3.add(156, o2, 0, 0), e3.add(27, o2, 11, 1), e3.add(157, o2, 4, 8), e3.addMany([
              152,
              158,
              159
            ], o2, 0, 7), e3.add(155, o2, 11, 3), e3.add(144, o2, 11, 9);
            return e3.addMany(r2, 0, 3, 0), e3.addMany(r2, 1, 3, 1), e3.add(127, 1, 0, 1), e3.addMany(r2, 8, 0, 8), e3.addMany(r2, 3, 3, 3), e3.add(127, 3, 0, 3), e3.addMany(r2, 4, 3, 4), e3.add(127, 4, 0, 4), e3.addMany(r2, 6, 3, 6), e3.addMany(r2, 5, 3, 5), e3.add(127, 5, 0, 5), e3.addMany(r2, 2, 3, 2), e3.add(127, 2, 0, 2), e3.add(93, 1, 4, 8), e3.addMany(s3, 8, 5, 8), e3.add(127, 8, 5, 8), e3.addMany([
              156,
              27,
              24,
              26,
              7
            ], 8, 6, 0), e3.addMany(i4(28, 32), 8, 0, 8), e3.addMany([
              88,
              94,
              95
            ], 1, 0, 7), e3.addMany(s3, 7, 0, 7), e3.addMany(r2, 7, 0, 7), e3.add(156, 7, 0, 0), e3.add(127, 7, 0, 7), e3.add(91, 1, 11, 3), e3.addMany(i4(64, 127), 3, 7, 0), e3.addMany(i4(48, 60), 3, 8, 4), e3.addMany([
              60,
              61,
              62,
              63
            ], 3, 9, 4), e3.addMany(i4(48, 60), 4, 8, 4), e3.addMany(i4(64, 127), 4, 7, 0), e3.addMany([
              60,
              61,
              62,
              63
            ], 4, 0, 6), e3.addMany(i4(32, 64), 6, 0, 6), e3.add(127, 6, 0, 6), e3.addMany(i4(64, 127), 6, 0, 0), e3.addMany(i4(32, 48), 3, 9, 5), e3.addMany(i4(32, 48), 5, 9, 5), e3.addMany(i4(48, 64), 5, 0, 6), e3.addMany(i4(64, 127), 5, 7, 0), e3.addMany(i4(32, 48), 4, 9, 5), e3.addMany(i4(32, 48), 1, 9, 2), e3.addMany(i4(32, 48), 2, 9, 2), e3.addMany(i4(48, 127), 2, 10, 0), e3.addMany(i4(48, 80), 1, 10, 0), e3.addMany(i4(81, 88), 1, 10, 0), e3.addMany([
              89,
              90,
              92
            ], 1, 10, 0), e3.addMany(i4(96, 127), 1, 10, 0), e3.add(80, 1, 11, 9), e3.addMany(r2, 9, 0, 9), e3.add(127, 9, 0, 9), e3.addMany(i4(28, 32), 9, 0, 9), e3.addMany(i4(32, 48), 9, 9, 12), e3.addMany(i4(48, 60), 9, 8, 10), e3.addMany([
              60,
              61,
              62,
              63
            ], 9, 9, 10), e3.addMany(r2, 11, 0, 11), e3.addMany(i4(32, 128), 11, 0, 11), e3.addMany(i4(28, 32), 11, 0, 11), e3.addMany(r2, 10, 0, 10), e3.add(127, 10, 0, 10), e3.addMany(i4(28, 32), 10, 0, 10), e3.addMany(i4(48, 60), 10, 8, 10), e3.addMany([
              60,
              61,
              62,
              63
            ], 10, 0, 11), e3.addMany(i4(32, 48), 10, 9, 12), e3.addMany(r2, 12, 0, 12), e3.add(127, 12, 0, 12), e3.addMany(i4(28, 32), 12, 0, 12), e3.addMany(i4(32, 48), 12, 9, 12), e3.addMany(i4(48, 64), 12, 0, 11), e3.addMany(i4(64, 127), 12, 12, 13), e3.addMany(i4(64, 127), 10, 12, 13), e3.addMany(i4(64, 127), 9, 12, 13), e3.addMany(r2, 13, 13, 13), e3.addMany(s3, 13, 13, 13), e3.add(127, 13, 0, 13), e3.addMany([
              27,
              156,
              24,
              26
            ], 13, 14, 0), e3.add(h, 0, 2, 0), e3.add(h, 8, 5, 8), e3.add(h, 6, 0, 6), e3.add(h, 11, 0, 11), e3.add(h, 13, 13, 13), e3;
          }();
          class c extends s2.Disposable {
            constructor(e3 = t3.VT500_TRANSITION_TABLE) {
              super(), this._transitions = e3, this._parseStack = {
                state: 0,
                handlers: [],
                handlerPos: 0,
                transition: 0,
                chunkPos: 0
              }, this.initialState = 0, this.currentState = this.initialState, this._params = new r.Params(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, this._printHandlerFb = (e4, t4, i4) => {
              }, this._executeHandlerFb = (e4) => {
              }, this._csiHandlerFb = (e4, t4) => {
              }, this._escHandlerFb = (e4) => {
              }, this._errorHandlerFb = (e4) => e4, this._printHandler = this._printHandlerFb, this._executeHandlers = /* @__PURE__ */ Object.create(null), this._csiHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null), this.register((0, s2.toDisposable)(() => {
                this._csiHandlers = /* @__PURE__ */ Object.create(null), this._executeHandlers = /* @__PURE__ */ Object.create(null), this._escHandlers = /* @__PURE__ */ Object.create(null);
              })), this._oscParser = this.register(new n.OscParser()), this._dcsParser = this.register(new o.DcsParser()), this._errorHandler = this._errorHandlerFb, this.registerEscHandler({
                final: "\\"
              }, () => true);
            }
            _identifier(e3, t4 = [
              64,
              126
            ]) {
              let i4 = 0;
              if (e3.prefix) {
                if (e3.prefix.length > 1) throw new Error("only one byte as prefix supported");
                if (i4 = e3.prefix.charCodeAt(0), i4 && 60 > i4 || i4 > 63) throw new Error("prefix must be in range 0x3c .. 0x3f");
              }
              if (e3.intermediates) {
                if (e3.intermediates.length > 2) throw new Error("only two bytes as intermediates are supported");
                for (let t5 = 0; t5 < e3.intermediates.length; ++t5) {
                  const s4 = e3.intermediates.charCodeAt(t5);
                  if (32 > s4 || s4 > 47) throw new Error("intermediate must be in range 0x20 .. 0x2f");
                  i4 <<= 8, i4 |= s4;
                }
              }
              if (1 !== e3.final.length) throw new Error("final must be a single byte");
              const s3 = e3.final.charCodeAt(0);
              if (t4[0] > s3 || s3 > t4[1]) throw new Error(`final must be in range ${t4[0]} .. ${t4[1]}`);
              return i4 <<= 8, i4 |= s3, i4;
            }
            identToString(e3) {
              const t4 = [];
              for (; e3; ) t4.push(String.fromCharCode(255 & e3)), e3 >>= 8;
              return t4.reverse().join("");
            }
            setPrintHandler(e3) {
              this._printHandler = e3;
            }
            clearPrintHandler() {
              this._printHandler = this._printHandlerFb;
            }
            registerEscHandler(e3, t4) {
              const i4 = this._identifier(e3, [
                48,
                126
              ]);
              void 0 === this._escHandlers[i4] && (this._escHandlers[i4] = []);
              const s3 = this._escHandlers[i4];
              return s3.push(t4), {
                dispose: () => {
                  const e4 = s3.indexOf(t4);
                  -1 !== e4 && s3.splice(e4, 1);
                }
              };
            }
            clearEscHandler(e3) {
              this._escHandlers[this._identifier(e3, [
                48,
                126
              ])] && delete this._escHandlers[this._identifier(e3, [
                48,
                126
              ])];
            }
            setEscHandlerFallback(e3) {
              this._escHandlerFb = e3;
            }
            setExecuteHandler(e3, t4) {
              this._executeHandlers[e3.charCodeAt(0)] = t4;
            }
            clearExecuteHandler(e3) {
              this._executeHandlers[e3.charCodeAt(0)] && delete this._executeHandlers[e3.charCodeAt(0)];
            }
            setExecuteHandlerFallback(e3) {
              this._executeHandlerFb = e3;
            }
            registerCsiHandler(e3, t4) {
              const i4 = this._identifier(e3);
              void 0 === this._csiHandlers[i4] && (this._csiHandlers[i4] = []);
              const s3 = this._csiHandlers[i4];
              return s3.push(t4), {
                dispose: () => {
                  const e4 = s3.indexOf(t4);
                  -1 !== e4 && s3.splice(e4, 1);
                }
              };
            }
            clearCsiHandler(e3) {
              this._csiHandlers[this._identifier(e3)] && delete this._csiHandlers[this._identifier(e3)];
            }
            setCsiHandlerFallback(e3) {
              this._csiHandlerFb = e3;
            }
            registerDcsHandler(e3, t4) {
              return this._dcsParser.registerHandler(this._identifier(e3), t4);
            }
            clearDcsHandler(e3) {
              this._dcsParser.clearHandler(this._identifier(e3));
            }
            setDcsHandlerFallback(e3) {
              this._dcsParser.setHandlerFallback(e3);
            }
            registerOscHandler(e3, t4) {
              return this._oscParser.registerHandler(e3, t4);
            }
            clearOscHandler(e3) {
              this._oscParser.clearHandler(e3);
            }
            setOscHandlerFallback(e3) {
              this._oscParser.setHandlerFallback(e3);
            }
            setErrorHandler(e3) {
              this._errorHandler = e3;
            }
            clearErrorHandler() {
              this._errorHandler = this._errorHandlerFb;
            }
            reset() {
              this.currentState = this.initialState, this._oscParser.reset(), this._dcsParser.reset(), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0, 0 !== this._parseStack.state && (this._parseStack.state = 2, this._parseStack.handlers = []);
            }
            _preserveStack(e3, t4, i4, s3, r2) {
              this._parseStack.state = e3, this._parseStack.handlers = t4, this._parseStack.handlerPos = i4, this._parseStack.transition = s3, this._parseStack.chunkPos = r2;
            }
            parse(e3, t4, i4) {
              let s3, r2 = 0, n2 = 0, o2 = 0;
              if (this._parseStack.state) if (2 === this._parseStack.state) this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1;
              else {
                if (void 0 === i4 || 1 === this._parseStack.state) throw this._parseStack.state = 1, new Error("improper continuation due to previous async handler, giving up parsing");
                const t5 = this._parseStack.handlers;
                let n3 = this._parseStack.handlerPos - 1;
                switch (this._parseStack.state) {
                  case 3:
                    if (false === i4 && n3 > -1) {
                      for (; n3 >= 0 && (s3 = t5[n3](this._params), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                    }
                    this._parseStack.handlers = [];
                    break;
                  case 4:
                    if (false === i4 && n3 > -1) {
                      for (; n3 >= 0 && (s3 = t5[n3](), true !== s3); n3--) if (s3 instanceof Promise) return this._parseStack.handlerPos = n3, s3;
                    }
                    this._parseStack.handlers = [];
                    break;
                  case 6:
                    if (r2 = e3[this._parseStack.chunkPos], s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2, i4), s3) return s3;
                    27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                    break;
                  case 5:
                    if (r2 = e3[this._parseStack.chunkPos], s3 = this._oscParser.end(24 !== r2 && 26 !== r2, i4), s3) return s3;
                    27 === r2 && (this._parseStack.transition |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0;
                }
                this._parseStack.state = 0, o2 = this._parseStack.chunkPos + 1, this.precedingJoinState = 0, this.currentState = 15 & this._parseStack.transition;
              }
              for (let i5 = o2; i5 < t4; ++i5) {
                switch (r2 = e3[i5], n2 = this._transitions.table[this.currentState << 8 | (r2 < 160 ? r2 : h)], n2 >> 4) {
                  case 2:
                    for (let s4 = i5 + 1; ; ++s4) {
                      if (s4 >= t4 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i5, s4), i5 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t4 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i5, s4), i5 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t4 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i5, s4), i5 = s4 - 1;
                        break;
                      }
                      if (++s4 >= t4 || (r2 = e3[s4]) < 32 || r2 > 126 && r2 < h) {
                        this._printHandler(e3, i5, s4), i5 = s4 - 1;
                        break;
                      }
                    }
                    break;
                  case 3:
                    this._executeHandlers[r2] ? this._executeHandlers[r2]() : this._executeHandlerFb(r2), this.precedingJoinState = 0;
                    break;
                  case 0:
                    break;
                  case 1:
                    if (this._errorHandler({
                      position: i5,
                      code: r2,
                      currentState: this.currentState,
                      collect: this._collect,
                      params: this._params,
                      abort: false
                    }).abort) return;
                    break;
                  case 7:
                    const o3 = this._csiHandlers[this._collect << 8 | r2];
                    let a2 = o3 ? o3.length - 1 : -1;
                    for (; a2 >= 0 && (s3 = o3[a2](this._params), true !== s3); a2--) if (s3 instanceof Promise) return this._preserveStack(3, o3, a2, n2, i5), s3;
                    a2 < 0 && this._csiHandlerFb(this._collect << 8 | r2, this._params), this.precedingJoinState = 0;
                    break;
                  case 8:
                    do {
                      switch (r2) {
                        case 59:
                          this._params.addParam(0);
                          break;
                        case 58:
                          this._params.addSubParam(-1);
                          break;
                        default:
                          this._params.addDigit(r2 - 48);
                      }
                    } while (++i5 < t4 && (r2 = e3[i5]) > 47 && r2 < 60);
                    i5--;
                    break;
                  case 9:
                    this._collect <<= 8, this._collect |= r2;
                    break;
                  case 10:
                    const c2 = this._escHandlers[this._collect << 8 | r2];
                    let l = c2 ? c2.length - 1 : -1;
                    for (; l >= 0 && (s3 = c2[l](), true !== s3); l--) if (s3 instanceof Promise) return this._preserveStack(4, c2, l, n2, i5), s3;
                    l < 0 && this._escHandlerFb(this._collect << 8 | r2), this.precedingJoinState = 0;
                    break;
                  case 11:
                    this._params.reset(), this._params.addParam(0), this._collect = 0;
                    break;
                  case 12:
                    this._dcsParser.hook(this._collect << 8 | r2, this._params);
                    break;
                  case 13:
                    for (let s4 = i5 + 1; ; ++s4) if (s4 >= t4 || 24 === (r2 = e3[s4]) || 26 === r2 || 27 === r2 || r2 > 127 && r2 < h) {
                      this._dcsParser.put(e3, i5, s4), i5 = s4 - 1;
                      break;
                    }
                    break;
                  case 14:
                    if (s3 = this._dcsParser.unhook(24 !== r2 && 26 !== r2), s3) return this._preserveStack(6, [], 0, n2, i5), s3;
                    27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                    break;
                  case 4:
                    this._oscParser.start();
                    break;
                  case 5:
                    for (let s4 = i5 + 1; ; s4++) if (s4 >= t4 || (r2 = e3[s4]) < 32 || r2 > 127 && r2 < h) {
                      this._oscParser.put(e3, i5, s4), i5 = s4 - 1;
                      break;
                    }
                    break;
                  case 6:
                    if (s3 = this._oscParser.end(24 !== r2 && 26 !== r2), s3) return this._preserveStack(5, [], 0, n2, i5), s3;
                    27 === r2 && (n2 |= 1), this._params.reset(), this._params.addParam(0), this._collect = 0, this.precedingJoinState = 0;
                }
                this.currentState = 15 & n2;
              }
            }
          }
          t3.EscapeSequenceParser = c;
        },
        6242: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.OscHandler = t3.OscParser = void 0;
          const s2 = i3(5770), r = i3(482), n = [];
          t3.OscParser = class {
            constructor() {
              this._state = 0, this._active = n, this._id = -1, this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._stack = {
                paused: false,
                loopPosition: 0,
                fallThrough: false
              };
            }
            registerHandler(e3, t4) {
              void 0 === this._handlers[e3] && (this._handlers[e3] = []);
              const i4 = this._handlers[e3];
              return i4.push(t4), {
                dispose: () => {
                  const e4 = i4.indexOf(t4);
                  -1 !== e4 && i4.splice(e4, 1);
                }
              };
            }
            clearHandler(e3) {
              this._handlers[e3] && delete this._handlers[e3];
            }
            setHandlerFallback(e3) {
              this._handlerFb = e3;
            }
            dispose() {
              this._handlers = /* @__PURE__ */ Object.create(null), this._handlerFb = () => {
              }, this._active = n;
            }
            reset() {
              if (2 === this._state) for (let e3 = this._stack.paused ? this._stack.loopPosition - 1 : this._active.length - 1; e3 >= 0; --e3) this._active[e3].end(false);
              this._stack.paused = false, this._active = n, this._id = -1, this._state = 0;
            }
            _start() {
              if (this._active = this._handlers[this._id] || n, this._active.length) for (let e3 = this._active.length - 1; e3 >= 0; e3--) this._active[e3].start();
              else this._handlerFb(this._id, "START");
            }
            _put(e3, t4, i4) {
              if (this._active.length) for (let s3 = this._active.length - 1; s3 >= 0; s3--) this._active[s3].put(e3, t4, i4);
              else this._handlerFb(this._id, "PUT", (0, r.utf32ToString)(e3, t4, i4));
            }
            start() {
              this.reset(), this._state = 1;
            }
            put(e3, t4, i4) {
              if (3 !== this._state) {
                if (1 === this._state) for (; t4 < i4; ) {
                  const i5 = e3[t4++];
                  if (59 === i5) {
                    this._state = 2, this._start();
                    break;
                  }
                  if (i5 < 48 || 57 < i5) return void (this._state = 3);
                  -1 === this._id && (this._id = 0), this._id = 10 * this._id + i5 - 48;
                }
                2 === this._state && i4 - t4 > 0 && this._put(e3, t4, i4);
              }
            }
            end(e3, t4 = true) {
              if (0 !== this._state) {
                if (3 !== this._state) if (1 === this._state && this._start(), this._active.length) {
                  let i4 = false, s3 = this._active.length - 1, r2 = false;
                  if (this._stack.paused && (s3 = this._stack.loopPosition - 1, i4 = t4, r2 = this._stack.fallThrough, this._stack.paused = false), !r2 && false === i4) {
                    for (; s3 >= 0 && (i4 = this._active[s3].end(e3), true !== i4); s3--) if (i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = false, i4;
                    s3--;
                  }
                  for (; s3 >= 0; s3--) if (i4 = this._active[s3].end(false), i4 instanceof Promise) return this._stack.paused = true, this._stack.loopPosition = s3, this._stack.fallThrough = true, i4;
                } else this._handlerFb(this._id, "END", e3);
                this._active = n, this._id = -1, this._state = 0;
              }
            }
          }, t3.OscHandler = class {
            constructor(e3) {
              this._handler = e3, this._data = "", this._hitLimit = false;
            }
            start() {
              this._data = "", this._hitLimit = false;
            }
            put(e3, t4, i4) {
              this._hitLimit || (this._data += (0, r.utf32ToString)(e3, t4, i4), this._data.length > s2.PAYLOAD_LIMIT && (this._data = "", this._hitLimit = true));
            }
            end(e3) {
              let t4 = false;
              if (this._hitLimit) t4 = false;
              else if (e3 && (t4 = this._handler(this._data), t4 instanceof Promise)) return t4.then((e4) => (this._data = "", this._hitLimit = false, e4));
              return this._data = "", this._hitLimit = false, t4;
            }
          };
        },
        8742: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Params = void 0;
          const i3 = 2147483647;
          class s2 {
            static fromArray(e3) {
              const t4 = new s2();
              if (!e3.length) return t4;
              for (let i4 = Array.isArray(e3[0]) ? 1 : 0; i4 < e3.length; ++i4) {
                const s3 = e3[i4];
                if (Array.isArray(s3)) for (let e4 = 0; e4 < s3.length; ++e4) t4.addSubParam(s3[e4]);
                else t4.addParam(s3);
              }
              return t4;
            }
            constructor(e3 = 32, t4 = 32) {
              if (this.maxLength = e3, this.maxSubParamsLength = t4, t4 > 256) throw new Error("maxSubParamsLength must not be greater than 256");
              this.params = new Int32Array(e3), this.length = 0, this._subParams = new Int32Array(t4), this._subParamsLength = 0, this._subParamsIdx = new Uint16Array(e3), this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
            }
            clone() {
              const e3 = new s2(this.maxLength, this.maxSubParamsLength);
              return e3.params.set(this.params), e3.length = this.length, e3._subParams.set(this._subParams), e3._subParamsLength = this._subParamsLength, e3._subParamsIdx.set(this._subParamsIdx), e3._rejectDigits = this._rejectDigits, e3._rejectSubDigits = this._rejectSubDigits, e3._digitIsSub = this._digitIsSub, e3;
            }
            toArray() {
              const e3 = [];
              for (let t4 = 0; t4 < this.length; ++t4) {
                e3.push(this.params[t4]);
                const i4 = this._subParamsIdx[t4] >> 8, s3 = 255 & this._subParamsIdx[t4];
                s3 - i4 > 0 && e3.push(Array.prototype.slice.call(this._subParams, i4, s3));
              }
              return e3;
            }
            reset() {
              this.length = 0, this._subParamsLength = 0, this._rejectDigits = false, this._rejectSubDigits = false, this._digitIsSub = false;
            }
            addParam(e3) {
              if (this._digitIsSub = false, this.length >= this.maxLength) this._rejectDigits = true;
              else {
                if (e3 < -1) throw new Error("values lesser than -1 are not allowed");
                this._subParamsIdx[this.length] = this._subParamsLength << 8 | this._subParamsLength, this.params[this.length++] = e3 > i3 ? i3 : e3;
              }
            }
            addSubParam(e3) {
              if (this._digitIsSub = true, this.length) if (this._rejectDigits || this._subParamsLength >= this.maxSubParamsLength) this._rejectSubDigits = true;
              else {
                if (e3 < -1) throw new Error("values lesser than -1 are not allowed");
                this._subParams[this._subParamsLength++] = e3 > i3 ? i3 : e3, this._subParamsIdx[this.length - 1]++;
              }
            }
            hasSubParams(e3) {
              return (255 & this._subParamsIdx[e3]) - (this._subParamsIdx[e3] >> 8) > 0;
            }
            getSubParams(e3) {
              const t4 = this._subParamsIdx[e3] >> 8, i4 = 255 & this._subParamsIdx[e3];
              return i4 - t4 > 0 ? this._subParams.subarray(t4, i4) : null;
            }
            getSubParamsAll() {
              const e3 = {};
              for (let t4 = 0; t4 < this.length; ++t4) {
                const i4 = this._subParamsIdx[t4] >> 8, s3 = 255 & this._subParamsIdx[t4];
                s3 - i4 > 0 && (e3[t4] = this._subParams.slice(i4, s3));
              }
              return e3;
            }
            addDigit(e3) {
              let t4;
              if (this._rejectDigits || !(t4 = this._digitIsSub ? this._subParamsLength : this.length) || this._digitIsSub && this._rejectSubDigits) return;
              const s3 = this._digitIsSub ? this._subParams : this.params, r = s3[t4 - 1];
              s3[t4 - 1] = ~r ? Math.min(10 * r + e3, i3) : e3;
            }
          }
          t3.Params = s2;
        },
        5741: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.AddonManager = void 0, t3.AddonManager = class {
            constructor() {
              this._addons = [];
            }
            dispose() {
              for (let e3 = this._addons.length - 1; e3 >= 0; e3--) this._addons[e3].instance.dispose();
            }
            loadAddon(e3, t4) {
              const i3 = {
                instance: t4,
                dispose: t4.dispose,
                isDisposed: false
              };
              this._addons.push(i3), t4.dispose = () => this._wrappedAddonDispose(i3), t4.activate(e3);
            }
            _wrappedAddonDispose(e3) {
              if (e3.isDisposed) return;
              let t4 = -1;
              for (let i3 = 0; i3 < this._addons.length; i3++) if (this._addons[i3] === e3) {
                t4 = i3;
                break;
              }
              if (-1 === t4) throw new Error("Could not dispose an addon that has not been loaded");
              e3.isDisposed = true, e3.dispose.apply(e3.instance), this._addons.splice(t4, 1);
            }
          };
        },
        8771: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferApiView = void 0;
          const s2 = i3(3785), r = i3(511);
          t3.BufferApiView = class {
            constructor(e3, t4) {
              this._buffer = e3, this.type = t4;
            }
            init(e3) {
              return this._buffer = e3, this;
            }
            get cursorY() {
              return this._buffer.y;
            }
            get cursorX() {
              return this._buffer.x;
            }
            get viewportY() {
              return this._buffer.ydisp;
            }
            get baseY() {
              return this._buffer.ybase;
            }
            get length() {
              return this._buffer.lines.length;
            }
            getLine(e3) {
              const t4 = this._buffer.lines.get(e3);
              if (t4) return new s2.BufferLineApiView(t4);
            }
            getNullCell() {
              return new r.CellData();
            }
          };
        },
        3785: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferLineApiView = void 0;
          const s2 = i3(511);
          t3.BufferLineApiView = class {
            constructor(e3) {
              this._line = e3;
            }
            get isWrapped() {
              return this._line.isWrapped;
            }
            get length() {
              return this._line.length;
            }
            getCell(e3, t4) {
              if (!(e3 < 0 || e3 >= this._line.length)) return t4 ? (this._line.loadCell(e3, t4), t4) : this._line.loadCell(e3, new s2.CellData());
            }
            translateToString(e3, t4, i4) {
              return this._line.translateToString(e3, t4, i4);
            }
          };
        },
        8285: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferNamespaceApi = void 0;
          const s2 = i3(8771), r = i3(8460), n = i3(844);
          class o extends n.Disposable {
            constructor(e3) {
              super(), this._core = e3, this._onBufferChange = this.register(new r.EventEmitter()), this.onBufferChange = this._onBufferChange.event, this._normal = new s2.BufferApiView(this._core.buffers.normal, "normal"), this._alternate = new s2.BufferApiView(this._core.buffers.alt, "alternate"), this._core.buffers.onBufferActivate(() => this._onBufferChange.fire(this.active));
            }
            get active() {
              if (this._core.buffers.active === this._core.buffers.normal) return this.normal;
              if (this._core.buffers.active === this._core.buffers.alt) return this.alternate;
              throw new Error("Active buffer is neither normal nor alternate");
            }
            get normal() {
              return this._normal.init(this._core.buffers.normal);
            }
            get alternate() {
              return this._alternate.init(this._core.buffers.alt);
            }
          }
          t3.BufferNamespaceApi = o;
        },
        7975: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.ParserApi = void 0, t3.ParserApi = class {
            constructor(e3) {
              this._core = e3;
            }
            registerCsiHandler(e3, t4) {
              return this._core.registerCsiHandler(e3, (e4) => t4(e4.toArray()));
            }
            addCsiHandler(e3, t4) {
              return this.registerCsiHandler(e3, t4);
            }
            registerDcsHandler(e3, t4) {
              return this._core.registerDcsHandler(e3, (e4, i3) => t4(e4, i3.toArray()));
            }
            addDcsHandler(e3, t4) {
              return this.registerDcsHandler(e3, t4);
            }
            registerEscHandler(e3, t4) {
              return this._core.registerEscHandler(e3, t4);
            }
            addEscHandler(e3, t4) {
              return this.registerEscHandler(e3, t4);
            }
            registerOscHandler(e3, t4) {
              return this._core.registerOscHandler(e3, t4);
            }
            addOscHandler(e3, t4) {
              return this.registerOscHandler(e3, t4);
            }
          };
        },
        7090: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.UnicodeApi = void 0, t3.UnicodeApi = class {
            constructor(e3) {
              this._core = e3;
            }
            register(e3) {
              this._core.unicodeService.register(e3);
            }
            get versions() {
              return this._core.unicodeService.versions;
            }
            get activeVersion() {
              return this._core.unicodeService.activeVersion;
            }
            set activeVersion(e3) {
              this._core.unicodeService.activeVersion = e3;
            }
          };
        },
        744: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.BufferService = t3.MINIMUM_ROWS = t3.MINIMUM_COLS = void 0;
          const n = i3(8460), o = i3(844), a = i3(5295), h = i3(2585);
          t3.MINIMUM_COLS = 2, t3.MINIMUM_ROWS = 1;
          let c = t3.BufferService = class extends o.Disposable {
            get buffer() {
              return this.buffers.active;
            }
            constructor(e3) {
              super(), this.isUserScrolling = false, this._onResize = this.register(new n.EventEmitter()), this.onResize = this._onResize.event, this._onScroll = this.register(new n.EventEmitter()), this.onScroll = this._onScroll.event, this.cols = Math.max(e3.rawOptions.cols || 0, t3.MINIMUM_COLS), this.rows = Math.max(e3.rawOptions.rows || 0, t3.MINIMUM_ROWS), this.buffers = this.register(new a.BufferSet(e3, this));
            }
            resize(e3, t4) {
              this.cols = e3, this.rows = t4, this.buffers.resize(e3, t4), this._onResize.fire({
                cols: e3,
                rows: t4
              });
            }
            reset() {
              this.buffers.reset(), this.isUserScrolling = false;
            }
            scroll(e3, t4 = false) {
              const i4 = this.buffer;
              let s3;
              s3 = this._cachedBlankLine, s3 && s3.length === this.cols && s3.getFg(0) === e3.fg && s3.getBg(0) === e3.bg || (s3 = i4.getBlankLine(e3, t4), this._cachedBlankLine = s3), s3.isWrapped = t4;
              const r2 = i4.ybase + i4.scrollTop, n2 = i4.ybase + i4.scrollBottom;
              if (0 === i4.scrollTop) {
                const e4 = i4.lines.isFull;
                n2 === i4.lines.length - 1 ? e4 ? i4.lines.recycle().copyFrom(s3) : i4.lines.push(s3.clone()) : i4.lines.splice(n2 + 1, 0, s3.clone()), e4 ? this.isUserScrolling && (i4.ydisp = Math.max(i4.ydisp - 1, 0)) : (i4.ybase++, this.isUserScrolling || i4.ydisp++);
              } else {
                const e4 = n2 - r2 + 1;
                i4.lines.shiftElements(r2 + 1, e4 - 1, -1), i4.lines.set(n2, s3.clone());
              }
              this.isUserScrolling || (i4.ydisp = i4.ybase), this._onScroll.fire(i4.ydisp);
            }
            scrollLines(e3, t4, i4) {
              const s3 = this.buffer;
              if (e3 < 0) {
                if (0 === s3.ydisp) return;
                this.isUserScrolling = true;
              } else e3 + s3.ydisp >= s3.ybase && (this.isUserScrolling = false);
              const r2 = s3.ydisp;
              s3.ydisp = Math.max(Math.min(s3.ydisp + e3, s3.ybase), 0), r2 !== s3.ydisp && (t4 || this._onScroll.fire(s3.ydisp));
            }
          };
          t3.BufferService = c = s2([
            r(0, h.IOptionsService)
          ], c);
        },
        7994: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CharsetService = void 0, t3.CharsetService = class {
            constructor() {
              this.glevel = 0, this._charsets = [];
            }
            reset() {
              this.charset = void 0, this._charsets = [], this.glevel = 0;
            }
            setgLevel(e3) {
              this.glevel = e3, this.charset = this._charsets[e3];
            }
            setgCharset(e3, t4) {
              this._charsets[e3] = t4, this.glevel === e3 && (this.charset = t4);
            }
          };
        },
        1753: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CoreMouseService = void 0;
          const n = i3(2585), o = i3(8460), a = i3(844), h = {
            NONE: {
              events: 0,
              restrict: () => false
            },
            X10: {
              events: 1,
              restrict: (e3) => 4 !== e3.button && 1 === e3.action && (e3.ctrl = false, e3.alt = false, e3.shift = false, true)
            },
            VT200: {
              events: 19,
              restrict: (e3) => 32 !== e3.action
            },
            DRAG: {
              events: 23,
              restrict: (e3) => 32 !== e3.action || 3 !== e3.button
            },
            ANY: {
              events: 31,
              restrict: (e3) => true
            }
          };
          function c(e3, t4) {
            let i4 = (e3.ctrl ? 16 : 0) | (e3.shift ? 4 : 0) | (e3.alt ? 8 : 0);
            return 4 === e3.button ? (i4 |= 64, i4 |= e3.action) : (i4 |= 3 & e3.button, 4 & e3.button && (i4 |= 64), 8 & e3.button && (i4 |= 128), 32 === e3.action ? i4 |= 32 : 0 !== e3.action || t4 || (i4 |= 3)), i4;
          }
          const l = String.fromCharCode, d = {
            DEFAULT: (e3) => {
              const t4 = [
                c(e3, false) + 32,
                e3.col + 32,
                e3.row + 32
              ];
              return t4[0] > 255 || t4[1] > 255 || t4[2] > 255 ? "" : `\x1B[M${l(t4[0])}${l(t4[1])}${l(t4[2])}`;
            },
            SGR: (e3) => {
              const t4 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
              return `\x1B[<${c(e3, true)};${e3.col};${e3.row}${t4}`;
            },
            SGR_PIXELS: (e3) => {
              const t4 = 0 === e3.action && 4 !== e3.button ? "m" : "M";
              return `\x1B[<${c(e3, true)};${e3.x};${e3.y}${t4}`;
            }
          };
          let _ = t3.CoreMouseService = class extends a.Disposable {
            constructor(e3, t4) {
              super(), this._bufferService = e3, this._coreService = t4, this._protocols = {}, this._encodings = {}, this._activeProtocol = "", this._activeEncoding = "", this._lastEvent = null, this._onProtocolChange = this.register(new o.EventEmitter()), this.onProtocolChange = this._onProtocolChange.event;
              for (const e4 of Object.keys(h)) this.addProtocol(e4, h[e4]);
              for (const e4 of Object.keys(d)) this.addEncoding(e4, d[e4]);
              this.reset();
            }
            addProtocol(e3, t4) {
              this._protocols[e3] = t4;
            }
            addEncoding(e3, t4) {
              this._encodings[e3] = t4;
            }
            get activeProtocol() {
              return this._activeProtocol;
            }
            get areMouseEventsActive() {
              return 0 !== this._protocols[this._activeProtocol].events;
            }
            set activeProtocol(e3) {
              if (!this._protocols[e3]) throw new Error(`unknown protocol "${e3}"`);
              this._activeProtocol = e3, this._onProtocolChange.fire(this._protocols[e3].events);
            }
            get activeEncoding() {
              return this._activeEncoding;
            }
            set activeEncoding(e3) {
              if (!this._encodings[e3]) throw new Error(`unknown encoding "${e3}"`);
              this._activeEncoding = e3;
            }
            reset() {
              this.activeProtocol = "NONE", this.activeEncoding = "DEFAULT", this._lastEvent = null;
            }
            triggerMouseEvent(e3) {
              if (e3.col < 0 || e3.col >= this._bufferService.cols || e3.row < 0 || e3.row >= this._bufferService.rows) return false;
              if (4 === e3.button && 32 === e3.action) return false;
              if (3 === e3.button && 32 !== e3.action) return false;
              if (4 !== e3.button && (2 === e3.action || 3 === e3.action)) return false;
              if (e3.col++, e3.row++, 32 === e3.action && this._lastEvent && this._equalEvents(this._lastEvent, e3, "SGR_PIXELS" === this._activeEncoding)) return false;
              if (!this._protocols[this._activeProtocol].restrict(e3)) return false;
              const t4 = this._encodings[this._activeEncoding](e3);
              return t4 && ("DEFAULT" === this._activeEncoding ? this._coreService.triggerBinaryEvent(t4) : this._coreService.triggerDataEvent(t4, true)), this._lastEvent = e3, true;
            }
            explainEvents(e3) {
              return {
                down: !!(1 & e3),
                up: !!(2 & e3),
                drag: !!(4 & e3),
                move: !!(8 & e3),
                wheel: !!(16 & e3)
              };
            }
            _equalEvents(e3, t4, i4) {
              if (i4) {
                if (e3.x !== t4.x) return false;
                if (e3.y !== t4.y) return false;
              } else {
                if (e3.col !== t4.col) return false;
                if (e3.row !== t4.row) return false;
              }
              return e3.button === t4.button && e3.action === t4.action && e3.ctrl === t4.ctrl && e3.alt === t4.alt && e3.shift === t4.shift;
            }
          };
          t3.CoreMouseService = _ = s2([
            r(0, n.IBufferService),
            r(1, n.ICoreService)
          ], _);
        },
        6975: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.CoreService = void 0;
          const n = i3(1439), o = i3(8460), a = i3(844), h = i3(2585), c = Object.freeze({
            insertMode: false
          }), l = Object.freeze({
            applicationCursorKeys: false,
            applicationKeypad: false,
            bracketedPasteMode: false,
            origin: false,
            reverseWraparound: false,
            sendFocus: false,
            wraparound: true
          });
          let d = t3.CoreService = class extends a.Disposable {
            constructor(e3, t4, i4) {
              super(), this._bufferService = e3, this._logService = t4, this._optionsService = i4, this.isCursorInitialized = false, this.isCursorHidden = false, this._onData = this.register(new o.EventEmitter()), this.onData = this._onData.event, this._onUserInput = this.register(new o.EventEmitter()), this.onUserInput = this._onUserInput.event, this._onBinary = this.register(new o.EventEmitter()), this.onBinary = this._onBinary.event, this._onRequestScrollToBottom = this.register(new o.EventEmitter()), this.onRequestScrollToBottom = this._onRequestScrollToBottom.event, this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
            }
            reset() {
              this.modes = (0, n.clone)(c), this.decPrivateModes = (0, n.clone)(l);
            }
            triggerDataEvent(e3, t4 = false) {
              if (this._optionsService.rawOptions.disableStdin) return;
              const i4 = this._bufferService.buffer;
              t4 && this._optionsService.rawOptions.scrollOnUserInput && i4.ybase !== i4.ydisp && this._onRequestScrollToBottom.fire(), t4 && this._onUserInput.fire(), this._logService.debug(`sending data "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onData.fire(e3);
            }
            triggerBinaryEvent(e3) {
              this._optionsService.rawOptions.disableStdin || (this._logService.debug(`sending binary "${e3}"`, () => e3.split("").map((e4) => e4.charCodeAt(0))), this._onBinary.fire(e3));
            }
          };
          t3.CoreService = d = s2([
            r(0, h.IBufferService),
            r(1, h.ILogService),
            r(2, h.IOptionsService)
          ], d);
        },
        9074: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.DecorationService = void 0;
          const s2 = i3(8055), r = i3(8460), n = i3(844), o = i3(6106);
          let a = 0, h = 0;
          class c extends n.Disposable {
            get decorations() {
              return this._decorations.values();
            }
            constructor() {
              super(), this._decorations = new o.SortedList((e3) => e3 == null ? void 0 : e3.marker.line), this._onDecorationRegistered = this.register(new r.EventEmitter()), this.onDecorationRegistered = this._onDecorationRegistered.event, this._onDecorationRemoved = this.register(new r.EventEmitter()), this.onDecorationRemoved = this._onDecorationRemoved.event, this.register((0, n.toDisposable)(() => this.reset()));
            }
            registerDecoration(e3) {
              if (e3.marker.isDisposed) return;
              const t4 = new l(e3);
              if (t4) {
                const e4 = t4.marker.onDispose(() => t4.dispose());
                t4.onDispose(() => {
                  t4 && (this._decorations.delete(t4) && this._onDecorationRemoved.fire(t4), e4.dispose());
                }), this._decorations.insert(t4), this._onDecorationRegistered.fire(t4);
              }
              return t4;
            }
            reset() {
              for (const e3 of this._decorations.values()) e3.dispose();
              this._decorations.clear();
            }
            *getDecorationsAtCell(e3, t4, i4) {
              let s3 = 0, r2 = 0;
              for (const n2 of this._decorations.getKeyIterator(t4)) s3 = n2.options.x ?? 0, r2 = s3 + (n2.options.width ?? 1), e3 >= s3 && e3 < r2 && (!i4 || (n2.options.layer ?? "bottom") === i4) && (yield n2);
            }
            forEachDecorationAtCell(e3, t4, i4, s3) {
              this._decorations.forEachByKey(t4, (t5) => {
                a = t5.options.x ?? 0, h = a + (t5.options.width ?? 1), e3 >= a && e3 < h && (!i4 || (t5.options.layer ?? "bottom") === i4) && s3(t5);
              });
            }
          }
          t3.DecorationService = c;
          class l extends n.Disposable {
            get isDisposed() {
              return this._isDisposed;
            }
            get backgroundColorRGB() {
              return null === this._cachedBg && (this.options.backgroundColor ? this._cachedBg = s2.css.toColor(this.options.backgroundColor) : this._cachedBg = void 0), this._cachedBg;
            }
            get foregroundColorRGB() {
              return null === this._cachedFg && (this.options.foregroundColor ? this._cachedFg = s2.css.toColor(this.options.foregroundColor) : this._cachedFg = void 0), this._cachedFg;
            }
            constructor(e3) {
              super(), this.options = e3, this.onRenderEmitter = this.register(new r.EventEmitter()), this.onRender = this.onRenderEmitter.event, this._onDispose = this.register(new r.EventEmitter()), this.onDispose = this._onDispose.event, this._cachedBg = null, this._cachedFg = null, this.marker = e3.marker, this.options.overviewRulerOptions && !this.options.overviewRulerOptions.position && (this.options.overviewRulerOptions.position = "full");
            }
            dispose() {
              this._onDispose.fire(), super.dispose();
            }
          }
        },
        4348: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.InstantiationService = t3.ServiceCollection = void 0;
          const s2 = i3(2585), r = i3(8343);
          class n {
            constructor(...e3) {
              this._entries = /* @__PURE__ */ new Map();
              for (const [t4, i4] of e3) this.set(t4, i4);
            }
            set(e3, t4) {
              const i4 = this._entries.get(e3);
              return this._entries.set(e3, t4), i4;
            }
            forEach(e3) {
              for (const [t4, i4] of this._entries.entries()) e3(t4, i4);
            }
            has(e3) {
              return this._entries.has(e3);
            }
            get(e3) {
              return this._entries.get(e3);
            }
          }
          t3.ServiceCollection = n, t3.InstantiationService = class {
            constructor() {
              this._services = new n(), this._services.set(s2.IInstantiationService, this);
            }
            setService(e3, t4) {
              this._services.set(e3, t4);
            }
            getService(e3) {
              return this._services.get(e3);
            }
            createInstance(e3, ...t4) {
              const i4 = (0, r.getServiceDependencies)(e3).sort((e4, t5) => e4.index - t5.index), s3 = [];
              for (const t5 of i4) {
                const i5 = this._services.get(t5.id);
                if (!i5) throw new Error(`[createInstance] ${e3.name} depends on UNKNOWN service ${t5.id}.`);
                s3.push(i5);
              }
              const n2 = i4.length > 0 ? i4[0].index : t4.length;
              if (t4.length !== n2) throw new Error(`[createInstance] First service dependency of ${e3.name} at position ${n2 + 1} conflicts with ${t4.length} static arguments`);
              return new e3(...[
                ...t4,
                ...s3
              ]);
            }
          };
        },
        7866: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a2 = e3.length - 1; a2 >= 0; a2--) (r2 = e3[a2]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.traceCall = t3.setTraceLogger = t3.LogService = void 0;
          const n = i3(844), o = i3(2585), a = {
            trace: o.LogLevelEnum.TRACE,
            debug: o.LogLevelEnum.DEBUG,
            info: o.LogLevelEnum.INFO,
            warn: o.LogLevelEnum.WARN,
            error: o.LogLevelEnum.ERROR,
            off: o.LogLevelEnum.OFF
          };
          let h, c = t3.LogService = class extends n.Disposable {
            get logLevel() {
              return this._logLevel;
            }
            constructor(e3) {
              super(), this._optionsService = e3, this._logLevel = o.LogLevelEnum.OFF, this._updateLogLevel(), this.register(this._optionsService.onSpecificOptionChange("logLevel", () => this._updateLogLevel())), h = this;
            }
            _updateLogLevel() {
              this._logLevel = a[this._optionsService.rawOptions.logLevel];
            }
            _evalLazyOptionalParams(e3) {
              for (let t4 = 0; t4 < e3.length; t4++) "function" == typeof e3[t4] && (e3[t4] = e3[t4]());
            }
            _log(e3, t4, i4) {
              this._evalLazyOptionalParams(i4), e3.call(console, (this._optionsService.options.logger ? "" : "xterm.js: ") + t4, ...i4);
            }
            trace(e3, ...t4) {
              var _a2;
              this._logLevel <= o.LogLevelEnum.TRACE && this._log(((_a2 = this._optionsService.options.logger) == null ? void 0 : _a2.trace.bind(this._optionsService.options.logger)) ?? console.log, e3, t4);
            }
            debug(e3, ...t4) {
              var _a2;
              this._logLevel <= o.LogLevelEnum.DEBUG && this._log(((_a2 = this._optionsService.options.logger) == null ? void 0 : _a2.debug.bind(this._optionsService.options.logger)) ?? console.log, e3, t4);
            }
            info(e3, ...t4) {
              var _a2;
              this._logLevel <= o.LogLevelEnum.INFO && this._log(((_a2 = this._optionsService.options.logger) == null ? void 0 : _a2.info.bind(this._optionsService.options.logger)) ?? console.info, e3, t4);
            }
            warn(e3, ...t4) {
              var _a2;
              this._logLevel <= o.LogLevelEnum.WARN && this._log(((_a2 = this._optionsService.options.logger) == null ? void 0 : _a2.warn.bind(this._optionsService.options.logger)) ?? console.warn, e3, t4);
            }
            error(e3, ...t4) {
              var _a2;
              this._logLevel <= o.LogLevelEnum.ERROR && this._log(((_a2 = this._optionsService.options.logger) == null ? void 0 : _a2.error.bind(this._optionsService.options.logger)) ?? console.error, e3, t4);
            }
          };
          t3.LogService = c = s2([
            r(0, o.IOptionsService)
          ], c), t3.setTraceLogger = function(e3) {
            h = e3;
          }, t3.traceCall = function(e3, t4, i4) {
            if ("function" != typeof i4.value) throw new Error("not supported");
            const s3 = i4.value;
            i4.value = function(...e4) {
              if (h.logLevel !== o.LogLevelEnum.TRACE) return s3.apply(this, e4);
              h.trace(`GlyphRenderer#${s3.name}(${e4.map((e5) => JSON.stringify(e5)).join(", ")})`);
              const t5 = s3.apply(this, e4);
              return h.trace(`GlyphRenderer#${s3.name} return`, t5), t5;
            };
          };
        },
        7302: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.OptionsService = t3.DEFAULT_OPTIONS = void 0;
          const s2 = i3(8460), r = i3(844), n = i3(6114);
          t3.DEFAULT_OPTIONS = {
            cols: 80,
            rows: 24,
            cursorBlink: false,
            cursorStyle: "block",
            cursorWidth: 1,
            cursorInactiveStyle: "outline",
            customGlyphs: true,
            drawBoldTextInBrightColors: true,
            documentOverride: null,
            fastScrollModifier: "alt",
            fastScrollSensitivity: 5,
            fontFamily: "courier-new, courier, monospace",
            fontSize: 15,
            fontWeight: "normal",
            fontWeightBold: "bold",
            ignoreBracketedPasteMode: false,
            lineHeight: 1,
            letterSpacing: 0,
            linkHandler: null,
            logLevel: "info",
            logger: null,
            scrollback: 1e3,
            scrollOnUserInput: true,
            scrollSensitivity: 1,
            screenReaderMode: false,
            smoothScrollDuration: 0,
            macOptionIsMeta: false,
            macOptionClickForcesSelection: false,
            minimumContrastRatio: 1,
            disableStdin: false,
            allowProposedApi: false,
            allowTransparency: false,
            tabStopWidth: 8,
            theme: {},
            rescaleOverlappingGlyphs: false,
            rightClickSelectsWord: n.isMac,
            windowOptions: {},
            windowsMode: false,
            windowsPty: {},
            wordSeparator: " ()[]{}',\"`",
            altClickMovesCursor: true,
            convertEol: false,
            termName: "xterm",
            cancelEvents: false,
            overviewRulerWidth: 0
          };
          const o = [
            "normal",
            "bold",
            "100",
            "200",
            "300",
            "400",
            "500",
            "600",
            "700",
            "800",
            "900"
          ];
          class a extends r.Disposable {
            constructor(e3) {
              super(), this._onOptionChange = this.register(new s2.EventEmitter()), this.onOptionChange = this._onOptionChange.event;
              const i4 = {
                ...t3.DEFAULT_OPTIONS
              };
              for (const t4 in e3) if (t4 in i4) try {
                const s3 = e3[t4];
                i4[t4] = this._sanitizeAndValidateOption(t4, s3);
              } catch (e4) {
                console.error(e4);
              }
              this.rawOptions = i4, this.options = {
                ...i4
              }, this._setupOptions(), this.register((0, r.toDisposable)(() => {
                this.rawOptions.linkHandler = null, this.rawOptions.documentOverride = null;
              }));
            }
            onSpecificOptionChange(e3, t4) {
              return this.onOptionChange((i4) => {
                i4 === e3 && t4(this.rawOptions[e3]);
              });
            }
            onMultipleOptionChange(e3, t4) {
              return this.onOptionChange((i4) => {
                -1 !== e3.indexOf(i4) && t4();
              });
            }
            _setupOptions() {
              const e3 = (e4) => {
                if (!(e4 in t3.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e4}"`);
                return this.rawOptions[e4];
              }, i4 = (e4, i5) => {
                if (!(e4 in t3.DEFAULT_OPTIONS)) throw new Error(`No option with key "${e4}"`);
                i5 = this._sanitizeAndValidateOption(e4, i5), this.rawOptions[e4] !== i5 && (this.rawOptions[e4] = i5, this._onOptionChange.fire(e4));
              };
              for (const t4 in this.rawOptions) {
                const s3 = {
                  get: e3.bind(this, t4),
                  set: i4.bind(this, t4)
                };
                Object.defineProperty(this.options, t4, s3);
              }
            }
            _sanitizeAndValidateOption(e3, i4) {
              switch (e3) {
                case "cursorStyle":
                  if (i4 || (i4 = t3.DEFAULT_OPTIONS[e3]), !/* @__PURE__ */ function(e4) {
                    return "block" === e4 || "underline" === e4 || "bar" === e4;
                  }(i4)) throw new Error(`"${i4}" is not a valid value for ${e3}`);
                  break;
                case "wordSeparator":
                  i4 || (i4 = t3.DEFAULT_OPTIONS[e3]);
                  break;
                case "fontWeight":
                case "fontWeightBold":
                  if ("number" == typeof i4 && 1 <= i4 && i4 <= 1e3) break;
                  i4 = o.includes(i4) ? i4 : t3.DEFAULT_OPTIONS[e3];
                  break;
                case "cursorWidth":
                  i4 = Math.floor(i4);
                case "lineHeight":
                case "tabStopWidth":
                  if (i4 < 1) throw new Error(`${e3} cannot be less than 1, value: ${i4}`);
                  break;
                case "minimumContrastRatio":
                  i4 = Math.max(1, Math.min(21, Math.round(10 * i4) / 10));
                  break;
                case "scrollback":
                  if ((i4 = Math.min(i4, 4294967295)) < 0) throw new Error(`${e3} cannot be less than 0, value: ${i4}`);
                  break;
                case "fastScrollSensitivity":
                case "scrollSensitivity":
                  if (i4 <= 0) throw new Error(`${e3} cannot be less than or equal to 0, value: ${i4}`);
                  break;
                case "rows":
                case "cols":
                  if (!i4 && 0 !== i4) throw new Error(`${e3} must be numeric, value: ${i4}`);
                  break;
                case "windowsPty":
                  i4 = i4 ?? {};
              }
              return i4;
            }
          }
          t3.OptionsService = a;
        },
        2660: function(e2, t3, i3) {
          var s2 = this && this.__decorate || function(e3, t4, i4, s3) {
            var r2, n2 = arguments.length, o2 = n2 < 3 ? t4 : null === s3 ? s3 = Object.getOwnPropertyDescriptor(t4, i4) : s3;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o2 = Reflect.decorate(e3, t4, i4, s3);
            else for (var a = e3.length - 1; a >= 0; a--) (r2 = e3[a]) && (o2 = (n2 < 3 ? r2(o2) : n2 > 3 ? r2(t4, i4, o2) : r2(t4, i4)) || o2);
            return n2 > 3 && o2 && Object.defineProperty(t4, i4, o2), o2;
          }, r = this && this.__param || function(e3, t4) {
            return function(i4, s3) {
              t4(i4, s3, e3);
            };
          };
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.OscLinkService = void 0;
          const n = i3(2585);
          let o = t3.OscLinkService = class {
            constructor(e3) {
              this._bufferService = e3, this._nextId = 1, this._entriesWithId = /* @__PURE__ */ new Map(), this._dataByLinkId = /* @__PURE__ */ new Map();
            }
            registerLink(e3) {
              const t4 = this._bufferService.buffer;
              if (void 0 === e3.id) {
                const i5 = t4.addMarker(t4.ybase + t4.y), s4 = {
                  data: e3,
                  id: this._nextId++,
                  lines: [
                    i5
                  ]
                };
                return i5.onDispose(() => this._removeMarkerFromLink(s4, i5)), this._dataByLinkId.set(s4.id, s4), s4.id;
              }
              const i4 = e3, s3 = this._getEntryIdKey(i4), r2 = this._entriesWithId.get(s3);
              if (r2) return this.addLineToLink(r2.id, t4.ybase + t4.y), r2.id;
              const n2 = t4.addMarker(t4.ybase + t4.y), o2 = {
                id: this._nextId++,
                key: this._getEntryIdKey(i4),
                data: i4,
                lines: [
                  n2
                ]
              };
              return n2.onDispose(() => this._removeMarkerFromLink(o2, n2)), this._entriesWithId.set(o2.key, o2), this._dataByLinkId.set(o2.id, o2), o2.id;
            }
            addLineToLink(e3, t4) {
              const i4 = this._dataByLinkId.get(e3);
              if (i4 && i4.lines.every((e4) => e4.line !== t4)) {
                const e4 = this._bufferService.buffer.addMarker(t4);
                i4.lines.push(e4), e4.onDispose(() => this._removeMarkerFromLink(i4, e4));
              }
            }
            getLinkData(e3) {
              var _a2;
              return (_a2 = this._dataByLinkId.get(e3)) == null ? void 0 : _a2.data;
            }
            _getEntryIdKey(e3) {
              return `${e3.id};;${e3.uri}`;
            }
            _removeMarkerFromLink(e3, t4) {
              const i4 = e3.lines.indexOf(t4);
              -1 !== i4 && (e3.lines.splice(i4, 1), 0 === e3.lines.length && (void 0 !== e3.data.id && this._entriesWithId.delete(e3.key), this._dataByLinkId.delete(e3.id)));
            }
          };
          t3.OscLinkService = o = s2([
            r(0, n.IBufferService)
          ], o);
        },
        8343: (e2, t3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.createDecorator = t3.getServiceDependencies = t3.serviceRegistry = void 0;
          const i3 = "di$target", s2 = "di$dependencies";
          t3.serviceRegistry = /* @__PURE__ */ new Map(), t3.getServiceDependencies = function(e3) {
            return e3[s2] || [];
          }, t3.createDecorator = function(e3) {
            if (t3.serviceRegistry.has(e3)) return t3.serviceRegistry.get(e3);
            const r = function(e4, t4, n) {
              if (3 !== arguments.length) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
              !function(e5, t5, r2) {
                t5[i3] === t5 ? t5[s2].push({
                  id: e5,
                  index: r2
                }) : (t5[s2] = [
                  {
                    id: e5,
                    index: r2
                  }
                ], t5[i3] = t5);
              }(r, e4, n);
            };
            return r.toString = () => e3, t3.serviceRegistry.set(e3, r), r;
          };
        },
        2585: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.IDecorationService = t3.IUnicodeService = t3.IOscLinkService = t3.IOptionsService = t3.ILogService = t3.LogLevelEnum = t3.IInstantiationService = t3.ICharsetService = t3.ICoreService = t3.ICoreMouseService = t3.IBufferService = void 0;
          const s2 = i3(8343);
          var r;
          t3.IBufferService = (0, s2.createDecorator)("BufferService"), t3.ICoreMouseService = (0, s2.createDecorator)("CoreMouseService"), t3.ICoreService = (0, s2.createDecorator)("CoreService"), t3.ICharsetService = (0, s2.createDecorator)("CharsetService"), t3.IInstantiationService = (0, s2.createDecorator)("InstantiationService"), function(e3) {
            e3[e3.TRACE = 0] = "TRACE", e3[e3.DEBUG = 1] = "DEBUG", e3[e3.INFO = 2] = "INFO", e3[e3.WARN = 3] = "WARN", e3[e3.ERROR = 4] = "ERROR", e3[e3.OFF = 5] = "OFF";
          }(r || (t3.LogLevelEnum = r = {})), t3.ILogService = (0, s2.createDecorator)("LogService"), t3.IOptionsService = (0, s2.createDecorator)("OptionsService"), t3.IOscLinkService = (0, s2.createDecorator)("OscLinkService"), t3.IUnicodeService = (0, s2.createDecorator)("UnicodeService"), t3.IDecorationService = (0, s2.createDecorator)("DecorationService");
        },
        1480: (e2, t3, i3) => {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.UnicodeService = void 0;
          const s2 = i3(8460), r = i3(225);
          class n {
            static extractShouldJoin(e3) {
              return 0 != (1 & e3);
            }
            static extractWidth(e3) {
              return e3 >> 1 & 3;
            }
            static extractCharKind(e3) {
              return e3 >> 3;
            }
            static createPropertyValue(e3, t4, i4 = false) {
              return (16777215 & e3) << 3 | (3 & t4) << 1 | (i4 ? 1 : 0);
            }
            constructor() {
              this._providers = /* @__PURE__ */ Object.create(null), this._active = "", this._onChange = new s2.EventEmitter(), this.onChange = this._onChange.event;
              const e3 = new r.UnicodeV6();
              this.register(e3), this._active = e3.version, this._activeProvider = e3;
            }
            dispose() {
              this._onChange.dispose();
            }
            get versions() {
              return Object.keys(this._providers);
            }
            get activeVersion() {
              return this._active;
            }
            set activeVersion(e3) {
              if (!this._providers[e3]) throw new Error(`unknown Unicode version "${e3}"`);
              this._active = e3, this._activeProvider = this._providers[e3], this._onChange.fire(e3);
            }
            register(e3) {
              this._providers[e3.version] = e3;
            }
            wcwidth(e3) {
              return this._activeProvider.wcwidth(e3);
            }
            getStringCellWidth(e3) {
              let t4 = 0, i4 = 0;
              const s3 = e3.length;
              for (let r2 = 0; r2 < s3; ++r2) {
                let o = e3.charCodeAt(r2);
                if (55296 <= o && o <= 56319) {
                  if (++r2 >= s3) return t4 + this.wcwidth(o);
                  const i5 = e3.charCodeAt(r2);
                  56320 <= i5 && i5 <= 57343 ? o = 1024 * (o - 55296) + i5 - 56320 + 65536 : t4 += this.wcwidth(i5);
                }
                const a = this.charProperties(o, i4);
                let h = n.extractWidth(a);
                n.extractShouldJoin(a) && (h -= n.extractWidth(i4)), t4 += h, i4 = a;
              }
              return t4;
            }
            charProperties(e3, t4) {
              return this._activeProvider.charProperties(e3, t4);
            }
          }
          t3.UnicodeService = n;
        }
      }, t2 = {};
      function i2(s2) {
        var r = t2[s2];
        if (void 0 !== r) return r.exports;
        var n = t2[s2] = {
          exports: {}
        };
        return e[s2].call(n.exports, n, n.exports, i2), n.exports;
      }
      var s = {};
      return (() => {
        var e2 = s;
        Object.defineProperty(e2, "__esModule", {
          value: true
        }), e2.Terminal = void 0;
        const t3 = i2(9042), r = i2(3236), n = i2(844), o = i2(5741), a = i2(8285), h = i2(7975), c = i2(7090), l = [
          "cols",
          "rows"
        ];
        class d extends n.Disposable {
          constructor(e3) {
            super(), this._core = this.register(new r.Terminal(e3)), this._addonManager = this.register(new o.AddonManager()), this._publicOptions = {
              ...this._core.options
            };
            const t4 = (e4) => this._core.options[e4], i3 = (e4, t5) => {
              this._checkReadonlyOptions(e4), this._core.options[e4] = t5;
            };
            for (const e4 in this._core.options) {
              const s2 = {
                get: t4.bind(this, e4),
                set: i3.bind(this, e4)
              };
              Object.defineProperty(this._publicOptions, e4, s2);
            }
          }
          _checkReadonlyOptions(e3) {
            if (l.includes(e3)) throw new Error(`Option "${e3}" can only be set in the constructor`);
          }
          _checkProposedApi() {
            if (!this._core.optionsService.rawOptions.allowProposedApi) throw new Error("You must set the allowProposedApi option to true to use proposed API");
          }
          get onBell() {
            return this._core.onBell;
          }
          get onBinary() {
            return this._core.onBinary;
          }
          get onCursorMove() {
            return this._core.onCursorMove;
          }
          get onData() {
            return this._core.onData;
          }
          get onKey() {
            return this._core.onKey;
          }
          get onLineFeed() {
            return this._core.onLineFeed;
          }
          get onRender() {
            return this._core.onRender;
          }
          get onResize() {
            return this._core.onResize;
          }
          get onScroll() {
            return this._core.onScroll;
          }
          get onSelectionChange() {
            return this._core.onSelectionChange;
          }
          get onTitleChange() {
            return this._core.onTitleChange;
          }
          get onWriteParsed() {
            return this._core.onWriteParsed;
          }
          get element() {
            return this._core.element;
          }
          get parser() {
            return this._parser || (this._parser = new h.ParserApi(this._core)), this._parser;
          }
          get unicode() {
            return this._checkProposedApi(), new c.UnicodeApi(this._core);
          }
          get textarea() {
            return this._core.textarea;
          }
          get rows() {
            return this._core.rows;
          }
          get cols() {
            return this._core.cols;
          }
          get buffer() {
            return this._buffer || (this._buffer = this.register(new a.BufferNamespaceApi(this._core))), this._buffer;
          }
          get markers() {
            return this._checkProposedApi(), this._core.markers;
          }
          get modes() {
            const e3 = this._core.coreService.decPrivateModes;
            let t4 = "none";
            switch (this._core.coreMouseService.activeProtocol) {
              case "X10":
                t4 = "x10";
                break;
              case "VT200":
                t4 = "vt200";
                break;
              case "DRAG":
                t4 = "drag";
                break;
              case "ANY":
                t4 = "any";
            }
            return {
              applicationCursorKeysMode: e3.applicationCursorKeys,
              applicationKeypadMode: e3.applicationKeypad,
              bracketedPasteMode: e3.bracketedPasteMode,
              insertMode: this._core.coreService.modes.insertMode,
              mouseTrackingMode: t4,
              originMode: e3.origin,
              reverseWraparoundMode: e3.reverseWraparound,
              sendFocusMode: e3.sendFocus,
              wraparoundMode: e3.wraparound
            };
          }
          get options() {
            return this._publicOptions;
          }
          set options(e3) {
            for (const t4 in e3) this._publicOptions[t4] = e3[t4];
          }
          blur() {
            this._core.blur();
          }
          focus() {
            this._core.focus();
          }
          input(e3, t4 = true) {
            this._core.input(e3, t4);
          }
          resize(e3, t4) {
            this._verifyIntegers(e3, t4), this._core.resize(e3, t4);
          }
          open(e3) {
            this._core.open(e3);
          }
          attachCustomKeyEventHandler(e3) {
            this._core.attachCustomKeyEventHandler(e3);
          }
          attachCustomWheelEventHandler(e3) {
            this._core.attachCustomWheelEventHandler(e3);
          }
          registerLinkProvider(e3) {
            return this._core.registerLinkProvider(e3);
          }
          registerCharacterJoiner(e3) {
            return this._checkProposedApi(), this._core.registerCharacterJoiner(e3);
          }
          deregisterCharacterJoiner(e3) {
            this._checkProposedApi(), this._core.deregisterCharacterJoiner(e3);
          }
          registerMarker(e3 = 0) {
            return this._verifyIntegers(e3), this._core.registerMarker(e3);
          }
          registerDecoration(e3) {
            return this._checkProposedApi(), this._verifyPositiveIntegers(e3.x ?? 0, e3.width ?? 0, e3.height ?? 0), this._core.registerDecoration(e3);
          }
          hasSelection() {
            return this._core.hasSelection();
          }
          select(e3, t4, i3) {
            this._verifyIntegers(e3, t4, i3), this._core.select(e3, t4, i3);
          }
          getSelection() {
            return this._core.getSelection();
          }
          getSelectionPosition() {
            return this._core.getSelectionPosition();
          }
          clearSelection() {
            this._core.clearSelection();
          }
          selectAll() {
            this._core.selectAll();
          }
          selectLines(e3, t4) {
            this._verifyIntegers(e3, t4), this._core.selectLines(e3, t4);
          }
          dispose() {
            super.dispose();
          }
          scrollLines(e3) {
            this._verifyIntegers(e3), this._core.scrollLines(e3);
          }
          scrollPages(e3) {
            this._verifyIntegers(e3), this._core.scrollPages(e3);
          }
          scrollToTop() {
            this._core.scrollToTop();
          }
          scrollToBottom() {
            this._core.scrollToBottom();
          }
          scrollToLine(e3) {
            this._verifyIntegers(e3), this._core.scrollToLine(e3);
          }
          clear() {
            this._core.clear();
          }
          write(e3, t4) {
            this._core.write(e3, t4);
          }
          writeln(e3, t4) {
            this._core.write(e3), this._core.write("\r\n", t4);
          }
          paste(e3) {
            this._core.paste(e3);
          }
          refresh(e3, t4) {
            this._verifyIntegers(e3, t4), this._core.refresh(e3, t4);
          }
          reset() {
            this._core.reset();
          }
          clearTextureAtlas() {
            this._core.clearTextureAtlas();
          }
          loadAddon(e3) {
            this._addonManager.loadAddon(this, e3);
          }
          static get strings() {
            return t3;
          }
          _verifyIntegers(...e3) {
            for (const t4 of e3) if (t4 === 1 / 0 || isNaN(t4) || t4 % 1 != 0) throw new Error("This API only accepts integers");
          }
          _verifyPositiveIntegers(...e3) {
            for (const t4 of e3) if (t4 && (t4 === 1 / 0 || isNaN(t4) || t4 % 1 != 0 || t4 < 0)) throw new Error("This API only accepts positive integers");
          }
        }
        e2.Terminal = d;
      })(), s;
    })());
  })(xterm$1);
  var xtermExports = xterm$1.exports;
  var xterm = xtermExports;
  var react = reactExports;
  document.head.innerHTML += `<style>/**
 * Copyright (c) 2014 The xterm.js authors. All rights reserved.
 * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)
 * https://github.com/chjj/term.js
 * @license MIT
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Originally forked from (with the author's permission):
 *   Fabrice Bellard's javascript vt100 for jslinux:
 *   http://bellard.org/jslinux/
 *   Copyright (c) 2011 Fabrice Bellard
 *   The original design remains. The terminal itself
 *   has been extended to include xterm CSI codes, among
 *   other features.
 */

/**
 *  Default styles for xterm.js
 */

.xterm {
    cursor: text;
    position: relative;
    user-select: none;
    -ms-user-select: none;
    -webkit-user-select: none;
}

.xterm.focus,
.xterm:focus {
    outline: none;
}

.xterm .xterm-helpers {
    position: absolute;
    top: 0;
    /**
     * The z-index of the helpers must be higher than the canvases in order for
     * IMEs to appear on top.
     */
    z-index: 5;
}

.xterm .xterm-helper-textarea {
    padding: 0;
    border: 0;
    margin: 0;
    /* Move textarea out of the screen to the far left, so that the cursor is not visible */
    position: absolute;
    opacity: 0;
    left: -9999em;
    top: 0;
    width: 0;
    height: 0;
    z-index: -5;
    /** Prevent wrapping so the IME appears against the textarea at the correct position */
    white-space: nowrap;
    overflow: hidden;
    resize: none;
}

.xterm .composition-view {
    /* TODO: Composition position got messed up somewhere */
    background: #000;
    color: #FFF;
    display: none;
    position: absolute;
    white-space: nowrap;
    z-index: 1;
}

.xterm .composition-view.active {
    display: block;
}

.xterm .xterm-viewport {
    /* On OS X this is required in order for the scroll bar to appear fully opaque */
    background-color: #000;
    overflow-y: scroll;
    cursor: default;
    position: absolute;
    right: 0;
    left: 0;
    top: 0;
    bottom: 0;
}

.xterm .xterm-screen {
    position: relative;
}

.xterm .xterm-screen canvas {
    position: absolute;
    left: 0;
    top: 0;
}

.xterm .xterm-scroll-area {
    visibility: hidden;
}

.xterm-char-measure-element {
    display: inline-block;
    visibility: hidden;
    position: absolute;
    top: 0;
    left: -9999em;
    line-height: normal;
}

.xterm.enable-mouse-events {
    /* When mouse events are enabled (eg. tmux), revert to the standard pointer cursor */
    cursor: default;
}

.xterm.xterm-cursor-pointer,
.xterm .xterm-cursor-pointer {
    cursor: pointer;
}

.xterm.column-select.focus {
    /* Column selection mode */
    cursor: crosshair;
}

.xterm .xterm-accessibility:not(.debug),
.xterm .xterm-message {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0;
    z-index: 10;
    color: transparent;
    pointer-events: none;
}

.xterm .xterm-accessibility-tree:not(.debug) *::selection {
  color: transparent;
}

.xterm .xterm-accessibility-tree {
  user-select: text;
  white-space: pre;
}

.xterm .live-region {
    position: absolute;
    left: -9999px;
    width: 1px;
    height: 1px;
    overflow: hidden;
}

.xterm-dim {
    /* Dim should not apply to background, so the opacity of the foreground color is applied
     * explicitly in the generated class and reset to 1 here */
    opacity: 1 !important;
}

.xterm-underline-1 { text-decoration: underline; }
.xterm-underline-2 { text-decoration: double underline; }
.xterm-underline-3 { text-decoration: wavy underline; }
.xterm-underline-4 { text-decoration: dotted underline; }
.xterm-underline-5 { text-decoration: dashed underline; }

.xterm-overline {
    text-decoration: overline;
}

.xterm-overline.xterm-underline-1 { text-decoration: overline underline; }
.xterm-overline.xterm-underline-2 { text-decoration: overline double underline; }
.xterm-overline.xterm-underline-3 { text-decoration: overline wavy underline; }
.xterm-overline.xterm-underline-4 { text-decoration: overline dotted underline; }
.xterm-overline.xterm-underline-5 { text-decoration: overline dashed underline; }

.xterm-strikethrough {
    text-decoration: line-through;
}

.xterm-screen .xterm-decoration-container .xterm-decoration {
	z-index: 6;
	position: absolute;
}

.xterm-screen .xterm-decoration-container .xterm-decoration.xterm-decoration-top-layer {
	z-index: 7;
}

.xterm-decoration-overview-ruler {
    z-index: 8;
    position: absolute;
    top: 0;
    right: 0;
    pointer-events: none;
}

.xterm-decoration-top {
    z-index: 2;
    position: relative;
}
</style>`;
  function useXTerm({ options, addons, listeners } = {}) {
    const terminalRef = react.useRef(null);
    const [terminalInstance, setTerminalInstance] = react.useState(null);
    react.useEffect(() => {
      const instance = new xterm.Terminal({
        fontFamily: "operator mono,SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace",
        fontSize: 14,
        theme: {
          background: "#101420"
        },
        cursorStyle: "underline",
        cursorBlink: false,
        ...options
      });
      if (addons) {
        addons.forEach((addon) => {
          instance.loadAddon(addon);
        });
      }
      if (listeners) {
        if (listeners.onBinary) instance.onBinary(listeners.onBinary);
        if (listeners.onCursorMove) instance.onCursorMove(listeners.onCursorMove);
        if (listeners.onLineFeed) instance.onLineFeed(listeners.onLineFeed);
        if (listeners.onScroll) instance.onScroll(listeners.onScroll);
        if (listeners.onSelectionChange) instance.onSelectionChange(listeners.onSelectionChange);
        if (listeners.onRender) instance.onRender(listeners.onRender);
        if (listeners.onResize) instance.onResize(listeners.onResize);
        if (listeners.onTitleChange) instance.onTitleChange(listeners.onTitleChange);
        if (listeners.onKey) instance.onKey(listeners.onKey);
        if (listeners.onData) instance.onData(listeners.onData);
        if (listeners.customKeyEventHandler) {
          instance.attachCustomKeyEventHandler(listeners.customKeyEventHandler);
        }
      }
      if (terminalRef.current) {
        instance.open(terminalRef.current);
        instance.focus();
      }
      setTerminalInstance(instance);
      return () => {
        instance.dispose();
        setTerminalInstance(null);
      };
    }, [
      terminalRef,
      options,
      addons,
      listeners,
      listeners == null ? void 0 : listeners.onBinary,
      listeners == null ? void 0 : listeners.onCursorMove,
      listeners == null ? void 0 : listeners.onData,
      listeners == null ? void 0 : listeners.onKey,
      listeners == null ? void 0 : listeners.onLineFeed,
      listeners == null ? void 0 : listeners.onScroll,
      listeners == null ? void 0 : listeners.onSelectionChange,
      listeners == null ? void 0 : listeners.onRender,
      listeners == null ? void 0 : listeners.onResize,
      listeners == null ? void 0 : listeners.onTitleChange,
      listeners == null ? void 0 : listeners.customKeyEventHandler
    ]);
    return {
      ref: terminalRef,
      instance: terminalInstance
    };
  }
  var useXTerm_1 = useXTerm;
  var addonFit = {
    exports: {}
  };
  (function(module, exports) {
    !function(e, t2) {
      module.exports = t2();
    }(self, () => (() => {
      var e = {};
      return (() => {
        var t2 = e;
        Object.defineProperty(t2, "__esModule", {
          value: true
        }), t2.FitAddon = void 0, t2.FitAddon = class {
          activate(e2) {
            this._terminal = e2;
          }
          dispose() {
          }
          fit() {
            const e2 = this.proposeDimensions();
            if (!e2 || !this._terminal || isNaN(e2.cols) || isNaN(e2.rows)) return;
            const t3 = this._terminal._core;
            this._terminal.rows === e2.rows && this._terminal.cols === e2.cols || (t3._renderService.clear(), this._terminal.resize(e2.cols, e2.rows));
          }
          proposeDimensions() {
            if (!this._terminal) return;
            if (!this._terminal.element || !this._terminal.element.parentElement) return;
            const e2 = this._terminal._core, t3 = e2._renderService.dimensions;
            if (0 === t3.css.cell.width || 0 === t3.css.cell.height) return;
            const r = 0 === this._terminal.options.scrollback ? 0 : e2.viewport.scrollBarWidth, i2 = window.getComputedStyle(this._terminal.element.parentElement), o = parseInt(i2.getPropertyValue("height")), s = Math.max(0, parseInt(i2.getPropertyValue("width"))), n = window.getComputedStyle(this._terminal.element), l = o - (parseInt(n.getPropertyValue("padding-top")) + parseInt(n.getPropertyValue("padding-bottom"))), a = s - (parseInt(n.getPropertyValue("padding-right")) + parseInt(n.getPropertyValue("padding-left"))) - r;
            return {
              cols: Math.max(2, Math.floor(a / t3.css.cell.width)),
              rows: Math.max(1, Math.floor(l / t3.css.cell.height))
            };
          }
        };
      })(), e;
    })());
  })(addonFit);
  var addonFitExports = addonFit.exports;
  const DEFAULT_PROMPT_ICON = "\u276F";
  const DEFAULT_PROMPT = `${DEFAULT_PROMPT_ICON} `;
  const DEFAULT_PROMPT_COL = 2;
  const ContainerTernimal = reactExports.memo(({ fileSystemTree }) => {
    const [terminal, setTernimal] = reactExports.useState({
      containerReady: false,
      shellReady: false,
      loading: false,
      prompt: ""
    });
    const isProcessing = reactExports.useRef(false);
    const runningWebContainerProcess = reactExports.useRef();
    const webContainerShellRef = reactExports.useRef();
    const webContainerRef = reactExports.useRef();
    const webContainerInit = useWebContainerState((state) => state.init);
    const webContainerTeardown = useWebContainerState((state) => state.teardown);
    const editorRef = reactExports.useRef(null);
    const { instance, ref } = useXTerm_1();
    usePreventPitchZoom(editorRef);
    const getTerminalInformation = reactExports.useCallback(() => {
      if (!instance) {
        return {
          raw: "",
          currentPage: 0,
          totalLines: 0,
          currentPageLines: 0
        };
      }
      const totalActiveline = instance.buffer.active.length;
      const viewportRows = instance.rows;
      const raw = Array.from({
        length: instance.buffer.active.length
      }, (_, i2) => {
        var _a2;
        return ((_a2 = instance.buffer.active.getLine(i2)) == null ? void 0 : _a2.translateToString()) || "";
      }).join("\n").trim();
      const totalLines = raw.split("\n").length;
      const currentPage = Math.floor(totalActiveline / viewportRows);
      return {
        raw,
        totalLines,
        currentPage
      };
    }, [
      instance
    ]);
    reactExports.useEffect(() => {
      return () => {
        var _a2;
        (_a2 = webContainerShellRef.current) == null ? void 0 : _a2.kill();
        webContainerShellRef.current = void 0;
        webContainerTeardown();
        webContainerRef.current = null;
      };
    }, [
      webContainerTeardown
    ]);
    reactExports.useEffect(() => {
      if (!webContainerShellRef.current || !instance) {
        return;
      }
      webContainerShellRef.current.resize({
        rows: instance.rows,
        cols: instance.cols
      });
      webContainerShellRef.current.output.pipeTo(new WritableStream({
        write(data) {
          instance.write(data);
        }
      }));
    }, [
      instance,
      webContainerShellRef.current
    ]);
    const writeLines = reactExports.useCallback((...args) => {
      if (!instance) {
        return;
      }
      args.forEach((line) => {
        instance.writeln(line);
      });
    }, [
      instance
    ]);
    const updateLine = reactExports.useCallback((line) => {
      if (!instance) {
        return;
      }
      instance.write("\r\x1B[K");
      instance.write(line);
    }, [
      instance
    ]);
    const handleKillCurrentProcess = reactExports.useCallback(() => {
      if (runningWebContainerProcess.current) {
        runningWebContainerProcess.current.kill();
      }
    }, []);
    const handleActions = reactExports.useCallback(async () => {
      var _a2;
      const currentLine = instance == null ? void 0 : instance.buffer.active.getLine(instance == null ? void 0 : instance.buffer.active.cursorY);
      let command2 = currentLine == null ? void 0 : currentLine.translateToString();
      command2 = (command2 == null ? void 0 : command2.startsWith(DEFAULT_PROMPT_ICON)) ? command2.substring(1).trim() : command2 == null ? void 0 : command2.trim();
      if (!command2) {
        return;
      }
      setTernimal((pre) => ({
        ...pre,
        loading: true,
        prompt: command2
      }));
      try {
        isProcessing.current = true;
        updateLine(`${DEFAULT_PROMPT}${command2}`);
        if (command2.startsWith("init")) {
          writeLines("");
          updateLine("\u{1F680}  Initializing container...");
          try {
            if (!fileSystemTree) {
              updateLine("\u{1F6D1}  No file system tree");
              return;
            }
            setTernimal((pre) => ({
              ...pre,
              shellReady: true,
              containerReady: true
            }));
            if (webContainerShellRef.current) {
              webContainerShellRef.current.kill();
              webContainerShellRef.current = void 0;
            }
            if (webContainerRef.current) {
              webContainerRef.current.teardown();
              webContainerRef.current = void 0;
            }
            const containerInstance = await webContainerInit(() => {
              webContainerRef.current = null;
              webContainerShellRef.current = void 0;
              setTernimal((pre) => ({
                ...pre,
                shellReady: false,
                containerReady: false
              }));
            });
            setTernimal((pre) => ({
              ...pre,
              containerReady: true
            }));
            if (!containerInstance) {
              updateLine("\u{1F6D1}  Failed to init container");
              return;
            }
            webContainerRef.current = containerInstance;
            await containerInstance.mount(fileSystemTree);
            webContainerShellRef.current = await webContainerRef.current.spawn("jsh");
            setTernimal((pre) => ({
              ...pre,
              shellReady: true
            }));
            updateLine("\u{1F680}  Container initialized");
            writeLines("");
          } catch {
            updateLine("\u{1F6D1}  Failed to init container");
          }
        } else if (command2.trim().startsWith("npm")) {
          try {
            writeLines("");
            if (!webContainerRef.current) {
              updateLine("\u{1F6D1}  Container is not initialized yet.");
              writeLines("  ");
              return;
            }
            const [lib, ...args] = command2.split(" ");
            const process = await webContainerRef.current.spawn(lib, args);
            runningWebContainerProcess.current = process;
            process.output.pipeTo(new WritableStream({
              write(data) {
                instance == null ? void 0 : instance.write(data);
              }
            }));
            await process.exit;
          } finally {
            runningWebContainerProcess.current = void 0;
          }
        } else {
          writeLines("");
          if (!webContainerRef.current) {
            updateLine("\u{1F6D1}  Container is not initialized yet.");
            writeLines("");
            return;
          }
          let writer;
          try {
            writer = await ((_a2 = webContainerShellRef.current) == null ? void 0 : _a2.input.getWriter());
            if (writer && webContainerShellRef.current && await writer.ready) {
              await writer.write(`${command2}
`);
              await writer.releaseLock();
            }
          } catch (error) {
            logError(error);
            updateLine("\u{1F6D1}  Failed to run command");
          } finally {
            await (writer == null ? void 0 : writer.close());
          }
        }
      } finally {
        updateLine(`${DEFAULT_PROMPT}`);
        isProcessing.current = false;
        setTernimal((pre) => ({
          ...pre,
          loading: false,
          prompt: command2
        }));
      }
    }, [
      fileSystemTree,
      instance,
      updateLine,
      webContainerInit,
      writeLines
    ]);
    reactExports.useEffect(() => {
      if (!instance) {
        return;
      }
      isProcessing.current = false;
      const fitAddon = new addonFitExports.FitAddon();
      instance == null ? void 0 : instance.loadAddon(fitAddon);
      const handleResize = () => {
        fitAddon.fit();
        if (webContainerShellRef.current) {
          webContainerShellRef.current.resize({
            rows: instance.rows,
            cols: instance.cols
          });
        }
      };
      instance == null ? void 0 : instance.writeln('Please type "init" to start!');
      updateLine(`${DEFAULT_PROMPT}`);
      const removeListener = instance == null ? void 0 : instance.onData((data) => {
        var _a2;
        try {
          if (isProcessing.current) {
            return;
          }
          const isCursorMoving = [
            "\x1B[D",
            "\x1B[C",
            "\x1B[A",
            "\x1B[B"
          ].includes(data);
          const currentLine = instance == null ? void 0 : instance.buffer.active.cursorY;
          const currentCol = instance == null ? void 0 : instance.buffer.active.cursorX;
          const isSuffixValue = !!Array.from({
            length: instance.rows + (instance == null ? void 0 : instance.buffer.active.viewportY) - ((instance == null ? void 0 : instance.buffer.active.viewportY) + currentLine + 1)
          }, (_, i2) => {
            const line = instance == null ? void 0 : instance.buffer.active.getLine((instance == null ? void 0 : instance.buffer.active.viewportY) + currentLine + i2 + 1);
            return line == null ? void 0 : line.translateToString(true, 0, instance.cols);
          }).filter(Boolean).length;
          const boxContent = (_a2 = instance.buffer.active.getLine(currentLine)) == null ? void 0 : _a2.translateToString(true, 0, 4);
          if (currentCol < DEFAULT_PROMPT_COL && !isCursorMoving && (boxContent == null ? void 0 : boxContent.startsWith(DEFAULT_PROMPT))) {
            return;
          }
          if ((isSuffixValue || !(boxContent == null ? void 0 : boxContent.startsWith(DEFAULT_PROMPT))) && !isCursorMoving) {
            return;
          }
          instance == null ? void 0 : instance.write(data);
        } catch (error) {
          logError(error);
        }
      });
      const removeKeyListenter = instance == null ? void 0 : instance.onKey((e) => {
        var _a2;
        if (e.domEvent.code === "Backspace") {
          const currentLine = instance == null ? void 0 : instance.buffer.active.cursorY;
          const currentCol = instance == null ? void 0 : instance.buffer.active.cursorX;
          if (currentCol <= DEFAULT_PROMPT_COL) {
            const boxContent = (_a2 = instance.buffer.active.getLine(currentLine)) == null ? void 0 : _a2.translateToString(true, 0, 4);
            if (boxContent == null ? void 0 : boxContent.startsWith(DEFAULT_PROMPT)) {
              return e.domEvent.preventDefault();
            }
          }
          instance.write("\b \b");
        } else if (e.domEvent.code === "Enter") {
          handleActions();
        }
        if (e.domEvent.ctrlKey && e.domEvent.key === "c") {
          handleKillCurrentProcess();
        }
      });
      window.addEventListener("resize", handleResize);
      return () => {
        removeListener == null ? void 0 : removeListener.dispose();
        removeKeyListenter == null ? void 0 : removeKeyListenter.dispose();
        window.removeEventListener("resize", handleResize);
      };
    }, [
      getTerminalInformation,
      handleActions,
      handleKillCurrentProcess,
      instance,
      updateLine
    ]);
    return jsxRuntimeExports.jsx("div", {
      ref: editorRef,
      className: "w-full flex-1 overflow-y-auto nowheel nodrag",
      children: jsxRuntimeExports.jsxs("div", {
        className: "flex h-full w-full flex-col",
        children: [
          jsxRuntimeExports.jsx("div", {
            ref,
            className: "w-full flex-1 overflow-y-auto"
          }),
          terminal.loading && terminal.prompt ? jsxRuntimeExports.jsxs("div", {
            className: "bg-neutral-200 flex gap-2 max-h-16 w-full p-2",
            children: [
              jsxRuntimeExports.jsx(LazyIcon, {
                name: "loader",
                className: "animate-spin"
              }),
              jsxRuntimeExports.jsx("div", {
                className: "overflow-auto flex-1 max-h-full break-words flex-wrap",
                dangerouslySetInnerHTML: {
                  __html: terminal.prompt
                }
              }),
              runningWebContainerProcess.current ? jsxRuntimeExports.jsx(LazyIcon, {
                className: "cursor-pointer",
                name: "circle-pause",
                onClick: handleKillCurrentProcess
              }) : void 0
            ]
          }) : void 0
        ]
      })
    });
  });
  const CodeContainerApp = reactExports.memo((props) => {
    var _a2, _b, _c;
    const { id, data } = props;
    const iframeRef = reactExports.useRef(null);
    const [fileSystemTree, setFileSystemTree] = reactExports.useState(((_a2 = data == null ? void 0 : data.flowNode) == null ? void 0 : _a2.raw) ? parseJSONLToFileSystemTree(data.flowNode.raw) : void 0);
    useConnectionToHandler(id);
    const { updateCodeContainerData } = useActions(id);
    const handleUpdateCodeContainerData = reactExports.useCallback(async (tree) => {
      var _a3, _b2;
      if (!((_a3 = data == null ? void 0 : data.flowNode) == null ? void 0 : _a3.id)) return;
      await updateCodeContainerData((_b2 = data == null ? void 0 : data.flowNode) == null ? void 0 : _b2.id, tree);
      setFileSystemTree(tree);
    }, [
      (_b = data == null ? void 0 : data.flowNode) == null ? void 0 : _b.id,
      updateCodeContainerData
    ]);
    const handleUpdateCodeContainerFile = reactExports.useCallback(async (filePath, code2) => {
      setFileSystemTree((prev) => {
        var _a3;
        if (!prev) return prev;
        const result = updateFileContentOfFileSystemTree(prev, filePath, code2);
        updateCodeContainerData((_a3 = data == null ? void 0 : data.flowNode) == null ? void 0 : _a3.id, result);
        return result;
      });
    }, [
      (_c = data == null ? void 0 : data.flowNode) == null ? void 0 : _c.id,
      updateCodeContainerData
    ]);
    if (!fileSystemTree) {
      return jsxRuntimeExports.jsx("div", {
        className: "h-full flex justify-center items-center",
        children: jsxRuntimeExports.jsx(CreateSourcebaseCard, {
          className: "w-64",
          onUpdateSourceBase: handleUpdateCodeContainerData
        })
      });
    }
    return jsxRuntimeExports.jsxs("div", {
      className: "flex h-full",
      children: [
        jsxRuntimeExports.jsx(CodeEditor, {
          fileSystemTree,
          updateCodeContainerFile: handleUpdateCodeContainerFile
        }),
        jsxRuntimeExports.jsxs("div", {
          className: "w-[400px] h-full flex flex-col border",
          children: [
            jsxRuntimeExports.jsx(ContainerBrowser, {
              iframeRef
            }),
            jsxRuntimeExports.jsx(ContainerTernimal, {
              fileSystemTree
            })
          ]
        })
      ]
    });
  });
  CodeContainerApp$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: CodeContainerApp
  }, Symbol.toStringTag, {
    value: "Module"
  }));
});
export {
  CodeContainerApp$1 as C,
  DefaultBufferLength as D,
  EditorView as E,
  IterMode as I,
  LanguageSupport as L,
  NodeWeakMap as N,
  Parser as P,
  Tree$1 as T,
  __tla,
  syntaxTree as a,
  EditorSelection as b,
  completeFromList as c,
  snippetCompletion as d,
  LRLanguage as e,
  indentNodeProp as f,
  continuedIndent as g,
  flatIndent as h,
  ifNotIn as i,
  delimitedIndent as j,
  foldNodeProp as k,
  foldInside as l,
  sublanguageProp as m,
  defineLanguageFacet as n,
  NodeSet as o,
  NodeType as p,
  NodeProp as q,
  parseMixed as r,
  styleTags as s,
  tags as t,
  bracketMatchingHandle as u
};
