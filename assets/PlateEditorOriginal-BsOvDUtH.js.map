{"version":3,"mappings":"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,GAAS,aAAc,CAC3C,MAAO,EACT,CAAC,EACDA,GAAA,QAAkBC,EACHD,GAAA,QAAG,OAClB,IAAInU,EAAgBC,OAAqD,CACzE,eAAuC,oCAEvC,IAAIoU,EAAS,CACX,YAAS,kDACT,IAAS,uCACT,CAAS,wBACT,iBAAS,uBACT,GAAS,mCACT,OAAS,iCACT,IAAS,sCACA,4BACT,OAAS,8BACT,YAAS,6DACA,uCACA,kDACA,mBACA,uBACT,YAAS,2CACA,kCACA,+BACT,OAAS,sCACT,YAAS,gDACT,cAAS,qCACA,2BACT,QAAS,2DACA,mBACA,iDACT,GAAS,+EACA,uCACT,QAAS,qCACA,6BACT,4BAAS,YACA,mCACT,MAAS,4CACT,gBAAS,qCACA,8EACT,WAAS,mBACT,OAAS,2EACA,0DACT,0CAAS,mBACT,SAAS,iBACT,iBAAS,eACT,OAAS,wDACT,SAAS,wBACT,GAAS,gDACT,IAAS,uCACT,eAAS,2BACT,GAAS,gCACT,iBAAS,IACT,mBAAS,mBACT,GAAS,wCACT,YAAS,yBACT,QAAS,8CACT,eAAS,2DACT,CAAS,+CACT,CAAS,kDACT,IAAS,qBACT,uCAAS,0CACT,QAAS,yBACT,cAAS,0BACT,EAAS,yBACT,QAAS,gCACT,QAAS,yDACA,CACT,kBAAS,uBACA,sBACT,kBAAS,qBACA,sBACT,oBAAS,oBACA,+FACT,IAAS,yCACA,mBACA,mBACT,QAAS,gCACT,iBAAS,uBACT,GAAS,yBACT,UAAS,0DACA,oCACA,wBACT,SAAS,oBACT,aAAS,mBACT,qBAAS,mBACT,IAAS,8DACA,GACT,wBAAS,GACT,sBAAS,iBACT,iBAAS,WACT,kBAAS,WACT,kBAAS,eACT,OAAS,qCACA,wBACT,KAAS,uBACT,cAAS,2CACT,IAAS,iFACA,4BACT,UAAS,0BACT,OAAS,sCACT,QAAS,uBACT,QAAS,kBACT,WAAS,sBACT,QAAS,uBACT,OAAS,uBACT,QAAS,8BACT,SAAS,6BACT,QAAS,8BACT,QAAS,yBACT,QAAS,8BACT,QAAS,oBACT,MAAS,mDACT,MAAS,oCACT,QAAS,qGACT,QAAS,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","names":["IS_APPLE","findHtmlParentElement","nodeName","el","hexToBase64","hex","hexPair","protocolAndDomainRE","emailLintRE","localhostDomainRE","nonLocalhostDomainRE","isUrl","string","generalMatch","emailLinkMatch","match","everythingAfterProtocol","handlerKeys","key","acc","value","_a","map","args","_a2","fn","mapProps","props","overrideProps","sanitizeUrl","permitInvalid","url","parsedUrl","allowedSchemes","isUndefined","obj","isNull","isUndefinedOrNull","isDefined","arg","bindFirst","firstArg","__defProp","__defProps","__getOwnPropDescs","__getOwnPropSymbols","__hasOwnProp","__propIsEnum","__defNormalProp","__spreadValues","b","prop","a","__spreadProps","__objRest","source","exclude","target","_b","Comp","as","element","ref","Box","createSlotComponent","MemoizedChildren","React2","children","Text","setRef","composeRefs","refs","node","useComposedRef","React4","createPrimitiveComponent","stateHook","React5","asChild","classNameProp","getClassName","options","_a3","_b2","stateProp","hidden","propsHook","state","_ref","hookRef","hookProps","clsx","style","className","createPrimitiveElement","tag","React6","CAN_USE_DOM","useIsomorphicLayoutEffect","useMemoOnce","factory","deps","initialized","React9","dep","i","prevDepsRef","canUsePassiveEvents","passive","noop","DEFAULT_IGNORE_CLASS","checkClass","cl","ignoreClass","c","clickedOnScrollbar","getEventOptions","type","useOnClickOutside","detectIFrame","disabled","refsState","React10","callbackRef","callback","setRefsState","prevState","getEls","refsOpt","current","els","handler","e","excludeScrollbar","activeElement","removeEventListener","eventTypes","useStableMemo","producer","setValue","React11","React13","renderFunction","DndContext","createContext","formatProdErrorMessage","code","$$observable","randomString","isPlainObject","proto","reducer","preloadedState","enhancer","createStore","currentReducer","currentListeners","nextListeners","currentState","subscribe","listener","isSubscribed","ensureCanMutateNextListeners","index","isDispatching","action","listeners","replaceReducer","nextReducer","dispatch","ActionTypes","observable","outerSubscribe","observer","observeState","getState","_ref2","invariant","condition","format","isProduction","error","argIndex","process","path","without","items","item","input","xor","itemsA","itemsB","insertItem","result","count","intersection","t","PUBLISH_DRAG_SOURCE","HOVER","DROP","END_DRAG","setClientOffset","clientOffset","INIT_COORDS","sourceClientOffset","createBeginDrag","publishSource","getSourceClientOffset","monitor","manager","sourceIds","sourceId","getDraggableSource","verifyGetSourceClientOffsetIsFunction","verifyItemIsObject","itemType","registry","BEGIN_DRAG","verifyInvariants","_defineProperty","createDrop","getDroppableTargets","targetId","dropResult","determineDropResult","_objectSpread","verifyDropResultType","targetIds","createEndDrag","verifyIsDragging","targetType","draggedItemType","createHover","targetIdsArg","removeNonMatchingTargetIds","checkInvariants","hoverAllTargets","createPublishDragSource","createDragDropActions","DragDropManagerImpl","backend","bindActionCreator","actionCreator","actions","boundActions","shouldSetUp","store","subtract","initialClientOffset","initialSourceClientOffset","add","getDifferenceFromInitialOffset","ALL","NONE","areDirty","dirtyIds","handlerIds","prevStateId","currentStateId","handleChange","nextState","previousState","sourceType","shallow","matchesType","scope","global","makeRequestCallFromTimer","handleTimer","toggle","BrowserMutationObserver","q","requestFlush","scan","newLength","err","makeRequestCall","onError","task","tasks","t1","RawTask","asapQueue","taskFactory","TaskFactory","asap","REMOVE_SOURCE","REMOVE_TARGET","addSource","addTarget","removeTarget","validateTargetContract","validateType","allowArray","HandlerRole","nextUniqueId","getNextUniqueId","handlerId","mapContainsValue","entries","done","searchValue","isDone","HandlerRegistryImpl","validateSourceContract","includePinned","removeSource","id","getNextHandlerId","role","strictEquality","areCoordsEqual","offsetA","offsetB","isEqual","ADD_SOURCE","prevTargetIds","innermostTargetId","prevInnermostTargetId","ownKeys","sym","reduce","payload","initialState","ADD_TARGET","dragOffset","refCount","stateId","createDragDropManager","backendFactory","globalContext","makeStoreInstance","debugMode","reduxDevTools","_objectWithoutProperties","_objectWithoutPropertiesLoose","excluded","sourceKeys","INSTANCE_SYM","_param","getDndContextValue","useEffect","isGlobalInstance","context","createSingletonDndContext","getGlobalContext","ctx","useLayoutEffect","useCollector","collect","onUpdate","useState","updateCollected","useCallback","nextValue","equal","collected","setCollected","useMonitorOutput","onCollect","useCollectedProps","connector","useOptionalFactory","memoDeps","useMemo","useConnectDragSource","useConnectDragPreview","isCallingCanDrag","DragSourceMonitorImpl","isCallingIsDragging","isCallingCanDrop","registerTarget","compareResult","objA","objB","keysA","valueA","valueB","throwIfCompositeComponentElement","displayName","wrapHookToRecognizeElement","elementOrNode","isValidElement","hook","cloneWithRef","wrapConnectorHooks","hooks","wrappedHooks","wrappedHook","newRef","previousRef","cloneElement","newHandlerId","didChange","dragSource","dragPreview","forceDidChange","shallowEqual","isRef","TargetConnector","dropTarget","dragDropManager","useDragDropManager","dragSourceOptions","DragSourceImpl","spec","globalMonitor","useDragType","useRegisteredDragSource","useDragSource","unregister","useDrag","specArg","useDragSourceMonitor","useDragSourceConnector","useConnectDropTarget","DropTargetMonitorImpl","useAccept","accept","useDropTarget","DropTargetImpl","useDrop","useDropTargetMonitor","useDropTargetConnector","memoize","union","set","EnterLeaveCounter","enteringNode","isNodeEntered","previousLength","leavingNode","isNodeInDocument","NativeDragSource","property","dataTransfer","propertyFn","newProperties","config","URL","HTML","typesToTry","resultSoFar","typeToTry","defaultValue","nativeTypesConfig","NativeTypes.FILE","NativeTypes.HTML","matchesTypes","NativeTypes.URL","NativeTypes.TEXT","getDataFromDataTransfer","createNativeDragSource","matchNativeItemType","dataTransferTypes","nativeItemType","typeConfig","isFirefox","MonotonicInterpolant","ys","c1s","c2s","xs","x","low","high","c3s","mid","xHere","diff","diffSq","length","indexes","dxs","dx","dy","i1","ms","i2","m2","mNext","dxNext","common","m","i3","c1","invDx","ELEMENT_NODE","left","sourceWidth","sourceHeight","dragPreviewWidth","isImage","dragPreviewHeight","isSafari","anchorPoint","offsetPoint","isImageNode","dragPreviewNodeOffsetFromClient","getNodeClientOffset","sourceNode","offsetFromDragPreview","anchorX","anchorY","calculateYOffset","y","calculateXOffset","offsetX","offsetY","isManualOffsetY","OptionsReader","HTML5BackendImpl","ref1","root","handleDragStart","handleDragEnter","handleDrop","sourceNodeOptions","NativeTypes","MOUSE_MOVE_TIMEOUT","dragOverTargetIds","getEventClientOffset","dragPreviewOffset","nativeType","dragEnterTargetIds","dropTargetIds","emptyImage","HTML5Backend","isObject","o","ctor","prot","NOTHING","die","DRAFT_STATE","isDraftable","DRAFTABLE","isMap","objectCtorString","getPrototypeOf","Ctor","each","iter","getArchtype","entry","thing","has","propOrOldValue","is","isSet","shallowCopy","base","strict","isPlain","descriptors","keys","desc","isDraft","dontMutateFrozenCollections","deep","freeze","isFrozen","plugins","getPlugin","pluginKey","plugin","loadPlugin","implementation","currentScope","parent_","immer_","patchListener","revokeScope","revokeDraft","leaveScope","immer2","processResult","baseDraft","maybeFreeze","finalize","rootScope","finalizeProperty","resultEach","isSet2","childValue","rootPath","targetIsSet","parentState","res","targetObject","parent","isArray","traps","objectTraps","arrayTraps","revoke","proxy","latest","readPropFromProto","prepareCopy","current2","peek","markChanged","owner","draft","getDescriptorFromProto","recipe","defaultBase","self","base2","enterScope","createProxy","ip","p","patches","inversePatches","patch","applyPatchesImpl","getCurrentScope","currentImpl","copy","DraftMap","assertUnrevoked","prepareMapCopy","thisArg","_value","_map","iterator","r","proxyMap_","DraftSet","cb","immer","Immer2","produce","setAutoFreeze","createDraft","PathRef","op","affinity","PointRef","point","Point","RangeRef","Range","DIRTY_PATHS","DIRTY_PATH_KEYS","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","Path","reverse","paths","another","av","bv","min","bs","al","list","last","operation","ancestor","_op","_op2","position","_position","_op3","_op4","onp","_typeof","_toPrimitive","prim","hint","_toPropertyKey","ownKeys$e","_objectSpread$e","editor","selection","Node","_path","text","_node","before","after","_point","_key","_path2","_node2","prevPath","prev","_parent","_index","Scrubber","_point2","_key2","_path3","newPath","_node3","_parent2","_index2","truePath","newParent","newIndex","_point3","_key3","_index3","_path4","_parent3","_point4","_key4","n","_prev","preferNext","next","_path5","_offset","_text","_node4","_before","_after","_point5","_key5","properties","_path6","_node5","_key6","_key7","_newProperties","_key8","_path7","_properties","_node6","_parent4","newNode","_after2","_before3","_after3","_index4","_point6","_key9","GeneralTransforms","applyToDraft","finishDraft","NodeTransforms","nodes","SelectionTransforms","isDeepEqual","sourceSymbolKeys","_excluded$4","ownKeys$d","_objectSpread$d","range","focus","end","intersectionRange","rs","re","ts","te","start","isAfterStart","isBeforeEnd","rest","s2","s1","e1","e2","anchor","affinityAnchor","affinityFocus","isCollapsed","isElement","Editor","Element","val","elementKey","elementVal","_excluded$3","childPath","child","newRoot","cachedResult","isNodeList","from","visited","to","pass","_newPath","ownKeys$c","Operation","_objectSpread$c","inversePath","inverseNewPath","IS_EDITOR_CACHE","cachedIsEditor","isEditor","at","unit","fragment","isNormalizing","curNode","prevNode","Span","ownKeys$b","_objectSpread$b","offset","scrubber","_scrubber","_excluded$2","_excluded2$2","ownKeys$a","_objectSpread$a","loose","omitText","decorations","dec","leafEnd","leaf","leaves","leafStart","decorationStart","decorationEnd","middle","off","_off","getDefaultInsertLocation","matchPath","getCharacterDistance","str","isLTR","isRTL","codepoints","codepointsIteratorRTL","CodepointType","right","distance","gb11","char","getCodepointType","intersects","endsWithEmojiZWJ","gb12Or13","endsWithOddNumberOfRIs","isBoundaryPair","PUNCTUATION","CHAMELEON","getWordDistance","dist","remaining","splitByCharacterDistance","isWordCharacter","started","charDist","SPACE","nextChar","nextRemaining","isLowSurrogate","char1","isHighSurrogate","char2","charCode","reExtend","reSpacingMark","reL","reT","reLV","reLVT","STRINGS","attributes","createEditor","otherChildren","descendants","resolveDescendants","makeEditor","getAnchorOffset","getFocusOffset","selectionChild","createElement","createFocus","createFragment","createText","elementCreators","creators","DEFAULT_CREATORS","jsx","createFactory","tagName","_len","creator","ret","elements","_loop","createHyperscript","l","s","u","g","w","f","createTrackedSelector","useSelector","useReducer","affected","lastAffected","useRef","lastState","isChanged","selector","proxyCache","trackedConnections","name","api","api2","extensionConnector","existingConnection","newConnection","devtoolsOptions","get","anonymousActionType","enabled","__vite_import_meta_env__","connection","connectionInformation","isRecording","replace","nameOrAction","originalIsRecording","originalDispatch","message","parseJsonThen","stateFromDevtools","setStateFromDevtools","getTrackedConnectionState","nextLiftedState","lastComputedState","devtools","devtoolsImpl","parsed","stringified","createJSONStorage","getStorage","storage","parse","str2","newValue","toThenable","onFulfilled","_onRejected","_onFulfilled","onRejected","oldImpl","baseOptions","persistedState","hasHydrated","hydrationListeners","finishHydrationListeners","thenableSerialize","setItem","errorInSync","thenable","serializedValue","savedSetState","configResult","stateFromStorage","hydrate","postRehydrationCallback","storageValue","deserializedStorageValue","newOptions","newImpl","migrationResult","migratedState","persistImpl","setState","partial","createState","createStoreImpl","useSyncExternalStoreWithSelector","useSyncExternalStoreExports","identity","useStoreWithEqualityFn","equalityFn","useDebugValue","slice","LARGE_ARRAY_SIZE","FUNC_ERROR_TEXT","HASH_UNDEFINED","UNORDERED_COMPARE_FLAG","INFINITY","MAX_SAFE_INTEGER","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","promiseTag","regexpTag","setTag","symbolTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int32Tag","uint8Tag","uint8ClampedTag","reIsPlainProp","rePropName","reIsHostCtor","reIsUint","typedArrayTags","int16Tag","argsTag","arrayTag","boolTag","weakMapTag","freeGlobal","freeSelf","freeExports","exports","freeModule","module","moduleExports","freeProcess","nodeIsTypedArray","nodeUtil","array","predicate","baseProperty","object","baseTimes","iteratee","baseUnary","func","getValue","isHostObject","setToArray","arrayProto","catchSlateFragment","getSlateFragmentAttribute","htmlData","getSelection","isDOMElement","document","DOMEditor","addedNodes","removedNodes","parentMutation","batch","getActiveElement","_activeElement","_activeElement$shadow","_activeElement2","isBefore","otherNode","DOMNode","isAfter","_navigator$userAgent$2","IS_IOS","IS_ANDROID","IS_CHROME_LEGACY","IS_WECHATBROWSER","_navigator$userAgent$","IS_ANDROID_CHROME_LEGACY","Key","IS_NODE_MAP_DIRTY","NODE_TO_PARENT","EDITOR_TO_PLACEHOLDER_ELEMENT","ELEMENT_TO_NODE","EDITOR_TO_KEY_TO_ELEMENT","IS_FOCUSED","IS_COMPOSING","EDITOR_TO_USER_SELECTION","EDITOR_TO_ON_CHANGE","EDITOR_TO_SCHEDULE_FLUSH","EDITOR_TO_PENDING_INSERTION_MARKS","EDITOR_TO_PENDING_DIFFS","EDITOR_TO_PENDING_ACTION","EDITOR_TO_PENDING_SELECTION","EDITOR_TO_FORCE_RENDER","MARK_PLACEHOLDER_SYMBOL","_EDITOR_TO_SCHEDULE_F","domSelection","Transforms","event","rect","isPrev","edge","domRange","NODE_TO_KEY","window","EDITOR_TO_WINDOW","editable","editorEl","targetEl","isDOMNode","data","IS_READ_ONLY","slateNode","originEvent","domNode","EDITOR_TO_ELEMENT","KEY_TO_ELEMENT","texts","attr","trueLength","nextText","_nextText$textContent","domText","domPoint","domAnchor","domFocus","startNode","isBackward","isStartAtZeroWidth","endEl","endNode","startOffset","isEndAtZeroWidth","domEl","nearestNode","normalizeDOMPoint","textNode","parentNode","_domNode$textContent","_domNode$textContent2","voidNode","potentialVoidNode","potentialNonEditableNode","nonEditableNode","leafNode","nearestOffset","contents","exactMatch","leafNodes","getLeafNodes","elementNode","_leafNodes$find","_leafNodes","_leafNodes2$findLast","searchDirection","IS_FIREFOX","_slateNode","suppressThrow","_focusNode$textConten","isDOMSelection","anchorOffset","focusNode","focusOffset","firstRange","lastRange","getLastChildren","firstNodeRow","lastNodeRow","firstNode","lastNode","anchorNode","hasShadowRoot","verifyDiffState","textDiff","nextPath","nextNode","applyStringDiff","diffs","max","removedText","targetText","prefixLength","longestCommonPrefixLength","suffixLength","longestCommonSuffixLength","normalized","overlap","sliceEnd","applied","targetRange","normalizePoint","parentBlock","pendingDiffs","_anchor","_transformed","transformed","transformPendingRange","transformPendingPoint","transformTextDiff","doRectsIntersect","compareRect","areRangesSameLine","rect1","rect2","findCurrentLineRange","parentRange","positions","withDOM","clipboardFormatKey","apply","deleteBackward","removeMark","_EDITOR_TO_PENDING_DI","addMark","_EDITOR_TO_PENDING_DI2","parentBlockEntry","parentElementRange","currentLineRange","pendingSelection","pendingAction","_EDITOR_TO_USER_SELEC","getMatches","matches","commonPath","changedPath","changedNode","changedNodeKey","changedPathRef","pathRefMatches","pathRef","startVoid","endVoid","zw","isNewline","isDOMText","attach","span","encoded","div","decoded","line","lines","split","onContextChange","onChange","TRIPLE_CLICK","HOTKEYS","APPLE_HOTKEYS","WINDOWS_HOTKEYS","create","generic","apple","windows","isGeneric","isHotkey","isApple","isWindows","hotkeys","_excluded","_excluded2","shallowCompare","obj2","obj1","rangeOwnProps","other","isDecorationFlagsEqual","isTextDecorationsEqual","resizeObservers","hasActiveObservations","ro","hasSkippedObservations","msg","deliverResizeLoopError","ResizeObserverBoxOptions","ResizeObserverSize","inlineSize","blockSize","DOMRectReadOnly","width","height","top","bottom","rectangle","isSVG","offsetWidth","offsetHeight","scrollRegexp","verticalRegexp","IE","parseDimension","pixel","size","switchSizes","calculateBoxSizes","forceRecalculation","cache","svg","removePadding","canScrollVertically","canScrollHorizontally","cs","borderTop","borderRight","borderBottom","borderLeft","horizontalPadding","paddingBottom","horizontalBorderArea","verticalBorderArea","horizontalScrollbarThickness","verticalScrollbarThickness","widthReduction","verticalPadding","contentWidth","contentHeight","heightReduction","borderBoxWidth","borderBoxHeight","boxes","paddingLeft","observedBox","borderBoxSize","devicePixelContentBoxSize","ResizeObserverEntry","calculateDepthForNode","isHidden","depth","broadcastActiveObservations","shallowestDepth","callbacks","ot","calculateBoxSize","targetDepth","callbacks_1","_i","gatherActiveObservationsAtDepth","trigger","notify","queueMicroTask","toggle_1","el_1","queueResizeObserver","watching","isWatching","observerConfig","events","time","timeout","scheduled","Scheduler","_this","CATCH_PERIOD","elementsHaveResized","scheduler","updateCount","skipNotifyOnElement","ResizeObservation","ResizeObserverDetail","resizeObserver","observerMap","getObservationIndex","observationTargets","ResizeObserverController","detail","lastObservation","ResizeObserver","useSlateStatic","useContext","ReactEditor","ownKeys$5","_objectSpread$5","debug","isDataTransfer","flushing","insertPositionHint","performAction","flush","flushTimeoutId","actionTimeoutId","hasPendingDiffs","hasPendingAction","selectionRef","EDITOR_TO_USER_MARKS","scheduleSelectionChange","pendingMarks","scheduleOnDOMSelectionChange","onDOMSelectionChange","applyPendingSelection","userMarks","_event","compositionEndTimeoutId","handleCompositionStart","updatePlaceholderVisibility","placeholderElement","forceHide","_EDITOR_TO_PENDING_DI3","idx","change","normalizeStringDiff","idCounter","mergeStringDiffs","merged","run","handleDOMBeforeInput","_targetRange2","nativeTargetRange","_end","_start","_leaf","direction","handleUserSelect","canStoreDiff","_nativeTargetRange","nativeCollapsed","storeDiff","scheduleAction","parts","React","containerRef","decorate","readOnly","renderElement","renderLeaf","onSelectionChange","onValueChange","Plate","useId","React16","scrollRef","usePlateInstancesWarn","PlateInner","readOnlyProp","editableProps","useEditorRef","selectors","usePlateSelectors","storeReadOnly","storeRenderLeaf","storeRenderElement","useMemoOnce2","pipeDecorate","storeDecorate","decorateMemo","versionDecorate","React17","pipeRenderElement","pipeRenderLeaf","useDeepCompareMemo","_props","DOM_HANDLERS","handlerKey","pipeHandler","omit","clsx4","onChangeProp","onSelectionChangeProp","React18","onValueChangeProp","PlateControllerEffect","idFromStore","React19","focusAtom","plateControllerStore","optic","setCurrentStore","usePlateControllerActions","primary","setPrimaryEditorIds","useFocused","setActiveId","activeId","ids","focused","PlateSlate","slateProps","useSlateProps","aboveSlate","Slate","AboveSlate","PlateContent","React21","autoFocusOnEditable","useEditableProps","combinedRef","beforeEditable","BeforeEditable","AfterEditable","afterEditable","aboveEditable","EditorMethodsEffect","EditorHotkeysEffect","editableRef","EditorStateEffect","EditorRefEffect","AboveEditable","prevReadOnly","usePlateEditor","useMemoOnce3","createPlateEditor","HOC","Component","hocRef","componentRef","hocProps","usePlateElement","elementToAttributes","nodeProps","rootProps","mounted","block","PlateElement","rootRef","usePlateLeaf","omitPluginContext2","leafToAttributes","clsx2","PlateLeaf","childrenProps","React3","createHOC","withHOC","components","_components","optionsByKey","castArray","opt","merge","createNodesHOC","createNodeHOC","createNodesWithHOC","selectEditor","focusEditor","location","getStartPoint","getEndPoint","useMarkToolbarButtonState","clear","nodeType","isMarkActive","pressed","useMarkToolbarButton","usePlaceholderState","hideOnBlur","query","selected","composing","findNodePath2","findNodePath3","removeNodes","useSelectionFragmentProp","structuralTypes","useEditorSelector5","getSelectionFragment","getFragmentProp","editorContainerVariants","cva","cn","EditorContainer","variant","editorVariants","baseMerge","customDefaultsMerge","objValue","srcValue","stack","require$$0","require$$1","require$$2","require$$3","defaultsDeep","defaultsDeep_1","mergePlugins","basePlugin","mergeWith","createSlatePlugin","baseConfig","isFunction","initialExtension","newPlugin","config2","configureNestedPlugin","updatedPlugins","nestedPlugin","found","result2","extension","extendConfig","extendNestedPlugin","applyDeepToNodes","queryNode","isAncestor","types","getKeyByType","plugin2","excludeBelowPlugins","excludePlugins","_isElement","_isBlock","isLeaf","targetPlugins","maxLevel","excludeTypes","getKeysByTypes","getInjectedPlugins","injectedPlugin","injectedPlugins","createHotkey","isKeyHotkey","Hotkeys","mergeDeepToNodes","markableVoid","voidTypes","markableVoidTypes","inlineTypes","isInline","insertData","parser","deserialize","formats","mimeTypeList","fmt","mimeType","pipeInsertDataQuery","pipeTransformData","pipeTransformFragment","pipeInsertFragment","withParser","PlateError","details","log","level","getOptions","resetEditorChildren","resetEditor","toggleBlock","editorNodesOptions","defaultType","BaseParagraphPlugin","someNode","isActive","withSlateNext","deleteForward","resetMarks","isSelectionAtBlockStart","toggleMark","CARRIAGE_RETURN","NO_BREAK_SPACE","TAB","isHtmlElement","currentChild","traverseHtmlNode","previousChild","traverseHtmlElements","rootNode","replacementTextNode","cleanHtmlCrLf","ALLOWED_EMPTY_ELEMENTS","isEmpty","removeIfEmpty","parentElement","cleanHtmlEmptyElements","newElement","cleanHtmlFontElements","replaceTagName","isHtmlFragmentHref","href","unwrapHtmlElement","cleanHtmlTextNodes","traverseHtmlTexts","hasSpace","LINE_FEED","hasLineFeed","inlineTagNames","displayProperty","tagNameIsInline","isHtmlInlineElement","copyBlockMarksToSpanChild","isHtmlTable","backgroundColor","color","fontFamily","fontStyle","fontWeight","fontSize","textDecoration","collapseString","shouldCollapseWhiteSpace","trimEnd","trimStart","whiteSpaceIncludesNewlines","pluginDeserializeHtml","deserializeLeaf","divChild","deselect","BlockSelectionPlugin","textPlain","selectedFragmentStr","encodedFragment","selectInsertedBlocks","setOption","getEditorPlugin","isBlock","pasteSelectedBlocks","getEditorPlugin2","getStartPoint2","isElementEmpty","Path3","insertNodes","BlockSelectionAfterEditable","useEditorRef2","getOption","useEditorPlugin7","isSelecting2","useOption","useSelectionArea","setIsMounted","inputRef","handleKeyDown","isReadonly","isEditorReadOnly","getEndPoint2","selectedIds","firstId","prevId","lastId","handleCopy","handleCut","copySelectedBlocks","handlePaste","isMounted","ReactDOM","onKeyDownSelection","isHotkey2","ancestorNode","isRangeInSameBlock","select2","stripMarkdownInline","stripMarkdown","stripMarkdownBlocks","leadingSpaces","trailingSpaces","strippedText","MarkdownPlugin","remarkTextTypes","elementRules","elementRule","remarkDefaultTextRules","inlineNodes","listDepth","_c","spacer","isOL","_","ulListStyleTypes","listStyleType","pre","listStart","treatAsLeaf","serializeMdNodes","optionsNodes","defaultSerializeMdNodesOptions","v","serializeMdNode","getNodeString","leadingMatch","serializedContent","remarkDefaultElementRules","deserializeMd","serializeMd","files","getSelectedDomNode","getAllSelectableDomNode","BlockMenuPlugin","createTPlatePlugin","setOptions","BLOCK_CONTEXT_MENU_ID","useBlockSelectable","useElement","useEditorPlugin","findNodePath","enableContextMenu","nodeEntry","getAboveNode","isSelected","id2","isOpenAlways","isVoid","EventTarget","ok","unitify","css","method","ev","on","eventListener","simplifyEvent","evt","clientY","clientX","intersectsScroll","mode","container","containerRect","scrollLeft","scrollTop","selectAll","doc","isTouchDevice","isSafariBrowser","frames","previousArgs","lock","frameId","shouldTrigger","triggers","reqButtonIsPressed","modifier","allReqModifiersArePressed","_e","document2","features","activate","startThreshold","x1","abs","_options","_selection","changed","stored","touched","addedElements","Ry","Rx","deltaX","intersect","reference","preceding","following","rangeItems","_areaClientLocation","_frame","_scrollSpeed","scroll","ceil","_areaLocation","silent","startAreas","resolvedBoundaries","evtPath","scrollElement","_singleClick","_container","_containerRect","clientHeight","clientWidth","scrollHeight","x2","startScrollMargins","y2","y3","y1","x4","_areaRect","x3","y4","_selectables","invert","added","removed","newlyTouched","includeStored","quiet","SelectionArea","areaOptions","deselectEditor","selectedEntries","selectedFragment","copyToClipboard","Path2","findNode","focusEditor2","getPreviousNode","getNextNode","nextId","isSelectionCoverBlock","getAncestorNode","duplicateBlockSelectionNodes","blocks","duplicateBlocks","lastBlock","targetPath","getNodeEntry","targetNode","insertBlocksAndSelect","insertNodes2","removeBlockSelectionNodes","selectBlockSelectionNodes","selectNodes","setBlockSelectionNodes","withoutNormalizing2","setNodes","setBlockSelectionIndent","indent","currentIndent","setBlockSelectionTexts","createTPlatePlugin2","shadowInputRef","getNodeEntries","extractSelectableIds","delay","isSelecting","isSelectingSome","aiNodes","collapseSelection","removeAIMarks","unsetNodes","removeAINodes","isText","lastBatch","BaseAIPlugin","createTSlatePlugin","insertAINodes","undoAI","AIPlugin","toPlatePlugin","acceptAIChat","withAIBatch","sourceEditor","isEditorEmpty","isBlockSelecting","selectedBlocks","endPath","cloneDeep","replaceSelectionAIChat","isEditorEmpty2","BlockSelectionPlugin2","firstBlockPath","withNewBatch2","cloneDeep2","useLastAssistantMessage","useChatChunk","onChunk","isLoading","content","insertedTextRef","onFinish","prevIsLoadingRef","chunk","isFirst","useAIChatHooks","tf","useEditorPlugin2","getMarkdown","BlockSelectionPlugin3","replacePlaceholders","prompt","placeholder","createPromptFromConfig","params","isSelecting3","template","promptText","resetAIChat","chat","submitAIChat","_d","getEditorPlugin3","getEditorPrompt","withAIChat","normalizeNode","matchesTrigger","triggerPreviousCharPattern","triggerQuery","previousChar","getEditorString","getRange","getPointBefore","AIChatPlugin","bindFirst2","BlockSelectionPlugin5","focusEditor3","insertBelowAIChat","useEditorChat","onOpenBlockSelection","onOpenSelection","useEffect2","onOpenChange","blockSelectionApi","BlockSelectionPlugin6","onOpenCursor","isSelectionExpanded","open","renderCopilotBelowNodes","copilot","getEditorPlugin4","GhostText","suggestionText","deserializeInlineMd2","getOriginalFetch","callCompletionApi","body","credentials","fetch2","headers","setAbortController","setCompletion","setError","setLoading","onResponse","abortController","nonSpaceMatch","firstNonSpaceChar","isCJKChar","firstWord","remainingText","fullMatch","spaces","punctuation","getEditorPlugin5","completeOptions","getPrompt","completion","controller","loading","CopilotPlugin","acceptCopilotNextWord","getNextWord2","withoutAbort","deserializeInlineMd3","getPatchString","operations","withCopilot","insertText","debounceDelay","debounce","undo","lastUndos","oldText","redo","topRedo","prevSuggestion","shouldRemoveText","newText","writeHistory","stacks","shouldAbort","prevSelection","Range2","isEditorFocused","isBlockAboveEmpty","getBlockAbove2","blockAbove","getNextWord","contextEntry","serializeMdNodes2","isExpanded","isSelectionAtBlockEnd","bindFirst3","acceptCopilot","triggerCopilotSuggestion","BaseBoldPlugin","someHtmlElement","BaseCodePlugin","createSlatePlugin2","BaseItalicPlugin","createSlatePlugin3","BaseStrikethroughPlugin","someHtmlElement3","textContent","textTsv","cellStrings","_tableEntry","findNode15","tablePath","TablePlugin","Prism","_self","lang","extraVinculum","hLinePad","sqrtSize2","sqrtSize3","sqrtSize4","vertSegment","sqrtPath","viewBoxHeight","label","midHeight","numSvgChildren","SvgNode","makeEm","streamProtocol","AIChatEditor","systemSelecting","systemBlockSelecting","systemCommon","userDefault","userBlockSelecting","assertString","isString","invalidType","toDate","_assertString","_interopRequireDefault","date","alpha_1","alpha","alphanumeric","locale","englishLocales","decimal","arabicLocales","_locale","_i2","farsiLocales","_locale2","bengaliLocales","_i3","dotDecimal","commaDecimal","_i4","_i5","isFloat_1","_alpha","float","_isFloat","toFloat","toInt","toBoolean","equals","comparison","toString","defaults","contains","_toString","_merge","defaulContainsOptions","pattern","modifiers","len","default_fqdn_options","isFQDN","tld","part","IPv4SegmentFormat","IPv6SegmentFormat","IPv6AddressRegExp","IPv4AddressFormat","isIP","version","_isByteLength","_isFQDN","_isIP","splitNameAddress","emailUserPart","gmailUserPart","emailUserUtf8Part","quotedEmailUserUtf8","defaultMaxEmailLength","validateDisplayName","display_name_without_quotes","display_name","contains_illegal","all_start_with_back_slash","isEmail","display_email","domain","lower_domain","user","username","_user_parts","noBracketdomain","quotedEmailUser","user_parts","_slicedToArray","arr","_arrayWithHoles","_unsupportedIterableToArray","_nonIterableRest","minLen","_arrayLikeToArray","arr2","_iterableToArrayLimit","default_url_options","host","isRegExp","auth","port_str","protocol","_auth$split","password","hostname","ipv6","ipv6_match","port","checkHost","macAddress48","macAddress48NoSeparators","macAddress64WithDots","macAddress64NoSeparators","macAddress48WithDots","macAddress64","isMACAddress","isIPRange","subnetMaybe","v4Subnet","isValidIP","expectedSubnet","isDate","didErr","it","step","normalCompletion","_e2","zippedArr","default_date_options","formatDelimiter","dateAndFormat","zip","dateDelimiter","_step$value","_step","dateObj","fullYear","month","day","default_time_options","strictBooleans","looseBooleans","isBoolean","defaultOptions","isLocale","extlang","singleton","irregular","regular","delimiter","language","script","languageTagRegex","checkSumVal","isAlpha_1","_str","ignore","isAlphanumeric_1","isNumeric","isInt","int","intLeadingZeroes","maxCheckPassed","ltCheckPassed","gtCheckPassed","minCheckPassed","_isInt","isLowercase","isUppercase","isIMEI","imeiRegexWithHypens","imeiRegex","imeiRegexWithoutHypens","sum","mul","tp","chk","isAscii","ascii","isFullWidth_1","isFullWidth","isHalfWidth_1","isHalfWidth","_isFullWidth","isVariableWidth","_isHalfWidth","isMultibyte","multilineRegexp","flags","regexpAsStringLiteral","isSemVer","_multilineRegex","semanticVersioningRegex","isSurrogatePair","surrogatePair","includes","arrVal","isDecimal","decimalRegExp","regExp","default_decimal_options","hexadecimal","isOctal","octal","isDivisibleBy","_toFloat","hexcolor","includePercentValues","rgbaColor","isHSL","hslSpace","strippedStr","hslComma","isISRC","isIBAN_1","countryCodeArrayFilteredWithObjectIbanCode","countryCodeArray","hasValidIbanFormat","isoCountryCodeInIbanRegexCodeObject","isoCountryCode","ibanRegexThroughCountryCode","hasOnlyValidCountryCodes","isoCountryCodeInWhiteList","isoCountryCodeInBlackList","hasValidIbanChecksum","rearranged","remainder","alphaCapsReplacedWithDigits","isISO31661Alpha2_1","isISO31661Alpha2","validISO31661Alpha2CountriesCodes","_isISO31661Alpha","countryCode","isBICReg","md5","isHash","algorithm","hash","lengths","urlSafeBase64","notBase64","firstPaddingChar","isJWT","_isBase","dotSplit","isJSON","default_json_options","primitives","default_is_empty_options","presentationSequences","surrogatePairs","_iterableToArray","_arrayWithoutHoles","bgBgCheck","tin","century_year","digits","checksum","multip_lookup","isCanadianSIN","even","digitsArray","total","csCzCheck","full_year","_isDate","checkdigit","algorithms","deDeCheck","occurences","j","recurrent","trip_locations","year","century_digit","enUsCampusPrefix","enUsGetPrefixes","accum","verif","digit","esEsCheck","chars","lead_replace","weight","century_symbol","letters_lookup","checkdigits","frLuCheck","hrHrCheck","huHuCheck","itItNameCheck","xflag","vowelflag","number_locations","_number_locations","number_replace","month_replace","char_to_int","odd_convert","_i6","_char_to_int","multiplier","mtMtCheck","first_part","second_part","lookup","_checksum","_i7","ptBrCheck","_sum","_i8","identifiers","pos","_i9","_i10","ptPtCheck","roRoCheck","multipliers","skSkCheck","svSeCheck","tin_copy","current_year","current_century","taxIdFormat","deAtCheck","dkDkCheck","elGrCheck","enIeCheck","etEeCheck","frBeCheck","nlNlCheck","slSiCheck","ukUaCheck","taxIdCheck","allsymbols","sanitizeRegexes","isTaxID","strcopy","isMobilePhone_1","isMobilePhone","phones","isEthereumAddress","eth","isCurrency","currencyRegex","decimal_digits","symbol","negative","whole_dollar_amount_without_sep","whole_dollar_amount_with_sep","valid_whole_dollar_amounts","decimal_amount","default_currency_options","bech32","isISO6346_1","isISO6346","isISO6346Str","isDigit","letterCode","convertedCode","checkSumDigit","isISO8601","isValidDate","oYear","ordinalMatch","oDay","monthString","dayString","d","check","dateMonth","dateMDay","timeHour","timeMinute","timeOffset","timeNumOffset","rfc3339","fullDate","fullTime","isRFC3339","isISO4217_1","validISO4217CurrencyCodes","isBase32","crockfordBase32","defaultBase32Options","base32","isBase58","base58Reg","isDataURI","validMediaType","mediaType","schemeAndMediaType","validAttribute","isMagnetURI","rtrim","strIndex","_rtrim","_ltrim","isMailtoURI","_trim","_isEmail","queryString","allowedParams","isParseFailed","queryParams","_iterator","_createForOfIteratorHelper","_q$split","_q$split2","_url$replace$split","_url$replace$split2","_url$replace$split2$","email","mimeTypeSimple","mimeTypeMultipart","isLatLong","latDMS","defaultLatLongOptions","getText","domhandler_1","isASCIIAlpha","upper","SUCCESS","FAILURE","lower","consumeSpecialNameChar","NEXT_STATE","stateBeforeCdata1","ifElseState","stateBeforeCdata2","stateBeforeCdata3","stateBeforeCdata4","stateBeforeCdata5","stateBeforeScript1","stateBeforeScript2","stateBeforeScript4","stateAfterScript1","stateAfterScript2","stateBeforeStyle1","stateBeforeStyle2","stateBeforeStyle3","stateAfterStyle1","stateAfterStyle2","stateBeforeSpecialT","stateBeforeTitle1","stateBeforeTitle2","stateBeforeTitle3","stateAfterTitle1","stateAfterTitle2","stateAfterTitle3","Tokenizer","cbs","whitespace","quote","ch","column","token","tokens","atRules","getCh","skip","isNextString","cursor","popState","pushState","newState","replaceState","skipStr","addToken","initializeToken","buffer"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226],"sources":["../../node_modules/@udecode/utils/dist/index.mjs","../../node_modules/@udecode/react-utils/dist/index.mjs","../../node_modules/react-dnd/dist/core/DndContext.js","../../node_modules/redux/es/redux.js","../../node_modules/@react-dnd/invariant/dist/index.js","../../node_modules/dnd-core/dist/utils/js_utils.js","../../node_modules/dnd-core/dist/actions/dragDrop/types.js","../../node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js","../../node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js","../../node_modules/dnd-core/dist/actions/dragDrop/drop.js","../../node_modules/dnd-core/dist/actions/dragDrop/endDrag.js","../../node_modules/dnd-core/dist/utils/matchesType.js","../../node_modules/dnd-core/dist/actions/dragDrop/hover.js","../../node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js","../../node_modules/dnd-core/dist/actions/dragDrop/index.js","../../node_modules/dnd-core/dist/classes/DragDropManagerImpl.js","../../node_modules/dnd-core/dist/utils/coords.js","../../node_modules/dnd-core/dist/utils/dirtiness.js","../../node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js","../../node_modules/@react-dnd/asap/dist/makeRequestCall.js","../../node_modules/@react-dnd/asap/dist/AsapQueue.js","../../node_modules/@react-dnd/asap/dist/RawTask.js","../../node_modules/@react-dnd/asap/dist/TaskFactory.js","../../node_modules/@react-dnd/asap/dist/asap.js","../../node_modules/dnd-core/dist/actions/registry.js","../../node_modules/dnd-core/dist/contracts.js","../../node_modules/dnd-core/dist/interfaces.js","../../node_modules/dnd-core/dist/utils/getNextUniqueId.js","../../node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js","../../node_modules/dnd-core/dist/utils/equality.js","../../node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js","../../node_modules/dnd-core/dist/reducers/dragOffset.js","../../node_modules/dnd-core/dist/reducers/dragOperation.js","../../node_modules/dnd-core/dist/reducers/refCount.js","../../node_modules/dnd-core/dist/reducers/stateId.js","../../node_modules/dnd-core/dist/reducers/index.js","../../node_modules/dnd-core/dist/createDragDropManager.js","../../node_modules/react-dnd/dist/core/DndProvider.js","../../node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js","../../node_modules/react-dnd/dist/hooks/useCollector.js","../../node_modules/react-dnd/dist/hooks/useMonitorOutput.js","../../node_modules/react-dnd/dist/hooks/useCollectedProps.js","../../node_modules/react-dnd/dist/hooks/useOptionalFactory.js","../../node_modules/react-dnd/dist/hooks/useDrag/connectors.js","../../node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js","../../node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js","../../node_modules/react-dnd/dist/internals/registration.js","../../node_modules/@react-dnd/shallowequal/dist/index.js","../../node_modules/react-dnd/dist/internals/isRef.js","../../node_modules/react-dnd/dist/internals/wrapConnectorHooks.js","../../node_modules/react-dnd/dist/internals/SourceConnector.js","../../node_modules/react-dnd/dist/internals/TargetConnector.js","../../node_modules/react-dnd/dist/hooks/useDragDropManager.js","../../node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js","../../node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js","../../node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js","../../node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js","../../node_modules/react-dnd/dist/hooks/useDrag/useDragType.js","../../node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js","../../node_modules/react-dnd/dist/hooks/useDrag/useDrag.js","../../node_modules/react-dnd/dist/hooks/useDrop/connectors.js","../../node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js","../../node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js","../../node_modules/react-dnd/dist/hooks/useDrop/useAccept.js","../../node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js","../../node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js","../../node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js","../../node_modules/react-dnd/dist/hooks/useDrop/useDrop.js","../../node_modules/react-dnd-html5-backend/dist/utils/js_utils.js","../../node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js","../../node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js","../../node_modules/react-dnd-html5-backend/dist/NativeTypes.js","../../node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js","../../node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js","../../node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js","../../node_modules/react-dnd-html5-backend/dist/BrowserDetector.js","../../node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js","../../node_modules/react-dnd-html5-backend/dist/OffsetUtils.js","../../node_modules/react-dnd-html5-backend/dist/OptionsReader.js","../../node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js","../../node_modules/react-dnd-html5-backend/dist/getEmptyImage.js","../../node_modules/react-dnd-html5-backend/dist/index.js","../../node_modules/is-plain-object/dist/is-plain-object.mjs","../../node_modules/immer/dist/immer.mjs","../../node_modules/slate/dist/index.es.js","../../node_modules/slate-hyperscript/dist/index.es.js","../../node_modules/proxy-compare/dist/index.modern.js","../../node_modules/react-tracked/dist/index.modern.mjs","../../node_modules/zustand-x/node_modules/zustand/esm/middleware.mjs","../../node_modules/zustand-x/node_modules/zustand/esm/vanilla.mjs","../../node_modules/zustand-x/node_modules/zustand/esm/traditional.mjs","../../node_modules/lodash.mapvalues/index.js","../../node_modules/slate-dom/dist/index.es.js","../../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js","../../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js","../../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js","../../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js","../../node_modules/@juggle/resize-observer/lib/utils/freeze.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js","../../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js","../../node_modules/@juggle/resize-observer/lib/utils/element.js","../../node_modules/@juggle/resize-observer/lib/utils/global.js","../../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js","../../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js","../../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js","../../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js","../../node_modules/@juggle/resize-observer/lib/utils/process.js","../../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js","../../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js","../../node_modules/@juggle/resize-observer/lib/utils/scheduler.js","../../node_modules/@juggle/resize-observer/lib/ResizeObservation.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js","../../node_modules/@juggle/resize-observer/lib/ResizeObserver.js","../../node_modules/slate-react/dist/index.es.js","../../node_modules/@udecode/plate-core/dist/react/index.mjs","../../node_modules/@udecode/plate-utils/dist/react/index.mjs","../../src/lib/plate-ui/ui/editor.tsx","../../node_modules/lodash/_customDefaultsMerge.js","../../node_modules/lodash/defaultsDeep.js","../../node_modules/@udecode/plate-core/dist/index.mjs","../../node_modules/@udecode/plate-selection/dist/react/index.mjs","../../node_modules/@udecode/plate-markdown/dist/index.mjs","../../node_modules/@udecode/plate-selection/dist/index.mjs","../../node_modules/@udecode/plate-ai/dist/react/index.mjs","../../node_modules/@udecode/plate-basic-marks/dist/react/index.mjs","../../node_modules/@udecode/plate-code-block/dist/react/index.mjs","../../node_modules/@udecode/plate-table/dist/react/index.mjs","../../node_modules/prismjs/prism.js","../../node_modules/@udecode/plate-code-block/dist/index.mjs","../../node_modules/katex/dist/katex.mjs","../../src/lib/plate-ui/hooks/use-chat.ts","../../src/lib/plate-ui/ui/ai-chat-editor.tsx","../../src/lib/plate-ui/ui/ai-menu-items.tsx","../../src/components/organisms/PlateEditor/plugins/ai-plugins.tsx","../../src/components/organisms/PlateEditor/plugins/copilot-plugins.tsx","../../node_modules/validator/lib/util/assertString.js","../../node_modules/validator/lib/toDate.js","../../node_modules/validator/lib/alpha.js","../../node_modules/validator/lib/isFloat.js","../../node_modules/validator/lib/toFloat.js","../../node_modules/validator/lib/toInt.js","../../node_modules/validator/lib/toBoolean.js","../../node_modules/validator/lib/equals.js","../../node_modules/validator/lib/util/toString.js","../../node_modules/validator/lib/util/merge.js","../../node_modules/validator/lib/contains.js","../../node_modules/validator/lib/matches.js","../../node_modules/validator/lib/isByteLength.js","../../node_modules/validator/lib/isFQDN.js","../../node_modules/validator/lib/isIP.js","../../node_modules/validator/lib/isEmail.js","../../node_modules/validator/lib/isURL.js","../../node_modules/validator/lib/isMACAddress.js","../../node_modules/validator/lib/isIPRange.js","../../node_modules/validator/lib/isDate.js","../../node_modules/validator/lib/isTime.js","../../node_modules/validator/lib/isBoolean.js","../../node_modules/validator/lib/isLocale.js","../../node_modules/validator/lib/isAbaRouting.js","../../node_modules/validator/lib/isAlpha.js","../../node_modules/validator/lib/isAlphanumeric.js","../../node_modules/validator/lib/isNumeric.js","../../node_modules/validator/lib/isPassportNumber.js","../../node_modules/validator/lib/isInt.js","../../node_modules/validator/lib/isPort.js","../../node_modules/validator/lib/isLowercase.js","../../node_modules/validator/lib/isUppercase.js","../../node_modules/validator/lib/isIMEI.js","../../node_modules/validator/lib/isAscii.js","../../node_modules/validator/lib/isFullWidth.js","../../node_modules/validator/lib/isHalfWidth.js","../../node_modules/validator/lib/isVariableWidth.js","../../node_modules/validator/lib/isMultibyte.js","../../node_modules/validator/lib/util/multilineRegex.js","../../node_modules/validator/lib/isSemVer.js","../../node_modules/validator/lib/isSurrogatePair.js","../../node_modules/validator/lib/util/includes.js","../../node_modules/validator/lib/isDecimal.js","../../node_modules/validator/lib/isHexadecimal.js","../../node_modules/validator/lib/isOctal.js","../../node_modules/validator/lib/isDivisibleBy.js","../../node_modules/validator/lib/isHexColor.js","../../node_modules/validator/lib/isRgbColor.js","../../node_modules/validator/lib/isHSL.js","../../node_modules/validator/lib/isISRC.js","../../node_modules/validator/lib/isIBAN.js","../../node_modules/validator/lib/isISO31661Alpha2.js","../../node_modules/validator/lib/isBIC.js","../../node_modules/validator/lib/isMD5.js","../../node_modules/validator/lib/isHash.js","../../node_modules/validator/lib/isBase64.js","../../node_modules/validator/lib/isJWT.js","../../node_modules/validator/lib/isJSON.js","../../node_modules/validator/lib/isEmpty.js","../../node_modules/validator/lib/isLength.js","../../node_modules/validator/lib/isTaxID.js","../../node_modules/validator/lib/isMobilePhone.js","../../node_modules/validator/lib/isEthereumAddress.js","../../node_modules/validator/lib/isCurrency.js","../../node_modules/validator/lib/isBtcAddress.js","../../node_modules/validator/lib/isISO6346.js","../../node_modules/validator/lib/isISO6391.js","../../node_modules/validator/lib/isISO8601.js","../../node_modules/validator/lib/isRFC3339.js","../../node_modules/validator/lib/isISO31661Alpha3.js","../../node_modules/validator/lib/isISO4217.js","../../node_modules/validator/lib/isBase32.js","../../node_modules/validator/lib/isBase58.js","../../node_modules/validator/lib/isDataURI.js","../../node_modules/validator/lib/isMagnetURI.js","../../node_modules/validator/lib/rtrim.js","../../node_modules/validator/lib/ltrim.js","../../node_modules/validator/lib/trim.js","../../node_modules/validator/lib/isMailtoURI.js","../../node_modules/validator/lib/isMimeType.js","../../node_modules/validator/lib/isLatLong.js","../../node_modules/domutils/lib/stringify.js","../../node_modules/css-select/lib/pseudo-selectors/aliases.js","../../node_modules/cheerio/node_modules/htmlparser2/lib/Tokenizer.js","../../node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js","../../node_modules/parse5/lib/parser/index.js","../../node_modules/cheerio/lib/api/forms.js","../../node_modules/mensch/lib/debug.js","../../node_modules/mensch/lib/lexer.js"],"sourcesContent":["// src/environment.ts\nvar IS_APPLE = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\n\n// src/escapeRegexp.ts\nvar escapeRegExp = (text) => {\n  return text.replaceAll(/[#$()*+,.?[\\\\\\]^s{|}-]/g, \"\\\\$&\");\n};\n\n// src/findHtmlParentElement.ts\nvar findHtmlParentElement = (el, nodeName) => {\n  if (!el || el.nodeName === nodeName) {\n    return el;\n  }\n  return findHtmlParentElement(el.parentElement, nodeName);\n};\n\n// src/getHandler.ts\nvar getHandler = (cb, ...args) => () => {\n  cb == null ? void 0 : cb(...args);\n};\n\n// src/hexToBase64.ts\nvar hexToBase64 = (hex) => {\n  const hexPairs = hex.match(/\\w{2}/g) || [];\n  const binary = hexPairs.map(\n    (hexPair) => String.fromCodePoint(Number.parseInt(hexPair, 16))\n  );\n  return btoa(binary.join(\"\"));\n};\n\n// src/isUrl.ts\nvar protocolAndDomainRE = /^(?:\\w+:)?\\/\\/(\\S+)$/;\nvar emailLintRE = /mailto:([^?\\\\]+)/;\nvar localhostDomainRE = /^localhost[\\d:?]*(?:[^\\d:?]\\S*)?$/;\nvar nonLocalhostDomainRE = /^[^\\s.]+\\.\\S{2,}$/;\nvar isUrl = (string) => {\n  if (typeof string !== \"string\") {\n    return false;\n  }\n  const generalMatch = string.match(protocolAndDomainRE);\n  const emailLinkMatch = string.match(emailLintRE);\n  const match = generalMatch || emailLinkMatch;\n  if (!match) {\n    return false;\n  }\n  const everythingAfterProtocol = match[1];\n  if (!everythingAfterProtocol) {\n    return false;\n  }\n  try {\n    new URL(string);\n  } catch (e) {\n    return false;\n  }\n  return localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol);\n};\n\n// src/mergeProps.ts\nvar mergeProps = (props, overrideProps, {\n  handlerKeys,\n  handlerQuery = (key) => key.startsWith(\"on\")\n} = {}) => {\n  const map = /* @__PURE__ */ new Map();\n  const acc = {};\n  const mapProps = (_props) => {\n    if (!_props)\n      return;\n    Object.entries(_props).forEach(([key, value]) => {\n      var _a;\n      if ((!handlerKeys || handlerKeys.includes(key)) && (!handlerQuery || handlerQuery(key)) && typeof value === \"function\") {\n        if (!map.has(key)) {\n          map.set(key, []);\n        }\n        (_a = map.get(key)) == null ? void 0 : _a.push(value);\n        acc[key] = (...args) => {\n          var _a2;\n          (_a2 = map.get(key)) == null ? void 0 : _a2.forEach((fn) => fn(...args));\n        };\n      } else {\n        acc[key] = value;\n      }\n    });\n  };\n  mapProps(props);\n  mapProps(overrideProps);\n  return acc;\n};\n\n// src/sanitizeUrl.ts\nvar sanitizeUrl = (url, { allowedSchemes, permitInvalid = false }) => {\n  if (!url)\n    return null;\n  let parsedUrl = null;\n  try {\n    parsedUrl = new URL(url);\n  } catch (e) {\n    return permitInvalid ? url : null;\n  }\n  if (allowedSchemes && !allowedSchemes.includes(parsedUrl.protocol.slice(0, -1))) {\n    return null;\n  }\n  return parsedUrl.href;\n};\n\n// src/type-utils.ts\nvar isUndefined = (obj) => obj === void 0;\nvar isNull = (obj) => obj === null;\nvar isUndefinedOrNull = (obj) => isUndefined(obj) || isNull(obj);\nvar isDefined = (arg) => !isUndefinedOrNull(arg);\nfunction bindFirst(fn, firstArg) {\n  return (...args) => fn(firstArg, ...args);\n}\nexport {\n  IS_APPLE,\n  bindFirst,\n  escapeRegExp,\n  findHtmlParentElement,\n  getHandler,\n  hexToBase64,\n  isDefined,\n  isNull,\n  isUndefined,\n  isUndefinedOrNull,\n  isUrl,\n  mergeProps,\n  sanitizeUrl\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/createSlotComponent.tsx\nimport React from \"react\";\nimport { Slot } from \"@radix-ui/react-slot\";\nvar createSlotComponent = (element) => (\n  // eslint-disable-next-line react/display-name\n  React.forwardRef((_a2, ref) => {\n    var _b = _a2, { as, asChild = false } = _b, props = __objRest(_b, [\"as\", \"asChild\"]);\n    const Comp = asChild ? Slot : as || element;\n    return /* @__PURE__ */ React.createElement(Comp, __spreadValues({ ref }, props));\n  })\n);\n\n// src/Box.tsx\nvar Box = createSlotComponent(\"div\");\n\n// src/MemoizedChildren.tsx\nimport React2 from \"react\";\nvar MemoizedChildren = React2.memo(\n  ({ children }) => {\n    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, children);\n  }\n);\n\n// src/PortalBody.tsx\nimport React3 from \"react\";\nimport ReactDOM from \"react-dom\";\nvar PortalBody = ({\n  children,\n  element\n}) => {\n  const container = element || typeof window !== \"undefined\" ? document.body : void 0;\n  if (!container) return /* @__PURE__ */ React3.createElement(React3.Fragment, null, children);\n  return ReactDOM.createPortal(children, element || document.body);\n};\n\n// src/Text.tsx\nvar Text = createSlotComponent(\"span\");\n\n// src/composeEventHandlers.ts\nvar composeEventHandlers = (originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) => (event) => {\n  originalEventHandler == null ? void 0 : originalEventHandler(event);\n  if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n    return ourEventHandler == null ? void 0 : ourEventHandler(event);\n  }\n};\n\n// src/createPrimitiveComponent.tsx\nimport React5 from \"react\";\nimport { isDefined } from \"@udecode/utils\";\nimport { clsx } from \"clsx\";\n\n// src/useComposedRef.ts\nimport React4 from \"react\";\nvar setRef = (ref, value) => {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref !== null && ref !== void 0) {\n    ref.current = value;\n  }\n};\nvar composeRefs = (...refs) => (node) => refs.forEach((ref) => setRef(ref, node));\nvar useComposedRef = (...refs) => {\n  return React4.useCallback(composeRefs(...refs), refs);\n};\n\n// src/createPrimitiveComponent.tsx\nvar createPrimitiveComponent = (element) => {\n  const Comp = createSlotComponent(element);\n  return ({\n    propsHook,\n    stateHook\n  } = {}) => {\n    return React5.forwardRef(\n      (_a2, ref) => {\n        var _b = _a2, {\n          asChild,\n          className: classNameProp,\n          getClassName,\n          options,\n          state: stateProp\n        } = _b, props = __objRest(_b, [\n          \"asChild\",\n          \"className\",\n          \"getClassName\",\n          \"options\",\n          \"state\"\n        ]);\n        var _a3, _b2;\n        const state = isDefined(stateProp) ? stateProp : stateHook ? stateHook(options) : void 0;\n        const {\n          hidden,\n          props: hookProps,\n          ref: hookRef\n        } = propsHook ? propsHook(state) : { hidden: false, props: {}, ref: null };\n        const _ref = useComposedRef(ref, hookRef);\n        const className = isDefined(hookProps == null ? void 0 : hookProps.className) || isDefined(classNameProp) ? clsx(hookProps == null ? void 0 : hookProps.className, classNameProp) : void 0;\n        const style = (hookProps == null ? void 0 : hookProps.style) || props.style ? __spreadValues(__spreadValues({}, hookProps == null ? void 0 : hookProps.style), props.style) : void 0;\n        if (!asChild && hidden) return null;\n        return /* @__PURE__ */ React5.createElement(\n          Comp,\n          __spreadValues(__spreadValues(__spreadProps(__spreadValues({\n            ref: _ref,\n            asChild\n          }, hookProps), {\n            className,\n            style\n          }), props), (_b2 = (_a3 = props.setProps) == null ? void 0 : _a3.call(props, hookProps != null ? hookProps : {})) != null ? _b2 : {})\n        );\n      }\n    );\n  };\n};\n\n// src/createPrimitiveElement.tsx\nimport React6 from \"react\";\nfunction createPrimitiveElement(tag) {\n  return React6.forwardRef(\n    function CreateComponent(props, ref) {\n      return React6.createElement(tag, __spreadProps(__spreadValues({}, props), { ref }));\n    }\n  );\n}\n\n// src/useEffectOnce.ts\nimport React7 from \"react\";\nfunction useEffectOnce(effect, deps) {\n  const initialized = React7.useRef(false);\n  const prevDepsRef = React7.useRef(deps);\n  React7.useEffect(() => {\n    const depsChanged = deps.some((dep, i) => dep !== prevDepsRef.current[i]);\n    if (!initialized.current || depsChanged) {\n      initialized.current = true;\n      prevDepsRef.current = deps;\n      effect();\n    }\n  }, deps);\n}\n\n// src/useIsomorphicLayoutEffect.ts\nimport React8 from \"react\";\nvar _a;\nvar CAN_USE_DOM = typeof window !== \"undefined\" && ((_a = window.document) == null ? void 0 : _a.createElement) !== void 0;\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? React8.useLayoutEffect : React8.useEffect;\n\n// src/useMemoOnce.ts\nimport React9 from \"react\";\nfunction useMemoOnce(factory, deps) {\n  const initialized = React9.useRef(false);\n  const prevDepsRef = React9.useRef(deps);\n  const memoizedValueRef = React9.useRef();\n  if (!initialized.current || deps.some((dep, i) => dep !== prevDepsRef.current[i])) {\n    initialized.current = true;\n    prevDepsRef.current = deps;\n    memoizedValueRef.current = factory();\n  }\n  return memoizedValueRef.current;\n}\n\n// src/useOnClickOutside.ts\nimport React10 from \"react\";\nvar canUsePassiveEvents = () => {\n  if (typeof window === \"undefined\" || typeof window.addEventListener !== \"function\")\n    return false;\n  let passive = false;\n  const options = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passive = true;\n    }\n  });\n  const noop = () => null;\n  window.addEventListener(\"test\", noop, options);\n  window.removeEventListener(\"test\", noop, options);\n  return passive;\n};\nvar DEFAULT_IGNORE_CLASS = \"ignore-onclickoutside\";\nvar checkClass = (el, cl) => {\n  var _a2;\n  return (_a2 = el.classList) == null ? void 0 : _a2.contains(cl);\n};\nvar hasIgnoreClass = (e, ignoreClass) => {\n  let el = e.target || e;\n  while (el) {\n    if (Array.isArray(ignoreClass)) {\n      if (ignoreClass.some((c) => checkClass(el, c))) return true;\n    } else if (checkClass(el, ignoreClass)) {\n      return true;\n    }\n    el = el.parentElement;\n  }\n  return false;\n};\nvar clickedOnScrollbar = (e) => document.documentElement.clientWidth <= e.clientX || document.documentElement.clientHeight <= e.clientY;\nvar getEventOptions = (type) => type.includes(\"touch\") && canUsePassiveEvents() ? { passive: true } : false;\nvar useOnClickOutside = (callback, {\n  detectIFrame = true,\n  disabled,\n  eventTypes = [\"mousedown\", \"touchstart\"],\n  excludeScrollbar,\n  ignoreClass = DEFAULT_IGNORE_CLASS,\n  refs: refsOpt\n} = {}) => {\n  const [refsState, setRefsState] = React10.useState([]);\n  const callbackRef = React10.useRef(callback);\n  callbackRef.current = callback;\n  const ref = React10.useCallback(\n    (el) => setRefsState((prevState) => [...prevState, { current: el }]),\n    []\n  );\n  React10.useEffect(\n    () => {\n      if (!(refsOpt == null ? void 0 : refsOpt.length) && refsState.length === 0) return;\n      const getEls = () => {\n        const els = [];\n        (refsOpt || refsState).forEach(\n          ({ current }) => current && els.push(current)\n        );\n        return els;\n      };\n      const handler = (e) => {\n        if (!hasIgnoreClass(e, ignoreClass) && !(excludeScrollbar && clickedOnScrollbar(e)) && getEls().every((el) => !el.contains(e.target)))\n          callbackRef.current(e);\n      };\n      const blurHandler = (e) => (\n        // On firefox the iframe becomes document.activeElement in the next event loop\n        setTimeout(() => {\n          const { activeElement } = document;\n          if ((activeElement == null ? void 0 : activeElement.tagName) === \"IFRAME\" && !hasIgnoreClass(activeElement, ignoreClass) && !getEls().includes(activeElement))\n            callbackRef.current(e);\n        }, 0)\n      );\n      const removeEventListener = () => {\n        eventTypes.forEach(\n          (type) => document.removeEventListener(\n            type,\n            handler,\n            getEventOptions(type)\n          )\n        );\n        if (detectIFrame) window.removeEventListener(\"blur\", blurHandler);\n      };\n      if (disabled) {\n        removeEventListener();\n        return;\n      }\n      eventTypes.forEach(\n        (type) => document.addEventListener(type, handler, getEventOptions(type))\n      );\n      if (detectIFrame) window.addEventListener(\"blur\", blurHandler);\n      return () => removeEventListener();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      refsState,\n      ignoreClass,\n      excludeScrollbar,\n      disabled,\n      detectIFrame,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      JSON.stringify(eventTypes)\n    ]\n  );\n  return ref;\n};\n\n// src/useStableMemo.ts\nimport React11 from \"react\";\nvar useStableMemo = (producer, deps) => {\n  const [value, setValue] = React11.useState(producer);\n  React11.useLayoutEffect(() => {\n    setValue(producer);\n  }, deps);\n  return value;\n};\n\n// src/withProviders.tsx\nimport React12 from \"react\";\nvar withProviders = (...providers) => (WrappedComponent) => (props) => providers.reduceRight(\n  (acc, prov) => {\n    let Provider = prov;\n    if (Array.isArray(prov)) {\n      [Provider] = prov;\n      return /* @__PURE__ */ React12.createElement(Provider, __spreadValues({}, prov[1]), acc);\n    }\n    return /* @__PURE__ */ React12.createElement(Provider, null, acc);\n  },\n  /* @__PURE__ */ React12.createElement(WrappedComponent, __spreadValues({}, props))\n);\n\n// src/withRef.tsx\nimport React13 from \"react\";\nfunction withRef(renderFunction) {\n  return React13.forwardRef(renderFunction);\n}\nexport {\n  Box,\n  CAN_USE_DOM,\n  DEFAULT_IGNORE_CLASS,\n  MemoizedChildren,\n  PortalBody,\n  Text,\n  composeEventHandlers,\n  composeRefs,\n  createPrimitiveComponent,\n  createPrimitiveElement,\n  createSlotComponent,\n  useComposedRef,\n  useEffectOnce,\n  useIsomorphicLayoutEffect,\n  useMemoOnce,\n  useOnClickOutside,\n  useStableMemo,\n  withProviders,\n  withRef\n};\n//# sourceMappingURL=index.mjs.map","import { createContext } from 'react';\n/**\n * Create the React Context\n */ export const DndContext = createContext({\n    dragDropManager: undefined\n});\n\n//# sourceMappingURL=DndContext.js.map","import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';\n\n/**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */\nfunction formatProdErrorMessage(code) {\n  return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + 'use the non-minified dev environment for full errors. ';\n}\n\n// Inlined version of the `symbol-observable` polyfill\nvar $$observable = (function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n})();\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\nfunction miniKindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n  var type = typeof val;\n\n  switch (type) {\n    case 'boolean':\n    case 'string':\n    case 'number':\n    case 'symbol':\n    case 'function':\n      {\n        return type;\n      }\n  }\n\n  if (Array.isArray(val)) return 'array';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  var constructorName = ctorName(val);\n\n  switch (constructorName) {\n    case 'Symbol':\n    case 'Promise':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Map':\n    case 'Set':\n      return constructorName;\n  } // other\n\n\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n}\n\nfunction ctorName(val) {\n  return typeof val.constructor === 'function' ? val.constructor.name : null;\n}\n\nfunction isError(val) {\n  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';\n}\n\nfunction kindOf(val) {\n  var typeOfVal = typeof val;\n\n  if (process.env.NODE_ENV !== 'production') {\n    typeOfVal = miniKindOf(val);\n  }\n\n  return typeOfVal;\n}\n\n/**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(0) : 'It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(1) : \"Expected the enhancer to be a function. Instead, received: '\" + kindOf(enhancer) + \"'\");\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(2) : \"Expected the root reducer to be a function. Instead, received: '\" + kindOf(reducer) + \"'\");\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(3) : 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(4) : \"Expected the listener to be a function. Instead, received: '\" + kindOf(listener) + \"'\");\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(5) : 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(6) : 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(7) : \"Actions must be plain objects. Instead, the actual type was: '\" + kindOf(action) + \"'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.\");\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(8) : 'Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.');\n    }\n\n    if (isDispatching) {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(9) : 'Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(10) : \"Expected the nextReducer to be a function. Instead, received: '\" + kindOf(nextReducer));\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(11) : \"Expected the observer to be an object. Instead, received: '\" + kindOf(observer) + \"'\");\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n/**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nvar legacy_createStore = createStore;\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + kindOf(inputState) + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(12) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(13) : \"The slice reducer for key \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle '\" + ActionTypes.INIT + \"' or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var actionType = action && action.type;\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(14) : \"When called with an action of type \" + (actionType ? \"\\\"\" + String(actionType) + \"\\\"\" : '(unknown type)') + \", the slice reducer for key \\\"\" + _key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\");\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(16) : \"bindActionCreators expected an object or a function, but instead received: '\" + kindOf(actionCreators) + \"'. \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error(process.env.NODE_ENV === \"production\" ? formatProdErrorMessage(15) : 'Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread(_objectSpread({}, store), {}, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\nexport { ActionTypes as __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore, legacy_createStore };\n","/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */ export function invariant(condition, format, ...args) {\n    if (isProduction()) {\n        if (format === undefined) {\n            throw new Error('invariant requires an error message argument');\n        }\n    }\n    if (!condition) {\n        let error;\n        if (format === undefined) {\n            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n        } else {\n            let argIndex = 0;\n            error = new Error(format.replace(/%s/g, function() {\n                return args[argIndex++];\n            }));\n            error.name = 'Invariant Violation';\n        }\n        error.framesToPop = 1 // we don't care about invariant's own frame\n        ;\n        throw error;\n    }\n}\nfunction isProduction() {\n    return typeof process !== 'undefined' && process.env['NODE_ENV'] === 'production';\n}\n\n//# sourceMappingURL=index.js.map","// cheap lodash replacements\n/**\n * drop-in replacement for _.get\n * @param obj\n * @param path\n * @param defaultValue\n */ export function get(obj, path, defaultValue) {\n    return path.split('.').reduce((a, c)=>a && a[c] ? a[c] : defaultValue || null\n    , obj);\n}\n/**\n * drop-in replacement for _.without\n */ export function without(items, item) {\n    return items.filter((i)=>i !== item\n    );\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ export function isString(input) {\n    return typeof input === 'string';\n}\n/**\n * drop-in replacement for _.isString\n * @param input\n */ export function isObject(input) {\n    return typeof input === 'object';\n}\n/**\n * replacement for _.xor\n * @param itemsA\n * @param itemsB\n */ export function xor(itemsA, itemsB) {\n    const map = new Map();\n    const insertItem = (item)=>{\n        map.set(item, map.has(item) ? map.get(item) + 1 : 1);\n    };\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    map.forEach((count, key)=>{\n        if (count === 1) {\n            result.push(key);\n        }\n    });\n    return result;\n}\n/**\n * replacement for _.intersection\n * @param itemsA\n * @param itemsB\n */ export function intersection(itemsA, itemsB) {\n    return itemsA.filter((t)=>itemsB.indexOf(t) > -1\n    );\n}\n\n//# sourceMappingURL=js_utils.js.map","export const INIT_COORDS = 'dnd-core/INIT_COORDS';\nexport const BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';\nexport const PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';\nexport const HOVER = 'dnd-core/HOVER';\nexport const DROP = 'dnd-core/DROP';\nexport const END_DRAG = 'dnd-core/END_DRAG';\n\n//# sourceMappingURL=types.js.map","import { INIT_COORDS } from '../types.js';\nexport function setClientOffset(clientOffset, sourceClientOffset) {\n    return {\n        type: INIT_COORDS,\n        payload: {\n            sourceClientOffset: sourceClientOffset || null,\n            clientOffset: clientOffset || null\n        }\n    };\n}\n\n//# sourceMappingURL=setClientOffset.js.map","import { invariant } from '@react-dnd/invariant';\nimport { isObject } from '../../utils/js_utils.js';\nimport { setClientOffset } from './local/setClientOffset.js';\nimport { BEGIN_DRAG, INIT_COORDS } from './types.js';\nconst ResetCoordinatesAction = {\n    type: INIT_COORDS,\n    payload: {\n        clientOffset: null,\n        sourceClientOffset: null\n    }\n};\nexport function createBeginDrag(manager) {\n    return function beginDrag(sourceIds = [], options = {\n        publishSource: true\n    }) {\n        const { publishSource =true , clientOffset , getSourceClientOffset ,  } = options;\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        // Initialize the coordinates using the client offset\n        manager.dispatch(setClientOffset(clientOffset));\n        verifyInvariants(sourceIds, monitor, registry);\n        // Get the draggable source\n        const sourceId = getDraggableSource(sourceIds, monitor);\n        if (sourceId == null) {\n            manager.dispatch(ResetCoordinatesAction);\n            return;\n        }\n        // Get the source client offset\n        let sourceClientOffset = null;\n        if (clientOffset) {\n            if (!getSourceClientOffset) {\n                throw new Error('getSourceClientOffset must be defined');\n            }\n            verifyGetSourceClientOffsetIsFunction(getSourceClientOffset);\n            sourceClientOffset = getSourceClientOffset(sourceId);\n        }\n        // Initialize the full coordinates\n        manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));\n        const source = registry.getSource(sourceId);\n        const item = source.beginDrag(monitor, sourceId);\n        // If source.beginDrag returns null, this is an indicator to cancel the drag\n        if (item == null) {\n            return undefined;\n        }\n        verifyItemIsObject(item);\n        registry.pinSource(sourceId);\n        const itemType = registry.getSourceType(sourceId);\n        return {\n            type: BEGIN_DRAG,\n            payload: {\n                itemType,\n                item,\n                sourceId,\n                clientOffset: clientOffset || null,\n                sourceClientOffset: sourceClientOffset || null,\n                isSourcePublic: !!publishSource\n            }\n        };\n    };\n}\nfunction verifyInvariants(sourceIds, monitor, registry) {\n    invariant(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');\n    sourceIds.forEach(function(sourceId) {\n        invariant(registry.getSource(sourceId), 'Expected sourceIds to be registered.');\n    });\n}\nfunction verifyGetSourceClientOffsetIsFunction(getSourceClientOffset) {\n    invariant(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');\n}\nfunction verifyItemIsObject(item) {\n    invariant(isObject(item), 'Item must be an object.');\n}\nfunction getDraggableSource(sourceIds, monitor) {\n    let sourceId = null;\n    for(let i = sourceIds.length - 1; i >= 0; i--){\n        if (monitor.canDragSource(sourceIds[i])) {\n            sourceId = sourceIds[i];\n            break;\n        }\n    }\n    return sourceId;\n}\n\n//# sourceMappingURL=beginDrag.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { invariant } from '@react-dnd/invariant';\nimport { isObject } from '../../utils/js_utils.js';\nimport { DROP } from './types.js';\nexport function createDrop(manager) {\n    return function drop(options = {}) {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyInvariants(monitor);\n        const targetIds = getDroppableTargets(monitor);\n        // Multiple actions are dispatched here, which is why this doesn't return an action\n        targetIds.forEach((targetId, index)=>{\n            const dropResult = determineDropResult(targetId, index, registry, monitor);\n            const action = {\n                type: DROP,\n                payload: {\n                    dropResult: _objectSpread({}, options, dropResult)\n                }\n            };\n            manager.dispatch(action);\n        });\n    };\n}\nfunction verifyInvariants(monitor) {\n    invariant(monitor.isDragging(), 'Cannot call drop while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');\n}\nfunction determineDropResult(targetId, index, registry, monitor) {\n    const target = registry.getTarget(targetId);\n    let dropResult = target ? target.drop(monitor, targetId) : undefined;\n    verifyDropResultType(dropResult);\n    if (typeof dropResult === 'undefined') {\n        dropResult = index === 0 ? {} : monitor.getDropResult();\n    }\n    return dropResult;\n}\nfunction verifyDropResultType(dropResult) {\n    invariant(typeof dropResult === 'undefined' || isObject(dropResult), 'Drop result must either be an object or undefined.');\n}\nfunction getDroppableTargets(monitor) {\n    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);\n    targetIds.reverse();\n    return targetIds;\n}\n\n//# sourceMappingURL=drop.js.map","import { invariant } from '@react-dnd/invariant';\nimport { END_DRAG } from './types.js';\nexport function createEndDrag(manager) {\n    return function endDrag() {\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        verifyIsDragging(monitor);\n        const sourceId = monitor.getSourceId();\n        if (sourceId != null) {\n            const source = registry.getSource(sourceId, true);\n            source.endDrag(monitor, sourceId);\n            registry.unpinSource();\n        }\n        return {\n            type: END_DRAG\n        };\n    };\n}\nfunction verifyIsDragging(monitor) {\n    invariant(monitor.isDragging(), 'Cannot call endDrag while not dragging.');\n}\n\n//# sourceMappingURL=endDrag.js.map","export function matchesType(targetType, draggedItemType) {\n    if (draggedItemType === null) {\n        return targetType === null;\n    }\n    return Array.isArray(targetType) ? targetType.some((t)=>t === draggedItemType\n    ) : targetType === draggedItemType;\n}\n\n//# sourceMappingURL=matchesType.js.map","import { invariant } from '@react-dnd/invariant';\nimport { matchesType } from '../../utils/matchesType.js';\nimport { HOVER } from './types.js';\nexport function createHover(manager) {\n    return function hover(targetIdsArg, { clientOffset  } = {}) {\n        verifyTargetIdsIsArray(targetIdsArg);\n        const targetIds = targetIdsArg.slice(0);\n        const monitor = manager.getMonitor();\n        const registry = manager.getRegistry();\n        const draggedItemType = monitor.getItemType();\n        removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n        checkInvariants(targetIds, monitor, registry);\n        hoverAllTargets(targetIds, monitor, registry);\n        return {\n            type: HOVER,\n            payload: {\n                targetIds,\n                clientOffset: clientOffset || null\n            }\n        };\n    };\n}\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n    invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\nfunction checkInvariants(targetIds, monitor, registry) {\n    invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n    invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n    for(let i = 0; i < targetIds.length; i++){\n        const targetId = targetIds[i];\n        invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n        const target = registry.getTarget(targetId);\n        invariant(target, 'Expected targetIds to be registered.');\n    }\n}\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n    // Remove those targetIds that don't match the targetType.  This\n    // fixes shallow isOver which would only be non-shallow because of\n    // non-matching targets.\n    for(let i = targetIds.length - 1; i >= 0; i--){\n        const targetId = targetIds[i];\n        const targetType = registry.getTargetType(targetId);\n        if (!matchesType(targetType, draggedItemType)) {\n            targetIds.splice(i, 1);\n        }\n    }\n}\nfunction hoverAllTargets(targetIds, monitor, registry) {\n    // Finally call hover on all matching targets.\n    targetIds.forEach(function(targetId) {\n        const target = registry.getTarget(targetId);\n        target.hover(monitor, targetId);\n    });\n}\n\n//# sourceMappingURL=hover.js.map","import { PUBLISH_DRAG_SOURCE } from './types.js';\nexport function createPublishDragSource(manager) {\n    return function publishDragSource() {\n        const monitor = manager.getMonitor();\n        if (monitor.isDragging()) {\n            return {\n                type: PUBLISH_DRAG_SOURCE\n            };\n        }\n        return;\n    };\n}\n\n//# sourceMappingURL=publishDragSource.js.map","import { createBeginDrag } from './beginDrag.js';\nimport { createDrop } from './drop.js';\nimport { createEndDrag } from './endDrag.js';\nimport { createHover } from './hover.js';\nimport { createPublishDragSource } from './publishDragSource.js';\nexport * from './types.js';\nexport function createDragDropActions(manager) {\n    return {\n        beginDrag: createBeginDrag(manager),\n        publishDragSource: createPublishDragSource(manager),\n        hover: createHover(manager),\n        drop: createDrop(manager),\n        endDrag: createEndDrag(manager)\n    };\n}\n\n//# sourceMappingURL=index.js.map","import { createDragDropActions } from '../actions/dragDrop/index.js';\nexport class DragDropManagerImpl {\n    receiveBackend(backend) {\n        this.backend = backend;\n    }\n    getMonitor() {\n        return this.monitor;\n    }\n    getBackend() {\n        return this.backend;\n    }\n    getRegistry() {\n        return this.monitor.registry;\n    }\n    getActions() {\n        /* eslint-disable-next-line @typescript-eslint/no-this-alias */ const manager = this;\n        const { dispatch  } = this.store;\n        function bindActionCreator(actionCreator) {\n            return (...args)=>{\n                const action = actionCreator.apply(manager, args);\n                if (typeof action !== 'undefined') {\n                    dispatch(action);\n                }\n            };\n        }\n        const actions = createDragDropActions(this);\n        return Object.keys(actions).reduce((boundActions, key)=>{\n            const action = actions[key];\n            boundActions[key] = bindActionCreator(action);\n            return boundActions;\n        }, {});\n    }\n    dispatch(action) {\n        this.store.dispatch(action);\n    }\n    constructor(store, monitor){\n        this.isSetUp = false;\n        this.handleRefCountChange = ()=>{\n            const shouldSetUp = this.store.getState().refCount > 0;\n            if (this.backend) {\n                if (shouldSetUp && !this.isSetUp) {\n                    this.backend.setup();\n                    this.isSetUp = true;\n                } else if (!shouldSetUp && this.isSetUp) {\n                    this.backend.teardown();\n                    this.isSetUp = false;\n                }\n            }\n        };\n        this.store = store;\n        this.monitor = monitor;\n        store.subscribe(this.handleRefCountChange);\n    }\n}\n\n//# sourceMappingURL=DragDropManagerImpl.js.map","/**\n * Coordinate addition\n * @param a The first coordinate\n * @param b The second coordinate\n */ export function add(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y\n    };\n}\n/**\n * Coordinate subtraction\n * @param a The first coordinate\n * @param b The second coordinate\n */ export function subtract(a, b) {\n    return {\n        x: a.x - b.x,\n        y: a.y - b.y\n    };\n}\n/**\n * Returns the cartesian distance of the drag source component's position, based on its position\n * at the time when the current drag operation has started, and the movement difference.\n *\n * Returns null if no item is being dragged.\n *\n * @param state The offset state to compute from\n */ export function getSourceClientOffset(state) {\n    const { clientOffset , initialClientOffset , initialSourceClientOffset  } = state;\n    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {\n        return null;\n    }\n    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);\n}\n/**\n * Determines the x,y offset between the client offset and the initial client offset\n *\n * @param state The offset state to compute from\n */ export function getDifferenceFromInitialOffset(state) {\n    const { clientOffset , initialClientOffset  } = state;\n    if (!clientOffset || !initialClientOffset) {\n        return null;\n    }\n    return subtract(clientOffset, initialClientOffset);\n}\n\n//# sourceMappingURL=coords.js.map","import { intersection } from './js_utils.js';\nexport const NONE = [];\nexport const ALL = [];\nNONE.__IS_NONE__ = true;\nALL.__IS_ALL__ = true;\n/**\n * Determines if the given handler IDs are dirty or not.\n *\n * @param dirtyIds The set of dirty handler ids\n * @param handlerIds The set of handler ids to check\n */ export function areDirty(dirtyIds, handlerIds) {\n    if (dirtyIds === NONE) {\n        return false;\n    }\n    if (dirtyIds === ALL || typeof handlerIds === 'undefined') {\n        return true;\n    }\n    const commonIds = intersection(handlerIds, dirtyIds);\n    return commonIds.length > 0;\n}\n\n//# sourceMappingURL=dirtiness.js.map","import { invariant } from '@react-dnd/invariant';\nimport { getDifferenceFromInitialOffset, getSourceClientOffset } from '../utils/coords.js';\nimport { areDirty } from '../utils/dirtiness.js';\nimport { matchesType } from '../utils/matchesType.js';\nexport class DragDropMonitorImpl {\n    subscribeToStateChange(listener, options = {}) {\n        const { handlerIds  } = options;\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        invariant(typeof handlerIds === 'undefined' || Array.isArray(handlerIds), 'handlerIds, when specified, must be an array of strings.');\n        let prevStateId = this.store.getState().stateId;\n        const handleChange = ()=>{\n            const state = this.store.getState();\n            const currentStateId = state.stateId;\n            try {\n                const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);\n                if (!canSkipListener) {\n                    listener();\n                }\n            } finally{\n                prevStateId = currentStateId;\n            }\n        };\n        return this.store.subscribe(handleChange);\n    }\n    subscribeToOffsetChange(listener) {\n        invariant(typeof listener === 'function', 'listener must be a function.');\n        let previousState = this.store.getState().dragOffset;\n        const handleChange = ()=>{\n            const nextState = this.store.getState().dragOffset;\n            if (nextState === previousState) {\n                return;\n            }\n            previousState = nextState;\n            listener();\n        };\n        return this.store.subscribe(handleChange);\n    }\n    canDragSource(sourceId) {\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (this.isDragging()) {\n            return false;\n        }\n        return source.canDrag(this, sourceId);\n    }\n    canDropOnTarget(targetId) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const target = this.registry.getTarget(targetId);\n        invariant(target, `Expected to find a valid target. targetId=${targetId}`);\n        if (!this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);\n    }\n    isDragging() {\n        return Boolean(this.getItemType());\n    }\n    isDraggingSource(sourceId) {\n        // undefined on initial render\n        if (!sourceId) {\n            return false;\n        }\n        const source = this.registry.getSource(sourceId, true);\n        invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);\n        if (!this.isDragging() || !this.isSourcePublic()) {\n            return false;\n        }\n        const sourceType = this.registry.getSourceType(sourceId);\n        const draggedItemType = this.getItemType();\n        if (sourceType !== draggedItemType) {\n            return false;\n        }\n        return source.isDragging(this, sourceId);\n    }\n    isOverTarget(targetId, options = {\n        shallow: false\n    }) {\n        // undefined on initial render\n        if (!targetId) {\n            return false;\n        }\n        const { shallow  } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const targetType = this.registry.getTargetType(targetId);\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(targetType, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        } else {\n            return index > -1;\n        }\n    }\n    getItemType() {\n        return this.store.getState().dragOperation.itemType;\n    }\n    getItem() {\n        return this.store.getState().dragOperation.item;\n    }\n    getSourceId() {\n        return this.store.getState().dragOperation.sourceId;\n    }\n    getTargetIds() {\n        return this.store.getState().dragOperation.targetIds;\n    }\n    getDropResult() {\n        return this.store.getState().dragOperation.dropResult;\n    }\n    didDrop() {\n        return this.store.getState().dragOperation.didDrop;\n    }\n    isSourcePublic() {\n        return Boolean(this.store.getState().dragOperation.isSourcePublic);\n    }\n    getInitialClientOffset() {\n        return this.store.getState().dragOffset.initialClientOffset;\n    }\n    getInitialSourceClientOffset() {\n        return this.store.getState().dragOffset.initialSourceClientOffset;\n    }\n    getClientOffset() {\n        return this.store.getState().dragOffset.clientOffset;\n    }\n    getSourceClientOffset() {\n        return getSourceClientOffset(this.store.getState().dragOffset);\n    }\n    getDifferenceFromInitialOffset() {\n        return getDifferenceFromInitialOffset(this.store.getState().dragOffset);\n    }\n    constructor(store, registry){\n        this.store = store;\n        this.registry = registry;\n    }\n}\n\n//# sourceMappingURL=DragDropMonitorImpl.js.map","// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n/* globals self */ const scope = typeof global !== 'undefined' ? global : self;\nconst BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\nexport function makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        const timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        const intervalHandle = setInterval(handleTimer, 50);\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nexport function makeRequestCallFromMutationObserver(callback) {\n    let toggle = 1;\n    const observer = new BrowserMutationObserver(callback);\n    const node = document.createTextNode('');\n    observer.observe(node, {\n        characterData: true\n    });\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\nexport const makeRequestCall = typeof BrowserMutationObserver === 'function' ? // reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nmakeRequestCallFromMutationObserver : // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\nmakeRequestCallFromTimer;\n\n//# sourceMappingURL=makeRequestCall.js.map","/* eslint-disable no-restricted-globals, @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unused-vars, @typescript-eslint/no-non-null-assertion */ import { makeRequestCall, makeRequestCallFromTimer } from './makeRequestCall.js';\nexport class AsapQueue {\n    // Use the fastest means possible to execute a task in its own turn, with\n    // priority over other events including IO, animation, reflow, and redraw\n    // events in browsers.\n    //\n    // An exception thrown by a task will permanently interrupt the processing of\n    // subsequent tasks. The higher level `asap` function ensures that if an\n    // exception is thrown by a task, that the task queue will continue flushing as\n    // soon as possible, but if you use `rawAsap` directly, you are responsible to\n    // either ensure that no exceptions are thrown from your task, or to manually\n    // call `rawAsap.requestFlush` if an exception is thrown.\n    enqueueTask(task) {\n        const { queue: q , requestFlush  } = this;\n        if (!q.length) {\n            requestFlush();\n            this.flushing = true;\n        }\n        // Equivalent to push, but avoids a function call.\n        q[q.length] = task;\n    }\n    constructor(){\n        this.queue = [];\n        // We queue errors to ensure they are thrown in right order (FIFO).\n        // Array-as-queue is good enough here, since we are just dealing with exceptions.\n        this.pendingErrors = [];\n        // Once a flush has been requested, no further calls to `requestFlush` are\n        // necessary until the next `flush` completes.\n        // @ts-ignore\n        this.flushing = false;\n        // The position of the next task to execute in the task queue. This is\n        // preserved between calls to `flush` so that it can be resumed if\n        // a task throws an exception.\n        this.index = 0;\n        // If a task schedules additional tasks recursively, the task queue can grow\n        // unbounded. To prevent memory exhaustion, the task queue will periodically\n        // truncate already-completed tasks.\n        this.capacity = 1024;\n        // The flush function processes all tasks that have been scheduled with\n        // `rawAsap` unless and until one of those tasks throws an exception.\n        // If a task throws an exception, `flush` ensures that its state will remain\n        // consistent and will resume where it left off when called again.\n        // However, `flush` does not make any arrangements to be called again if an\n        // exception is thrown.\n        this.flush = ()=>{\n            const { queue: q  } = this;\n            while(this.index < q.length){\n                const currentIndex = this.index;\n                // Advance the index before calling the task. This ensures that we will\n                // begin flushing on the next task the task throws an error.\n                this.index++;\n                q[currentIndex].call();\n                // Prevent leaking memory for long chains of recursive calls to `asap`.\n                // If we call `asap` within tasks scheduled by `asap`, the queue will\n                // grow, but to avoid an O(n) walk for every task we execute, we don't\n                // shift tasks off the queue after they have been executed.\n                // Instead, we periodically shift 1024 tasks off the queue.\n                if (this.index > this.capacity) {\n                    // Manually shift all values starting at the index back to the\n                    // beginning of the queue.\n                    for(let scan = 0, newLength = q.length - this.index; scan < newLength; scan++){\n                        q[scan] = q[scan + this.index];\n                    }\n                    q.length -= this.index;\n                    this.index = 0;\n                }\n            }\n            q.length = 0;\n            this.index = 0;\n            this.flushing = false;\n        };\n        // In a web browser, exceptions are not fatal. However, to avoid\n        // slowing down the queue of pending tasks, we rethrow the error in a\n        // lower priority turn.\n        this.registerPendingError = (err)=>{\n            this.pendingErrors.push(err);\n            this.requestErrorThrow();\n        };\n        // `requestFlush` requests that the high priority event queue be flushed as\n        // soon as possible.\n        // This is useful to prevent an error thrown in a task from stalling the event\n        // queue if the exception handled by Node.jss\n        // `process.on(\"uncaughtException\")` or by a domain.\n        // `requestFlush` is implemented using a strategy based on data collected from\n        // every available SauceLabs Selenium web driver worker at time of writing.\n        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n        this.requestFlush = makeRequestCall(this.flush);\n        this.requestErrorThrow = makeRequestCallFromTimer(()=>{\n            // Throw first error\n            if (this.pendingErrors.length) {\n                throw this.pendingErrors.shift();\n            }\n        });\n    }\n} // The message channel technique was discovered by Malte Ubl and was the\n // original foundation for this library.\n // http://www.nonblocking.io/2011/06/windownexttick.html\n // Safari 6.0.5 (at least) intermittently fails to create message ports on a\n // page's first load. Thankfully, this version of Safari supports\n // MutationObservers, so we don't need to fall back in that case.\n // function makeRequestCallFromMessageChannel(callback) {\n //     var channel = new MessageChannel();\n //     channel.port1.onmessage = callback;\n //     return function requestCall() {\n //         channel.port2.postMessage(0);\n //     };\n // }\n // For reasons explained above, we are also unable to use `setImmediate`\n // under any circumstances.\n // Even if we were, there is another bug in Internet Explorer 10.\n // It is not sufficient to assign `setImmediate` to `requestFlush` because\n // `setImmediate` must be called *by name* and therefore must be wrapped in a\n // closure.\n // Never forget.\n // function makeRequestCallFromSetImmediate(callback) {\n //     return function requestCall() {\n //         setImmediate(callback);\n //     };\n // }\n // Safari 6.0 has a problem where timers will get lost while the user is\n // scrolling. This problem does not impact ASAP because Safari 6.0 supports\n // mutation observers, so that implementation is used instead.\n // However, if we ever elect to use timers in Safari, the prevalent work-around\n // is to add a scroll event listener that calls for a flush.\n // `setTimeout` does not call the passed callback if the delay is less than\n // approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n // even then.\n // This is for `asap.js` only.\n // Its name will be periodically randomized to break any code that depends on\n // // its existence.\n // rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer\n // ASAP was originally a nextTick shim included in Q. This was factored out\n // into this ASAP package. It was later adapted to RSVP which made further\n // amendments. These decisions, particularly to marginalize MessageChannel and\n // to capture the MutationObserver implementation in a closure, were integrated\n // back into ASAP proper.\n // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n//# sourceMappingURL=AsapQueue.js.map","// `call`, just like a function.\nexport class RawTask {\n    call() {\n        try {\n            this.task && this.task();\n        } catch (error) {\n            this.onError(error);\n        } finally{\n            this.task = null;\n            this.release(this);\n        }\n    }\n    constructor(onError, release){\n        this.onError = onError;\n        this.release = release;\n        this.task = null;\n    }\n}\n\n//# sourceMappingURL=RawTask.js.map","import { RawTask } from './RawTask.js';\nexport class TaskFactory {\n    create(task) {\n        const tasks = this.freeTasks;\n        const t1 = tasks.length ? tasks.pop() : new RawTask(this.onError, (t)=>tasks[tasks.length] = t\n        );\n        t1.task = task;\n        return t1;\n    }\n    constructor(onError){\n        this.onError = onError;\n        this.freeTasks = [];\n    }\n}\n\n//# sourceMappingURL=TaskFactory.js.map","import { AsapQueue } from './AsapQueue.js';\nimport { TaskFactory } from './TaskFactory.js';\nconst asapQueue = new AsapQueue();\nconst taskFactory = new TaskFactory(asapQueue.registerPendingError);\n/**\n * Calls a task as soon as possible after returning, in its own event, with priority\n * over other events like animation, reflow, and repaint. An error thrown from an\n * event will not interrupt, nor even substantially slow down the processing of\n * other events, but will be rather postponed to a lower priority event.\n * @param {{call}} task A callable object, typically a function that takes no\n * arguments.\n */ export function asap(task) {\n    asapQueue.enqueueTask(taskFactory.create(task));\n}\n\n//# sourceMappingURL=asap.js.map","export const ADD_SOURCE = 'dnd-core/ADD_SOURCE';\nexport const ADD_TARGET = 'dnd-core/ADD_TARGET';\nexport const REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';\nexport const REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';\nexport function addSource(sourceId) {\n    return {\n        type: ADD_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nexport function addTarget(targetId) {\n    return {\n        type: ADD_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\nexport function removeSource(sourceId) {\n    return {\n        type: REMOVE_SOURCE,\n        payload: {\n            sourceId\n        }\n    };\n}\nexport function removeTarget(targetId) {\n    return {\n        type: REMOVE_TARGET,\n        payload: {\n            targetId\n        }\n    };\n}\n\n//# sourceMappingURL=registry.js.map","import { invariant } from '@react-dnd/invariant';\nexport function validateSourceContract(source) {\n    invariant(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');\n    invariant(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');\n    invariant(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');\n}\nexport function validateTargetContract(target) {\n    invariant(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');\n    invariant(typeof target.hover === 'function', 'Expected hover to be a function.');\n    invariant(typeof target.drop === 'function', 'Expected beginDrag to be a function.');\n}\nexport function validateType(type, allowArray) {\n    if (allowArray && Array.isArray(type)) {\n        type.forEach((t)=>validateType(t, false)\n        );\n        return;\n    }\n    invariant(typeof type === 'string' || typeof type === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');\n}\n\n//# sourceMappingURL=contracts.js.map","export var HandlerRole;\n(function(HandlerRole) {\n    HandlerRole[\"SOURCE\"] = \"SOURCE\";\n    HandlerRole[\"TARGET\"] = \"TARGET\";\n})(HandlerRole || (HandlerRole = {}));\n\n//# sourceMappingURL=interfaces.js.map","let nextUniqueId = 0;\nexport function getNextUniqueId() {\n    return nextUniqueId++;\n}\n\n//# sourceMappingURL=getNextUniqueId.js.map","import { asap } from '@react-dnd/asap';\nimport { invariant } from '@react-dnd/invariant';\nimport { addSource, addTarget, removeSource, removeTarget } from '../actions/registry.js';\nimport { validateSourceContract, validateTargetContract, validateType } from '../contracts.js';\nimport { HandlerRole } from '../interfaces.js';\nimport { getNextUniqueId } from '../utils/getNextUniqueId.js';\nfunction getNextHandlerId(role) {\n    const id = getNextUniqueId().toString();\n    switch(role){\n        case HandlerRole.SOURCE:\n            return `S${id}`;\n        case HandlerRole.TARGET:\n            return `T${id}`;\n        default:\n            throw new Error(`Unknown Handler Role: ${role}`);\n    }\n}\nfunction parseRoleFromHandlerId(handlerId) {\n    switch(handlerId[0]){\n        case 'S':\n            return HandlerRole.SOURCE;\n        case 'T':\n            return HandlerRole.TARGET;\n        default:\n            throw new Error(`Cannot parse handler ID: ${handlerId}`);\n    }\n}\nfunction mapContainsValue(map, searchValue) {\n    const entries = map.entries();\n    let isDone = false;\n    do {\n        const { done , value: [, value] ,  } = entries.next();\n        if (value === searchValue) {\n            return true;\n        }\n        isDone = !!done;\n    }while (!isDone)\n    return false;\n}\nexport class HandlerRegistryImpl {\n    addSource(type, source) {\n        validateType(type);\n        validateSourceContract(source);\n        const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);\n        this.store.dispatch(addSource(sourceId));\n        return sourceId;\n    }\n    addTarget(type, target) {\n        validateType(type, true);\n        validateTargetContract(target);\n        const targetId = this.addHandler(HandlerRole.TARGET, type, target);\n        this.store.dispatch(addTarget(targetId));\n        return targetId;\n    }\n    containsHandler(handler) {\n        return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);\n    }\n    getSource(sourceId, includePinned = false) {\n        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n        const isPinned = includePinned && sourceId === this.pinnedSourceId;\n        const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);\n        return source;\n    }\n    getTarget(targetId) {\n        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n        return this.dropTargets.get(targetId);\n    }\n    getSourceType(sourceId) {\n        invariant(this.isSourceId(sourceId), 'Expected a valid source ID.');\n        return this.types.get(sourceId);\n    }\n    getTargetType(targetId) {\n        invariant(this.isTargetId(targetId), 'Expected a valid target ID.');\n        return this.types.get(targetId);\n    }\n    isSourceId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.SOURCE;\n    }\n    isTargetId(handlerId) {\n        const role = parseRoleFromHandlerId(handlerId);\n        return role === HandlerRole.TARGET;\n    }\n    removeSource(sourceId) {\n        invariant(this.getSource(sourceId), 'Expected an existing source.');\n        this.store.dispatch(removeSource(sourceId));\n        asap(()=>{\n            this.dragSources.delete(sourceId);\n            this.types.delete(sourceId);\n        });\n    }\n    removeTarget(targetId) {\n        invariant(this.getTarget(targetId), 'Expected an existing target.');\n        this.store.dispatch(removeTarget(targetId));\n        this.dropTargets.delete(targetId);\n        this.types.delete(targetId);\n    }\n    pinSource(sourceId) {\n        const source = this.getSource(sourceId);\n        invariant(source, 'Expected an existing source.');\n        this.pinnedSourceId = sourceId;\n        this.pinnedSource = source;\n    }\n    unpinSource() {\n        invariant(this.pinnedSource, 'No source is pinned at the time.');\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n    }\n    addHandler(role, type, handler) {\n        const id = getNextHandlerId(role);\n        this.types.set(id, type);\n        if (role === HandlerRole.SOURCE) {\n            this.dragSources.set(id, handler);\n        } else if (role === HandlerRole.TARGET) {\n            this.dropTargets.set(id, handler);\n        }\n        return id;\n    }\n    constructor(store){\n        this.types = new Map();\n        this.dragSources = new Map();\n        this.dropTargets = new Map();\n        this.pinnedSourceId = null;\n        this.pinnedSource = null;\n        this.store = store;\n    }\n}\n\n//# sourceMappingURL=HandlerRegistryImpl.js.map","export const strictEquality = (a, b)=>a === b\n;\n/**\n * Determine if two cartesian coordinate offsets are equal\n * @param offsetA\n * @param offsetB\n */ export function areCoordsEqual(offsetA, offsetB) {\n    if (!offsetA && !offsetB) {\n        return true;\n    } else if (!offsetA || !offsetB) {\n        return false;\n    } else {\n        return offsetA.x === offsetB.x && offsetA.y === offsetB.y;\n    }\n}\n/**\n * Determines if two arrays of items are equal\n * @param a The first array of items\n * @param b The second array of items\n */ export function areArraysEqual(a, b, isEqual = strictEquality) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; ++i){\n        if (!isEqual(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=equality.js.map","import { BEGIN_DRAG, DROP, END_DRAG, HOVER, PUBLISH_DRAG_SOURCE } from '../actions/dragDrop/index.js';\nimport { ADD_SOURCE, ADD_TARGET, REMOVE_SOURCE, REMOVE_TARGET } from '../actions/registry.js';\nimport { ALL, NONE } from '../utils/dirtiness.js';\nimport { areArraysEqual } from '../utils/equality.js';\nimport { xor } from '../utils/js_utils.js';\nexport function reduce(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n_state = NONE, action) {\n    switch(action.type){\n        case HOVER:\n            break;\n        case ADD_SOURCE:\n        case ADD_TARGET:\n        case REMOVE_TARGET:\n        case REMOVE_SOURCE:\n            return NONE;\n        case BEGIN_DRAG:\n        case PUBLISH_DRAG_SOURCE:\n        case END_DRAG:\n        case DROP:\n        default:\n            return ALL;\n    }\n    const { targetIds =[] , prevTargetIds =[]  } = action.payload;\n    const result = xor(targetIds, prevTargetIds);\n    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);\n    if (!didChange) {\n        return NONE;\n    }\n    // Check the target ids at the innermost position. If they are valid, add them\n    // to the result\n    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];\n    const innermostTargetId = targetIds[targetIds.length - 1];\n    if (prevInnermostTargetId !== innermostTargetId) {\n        if (prevInnermostTargetId) {\n            result.push(prevInnermostTargetId);\n        }\n        if (innermostTargetId) {\n            result.push(innermostTargetId);\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=dirtyHandlerIds.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { BEGIN_DRAG, DROP, END_DRAG, HOVER, INIT_COORDS } from '../actions/dragDrop/index.js';\nimport { areCoordsEqual } from '../utils/equality.js';\nconst initialState = {\n    initialSourceClientOffset: null,\n    initialClientOffset: null,\n    clientOffset: null\n};\nexport function reduce(state = initialState, action) {\n    const { payload  } = action;\n    switch(action.type){\n        case INIT_COORDS:\n        case BEGIN_DRAG:\n            return {\n                initialSourceClientOffset: payload.sourceClientOffset,\n                initialClientOffset: payload.clientOffset,\n                clientOffset: payload.clientOffset\n            };\n        case HOVER:\n            if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {\n                return state;\n            }\n            return _objectSpread({}, state, {\n                clientOffset: payload.clientOffset\n            });\n        case END_DRAG:\n        case DROP:\n            return initialState;\n        default:\n            return state;\n    }\n}\n\n//# sourceMappingURL=dragOffset.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { BEGIN_DRAG, DROP, END_DRAG, HOVER, PUBLISH_DRAG_SOURCE } from '../actions/dragDrop/index.js';\nimport { REMOVE_TARGET } from '../actions/registry.js';\nimport { without } from '../utils/js_utils.js';\nconst initialState = {\n    itemType: null,\n    item: null,\n    sourceId: null,\n    targetIds: [],\n    dropResult: null,\n    didDrop: false,\n    isSourcePublic: null\n};\nexport function reduce(state = initialState, action) {\n    const { payload  } = action;\n    switch(action.type){\n        case BEGIN_DRAG:\n            return _objectSpread({}, state, {\n                itemType: payload.itemType,\n                item: payload.item,\n                sourceId: payload.sourceId,\n                isSourcePublic: payload.isSourcePublic,\n                dropResult: null,\n                didDrop: false\n            });\n        case PUBLISH_DRAG_SOURCE:\n            return _objectSpread({}, state, {\n                isSourcePublic: true\n            });\n        case HOVER:\n            return _objectSpread({}, state, {\n                targetIds: payload.targetIds\n            });\n        case REMOVE_TARGET:\n            if (state.targetIds.indexOf(payload.targetId) === -1) {\n                return state;\n            }\n            return _objectSpread({}, state, {\n                targetIds: without(state.targetIds, payload.targetId)\n            });\n        case DROP:\n            return _objectSpread({}, state, {\n                dropResult: payload.dropResult,\n                didDrop: true,\n                targetIds: []\n            });\n        case END_DRAG:\n            return _objectSpread({}, state, {\n                itemType: null,\n                item: null,\n                sourceId: null,\n                dropResult: null,\n                didDrop: false,\n                isSourcePublic: null,\n                targetIds: []\n            });\n        default:\n            return state;\n    }\n}\n\n//# sourceMappingURL=dragOperation.js.map","import { ADD_SOURCE, ADD_TARGET, REMOVE_SOURCE, REMOVE_TARGET } from '../actions/registry.js';\nexport function reduce(state = 0, action) {\n    switch(action.type){\n        case ADD_SOURCE:\n        case ADD_TARGET:\n            return state + 1;\n        case REMOVE_SOURCE:\n        case REMOVE_TARGET:\n            return state - 1;\n        default:\n            return state;\n    }\n}\n\n//# sourceMappingURL=refCount.js.map","export function reduce(state = 0) {\n    return state + 1;\n}\n\n//# sourceMappingURL=stateId.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { get } from '../utils/js_utils.js';\nimport { reduce as dirtyHandlerIds } from './dirtyHandlerIds.js';\nimport { reduce as dragOffset } from './dragOffset.js';\nimport { reduce as dragOperation } from './dragOperation.js';\nimport { reduce as refCount } from './refCount.js';\nimport { reduce as stateId } from './stateId.js';\nexport function reduce(state = {}, action) {\n    return {\n        dirtyHandlerIds: dirtyHandlerIds(state.dirtyHandlerIds, {\n            type: action.type,\n            payload: _objectSpread({}, action.payload, {\n                prevTargetIds: get(state, 'dragOperation.targetIds', [])\n            })\n        }),\n        dragOffset: dragOffset(state.dragOffset, action),\n        refCount: refCount(state.refCount, action),\n        dragOperation: dragOperation(state.dragOperation, action),\n        stateId: stateId(state.stateId)\n    };\n}\n\n//# sourceMappingURL=index.js.map","import { createStore } from 'redux';\nimport { DragDropManagerImpl } from './classes/DragDropManagerImpl.js';\nimport { DragDropMonitorImpl } from './classes/DragDropMonitorImpl.js';\nimport { HandlerRegistryImpl } from './classes/HandlerRegistryImpl.js';\nimport { reduce } from './reducers/index.js';\nexport function createDragDropManager(backendFactory, globalContext = undefined, backendOptions = {}, debugMode = false) {\n    const store = makeStoreInstance(debugMode);\n    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));\n    const manager = new DragDropManagerImpl(store, monitor);\n    const backend = backendFactory(manager, globalContext, backendOptions);\n    manager.receiveBackend(backend);\n    return manager;\n}\nfunction makeStoreInstance(debugMode) {\n    // TODO: if we ever make a react-native version of this,\n    // we'll need to consider how to pull off dev-tooling\n    const reduxDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__;\n    return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({\n        name: 'dnd-core',\n        instanceId: 'dnd-core'\n    }));\n}\n\n//# sourceMappingURL=createDragDropManager.js.map","function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createDragDropManager } from 'dnd-core';\nimport { memo, useEffect } from 'react';\nimport { DndContext } from './DndContext.js';\nlet refCount = 0;\nconst INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__');\nvar DndProvider = /*#__PURE__*/ memo(function DndProvider(_param) {\n    var { children  } = _param, props = _objectWithoutProperties(_param, [\n        \"children\"\n    ]);\n    const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n    ;\n    /**\n\t\t * If the global context was used to store the DND context\n\t\t * then where theres no more references to it we should\n\t\t * clean it up to avoid memory leaks\n\t\t */ useEffect(()=>{\n        if (isGlobalInstance) {\n            const context = getGlobalContext();\n            ++refCount;\n            return ()=>{\n                if (--refCount === 0) {\n                    context[INSTANCE_SYM] = null;\n                }\n            };\n        }\n        return;\n    }, []);\n    return /*#__PURE__*/ _jsx(DndContext.Provider, {\n        value: manager,\n        children: children\n    });\n});\n/**\n * A React component that provides the React-DnD context\n */ export { DndProvider,  };\nfunction getDndContextValue(props) {\n    if ('manager' in props) {\n        const manager = {\n            dragDropManager: props.manager\n        };\n        return [\n            manager,\n            false\n        ];\n    }\n    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n    const isGlobalInstance = !props.context;\n    return [\n        manager,\n        isGlobalInstance\n    ];\n}\nfunction createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {\n    const ctx = context;\n    if (!ctx[INSTANCE_SYM]) {\n        ctx[INSTANCE_SYM] = {\n            dragDropManager: createDragDropManager(backend, context, options, debugMode)\n        };\n    }\n    return ctx[INSTANCE_SYM];\n}\nfunction getGlobalContext() {\n    return typeof global !== 'undefined' ? global : window;\n}\n\n//# sourceMappingURL=DndProvider.js.map","import { useEffect, useLayoutEffect } from 'react';\n// suppress the useLayoutEffect warning on server side.\nexport const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\n//# sourceMappingURL=useIsomorphicLayoutEffect.js.map","import equal from 'fast-deep-equal';\nimport { useCallback, useState } from 'react';\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect.js';\n/**\n *\n * @param monitor The monitor to collect state from\n * @param collect The collecting function\n * @param onUpdate A method to invoke when updates occur\n */ export function useCollector(monitor, collect, onUpdate) {\n    const [collected, setCollected] = useState(()=>collect(monitor)\n    );\n    const updateCollected = useCallback(()=>{\n        const nextValue = collect(monitor);\n        // This needs to be a deep-equality check because some monitor-collected values\n        // include XYCoord objects that may be equivalent, but do not have instance equality.\n        if (!equal(collected, nextValue)) {\n            setCollected(nextValue);\n            if (onUpdate) {\n                onUpdate();\n            }\n        }\n    }, [\n        collected,\n        monitor,\n        onUpdate\n    ]);\n    // update the collected properties after react renders.\n    // Note that the \"Dustbin Stress Test\" fails if this is not\n    // done when the component updates\n    useIsomorphicLayoutEffect(updateCollected);\n    return [\n        collected,\n        updateCollected\n    ];\n}\n\n//# sourceMappingURL=useCollector.js.map","import { useCollector } from './useCollector.js';\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect.js';\nexport function useMonitorOutput(monitor, collect, onCollect) {\n    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);\n    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {\n        const handlerId = monitor.getHandlerId();\n        if (handlerId == null) {\n            return;\n        }\n        return monitor.subscribeToStateChange(updateCollected, {\n            handlerIds: [\n                handlerId\n            ]\n        });\n    }, [\n        monitor,\n        updateCollected\n    ]);\n    return collected;\n}\n\n//# sourceMappingURL=useMonitorOutput.js.map","import { useMonitorOutput } from './useMonitorOutput.js';\nexport function useCollectedProps(collector, monitor, connector) {\n    return useMonitorOutput(monitor, collector || (()=>({})\n    ), ()=>connector.reconnect()\n    );\n}\n\n//# sourceMappingURL=useCollectedProps.js.map","import { useMemo } from 'react';\nexport function useOptionalFactory(arg, deps) {\n    const memoDeps = [\n        ...deps || []\n    ];\n    if (deps == null && typeof arg !== 'function') {\n        memoDeps.push(arg);\n    }\n    return useMemo(()=>{\n        return typeof arg === 'function' ? arg() : arg;\n    }, memoDeps);\n}\n\n//# sourceMappingURL=useOptionalFactory.js.map","import { useMemo } from 'react';\nexport function useConnectDragSource(connector) {\n    return useMemo(()=>connector.hooks.dragSource()\n    , [\n        connector\n    ]);\n}\nexport function useConnectDragPreview(connector) {\n    return useMemo(()=>connector.hooks.dragPreview()\n    , [\n        connector\n    ]);\n}\n\n//# sourceMappingURL=connectors.js.map","import { invariant } from '@react-dnd/invariant';\nlet isCallingCanDrag = false;\nlet isCallingIsDragging = false;\nexport class DragSourceMonitorImpl {\n    receiveHandlerId(sourceId) {\n        this.sourceId = sourceId;\n    }\n    getHandlerId() {\n        return this.sourceId;\n    }\n    canDrag() {\n        invariant(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');\n        try {\n            isCallingCanDrag = true;\n            return this.internalMonitor.canDragSource(this.sourceId);\n        } finally{\n            isCallingCanDrag = false;\n        }\n    }\n    isDragging() {\n        if (!this.sourceId) {\n            return false;\n        }\n        invariant(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor');\n        try {\n            isCallingIsDragging = true;\n            return this.internalMonitor.isDraggingSource(this.sourceId);\n        } finally{\n            isCallingIsDragging = false;\n        }\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    isDraggingSource(sourceId) {\n        return this.internalMonitor.isDraggingSource(sourceId);\n    }\n    isOverTarget(targetId, options) {\n        return this.internalMonitor.isOverTarget(targetId, options);\n    }\n    getTargetIds() {\n        return this.internalMonitor.getTargetIds();\n    }\n    isSourcePublic() {\n        return this.internalMonitor.isSourcePublic();\n    }\n    getSourceId() {\n        return this.internalMonitor.getSourceId();\n    }\n    subscribeToOffsetChange(listener) {\n        return this.internalMonitor.subscribeToOffsetChange(listener);\n    }\n    canDragSource(sourceId) {\n        return this.internalMonitor.canDragSource(sourceId);\n    }\n    canDropOnTarget(targetId) {\n        return this.internalMonitor.canDropOnTarget(targetId);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.sourceId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\n\n//# sourceMappingURL=DragSourceMonitorImpl.js.map","import { invariant } from '@react-dnd/invariant';\nlet isCallingCanDrop = false;\nexport class DropTargetMonitorImpl {\n    receiveHandlerId(targetId) {\n        this.targetId = targetId;\n    }\n    getHandlerId() {\n        return this.targetId;\n    }\n    subscribeToStateChange(listener, options) {\n        return this.internalMonitor.subscribeToStateChange(listener, options);\n    }\n    canDrop() {\n        // Cut out early if the target id has not been set. This should prevent errors\n        // where the user has an older version of dnd-core like in\n        // https://github.com/react-dnd/react-dnd/issues/1310\n        if (!this.targetId) {\n            return false;\n        }\n        invariant(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor');\n        try {\n            isCallingCanDrop = true;\n            return this.internalMonitor.canDropOnTarget(this.targetId);\n        } finally{\n            isCallingCanDrop = false;\n        }\n    }\n    isOver(options) {\n        if (!this.targetId) {\n            return false;\n        }\n        return this.internalMonitor.isOverTarget(this.targetId, options);\n    }\n    getItemType() {\n        return this.internalMonitor.getItemType();\n    }\n    getItem() {\n        return this.internalMonitor.getItem();\n    }\n    getDropResult() {\n        return this.internalMonitor.getDropResult();\n    }\n    didDrop() {\n        return this.internalMonitor.didDrop();\n    }\n    getInitialClientOffset() {\n        return this.internalMonitor.getInitialClientOffset();\n    }\n    getInitialSourceClientOffset() {\n        return this.internalMonitor.getInitialSourceClientOffset();\n    }\n    getSourceClientOffset() {\n        return this.internalMonitor.getSourceClientOffset();\n    }\n    getClientOffset() {\n        return this.internalMonitor.getClientOffset();\n    }\n    getDifferenceFromInitialOffset() {\n        return this.internalMonitor.getDifferenceFromInitialOffset();\n    }\n    constructor(manager){\n        this.targetId = null;\n        this.internalMonitor = manager.getMonitor();\n    }\n}\n\n//# sourceMappingURL=DropTargetMonitorImpl.js.map","export function registerTarget(type, target, manager) {\n    const registry = manager.getRegistry();\n    const targetId = registry.addTarget(type, target);\n    return [\n        targetId,\n        ()=>registry.removeTarget(targetId)\n    ];\n}\nexport function registerSource(type, source, manager) {\n    const registry = manager.getRegistry();\n    const sourceId = registry.addSource(type, source);\n    return [\n        sourceId,\n        ()=>registry.removeSource(sourceId)\n    ];\n}\n\n//# sourceMappingURL=registration.js.map","export function shallowEqual(objA, objB, compare, compareContext) {\n    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;\n    if (compareResult !== void 0) {\n        return !!compareResult;\n    }\n    if (objA === objB) {\n        return true;\n    }\n    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);\n    // Test for A's keys different from B.\n    for(let idx = 0; idx < keysA.length; idx++){\n        const key = keysA[idx];\n        if (!bHasOwnProperty(key)) {\n            return false;\n        }\n        const valueA = objA[key];\n        const valueB = objB[key];\n        compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;\n        if (compareResult === false || compareResult === void 0 && valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//# sourceMappingURL=index.js.map","export function isRef(obj) {\n    return(// eslint-disable-next-line no-prototype-builtins\n    obj !== null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, 'current'));\n}\n\n//# sourceMappingURL=isRef.js.map","import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\nfunction throwIfCompositeComponentElement(element) {\n    // Custom components can no longer be wrapped directly in React DnD 2.0\n    // so that we don't need to depend on findDOMNode() from react-dom.\n    if (typeof element.type === 'string') {\n        return;\n    }\n    const displayName = element.type.displayName || element.type.name || 'the component';\n    throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n    return (elementOrNode = null, options = null)=>{\n        // When passed a node, call the hook straight away.\n        if (!isValidElement(elementOrNode)) {\n            const node = elementOrNode;\n            hook(node, options);\n            // return the node so it can be chained (e.g. when within callback refs\n            // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n            return node;\n        }\n        // If passed a ReactElement, clone it and attach this function as a ref.\n        // This helps us achieve a neat API where user doesn't even know that refs\n        // are being used under the hood.\n        const element = elementOrNode;\n        throwIfCompositeComponentElement(element);\n        // When no options are passed, use the hook directly\n        const ref = options ? (node)=>hook(node, options)\n         : hook;\n        return cloneWithRef(element, ref);\n    };\n}\nexport function wrapConnectorHooks(hooks) {\n    const wrappedHooks = {};\n    Object.keys(hooks).forEach((key)=>{\n        const hook = hooks[key];\n        // ref objects should be passed straight through without wrapping\n        if (key.endsWith('Ref')) {\n            wrappedHooks[key] = hooks[key];\n        } else {\n            const wrappedHook = wrapHookToRecognizeElement(hook);\n            wrappedHooks[key] = ()=>wrappedHook\n            ;\n        }\n    });\n    return wrappedHooks;\n}\nfunction setRef(ref, node) {\n    if (typeof ref === 'function') {\n        ref(node);\n    } else {\n        ref.current = node;\n    }\n}\nfunction cloneWithRef(element, newRef) {\n    const previousRef = element.ref;\n    invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n    if (!previousRef) {\n        // When there is no ref on the element, use the new ref directly\n        return cloneElement(element, {\n            ref: newRef\n        });\n    } else {\n        return cloneElement(element, {\n            ref: (node)=>{\n                setRef(previousRef, node);\n                setRef(newRef, node);\n            }\n        });\n    }\n}\n\n//# sourceMappingURL=wrapConnectorHooks.js.map","import { shallowEqual } from '@react-dnd/shallowequal';\nimport { isRef } from './isRef.js';\nimport { wrapConnectorHooks } from './wrapConnectorHooks.js';\nexport class SourceConnector {\n    receiveHandlerId(newHandlerId) {\n        if (this.handlerId === newHandlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get connectTarget() {\n        return this.dragSource;\n    }\n    get dragSourceOptions() {\n        return this.dragSourceOptionsInternal;\n    }\n    set dragSourceOptions(options) {\n        this.dragSourceOptionsInternal = options;\n    }\n    get dragPreviewOptions() {\n        return this.dragPreviewOptionsInternal;\n    }\n    set dragPreviewOptions(options) {\n        this.dragPreviewOptionsInternal = options;\n    }\n    reconnect() {\n        const didChange = this.reconnectDragSource();\n        this.reconnectDragPreview(didChange);\n    }\n    reconnectDragSource() {\n        const dragSource = this.dragSource;\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();\n        if (didChange) {\n            this.disconnectDragSource();\n        }\n        if (!this.handlerId) {\n            return didChange;\n        }\n        if (!dragSource) {\n            this.lastConnectedDragSource = dragSource;\n            return didChange;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragSource = dragSource;\n            this.lastConnectedDragSourceOptions = this.dragSourceOptions;\n            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);\n        }\n        return didChange;\n    }\n    reconnectDragPreview(forceDidChange = false) {\n        const dragPreview = this.dragPreview;\n        // if nothing has changed then don't resubscribe\n        const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();\n        if (didChange) {\n            this.disconnectDragPreview();\n        }\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dragPreview) {\n            this.lastConnectedDragPreview = dragPreview;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDragPreview = dragPreview;\n            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;\n            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);\n        }\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didConnectedDragSourceChange() {\n        return this.lastConnectedDragSource !== this.dragSource;\n    }\n    didConnectedDragPreviewChange() {\n        return this.lastConnectedDragPreview !== this.dragPreview;\n    }\n    didDragSourceOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);\n    }\n    didDragPreviewOptionsChange() {\n        return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);\n    }\n    disconnectDragSource() {\n        if (this.dragSourceUnsubscribe) {\n            this.dragSourceUnsubscribe();\n            this.dragSourceUnsubscribe = undefined;\n        }\n    }\n    disconnectDragPreview() {\n        if (this.dragPreviewUnsubscribe) {\n            this.dragPreviewUnsubscribe();\n            this.dragPreviewUnsubscribe = undefined;\n            this.dragPreviewNode = null;\n            this.dragPreviewRef = null;\n        }\n    }\n    get dragSource() {\n        return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;\n    }\n    get dragPreview() {\n        return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;\n    }\n    clearDragSource() {\n        this.dragSourceNode = null;\n        this.dragSourceRef = null;\n    }\n    clearDragPreview() {\n        this.dragPreviewNode = null;\n        this.dragPreviewRef = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dragSource: (node, options)=>{\n                this.clearDragSource();\n                this.dragSourceOptions = options || null;\n                if (isRef(node)) {\n                    this.dragSourceRef = node;\n                } else {\n                    this.dragSourceNode = node;\n                }\n                this.reconnectDragSource();\n            },\n            dragPreview: (node, options)=>{\n                this.clearDragPreview();\n                this.dragPreviewOptions = options || null;\n                if (isRef(node)) {\n                    this.dragPreviewRef = node;\n                } else {\n                    this.dragPreviewNode = node;\n                }\n                this.reconnectDragPreview();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dragSourceRef = null;\n        this.dragSourceOptionsInternal = null;\n        // The drag preview may either be attached via ref or connect function\n        this.dragPreviewRef = null;\n        this.dragPreviewOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDragSource = null;\n        this.lastConnectedDragSourceOptions = null;\n        this.lastConnectedDragPreview = null;\n        this.lastConnectedDragPreviewOptions = null;\n        this.backend = backend;\n    }\n}\n\n//# sourceMappingURL=SourceConnector.js.map","import { shallowEqual } from '@react-dnd/shallowequal';\nimport { isRef } from './isRef.js';\nimport { wrapConnectorHooks } from './wrapConnectorHooks.js';\nexport class TargetConnector {\n    get connectTarget() {\n        return this.dropTarget;\n    }\n    reconnect() {\n        // if nothing has changed then don't resubscribe\n        const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();\n        if (didChange) {\n            this.disconnectDropTarget();\n        }\n        const dropTarget = this.dropTarget;\n        if (!this.handlerId) {\n            return;\n        }\n        if (!dropTarget) {\n            this.lastConnectedDropTarget = dropTarget;\n            return;\n        }\n        if (didChange) {\n            this.lastConnectedHandlerId = this.handlerId;\n            this.lastConnectedDropTarget = dropTarget;\n            this.lastConnectedDropTargetOptions = this.dropTargetOptions;\n            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);\n        }\n    }\n    receiveHandlerId(newHandlerId) {\n        if (newHandlerId === this.handlerId) {\n            return;\n        }\n        this.handlerId = newHandlerId;\n        this.reconnect();\n    }\n    get dropTargetOptions() {\n        return this.dropTargetOptionsInternal;\n    }\n    set dropTargetOptions(options) {\n        this.dropTargetOptionsInternal = options;\n    }\n    didHandlerIdChange() {\n        return this.lastConnectedHandlerId !== this.handlerId;\n    }\n    didDropTargetChange() {\n        return this.lastConnectedDropTarget !== this.dropTarget;\n    }\n    didOptionsChange() {\n        return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);\n    }\n    disconnectDropTarget() {\n        if (this.unsubscribeDropTarget) {\n            this.unsubscribeDropTarget();\n            this.unsubscribeDropTarget = undefined;\n        }\n    }\n    get dropTarget() {\n        return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;\n    }\n    clearDropTarget() {\n        this.dropTargetRef = null;\n        this.dropTargetNode = null;\n    }\n    constructor(backend){\n        this.hooks = wrapConnectorHooks({\n            dropTarget: (node, options)=>{\n                this.clearDropTarget();\n                this.dropTargetOptions = options;\n                if (isRef(node)) {\n                    this.dropTargetRef = node;\n                } else {\n                    this.dropTargetNode = node;\n                }\n                this.reconnect();\n            }\n        });\n        this.handlerId = null;\n        // The drop target may either be attached via ref or connect function\n        this.dropTargetRef = null;\n        this.dropTargetOptionsInternal = null;\n        this.lastConnectedHandlerId = null;\n        this.lastConnectedDropTarget = null;\n        this.lastConnectedDropTargetOptions = null;\n        this.backend = backend;\n    }\n}\n\n//# sourceMappingURL=TargetConnector.js.map","import { invariant } from '@react-dnd/invariant';\nimport { useContext } from 'react';\nimport { DndContext } from '../core/index.js';\n/**\n * A hook to retrieve the DragDropManager from Context\n */ export function useDragDropManager() {\n    const { dragDropManager  } = useContext(DndContext);\n    invariant(dragDropManager != null, 'Expected drag drop context');\n    return dragDropManager;\n}\n\n//# sourceMappingURL=useDragDropManager.js.map","import { useMemo } from 'react';\nimport { SourceConnector } from '../../internals/index.js';\nimport { useDragDropManager } from '../useDragDropManager.js';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js';\nexport function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {\n    const manager = useDragDropManager();\n    const connector = useMemo(()=>new SourceConnector(manager.getBackend())\n    , [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragSourceOptions = dragSourceOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragSource()\n        ;\n    }, [\n        connector,\n        dragSourceOptions\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dragPreviewOptions = dragPreviewOptions || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDragPreview()\n        ;\n    }, [\n        connector,\n        dragPreviewOptions\n    ]);\n    return connector;\n}\n\n//# sourceMappingURL=useDragSourceConnector.js.map","import { useMemo } from 'react';\nimport { DragSourceMonitorImpl } from '../../internals/index.js';\nimport { useDragDropManager } from '../useDragDropManager.js';\nexport function useDragSourceMonitor() {\n    const manager = useDragDropManager();\n    return useMemo(()=>new DragSourceMonitorImpl(manager)\n    , [\n        manager\n    ]);\n}\n\n//# sourceMappingURL=useDragSourceMonitor.js.map","export class DragSourceImpl {\n    beginDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        let result = null;\n        if (typeof spec.item === 'object') {\n            result = spec.item;\n        } else if (typeof spec.item === 'function') {\n            result = spec.item(monitor);\n        } else {\n            result = {};\n        }\n        return result !== null && result !== void 0 ? result : null;\n    }\n    canDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (typeof spec.canDrag === 'boolean') {\n            return spec.canDrag;\n        } else if (typeof spec.canDrag === 'function') {\n            return spec.canDrag(monitor);\n        } else {\n            return true;\n        }\n    }\n    isDragging(globalMonitor, target) {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const { isDragging  } = spec;\n        return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();\n    }\n    endDrag() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        const connector = this.connector;\n        const { end  } = spec;\n        if (end) {\n            end(monitor.getItem(), monitor);\n        }\n        connector.reconnect();\n    }\n    constructor(spec, monitor, connector){\n        this.spec = spec;\n        this.monitor = monitor;\n        this.connector = connector;\n    }\n}\n\n//# sourceMappingURL=DragSourceImpl.js.map","import { useEffect, useMemo } from 'react';\nimport { DragSourceImpl } from './DragSourceImpl.js';\nexport function useDragSource(spec, monitor, connector) {\n    const handler = useMemo(()=>new DragSourceImpl(spec, monitor, connector)\n    , [\n        monitor,\n        connector\n    ]);\n    useEffect(()=>{\n        handler.spec = spec;\n    }, [\n        spec\n    ]);\n    return handler;\n}\n\n//# sourceMappingURL=useDragSource.js.map","import { invariant } from '@react-dnd/invariant';\nimport { useMemo } from 'react';\nexport function useDragType(spec) {\n    return useMemo(()=>{\n        const result = spec.type;\n        invariant(result != null, 'spec.type must be defined');\n        return result;\n    }, [\n        spec\n    ]);\n}\n\n//# sourceMappingURL=useDragType.js.map","import { registerSource } from '../../internals/index.js';\nimport { useDragDropManager } from '../useDragDropManager.js';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js';\nimport { useDragSource } from './useDragSource.js';\nimport { useDragType } from './useDragType.js';\nexport function useRegisteredDragSource(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const handler = useDragSource(spec, monitor, connector);\n    const itemType = useDragType(spec);\n    useIsomorphicLayoutEffect(function registerDragSource() {\n        if (itemType != null) {\n            const [handlerId, unregister] = registerSource(itemType, handler, manager);\n            monitor.receiveHandlerId(handlerId);\n            connector.receiveHandlerId(handlerId);\n            return unregister;\n        }\n        return;\n    }, [\n        manager,\n        monitor,\n        connector,\n        handler,\n        itemType\n    ]);\n}\n\n//# sourceMappingURL=useRegisteredDragSource.js.map","import { invariant } from '@react-dnd/invariant';\nimport { useCollectedProps } from '../useCollectedProps.js';\nimport { useOptionalFactory } from '../useOptionalFactory.js';\nimport { useConnectDragPreview, useConnectDragSource } from './connectors.js';\nimport { useDragSourceConnector } from './useDragSourceConnector.js';\nimport { useDragSourceMonitor } from './useDragSourceMonitor.js';\nimport { useRegisteredDragSource } from './useRegisteredDragSource.js';\n/**\n * useDragSource hook\n * @param sourceSpec The drag source specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ export function useDrag(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);\n    const monitor = useDragSourceMonitor();\n    const connector = useDragSourceConnector(spec.options, spec.previewOptions);\n    useRegisteredDragSource(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDragSource(connector),\n        useConnectDragPreview(connector), \n    ];\n}\n\n//# sourceMappingURL=useDrag.js.map","import { useMemo } from 'react';\nexport function useConnectDropTarget(connector) {\n    return useMemo(()=>connector.hooks.dropTarget()\n    , [\n        connector\n    ]);\n}\n\n//# sourceMappingURL=connectors.js.map","import { useMemo } from 'react';\nimport { TargetConnector } from '../../internals/index.js';\nimport { useDragDropManager } from '../useDragDropManager.js';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js';\nexport function useDropTargetConnector(options) {\n    const manager = useDragDropManager();\n    const connector = useMemo(()=>new TargetConnector(manager.getBackend())\n    , [\n        manager\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        connector.dropTargetOptions = options || null;\n        connector.reconnect();\n        return ()=>connector.disconnectDropTarget()\n        ;\n    }, [\n        options\n    ]);\n    return connector;\n}\n\n//# sourceMappingURL=useDropTargetConnector.js.map","import { useMemo } from 'react';\nimport { DropTargetMonitorImpl } from '../../internals/index.js';\nimport { useDragDropManager } from '../useDragDropManager.js';\nexport function useDropTargetMonitor() {\n    const manager = useDragDropManager();\n    return useMemo(()=>new DropTargetMonitorImpl(manager)\n    , [\n        manager\n    ]);\n}\n\n//# sourceMappingURL=useDropTargetMonitor.js.map","import { invariant } from '@react-dnd/invariant';\nimport { useMemo } from 'react';\n/**\n * Internal utility hook to get an array-version of spec.accept.\n * The main utility here is that we aren't creating a new array on every render if a non-array spec.accept is passed in.\n * @param spec\n */ export function useAccept(spec) {\n    const { accept  } = spec;\n    return useMemo(()=>{\n        invariant(spec.accept != null, 'accept must be defined');\n        return Array.isArray(accept) ? accept : [\n            accept\n        ];\n    }, [\n        accept\n    ]);\n}\n\n//# sourceMappingURL=useAccept.js.map","export class DropTargetImpl {\n    canDrop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;\n    }\n    hover() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.hover) {\n            spec.hover(monitor.getItem(), monitor);\n        }\n    }\n    drop() {\n        const spec = this.spec;\n        const monitor = this.monitor;\n        if (spec.drop) {\n            return spec.drop(monitor.getItem(), monitor);\n        }\n        return;\n    }\n    constructor(spec, monitor){\n        this.spec = spec;\n        this.monitor = monitor;\n    }\n}\n\n//# sourceMappingURL=DropTargetImpl.js.map","import { useEffect, useMemo } from 'react';\nimport { DropTargetImpl } from './DropTargetImpl.js';\nexport function useDropTarget(spec, monitor) {\n    const dropTarget = useMemo(()=>new DropTargetImpl(spec, monitor)\n    , [\n        monitor\n    ]);\n    useEffect(()=>{\n        dropTarget.spec = spec;\n    }, [\n        spec\n    ]);\n    return dropTarget;\n}\n\n//# sourceMappingURL=useDropTarget.js.map","import { registerTarget } from '../../internals/index.js';\nimport { useDragDropManager } from '../useDragDropManager.js';\nimport { useIsomorphicLayoutEffect } from '../useIsomorphicLayoutEffect.js';\nimport { useAccept } from './useAccept.js';\nimport { useDropTarget } from './useDropTarget.js';\nexport function useRegisteredDropTarget(spec, monitor, connector) {\n    const manager = useDragDropManager();\n    const dropTarget = useDropTarget(spec, monitor);\n    const accept = useAccept(spec);\n    useIsomorphicLayoutEffect(function registerDropTarget() {\n        const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);\n        monitor.receiveHandlerId(handlerId);\n        connector.receiveHandlerId(handlerId);\n        return unregister;\n    }, [\n        manager,\n        monitor,\n        dropTarget,\n        connector,\n        accept.map((a)=>a.toString()\n        ).join('|'), \n    ]);\n}\n\n//# sourceMappingURL=useRegisteredDropTarget.js.map","import { useCollectedProps } from '../useCollectedProps.js';\nimport { useOptionalFactory } from '../useOptionalFactory.js';\nimport { useConnectDropTarget } from './connectors.js';\nimport { useDropTargetConnector } from './useDropTargetConnector.js';\nimport { useDropTargetMonitor } from './useDropTargetMonitor.js';\nimport { useRegisteredDropTarget } from './useRegisteredDropTarget.js';\n/**\n * useDropTarget Hook\n * @param spec The drop target specification (object or function, function preferred)\n * @param deps The memoization deps array to use when evaluating spec changes\n */ export function useDrop(specArg, deps) {\n    const spec = useOptionalFactory(specArg, deps);\n    const monitor = useDropTargetMonitor();\n    const connector = useDropTargetConnector(spec.options);\n    useRegisteredDropTarget(spec, monitor, connector);\n    return [\n        useCollectedProps(spec.collect, monitor, connector),\n        useConnectDropTarget(connector), \n    ];\n}\n\n//# sourceMappingURL=useDrop.js.map","// cheap lodash replacements\nexport function memoize(fn) {\n    let result = null;\n    const memoized = ()=>{\n        if (result == null) {\n            result = fn();\n        }\n        return result;\n    };\n    return memoized;\n}\n/**\n * drop-in replacement for _.without\n */ export function without(items, item) {\n    return items.filter((i)=>i !== item\n    );\n}\nexport function union(itemsA, itemsB) {\n    const set = new Set();\n    const insertItem = (item)=>set.add(item)\n    ;\n    itemsA.forEach(insertItem);\n    itemsB.forEach(insertItem);\n    const result = [];\n    set.forEach((key)=>result.push(key)\n    );\n    return result;\n}\n\n//# sourceMappingURL=js_utils.js.map","import { union, without } from './utils/js_utils.js';\nexport class EnterLeaveCounter {\n    enter(enteringNode) {\n        const previousLength = this.entered.length;\n        const isNodeEntered = (node)=>this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode))\n        ;\n        this.entered = union(this.entered.filter(isNodeEntered), [\n            enteringNode\n        ]);\n        return previousLength === 0 && this.entered.length > 0;\n    }\n    leave(leavingNode) {\n        const previousLength = this.entered.length;\n        this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);\n        return previousLength > 0 && this.entered.length === 0;\n    }\n    reset() {\n        this.entered = [];\n    }\n    constructor(isNodeInDocument){\n        this.entered = [];\n        this.isNodeInDocument = isNodeInDocument;\n    }\n}\n\n//# sourceMappingURL=EnterLeaveCounter.js.map","export class NativeDragSource {\n    initializeExposedProperties() {\n        Object.keys(this.config.exposeProperties).forEach((property)=>{\n            Object.defineProperty(this.item, property, {\n                configurable: true,\n                enumerable: true,\n                get () {\n                    // eslint-disable-next-line no-console\n                    console.warn(`Browser doesn't allow reading \"${property}\" until the drop event.`);\n                    return null;\n                }\n            });\n        });\n    }\n    loadDataTransfer(dataTransfer) {\n        if (dataTransfer) {\n            const newProperties = {};\n            Object.keys(this.config.exposeProperties).forEach((property)=>{\n                const propertyFn = this.config.exposeProperties[property];\n                if (propertyFn != null) {\n                    newProperties[property] = {\n                        value: propertyFn(dataTransfer, this.config.matchesTypes),\n                        configurable: true,\n                        enumerable: true\n                    };\n                }\n            });\n            Object.defineProperties(this.item, newProperties);\n        }\n    }\n    canDrag() {\n        return true;\n    }\n    beginDrag() {\n        return this.item;\n    }\n    isDragging(monitor, handle) {\n        return handle === monitor.getSourceId();\n    }\n    endDrag() {\n    // empty\n    }\n    constructor(config){\n        this.config = config;\n        this.item = {};\n        this.initializeExposedProperties();\n    }\n}\n\n//# sourceMappingURL=NativeDragSource.js.map","export const FILE = '__NATIVE_FILE__';\nexport const URL = '__NATIVE_URL__';\nexport const TEXT = '__NATIVE_TEXT__';\nexport const HTML = '__NATIVE_HTML__';\n\n//# sourceMappingURL=NativeTypes.js.map","export function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {\n    const result = typesToTry.reduce((resultSoFar, typeToTry)=>resultSoFar || dataTransfer.getData(typeToTry)\n    , '');\n    return result != null ? result : defaultValue;\n}\n\n//# sourceMappingURL=getDataFromDataTransfer.js.map","import * as NativeTypes from '../NativeTypes.js';\nimport { getDataFromDataTransfer } from './getDataFromDataTransfer.js';\nexport const nativeTypesConfig = {\n    [NativeTypes.FILE]: {\n        exposeProperties: {\n            files: (dataTransfer)=>Array.prototype.slice.call(dataTransfer.files)\n            ,\n            items: (dataTransfer)=>dataTransfer.items\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Files'\n        ]\n    },\n    [NativeTypes.HTML]: {\n        exposeProperties: {\n            html: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Html',\n            'text/html'\n        ]\n    },\n    [NativeTypes.URL]: {\n        exposeProperties: {\n            urls: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\\n')\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Url',\n            'text/uri-list'\n        ]\n    },\n    [NativeTypes.TEXT]: {\n        exposeProperties: {\n            text: (dataTransfer, matchesTypes)=>getDataFromDataTransfer(dataTransfer, matchesTypes, '')\n            ,\n            dataTransfer: (dataTransfer)=>dataTransfer\n        },\n        matchesTypes: [\n            'Text',\n            'text/plain'\n        ]\n    }\n};\n\n//# sourceMappingURL=nativeTypesConfig.js.map","import { NativeDragSource } from './NativeDragSource.js';\nimport { nativeTypesConfig } from './nativeTypesConfig.js';\nexport function createNativeDragSource(type, dataTransfer) {\n    const config = nativeTypesConfig[type];\n    if (!config) {\n        throw new Error(`native type ${type} has no configuration`);\n    }\n    const result = new NativeDragSource(config);\n    result.loadDataTransfer(dataTransfer);\n    return result;\n}\nexport function matchNativeItemType(dataTransfer) {\n    if (!dataTransfer) {\n        return null;\n    }\n    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);\n    return Object.keys(nativeTypesConfig).filter((nativeItemType)=>{\n        const typeConfig = nativeTypesConfig[nativeItemType];\n        if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {\n            return false;\n        }\n        return typeConfig.matchesTypes.some((t)=>dataTransferTypes.indexOf(t) > -1\n        );\n    })[0] || null;\n}\n\n//# sourceMappingURL=index.js.map","import { memoize } from './utils/js_utils.js';\nexport const isFirefox = memoize(()=>/firefox/i.test(navigator.userAgent)\n);\nexport const isSafari = memoize(()=>Boolean(window.safari)\n);\n\n//# sourceMappingURL=BrowserDetector.js.map","export class MonotonicInterpolant {\n    interpolate(x) {\n        const { xs , ys , c1s , c2s , c3s  } = this;\n        // The rightmost point in the dataset should give an exact result\n        let i = xs.length - 1;\n        if (x === xs[i]) {\n            return ys[i];\n        }\n        // Search for the interval x is in, returning the corresponding y if x is one of the original xs\n        let low = 0;\n        let high = c3s.length - 1;\n        let mid;\n        while(low <= high){\n            mid = Math.floor(0.5 * (low + high));\n            const xHere = xs[mid];\n            if (xHere < x) {\n                low = mid + 1;\n            } else if (xHere > x) {\n                high = mid - 1;\n            } else {\n                return ys[mid];\n            }\n        }\n        i = Math.max(0, high);\n        // Interpolate\n        const diff = x - xs[i];\n        const diffSq = diff * diff;\n        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;\n    }\n    constructor(xs, ys){\n        const { length  } = xs;\n        // Rearrange xs and ys so that xs is sorted\n        const indexes = [];\n        for(let i = 0; i < length; i++){\n            indexes.push(i);\n        }\n        indexes.sort((a, b)=>xs[a] < xs[b] ? -1 : 1\n        );\n        // Get consecutive differences and slopes\n        const dys = [];\n        const dxs = [];\n        const ms = [];\n        let dx;\n        let dy;\n        for(let i1 = 0; i1 < length - 1; i1++){\n            dx = xs[i1 + 1] - xs[i1];\n            dy = ys[i1 + 1] - ys[i1];\n            dxs.push(dx);\n            dys.push(dy);\n            ms.push(dy / dx);\n        }\n        // Get degree-1 coefficients\n        const c1s = [\n            ms[0]\n        ];\n        for(let i2 = 0; i2 < dxs.length - 1; i2++){\n            const m2 = ms[i2];\n            const mNext = ms[i2 + 1];\n            if (m2 * mNext <= 0) {\n                c1s.push(0);\n            } else {\n                dx = dxs[i2];\n                const dxNext = dxs[i2 + 1];\n                const common = dx + dxNext;\n                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));\n            }\n        }\n        c1s.push(ms[ms.length - 1]);\n        // Get degree-2 and degree-3 coefficients\n        const c2s = [];\n        const c3s = [];\n        let m;\n        for(let i3 = 0; i3 < c1s.length - 1; i3++){\n            m = ms[i3];\n            const c1 = c1s[i3];\n            const invDx = 1 / dxs[i3];\n            const common = c1 + c1s[i3 + 1] - m - m;\n            c2s.push((m - c1 - common) * invDx);\n            c3s.push(common * invDx * invDx);\n        }\n        this.xs = xs;\n        this.ys = ys;\n        this.c1s = c1s;\n        this.c2s = c2s;\n        this.c3s = c3s;\n    }\n}\n\n//# sourceMappingURL=MonotonicInterpolant.js.map","import { isFirefox, isSafari } from './BrowserDetector.js';\nimport { MonotonicInterpolant } from './MonotonicInterpolant.js';\nconst ELEMENT_NODE = 1;\nexport function getNodeClientOffset(node) {\n    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n    if (!el) {\n        return null;\n    }\n    const { top , left  } = el.getBoundingClientRect();\n    return {\n        x: left,\n        y: top\n    };\n}\nexport function getEventClientOffset(e) {\n    return {\n        x: e.clientX,\n        y: e.clientY\n    };\n}\nfunction isImageNode(node) {\n    var ref;\n    return node.nodeName === 'IMG' && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n    // Work around @2x coordinate discrepancies in browsers\n    if (isSafari() && isImage) {\n        dragPreviewHeight /= window.devicePixelRatio;\n        dragPreviewWidth /= window.devicePixelRatio;\n    }\n    return {\n        dragPreviewWidth,\n        dragPreviewHeight\n    };\n}\nexport function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n    // The browsers will use the image intrinsic size under different conditions.\n    // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n    const isImage = isImageNode(dragPreview);\n    const dragPreviewNode = isImage ? sourceNode : dragPreview;\n    const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n    const offsetFromDragPreview = {\n        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n    };\n    const { offsetWidth: sourceWidth , offsetHeight: sourceHeight  } = sourceNode;\n    const { anchorX , anchorY  } = anchorPoint;\n    const { dragPreviewWidth , dragPreviewHeight  } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);\n    const calculateYOffset = ()=>{\n        const interpolantY = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the top\n            offsetFromDragPreview.y,\n            // Align at the center\n            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,\n            // Dock to the bottom\n            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight, \n        ]);\n        let y = interpolantY.interpolate(anchorY);\n        // Work around Safari 8 positioning bug\n        if (isSafari() && isImage) {\n            // We'll have to wait for @3x to see if this is entirely correct\n            y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n        }\n        return y;\n    };\n    const calculateXOffset = ()=>{\n        // Interpolate coordinates depending on anchor point\n        // If you know a simpler way to do this, let me know\n        const interpolantX = new MonotonicInterpolant([\n            0,\n            0.5,\n            1\n        ], [\n            // Dock to the left\n            offsetFromDragPreview.x,\n            // Align at the center\n            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,\n            // Dock to the right\n            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth, \n        ]);\n        return interpolantX.interpolate(anchorX);\n    };\n    // Force offsets if specified in the options.\n    const { offsetX , offsetY  } = offsetPoint;\n    const isManualOffsetX = offsetX === 0 || offsetX;\n    const isManualOffsetY = offsetY === 0 || offsetY;\n    return {\n        x: isManualOffsetX ? offsetX : calculateXOffset(),\n        y: isManualOffsetY ? offsetY : calculateYOffset()\n    };\n}\n\n//# sourceMappingURL=OffsetUtils.js.map","export class OptionsReader {\n    get window() {\n        if (this.globalContext) {\n            return this.globalContext;\n        } else if (typeof window !== 'undefined') {\n            return window;\n        }\n        return undefined;\n    }\n    get document() {\n        var ref;\n        if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {\n            return this.globalContext.document;\n        } else if (this.window) {\n            return this.window.document;\n        } else {\n            return undefined;\n        }\n    }\n    get rootElement() {\n        var ref;\n        return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;\n    }\n    constructor(globalContext, options){\n        this.ownerDocument = null;\n        this.globalContext = globalContext;\n        this.optionsArgs = options;\n    }\n}\n\n//# sourceMappingURL=OptionsReader.js.map","function _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nimport { EnterLeaveCounter } from './EnterLeaveCounter.js';\nimport { createNativeDragSource, matchNativeItemType } from './NativeDragSources/index.js';\nimport * as NativeTypes from './NativeTypes.js';\nimport { getDragPreviewOffset, getEventClientOffset, getNodeClientOffset } from './OffsetUtils.js';\nimport { OptionsReader } from './OptionsReader.js';\nexport class HTML5BackendImpl {\n    /**\n\t * Generate profiling statistics for the HTML5Backend.\n\t */ profile() {\n        var ref, ref1;\n        return {\n            sourcePreviewNodes: this.sourcePreviewNodes.size,\n            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,\n            sourceNodeOptions: this.sourceNodeOptions.size,\n            sourceNodes: this.sourceNodes.size,\n            dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,\n            dropTargetIds: this.dropTargetIds.length,\n            dragEnterTargetIds: this.dragEnterTargetIds.length,\n            dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0\n        };\n    }\n    // public for test\n    get window() {\n        return this.options.window;\n    }\n    get document() {\n        return this.options.document;\n    }\n    /**\n\t * Get the root element to use for event subscriptions\n\t */ get rootElement() {\n        return this.options.rootElement;\n    }\n    setup() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        if (root.__isReactDndBackendSetUp) {\n            throw new Error('Cannot have two HTML5 backends at the same time.');\n        }\n        root.__isReactDndBackendSetUp = true;\n        this.addEventListeners(root);\n    }\n    teardown() {\n        const root = this.rootElement;\n        if (root === undefined) {\n            return;\n        }\n        root.__isReactDndBackendSetUp = false;\n        this.removeEventListeners(this.rootElement);\n        this.clearCurrentDragSourceNode();\n        if (this.asyncEndDragFrameId) {\n            var ref;\n            (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);\n        }\n    }\n    connectDragPreview(sourceId, node, options) {\n        this.sourcePreviewNodeOptions.set(sourceId, options);\n        this.sourcePreviewNodes.set(sourceId, node);\n        return ()=>{\n            this.sourcePreviewNodes.delete(sourceId);\n            this.sourcePreviewNodeOptions.delete(sourceId);\n        };\n    }\n    connectDragSource(sourceId, node, options) {\n        this.sourceNodes.set(sourceId, node);\n        this.sourceNodeOptions.set(sourceId, options);\n        const handleDragStart = (e)=>this.handleDragStart(e, sourceId)\n        ;\n        const handleSelectStart = (e)=>this.handleSelectStart(e)\n        ;\n        node.setAttribute('draggable', 'true');\n        node.addEventListener('dragstart', handleDragStart);\n        node.addEventListener('selectstart', handleSelectStart);\n        return ()=>{\n            this.sourceNodes.delete(sourceId);\n            this.sourceNodeOptions.delete(sourceId);\n            node.removeEventListener('dragstart', handleDragStart);\n            node.removeEventListener('selectstart', handleSelectStart);\n            node.setAttribute('draggable', 'false');\n        };\n    }\n    connectDropTarget(targetId, node) {\n        const handleDragEnter = (e)=>this.handleDragEnter(e, targetId)\n        ;\n        const handleDragOver = (e)=>this.handleDragOver(e, targetId)\n        ;\n        const handleDrop = (e)=>this.handleDrop(e, targetId)\n        ;\n        node.addEventListener('dragenter', handleDragEnter);\n        node.addEventListener('dragover', handleDragOver);\n        node.addEventListener('drop', handleDrop);\n        return ()=>{\n            node.removeEventListener('dragenter', handleDragEnter);\n            node.removeEventListener('dragover', handleDragOver);\n            node.removeEventListener('drop', handleDrop);\n        };\n    }\n    addEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.addEventListener) {\n            return;\n        }\n        target.addEventListener('dragstart', this.handleTopDragStart);\n        target.addEventListener('dragstart', this.handleTopDragStartCapture, true);\n        target.addEventListener('dragend', this.handleTopDragEndCapture, true);\n        target.addEventListener('dragenter', this.handleTopDragEnter);\n        target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);\n        target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n        target.addEventListener('dragover', this.handleTopDragOver);\n        target.addEventListener('dragover', this.handleTopDragOverCapture, true);\n        target.addEventListener('drop', this.handleTopDrop);\n        target.addEventListener('drop', this.handleTopDropCapture, true);\n    }\n    removeEventListeners(target) {\n        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813\n        if (!target.removeEventListener) {\n            return;\n        }\n        target.removeEventListener('dragstart', this.handleTopDragStart);\n        target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);\n        target.removeEventListener('dragend', this.handleTopDragEndCapture, true);\n        target.removeEventListener('dragenter', this.handleTopDragEnter);\n        target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);\n        target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);\n        target.removeEventListener('dragover', this.handleTopDragOver);\n        target.removeEventListener('dragover', this.handleTopDragOverCapture, true);\n        target.removeEventListener('drop', this.handleTopDrop);\n        target.removeEventListener('drop', this.handleTopDropCapture, true);\n    }\n    getCurrentSourceNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);\n        return _objectSpread({\n            dropEffect: this.altKeyPressed ? 'copy' : 'move'\n        }, sourceNodeOptions || {});\n    }\n    getCurrentDropEffect() {\n        if (this.isDraggingNativeItem()) {\n            // It makes more sense to default to 'copy' for native resources\n            return 'copy';\n        }\n        return this.getCurrentSourceNodeOptions().dropEffect;\n    }\n    getCurrentSourcePreviewNodeOptions() {\n        const sourceId = this.monitor.getSourceId();\n        const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);\n        return _objectSpread({\n            anchorX: 0.5,\n            anchorY: 0.5,\n            captureDraggingState: false\n        }, sourcePreviewNodeOptions || {});\n    }\n    isDraggingNativeItem() {\n        const itemType = this.monitor.getItemType();\n        return Object.keys(NativeTypes).some((key)=>NativeTypes[key] === itemType\n        );\n    }\n    beginDragNativeItem(type, dataTransfer) {\n        this.clearCurrentDragSourceNode();\n        this.currentNativeSource = createNativeDragSource(type, dataTransfer);\n        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);\n        this.actions.beginDrag([\n            this.currentNativeHandle\n        ]);\n    }\n    setCurrentDragSourceNode(node) {\n        this.clearCurrentDragSourceNode();\n        this.currentDragSourceNode = node;\n        // A timeout of > 0 is necessary to resolve Firefox issue referenced\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        const MOUSE_MOVE_TIMEOUT = 1000;\n        // Receiving a mouse event in the middle of a dragging operation\n        // means it has ended and the drag source node disappeared from DOM,\n        // so the browser didn't dispatch the dragend event.\n        //\n        // We need to wait before we start listening for mousemove events.\n        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event\n        // immediately in some browsers.\n        //\n        // See:\n        //   * https://github.com/react-dnd/react-dnd/pull/928\n        //   * https://github.com/react-dnd/react-dnd/issues/869\n        //\n        this.mouseMoveTimeoutTimer = setTimeout(()=>{\n            var ref;\n            return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n        }, MOUSE_MOVE_TIMEOUT);\n    }\n    clearCurrentDragSourceNode() {\n        if (this.currentDragSourceNode) {\n            this.currentDragSourceNode = null;\n            if (this.rootElement) {\n                var ref;\n                (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || undefined);\n                this.rootElement.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);\n            }\n            this.mouseMoveTimeoutTimer = null;\n            return true;\n        }\n        return false;\n    }\n    handleDragStart(e, sourceId) {\n        if (e.defaultPrevented) {\n            return;\n        }\n        if (!this.dragStartSourceIds) {\n            this.dragStartSourceIds = [];\n        }\n        this.dragStartSourceIds.unshift(sourceId);\n    }\n    handleDragEnter(_e, targetId) {\n        this.dragEnterTargetIds.unshift(targetId);\n    }\n    handleDragOver(_e, targetId) {\n        if (this.dragOverTargetIds === null) {\n            this.dragOverTargetIds = [];\n        }\n        this.dragOverTargetIds.unshift(targetId);\n    }\n    handleDrop(_e, targetId) {\n        this.dropTargetIds.unshift(targetId);\n    }\n    constructor(manager, globalContext, options){\n        this.sourcePreviewNodes = new Map();\n        this.sourcePreviewNodeOptions = new Map();\n        this.sourceNodes = new Map();\n        this.sourceNodeOptions = new Map();\n        this.dragStartSourceIds = null;\n        this.dropTargetIds = [];\n        this.dragEnterTargetIds = [];\n        this.currentNativeSource = null;\n        this.currentNativeHandle = null;\n        this.currentDragSourceNode = null;\n        this.altKeyPressed = false;\n        this.mouseMoveTimeoutTimer = null;\n        this.asyncEndDragFrameId = null;\n        this.dragOverTargetIds = null;\n        this.lastClientOffset = null;\n        this.hoverRafId = null;\n        this.getSourceClientOffset = (sourceId)=>{\n            const source = this.sourceNodes.get(sourceId);\n            return source && getNodeClientOffset(source) || null;\n        };\n        this.endDragNativeItem = ()=>{\n            if (!this.isDraggingNativeItem()) {\n                return;\n            }\n            this.actions.endDrag();\n            if (this.currentNativeHandle) {\n                this.registry.removeSource(this.currentNativeHandle);\n            }\n            this.currentNativeHandle = null;\n            this.currentNativeSource = null;\n        };\n        this.isNodeInDocument = (node)=>{\n            // Check the node either in the main document or in the current context\n            return Boolean(node && this.document && this.document.body && this.document.body.contains(node));\n        };\n        this.endDragIfSourceWasRemovedFromDOM = ()=>{\n            const node = this.currentDragSourceNode;\n            if (node == null || this.isNodeInDocument(node)) {\n                return;\n            }\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.scheduleHover = (dragOverTargetIds)=>{\n            if (this.hoverRafId === null && typeof requestAnimationFrame !== 'undefined') {\n                this.hoverRafId = requestAnimationFrame(()=>{\n                    if (this.monitor.isDragging()) {\n                        this.actions.hover(dragOverTargetIds || [], {\n                            clientOffset: this.lastClientOffset\n                        });\n                    }\n                    this.hoverRafId = null;\n                });\n            }\n        };\n        this.cancelHover = ()=>{\n            if (this.hoverRafId !== null && typeof cancelAnimationFrame !== 'undefined') {\n                cancelAnimationFrame(this.hoverRafId);\n                this.hoverRafId = null;\n            }\n        };\n        this.handleTopDragStartCapture = ()=>{\n            this.clearCurrentDragSourceNode();\n            this.dragStartSourceIds = [];\n        };\n        this.handleTopDragStart = (e)=>{\n            if (e.defaultPrevented) {\n                return;\n            }\n            const { dragStartSourceIds  } = this;\n            this.dragStartSourceIds = null;\n            const clientOffset = getEventClientOffset(e);\n            // Avoid crashing if we missed a drop event or our previous drag died\n            if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n                this.cancelHover();\n            }\n            // Don't publish the source just yet (see why below)\n            this.actions.beginDrag(dragStartSourceIds || [], {\n                publishSource: false,\n                getSourceClientOffset: this.getSourceClientOffset,\n                clientOffset\n            });\n            const { dataTransfer  } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (this.monitor.isDragging()) {\n                if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {\n                    // Use custom drag image if user specifies it.\n                    // If child drag source refuses drag but parent agrees,\n                    // use parent's node as drag image. Neither works in IE though.\n                    const sourceId = this.monitor.getSourceId();\n                    const sourceNode = this.sourceNodes.get(sourceId);\n                    const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;\n                    if (dragPreview) {\n                        const { anchorX , anchorY , offsetX , offsetY  } = this.getCurrentSourcePreviewNodeOptions();\n                        const anchorPoint = {\n                            anchorX,\n                            anchorY\n                        };\n                        const offsetPoint = {\n                            offsetX,\n                            offsetY\n                        };\n                        const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);\n                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);\n                    }\n                }\n                try {\n                    // Firefox won't drag without setting data\n                    dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData('application/json', {});\n                } catch (err) {\n                // IE doesn't support MIME types in setData\n                }\n                // Store drag source node so we can check whether\n                // it is removed from DOM and trigger endDrag manually.\n                this.setCurrentDragSourceNode(e.target);\n                // Now we are ready to publish the drag source.. or are we not?\n                const { captureDraggingState  } = this.getCurrentSourcePreviewNodeOptions();\n                if (!captureDraggingState) {\n                    // Usually we want to publish it in the next tick so that browser\n                    // is able to screenshot the current (not yet dragging) state.\n                    //\n                    // It also neatly avoids a situation where render() returns null\n                    // in the same tick for the source element, and browser freaks out.\n                    setTimeout(()=>this.actions.publishDragSource()\n                    , 0);\n                } else {\n                    // In some cases the user may want to override this behavior, e.g.\n                    // to work around IE not supporting custom drag previews.\n                    //\n                    // When using a custom drag layer, the only way to prevent\n                    // the default drag preview from drawing in IE is to screenshot\n                    // the dragging state in which the node itself has zero opacity\n                    // and height. In this case, though, returning null from render()\n                    // will abruptly end the dragging, which is not obvious.\n                    //\n                    // This is the reason such behavior is strictly opt-in.\n                    this.actions.publishDragSource();\n                }\n            } else if (nativeType) {\n                // A native item (such as URL) dragged from inside the document\n                this.beginDragNativeItem(nativeType);\n            } else if (dataTransfer && !dataTransfer.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {\n                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.\n                // Just let it drag. It's a native type (URL or text) and will be picked up in\n                // dragenter handler.\n                return;\n            } else {\n                // If by this time no drag source reacted, tell browser not to drag.\n                e.preventDefault();\n            }\n        };\n        this.handleTopDragEndCapture = ()=>{\n            if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {\n                // Firefox can dispatch this event in an infinite loop\n                // if dragend handler does something like showing an alert.\n                // Only proceed if we have not handled it already.\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleTopDragEnterCapture = (e)=>{\n            this.dragEnterTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n            const isFirstEnter = this.enterLeaveCounter.enter(e.target);\n            if (!isFirstEnter || this.monitor.isDragging()) {\n                return;\n            }\n            const { dataTransfer  } = e;\n            const nativeType = matchNativeItemType(dataTransfer);\n            if (nativeType) {\n                // A native item (such as file or URL) dragged from outside the document\n                this.beginDragNativeItem(nativeType, dataTransfer);\n            }\n        };\n        this.handleTopDragEnter = (e)=>{\n            const { dragEnterTargetIds  } = this;\n            this.dragEnterTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            // If the target changes position as the result of `dragenter`, `dragover` might still\n            // get dispatched despite target being no longer there. The easy solution is to check\n            // whether there actually is a target before firing `hover`.\n            if (dragEnterTargetIds.length > 0) {\n                this.actions.hover(dragEnterTargetIds, {\n                    clientOffset: getEventClientOffset(e)\n                });\n            }\n            const canDrop = dragEnterTargetIds.some((targetId)=>this.monitor.canDropOnTarget(targetId)\n            );\n            if (canDrop) {\n                // IE requires this to fire dragover events\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            }\n        };\n        this.handleTopDragOverCapture = (e)=>{\n            this.dragOverTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            }\n        };\n        this.handleTopDragOver = (e)=>{\n            const { dragOverTargetIds  } = this;\n            this.dragOverTargetIds = [];\n            if (!this.monitor.isDragging()) {\n                // This is probably a native item type we don't understand.\n                // Prevent default \"drop and blow away the whole document\" action.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = 'none';\n                }\n                return;\n            }\n            this.altKeyPressed = e.altKey;\n            this.lastClientOffset = getEventClientOffset(e);\n            this.scheduleHover(dragOverTargetIds);\n            const canDrop = (dragOverTargetIds || []).some((targetId)=>this.monitor.canDropOnTarget(targetId)\n            );\n            if (canDrop) {\n                // Show user-specified drop effect.\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = this.getCurrentDropEffect();\n                }\n            } else if (this.isDraggingNativeItem()) {\n                // Don't show a nice cursor but still prevent default\n                // \"drop and blow away the whole document\" action.\n                e.preventDefault();\n            } else {\n                e.preventDefault();\n                if (e.dataTransfer) {\n                    e.dataTransfer.dropEffect = 'none';\n                }\n            }\n        };\n        this.handleTopDragLeaveCapture = (e)=>{\n            if (this.isDraggingNativeItem()) {\n                e.preventDefault();\n            }\n            const isLastLeave = this.enterLeaveCounter.leave(e.target);\n            if (!isLastLeave) {\n                return;\n            }\n            if (this.isDraggingNativeItem()) {\n                setTimeout(()=>this.endDragNativeItem()\n                , 0);\n            }\n            this.cancelHover();\n        };\n        this.handleTopDropCapture = (e)=>{\n            this.dropTargetIds = [];\n            if (this.isDraggingNativeItem()) {\n                var ref;\n                e.preventDefault();\n                (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e.dataTransfer);\n            } else if (matchNativeItemType(e.dataTransfer)) {\n                // Dragging some elements, like <a> and <img> may still behave like a native drag event,\n                // even if the current drag event matches a user-defined type.\n                // Stop the default behavior when we're not expecting a native item to be dropped.\n                e.preventDefault();\n            }\n            this.enterLeaveCounter.reset();\n        };\n        this.handleTopDrop = (e)=>{\n            const { dropTargetIds  } = this;\n            this.dropTargetIds = [];\n            this.actions.hover(dropTargetIds, {\n                clientOffset: getEventClientOffset(e)\n            });\n            this.actions.drop({\n                dropEffect: this.getCurrentDropEffect()\n            });\n            if (this.isDraggingNativeItem()) {\n                this.endDragNativeItem();\n            } else if (this.monitor.isDragging()) {\n                this.actions.endDrag();\n            }\n            this.cancelHover();\n        };\n        this.handleSelectStart = (e)=>{\n            const target = e.target;\n            // Only IE requires us to explicitly say\n            // we want drag drop operation to start\n            if (typeof target.dragDrop !== 'function') {\n                return;\n            }\n            // Inputs and textareas should be selectable\n            if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n                return;\n            }\n            // For other targets, ask IE\n            // to enable drag and drop\n            e.preventDefault();\n            target.dragDrop();\n        };\n        this.options = new OptionsReader(globalContext, options);\n        this.actions = manager.getActions();\n        this.monitor = manager.getMonitor();\n        this.registry = manager.getRegistry();\n        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);\n    }\n}\n\n//# sourceMappingURL=HTML5BackendImpl.js.map","let emptyImage;\nexport function getEmptyImage() {\n    if (!emptyImage) {\n        emptyImage = new Image();\n        emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n    }\n    return emptyImage;\n}\n\n//# sourceMappingURL=getEmptyImage.js.map","import { HTML5BackendImpl } from './HTML5BackendImpl.js';\nimport * as _NativeTypes from './NativeTypes.js';\nexport { getEmptyImage } from './getEmptyImage.js';\nexport { _NativeTypes as NativeTypes };\nexport const HTML5Backend = function createBackend(manager, context, options) {\n    return new HTML5BackendImpl(manager, context, options);\n};\n\n//# sourceMappingURL=index.js.map","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport { isPlainObject };\n","// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors = process.env.NODE_ENV !== \"production\" ? [\n  // All error codes, starting by 0:\n  function(plugin) {\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n  },\n  function(thing) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(thing) {\n    return `'current' expects a draft, got: ${thing}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(thing) {\n    return `'original' expects a draft, got: ${thing}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : [];\nfunction die(error, ...args) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const e = errors[error];\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\n\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value)\n    return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\")\n    return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object)\n    return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value))\n    die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Reflect.ownKeys(obj).forEach((key) => {\n      iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2 /* Map */)\n    thing.set(propOrOldValue, value);\n  else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else\n    thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base))\n    return Array.prototype.slice.call(base);\n  const isPlain = isPlainObject(base);\n  if (strict === true || strict === \"class_only\" && !isPlain) {\n    const descriptors = Object.getOwnPropertyDescriptors(base);\n    delete descriptors[DRAFT_STATE];\n    let keys = Reflect.ownKeys(descriptors);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const desc = descriptors[key];\n      if (desc.writable === false) {\n        desc.writable = true;\n        desc.configurable = true;\n      }\n      if (desc.get || desc.set)\n        descriptors[key] = {\n          configurable: true,\n          writable: true,\n          // could live with !!desc.set as well here...\n          enumerable: desc.enumerable,\n          value: base[key]\n        };\n    }\n    return Object.create(getPrototypeOf(base), descriptors);\n  } else {\n    const proto = getPrototypeOf(base);\n    if (proto !== null && isPlain) {\n      return { ...base };\n    }\n    const obj = Object.create(proto);\n    return Object.assign(obj, base);\n  }\n}\nfunction freeze(obj, deep = false) {\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\n    return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep)\n    Object.entries(obj).forEach(([key, value]) => freeze(value, true));\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey])\n    plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\n    state.revoke_();\n  else\n    state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_)\n        maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(\n        baseDraft[DRAFT_STATE].base_,\n        result,\n        scope.patches_,\n        scope.inversePatches_\n      );\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  if (!state) {\n    each(\n      value,\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)\n    );\n    return value;\n  }\n  if (state.scope_ !== rootScope)\n    return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(\n      resultEach,\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\n    );\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(\n        state,\n        path,\n        rootScope.patches_,\n        rootScope.inversePatches_\n      );\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n    die(5);\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else\n      return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== \"symbol\" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))\n      maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE)\n      return state;\n    const source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    const value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\n        return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\n      return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc)\n      return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty() {\n    die(11);\n  },\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n  setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function() {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function(state, prop) {\n  if (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop)))\n    die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n  if (process.env.NODE_ENV !== \"production\" && prop !== \"length\" && isNaN(parseInt(prop)))\n    die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)\n  ) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source))\n    return void 0;\n  let proto = getPrototypeOf(source);\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc)\n      return desc;\n    proto = getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(\n      state.base_,\n      state.scope_.immer_.useStrictShallowCopy_\n    );\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = class {\n  constructor(config) {\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce(base2 = defaultBase, ...args) {\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\n        };\n      }\n      if (typeof recipe !== \"function\")\n        die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\n        die(7);\n      let result;\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError)\n            revokeScope(scope);\n          else\n            leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0)\n          result = base;\n        if (result === NOTHING)\n          result = void 0;\n        if (this.autoFreeze_)\n          freeze(result, true);\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else\n        die(1, base);\n    };\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\n      }\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof config?.autoFreeze === \"boolean\")\n      this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  createDraft(base) {\n    if (!isDraftable(base))\n      die(8);\n    if (isDraft(base))\n      base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_)\n      die(9);\n    const { scope_: scope } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  applyPatches(base, patches) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n    return this.produce(\n      base,\n      (draft) => applyPatchesImpl(draft, patches)\n    );\n  }\n};\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value))\n    die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  if (state) {\n    if (!state.modified_)\n      return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  const errorOffset = 16;\n  if (process.env.NODE_ENV !== \"production\") {\n    errors.push(\n      'Sets cannot have \"replace\" patches.',\n      function(op) {\n        return \"Unsupported patch operation: \" + op;\n      },\n      function(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n      },\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n    );\n  }\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let { base_, assigned_ } = state;\n    let copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const { base_, copy_ } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE)\n        return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\n      inversePatches.push(\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\n      );\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let { base_, copy_ } = state;\n    let i = 0;\n    base_.forEach((value) => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach((value) => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach((patch) => {\n      const { path, op } = patch;\n      let base = draft;\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\n          die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\")\n          die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\")\n          die(errorOffset + 2, path.join(\"/\"));\n      }\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj))\n      return obj;\n    if (Array.isArray(obj))\n      return obj.map(deepClonePatchValue);\n    if (isMap(obj))\n      return new Map(\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n      );\n    if (isSet(obj))\n      return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n    for (const key in obj)\n      cloned[key] = deepClonePatchValue(obj[key]);\n    if (has(obj, DRAFTABLE))\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else\n      return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n      return this;\n    }\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n      state.copy_.delete(key);\n      return true;\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */ new Map();\n        each(state.base_, (key) => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n  }\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */ new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */ new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n      if (state.copy_.has(value))\n        return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n        return true;\n      return false;\n    }\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n      return this;\n    }\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\n        /* istanbul ignore next */\n        false\n      ));\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n    keys() {\n      return this.values();\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n  }\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */ new Set();\n      state.base_.forEach((value) => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_)\n      die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(\n  immer\n);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\nexport {\n  Immer2 as Immer,\n  applyPatches,\n  castDraft,\n  castImmutable,\n  createDraft,\n  current,\n  enableMapSet,\n  enablePatches,\n  finishDraft,\n  freeze,\n  DRAFTABLE as immerable,\n  isDraft,\n  isDraftable,\n  NOTHING as nothing,\n  original,\n  produce,\n  produceWithPatches,\n  setAutoFreeze,\n  setUseStrictShallowCopy\n};\n//# sourceMappingURL=immer.mjs.map","import { isPlainObject } from 'is-plain-object';\nimport { createDraft, finishDraft, isDraft, produce } from 'immer';\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n    if (current == null) {\n      return;\n    }\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n    return paths;\n  },\n  common(path, another) {\n    var common = [];\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n      if (av !== bv) {\n        break;\n      }\n      common.push(av);\n    }\n    return common;\n  },\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n    return 0;\n  },\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n    if (reverse) {\n      list.reverse();\n    }\n    return list;\n  },\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n      default:\n        return false;\n    }\n  },\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n    return path.slice(0, -1);\n  },\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n    var last = path[path.length - 1];\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n    return path.slice(0, -1).concat(last - 1);\n  },\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n    return path.slice(ancestor.length);\n  },\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null;\n    // PERF: use destructing instead of immer\n    var p = [...path];\n    var {\n      affinity = 'forward'\n    } = options;\n    // PERF: Exit early if the operation is guaranteed not to have an effect.\n    if (path.length === 0) {\n      return p;\n    }\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var {\n            path: op\n          } = operation;\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n          break;\n        }\n      case 'remove_node':\n        {\n          var {\n            path: _op\n          } = operation;\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n          break;\n        }\n      case 'merge_node':\n        {\n          var {\n            path: _op2,\n            position\n          } = operation;\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n          break;\n        }\n      case 'split_node':\n        {\n          var {\n            path: _op3,\n            position: _position\n          } = operation;\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n          break;\n        }\n      case 'move_node':\n        {\n          var {\n            path: _op4,\n            newPath: onp\n          } = operation;\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n            p[_op4.length - 1] -= 1;\n          }\n          break;\n        }\n    }\n    return p;\n  }\n};\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var {\n          path,\n          node\n        } = op;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n        parent.children.splice(index, 0, node);\n        if (selection) {\n          for (var [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op);\n          }\n        }\n        break;\n      }\n    case 'insert_text':\n      {\n        var {\n          path: _path,\n          offset,\n          text\n        } = op;\n        if (text.length === 0) break;\n        var _node = Node.leaf(editor, _path);\n        var before = _node.text.slice(0, offset);\n        var after = _node.text.slice(offset);\n        _node.text = before + text + after;\n        if (selection) {\n          for (var [_point, _key] of Range.points(selection)) {\n            selection[_key] = Point.transform(_point, op);\n          }\n        }\n        break;\n      }\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n        var _node2 = Node.get(editor, _path2);\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n        var _parent = Node.parent(editor, _path2);\n        var _index = _path2[_path2.length - 1];\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          prev.children.push(..._node2.children);\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n        _parent.children.splice(_index, 1);\n        if (selection) {\n          for (var [_point2, _key2] of Range.points(selection)) {\n            selection[_key2] = Point.transform(_point2, op);\n          }\n        }\n        break;\n      }\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n        var _node3 = Node.get(editor, _path3);\n        var _parent2 = Node.parent(editor, _path3);\n        var _index2 = _path3[_path3.length - 1];\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        _parent2.children.splice(_index2, 1);\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n        if (selection) {\n          for (var [_point3, _key3] of Range.points(selection)) {\n            selection[_key3] = Point.transform(_point3, op);\n          }\n        }\n        break;\n      }\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _index3 = _path4[_path4.length - 1];\n        var _parent3 = Node.parent(editor, _path4);\n        _parent3.children.splice(_index3, 1);\n        // Transform all the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (var [_point4, _key4] of Range.points(selection)) {\n            var result = Point.transform(_point4, op);\n            if (selection != null && result != null) {\n              selection[_key4] = result;\n            } else {\n              var _prev = void 0;\n              var next = void 0;\n              for (var [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, _path4) === -1) {\n                  _prev = [n, p];\n                } else {\n                  next = [n, p];\n                  break;\n                }\n              }\n              var preferNext = false;\n              if (_prev && next) {\n                if (Path.equals(next[1], _path4)) {\n                  preferNext = !Path.hasPrevious(next[1]);\n                } else {\n                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                }\n              }\n              if (_prev && !preferNext) {\n                _point4.path = _prev[1];\n                _point4.offset = _prev[0].text.length;\n              } else if (next) {\n                _point4.path = next[1];\n                _point4.offset = 0;\n              } else {\n                selection = null;\n              }\n            }\n          }\n        }\n        break;\n      }\n    case 'remove_text':\n      {\n        var {\n          path: _path5,\n          offset: _offset,\n          text: _text\n        } = op;\n        if (_text.length === 0) break;\n        var _node4 = Node.leaf(editor, _path5);\n        var _before = _node4.text.slice(0, _offset);\n        var _after = _node4.text.slice(_offset + _text.length);\n        _node4.text = _before + _after;\n        if (selection) {\n          for (var [_point5, _key5] of Range.points(selection)) {\n            selection[_key5] = Point.transform(_point5, op);\n          }\n        }\n        break;\n      }\n    case 'set_node':\n      {\n        var {\n          path: _path6,\n          properties,\n          newProperties\n        } = op;\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n        var _node5 = Node.get(editor, _path6);\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n          var value = newProperties[_key6];\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        }\n        // properties that were previously defined, but are now missing, must be deleted\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n        break;\n      }\n    case 'set_selection':\n      {\n        var {\n          newProperties: _newProperties\n        } = op;\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n            selection = _objectSpread$e({}, _newProperties);\n          }\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n        break;\n      }\n    case 'split_node':\n      {\n        var {\n          path: _path7,\n          position,\n          properties: _properties\n        } = op;\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n        var _node6 = Node.get(editor, _path7);\n        var _parent4 = Node.parent(editor, _path7);\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n          var _after2 = _node6.text.slice(position);\n          _node6.text = _before2;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n          var _after3 = _node6.children.slice(position);\n          _node6.children = _before3;\n          newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n            children: _after3\n          });\n        }\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n        if (selection) {\n          for (var [_point6, _key9] of Range.points(selection)) {\n            selection[_key9] = Point.transform(_point6, op);\n          }\n        }\n        break;\n      }\n  }\n  return selection;\n};\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n  transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = finishDraft(editor.children);\n      if (selection) {\n        editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n  insertNodes(editor, nodes, options) {\n    editor.insertNodes(nodes, options);\n  },\n  liftNodes(editor, options) {\n    editor.liftNodes(options);\n  },\n  mergeNodes(editor, options) {\n    editor.mergeNodes(options);\n  },\n  moveNodes(editor, options) {\n    editor.moveNodes(options);\n  },\n  removeNodes(editor, options) {\n    editor.removeNodes(options);\n  },\n  setNodes(editor, props, options) {\n    editor.setNodes(props, options);\n  },\n  splitNodes(editor, options) {\n    editor.splitNodes(options);\n  },\n  unsetNodes(editor, props, options) {\n    editor.unsetNodes(props, options);\n  },\n  unwrapNodes(editor, options) {\n    editor.unwrapNodes(options);\n  },\n  wrapNodes(editor, element, options) {\n    editor.wrapNodes(element, options);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n  collapse(editor, options) {\n    editor.collapse(options);\n  },\n  deselect(editor) {\n    editor.deselect();\n  },\n  move(editor, options) {\n    editor.move(options);\n  },\n  select(editor, target) {\n    editor.select(target);\n  },\n  setPoint(editor, props, options) {\n    editor.setPoint(props, options);\n  },\n  setSelection(editor, props) {\n    editor.setSelection(props);\n  }\n};\n\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n    if (isPlainObject(a) && isPlainObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n  return true;\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded$4 = [\"anchor\", \"focus\"];\nfunction ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Range = {\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n  surrounds(range, target) {\n    var intersectionRange = Range.intersection(range, target);\n    if (!intersectionRange) {\n      return false;\n    }\n    return Range.equals(intersectionRange, target);\n  },\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n    return isAfterStart && isBeforeEnd;\n  },\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$4);\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$d({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n  isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(range, r => {\n      if (r === null) {\n        return null;\n      }\n      var {\n        affinity = 'inward'\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n      if (!anchor || !focus) {\n        return null;\n      }\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\n\n/**\n * Shared the function with isElementType utility\n */\nvar isElement = value => {\n  return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n  isAncestor(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children);\n  },\n  isElement,\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nvar _excluded$3 = [\"children\"],\n  _excluded2$3 = [\"text\"];\nvar IS_NODE_LIST_CACHE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Node = {\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      for (var p of Path.ancestors(path, options)) {\n        var n = Node.ancestor(root, p);\n        var entry = [n, p];\n        yield entry;\n      }\n    }();\n  },\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n    var c = root.children[index];\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n    return c;\n  },\n  children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      var {\n        reverse = false\n      } = options;\n      var ancestor = Node.ancestor(root, path);\n      var {\n        children\n      } = ancestor;\n      var index = reverse ? children.length - 1 : 0;\n      while (reverse ? index >= 0 : index < children.length) {\n        var child = Node.child(ancestor, index);\n        var childPath = path.concat(index);\n        yield [child, childPath];\n        index = reverse ? index - 1 : index + 1;\n      }\n    }();\n  },\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n  descendant(root, path) {\n    var node = Node.get(root, path);\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (path.length !== 0) {\n          // NOTE: we have to coerce here because checking the path's length does\n          // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n          yield [node, path];\n        }\n      }\n    }();\n  },\n  elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (Element.isElement(node)) {\n          yield [node, path];\n        }\n      }\n    }();\n  },\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$3);\n      return properties;\n    }\n  },\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n    return [n, p];\n  },\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n    var newRoot = produce({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n  get(root, path) {\n    var node = Node.getIf(root, path);\n    if (node === undefined) {\n      throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n    }\n    return node;\n  },\n  getIf(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return;\n      }\n      node = node.children[p];\n    }\n    return node;\n  },\n  has(root, path) {\n    var node = root;\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n      node = node.children[p];\n    }\n    return true;\n  },\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n    return [n, p];\n  },\n  leaf(root, path) {\n    var node = Node.get(root, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n    return node;\n  },\n  levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return function* () {\n      for (var p of Path.levels(path, options)) {\n        var n = Node.get(root, p);\n        yield [n, p];\n      }\n    }();\n  },\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n  nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      var {\n        pass,\n        reverse = false\n      } = options;\n      var {\n        from = [],\n        to\n      } = options;\n      var visited = new Set();\n      var p = [];\n      var n = root;\n      while (true) {\n        if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n          break;\n        }\n        if (!visited.has(n)) {\n          yield [n, p];\n        }\n        // If we're allowed to go downward and we haven't descended yet, do.\n        if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n          visited.add(n);\n          var nextIndex = reverse ? n.children.length - 1 : 0;\n          if (Path.isAncestor(p, from)) {\n            nextIndex = from[p.length];\n          }\n          p = p.concat(nextIndex);\n          n = Node.get(root, p);\n          continue;\n        }\n        // If we're at the root and we can't go down, we're done.\n        if (p.length === 0) {\n          break;\n        }\n        // If we're going forward...\n        if (!reverse) {\n          var newPath = Path.next(p);\n          if (Node.has(root, newPath)) {\n            p = newPath;\n            n = Node.get(root, p);\n            continue;\n          }\n        }\n        // If we're going backward...\n        if (reverse && p[p.length - 1] !== 0) {\n          var _newPath = Path.previous(p);\n          p = _newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n        // Otherwise we're going upward...\n        p = Path.parent(p);\n        n = Node.get(root, p);\n        visited.add(n);\n      }\n    }();\n  },\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n    return p;\n  },\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n  texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function* () {\n      for (var [node, path] of Node.nodes(root, options)) {\n        if (Text.isText(node)) {\n          yield [node, path];\n        }\n      }\n    }();\n  }\n};\n\nfunction ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n  isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);\n      default:\n        return false;\n    }\n  },\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n      case 'insert_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n      case 'merge_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op;\n          // PERF: in this case the move operation is a no-op anyways.\n          if (Path.equals(newPath, path)) {\n            return op;\n          }\n          // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          }\n          // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n      case 'remove_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n      case 'remove_text':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n          if (_properties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$c(_objectSpread$c({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n      case 'split_node':\n        {\n          return _objectSpread$c(_objectSpread$c({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\n\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = value => {\n  var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n  if (cachedIsEditor !== undefined) {\n    return cachedIsEditor;\n  }\n  if (!isPlainObject(value)) {\n    return false;\n  }\n  var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isElementReadOnly === 'function' && typeof value.isInline === 'function' && typeof value.isSelectable === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  IS_EDITOR_CACHE.set(value, isEditor);\n  return isEditor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n  above(editor, options) {\n    return editor.above(options);\n  },\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n  after(editor, at, options) {\n    return editor.after(at, options);\n  },\n  before(editor, at, options) {\n    return editor.before(at, options);\n  },\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n  deleteFragment(editor, options) {\n    editor.deleteFragment(options);\n  },\n  edges(editor, at) {\n    return editor.edges(at);\n  },\n  elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return editor.elementReadOnly(options);\n  },\n  end(editor, at) {\n    return editor.end(at);\n  },\n  first(editor, at) {\n    return editor.first(at);\n  },\n  fragment(editor, at) {\n    return editor.fragment(at);\n  },\n  hasBlocks(editor, element) {\n    return editor.hasBlocks(element);\n  },\n  hasInlines(editor, element) {\n    return editor.hasInlines(element);\n  },\n  hasPath(editor, path) {\n    return editor.hasPath(path);\n  },\n  hasTexts(editor, element) {\n    return editor.hasTexts(element);\n  },\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n  isBlock(editor, value) {\n    return editor.isBlock(value);\n  },\n  isEdge(editor, point, at) {\n    return editor.isEdge(point, at);\n  },\n  isEditor(value) {\n    return isEditor(value);\n  },\n  isElementReadOnly(editor, element) {\n    return editor.isElementReadOnly(element);\n  },\n  isEmpty(editor, element) {\n    return editor.isEmpty(element);\n  },\n  isEnd(editor, point, at) {\n    return editor.isEnd(point, at);\n  },\n  isInline(editor, value) {\n    return editor.isInline(value);\n  },\n  isNormalizing(editor) {\n    return editor.isNormalizing();\n  },\n  isSelectable(editor, value) {\n    return editor.isSelectable(value);\n  },\n  isStart(editor, point, at) {\n    return editor.isStart(point, at);\n  },\n  isVoid(editor, value) {\n    return editor.isVoid(value);\n  },\n  last(editor, at) {\n    return editor.last(at);\n  },\n  leaf(editor, at, options) {\n    return editor.leaf(at, options);\n  },\n  levels(editor, options) {\n    return editor.levels(options);\n  },\n  marks(editor) {\n    return editor.getMarks();\n  },\n  next(editor, options) {\n    return editor.next(options);\n  },\n  node(editor, at, options) {\n    return editor.node(at, options);\n  },\n  nodes(editor, options) {\n    return editor.nodes(options);\n  },\n  normalize(editor, options) {\n    editor.normalize(options);\n  },\n  parent(editor, at, options) {\n    return editor.parent(at, options);\n  },\n  path(editor, at, options) {\n    return editor.path(at, options);\n  },\n  pathRef(editor, path, options) {\n    return editor.pathRef(path, options);\n  },\n  pathRefs(editor) {\n    return editor.pathRefs();\n  },\n  point(editor, at, options) {\n    return editor.point(at, options);\n  },\n  pointRef(editor, point, options) {\n    return editor.pointRef(point, options);\n  },\n  pointRefs(editor) {\n    return editor.pointRefs();\n  },\n  positions(editor, options) {\n    return editor.positions(options);\n  },\n  previous(editor, options) {\n    return editor.previous(options);\n  },\n  range(editor, at, to) {\n    return editor.range(at, to);\n  },\n  rangeRef(editor, range, options) {\n    return editor.rangeRef(range, options);\n  },\n  rangeRefs(editor) {\n    return editor.rangeRefs();\n  },\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n  setNormalizing(editor, isNormalizing) {\n    editor.setNormalizing(isNormalizing);\n  },\n  start(editor, at) {\n    return editor.start(at);\n  },\n  string(editor, at, options) {\n    return editor.string(at, options);\n  },\n  unhangRange(editor, range, options) {\n    return editor.unhangRange(range, options);\n  },\n  void(editor, options) {\n    return editor.void(options);\n  },\n  withoutNormalizing(editor, fn) {\n    editor.withoutNormalizing(fn);\n  },\n  shouldMergeNodesRemovePrevNode: (editor, prevNode, curNode) => {\n    return editor.shouldMergeNodesRemovePrevNode(prevNode, curNode);\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar Location = {\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\n\nfunction ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Point = {\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n    return result;\n  },\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n  isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, p => {\n      if (p === null) {\n        return null;\n      }\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n            break;\n          }\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n            break;\n          }\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n            break;\n          }\n      }\n    });\n  }\n};\n\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */\n// eslint-disable-next-line no-redeclare\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n};\n\nvar _excluded$2 = [\"text\"],\n  _excluded2$2 = [\"anchor\", \"focus\"];\nfunction ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// eslint-disable-next-line no-redeclare\nvar Text = {\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$2);\n      return rest;\n    }\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n  isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$a({}, node)];\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$2);\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length;\n        // If the range encompasses the entire leaf, add the range.\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        }\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        }\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n          before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n        Object.assign(middle, rest);\n        if (before) {\n          next.push(before);\n        }\n        next.push(middle);\n        if (after) {\n          next.push(after);\n        }\n      }\n      leaves = next;\n    }\n    return leaves;\n  }\n};\n\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */\nvar getDefaultInsertLocation = editor => {\n  if (editor.selection) {\n    return editor.selection;\n  } else if (editor.children.length > 0) {\n    return Editor.end(editor, []);\n  } else {\n    return [0];\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0;\n  // Evaluation of these conditions are deferred.\n  var gb11 = null; // Is GB11 applicable?\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n      if (!gb11) break;\n    }\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n      if (!gb12Or13) break;\n    }\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n    distance += char.length;\n  }\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u002B\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n    text = remaining;\n  }\n  return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (SPACE.test(char)) {\n    return false;\n  }\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n  return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n    yield char1;\n  }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n  return type;\n};\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],\n// GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],\n// GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T],\n// GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],\n// GB9a\n[CodepointType.Any, CodepointType.SpacingMark],\n// GB9b\n[CodepointType.Prepend, CodepointType.Any],\n// GB11\n[CodepointType.ZWJ, CodepointType.ExtPict],\n// GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n  delete(editor, options) {\n    editor.delete(options);\n  },\n  insertFragment(editor, fragment, options) {\n    editor.insertFragment(fragment, options);\n  },\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = getDefaultInsertLocation(editor)\n      } = options;\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n      if (!voids && Editor.void(editor, {\n        at\n      }) || Editor.elementReadOnly(editor, {\n        at\n      })) {\n        return;\n      }\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n};\n\nfunction ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n// perf\nvar BATCHING_DIRTY_PATHS = new WeakMap();\nvar isBatchingDirtyPaths = editor => {\n  return BATCHING_DIRTY_PATHS.get(editor) || false;\n};\nvar batchDirtyPaths = (editor, fn, update) => {\n  var value = BATCHING_DIRTY_PATHS.get(editor) || false;\n  BATCHING_DIRTY_PATHS.set(editor, true);\n  try {\n    fn();\n    update();\n  } finally {\n    BATCHING_DIRTY_PATHS.set(editor, value);\n  }\n};\n\n/**\n * update editor dirty paths\n *\n * @param newDirtyPaths: Path[]; new dirty paths\n * @param transform: (p: Path) => Path | null; how to transform existing dirty paths\n */\nfunction updateDirtyPaths(editor, newDirtyPaths, transform) {\n  var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n  var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n  var dirtyPaths;\n  var dirtyPathKeys;\n  var add = path => {\n    if (path) {\n      var key = path.join(',');\n      if (!dirtyPathKeys.has(key)) {\n        dirtyPathKeys.add(key);\n        dirtyPaths.push(path);\n      }\n    }\n  };\n  if (transform) {\n    dirtyPaths = [];\n    dirtyPathKeys = new Set();\n    for (var path of oldDirtyPaths) {\n      var newPath = transform(path);\n      add(newPath);\n    }\n  } else {\n    dirtyPaths = oldDirtyPaths;\n    dirtyPathKeys = oldDirtyPathKeys;\n  }\n  for (var _path of newDirtyPaths) {\n    add(_path);\n  }\n  DIRTY_PATHS.set(editor, dirtyPaths);\n  DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n}\n\nvar apply = (editor, op) => {\n  for (var ref of Editor.pathRefs(editor)) {\n    PathRef.transform(ref, op);\n  }\n  for (var _ref of Editor.pointRefs(editor)) {\n    PointRef.transform(_ref, op);\n  }\n  for (var _ref2 of Editor.rangeRefs(editor)) {\n    RangeRef.transform(_ref2, op);\n  }\n  // update dirty paths\n  if (!isBatchingDirtyPaths(editor)) {\n    var transform = Path.operationCanTransformPath(op) ? p => Path.transform(p, op) : undefined;\n    updateDirtyPaths(editor, editor.getDirtyPaths(op), transform);\n  }\n  Transforms.transform(editor, op);\n  editor.operations.push(op);\n  Editor.normalize(editor, {\n    operation: op\n  });\n  // Clear any formats applied to the cursor if the selection changes.\n  if (op.type === 'set_selection') {\n    editor.marks = null;\n  }\n  if (!FLUSHING.get(editor)) {\n    FLUSHING.set(editor, true);\n    Promise.resolve().then(() => {\n      FLUSHING.set(editor, false);\n      editor.onChange({\n        operation: op\n      });\n      editor.operations = [];\n    });\n  }\n};\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\nvar getDirtyPaths = (editor, op) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path\n        } = op;\n        var levels = Path.levels(_path);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref => {\n          var [, p] = _ref;\n          return _path.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n        var ancestors = Path.ancestors(_path2);\n        var previousPath = Path.previous(_path2);\n        return [...ancestors, previousPath];\n      }\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n        if (Path.equals(_path3, newPath)) {\n          return [];\n        }\n        var oldAncestors = [];\n        var newAncestors = [];\n        for (var ancestor of Path.ancestors(_path3)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n          newAncestors.push(_p);\n        }\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _ancestors = Path.ancestors(_path4);\n        return [..._ancestors];\n      }\n    case 'split_node':\n      {\n        var {\n          path: _path5\n        } = op;\n        var _levels = Path.levels(_path5);\n        var nextPath = Path.next(_path5);\n        return [..._levels, nextPath];\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nvar getFragment = editor => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    return Node.fragment(editor, selection);\n  }\n  return [];\n};\n\nvar normalizeNode = (editor, entry) => {\n  var [node, path] = entry;\n  // There are no core normalizations for text nodes.\n  if (Text.isText(node)) {\n    return;\n  }\n  // Ensure that block and inline nodes have at least one text child.\n  if (Element.isElement(node) && node.children.length === 0) {\n    var child = {\n      text: ''\n    };\n    Transforms.insertNodes(editor, child, {\n      at: path.concat(0),\n      voids: true\n    });\n    return;\n  }\n  // Determine whether the node should have block or inline children.\n  var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n  // Since we'll be applying operations while iterating, keep track of an\n  // index that accounts for any added/removed nodes.\n  var n = 0;\n  for (var i = 0; i < node.children.length; i++, n++) {\n    var currentNode = Node.get(editor, path);\n    if (Text.isText(currentNode)) continue;\n    var _child = currentNode.children[n];\n    var prev = currentNode.children[n - 1];\n    var isLast = i === node.children.length - 1;\n    var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n    // Only allow block nodes in the top-level children and parent blocks\n    // that only contain block nodes. Similarly, only allow inline nodes in\n    // other inline nodes, or parent blocks that only contain inlines and\n    // text.\n    if (isInlineOrText !== shouldHaveInlines) {\n      Transforms.removeNodes(editor, {\n        at: path.concat(n),\n        voids: true\n      });\n      n--;\n    } else if (Element.isElement(_child)) {\n      // Ensure that inline nodes are surrounded by text nodes.\n      if (editor.isInline(_child)) {\n        if (prev == null || !Text.isText(prev)) {\n          var newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, newChild, {\n            at: path.concat(n),\n            voids: true\n          });\n          n++;\n        } else if (isLast) {\n          var _newChild = {\n            text: ''\n          };\n          Transforms.insertNodes(editor, _newChild, {\n            at: path.concat(n + 1),\n            voids: true\n          });\n          n++;\n        }\n      }\n    } else {\n      // If the child is not a text node, and doesn't have a `children` field,\n      // then we have an invalid node that will upset slate.\n      //\n      // eg: `{ type: 'some_node' }`.\n      //\n      // To prevent slate from breaking, we can add the `children` field,\n      // and now that it is valid, we can to many more operations easily,\n      // such as extend normalizers to fix erronous structure.\n      if (!Text.isText(_child) && !('children' in _child)) {\n        var elementChild = _child;\n        elementChild.children = [];\n      }\n      // Merge adjacent text nodes that are empty or match.\n      if (prev != null && Text.isText(prev)) {\n        if (Text.equals(_child, prev, {\n          loose: true\n        })) {\n          Transforms.mergeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (prev.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n - 1),\n            voids: true\n          });\n          n--;\n        } else if (_child.text === '') {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        }\n      }\n    }\n  }\n};\n\nvar shouldNormalize = (editor, _ref) => {\n  var {\n    iteration,\n    initialDirtyPathsLength\n  } = _ref;\n  var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n  if (iteration > maxIterations) {\n    throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n  }\n  return true;\n};\n\nvar above = function above(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    voids = false,\n    mode = 'lowest',\n    at = editor.selection,\n    match\n  } = options;\n  if (!at) {\n    return;\n  }\n  var path = Editor.path(editor, at);\n  var reverse = mode === 'lowest';\n  for (var [n, p] of Editor.levels(editor, {\n    at: path,\n    voids,\n    match,\n    reverse\n  })) {\n    if (Text.isText(n)) continue;\n    if (Range.isRange(at)) {\n      if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n        return [n, p];\n      }\n    } else {\n      if (!Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  }\n};\n\nfunction ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar addMark = (editor, key, value) => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.setNodes(editor, {\n        [key]: value\n      }, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n        [key]: value\n      });\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar after = function after(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var focus = Editor.end(editor, []);\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n  for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n    at: range\n  }))) {\n    if (d > distance) {\n      break;\n    }\n    if (d !== 0) {\n      target = p;\n    }\n    d++;\n  }\n  return target;\n};\n\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar before = function before(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var anchor = Editor.start(editor, []);\n  var focus = Editor.point(editor, at, {\n    edge: 'start'\n  });\n  var range = {\n    anchor,\n    focus\n  };\n  var {\n    distance = 1\n  } = options;\n  var d = 0;\n  var target;\n  for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n    at: range,\n    reverse: true\n  }))) {\n    if (d > distance) {\n      break;\n    }\n    if (d !== 0) {\n      target = p;\n    }\n    d++;\n  }\n  return target;\n};\n\nvar deleteBackward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit,\n      reverse: true\n    });\n  }\n};\n\nvar deleteForward = (editor, unit) => {\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isCollapsed(selection)) {\n    Transforms.delete(editor, {\n      unit\n    });\n  }\n};\n\nvar deleteFragment = function deleteFragment(editor) {\n  var {\n    direction = 'forward'\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  if (selection && Range.isExpanded(selection)) {\n    Transforms.delete(editor, {\n      reverse: direction === 'backward'\n    });\n  }\n};\n\nvar edges = (editor, at) => {\n  return [Editor.start(editor, at), Editor.end(editor, at)];\n};\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar elementReadOnly = function elementReadOnly(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n  }));\n};\n\nvar end = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'end'\n  });\n};\n\nvar first = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'start'\n  });\n  return Editor.node(editor, path);\n};\n\nvar fragment = (editor, at) => {\n  var range = Editor.range(editor, at);\n  return Node.fragment(editor, range);\n};\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar getVoid = function getVoid(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n    match: n => Element.isElement(n) && Editor.isVoid(editor, n)\n  }));\n};\n\nvar hasBlocks = (editor, element) => {\n  return element.children.some(n => Element.isElement(n) && Editor.isBlock(editor, n));\n};\n\nvar hasInlines = (editor, element) => {\n  return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n};\n\nvar hasPath = (editor, path) => {\n  return Node.has(editor, path);\n};\n\nvar hasTexts = (editor, element) => {\n  return element.children.every(n => Text.isText(n));\n};\n\nvar insertBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nvar insertNode = (editor, node, options) => {\n  Transforms.insertNodes(editor, node, options);\n};\n\nvar insertSoftBreak = editor => {\n  Transforms.splitNodes(editor, {\n    always: true\n  });\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar insertText = function insertText(editor, text) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection,\n    marks\n  } = editor;\n  if (selection) {\n    if (marks) {\n      var node = _objectSpread$3({\n        text\n      }, marks);\n      Transforms.insertNodes(editor, node, {\n        at: options.at,\n        voids: options.voids\n      });\n    } else {\n      Transforms.insertText(editor, text, options);\n    }\n    editor.marks = null;\n  }\n};\n\nvar isBlock = (editor, value) => {\n  return !editor.isInline(value);\n};\n\nvar isEdge = (editor, point, at) => {\n  return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\n\nvar isEmpty = (editor, element) => {\n  var {\n    children\n  } = element;\n  var [first] = children;\n  return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n};\n\nvar isEnd = (editor, point, at) => {\n  var end = Editor.end(editor, at);\n  return Point.equals(point, end);\n};\n\nvar isNormalizing = editor => {\n  var isNormalizing = NORMALIZING.get(editor);\n  return isNormalizing === undefined ? true : isNormalizing;\n};\n\nvar isStart = (editor, point, at) => {\n  // PERF: If the offset isn't `0` we know it's not the start.\n  if (point.offset !== 0) {\n    return false;\n  }\n  var start = Editor.start(editor, at);\n  return Point.equals(point, start);\n};\n\nvar last = (editor, at) => {\n  var path = Editor.path(editor, at, {\n    edge: 'end'\n  });\n  return Editor.node(editor, path);\n};\n\nvar leaf = function leaf(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.leaf(editor, path);\n  return [node, path];\n};\n\nfunction levels(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (match == null) {\n      match = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var levels = [];\n    var path = Editor.path(editor, at);\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n      levels.push([n, p]);\n      if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n    if (reverse) {\n      levels.reverse();\n    }\n    yield* levels;\n  }();\n}\n\nvar _excluded$1 = [\"text\"],\n  _excluded2$1 = [\"text\"];\nvar marks = function marks(editor) {\n  var {\n    marks,\n    selection\n  } = editor;\n  if (!selection) {\n    return null;\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  if (marks) {\n    return marks;\n  }\n  if (Range.isExpanded(selection)) {\n    var isBackward = Range.isBackward(selection);\n    if (isBackward) {\n      [focus, anchor] = [anchor, focus];\n    }\n    /**\n     * COMPAT: Make sure hanging ranges (caused by double clicking in Firefox)\n     * do not adversely affect the returned marks.\n     */\n    var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n    if (isEnd) {\n      var after = Editor.after(editor, anchor);\n      if (after) {\n        anchor = after;\n      }\n    }\n    var [match] = Editor.nodes(editor, {\n      match: Text.isText,\n      at: {\n        anchor,\n        focus\n      }\n    });\n    if (match) {\n      var [_node] = match;\n      var _rest = _objectWithoutProperties(_node, _excluded$1);\n      return _rest;\n    } else {\n      return {};\n    }\n  }\n  var {\n    path\n  } = anchor;\n  var [node] = Editor.leaf(editor, path);\n  if (anchor.offset === 0) {\n    var prev = Editor.previous(editor, {\n      at: path,\n      match: Text.isText\n    });\n    var markedVoid = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n    });\n    if (!markedVoid) {\n      var block = Editor.above(editor, {\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n      });\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n  }\n  var rest = _objectWithoutProperties(node, _excluded2$1);\n  return rest;\n};\n\nvar next = function next(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n  if (!at) {\n    return;\n  }\n  var pointAfterLocation = Editor.after(editor, at, {\n    voids\n  });\n  if (!pointAfterLocation) return;\n  var [, to] = Editor.last(editor, []);\n  var span = [pointAfterLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the next node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n  var [next] = Editor.nodes(editor, {\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return next;\n};\n\nvar node = function node(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var node = Node.get(editor, path);\n  return [node, path];\n};\n\nfunction nodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n      ignoreNonSelectable = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (!match) {\n      match = () => true;\n    }\n    if (!at) {\n      return;\n    }\n    var from;\n    var to;\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [node] = _ref;\n        if (!Element.isElement(node)) return false;\n        if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n        if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n        return false;\n      }\n    });\n    var matches = [];\n    var hit;\n    for (var [node, path] of nodeEntries) {\n      if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n        continue;\n      }\n      var isLower = hit && Path.compare(path, hit[1]) === 0;\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      }\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      }\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      var emit = mode === 'lowest' ? hit : [node, path];\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n      hit = [node, path];\n    }\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    }\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches;\n    }\n  }();\n}\n\nvar normalize = function normalize(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    force = false,\n    operation\n  } = options;\n  var getDirtyPaths = editor => {\n    return DIRTY_PATHS.get(editor) || [];\n  };\n  var getDirtyPathKeys = editor => {\n    return DIRTY_PATH_KEYS.get(editor) || new Set();\n  };\n  var popDirtyPath = editor => {\n    var path = getDirtyPaths(editor).pop();\n    var key = path.join(',');\n    getDirtyPathKeys(editor).delete(key);\n    return path;\n  };\n  if (!Editor.isNormalizing(editor)) {\n    return;\n  }\n  if (force) {\n    var allPaths = Array.from(Node.nodes(editor), _ref => {\n      var [, p] = _ref;\n      return p;\n    });\n    var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n    DIRTY_PATHS.set(editor, allPaths);\n    DIRTY_PATH_KEYS.set(editor, allPathKeys);\n  }\n  if (getDirtyPaths(editor).length === 0) {\n    return;\n  }\n  Editor.withoutNormalizing(editor, () => {\n    /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */\n    for (var dirtyPath of getDirtyPaths(editor)) {\n      if (Node.has(editor, dirtyPath)) {\n        var entry = Editor.node(editor, dirtyPath);\n        var [node, _] = entry;\n        /*\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\n          So there is some risk here.\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n          by definition adding children to an empty node can't cause other paths to change.\n        */\n        if (Element.isElement(node) && node.children.length === 0) {\n          editor.normalizeNode(entry, {\n            operation\n          });\n        }\n      }\n    }\n    var dirtyPaths = getDirtyPaths(editor);\n    var initialDirtyPathsLength = dirtyPaths.length;\n    var iteration = 0;\n    while (dirtyPaths.length !== 0) {\n      if (!editor.shouldNormalize({\n        dirtyPaths,\n        iteration,\n        initialDirtyPathsLength,\n        operation\n      })) {\n        return;\n      }\n      var _dirtyPath = popDirtyPath(editor);\n      // If the node doesn't exist in the tree, it does not need to be normalized.\n      if (Node.has(editor, _dirtyPath)) {\n        var _entry = Editor.node(editor, _dirtyPath);\n        editor.normalizeNode(_entry, {\n          operation\n        });\n      }\n      iteration++;\n      dirtyPaths = getDirtyPaths(editor);\n    }\n  });\n};\n\nvar parent = function parent(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var path = Editor.path(editor, at, options);\n  var parentPath = Path.parent(path);\n  var entry = Editor.node(editor, parentPath);\n  return entry;\n};\n\nvar pathRef = function pathRef(editor, path) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: path,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var pathRefs = Editor.pathRefs(editor);\n      pathRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pathRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pathRefs = editor => {\n  var refs = PATH_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    PATH_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar path = function path(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    depth,\n    edge\n  } = options;\n  if (Path.isPath(at)) {\n    if (edge === 'start') {\n      var [, firstPath] = Node.first(editor, at);\n      at = firstPath;\n    } else if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      at = lastPath;\n    }\n  }\n  if (Range.isRange(at)) {\n    if (edge === 'start') {\n      at = Range.start(at);\n    } else if (edge === 'end') {\n      at = Range.end(at);\n    } else {\n      at = Path.common(at.anchor.path, at.focus.path);\n    }\n  }\n  if (Point.isPoint(at)) {\n    at = at.path;\n  }\n  if (depth != null) {\n    at = at.slice(0, depth);\n  }\n  return at;\n};\n\nvar pointRef = function pointRef(editor, point) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: point,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var pointRefs = Editor.pointRefs(editor);\n      pointRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.pointRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar pointRefs = editor => {\n  var refs = POINT_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    POINT_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar point = function point(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    edge = 'start'\n  } = options;\n  if (Path.isPath(at)) {\n    var path;\n    if (edge === 'end') {\n      var [, lastPath] = Node.last(editor, at);\n      path = lastPath;\n    } else {\n      var [, firstPath] = Node.first(editor, at);\n      path = firstPath;\n    }\n    var node = Node.get(editor, path);\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n    }\n    return {\n      path,\n      offset: edge === 'end' ? node.text.length : 0\n    };\n  }\n  if (Range.isRange(at)) {\n    var [start, end] = Range.edges(at);\n    return edge === 'start' ? start : end;\n  }\n  return at;\n};\n\nfunction positions(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function* () {\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false,\n      ignoreNonSelectable = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0;\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids,\n      ignoreNonSelectable\n    })) {\n      /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n          yield Editor.start(editor, path);\n          continue;\n        }\n        // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n        if (editor.isInline(node)) continue;\n        // Block element node - set `blockText` to its text content.\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          blockText = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          }, {\n            voids\n          });\n          isNewBlock = true;\n        }\n      }\n      /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path);\n        // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n        // Reset `leafText` counters for new text node.\n        if (isFirst) {\n          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n          leafTextOffset = first.offset; // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length;\n          leafTextOffset = reverse ? leafTextRemaining : 0;\n        }\n        // Yield position at the start of node (potentially).\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n          isNewBlock = false;\n        }\n        // Yield positions every (dynamically calculated) `distance` offset.\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break;\n            distance = calcDistance(blockText, unit, reverse);\n            // Split the string at the previously found distance and use the\n            // remaining string for the next iteration.\n            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n          }\n          // Advance `leafText` by the current `distance`.\n          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n          leafTextRemaining = leafTextRemaining - distance;\n          // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining;\n            break;\n          }\n          // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n          distance = 0;\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n        }\n      }\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n      return 1;\n    }\n  }();\n}\n\nvar previous = function previous(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    mode = 'lowest',\n    voids = false\n  } = options;\n  var {\n    match,\n    at = editor.selection\n  } = options;\n  if (!at) {\n    return;\n  }\n  var pointBeforeLocation = Editor.before(editor, at, {\n    voids\n  });\n  if (!pointBeforeLocation) {\n    return;\n  }\n  var [, to] = Editor.first(editor, []);\n  // The search location is from the start of the document to the path of\n  // the point before the location passed in\n  var span = [pointBeforeLocation.path, to];\n  if (Path.isPath(at) && at.length === 0) {\n    throw new Error(\"Cannot get the previous node from the root node!\");\n  }\n  if (match == null) {\n    if (Path.isPath(at)) {\n      var [parent] = Editor.parent(editor, at);\n      match = n => parent.children.includes(n);\n    } else {\n      match = () => true;\n    }\n  }\n  var [previous] = Editor.nodes(editor, {\n    reverse: true,\n    at: span,\n    match,\n    mode,\n    voids\n  });\n  return previous;\n};\n\nvar rangeRef = function rangeRef(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    affinity = 'forward'\n  } = options;\n  var ref = {\n    current: range,\n    affinity,\n    unref() {\n      var {\n        current\n      } = ref;\n      var rangeRefs = Editor.rangeRefs(editor);\n      rangeRefs.delete(ref);\n      ref.current = null;\n      return current;\n    }\n  };\n  var refs = Editor.rangeRefs(editor);\n  refs.add(ref);\n  return ref;\n};\n\nvar rangeRefs = editor => {\n  var refs = RANGE_REFS.get(editor);\n  if (!refs) {\n    refs = new Set();\n    RANGE_REFS.set(editor, refs);\n  }\n  return refs;\n};\n\nvar range = (editor, at, to) => {\n  if (Range.isRange(at) && !to) {\n    return at;\n  }\n  var start = Editor.start(editor, at);\n  var end = Editor.end(editor, to || at);\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar removeMark = (editor, key) => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    var match = (node, path) => {\n      if (!Text.isText(node)) {\n        return false; // marks can only be applied to text\n      }\n\n      var [parentNode, parentPath] = Editor.parent(editor, path);\n      return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n    };\n    var expandedSelection = Range.isExpanded(selection);\n    var markAcceptingVoidSelected = false;\n    if (!expandedSelection) {\n      var [selectedNode, selectedPath] = Editor.node(editor, selection);\n      if (selectedNode && match(selectedNode, selectedPath)) {\n        var [parentNode] = Editor.parent(editor, selectedPath);\n        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n      }\n    }\n    if (expandedSelection || markAcceptingVoidSelected) {\n      Transforms.unsetNodes(editor, key, {\n        match,\n        split: true,\n        voids: true\n      });\n    } else {\n      var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n      delete marks[key];\n      editor.marks = marks;\n      if (!FLUSHING.get(editor)) {\n        editor.onChange();\n      }\n    }\n  }\n};\n\nvar setNormalizing = (editor, isNormalizing) => {\n  NORMALIZING.set(editor, isNormalizing);\n};\n\nvar start = (editor, at) => {\n  return Editor.point(editor, at, {\n    edge: 'start'\n  });\n};\n\nvar string = function string(editor, at) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var range = Editor.range(editor, at);\n  var [start, end] = Range.edges(range);\n  var text = '';\n  for (var [node, path] of Editor.nodes(editor, {\n    at: range,\n    match: Text.isText,\n    voids\n  })) {\n    var t = node.text;\n    if (Path.equals(path, end.path)) {\n      t = t.slice(0, end.offset);\n    }\n    if (Path.equals(path, start.path)) {\n      t = t.slice(start.offset);\n    }\n    text += t;\n  }\n  return text;\n};\n\nvar unhangRange = function unhangRange(editor, range) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    voids = false\n  } = options;\n  var [start, end] = Range.edges(range);\n  // PERF: exit early if we can guarantee that the range isn't hanging.\n  if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n    return range;\n  }\n  var endBlock = Editor.above(editor, {\n    at: end,\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    voids\n  });\n  var blockPath = endBlock ? endBlock[1] : [];\n  var first = Editor.start(editor, start);\n  var before = {\n    anchor: first,\n    focus: end\n  };\n  var skip = true;\n  for (var [node, path] of Editor.nodes(editor, {\n    at: before,\n    match: Text.isText,\n    reverse: true,\n    voids\n  })) {\n    if (skip) {\n      skip = false;\n      continue;\n    }\n    if (node.text !== '' || Path.isBefore(path, blockPath)) {\n      end = {\n        path,\n        offset: node.text.length\n      };\n      break;\n    }\n  }\n  return {\n    anchor: start,\n    focus: end\n  };\n};\n\nvar withoutNormalizing = (editor, fn) => {\n  var value = Editor.isNormalizing(editor);\n  Editor.setNormalizing(editor, false);\n  try {\n    fn();\n  } finally {\n    Editor.setNormalizing(editor, value);\n  }\n  Editor.normalize(editor);\n};\n\nvar shouldMergeNodesRemovePrevNode = (editor, _ref, _ref2) => {\n  var [prevNode, prevPath] = _ref;\n  // If the target node that we're merging with is empty, remove it instead\n  // of merging the two. This is a common rich text editor behavior to\n  // prevent losing formatting when deleting entire nodes when you have a\n  // hanging selection.\n  // if prevNode is first child in parent,don't remove it.\n  return Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0;\n};\n\nvar deleteText = function deleteText(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var _Editor$void, _Editor$void2;\n    var {\n      reverse = false,\n      unit = 'character',\n      distance = 1,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      hanging = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    var isCollapsed = false;\n    if (Range.isRange(at) && Range.isCollapsed(at)) {\n      isCollapsed = true;\n      at = at.anchor;\n    }\n    if (Point.isPoint(at)) {\n      var furthestVoid = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      if (!voids && furthestVoid) {\n        var [, voidPath] = furthestVoid;\n        at = voidPath;\n      } else {\n        var opts = {\n          unit,\n          distance\n        };\n        var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n        at = {\n          anchor: at,\n          focus: target\n        };\n        hanging = true;\n      }\n    }\n    if (Path.isPath(at)) {\n      Transforms.removeNodes(editor, {\n        at,\n        voids\n      });\n      return;\n    }\n    if (Range.isCollapsed(at)) {\n      return;\n    }\n    if (!hanging) {\n      var [, _end] = Range.edges(at);\n      var endOfDoc = Editor.end(editor, []);\n      if (!Point.equals(_end, endOfDoc)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n    }\n    var [start, end] = Range.edges(at);\n    var startBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: start,\n      voids\n    });\n    var endBlock = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at: end,\n      voids\n    });\n    var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n    var isSingleText = Path.equals(start.path, end.path);\n    var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n      at: start,\n      mode: 'highest'\n    })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n      at: start,\n      mode: 'highest'\n    });\n    var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n      at: end,\n      mode: 'highest'\n    })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n      at: end,\n      mode: 'highest'\n    });\n    // If the start or end points are inside an inline void, nudge them out.\n    if (startNonEditable) {\n      var before = Editor.before(editor, start);\n      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n        start = before;\n      }\n    }\n    if (endNonEditable) {\n      var after = Editor.after(editor, end);\n      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n        end = after;\n      }\n    }\n    // Get the highest nodes that are completely inside the range, as well as\n    // the start and end nodes.\n    var matches = [];\n    var lastPath;\n    for (var entry of Editor.nodes(editor, {\n      at,\n      voids\n    })) {\n      var [node, path] = entry;\n      if (lastPath && Path.compare(path, lastPath) === 0) {\n        continue;\n      }\n      if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n        matches.push(entry);\n        lastPath = path;\n      }\n    }\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    var startRef = Editor.pointRef(editor, start);\n    var endRef = Editor.pointRef(editor, end);\n    var removedText = '';\n    if (!isSingleText && !startNonEditable) {\n      var _point = startRef.current;\n      var [_node] = Editor.leaf(editor, _point);\n      var {\n        path: _path\n      } = _point;\n      var {\n        offset\n      } = start;\n      var text = _node.text.slice(offset);\n      if (text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset,\n          text\n        });\n        removedText = text;\n      }\n    }\n    pathRefs.reverse().map(r => r.unref()).filter(r => r !== null).forEach(p => Transforms.removeNodes(editor, {\n      at: p,\n      voids\n    }));\n    if (!endNonEditable) {\n      var _point2 = endRef.current;\n      var [_node2] = Editor.leaf(editor, _point2);\n      var {\n        path: _path2\n      } = _point2;\n      var _offset = isSingleText ? start.offset : 0;\n      var _text = _node2.text.slice(_offset, end.offset);\n      if (_text.length > 0) {\n        editor.apply({\n          type: 'remove_text',\n          path: _path2,\n          offset: _offset,\n          text: _text\n        });\n        removedText = _text;\n      }\n    }\n    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n      Transforms.mergeNodes(editor, {\n        at: endRef.current,\n        hanging: true,\n        voids\n      });\n    }\n    // For Thai script, deleting N character(s) backward should delete\n    // N code point(s) instead of an entire grapheme cluster.\n    // Therefore, the remaining code points should be inserted back.\n    if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n      Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n    }\n    var startUnref = startRef.unref();\n    var endUnref = endRef.unref();\n    var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n    if (options.at == null && point) {\n      Transforms.select(editor, point);\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(editor, fragment) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false\n    } = options;\n    var {\n      at = getDefaultInsertLocation(editor),\n      batchDirty = true\n    } = options;\n    if (!fragment.length) {\n      return;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        if (!voids && Editor.void(editor, {\n          at: end\n        })) {\n          return;\n        }\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    } else if (Path.isPath(at)) {\n      at = Editor.start(editor, at);\n    }\n    if (!voids && Editor.void(editor, {\n      at\n    })) {\n      return;\n    }\n    // If the insert point is at the edge of an inline node, move it outside\n    // instead since it will need to be split otherwise.\n    var inlineElementMatch = Editor.above(editor, {\n      at,\n      match: n => Element.isElement(n) && Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    if (inlineElementMatch) {\n      var [, _inlinePath] = inlineElementMatch;\n      if (Editor.isEnd(editor, at, _inlinePath)) {\n        var after = Editor.after(editor, _inlinePath);\n        at = after;\n      } else if (Editor.isStart(editor, at, _inlinePath)) {\n        var before = Editor.before(editor, _inlinePath);\n        at = before;\n      }\n    }\n    var blockMatch = Editor.above(editor, {\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      at,\n      voids\n    });\n    var [, blockPath] = blockMatch;\n    var isBlockStart = Editor.isStart(editor, at, blockPath);\n    var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n    var isBlockEmpty = isBlockStart && isBlockEnd;\n    var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n    var mergeEnd = !isBlockEnd;\n    var [, firstPath] = Node.first({\n      children: fragment\n    }, []);\n    var [, lastPath] = Node.last({\n      children: fragment\n    }, []);\n    var matches = [];\n    var matcher = _ref => {\n      var [n, p] = _ref;\n      var isRoot = p.length === 0;\n      if (isRoot) {\n        return false;\n      }\n      if (isBlockEmpty) {\n        return true;\n      }\n      if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n        return false;\n      }\n      return true;\n    };\n    for (var entry of Node.nodes({\n      children: fragment\n    }, {\n      pass: matcher\n    })) {\n      if (matcher(entry)) {\n        matches.push(entry);\n      }\n    }\n    var starts = [];\n    var middles = [];\n    var ends = [];\n    var starting = true;\n    var hasBlocks = false;\n    for (var [node] of matches) {\n      if (Element.isElement(node) && !editor.isInline(node)) {\n        starting = false;\n        hasBlocks = true;\n        middles.push(node);\n      } else if (starting) {\n        starts.push(node);\n      } else {\n        ends.push(node);\n      }\n    }\n    var [inlineMatch] = Editor.nodes(editor, {\n      at,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids\n    });\n    var [, inlinePath] = inlineMatch;\n    var isInlineStart = Editor.isStart(editor, at, inlinePath);\n    var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n    var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n    var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.splitNodes(editor, {\n      at,\n      match: n => hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n      mode: hasBlocks ? 'lowest' : 'highest',\n      always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n      voids\n    });\n    var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n    Transforms.insertNodes(editor, starts, {\n      at: startRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty\n    });\n    if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n      Transforms.delete(editor, {\n        at: blockPath,\n        voids\n      });\n    }\n    Transforms.insertNodes(editor, middles, {\n      at: middleRef.current,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n      mode: 'lowest',\n      voids,\n      batchDirty\n    });\n    Transforms.insertNodes(editor, ends, {\n      at: endRef.current,\n      match: n => Text.isText(n) || Editor.isInline(editor, n),\n      mode: 'highest',\n      voids,\n      batchDirty\n    });\n    if (!options.at) {\n      var path;\n      if (ends.length > 0 && endRef.current) {\n        path = Path.previous(endRef.current);\n      } else if (middles.length > 0 && middleRef.current) {\n        path = Path.previous(middleRef.current);\n      } else if (startRef.current) {\n        path = Path.previous(startRef.current);\n      }\n      if (path) {\n        var _end = Editor.end(editor, path);\n        Transforms.select(editor, _end);\n      }\n    }\n    startRef.unref();\n    middleRef.unref();\n    endRef.unref();\n  });\n};\n\nvar collapse = function collapse(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    edge = 'anchor'\n  } = options;\n  var {\n    selection\n  } = editor;\n  if (!selection) {\n    return;\n  } else if (edge === 'anchor') {\n    Transforms.select(editor, selection.anchor);\n  } else if (edge === 'focus') {\n    Transforms.select(editor, selection.focus);\n  } else if (edge === 'start') {\n    var [start] = Range.edges(selection);\n    Transforms.select(editor, start);\n  } else if (edge === 'end') {\n    var [, end] = Range.edges(selection);\n    Transforms.select(editor, end);\n  }\n};\n\nvar deselect = editor => {\n  var {\n    selection\n  } = editor;\n  if (selection) {\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: null\n    });\n  }\n};\n\nvar move = function move(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    distance = 1,\n    unit = 'character',\n    reverse = false\n  } = options;\n  var {\n    edge = null\n  } = options;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  var opts = {\n    distance,\n    unit,\n    ignoreNonSelectable: true\n  };\n  var props = {};\n  if (edge == null || edge === 'anchor') {\n    var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n    if (point) {\n      props.anchor = point;\n    }\n  }\n  if (edge == null || edge === 'focus') {\n    var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n    if (_point) {\n      props.focus = _point;\n    }\n  }\n  Transforms.setSelection(editor, props);\n};\n\nvar select = (editor, target) => {\n  var {\n    selection\n  } = editor;\n  target = Editor.range(editor, target);\n  if (selection) {\n    Transforms.setSelection(editor, target);\n    return;\n  }\n  if (!Range.isRange(target)) {\n    throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n  }\n  editor.apply({\n    type: 'set_selection',\n    properties: selection,\n    newProperties: target\n  });\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar setPoint = function setPoint(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var {\n    selection\n  } = editor;\n  var {\n    edge = 'both'\n  } = options;\n  if (!selection) {\n    return;\n  }\n  if (edge === 'start') {\n    edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n  }\n  if (edge === 'end') {\n    edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n  }\n  var {\n    anchor,\n    focus\n  } = selection;\n  var point = edge === 'anchor' ? anchor : focus;\n  Transforms.setSelection(editor, {\n    [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n  });\n};\n\nvar setSelection = (editor, props) => {\n  var {\n    selection\n  } = editor;\n  var oldProps = {};\n  var newProps = {};\n  if (!selection) {\n    return;\n  }\n  for (var k in props) {\n    if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n      oldProps[k] = selection[k];\n      newProps[k] = props[k];\n    }\n  }\n  if (Object.keys(oldProps).length > 0) {\n    editor.apply({\n      type: 'set_selection',\n      properties: oldProps,\n      newProperties: newProps\n    });\n  }\n};\n\nvar insertNodes = function insertNodes(editor, nodes) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest',\n      batchDirty = true\n    } = options;\n    var {\n      at,\n      match,\n      select\n    } = options;\n    if (Node.isNode(nodes)) {\n      nodes = [nodes];\n    }\n    if (nodes.length === 0) {\n      return;\n    }\n    var [node] = nodes;\n    if (!at) {\n      at = getDefaultInsertLocation(editor);\n      if (select !== false) {\n        select = true;\n      }\n    }\n    if (select == null) {\n      select = false;\n    }\n    if (Range.isRange(at)) {\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n      }\n    }\n    if (Point.isPoint(at)) {\n      if (match == null) {\n        if (Text.isText(node)) {\n          match = n => Text.isText(n);\n        } else if (editor.isInline(node)) {\n          match = n => Text.isText(n) || Editor.isInline(editor, n);\n        } else {\n          match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      }\n      var [entry] = Editor.nodes(editor, {\n        at: at.path,\n        match,\n        mode,\n        voids\n      });\n      if (entry) {\n        var [, matchPath] = entry;\n        var pathRef = Editor.pathRef(editor, matchPath);\n        var isAtEnd = Editor.isEnd(editor, at, matchPath);\n        Transforms.splitNodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n        var path = pathRef.unref();\n        at = isAtEnd ? Path.next(path) : path;\n      } else {\n        return;\n      }\n    }\n    var parentPath = Path.parent(at);\n    var index = at[at.length - 1];\n    if (!voids && Editor.void(editor, {\n      at: parentPath\n    })) {\n      return;\n    }\n    if (batchDirty) {\n      // PERF: batch update dirty paths\n      // batched ops used to transform existing dirty paths\n      var batchedOps = [];\n      var newDirtyPaths = Path.levels(parentPath);\n      batchDirtyPaths(editor, () => {\n        var _loop = function _loop() {\n          var path = parentPath.concat(index);\n          index++;\n          var op = {\n            type: 'insert_node',\n            path,\n            node: _node\n          };\n          editor.apply(op);\n          at = Path.next(at);\n          batchedOps.push(op);\n          if (!Text.isText) {\n            newDirtyPaths.push(path);\n          } else {\n            newDirtyPaths.push(...Array.from(Node.nodes(_node), _ref => {\n              var [, p] = _ref;\n              return path.concat(p);\n            }));\n          }\n        };\n        for (var _node of nodes) {\n          _loop();\n        }\n      }, () => {\n        updateDirtyPaths(editor, newDirtyPaths, p => {\n          var newPath = p;\n          for (var op of batchedOps) {\n            if (Path.operationCanTransformPath(op)) {\n              newPath = Path.transform(newPath, op);\n              if (!newPath) {\n                return null;\n              }\n            }\n          }\n          return newPath;\n        });\n      });\n    } else {\n      for (var _node2 of nodes) {\n        var _path = parentPath.concat(index);\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node2\n        });\n        at = Path.next(at);\n      }\n    }\n    at = Path.previous(at);\n    if (select) {\n      var point = Editor.end(editor, at);\n      if (point) {\n        Transforms.select(editor, point);\n      }\n    }\n  });\n};\n\nvar liftNodes = function liftNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!at) {\n      return;\n    }\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      if (path.length < 2) {\n        throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n      }\n      var parentNodeEntry = Editor.node(editor, Path.parent(path));\n      var [parent, parentPath] = parentNodeEntry;\n      var index = path[path.length - 1];\n      var {\n        length\n      } = parent.children;\n      if (length === 1) {\n        var toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: toPath,\n          voids\n        });\n        Transforms.removeNodes(editor, {\n          at: parentPath,\n          voids\n        });\n      } else if (index === 0) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: parentPath,\n          voids\n        });\n      } else if (index === length - 1) {\n        var _toPath = Path.next(parentPath);\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath,\n          voids\n        });\n      } else {\n        var splitPath = Path.next(path);\n        var _toPath2 = Path.next(parentPath);\n        Transforms.splitNodes(editor, {\n          at: splitPath,\n          voids\n        });\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: _toPath2,\n          voids\n        });\n      }\n    }\n  });\n};\n\nvar _excluded = [\"text\"],\n  _excluded2 = [\"children\"];\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\nvar mergeNodes = function mergeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n        match = n => parent.children.includes(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    if (Range.isRange(at)) {\n      if (Range.isCollapsed(at)) {\n        at = at.anchor;\n      } else {\n        var [, end] = Range.edges(at);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n          at\n        });\n        at = pointRef.unref();\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n    }\n    var [current] = Editor.nodes(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    var prev = Editor.previous(editor, {\n      at,\n      match,\n      voids,\n      mode\n    });\n    if (!current || !prev) {\n      return;\n    }\n    var [node, path] = current;\n    var [prevNode, prevPath] = prev;\n    if (path.length === 0 || prevPath.length === 0) {\n      return;\n    }\n    var newPath = Path.next(prevPath);\n    var commonPath = Path.common(path, prevPath);\n    var isPreviousSibling = Path.isSibling(path, prevPath);\n    var levels = Array.from(Editor.levels(editor, {\n      at: path\n    }), _ref => {\n      var [n] = _ref;\n      return n;\n    }).slice(commonPath.length).slice(0, -1);\n    // Determine if the merge will leave an ancestor of the path empty as a\n    // result, in which case we'll want to remove it after merging.\n    var emptyAncestor = Editor.above(editor, {\n      at: path,\n      mode: 'highest',\n      match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n    });\n    var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n    var properties;\n    var position;\n    // Ensure that the nodes are equivalent, and figure out what the position\n    // and extra properties of the merge will be.\n    if (Text.isText(node) && Text.isText(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded);\n      position = prevNode.text.length;\n      properties = rest;\n    } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n      var rest = _objectWithoutProperties(node, _excluded2);\n      position = prevNode.children.length;\n      properties = rest;\n    } else {\n      throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n    }\n    // If the node isn't already the next sibling of the previous node, move\n    // it so that it is before merging.\n    if (!isPreviousSibling) {\n      Transforms.moveNodes(editor, {\n        at: path,\n        to: newPath,\n        voids\n      });\n    }\n    // If there was going to be an empty ancestor of the node that was merged,\n    // we remove it from the tree.\n    if (emptyRef) {\n      Transforms.removeNodes(editor, {\n        at: emptyRef.current,\n        voids\n      });\n    }\n    if (Editor.shouldMergeNodesRemovePrevNode(editor, prev, current)) {\n      Transforms.removeNodes(editor, {\n        at: prevPath,\n        voids\n      });\n    } else {\n      editor.apply({\n        type: 'merge_node',\n        path: newPath,\n        position,\n        properties\n      });\n    }\n    if (emptyRef) {\n      emptyRef.unref();\n    }\n  });\n};\n\nvar moveNodes = (editor, options) => {\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      to,\n      at = editor.selection,\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    var toRef = Editor.pathRef(editor, to);\n    var targets = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(targets, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      var newPath = toRef.current;\n      if (path.length !== 0) {\n        editor.apply({\n          type: 'move_node',\n          path,\n          newPath\n        });\n      }\n      if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n        // When performing a sibling move to a later index, the path at the destination is shifted\n        // to before the insertion point instead of after. To ensure our group of nodes are inserted\n        // in the correct order we increment toRef to account for that\n        toRef.current = Path.next(toRef.current);\n      }\n    }\n    toRef.unref();\n  });\n};\n\nvar removeNodes = function removeNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      hanging = false,\n      voids = false,\n      mode = 'lowest'\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    var depths = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(depths, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    });\n    for (var pathRef of pathRefs) {\n      var path = pathRef.unref();\n      if (path) {\n        var [node] = Editor.node(editor, path);\n        editor.apply({\n          type: 'remove_node',\n          path,\n          node\n        });\n      }\n    }\n  });\n};\n\nvar setNodes = function setNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      match,\n      at = editor.selection,\n      compare,\n      merge\n    } = options;\n    var {\n      hanging = false,\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (!hanging && Range.isRange(at)) {\n      at = Editor.unhangRange(editor, at, {\n        voids\n      });\n    }\n    if (split && Range.isRange(at)) {\n      if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n        // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n        // set that won't get normalized away\n        return;\n      }\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      var [start, end] = Range.edges(at);\n      var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n      var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        mode: splitMode,\n        voids,\n        always: !endAtEndOfNode\n      });\n      var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        mode: splitMode,\n        voids,\n        always: !startAtStartOfNode\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    if (!compare) {\n      compare = (prop, nodeProp) => prop !== nodeProp;\n    }\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    })) {\n      var properties = {};\n      // FIXME: is this correct?\n      var newProperties = {};\n      // You can't set properties on the editor node.\n      if (path.length === 0) {\n        continue;\n      }\n      var hasChanges = false;\n      for (var k in props) {\n        if (k === 'children' || k === 'text') {\n          continue;\n        }\n        if (compare(props[k], node[k])) {\n          hasChanges = true;\n          // Omit new properties from the old properties list\n          if (node.hasOwnProperty(k)) properties[k] = node[k];\n          // Omit properties that have been removed from the new properties list\n          if (merge) {\n            if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n          } else {\n            if (props[k] != null) newProperties[k] = props[k];\n          }\n        }\n      }\n      if (hasChanges) {\n        editor.apply({\n          type: 'set_node',\n          path,\n          properties,\n          newProperties\n        });\n      }\n    }\n  });\n};\n\n/**\n * Convert a range into a point by deleting it's content.\n */\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\nvar splitNodes = function splitNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection,\n      height = 0,\n      always = false\n    } = options;\n    if (match == null) {\n      match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (Range.isRange(at)) {\n      at = deleteRange(editor, at);\n    }\n    // If the target is a path, the default height-skipping and position\n    // counters need to account for us potentially splitting at a non-leaf.\n    if (Path.isPath(at)) {\n      var path = at;\n      var point = Editor.point(editor, path);\n      var [parent] = Editor.parent(editor, path);\n      match = n => n === parent;\n      height = point.path.length - path.length + 1;\n      at = point;\n      always = true;\n    }\n    if (!at) {\n      return;\n    }\n    var beforeRef = Editor.pointRef(editor, at, {\n      affinity: 'backward'\n    });\n    var afterRef;\n    try {\n      var [highest] = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      if (!highest) {\n        return;\n      }\n      var voidMatch = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n      if (!voids && voidMatch) {\n        var [voidNode, voidPath] = voidMatch;\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n          at = after;\n          always = true;\n        }\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n      afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var [, highestPath] = highest;\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      for (var [node, _path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids\n      })) {\n        var split = false;\n        if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n          break;\n        }\n        var _point = beforeRef.current;\n        var isEnd = Editor.isEnd(editor, _point, _path);\n        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n          split = true;\n          var properties = Node.extractProps(node);\n          editor.apply({\n            type: 'split_node',\n            path: _path,\n            position,\n            properties\n          });\n        }\n        position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n      }\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n        Transforms.select(editor, _point2);\n      }\n    } finally {\n      var _afterRef;\n      beforeRef.unref();\n      (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n    }\n  });\n};\n\nvar unsetNodes = function unsetNodes(editor, props) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!Array.isArray(props)) {\n    props = [props];\n  }\n  var obj = {};\n  for (var key of props) {\n    obj[key] = null;\n  }\n  Transforms.setNodes(editor, obj, options);\n};\n\nvar unwrapNodes = function unwrapNodes(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      at = editor.selection,\n      match\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      match = Path.isPath(at) ? matchPath(editor, at) : n => Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n    if (Path.isPath(at)) {\n      at = Editor.range(editor, at);\n    }\n    var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n    var matches = Editor.nodes(editor, {\n      at,\n      match,\n      mode,\n      voids\n    });\n    var pathRefs = Array.from(matches, _ref => {\n      var [, p] = _ref;\n      return Editor.pathRef(editor, p);\n    }\n    // unwrapNode will call liftNode which does not support splitting the node when nested.\n    // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n    // that wrap target node. So we reverse the order.\n    ).reverse();\n    var _loop = function _loop() {\n      var path = pathRef.unref();\n      var [node] = Editor.node(editor, path);\n      var range = Editor.range(editor, path);\n      if (split && rangeRef) {\n        range = Range.intersection(rangeRef.current, range);\n      }\n      Transforms.liftNodes(editor, {\n        at: range,\n        match: n => Element.isAncestor(node) && node.children.includes(n),\n        voids\n      });\n    };\n    for (var pathRef of pathRefs) {\n      _loop();\n    }\n    if (rangeRef) {\n      rangeRef.unref();\n    }\n  });\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar wrapNodes = function wrapNodes(editor, element) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Editor.withoutNormalizing(editor, () => {\n    var {\n      mode = 'lowest',\n      split = false,\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n    if (!at) {\n      return;\n    }\n    if (match == null) {\n      if (Path.isPath(at)) {\n        match = matchPath(editor, at);\n      } else if (editor.isInline(element)) {\n        match = n => Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n      } else {\n        match = n => Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }\n    if (split && Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      var rangeRef = Editor.rangeRef(editor, at, {\n        affinity: 'inward'\n      });\n      Transforms.splitNodes(editor, {\n        at: end,\n        match,\n        voids\n      });\n      Transforms.splitNodes(editor, {\n        at: start,\n        match,\n        voids\n      });\n      at = rangeRef.unref();\n      if (options.at == null) {\n        Transforms.select(editor, at);\n      }\n    }\n    var roots = Array.from(Editor.nodes(editor, {\n      at,\n      match: editor.isInline(element) ? n => Element.isElement(n) && Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n      mode: 'lowest',\n      voids\n    }));\n    var _loop = function _loop() {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n        if (!a) {\n          return 0; // continue\n        }\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n        if (matches.length > 0) {\n          var [first] = matches;\n          var last = matches[matches.length - 1];\n          var [, firstPath] = first;\n          var [, lastPath] = last;\n          if (firstPath.length === 0 && lastPath.length === 0) {\n            // if there's no matching parent - usually means the node is an editor - don't do anything\n            return 0; // continue\n          }\n          var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n          var range = Editor.range(editor, firstPath, lastPath);\n          var commonNodeEntry = Editor.node(editor, commonPath);\n          var [commonNode] = commonNodeEntry;\n          var depth = commonPath.length + 1;\n          var wrapperPath = Path.next(lastPath.slice(0, depth));\n          var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n            children: []\n          });\n          Transforms.insertNodes(editor, wrapper, {\n            at: wrapperPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids\n          });\n        }\n      },\n      _ret;\n    for (var [, rootPath] of roots) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n    }\n  });\n};\n\n/**\n * Create a new Slate `Editor` object.\n */\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isElementReadOnly: () => false,\n    isInline: () => false,\n    isSelectable: () => true,\n    isVoid: () => false,\n    markableVoid: () => false,\n    onChange: () => {},\n    // Core\n    apply: function apply$1() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return apply(editor, ...args);\n    },\n    // Editor\n    addMark: function addMark$1() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return addMark(editor, ...args);\n    },\n    deleteBackward: function deleteBackward$1() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return deleteBackward(editor, ...args);\n    },\n    deleteForward: function deleteForward$1() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return deleteForward(editor, ...args);\n    },\n    deleteFragment: function deleteFragment$1() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return deleteFragment(editor, ...args);\n    },\n    getFragment: function getFragment$1() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return getFragment(editor, ...args);\n    },\n    insertBreak: function insertBreak$1() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return insertBreak(editor, ...args);\n    },\n    insertSoftBreak: function insertSoftBreak$1() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n      return insertSoftBreak(editor, ...args);\n    },\n    insertFragment: function insertFragment$1() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n      return insertFragment(editor, ...args);\n    },\n    insertNode: function insertNode$1() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n      return insertNode(editor, ...args);\n    },\n    insertText: function insertText$1() {\n      for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n        args[_key11] = arguments[_key11];\n      }\n      return insertText(editor, ...args);\n    },\n    normalizeNode: function normalizeNode$1() {\n      for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        args[_key12] = arguments[_key12];\n      }\n      return normalizeNode(editor, ...args);\n    },\n    removeMark: function removeMark$1() {\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n      return removeMark(editor, ...args);\n    },\n    getDirtyPaths: function getDirtyPaths$1() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n      return getDirtyPaths(editor, ...args);\n    },\n    shouldNormalize: function shouldNormalize$1() {\n      for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        args[_key15] = arguments[_key15];\n      }\n      return shouldNormalize(editor, ...args);\n    },\n    // Editor interface\n    above: function above$1() {\n      for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        args[_key16] = arguments[_key16];\n      }\n      return above(editor, ...args);\n    },\n    after: function after$1() {\n      for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n        args[_key17] = arguments[_key17];\n      }\n      return after(editor, ...args);\n    },\n    before: function before$1() {\n      for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {\n        args[_key18] = arguments[_key18];\n      }\n      return before(editor, ...args);\n    },\n    collapse: function collapse$1() {\n      for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {\n        args[_key19] = arguments[_key19];\n      }\n      return collapse(editor, ...args);\n    },\n    delete: function _delete() {\n      for (var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {\n        args[_key20] = arguments[_key20];\n      }\n      return deleteText(editor, ...args);\n    },\n    deselect: function deselect$1() {\n      for (var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++) {\n        args[_key21] = arguments[_key21];\n      }\n      return deselect(editor, ...args);\n    },\n    edges: function edges$1() {\n      for (var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {\n        args[_key22] = arguments[_key22];\n      }\n      return edges(editor, ...args);\n    },\n    elementReadOnly: function elementReadOnly$1() {\n      for (var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {\n        args[_key23] = arguments[_key23];\n      }\n      return elementReadOnly(editor, ...args);\n    },\n    end: function end$1() {\n      for (var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {\n        args[_key24] = arguments[_key24];\n      }\n      return end(editor, ...args);\n    },\n    first: function first$1() {\n      for (var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {\n        args[_key25] = arguments[_key25];\n      }\n      return first(editor, ...args);\n    },\n    fragment: function fragment$1() {\n      for (var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {\n        args[_key26] = arguments[_key26];\n      }\n      return fragment(editor, ...args);\n    },\n    getMarks: function getMarks() {\n      for (var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++) {\n        args[_key27] = arguments[_key27];\n      }\n      return marks(editor, ...args);\n    },\n    hasBlocks: function hasBlocks$1() {\n      for (var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++) {\n        args[_key28] = arguments[_key28];\n      }\n      return hasBlocks(editor, ...args);\n    },\n    hasInlines: function hasInlines$1() {\n      for (var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++) {\n        args[_key29] = arguments[_key29];\n      }\n      return hasInlines(editor, ...args);\n    },\n    hasPath: function hasPath$1() {\n      for (var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++) {\n        args[_key30] = arguments[_key30];\n      }\n      return hasPath(editor, ...args);\n    },\n    hasTexts: function hasTexts$1() {\n      for (var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++) {\n        args[_key31] = arguments[_key31];\n      }\n      return hasTexts(editor, ...args);\n    },\n    insertNodes: function insertNodes$1() {\n      for (var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++) {\n        args[_key32] = arguments[_key32];\n      }\n      return insertNodes(editor, ...args);\n    },\n    isBlock: function isBlock$1() {\n      for (var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++) {\n        args[_key33] = arguments[_key33];\n      }\n      return isBlock(editor, ...args);\n    },\n    isEdge: function isEdge$1() {\n      for (var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++) {\n        args[_key34] = arguments[_key34];\n      }\n      return isEdge(editor, ...args);\n    },\n    isEmpty: function isEmpty$1() {\n      for (var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++) {\n        args[_key35] = arguments[_key35];\n      }\n      return isEmpty(editor, ...args);\n    },\n    isEnd: function isEnd$1() {\n      for (var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++) {\n        args[_key36] = arguments[_key36];\n      }\n      return isEnd(editor, ...args);\n    },\n    isNormalizing: function isNormalizing$1() {\n      for (var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++) {\n        args[_key37] = arguments[_key37];\n      }\n      return isNormalizing(editor, ...args);\n    },\n    isStart: function isStart$1() {\n      for (var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++) {\n        args[_key38] = arguments[_key38];\n      }\n      return isStart(editor, ...args);\n    },\n    last: function last$1() {\n      for (var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++) {\n        args[_key39] = arguments[_key39];\n      }\n      return last(editor, ...args);\n    },\n    leaf: function leaf$1() {\n      for (var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++) {\n        args[_key40] = arguments[_key40];\n      }\n      return leaf(editor, ...args);\n    },\n    levels: function levels$1() {\n      for (var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++) {\n        args[_key41] = arguments[_key41];\n      }\n      return levels(editor, ...args);\n    },\n    liftNodes: function liftNodes$1() {\n      for (var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++) {\n        args[_key42] = arguments[_key42];\n      }\n      return liftNodes(editor, ...args);\n    },\n    mergeNodes: function mergeNodes$1() {\n      for (var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++) {\n        args[_key43] = arguments[_key43];\n      }\n      return mergeNodes(editor, ...args);\n    },\n    move: function move$1() {\n      for (var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++) {\n        args[_key44] = arguments[_key44];\n      }\n      return move(editor, ...args);\n    },\n    moveNodes: function moveNodes$1() {\n      for (var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++) {\n        args[_key45] = arguments[_key45];\n      }\n      return moveNodes(editor, ...args);\n    },\n    next: function next$1() {\n      for (var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++) {\n        args[_key46] = arguments[_key46];\n      }\n      return next(editor, ...args);\n    },\n    node: function node$1() {\n      for (var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++) {\n        args[_key47] = arguments[_key47];\n      }\n      return node(editor, ...args);\n    },\n    nodes: function nodes$1() {\n      for (var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++) {\n        args[_key48] = arguments[_key48];\n      }\n      return nodes(editor, ...args);\n    },\n    normalize: function normalize$1() {\n      for (var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++) {\n        args[_key49] = arguments[_key49];\n      }\n      return normalize(editor, ...args);\n    },\n    parent: function parent$1() {\n      for (var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++) {\n        args[_key50] = arguments[_key50];\n      }\n      return parent(editor, ...args);\n    },\n    path: function path$1() {\n      for (var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++) {\n        args[_key51] = arguments[_key51];\n      }\n      return path(editor, ...args);\n    },\n    pathRef: function pathRef$1() {\n      for (var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++) {\n        args[_key52] = arguments[_key52];\n      }\n      return pathRef(editor, ...args);\n    },\n    pathRefs: function pathRefs$1() {\n      for (var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++) {\n        args[_key53] = arguments[_key53];\n      }\n      return pathRefs(editor, ...args);\n    },\n    point: function point$1() {\n      for (var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++) {\n        args[_key54] = arguments[_key54];\n      }\n      return point(editor, ...args);\n    },\n    pointRef: function pointRef$1() {\n      for (var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++) {\n        args[_key55] = arguments[_key55];\n      }\n      return pointRef(editor, ...args);\n    },\n    pointRefs: function pointRefs$1() {\n      for (var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++) {\n        args[_key56] = arguments[_key56];\n      }\n      return pointRefs(editor, ...args);\n    },\n    positions: function positions$1() {\n      for (var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++) {\n        args[_key57] = arguments[_key57];\n      }\n      return positions(editor, ...args);\n    },\n    previous: function previous$1() {\n      for (var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++) {\n        args[_key58] = arguments[_key58];\n      }\n      return previous(editor, ...args);\n    },\n    range: function range$1() {\n      for (var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++) {\n        args[_key59] = arguments[_key59];\n      }\n      return range(editor, ...args);\n    },\n    rangeRef: function rangeRef$1() {\n      for (var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++) {\n        args[_key60] = arguments[_key60];\n      }\n      return rangeRef(editor, ...args);\n    },\n    rangeRefs: function rangeRefs$1() {\n      for (var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++) {\n        args[_key61] = arguments[_key61];\n      }\n      return rangeRefs(editor, ...args);\n    },\n    removeNodes: function removeNodes$1() {\n      for (var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++) {\n        args[_key62] = arguments[_key62];\n      }\n      return removeNodes(editor, ...args);\n    },\n    select: function select$1() {\n      for (var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++) {\n        args[_key63] = arguments[_key63];\n      }\n      return select(editor, ...args);\n    },\n    setNodes: function setNodes$1() {\n      for (var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++) {\n        args[_key64] = arguments[_key64];\n      }\n      return setNodes(editor, ...args);\n    },\n    setNormalizing: function setNormalizing$1() {\n      for (var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++) {\n        args[_key65] = arguments[_key65];\n      }\n      return setNormalizing(editor, ...args);\n    },\n    setPoint: function setPoint$1() {\n      for (var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++) {\n        args[_key66] = arguments[_key66];\n      }\n      return setPoint(editor, ...args);\n    },\n    setSelection: function setSelection$1() {\n      for (var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++) {\n        args[_key67] = arguments[_key67];\n      }\n      return setSelection(editor, ...args);\n    },\n    splitNodes: function splitNodes$1() {\n      for (var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++) {\n        args[_key68] = arguments[_key68];\n      }\n      return splitNodes(editor, ...args);\n    },\n    start: function start$1() {\n      for (var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++) {\n        args[_key69] = arguments[_key69];\n      }\n      return start(editor, ...args);\n    },\n    string: function string$1() {\n      for (var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++) {\n        args[_key70] = arguments[_key70];\n      }\n      return string(editor, ...args);\n    },\n    unhangRange: function unhangRange$1() {\n      for (var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++) {\n        args[_key71] = arguments[_key71];\n      }\n      return unhangRange(editor, ...args);\n    },\n    unsetNodes: function unsetNodes$1() {\n      for (var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++) {\n        args[_key72] = arguments[_key72];\n      }\n      return unsetNodes(editor, ...args);\n    },\n    unwrapNodes: function unwrapNodes$1() {\n      for (var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++) {\n        args[_key73] = arguments[_key73];\n      }\n      return unwrapNodes(editor, ...args);\n    },\n    void: function _void() {\n      for (var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++) {\n        args[_key74] = arguments[_key74];\n      }\n      return getVoid(editor, ...args);\n    },\n    withoutNormalizing: function withoutNormalizing$1() {\n      for (var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++) {\n        args[_key75] = arguments[_key75];\n      }\n      return withoutNormalizing(editor, ...args);\n    },\n    wrapNodes: function wrapNodes$1() {\n      for (var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++) {\n        args[_key76] = arguments[_key76];\n      }\n      return wrapNodes(editor, ...args);\n    },\n    shouldMergeNodesRemovePrevNode: function shouldMergeNodesRemovePrevNode$1() {\n      for (var _len77 = arguments.length, args = new Array(_len77), _key77 = 0; _key77 < _len77; _key77++) {\n        args[_key77] = arguments[_key77];\n      }\n      return shouldMergeNodesRemovePrevNode(editor, ...args);\n    }\n  };\n  return editor;\n};\n\nexport { Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Scrubber, Span, Text, Transforms, above, addMark, after, apply, before, collapse, createEditor, deleteBackward, deleteForward, deleteFragment, deleteText, deselect, edges, elementReadOnly, end, first, fragment, getDirtyPaths, getFragment, getVoid, hasBlocks, hasInlines, hasPath, hasTexts, insertBreak, insertFragment, insertNode, insertNodes, insertSoftBreak, insertText, isBlock, isEdge, isEditor, isEmpty, isEnd, isNormalizing, isStart, last, leaf, levels, liftNodes, marks, mergeNodes, move, moveNodes, next, node, nodes, normalize, normalizeNode, parent, path, pathRef, pathRefs, point, pointRef, pointRefs, positions, previous, range, rangeRef, rangeRefs, removeMark, removeNodes, select, setNodes, setNormalizing, setPoint, setSelection, shouldMergeNodesRemovePrevNode, shouldNormalize, splitNodes, start, string, unhangRange, unsetNodes, unwrapNodes, withoutNormalizing, wrapNodes };\n//# sourceMappingURL=index.es.js.map\n","import { isPlainObject } from 'is-plain-object';\nimport { Text, Range, Node, Element, createEditor as createEditor$1 } from 'slate';\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * A weak map to hold anchor tokens.\n */\nvar ANCHOR = new WeakMap();\n/**\n * A weak map to hold focus tokens.\n */\nvar FOCUS = new WeakMap();\n/**\n * All tokens inherit from a single constructor for `instanceof` checking.\n */\nclass Token {}\n/**\n * Anchor tokens represent the selection's anchor point.\n */\nclass AnchorToken extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"offset\", void 0);\n    _defineProperty(this, \"path\", void 0);\n    var {\n      offset,\n      path\n    } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n}\n/**\n * Focus tokens represent the selection's focus point.\n */\nclass FocusToken extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _defineProperty(this, \"offset\", void 0);\n    _defineProperty(this, \"path\", void 0);\n    var {\n      offset,\n      path\n    } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n}\n/**\n * Add an anchor token to the end of a text node.\n */\nvar addAnchorToken = (text, token) => {\n  var offset = text.text.length;\n  ANCHOR.set(text, [offset, token]);\n};\n/**\n * Get the offset if a text node has an associated anchor token.\n */\nvar getAnchorOffset = text => {\n  return ANCHOR.get(text);\n};\n/**\n * Add a focus token to the end of a text node.\n */\nvar addFocusToken = (text, token) => {\n  var offset = text.text.length;\n  FOCUS.set(text, [offset, token]);\n};\n/**\n * Get the offset if a text node has an associated focus token.\n */\nvar getFocusOffset = text => {\n  return FOCUS.get(text);\n};\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Resolve the descedants of a node by normalizing the children that can be\n * passed into a hyperscript creator function.\n */\nvar STRINGS = new WeakSet();\nvar resolveDescendants = children => {\n  var nodes = [];\n  var addChild = child => {\n    if (child == null) {\n      return;\n    }\n    var prev = nodes[nodes.length - 1];\n    if (typeof child === 'string') {\n      var text = {\n        text: child\n      };\n      STRINGS.add(text);\n      child = text;\n    }\n    if (Text.isText(child)) {\n      var c = child; // HACK: fix typescript complaining\n      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && Text.equals(prev, c, {\n        loose: true\n      })) {\n        prev.text += c.text;\n      } else {\n        nodes.push(c);\n      }\n    } else if (Element.isElement(child)) {\n      nodes.push(child);\n    } else if (child instanceof Token) {\n      var n = nodes[nodes.length - 1];\n      if (!Text.isText(n)) {\n        addChild('');\n        n = nodes[nodes.length - 1];\n      }\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child);\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child);\n      }\n    } else {\n      throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n    }\n  };\n  for (var child of children.flat(Infinity)) {\n    addChild(child);\n  }\n  return nodes;\n};\n/**\n * Create an anchor token.\n */\nfunction createAnchor(tagName, attributes, children) {\n  return new AnchorToken(attributes);\n}\n/**\n * Create an anchor and a focus token.\n */\nfunction createCursor(tagName, attributes, children) {\n  return [new AnchorToken(attributes), new FocusToken(attributes)];\n}\n/**\n * Create an `Element` object.\n */\nfunction createElement(tagName, attributes, children) {\n  return _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n    children: resolveDescendants(children)\n  });\n}\n/**\n * Create a focus token.\n */\nfunction createFocus(tagName, attributes, children) {\n  return new FocusToken(attributes);\n}\n/**\n * Create a fragment.\n */\nfunction createFragment(tagName, attributes, children) {\n  return resolveDescendants(children);\n}\n/**\n * Create a `Selection` object.\n */\nfunction createSelection(tagName, attributes, children) {\n  var anchor = children.find(c => c instanceof AnchorToken);\n  var focus = children.find(c => c instanceof FocusToken);\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  return _objectSpread$1({\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path\n    }\n  }, attributes);\n}\n/**\n * Create a `Text` object.\n */\nfunction createText(tagName, attributes, children) {\n  var nodes = resolveDescendants(children);\n  if (nodes.length > 1) {\n    throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n  }\n  var [node] = nodes;\n  if (node == null) {\n    node = {\n      text: ''\n    };\n  }\n  if (!Text.isText(node)) {\n    throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n  }\n  // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n  STRINGS.delete(node);\n  Object.assign(node, attributes);\n  return node;\n}\n/**\n * Create a top-level `Editor` object.\n */\nvar createEditor = makeEditor => (tagName, attributes, children) => {\n  var otherChildren = [];\n  var selectionChild;\n  for (var child of children) {\n    if (Range.isRange(child)) {\n      selectionChild = child;\n    } else {\n      otherChildren.push(child);\n    }\n  }\n  var descendants = resolveDescendants(otherChildren);\n  var selection = {};\n  var editor = makeEditor();\n  Object.assign(editor, attributes);\n  editor.children = descendants;\n  // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n  for (var [node, path] of Node.texts(editor)) {\n    var anchor = getAnchorOffset(node);\n    var focus = getFocusOffset(node);\n    if (anchor != null) {\n      var [offset] = anchor;\n      selection.anchor = {\n        path,\n        offset\n      };\n    }\n    if (focus != null) {\n      var [_offset] = focus;\n      selection.focus = {\n        path,\n        offset: _offset\n      };\n    }\n  }\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n  if (selectionChild != null) {\n    editor.selection = selectionChild;\n  } else if (Range.isRange(selection)) {\n    editor.selection = selection;\n  }\n  return editor;\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * The default creators for Slate objects.\n */\nvar DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor(createEditor$1),\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText\n};\n/**\n * Create a Slate hyperscript function with `options`.\n */\nvar createHyperscript = function createHyperscript() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var {\n    elements = {}\n  } = options;\n  var elementCreators = normalizeElements(elements);\n  var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);\n  var jsx = createFactory(creators);\n  return jsx;\n};\n/**\n * Create a Slate hyperscript function with `options`.\n */\nvar createFactory = creators => {\n  var jsx = function jsx(tagName, attributes) {\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n    var creator = creators[tagName];\n    if (!creator) {\n      throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n    }\n    if (attributes == null) {\n      attributes = {};\n    }\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n    children = children.filter(child => Boolean(child)).flat();\n    var ret = creator(tagName, attributes, children);\n    return ret;\n  };\n  return jsx;\n};\n/**\n * Normalize a dictionary of element shorthands into creator functions.\n */\nvar normalizeElements = elements => {\n  var creators = {};\n  var _loop = function _loop() {\n    var props = elements[tagName];\n    if (typeof props !== 'object') {\n      throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n    }\n    creators[tagName] = (tagName, attributes, children) => {\n      return createElement('element', _objectSpread(_objectSpread({}, props), attributes), children);\n    };\n  };\n  for (var tagName in elements) {\n    _loop();\n  }\n  return creators;\n};\n\n/**\n * The default hyperscript factory that ships with Slate, without custom tags.\n */\nvar jsx = createHyperscript();\n\nexport { createEditor, createHyperscript, createText, jsx };\n//# sourceMappingURL=index.es.js.map\n","const e=Symbol(),t=Symbol(),r=\"a\",n=\"w\";let o=(e,t)=>new Proxy(e,t);const s=Object.getPrototypeOf,c=new WeakMap,l=e=>e&&(c.has(e)?c.get(e):s(e)===Object.prototype||s(e)===Array.prototype),f=e=>\"object\"==typeof e&&null!==e,i=e=>{if(Array.isArray(e))return Array.from(e);const t=Object.getOwnPropertyDescriptors(e);return Object.values(t).forEach(e=>{e.configurable=!0}),Object.create(s(e),t)},u=e=>e[t]||e,a=(s,c,f,p)=>{if(!l(s))return s;let g=p&&p.get(s);if(!g){const e=u(s);g=(e=>Object.values(Object.getOwnPropertyDescriptors(e)).some(e=>!e.configurable&&!e.writable))(e)?[e,i(e)]:[e],null==p||p.set(s,g)}const[y,h]=g;let w=f&&f.get(y);return w&&w[1].f===!!h||(w=((o,s)=>{const c={f:s};let l=!1;const f=(e,t)=>{if(!l){let s=c[r].get(o);if(s||(s={},c[r].set(o,s)),e===n)s[n]=!0;else{let r=s[e];r||(r=new Set,s[e]=r),r.add(t)}}},i={get:(e,n)=>n===t?o:(f(\"k\",n),a(Reflect.get(e,n),c[r],c.c,c.t)),has:(t,n)=>n===e?(l=!0,c[r].delete(o),!0):(f(\"h\",n),Reflect.has(t,n)),getOwnPropertyDescriptor:(e,t)=>(f(\"o\",t),Reflect.getOwnPropertyDescriptor(e,t)),ownKeys:e=>(f(n),Reflect.ownKeys(e))};return s&&(i.set=i.deleteProperty=()=>!1),[i,c]})(y,!!h),w[1].p=o(h||y,w[0]),f&&f.set(y,w)),w[1][r]=c,w[1].c=f,w[1].t=p,w[1].p},p=(e,t,r,o,s=Object.is)=>{if(s(e,t))return!1;if(!f(e)||!f(t))return!0;const c=r.get(u(e));if(!c)return!0;if(o){const r=o.get(e);if(r&&r.n===t)return r.g;o.set(e,{n:t,g:!1})}let l=null;try{for(const r of c.h||[])if(l=Reflect.has(e,r)!==Reflect.has(t,r),l)return l;if(!0===c[n]){if(l=((e,t)=>{const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);return r.length!==n.length||r.some((e,t)=>e!==n[t])})(e,t),l)return l}else for(const r of c.o||[])if(l=!!Reflect.getOwnPropertyDescriptor(e,r)!=!!Reflect.getOwnPropertyDescriptor(t,r),l)return l;for(const n of c.k||[])if(l=p(e[n],t[n],r,o,s),l)return l;return null===l&&(l=!0),l}finally{o&&o.set(e,{n:t,g:l})}},g=t=>!!l(t)&&e in t,y=e=>l(e)&&e[t]||null,h=(e,t=!0)=>{c.set(e,t)},w=(e,t,r)=>{const o=[],s=new WeakSet,c=(e,l)=>{if(s.has(e))return;f(e)&&s.add(e);const i=f(e)&&t.get(u(e));if(i){var a,p;if(null==(a=i.h)||a.forEach(e=>{const t=`:has(${String(e)})`;o.push(l?[...l,t]:[t])}),!0===i[n]){const e=\":ownKeys\";o.push(l?[...l,e]:[e])}else{var g;null==(g=i.o)||g.forEach(e=>{const t=`:hasOwn(${String(e)})`;o.push(l?[...l,t]:[t])})}null==(p=i.k)||p.forEach(t=>{r&&!(\"value\"in(Object.getOwnPropertyDescriptor(e,t)||{}))||c(e[t],l?[...l,t]:[t])})}else l&&o.push(l)};return c(e),o},O=e=>{o=e};export{w as affectedToPathList,a as createProxy,y as getUntracked,p as isChanged,h as markToTrack,O as replaceNewProxy,g as trackMemo};\n//# sourceMappingURL=index.modern.mjs.map\n","import { useRef, useEffect, useDebugValue, useReducer, useCallback, useMemo, createContext as createContext$1, useContext, createElement, forwardRef, memo as memo$1 } from 'react';\nimport { createContext, useContextUpdate, useContextSelector } from 'use-context-selector';\nimport { affectedToPathList, isChanged, createProxy, trackMemo } from 'proxy-compare';\nexport { getUntracked as getUntrackedObject } from 'proxy-compare';\n\nconst useAffectedDebugValue = (state, affected) => {\n  const pathList = useRef();\n  useEffect(() => {\n    pathList.current = affectedToPathList(state, affected);\n  });\n  useDebugValue(state);\n};\n\nconst createTrackedSelector = useSelector => {\n  const useTrackedSelector = () => {\n    const [, forceUpdate] = useReducer(c => c + 1, 0);\n    const affected = new WeakMap();\n    const lastAffected = useRef();\n    const prevState = useRef();\n    const lastState = useRef();\n    useEffect(() => {\n      lastAffected.current = affected;\n      if (prevState.current !== lastState.current && isChanged(prevState.current, lastState.current, affected, new WeakMap())) {\n        prevState.current = lastState.current;\n        forceUpdate();\n      }\n    });\n    const selector = useCallback(nextState => {\n      lastState.current = nextState;\n      if (prevState.current && prevState.current !== nextState && lastAffected.current && !isChanged(prevState.current, nextState, lastAffected.current, new WeakMap())) {\n        // not changed\n        return prevState.current;\n      }\n      prevState.current = nextState;\n      return nextState;\n    }, []);\n    const state = useSelector(selector);\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useAffectedDebugValue(state, affected);\n    }\n    const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache\n    return createProxy(state, affected, proxyCache);\n  };\n  return useTrackedSelector;\n};\n\n/* eslint react/destructuring-assignment: off */\nconst createContainer = (useValue, options) => {\n  var _options, _options2;\n  if (typeof options === 'boolean') {\n    // eslint-disable-next-line no-console\n    console.warn('boolean option is deprecated, please specify { concurrentMode: true }');\n    options = {\n      concurrentMode: options\n    };\n  }\n  const {\n    stateContextName = 'StateContainer',\n    updateContextName = 'UpdateContainer',\n    concurrentMode\n  } = options || {};\n  const StateContext = createContext((_options = options) == null ? void 0 : _options.defaultState);\n  const UpdateContext = createContext$1((_options2 = options) == null ? void 0 : _options2.defaultUpdate);\n  StateContext.displayName = stateContextName;\n  UpdateContext.displayName = updateContextName;\n  const Provider = props => {\n    const [state, update] = useValue(props);\n    return createElement(UpdateContext.Provider, {\n      value: update\n    }, createElement(StateContext.Provider, {\n      value: state\n    }, props.children));\n  };\n  const useSelector = selector => {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {\n      const selectorOrig = selector;\n      selector = state => {\n        if (state === undefined) {\n          throw new Error('Please use <Provider>');\n        }\n        return selectorOrig(state);\n      };\n    }\n    const selected = useContextSelector(StateContext, selector);\n    useDebugValue(selected);\n    return selected;\n  };\n  const useTrackedState = createTrackedSelector(useSelector);\n  const useUpdate = concurrentMode ? () => {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && useContext(UpdateContext) === undefined) {\n      throw new Error('Please use <Provider>');\n    }\n    const contextUpdate = useContextUpdate(StateContext);\n    const update = useContext(UpdateContext);\n    return useCallback((...args) => {\n      let result;\n      contextUpdate(() => {\n        result = update(...args);\n      });\n      return result;\n    }, [contextUpdate, update]);\n  }\n  // not concurrentMode\n  : () => {\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'production' && useContext(UpdateContext) === undefined) {\n      throw new Error('Please use <Provider>');\n    }\n    return useContext(UpdateContext);\n  };\n  const useTracked = () => [useTrackedState(), useUpdate()];\n  return {\n    Provider,\n    useTrackedState,\n    useTracked,\n    useUpdate,\n    useSelector\n  };\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction memo(Component, propsAreEqual) {\n  const WrappedComponent = forwardRef((props, ref) => {\n    Object.values(props).forEach(trackMemo);\n    return createElement(Component, _extends({}, props, {\n      ref\n    }));\n  });\n  return memo$1(WrappedComponent, propsAreEqual);\n}\n\nexport { createContainer, createTrackedSelector, memo };\n//# sourceMappingURL=index.modern.mjs.map\n","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (_e) {\n  }\n  if (!extensionConnector) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState) return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (_e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (_e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return [\n              true,\n              options.migrate(\n                deserializedStorageValue.state,\n                deserializedStorageValue.version\n              )\n            ];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, void 0];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, getInitialState, subscribe, destroy };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\nexport { createStore, vanilla as default };\n","import ReactExports from 'react';\nimport useSyncExternalStoreExports from 'use-sync-external-store/shim/with-selector.js';\nimport { createStore } from 'zustand/vanilla';\n\nconst { useDebugValue } = ReactExports;\nconst { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;\nconst identity = (arg) => arg;\nfunction useStoreWithEqualityFn(api, selector = identity, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getInitialState,\n    selector,\n    equalityFn\n  );\n  useDebugValue(slice);\n  return slice;\n}\nconst createWithEqualityFnImpl = (createState, defaultEqualityFn) => {\n  const api = createStore(createState);\n  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);\n  Object.assign(useBoundStoreWithEqualityFn, api);\n  return useBoundStoreWithEqualityFn;\n};\nconst createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;\n\nexport { createWithEqualityFn, useStoreWithEqualityFn };\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    result[key] = iteratee(value, key, object);\n  });\n  return result;\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = mapValues;\n","import { Transforms, Element, Editor, Scrubber, Range, Node, Text, Path, Point } from 'slate';\nimport { isHotkey } from 'is-hotkey';\n\n/**\n * Types.\n */\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint;\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset;\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    }\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  }\n  // Return the node and offset.\n  return [node, offset];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\nvar getPlainText = domNode => {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */\nvar getSelection = root => {\n  if (root.getSelection != null) {\n    return root.getSelection();\n  }\n  return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var {\n    document\n  } = DOMEditor.getWindow(editor);\n  if (document.contains(target)) {\n    return DOMEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  }\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */\nvar getActiveElement = () => {\n  var activeElement = document.activeElement;\n  while ((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement) {\n    var _activeElement, _activeElement$shadow, _activeElement2;\n    activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n  }\n  return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */\nvar isBefore = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */\nvar isAfter = (node, otherNode) => Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\n\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== 'undefined' && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n// Check if the browser is Safari and older than 17\ntypeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * An auto-incrementing identifier for keys.\n */\nvar n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\nclass Key {\n  constructor() {\n    _defineProperty(this, \"id\", void 0);\n    this.id = \"\".concat(n++);\n  }\n}\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\nvar IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n  androidPendingDiffs: editor => EDITOR_TO_PENDING_DIFFS.get(editor),\n  androidScheduleFlush: editor => {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n  },\n  blur: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  deselect: editor => {\n    var {\n      selection\n    } = editor;\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n  findDocumentOrShadowRoot: editor => {\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (root instanceof Document || root instanceof ShadowRoot) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  findEventRange: (editor, event) => {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = DOMEditor.toSlateNode(editor, event.target);\n    var path = DOMEditor.findPath(editor, node);\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (Element.isElement(node) && Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n      if (point) {\n        var _range = Editor.range(editor, point);\n        return _range;\n      }\n    }\n    // Else resolve a range from the caret position where the drop occured.\n    var domRange;\n    var {\n      document\n    } = DOMEditor.getWindow(editor);\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    // Resolve a Slate range from the DOM range.\n    var range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  findKey: (editor, node) => {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  findPath: (editor, node) => {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n  focus: function focus(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      retries: 5\n    };\n    // Return if already focused\n    if (IS_FOCUSED.get(editor)) {\n      return;\n    }\n    // Retry setting focus if the editor has pending operations.\n    // The DOM (selection) is unstable while changes are applied.\n    // Retry until retries are exhausted or editor is focused.\n    if (options.retries <= 0) {\n      throw new Error('Could not set focus, editor seems stuck with pending operations');\n    }\n    if (editor.operations.length > 0) {\n      setTimeout(() => {\n        DOMEditor.focus(editor, {\n          retries: options.retries - 1\n        });\n      }, 10);\n      return;\n    }\n    var el = DOMEditor.toDOMNode(editor, editor);\n    var root = DOMEditor.findDocumentOrShadowRoot(editor);\n    if (root.activeElement !== el) {\n      // Ensure that the DOM selection state is set to the editor's selection\n      if (editor.selection && root instanceof Document) {\n        var domSelection = getSelection(root);\n        var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n        domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n      }\n      // Create a new selection in the top of the document if missing\n      if (!editor.selection) {\n        Transforms.select(editor, Editor.start(editor, []));\n      }\n      // IS_FOCUSED should be set before calling el.focus() to ensure that\n      // FocusedContext is updated to the correct value\n      IS_FOCUSED.set(editor, true);\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  getWindow: editor => {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = DOMEditor.toDOMNode(editor, editor);\n    var targetEl;\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  hasEditableTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n    editable: true\n  }),\n  hasRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n  hasSelectableTarget: (editor, target) => DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n  hasTarget: (editor, target) => isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n  insertData: (editor, data) => {\n    editor.insertData(data);\n  },\n  insertFragmentData: (editor, data) => editor.insertFragmentData(data),\n  insertTextData: (editor, data) => editor.insertTextData(data),\n  isComposing: editor => {\n    return !!IS_COMPOSING.get(editor);\n  },\n  isFocused: editor => !!IS_FOCUSED.get(editor),\n  isReadOnly: editor => !!IS_READ_ONLY.get(editor),\n  isTargetInsideNonReadonlyVoid: (editor, target) => {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n    return Element.isElement(slateNode) && Editor.isVoid(editor, slateNode);\n  },\n  setFragmentData: (editor, data, originEvent) => editor.setFragmentData(data, originEvent),\n  toDOMNode: (editor, node) => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  toDOMPoint: (editor, point) => {\n    var [node] = Editor.node(editor, point.path);\n    var el = DOMEditor.toDOMNode(editor, node);\n    var domPoint;\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    }\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength;\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  toDOMRange: (editor, range) => {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n    var window = DOMEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  toSlateNode: (editor, domNode) => {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  toSlatePoint: (editor, domPoint, options) => {\n    var {\n      exactMatch,\n      suppressThrow,\n      searchDirection = 'backward'\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = DOMEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n      var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null;\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = DOMEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          });\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (DOMEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        }\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      } else if (nonEditableNode) {\n        // Find the edge of the nearest leaf in `searchDirection`\n        var getLeafNodes = node => node ? node.querySelectorAll(\n        // Exclude leaf nodes in nested editors\n        '[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])') : [];\n        var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n        if (searchDirection === 'forward') {\n          var _leafNodes$find;\n          var _leafNodes = [...getLeafNodes(elementNode), ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)];\n          leafNode = (_leafNodes$find = _leafNodes.find(leaf => isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n        } else {\n          var _leafNodes2$findLast;\n          var _leafNodes2 = [...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling), ...getLeafNodes(elementNode)];\n          leafNode = (_leafNodes2$findLast = _leafNodes2.findLast(leaf => isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n        }\n        if (leafNode) {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          if (searchDirection === 'forward') {\n            offset = 0;\n          } else {\n            offset = domNode.textContent.length;\n            domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n              offset -= el.textContent.length;\n            });\n          }\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      parentNode.hasAttribute('data-slate-zero-width') ||\n      // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n      // when the document ends with a new-line character. This results in the offset\n      // length being off by one, so we need to subtract one to account for this.\n      IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && DOMEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = DOMEditor.toSlateNode(editor, node);\n        var {\n          path: _path,\n          offset: _offset\n        } = Editor.start(editor, DOMEditor.findPath(editor, _slateNode));\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    }\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    var slateNode = DOMEditor.toSlateNode(editor, textNode);\n    var path = DOMEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n  toSlateRange: (editor, domRange, options) => {\n    var _focusNode$textConten;\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        // COMPAT: In firefox the normal seletion way does not work\n        // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n        if (IS_FIREFOX && domRange.rangeCount > 1) {\n          focusNode = domRange.focusNode; // Focus node works fine\n          var firstRange = domRange.getRangeAt(0);\n          var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n          // Here we are in the contenteditable mode of a table in firefox\n          if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n            // HTMLElement, becouse Element is a slate element\n            function getLastChildren(element) {\n              if (element.childElementCount > 0) {\n                return getLastChildren(element.children[0]);\n              } else {\n                return element;\n              }\n            }\n            var firstNodeRow = firstRange.startContainer;\n            var lastNodeRow = lastRange.startContainer;\n            // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n            var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n            var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n            // Zero, as we allways take the right one as the anchor point\n            focusOffset = 0;\n            if (lastNode.childNodes.length > 0) {\n              anchorNode = lastNode.childNodes[0];\n            } else {\n              anchorNode = lastNode;\n            }\n            if (firstNode.childNodes.length > 0) {\n              focusNode = firstNode.childNodes[0];\n            } else {\n              focusNode = firstNode;\n            }\n            if (lastNode instanceof HTMLElement) {\n              anchorOffset = lastNode.innerHTML.length;\n            } else {\n              // Fallback option\n              anchorOffset = 0;\n            }\n          } else {\n            // This is the read only mode of a firefox table\n            // Right to left\n            if (firstRange.startContainer === focusNode) {\n              anchorNode = lastRange.endContainer;\n              anchorOffset = lastRange.endOffset;\n              focusOffset = firstRange.startOffset;\n            } else {\n              // Left to right\n              anchorNode = firstRange.startContainer;\n              anchorOffset = firstRange.endOffset;\n              focusOffset = lastRange.startOffset;\n            }\n          }\n        } else {\n          anchorNode = domRange.anchorNode;\n          anchorOffset = domRange.anchorOffset;\n          focusNode = domRange.focusNode;\n          focusOffset = domRange.focusOffset;\n        }\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        // IsCollapsed might not work in firefox, but this will\n        if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n    // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n    // when isTrailing is true) in the focusOffset, resulting in an invalid\n    // Slate point. (2023/11/01)\n    if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith('\\n\\n') && focusOffset === focusNode.textContent.length) {\n      focusOffset--;\n    }\n    var anchor = DOMEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n    var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow,\n      searchDirection: focusBeforeAnchor ? 'forward' : 'backward'\n    });\n    if (!focus) {\n      return null;\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  }\n};\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = Node.get(editor, path);\n  if (!Text.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = Path.next(path);\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = Node.get(editor, nextPath);\n  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\n * Get the slate range the text diff spans.\n */\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = Node.get(editor, path);\n  if (!Text.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = Editor.above(editor, {\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text.isText\n    });\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path,\n    offset\n  };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var {\n    diff\n  } = textDiff;\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  }\n  // Point references location after the diff\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n    case 'split_node':\n      {\n        if (!Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\n/**\n * Utilities for single-line deletion\n */\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withDOM = function withDOM(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e;\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = Editor.above(e, {\n        match: n => Element.isElement(n) && Editor.isBlock(e, n),\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  };\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = op => {\n    var matches = [];\n    var pathRefMatches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, Path.parent(op.path)));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          var changedPath;\n          if (Path.isBefore(op.path, op.newPath)) {\n            matches.push(...getMatches(e, Path.parent(op.path)));\n            changedPath = op.newPath;\n          } else {\n            matches.push(...getMatches(e, Path.parent(op.newPath)));\n            changedPath = op.path;\n          }\n          var changedNode = Node.get(editor, Path.parent(changedPath));\n          var changedNodeKey = DOMEditor.findKey(e, changedNode);\n          var changedPathRef = Editor.pathRef(e, Path.parent(changedPath));\n          pathRefMatches.push([changedPathRef, changedNodeKey]);\n          break;\n        }\n    }\n    apply(op);\n    switch (op.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'move_node':\n      case 'split_node':\n        {\n          IS_NODE_MAP_DIRTY.set(e, true);\n        }\n    }\n    for (var [path, key] of matches) {\n      var [node] = Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n    for (var [pathRef, _key] of pathRefMatches) {\n      if (pathRef.current) {\n        var [_node] = Editor.node(e, pathRef.current);\n        NODE_TO_KEY.set(_node, _key);\n      }\n      pathRef.unref();\n    }\n  };\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n    if (!selection) {\n      return;\n    }\n    var [start, end] = Range.edges(selection);\n    var startVoid = Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = Editor.void(e, {\n      at: end.path\n    });\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    }\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    var domRange = DOMEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0];\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    });\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = DOMEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    }\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    }\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    });\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span');\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n    // Add the content to a <div> so that we can get its inner HTML.\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = data => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n        e.insertText(line);\n        split = true;\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = options => {\n    var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n    if (onContextChange) {\n      onContextChange(options);\n    }\n    onChange(options);\n  };\n  return e;\n};\nvar getMatches = (e, path) => {\n  var matches = [];\n  for (var [n, p] of Editor.levels(e, {\n    at: path\n  })) {\n    var key = DOMEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n  return matches;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\n * Hotkey mappings for each platform.\n */\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\n * Create a platform-aware hotkey checker.\n */\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isHotkey(generic);\n  var isApple = apple && isHotkey(apple);\n  var isWindows = windows && isHotkey(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\n * Hotkeys.\n */\nvar hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nvar _excluded = [\"anchor\", \"focus\"],\n  _excluded2 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other) => {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isElementDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\nvar isTextDecorationsEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    // compare only offsets because paths doesn't matter for text\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport { CAN_USE_DOM, DOMEditor, DOMElement, DOMNode, DOMRange, DOMSelection, DOMStaticRange, DOMText, EDITOR_TO_ELEMENT, EDITOR_TO_FORCE_RENDER, EDITOR_TO_KEY_TO_ELEMENT, EDITOR_TO_ON_CHANGE, EDITOR_TO_PENDING_ACTION, EDITOR_TO_PENDING_DIFFS, EDITOR_TO_PENDING_INSERTION_MARKS, EDITOR_TO_PENDING_SELECTION, EDITOR_TO_PLACEHOLDER_ELEMENT, EDITOR_TO_SCHEDULE_FLUSH, EDITOR_TO_USER_MARKS, EDITOR_TO_USER_SELECTION, EDITOR_TO_WINDOW, ELEMENT_TO_NODE, HAS_BEFORE_INPUT_SUPPORT, hotkeys as Hotkeys, IS_ANDROID, IS_CHROME, IS_COMPOSING, IS_FIREFOX, IS_FIREFOX_LEGACY, IS_FOCUSED, IS_IOS, IS_NODE_MAP_DIRTY, IS_READ_ONLY, IS_UC_MOBILE, IS_WEBKIT, IS_WECHATBROWSER, Key, MARK_PLACEHOLDER_SYMBOL, NODE_TO_ELEMENT, NODE_TO_INDEX, NODE_TO_KEY, NODE_TO_PARENT, PLACEHOLDER_SYMBOL, TRIPLE_CLICK, applyStringDiff, getActiveElement, getDefaultView, getSelection, hasShadowRoot, isAfter, isBefore, isDOMElement, isDOMNode, isDOMSelection, isElementDecorationsEqual, isPlainTextOnlyPaste, isTextDecorationsEqual, isTrackedMutation, mergeStringDiffs, normalizeDOMPoint, normalizePoint, normalizeRange, normalizeStringDiff, targetRange, verifyDiffState, withDOM };\n//# sourceMappingURL=index.es.js.map\n","var resizeObservers = [];\nexport { resizeObservers };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasActiveObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\nexport { hasActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nvar hasSkippedObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\nexport { hasSkippedObservations };\n","var msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n","var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n","export var freeze = function (obj) { return Object.freeze(obj); };\n","import { freeze } from './utils/freeze';\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        freeze(this);\n    }\n    return ResizeObserverSize;\n}());\nexport { ResizeObserverSize };\n","import { freeze } from './utils/freeze';\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return freeze(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\nexport { DOMRectReadOnly };\n","var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\nexport { isSVG, isHidden, isElement, isReplacedElement };\n","export var global = typeof window !== 'undefined' ? window : {};\n","import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { ResizeObserverSize } from '../ResizeObserverSize';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nimport { isSVG, isHidden } from '../utils/element';\nimport { freeze } from '../utils/freeze';\nimport { global } from '../utils/global';\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if (isHidden(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = freeze({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes };\n","import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nimport { freeze } from './utils/freeze';\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\nexport { ResizeObserverEntry };\n","import { isHidden } from '../utils/element';\nvar calculateDepthForNode = function (node) {\n    if (isHidden(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new ResizeObserverEntry(ot.target);\n            var targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n","import { resizeObservers } from '../utils/resizeObservers';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nvar gatherActiveObservationsAtDepth = function (depth) {\n    resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n","import { hasActiveObservations } from '../algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from '../algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from '../algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from '../algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from '../algorithms/gatherActiveObservationsAtDepth';\nvar process = function () {\n    var depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport { process };\n","var trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\nexport { queueMicroTask };\n","import { queueMicroTask } from './queueMicroTask';\nvar queueResizeObserver = function (cb) {\n    queueMicroTask(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\nexport { queueResizeObserver };\n","import { process } from './process';\nimport { global } from './global';\nimport { queueResizeObserver } from './queueResizeObserver';\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        queueResizeObserver(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = process();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\nexport { scheduler, updateCount };\n","import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nimport { isSVG, isReplacedElement } from './utils/element';\nvar skipNotifyOnElement = function (target) {\n    return !isSVG(target)\n        && !isReplacedElement(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = calculateBoxSize(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\nexport { ResizeObservation };\n","var ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\nexport { ResizeObserverDetail };\n","import { scheduler, updateCount } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { resizeObservers } from './utils/resizeObservers';\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && resizeObservers.push(detail);\n            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n            updateCount(1);\n            scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            updateCount(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\nexport { ResizeObserverController };\n","import { ResizeObserverController } from './ResizeObserverController';\nimport { isElement } from './utils/element';\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\nexport { ResizeObserver };\n","import getDirection from 'direction';\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport React, { createContext, useContext, useRef, useEffect, useLayoutEffect, useState, memo, forwardRef, useCallback, Component, useReducer, useMemo } from 'react';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport { Editor, Range, Transforms, Node, Text as Text$1, Path, Point, Element as Element$1, Scrubber } from 'slate';\nimport { DOMEditor, EDITOR_TO_USER_MARKS, EDITOR_TO_PENDING_DIFFS, EDITOR_TO_PENDING_ACTION, EDITOR_TO_PENDING_INSERTION_MARKS, targetRange, verifyDiffState, EDITOR_TO_PENDING_SELECTION, IS_COMPOSING, IS_NODE_MAP_DIRTY, applyStringDiff, isDOMSelection, isTrackedMutation, EDITOR_TO_FORCE_RENDER, normalizeRange, normalizePoint, EDITOR_TO_PLACEHOLDER_ELEMENT, normalizeStringDiff, mergeStringDiffs, CAN_USE_DOM, IS_ANDROID, EDITOR_TO_SCHEDULE_FLUSH, MARK_PLACEHOLDER_SYMBOL, IS_IOS, PLACEHOLDER_SYMBOL, IS_WEBKIT, isTextDecorationsEqual, EDITOR_TO_KEY_TO_ELEMENT, NODE_TO_ELEMENT, ELEMENT_TO_NODE, isElementDecorationsEqual, NODE_TO_INDEX, NODE_TO_PARENT, IS_READ_ONLY, getActiveElement, getSelection, IS_FOCUSED, getDefaultView, EDITOR_TO_WINDOW, EDITOR_TO_ELEMENT, IS_FIREFOX, EDITOR_TO_USER_SELECTION, HAS_BEFORE_INPUT_SUPPORT, isDOMElement, isDOMNode, TRIPLE_CLICK, IS_FIREFOX_LEGACY, IS_WECHATBROWSER, IS_UC_MOBILE, Hotkeys, IS_CHROME, isPlainTextOnlyPaste, EDITOR_TO_ON_CHANGE, withDOM } from 'slate-dom';\nexport { NODE_TO_INDEX, NODE_TO_PARENT } from 'slate-dom';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport ReactDOM from 'react-dom';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * A React context for sharing the editor object.\n */\nvar EditorContext = /*#__PURE__*/createContext(null);\n/**\n * Get the current editor object from the React context.\n */\nvar useSlateStatic = () => {\n  var editor = useContext(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n// eslint-disable-next-line no-redeclare\nvar ReactEditor = DOMEditor;\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25;\n// Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200;\n// Replace with `const debug = console.log` to debug\nvar debug = function debug() {};\n// Type guard to check if a value is a DataTransfer\nvar isDataTransfer = value => (value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n  var applyPendingSelection = () => {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = normalizeRange(editor, pendingSelection);\n      if (normalized && (!selection || !Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized);\n      }\n    }\n  };\n  var performAction = () => {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n    if (!action) {\n      return;\n    }\n    if (action.at) {\n      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n      if (!target) {\n        return;\n      }\n      var _targetRange = Editor.range(editor, target);\n      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {\n        Transforms.select(editor, target);\n      }\n    }\n    action.run();\n  };\n  var flush = () => {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = hasPendingDiffs();\n    var diff;\n    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {\n      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n      var range = targetRange(diff);\n      if (!editor.selection || !Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range);\n      }\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text);\n      } else {\n        Editor.deleteFragment(editor);\n      }\n      // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action';\n        // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 || selectionRef.unref();\n      }\n    }\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {\n      Transforms.select(editor, selection);\n    }\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    }\n    // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n  var handleCompositionStart = _event => {\n    IS_COMPOSING.set(editor, true);\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n    if (!placeholderElement) {\n      return;\n    }\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n    placeholderElement.style.removeProperty('display');\n  };\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI3;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => Path.equals(change.path, path));\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n      updatePlaceholderVisibility();\n      return;\n    }\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n    pendingDiffs[idx] = _objectSpread$5(_objectSpread$5({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n    if (hasPendingAction()) {\n      flush();\n    }\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    });\n    // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n    actionTimeoutId = setTimeout(flush);\n  };\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (IS_NODE_MAP_DIRTY.get(editor)) {\n      return;\n    }\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n    var [nativeTargetRange] = event.getTargetRanges();\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n    if (!targetRange) {\n      return;\n    }\n    // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n    var canStoreDiff = true;\n    if (type.startsWith('delete')) {\n      if (Range.isExpanded(targetRange)) {\n        var [_start, _end] = Range.edges(targetRange);\n        var _leaf = Node.leaf(editor, _start.path);\n        if (_leaf.text.length === _start.offset && _end.offset === 0) {\n          var next = Editor.next(editor, {\n            at: _start.path,\n            match: Text$1.isText\n          });\n          if (next && Path.equals(next[1], _end.path)) {\n            targetRange = {\n              anchor: _end,\n              focus: _end\n            };\n          }\n        }\n      }\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      var [start, end] = Range.edges(targetRange);\n      var [leaf, path] = Editor.leaf(editor, start.path);\n      var diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset\n      };\n      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(change => Path.equals(change.path, path));\n      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];\n      var text = applyStringDiff(leaf.text, ...diffs);\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false;\n      }\n      if (Range.isExpanded(targetRange)) {\n        if (canStoreDiff && Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          var point = {\n            path: targetRange.anchor.path,\n            offset: start.offset\n          };\n          var range = Editor.range(editor, point, point);\n          handleUserSelect(range);\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset\n          });\n        }\n        return scheduleAction(() => Editor.deleteFragment(editor, {\n          direction\n        }), {\n          at: targetRange\n        });\n      }\n    }\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n          if (canStoreDiff && Range.isCollapsed(targetRange)) {\n            var targetNode = Node.leaf(editor, anchor.path);\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n          return scheduleAction(() => Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n          var {\n            anchor: _anchor\n          } = targetRange;\n          // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n          if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n          return scheduleAction(() => Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if (isDataTransfer(data)) {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n          var _text = data !== null && data !== void 0 ? data : '';\n          // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            _text = _text.replace('\\uFEFF', '');\n          }\n          // Pastes from the Android clipboard will generate `insertText` events.\n          // If the copied text contains any newlines, Android will append an\n          // extra newline to the end of the copied text.\n          if (type === 'insertText' && /.*\\n.*\\n$/.test(_text)) {\n            _text = _text.slice(0, -1);\n          }\n          // If the text includes a newline, split it at newlines and paste each component\n          // string, with soft breaks in between each.\n          if (_text.includes('\\n')) {\n            return scheduleAction(() => {\n              var parts = _text.split('\\n');\n              parts.forEach((line, i) => {\n                if (line) {\n                  Editor.insertText(editor, line);\n                }\n                if (i !== parts.length - 1) {\n                  Editor.insertSoftBreak(editor);\n                }\n              });\n            }, {\n              at: targetRange\n            });\n          }\n          if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start2, _end2] = Range.edges(targetRange);\n            var _diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text: _text\n            };\n            // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n            if (_text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n              if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                _diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = _diff;\n              } else if (insertPositionHint && Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$5(_objectSpread$5({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + _text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n            if (canStoreDiff) {\n              storeDiff(_start2.path, _diff);\n              return;\n            }\n          }\n          return scheduleAction(() => Editor.insertText(editor, _text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n  var hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI4;\n    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n  };\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n  var isFlushing = () => {\n    return flushing;\n  };\n  var handleUserSelect = range => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var {\n      selection\n    } = editor;\n    if (!range) {\n      return;\n    }\n    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n    if (mutations.some(mutation => isTrackedMutation(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();\n    }\n  };\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = useRef(false);\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = useState(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  useEffect(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, [mutationObserver, node, options]);\n}\n\nvar _excluded$2 = [\"node\"];\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nvar useAndroidInputManager = !IS_ANDROID ? () => null : _ref => {\n  var {\n      node\n    } = _ref,\n    options = _objectWithoutProperties(_ref, _excluded$2);\n  if (!IS_ANDROID) {\n    return null;\n  }\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = useState(() => createAndroidInputManager(_objectSpread$4({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n  if (isMounted) {\n    inputManager.flush();\n  }\n  return inputManager;\n};\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Leaf content strings.\n */\nvar String$1 = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path);\n  var isMarkPlaceholder = Boolean(leaf[MARK_PLACEHOLDER_SYMBOL]);\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      length: Node.string(parent).length\n    });\n  }\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  }\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  }\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/React.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n  return /*#__PURE__*/React.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\n * Leaf strings with text in them.\n */\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = useRef(null);\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  };\n  var [initialText] = useState(getTextContent);\n  // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    }\n    // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n  });\n  // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n  return /*#__PURE__*/React.createElement(MemoizedText$1, {\n    ref: ref\n  }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  }, props.children);\n}));\n/**\n * Leaf strings without text, render as zero-width strings.\n */\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n  return /*#__PURE__*/React.createElement(\"span\", _objectSpread$3({}, attributes), !(IS_ANDROID || IS_IOS) || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/React.createElement(\"br\", null) : null);\n};\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n// Delay the placeholder on Android to prevent the keyboard from closing.\n// (https://github.com/ianstormtaylor/slate/pull/5368)\nvar PLACEHOLDER_DELAY = IS_ANDROID ? 300 : 0;\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect();\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null;\n    }\n  }\n}\nfunction clearTimeoutRef(timeoutRef) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = null;\n  }\n}\n/**\n * Individual leaves in a text node with unique formatting.\n */\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = props => /*#__PURE__*/React.createElement(DefaultLeaf, _objectSpread$2({}, props))\n  } = props;\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = useRef(null);\n  var placeholderRef = useRef(null);\n  var [showPlaceholder, setShowPlaceholder] = useState(false);\n  var showPlaceholderTimeoutRef = useRef(null);\n  var callbackPlaceholderRef = useCallback(placeholderEl => {\n    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n    if (placeholderEl == null) {\n      var _leaf$onPlaceholderRe;\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n      (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf, null);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n      if (!placeholderResizeObserver.current) {\n        // Create a new observer and observe the placeholder element.\n        var ResizeObserver$1 = window.ResizeObserver || ResizeObserver;\n        placeholderResizeObserver.current = new ResizeObserver$1(() => {\n          var _leaf$onPlaceholderRe2;\n          (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n        });\n      }\n      placeholderResizeObserver.current.observe(placeholderEl);\n      placeholderRef.current = placeholderEl;\n    }\n  }, [placeholderRef, leaf, editor]);\n  var children = /*#__PURE__*/React.createElement(String$1, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n  var leafIsPlaceholder = Boolean(leaf[PLACEHOLDER_SYMBOL]);\n  useEffect(() => {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder, so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(() => {\n          setShowPlaceholder(true);\n          showPlaceholderTimeoutRef.current = null;\n        }, PLACEHOLDER_DELAY);\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef);\n      setShowPlaceholder(false);\n    }\n    return () => clearTimeoutRef(showPlaceholderTimeoutRef);\n  }, [leafIsPlaceholder, setShowPlaceholder]);\n  if (leafIsPlaceholder && showPlaceholder) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n          // Fixes https://github.com/udecode/plate/issues/2315\n          WebkitUserModify: IS_WEBKIT ? 'inherit' : undefined\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef\n      }\n    };\n    children = /*#__PURE__*/React.createElement(React.Fragment, null, renderPlaceholder(placeholderProps), children);\n  }\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\nvar MemoizedLeaf = /*#__PURE__*/React.memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text$1.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/React.createElement(\"span\", _objectSpread$2({}, attributes), children);\n};\n\n/**\n * Text.\n */\nvar Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = useRef(null);\n  var leaves = Text$1.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/React.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  }\n  // Update element-related weak maps with the DOM element ref.\n  var callbackRef = useCallback(span => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (span) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, span);\n      NODE_TO_ELEMENT.set(text, span);\n      ELEMENT_TO_NODE.set(span, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n      if (ref.current) {\n        ELEMENT_TO_NODE.delete(ref.current);\n      }\n    }\n    ref.current = span;\n  }, [ref, editor, key, text]);\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: callbackRef\n  }, children);\n};\nvar MemoizedText = /*#__PURE__*/React.memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Element.\n */\nvar Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/React.createElement(DefaultElement, _objectSpread$1({}, p)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = useCallback(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  });\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  }\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node.string(element);\n    var dir = getDirection(text);\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  }\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = Node.texts(element);\n    children = /*#__PURE__*/React.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/React.createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\nvar MemoizedElement = /*#__PURE__*/React.memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));\n});\n/**\n * The default element renderer.\n */\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/React.createElement(Tag, _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\n * A React context for sharing the `decorate` prop of the editable.\n */\nvar DecorateContext = /*#__PURE__*/createContext(() => []);\n/**\n * Get the current `decorate` prop of the editable.\n */\nvar useDecorate = () => {\n  return useContext(DecorateContext);\n};\n\n/**\n * A React context for sharing the `selected` state of an element.\n */\nvar SelectedContext = /*#__PURE__*/createContext(false);\n/**\n * Get the current `selected` state of an element.\n */\nvar useSelected = () => {\n  return useContext(SelectedContext);\n};\n\n/**\n * Children.\n */\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  IS_NODE_MAP_DIRTY.set(editor, false);\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n    for (var dec of decorations) {\n      var d = Range.intersection(dec, range);\n      if (d) {\n        ds.push(d);\n      }\n    }\n    if (Element$1.isElement(n)) {\n      children.push( /*#__PURE__*/React.createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/React.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/React.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n  return children;\n};\n\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */\nvar ReadOnlyContext = /*#__PURE__*/createContext(false);\n/**\n * Get the current `readOnly` state of the editor.\n */\nvar useReadOnly = () => {\n  return useContext(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/createContext(null);\n/**\n * Get the current editor object from the React context.\n */\nvar useSlate = () => {\n  var context = useContext(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar useSlateWithV = () => {\n  var context = useContext(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  return context;\n};\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = useRef(false);\n  var animationFrameIdRef = useRef(0);\n  var onUserInput = useCallback(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, [editor]);\n  useEffect(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n  var clear = () => {\n    bufferedMutations = [];\n  };\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n    var trackedMutations = mutations.filter(mutation => isTrackedMutation(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(mutation => {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return;\n        }\n        mutation.removedNodes.forEach(node => {\n          mutation.target.insertBefore(node, mutation.nextSibling);\n        });\n        mutation.addedNodes.forEach(node => {\n          mutation.target.removeChild(node);\n        });\n      });\n      // Clear buffered mutations to ensure we don't undo them twice\n      clear();\n    }\n  }\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n};\n// We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends Component {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"context\", null);\n    _defineProperty(this, \"manager\", null);\n    _defineProperty(this, \"mutationObserver\", null);\n  }\n  observe() {\n    var _this$mutationObserve;\n    var {\n      node\n    } = this.props;\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n  }\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n      (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);\n    }\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();\n    return null;\n  }\n  componentDidUpdate() {\n    var _this$manager3;\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();\n    this.observe();\n  }\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();\n  }\n  render() {\n    return this.props.children;\n  }\n}\n_defineProperty(RestoreDOMComponent, \"contextType\", EditorContext);\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n};\n\n/**\n * A React context for sharing the `composing` state of the editor.\n */\nvar ComposingContext = /*#__PURE__*/createContext(false);\n/**\n * Get the current `composing` state of the editor.\n */\nvar useComposing = () => {\n  return useContext(ComposingContext);\n};\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\", \"disableDefaultStyles\"],\n  _excluded2 = [\"text\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar Children = props => /*#__PURE__*/React.createElement(React.Fragment, null, useChildren(props));\n/**\n * Editable.\n */\nvar Editable = /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  var defaultRenderPlaceholder = useCallback(props => /*#__PURE__*/React.createElement(DefaultPlaceholder, _objectSpread({}, props)), []);\n  var {\n      autoFocus,\n      decorate = defaultDecorate,\n      onDOMBeforeInput: propsOnDOMBeforeInput,\n      placeholder,\n      readOnly = false,\n      renderElement,\n      renderLeaf,\n      renderPlaceholder = defaultRenderPlaceholder,\n      scrollSelectionIntoView = defaultScrollSelectionIntoView,\n      style: userStyle = {},\n      as: Component = 'div',\n      disableDefaultStyles = false\n    } = props,\n    attributes = _objectWithoutProperties(props, _excluded$1);\n  var editor = useSlate();\n  // Rerender editor when composition status changed\n  var [isComposing, setIsComposing] = useState(false);\n  var ref = useRef(null);\n  var deferredOperations = useRef([]);\n  var [placeholderHeight, setPlaceholderHeight] = useState();\n  var processing = useRef(false);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender);\n  // Update internal state on each render.\n  IS_READ_ONLY.set(editor, readOnly);\n  // Keep track of some state for the event handler logic.\n  var state = useMemo(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []);\n  // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  /**\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\n   *\n   * It is defined as a reference to simplify hook dependencies and clarify that\n   * it needs to be initialized.\n   */\n  var androidInputManagerRef = useRef();\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  var onDOMSelectionChange = useMemo(() => throttle(() => {\n    if (IS_NODE_MAP_DIRTY.get(editor)) {\n      onDOMSelectionChange();\n      return;\n    }\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (!processing.current && IS_WEBKIT && root instanceof ShadowRoot) {\n      processing.current = true;\n      var active = getActiveElement();\n      if (active) {\n        document.execCommand('indent');\n      } else {\n        Transforms.deselect(editor);\n      }\n      processing.current = false;\n      return;\n    }\n    var androidInputManager = androidInputManagerRef.current;\n    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var _root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = _root;\n      var _el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = getSelection(_root);\n      if (activeElement === _el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n      if (!domSelection) {\n        return Transforms.deselect(editor);\n      }\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeInEditor = ReactEditor.hasTarget(editor, focusNode);\n      if (anchorNodeSelectable && focusNodeInEditor) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range);\n          }\n        }\n      }\n      // Deselect the editor if the dom selection is not selectable in readonly mode\n      if (readOnly && (!anchorNodeSelectable || !focusNodeInEditor)) {\n        Transforms.deselect(editor);\n      }\n    }\n  }, 100), [editor, readOnly, state]);\n  var scheduleOnDOMSelectionChange = useMemo(() => debounce(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    var _androidInputManagerR, _androidInputManagerR2;\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    }\n    // Make sure the DOM selection state is in sync.\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = getSelection(root);\n    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n      return;\n    }\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None';\n      // If the DOM selection is properly unset, we're done.\n      if (!selection && !hasDomSelection) {\n        return;\n      }\n      // Get anchorNode and focusNode\n      var focusNode = domSelection.focusNode;\n      var anchorNode;\n      // COMPAT: In firefox the normal seletion way does not work\n      // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n      if (IS_FIREFOX && domSelection.rangeCount > 1) {\n        var firstRange = domSelection.getRangeAt(0);\n        var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);\n        // Right to left\n        if (firstRange.startContainer === focusNode) {\n          anchorNode = lastRange.endContainer;\n        } else {\n          // Left to right\n          anchorNode = firstRange.startContainer;\n        }\n      } else {\n        anchorNode = domSelection.anchorNode;\n      }\n      // verify that the dom selection is in the editor\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n      if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n        hasDomSelectionInEditor = true;\n      }\n      // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n        if (slateRange && Range.equals(slateRange, selection)) {\n          var _anchorNode;\n          if (!state.hasMarkPlaceholder) {\n            return;\n          }\n          // Ensure selection is inside the mark placeholder\n          if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      }\n      // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      }\n      // Otherwise the DOM selection is out of sync, so update it.\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n      if (newDomRange) {\n        if (ReactEditor.isComposing(editor) && !IS_ANDROID) {\n          domSelection.collapseToEnd();\n        } else if (Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n      return newDomRange;\n    };\n    // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n    if (domSelection.rangeCount <= 1) {\n      setDomSelection();\n    }\n    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {\n            // Ignore, dom and state might be out of sync\n          }\n        };\n        // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  var onDOMBeforeInput = useCallback(event => {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if (processing !== null && processing !== void 0 && processing.current && IS_WEBKIT && root instanceof ShadowRoot) {\n      var ranges = event.getTargetRanges();\n      var range = ranges[0];\n      var newRange = new window.Range();\n      newRange.setStart(range.startContainer, range.startOffset);\n      newRange.setEnd(range.endContainer, range.endOffset);\n      // Translate the DOM Range into a Slate Range\n      var slateRange = ReactEditor.toSlateRange(editor, newRange, {\n        exactMatch: false,\n        suppressThrow: false\n      });\n      Transforms.select(editor, slateRange);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      return;\n    }\n    onUserInput();\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManagerRef.current) {\n        return androidInputManagerRef.current.handleDOMBeforeInput(event);\n      }\n      // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText';\n      // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n      var native = false;\n      if (type === 'insertText' && selection && Range.isCollapsed(selection) &&\n      // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) &&\n      // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        native = true;\n        // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n        if (editor.marks) {\n          native = false;\n        }\n        // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint)\n        if (!IS_NODE_MAP_DIRTY.get(editor)) {\n          var _node$parentElement, _window$getComputedSt;\n          // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n          // Therefore we don't allow native events to insert text at the end of anchor nodes.\n          var {\n            anchor\n          } = selection;\n          var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n          var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n          var _window = ReactEditor.getWindow(editor);\n          if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n            var _lastText$textContent;\n            // Find the last text node inside the anchor.\n            var lastText = _window === null || _window === void 0 ? void 0 : _window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n            if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n              native = false;\n            }\n          }\n          // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n          // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n          if (native && node.parentElement && (_window === null || _window === void 0 || (_window$getComputedSt = _window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n            var block = Editor.above(editor, {\n              at: anchor.path,\n              match: n => Element$1.isElement(n) && Editor.isBlock(editor, n)\n            });\n            if (block && Node.string(block[0]).includes('\\t')) {\n              native = false;\n            }\n          }\n        }\n      }\n      // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n      // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint via ReactEditor.toSlateRange)\n      if ((!type.startsWith('delete') || type.startsWith('deleteBy')) && !IS_NODE_MAP_DIRTY.get(editor)) {\n        var [targetRange] = event.getTargetRanges();\n        if (targetRange) {\n          var _range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n          if (!selection || !Range.equals(selection, _range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);\n            Transforms.select(editor, _range);\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      }\n      // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n      if (isCompositionChange) {\n        return;\n      }\n      if (!native) {\n        event.preventDefault();\n      }\n      // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            Editor.deleteFragment(editor);\n            break;\n          }\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            Editor.deleteForward(editor);\n            break;\n          }\n        case 'deleteContentBackward':\n          {\n            Editor.deleteBackward(editor);\n            break;\n          }\n        case 'deleteEntireSoftLine':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteWordBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'deleteWordForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'insertLineBreak':\n          Editor.insertSoftBreak(editor);\n          break;\n        case 'insertParagraph':\n          {\n            Editor.insertBreak(editor);\n            break;\n          }\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            }\n            // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => Editor.insertText(editor, data));\n              } else {\n                Editor.insertText(editor, data);\n              }\n            }\n            break;\n          }\n      }\n      // Restore the actual user section if nothing manually set it.\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {\n        Transforms.select(editor, toRestore);\n      }\n    }\n  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);\n  var callbackRef = useCallback(node => {\n    if (node == null) {\n      onDOMSelectionChange.cancel();\n      scheduleOnDOMSelectionChange.cancel();\n      EDITOR_TO_ELEMENT.delete(editor);\n      NODE_TO_ELEMENT.delete(editor);\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    } else {\n      // Attach a native DOM event handler for `beforeinput` events, because React's\n      // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n      // real `beforeinput` events sadly... (2019/11/04)\n      // https://github.com/facebook/react/issues/11211\n      if (HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        node.addEventListener('beforeinput', onDOMBeforeInput);\n      }\n    }\n    ref.current = node;\n    if (typeof forwardedRef === 'function') {\n      forwardedRef(node);\n    } else if (forwardedRef) {\n      forwardedRef.current = node;\n    }\n  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput, forwardedRef]);\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    // Attach a native DOM event handler for `selectionchange`, because React's\n    // built-in `onSelect` handler doesn't fire for all selection changes. It's\n    // a leaky polyfill that only fires on keypresses or clicks. Instead, we\n    // want to fire for any change to the selection inside the editor.\n    // (2019/11/04) https://github.com/facebook/react/issues/5785\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    // Listen for dragend and drop globally. In Firefox, if a drop handler\n    // initiates an operation that causes the originally dragged element to\n    // unmount, that element will not emit a dragend event. (2024/06/21)\n    var stoppedDragging = () => {\n      state.isDraggingInternally = false;\n    };\n    window.document.addEventListener('dragend', stoppedDragging);\n    window.document.addEventListener('drop', stoppedDragging);\n    return () => {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n      window.document.removeEventListener('dragend', stoppedDragging);\n      window.document.removeEventListener('drop', stoppedDragging);\n    };\n  }, [scheduleOnDOMSelectionChange, state]);\n  var decorations = decorate([editor, []]);\n  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing;\n  var placeHolderResizeHandler = useCallback(placeholderEl => {\n    if (placeholderEl && showPlaceholder) {\n      var _placeholderEl$getBou;\n      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n    } else {\n      setPlaceholderHeight(undefined);\n    }\n  }, [showPlaceholder]);\n  if (showPlaceholder) {\n    var start = Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      onPlaceholderResize: placeHolderResizeHandler,\n      anchor: start,\n      focus: start\n    });\n  }\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = Node.leaf(editor, anchor.path);\n    var rest = _objectWithoutProperties(leaf, _excluded2);\n    // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n    if (!Text$1.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(_objectSpread(_objectSpread(_objectSpread({\n        [MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  }\n  // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n  useEffect(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n        var _text = Node.leaf(editor, _anchor.path);\n        // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (marks && !Text$1.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  return /*#__PURE__*/React.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/React.createElement(ComposingContext.Provider, {\n    value: isComposing\n  }, /*#__PURE__*/React.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/React.createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/React.createElement(Component, _objectSpread(_objectSpread({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes), {}, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: callbackRef,\n    style: _objectSpread(_objectSpread({}, disableDefaultStyles ? {} : _objectSpread({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, placeholderHeight ? {\n      minHeight: placeholderHeight\n    } : {})), userStyle),\n    onBeforeInput: useCallback(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          Editor.insertText(editor, _text2);\n        }\n      }\n    }, [attributes.onBeforeInput, editor, readOnly]),\n    onInput: useCallback(event => {\n      if (isEventHandled(event, attributes.onInput)) {\n        return;\n      }\n      if (androidInputManagerRef.current) {\n        androidInputManagerRef.current.handleInput();\n        return;\n      }\n      // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n      for (var op of deferredOperations.current) {\n        op();\n      }\n      deferredOperations.current = [];\n      // COMPAT: Since `beforeinput` doesn't fully `preventDefault`,\n      // there's a chance that content might be placed in the browser's undo stack.\n      // This means undo can be triggered even when the div is not focused,\n      // and it only triggers the input event for the node. (2024/10/09)\n      if (!ReactEditor.isFocused(editor)) {\n        var native = event.nativeEvent;\n        var maybeHistoryEditor = editor;\n        if (native.inputType === 'historyUndo' && typeof maybeHistoryEditor.undo === 'function') {\n          maybeHistoryEditor.undo();\n          return;\n        }\n        if (native.inputType === 'historyRedo' && typeof maybeHistoryEditor.redo === 'function') {\n          maybeHistoryEditor.redo();\n          return;\n        }\n      }\n    }, [attributes.onInput, editor]),\n    onBlur: useCallback(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      }\n      // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n      if (relatedTarget === el) {\n        return;\n      }\n      // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      }\n      // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n        if (Element$1.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      }\n      // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n      if (IS_WEBKIT) {\n        var domSelection = getSelection(root);\n        domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n      }\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),\n    onClick: useCallback(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n        if (!Editor.hasPath(editor, path) || Node.get(editor, path) !== node) {\n          return;\n        }\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n          if (!(Element$1.isElement(node) && Editor.isBlock(editor, node))) {\n            var _block$;\n            var block = Editor.above(editor, {\n              match: n => Element$1.isElement(n) && Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n          var range = Editor.range(editor, blockPath);\n          Transforms.select(editor, range);\n          return;\n        }\n        if (readOnly) {\n          return;\n        }\n        var _start = Editor.start(editor, path);\n        var end = Editor.end(editor, path);\n        var startVoid = Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = Editor.void(editor, {\n          at: end\n        });\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var _range2 = Editor.range(editor, _start);\n          Transforms.select(editor, _range2);\n        }\n      }\n    }, [editor, attributes.onClick, readOnly]),\n    onCompositionEnd: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR3;\n        if (ReactEditor.isComposing(editor)) {\n          Promise.resolve().then(() => {\n            setIsComposing(false);\n            IS_COMPOSING.set(editor, false);\n          });\n        }\n        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        }\n        // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n        if (!IS_WEBKIT && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n          // Ensure we insert text with the marks the user was actually seeing\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n          Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd, editor]),\n    onCompositionUpdate: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate, editor]),\n    onCompositionStart: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR4;\n        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n        if (selection && Range.isExpanded(selection)) {\n          Editor.deleteFragment(editor);\n          return;\n        }\n      }\n    }, [attributes.onCompositionStart, editor]),\n    onCopy: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy, editor]),\n    onCut: useCallback(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node.parent(editor, selection.anchor.path);\n            if (Editor.isVoid(editor, node)) {\n              Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onCut]),\n    onDragOver: useCallback(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        if (Element$1.isElement(node) && Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver, editor]),\n    onDragStart: useCallback(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Element$1.isElement(node) && Editor.isVoid(editor, node) || Editor.void(editor, {\n          at: path,\n          voids: true\n        });\n        // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, editor, attributes.onDragStart, state]),\n    onDrop: useCallback(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault();\n        // Keep a reference to the dragged range before updating selection\n        var draggedRange = editor.selection;\n        // Find the range where the drop happened\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        Transforms.select(editor, range);\n        if (state.isDraggingInternally) {\n          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n        ReactEditor.insertData(editor, data);\n        // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n    }, [readOnly, editor, attributes.onDrop, state]),\n    onDragEnd: useCallback(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      }\n    }, [readOnly, state, attributes, editor]),\n    onFocus: useCallback(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement;\n        // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, state, editor, attributes.onFocus]),\n    onKeyDown: useCallback(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        var _androidInputManagerR5;\n        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event;\n        // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = getDirection(Node.string(element)) === 'rtl';\n        // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n          return;\n        }\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n          return;\n        }\n        // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        }\n        // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: isRTL ? 'end' : 'start'\n            });\n          }\n          return;\n        }\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: isRTL ? 'start' : 'end'\n            });\n          }\n          return;\n        }\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        }\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertSoftBreak(editor);\n            return;\n          }\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_WEBKIT) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {\n              var currentNode = Node.parent(editor, selection.anchor.path);\n              if (Element$1.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onKeyDown]),\n    onPaste: useCallback(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        // COMPAT: Safari InputEvents generated by pasting won't include\n        // application/x-slate-fragment items, so use the\n        // ClipboardEvent here. (2023/03/15)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_WEBKIT) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, editor, attributes.onPaste])\n  }), /*#__PURE__*/React.createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  }))))));\n});\n/**\n * The default placeholder element\n */\nvar DefaultPlaceholder = _ref => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    React.createElement(\"span\", _objectSpread({}, attributes), children, IS_ANDROID && /*#__PURE__*/React.createElement(\"br\", null))\n  );\n};\n/**\n * A default memoized decorate function.\n */\nvar defaultDecorate = () => [];\n/**\n * A default implement to scroll dom range into view.\n */\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoView(leafEl, {\n      scrollMode: 'if-needed'\n    });\n    // @ts-expect-error an unorthodox delete D:\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\n * Check if an event is overrided by a handler.\n */\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\n * Check if the event's target is an input element\n */\nvar isDOMEventTargetInput = event => {\n  return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\n * Check if a DOM event is overrided by a handler.\n */\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.defaultPrevented;\n};\n\n/**\n * A React context for sharing the `focused` state of the editor.\n */\nvar FocusedContext = /*#__PURE__*/createContext(false);\n/**\n * Get the current `focused` state of the editor.\n */\nvar useFocused = () => {\n  return useContext(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\n * A React context for sharing the editor selector context in a way to control rerenders\n */\nvar SlateSelectorContext = /*#__PURE__*/createContext({});\nvar refEquality = (a, b) => a === b;\n/**\n * use redux style selectors to prevent rerendering on every keystroke.\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\n *\n * Example:\n * ```\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\n * ```\n */\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  var context = useContext(SlateSelectorContext);\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n  var {\n    getSlate,\n    addEventListener\n  } = context;\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef(() => null);\n  var latestSelectedState = useRef(null);\n  var selectedState;\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n    throw err;\n  }\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(() => {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        if (err instanceof Error) {\n          latestSubscriptionCallbackError.current = err;\n        } else {\n          latestSubscriptionCallbackError.current = new Error(String(err));\n        }\n      }\n      forceRender();\n    }\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return () => unsubscribe();\n  },\n  // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\n * Create selector context with editor updating on every editor change\n */\nfunction useSelectorContext(editor) {\n  var eventListeners = useRef([]).current;\n  var slateRef = useRef({\n    editor\n  }).current;\n  var onChange = useCallback(editor => {\n    slateRef.editor = editor;\n    eventListeners.forEach(listener => listener(editor));\n  }, [eventListeners, slateRef]);\n  var selectorContext = useMemo(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: callback => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\n\nvar REACT_MAJOR_VERSION = parseInt(React.version.split('.')[0], 10);\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"onSelectionChange\", \"onValueChange\", \"initialValue\"];\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */\nvar Slate = props => {\n  var {\n      editor,\n      children,\n      onChange,\n      onSelectionChange,\n      onValueChange,\n      initialValue\n    } = props,\n    rest = _objectWithoutProperties(props, _excluded);\n  var [context, setContext] = React.useState(() => {\n    if (!Node.isNodeList(initialValue)) {\n      throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(Scrubber.stringify(initialValue)));\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(Scrubber.stringify(editor)));\n    }\n    editor.children = initialValue;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = useSelectorContext(editor);\n  var onContextChange = useCallback(options => {\n    var _options$operation;\n    if (onChange) {\n      onChange(editor.children);\n    }\n    switch (options === null || options === void 0 || (_options$operation = options.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type) {\n      case 'set_selection':\n        onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);\n        break;\n      default:\n        onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);\n    }\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [editor, handleSelectorChange, onChange, onSelectionChange, onValueChange]);\n  useEffect(() => {\n    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {});\n    };\n  }, [editor, onContextChange]);\n  var [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor));\n  useEffect(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  }, [editor]);\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n    if (REACT_MAJOR_VERSION >= 17) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/React.createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/React.createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/React.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\n * Get the current editor object from the React context.\n * @deprecated Use useSlateStatic instead.\n */\nvar useEditor = () => {\n  var editor = useContext(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n/**\n * Get the current slate selection.\n * Only triggers a rerender when the selection actually changes\n */\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\nvar withReact = function withReact(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  e = withDOM(e, clipboardFormatKey);\n  var {\n    onChange\n  } = e;\n  e.onChange = options => {\n    // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n    // that the children and selection can get out of sync for one render\n    // pass. So we have to use this unstable API to ensure it batches them.\n    // (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? ReactDOM.unstable_batchedUpdates : callback => callback();\n    maybeBatchUpdates(() => {\n      onChange(options);\n    });\n  };\n  return e;\n};\n\nexport { DefaultElement, DefaultLeaf, DefaultPlaceholder, Editable, ReactEditor, Slate, useComposing, useEditor, useFocused, useReadOnly, useSelected, useSlate, useSlateSelection, useSlateSelector, useSlateStatic, useSlateWithV, withReact };\n//# sourceMappingURL=index.es.js.map\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/react/components/DefaultLeaf.tsx\nimport React from \"react\";\nimport { clsx } from \"clsx\";\n\n// src/lib/editor/withSlate.ts\nimport {\n  createTEditor,\n  getEndPoint,\n  getStartPoint,\n  normalizeEditor,\n  select\n} from \"@udecode/slate\";\nimport { nanoid } from \"nanoid\";\n\n// src/internal/mergePlugins.ts\nimport mergeWith from \"lodash/mergeWith.js\";\nfunction mergePlugins(basePlugin, ...sourcePlugins) {\n  return mergeWith(\n    {},\n    basePlugin,\n    ...sourcePlugins,\n    (objValue, srcValue, key) => {\n      if (Array.isArray(srcValue)) {\n        return srcValue;\n      }\n      if (key === \"options\") {\n        return __spreadValues(__spreadValues({}, objValue), srcValue);\n      }\n    }\n  );\n}\n\n// src/lib/utils/misc/isFunction.ts\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/lib/plugin/createSlatePlugin.ts\nfunction createSlatePlugin(config = {}) {\n  var _a;\n  let baseConfig;\n  let initialExtension;\n  if (isFunction(config)) {\n    baseConfig = { key: \"\" };\n    initialExtension = (editor) => config(editor);\n  } else {\n    baseConfig = config;\n  }\n  const key = (_a = baseConfig.key) != null ? _a : \"\";\n  const plugin = mergePlugins(\n    {\n      key,\n      __apiExtensions: [],\n      __configuration: null,\n      __extensions: initialExtension ? [initialExtension] : [],\n      __optionExtensions: [],\n      api: {},\n      dependencies: [],\n      editor: {},\n      inject: {},\n      node: { type: key },\n      options: {},\n      override: {},\n      parser: {},\n      parsers: {},\n      plugins: [],\n      priority: 100,\n      render: {},\n      shortcuts: {},\n      transforms: {},\n      handlers: {}\n    },\n    config\n  );\n  plugin.configure = (config2) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__configuration = (ctx) => isFunction(config2) ? config2(ctx) : config2;\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.configurePlugin = (p, config2) => {\n    const newPlugin = __spreadValues({}, plugin);\n    const configureNestedPlugin = (plugins) => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n          return createSlatePlugin(__spreadProps(__spreadValues({}, nestedPlugin), {\n            __configuration: (ctx) => isFunction(config2) ? config2(ctx) : config2\n          }));\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result2 = configureNestedPlugin(nestedPlugin.plugins);\n          if (result2.found) {\n            found = true;\n            return __spreadProps(__spreadValues({}, nestedPlugin), {\n              plugins: result2.plugins\n            });\n          }\n        }\n        return nestedPlugin;\n      });\n      return { found, plugins: updatedPlugins };\n    };\n    const result = configureNestedPlugin(newPlugin.plugins);\n    newPlugin.plugins = result.plugins;\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendEditorApi = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: false }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendOptions = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__optionExtensions = [\n      ...newPlugin.__optionExtensions,\n      extension\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendApi = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: true }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendEditorTransforms = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: false, isTransform: true }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendTransforms = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: true, isTransform: true }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extend = (extendConfig) => {\n    let newPlugin = __spreadValues({}, plugin);\n    if (isFunction(extendConfig)) {\n      newPlugin.__extensions = [\n        ...newPlugin.__extensions,\n        extendConfig\n      ];\n    } else {\n      newPlugin = mergePlugins(newPlugin, extendConfig);\n    }\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.clone = () => mergePlugins(plugin);\n  plugin.extendPlugin = (p, extendConfig) => {\n    const newPlugin = __spreadValues({}, plugin);\n    const extendNestedPlugin = (plugins) => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n          return createSlatePlugin(__spreadProps(__spreadValues({}, nestedPlugin), {\n            __extensions: [\n              ...nestedPlugin.__extensions,\n              (ctx) => isFunction(extendConfig) ? extendConfig(ctx) : extendConfig\n            ]\n          }));\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result2 = extendNestedPlugin(nestedPlugin.plugins);\n          if (result2.found) {\n            found = true;\n            return __spreadProps(__spreadValues({}, nestedPlugin), {\n              plugins: result2.plugins\n            });\n          }\n        }\n        return nestedPlugin;\n      });\n      return { found, plugins: updatedPlugins };\n    };\n    const result = extendNestedPlugin(newPlugin.plugins);\n    newPlugin.plugins = result.plugins;\n    if (!result.found) {\n      newPlugin.plugins.push(\n        createSlatePlugin({\n          key: p.key,\n          __extensions: [\n            (ctx) => isFunction(extendConfig) ? extendConfig(ctx) : extendConfig\n          ]\n        })\n      );\n    }\n    return createSlatePlugin(newPlugin);\n  };\n  return plugin;\n}\nfunction createTSlatePlugin(config = {}) {\n  return createSlatePlugin(config);\n}\n\n// src/lib/utils/applyDeepToNodes.ts\nimport {\n  isAncestor,\n  queryNode\n} from \"@udecode/slate\";\nvar applyDeepToNodes = ({\n  apply,\n  node,\n  path = [],\n  query,\n  source\n}) => {\n  const entry = [node, path];\n  if (queryNode(entry, query)) {\n    if (source instanceof Function) {\n      apply(node, source());\n    } else {\n      apply(node, source);\n    }\n  }\n  if (!isAncestor(node)) return;\n  node.children.forEach((child, index) => {\n    applyDeepToNodes({\n      apply,\n      node: child,\n      path: path.concat([index]),\n      query,\n      source\n    });\n  });\n};\n\n// src/lib/utils/getInjectMatch.ts\nimport { getAboveNode, isBlock, isElement } from \"@udecode/slate\";\n\n// src/lib/utils/getKeysByTypes.ts\nvar getKeysByTypes = (editor, types) => {\n  return Object.values(editor.plugins).filter((plugin) => types.includes(plugin.node.type)).map((plugin) => plugin.key);\n};\nvar getKeyByType = (editor, type) => {\n  var _a;\n  const plugin = Object.values(editor.plugins).find(\n    (plugin2) => plugin2.node.type === type\n  );\n  return (_a = plugin == null ? void 0 : plugin.key) != null ? _a : type;\n};\n\n// src/lib/utils/getInjectMatch.ts\nvar getInjectMatch = (editor, plugin) => {\n  return (node, path) => {\n    const {\n      inject: {\n        excludeBelowPlugins,\n        excludePlugins,\n        isBlock: _isBlock,\n        isElement: _isElement,\n        isLeaf,\n        maxLevel,\n        targetPlugins\n      }\n    } = plugin;\n    const element = isElement(node) ? node : void 0;\n    if (_isElement && element) return false;\n    if (_isBlock && (!element || !isBlock(editor, element))) return false;\n    if (isLeaf && element) return false;\n    if (element == null ? void 0 : element.type) {\n      if (excludePlugins == null ? void 0 : excludePlugins.includes(getKeyByType(editor, element.type))) {\n        return false;\n      }\n      if (targetPlugins && !targetPlugins.includes(getKeyByType(editor, element.type))) {\n        return false;\n      }\n    }\n    if (excludeBelowPlugins || maxLevel) {\n      if (maxLevel && path.length > maxLevel) {\n        return false;\n      }\n      if (excludeBelowPlugins) {\n        const excludeTypes = getKeysByTypes(editor, excludeBelowPlugins);\n        const isBelow = getAboveNode(editor, {\n          at: path,\n          match: (n) => isElement(n) && excludeTypes.includes(n.type)\n        });\n        if (isBelow) return false;\n      }\n    }\n    return true;\n  };\n};\n\n// src/lib/utils/getInjectedPlugins.ts\nvar getInjectedPlugins = (editor, plugin) => {\n  const injectedPlugins = [];\n  [...editor.pluginList].reverse().forEach((p) => {\n    var _a;\n    const injectedPlugin = (_a = p.inject.plugins) == null ? void 0 : _a[plugin.key];\n    if (injectedPlugin) injectedPlugins.push(injectedPlugin);\n  });\n  return [plugin, ...injectedPlugins];\n};\n\n// src/lib/utils/hotkeys.ts\nimport { IS_APPLE } from \"@udecode/utils\";\nimport { isKeyHotkey } from \"is-hotkey\";\nimport { isHotkey } from \"is-hotkey\";\nvar HOTKEYS = {\n  bold: \"mod+b\",\n  compose: [\"down\", \"left\", \"right\", \"up\", \"backspace\", \"enter\"],\n  deleteBackward: \"shift?+backspace\",\n  deleteForward: \"shift?+delete\",\n  extendBackward: \"shift+left\",\n  extendForward: \"shift+right\",\n  insertSoftBreak: \"shift+enter\",\n  italic: \"mod+i\",\n  moveBackward: \"left\",\n  moveForward: \"right\",\n  moveWordBackward: \"ctrl+left\",\n  moveWordForward: \"ctrl+right\",\n  splitBlock: \"enter\",\n  tab: \"tab\",\n  undo: \"mod+z\",\n  untab: \"shift+tab\"\n};\nvar APPLE_HOTKEYS = {\n  deleteBackward: [\"ctrl+backspace\", \"ctrl+h\"],\n  deleteForward: [\"ctrl+delete\", \"ctrl+d\"],\n  deleteLineBackward: \"cmd+shift?+backspace\",\n  deleteLineForward: [\"cmd+shift?+delete\", \"ctrl+k\"],\n  deleteWordBackward: \"opt+shift?+backspace\",\n  deleteWordForward: \"opt+shift?+delete\",\n  extendLineBackward: \"opt+shift+up\",\n  extendLineForward: \"opt+shift+down\",\n  moveLineBackward: \"opt+up\",\n  moveLineForward: \"opt+down\",\n  moveWordBackward: \"opt+left\",\n  moveWordForward: \"opt+right\",\n  redo: \"cmd+shift+z\",\n  transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: \"ctrl+shift?+backspace\",\n  deleteWordForward: \"ctrl+shift?+delete\",\n  redo: [\"ctrl+y\", \"ctrl+shift+z\"]\n};\nvar createHotkey = (key) => {\n  const generic = HOTKEYS[key];\n  const apple = APPLE_HOTKEYS[key];\n  const windows = WINDOWS_HOTKEYS[key];\n  const isGeneric = generic && isKeyHotkey(generic);\n  const isApple = apple && isKeyHotkey(apple);\n  const isWindows = windows && isKeyHotkey(windows);\n  return (event) => {\n    if (isGeneric == null ? void 0 : isGeneric(event)) return true;\n    if (IS_APPLE && (isApple == null ? void 0 : isApple(event))) return true;\n    if (!IS_APPLE && (isWindows == null ? void 0 : isWindows(event))) return true;\n    return false;\n  };\n};\nvar Hotkeys = {\n  isBold: createHotkey(\"bold\"),\n  isCompose: createHotkey(\"compose\"),\n  isDeleteBackward: createHotkey(\"deleteBackward\"),\n  isDeleteForward: createHotkey(\"deleteForward\"),\n  isDeleteLineBackward: createHotkey(\"deleteLineBackward\"),\n  isDeleteLineForward: createHotkey(\"deleteLineForward\"),\n  isDeleteWordBackward: createHotkey(\"deleteWordBackward\"),\n  isDeleteWordForward: createHotkey(\"deleteWordForward\"),\n  isExtendBackward: createHotkey(\"extendBackward\"),\n  isExtendForward: createHotkey(\"extendForward\"),\n  isExtendLineBackward: createHotkey(\"extendLineBackward\"),\n  isExtendLineForward: createHotkey(\"extendLineForward\"),\n  isItalic: createHotkey(\"italic\"),\n  isMoveBackward: createHotkey(\"moveBackward\"),\n  isMoveForward: createHotkey(\"moveForward\"),\n  isMoveLineBackward: createHotkey(\"moveLineBackward\"),\n  isMoveLineForward: createHotkey(\"moveLineForward\"),\n  isMoveWordBackward: createHotkey(\"moveWordBackward\"),\n  isMoveWordForward: createHotkey(\"moveWordForward\"),\n  isRedo: createHotkey(\"redo\"),\n  isSoftBreak: createHotkey(\"insertSoftBreak\"),\n  isSplitBlock: createHotkey(\"splitBlock\"),\n  isTransposeCharacter: createHotkey(\"transposeCharacter\"),\n  isUndo: createHotkey(\"undo\")\n};\n\n// src/lib/utils/mergeDeepToNodes.ts\nimport merge from \"lodash/merge.js\";\nvar mergeDeepToNodes = (options) => {\n  applyDeepToNodes(__spreadProps(__spreadValues({}, options), { apply: merge }));\n};\n\n// src/lib/utils/normalizeDescendantsToDocumentFragment.ts\nimport {\n  isElement as isElement3,\n  isText as isText2\n} from \"@udecode/slate\";\n\n// src/lib/plugin/getEditorPlugin.ts\nfunction getEditorPlugin(editor, p) {\n  const plugin = editor.getPlugin(p);\n  return {\n    api: editor.api,\n    editor,\n    getOption: (key, ...args) => editor.getOption(plugin, key, ...args),\n    getOptions: () => editor.getOptions(plugin),\n    plugin,\n    setOption: (keyOrOptions, value) => editor.setOption(plugin, keyOrOptions, value),\n    setOptions: (options) => editor.setOptions(plugin, options),\n    tf: editor.transforms,\n    type: plugin.node.type\n  };\n}\n\n// src/lib/plugins/AstPlugin.ts\nvar AstPlugin = createSlatePlugin({\n  key: \"ast\",\n  parser: {\n    deserialize: ({ data }) => {\n      const decoded = decodeURIComponent(window.atob(data));\n      let parsed;\n      try {\n        parsed = JSON.parse(decoded);\n      } catch (e) {\n      }\n      return parsed;\n    },\n    format: \"application/x-slate-fragment\"\n  }\n});\n\n// src/lib/plugins/DOMPlugin.ts\nvar DOMPlugin = createSlatePlugin({\n  key: \"dom\"\n});\n\n// src/lib/plugins/HistoryPlugin.ts\nimport { withHistory } from \"@udecode/slate\";\nvar withPlateHistory = ({ editor }) => withHistory(editor);\nvar HistoryPlugin = createSlatePlugin({\n  key: \"history\",\n  extendEditor: withPlateHistory\n});\n\n// src/lib/plugins/InlineVoidPlugin.ts\nvar withInlineVoid = ({ editor }) => {\n  const { isInline, isVoid, markableVoid } = editor;\n  const voidTypes = [];\n  const inlineTypes = [];\n  const markableVoidTypes = [];\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isInline) {\n      inlineTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isVoid) {\n      voidTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isMarkableVoid) {\n      markableVoidTypes.push(plugin.node.type);\n    }\n  });\n  editor.isInline = (element) => {\n    return inlineTypes.includes(element.type) ? true : isInline(element);\n  };\n  editor.isVoid = (element) => {\n    return voidTypes.includes(element.type) ? true : isVoid(element);\n  };\n  editor.markableVoid = (element) => {\n    return markableVoidTypes.includes(element.type) ? true : markableVoid(element);\n  };\n  return editor;\n};\nvar InlineVoidPlugin = createSlatePlugin({\n  key: \"inlineVoid\",\n  extendEditor: withInlineVoid\n});\n\n// src/lib/plugins/ParserPlugin.ts\nvar withParser = ({ editor }) => {\n  const { insertData } = editor;\n  editor.insertData = (dataTransfer) => {\n    const inserted = [...editor.pluginList].reverse().some((plugin) => {\n      const parser = plugin.parser;\n      if (!parser) return false;\n      const injectedPlugins = getInjectedPlugins(editor, plugin);\n      const { deserialize, format, mimeTypes } = parser;\n      if (!format) return false;\n      const formats = Array.isArray(format) ? format : [format];\n      const mimeTypeList = mimeTypes || formats.map((fmt) => fmt.includes(\"/\") ? fmt : `text/${fmt}`);\n      for (const mimeType of mimeTypeList) {\n        let data = dataTransfer.getData(mimeType);\n        if (!data) continue;\n        if (!pipeInsertDataQuery(editor, injectedPlugins, {\n          data,\n          dataTransfer\n        })) {\n          continue;\n        }\n        data = pipeTransformData(editor, injectedPlugins, {\n          data,\n          dataTransfer\n        });\n        let fragment = deserialize == null ? void 0 : deserialize(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n          data,\n          dataTransfer\n        }));\n        if (!(fragment == null ? void 0 : fragment.length)) continue;\n        fragment = pipeTransformFragment(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n          fragment\n        });\n        if (fragment.length === 0) continue;\n        pipeInsertFragment(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n          fragment\n        });\n        return true;\n      }\n      return false;\n    });\n    if (inserted) return;\n    insertData(dataTransfer);\n  };\n  return editor;\n};\nvar ParserPlugin = createSlatePlugin({\n  key: \"parser\",\n  extendEditor: withParser\n});\n\n// src/lib/plugins/debug/DebugPlugin.ts\nvar PlateError = class extends Error {\n  constructor(message, type = \"DEFAULT\") {\n    super(`[${type}] ${message}`);\n    this.type = type;\n    this.name = \"PlateError\";\n  }\n};\nvar DebugPlugin = createTSlatePlugin({\n  key: \"debug\",\n  options: {\n    isProduction: process.env.NODE_ENV === \"production\",\n    logLevel: process.env.NODE_ENV === \"production\" ? \"error\" : \"log\",\n    logger: {\n      error: (message, type, details) => console.error(`${type ? `[${type}] ` : \"\"}${message}`, details),\n      info: (message, type, details) => console.info(`${type ? `[${type}] ` : \"\"}${message}`, details),\n      log: (message, type, details) => console.log(`${type ? `[${type}] ` : \"\"}${message}`, details),\n      warn: (message, type, details) => console.warn(`${type ? `[${type}] ` : \"\"}${message}`, details)\n    },\n    throwErrors: true\n  }\n}).extendEditorApi(({ getOptions }) => {\n  const logLevels = [\"error\", \"warn\", \"info\", \"log\"];\n  const log = (level, message, type, details) => {\n    var _a, _b;\n    const options = getOptions();\n    if (options.isProduction && level === \"log\") return;\n    if (logLevels.indexOf(level) <= logLevels.indexOf(options.logLevel)) {\n      if (level === \"error\" && options.throwErrors) {\n        const error = message instanceof Error ? message : new PlateError(message, type);\n        throw error;\n      } else {\n        (_b = (_a = options.logger)[level]) == null ? void 0 : _b.call(_a, message, type, details);\n      }\n    }\n  };\n  return {\n    debug: {\n      error: (message, type, details) => log(\"error\", message, type, details),\n      info: (message, type, details) => log(\"info\", message, type, details),\n      log: (message, type, details) => log(\"log\", message, type, details),\n      warn: (message, type, details) => log(\"warn\", message, type, details)\n    }\n  };\n});\n\n// src/lib/plugins/editor-protocol/SlateNextPlugin.ts\nimport {\n  isSelectionAtBlockStart,\n  removeSelectionMark,\n  replaceNodeChildren as replaceNodeChildren2,\n  toggleMark\n} from \"@udecode/slate-utils\";\nimport { bindFirst } from \"@udecode/utils\";\n\n// src/lib/transforms/resetEditorChildren.ts\nimport {\n  replaceNodeChildren\n} from \"@udecode/slate-utils\";\nvar resetEditorChildren = (editor, options) => {\n  replaceNodeChildren(editor, __spreadValues({\n    at: [],\n    nodes: editor.api.create.value()\n  }, options));\n};\n\n// src/lib/transforms/resetEditor.ts\nvar resetEditor = (editor) => {\n  resetEditorChildren(editor);\n  editor.history.undos = [];\n  editor.history.redos = [];\n  editor.operations = [];\n};\n\n// src/lib/transforms/toggleBlock.ts\nimport {\n  someNode\n} from \"@udecode/slate\";\nvar toggleBlock = (editor, options, editorNodesOptions) => {\n  var _a;\n  const { defaultType = editor.getType(BaseParagraphPlugin), type } = options;\n  const at = (_a = editorNodesOptions == null ? void 0 : editorNodesOptions.at) != null ? _a : editor.selection;\n  if (!type || !at) return;\n  const isActive = someNode(editor, __spreadProps(__spreadValues({}, editorNodesOptions), {\n    match: {\n      type\n    }\n  }));\n  if (isActive && type === defaultType) return;\n  editor.setNodes(\n    {\n      type: isActive ? defaultType : type\n    },\n    { at }\n  );\n};\n\n// src/lib/plugins/paragraph/BaseParagraphPlugin.ts\nvar BaseParagraphPlugin = createSlatePlugin({\n  key: \"p\",\n  node: { isElement: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => element.style.fontFamily !== \"Consolas\",\n        rules: [\n          {\n            validNodeName: \"P\"\n          }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/plugins/editor-protocol/SlateNextPlugin.ts\nvar withSlateNext = ({ editor }) => {\n  const { apply, deleteBackward, deleteForward, deleteFragment } = editor;\n  editor.prevSelection = null;\n  editor.currentKeyboardEvent = null;\n  const resetMarks = () => {\n    if (isSelectionAtBlockStart(editor)) {\n      removeSelectionMark(editor);\n    }\n  };\n  editor.deleteBackward = (unit) => {\n    deleteBackward(unit);\n    resetMarks();\n  };\n  editor.deleteForward = (unit) => {\n    deleteForward(unit);\n    resetMarks();\n  };\n  editor.deleteFragment = (direction) => {\n    deleteFragment(direction);\n    resetMarks();\n  };\n  editor.apply = (operation) => {\n    if (operation.type === \"set_selection\") {\n      const { properties } = operation;\n      editor.prevSelection = properties;\n      apply(operation);\n      editor.currentKeyboardEvent = null;\n      return;\n    }\n    apply(operation);\n  };\n  return editor;\n};\nvar SlateNextPlugin = createTSlatePlugin({\n  key: \"slateNext\",\n  extendEditor: withSlateNext\n}).extendEditorApi(({ editor }) => ({\n  create: {\n    /** Default block factory. */\n    block: (node, _path) => __spreadValues({\n      children: [{ text: \"\" }],\n      type: editor.getType(BaseParagraphPlugin)\n    }, node)\n  }\n})).extendEditorApi(({ api }) => ({\n  create: {\n    /** Editor children factory. */\n    value: () => [api.create.block()]\n  }\n})).extendEditorTransforms(({ editor }) => ({\n  reset: () => {\n    resetEditor(editor);\n  },\n  setValue: (value) => {\n    let children = value;\n    if (typeof value === \"string\") {\n      children = editor.api.html.deserialize({\n        element: value\n      });\n    } else if (!value || value.length === 0) {\n      children = editor.api.create.value();\n    }\n    replaceNodeChildren2(editor, {\n      at: [],\n      nodes: children\n    });\n  },\n  toggle: {\n    block: bindFirst(toggleBlock, editor),\n    mark: bindFirst(toggleMark, editor)\n  }\n}));\n\n// src/lib/plugins/html/HtmlPlugin.ts\nimport { bindFirst as bindFirst2 } from \"@udecode/utils\";\n\n// src/lib/plugins/html/utils/isHtmlElement.ts\nvar isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;\n\n// src/lib/plugins/html/utils/isHtmlText.ts\nvar isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;\n\n// src/lib/plugins/html/utils/inlineTagNames.ts\nvar inlineTagNames = /* @__PURE__ */ new Set([\n  \"A\",\n  \"ABBR\",\n  \"ACRONYM\",\n  \"B\",\n  \"BDI\",\n  \"BDO\",\n  \"BIG\",\n  \"BR\",\n  \"BUTTON\",\n  \"CANVAS\",\n  \"CITE\",\n  \"CODE\",\n  \"CONTENT\",\n  \"DATA\",\n  \"DEL\",\n  \"DFN\",\n  \"EM\",\n  \"EMBED\",\n  \"FONT\",\n  \"I\",\n  \"IFRAME\",\n  \"IMG\",\n  \"IMG\",\n  \"INPUT\",\n  \"INS\",\n  \"KBD\",\n  \"LABEL\",\n  \"MAP\",\n  \"MARK\",\n  \"MARQUEE\",\n  \"MENUITEM\",\n  \"METER\",\n  \"NOBR\",\n  \"OBJECT\",\n  \"OUTPUT\",\n  \"PICTURE\",\n  \"PORTAL\",\n  \"PROGRESS\",\n  \"Q\",\n  \"S\",\n  \"SAMP\",\n  \"SELECT\",\n  \"SHADOW\",\n  \"SMALL\",\n  \"SOURCE\",\n  \"SPAN\",\n  \"STRIKE\",\n  \"STRONG\",\n  \"SUB\",\n  \"SUP\",\n  \"TEXTAREA\",\n  \"TIME\",\n  \"TRACK\",\n  \"TT\",\n  \"U\",\n  \"VAR\",\n  \"VIDEO\",\n  \"WBR\",\n  \"math\",\n  \"svg\"\n]);\n\n// src/lib/plugins/html/utils/isHtmlInlineElement.ts\nvar isHtmlInlineElement = (node) => {\n  if (!isHtmlElement(node)) return false;\n  const element = node;\n  const tagNameIsInline = inlineTagNames.has(element.tagName);\n  const displayProperty = element.style.display.split(\" \")[0];\n  if (displayProperty === \"\") {\n    return tagNameIsInline;\n  }\n  if (displayProperty.startsWith(\"inline\")) {\n    return true;\n  }\n  if (displayProperty === \"inherit\" && element.parentElement) {\n    return isHtmlInlineElement(element.parentElement);\n  }\n  if ([\"contents\", \"initial\", \"none\", \"revert\", \"revert-layer\", \"unset\"].includes(\n    displayProperty\n  )) {\n    return tagNameIsInline;\n  }\n  return false;\n};\n\n// src/lib/plugins/html/utils/isHtmlBlockElement.ts\nvar isHtmlBlockElement = (node) => {\n  if (!isHtmlElement(node)) return false;\n  const element = node;\n  return !isHtmlInlineElement(element);\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseString.ts\nvar collapseString = (text, {\n  shouldCollapseWhiteSpace = true,\n  trimEnd = \"collapse\",\n  trimStart = \"collapse\",\n  whiteSpaceIncludesNewlines = true\n} = {}) => {\n  if (trimStart === \"all\") {\n    text = text.replace(/^\\s+/, \"\");\n  }\n  if (trimEnd === \"single-newline\") {\n    text = text.replace(/\\n$/, \"\");\n  }\n  if (shouldCollapseWhiteSpace) {\n    if (whiteSpaceIncludesNewlines) {\n      text = text.replaceAll(/\\s+/g, \" \");\n    } else {\n      text = text.replaceAll(/[^\\S\\n\\r]+/g, \" \");\n      text = text.replaceAll(/^[^\\S\\n\\r]+/gm, \"\");\n      text = text.replaceAll(/[^\\S\\n\\r]+$/gm, \"\");\n    }\n  }\n  return text;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts\nvar isLastNonEmptyTextOfInlineFormattingContext = (initialText) => {\n  let currentNode = initialText;\n  while (true) {\n    if (currentNode.nextSibling) {\n      currentNode = currentNode.nextSibling;\n    } else {\n      currentNode = currentNode.parentElement;\n      if (currentNode && isHtmlBlockElement(currentNode)) {\n        return true;\n      }\n      currentNode = (currentNode == null ? void 0 : currentNode.nextSibling) || null;\n    }\n    if (!currentNode) {\n      return true;\n    }\n    if (isHtmlBlockElement(currentNode)) {\n      return true;\n    }\n    if ((currentNode.textContent || \"\").length > 0) {\n      return false;\n    }\n  }\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/stateTransforms.ts\nvar upsertInlineFormattingContext = (state) => {\n  if (state.inlineFormattingContext) {\n    state.inlineFormattingContext.atStart = false;\n  } else {\n    state.inlineFormattingContext = {\n      atStart: true,\n      lastHasTrailingWhiteSpace: false\n    };\n  }\n};\nvar endInlineFormattingContext = (state) => {\n  state.inlineFormattingContext = null;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceText.ts\nvar collapseWhiteSpaceText = (text, state) => {\n  const textContent = text.textContent || \"\";\n  const isWhiteSpaceOnly = textContent.trim() === \"\";\n  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {\n    upsertInlineFormattingContext(state);\n  }\n  const { whiteSpaceRule } = state;\n  const trimStart = (() => {\n    if (whiteSpaceRule !== \"normal\") return \"collapse\";\n    if (!state.inlineFormattingContext || state.inlineFormattingContext.atStart || state.inlineFormattingContext.lastHasTrailingWhiteSpace)\n      return \"all\";\n    return \"collapse\";\n  })();\n  const trimEnd = (() => {\n    if (whiteSpaceRule === \"normal\") return \"collapse\";\n    if (isLastNonEmptyTextOfInlineFormattingContext(text))\n      return \"single-newline\";\n    return \"collapse\";\n  })();\n  const shouldCollapseWhiteSpace = {\n    normal: true,\n    pre: false,\n    \"pre-line\": true\n  }[whiteSpaceRule];\n  const whiteSpaceIncludesNewlines = whiteSpaceRule !== \"pre-line\";\n  const collapsedTextContent = collapseString(textContent || \"\", {\n    shouldCollapseWhiteSpace,\n    trimEnd,\n    trimStart,\n    whiteSpaceIncludesNewlines\n  });\n  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {\n    state.inlineFormattingContext.lastHasTrailingWhiteSpace = collapsedTextContent.endsWith(\" \");\n  }\n  text.textContent = collapsedTextContent;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceNode.ts\nvar collapseWhiteSpaceNode = (node, state) => {\n  if (isHtmlElement(node)) {\n    collapseWhiteSpaceElement(node, state);\n    return;\n  }\n  if (isHtmlText(node)) {\n    collapseWhiteSpaceText(node, state);\n    return;\n  }\n  collapseWhiteSpaceChildren(node, state);\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceChildren.ts\nvar collapseWhiteSpaceChildren = (node, state) => {\n  const childNodes = Array.from(node.childNodes);\n  for (const childNode of childNodes) {\n    collapseWhiteSpaceNode(childNode, state);\n  }\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/inferWhiteSpaceRule.ts\nvar inferWhiteSpaceRule = (element) => {\n  const whiteSpaceProperty = element.style.whiteSpace;\n  switch (whiteSpaceProperty) {\n    case \"break-spaces\":\n    case \"pre\":\n    case \"pre-wrap\": {\n      return \"pre\";\n    }\n    case \"normal\":\n    case \"nowrap\": {\n      return \"normal\";\n    }\n    case \"pre-line\": {\n      return \"pre-line\";\n    }\n  }\n  if (element.tagName === \"PRE\") {\n    return \"pre\";\n  }\n  if (whiteSpaceProperty === \"initial\") {\n    return \"normal\";\n  }\n  return null;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceElement.ts\nvar collapseWhiteSpaceElement = (element, state) => {\n  const isInlineElement = isHtmlInlineElement(element);\n  const previousWhiteSpaceRule = state.whiteSpaceRule;\n  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);\n  if (inferredWhiteSpaceRule) {\n    state.whiteSpaceRule = inferredWhiteSpaceRule;\n  }\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n  collapseWhiteSpaceChildren(element, state);\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n  state.whiteSpaceRule = previousWhiteSpaceRule;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpace.ts\nvar collapseWhiteSpace = (element) => {\n  const clonedElement = element.cloneNode(true);\n  const state = {\n    inlineFormattingContext: null,\n    whiteSpaceRule: \"normal\"\n  };\n  collapseWhiteSpaceElement(clonedElement, state);\n  return clonedElement;\n};\n\n// src/lib/plugins/html/utils/htmlBodyToFragment.ts\nimport { jsx } from \"slate-hyperscript\";\n\n// src/lib/plugins/html/utils/deserializeHtmlNodeChildren.ts\nvar deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).flatMap(\n  deserializeHtmlNode(editor)\n);\n\n// src/lib/plugins/html/utils/htmlBodyToFragment.ts\nvar htmlBodyToFragment = (editor, element) => {\n  if (element.nodeName === \"BODY\") {\n    return jsx(\n      \"fragment\",\n      {},\n      deserializeHtmlNodeChildren(editor, element)\n    );\n  }\n};\n\n// src/lib/plugins/html/utils/htmlBrToNewLine.ts\nvar htmlBrToNewLine = (node) => {\n  if (node.nodeName === \"BR\") {\n    return \"\\n\";\n  }\n};\n\n// src/lib/plugins/html/utils/htmlElementToElement.ts\nimport { jsx as jsx2 } from \"slate-hyperscript\";\n\n// src/lib/plugins/html/utils/pluginDeserializeHtml.ts\nimport { isDefined } from \"@udecode/utils\";\nimport castArray from \"lodash/castArray.js\";\nvar pluginDeserializeHtml = (editor, plugin, {\n  deserializeLeaf,\n  element: el\n}) => {\n  var _a, _b;\n  const {\n    node: { isElement: isElementRoot, isLeaf: isLeafRoot, type },\n    parsers\n  } = plugin;\n  const deserializer = (_a = parsers == null ? void 0 : parsers.html) == null ? void 0 : _a.deserializer;\n  if (!deserializer) return;\n  const {\n    attributeNames,\n    isElement: isElementRule,\n    isLeaf: isLeafRule,\n    query,\n    rules\n  } = deserializer;\n  let { parse } = deserializer;\n  const isElement4 = isElementRule || isElementRoot;\n  const isLeaf = isLeafRule || isLeafRoot;\n  if (!deserializeLeaf && !isElement4) {\n    return;\n  }\n  if (deserializeLeaf && !isLeaf) {\n    return;\n  }\n  if (rules) {\n    const isValid = rules.some(\n      ({ validAttribute, validClassName, validNodeName = \"*\", validStyle }) => {\n        var _a2;\n        if (validNodeName) {\n          const validNodeNames = castArray(validNodeName);\n          if (validNodeNames.length > 0 && !validNodeNames.includes(el.nodeName) && validNodeName !== \"*\")\n            return false;\n        }\n        if (validClassName && !el.classList.contains(validClassName))\n          return false;\n        if (validStyle) {\n          for (const [key, value] of Object.entries(validStyle)) {\n            const values = castArray(value);\n            if (!values.includes(el.style[key]) && value !== \"*\")\n              return;\n            if (value === \"*\" && !el.style[key]) return;\n            const defaultNodeValue = (_a2 = plugin.inject.nodeProps) == null ? void 0 : _a2.defaultNodeValue;\n            if (defaultNodeValue && defaultNodeValue === el.style[key]) {\n              return false;\n            }\n          }\n        }\n        if (validAttribute) {\n          if (typeof validAttribute === \"string\") {\n            if (!el.getAttributeNames().includes(validAttribute)) return false;\n          } else {\n            for (const [attributeName, attributeValue] of Object.entries(\n              validAttribute\n            )) {\n              const attributeValues = castArray(attributeValue);\n              const elAttribute = el.getAttribute(attributeName);\n              if (!isDefined(elAttribute) || !attributeValues.includes(elAttribute))\n                return false;\n            }\n          }\n        }\n        return true;\n      }\n    );\n    if (!isValid) return;\n  }\n  if (query && !query(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), { element: el }))) {\n    return;\n  }\n  if (!parse) {\n    if (isElement4) {\n      parse = () => ({ type });\n    } else if (isLeaf) {\n      parse = () => ({ [type]: true });\n    } else {\n      return;\n    }\n  }\n  let node = (_b = parse(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n    element: el,\n    node: {}\n  }))) != null ? _b : {};\n  if (Object.keys(node).length === 0) return;\n  const injectedPlugins = getInjectedPlugins(editor, plugin);\n  injectedPlugins.forEach((injectedPlugin) => {\n    var _a2, _b2, _c, _d;\n    const res = (_d = (_c = (_b2 = (_a2 = injectedPlugin.parsers) == null ? void 0 : _a2.html) == null ? void 0 : _b2.deserializer) == null ? void 0 : _c.parse) == null ? void 0 : _d.call(_c, __spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n      element: el,\n      node\n    }));\n    if (res) {\n      node = __spreadValues(__spreadValues({}, node), res);\n    }\n  });\n  if (attributeNames) {\n    const elementAttributes = {};\n    const elementAttributeNames = el.getAttributeNames();\n    for (const elementAttributeName of elementAttributeNames) {\n      if (attributeNames.includes(elementAttributeName)) {\n        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);\n      }\n    }\n    if (Object.keys(elementAttributes).length > 0) {\n      node.attributes = elementAttributes;\n    }\n  }\n  return __spreadProps(__spreadValues({}, deserializer), { node });\n};\n\n// src/lib/plugins/html/utils/pipeDeserializeHtmlElement.ts\nvar pipeDeserializeHtmlElement = (editor, element) => {\n  let result;\n  [...editor.pluginList].reverse().some((plugin) => {\n    result = pluginDeserializeHtml(editor, plugin, { element });\n    return !!result;\n  });\n  return result;\n};\n\n// src/lib/plugins/html/utils/htmlElementToElement.ts\nvar htmlElementToElement = (editor, element) => {\n  var _a;\n  const deserialized = pipeDeserializeHtmlElement(editor, element);\n  if (deserialized) {\n    const { node, withoutChildren } = deserialized;\n    let descendants = (_a = node.children) != null ? _a : deserializeHtmlNodeChildren(editor, element);\n    if (descendants.length === 0 || withoutChildren) {\n      descendants = [{ text: \"\" }];\n    }\n    return jsx2(\"element\", node, descendants);\n  }\n};\n\n// src/lib/plugins/html/utils/htmlElementToLeaf.ts\nimport { isElement as isElement2, isText } from \"@udecode/slate\";\nimport { jsx as jsx3 } from \"slate-hyperscript\";\n\n// src/lib/plugins/html/utils/pipeDeserializeHtmlLeaf.ts\nvar pipeDeserializeHtmlLeaf = (editor, element) => {\n  let node = {};\n  [...editor.pluginList].reverse().forEach((plugin) => {\n    const deserialized = pluginDeserializeHtml(editor, plugin, {\n      deserializeLeaf: true,\n      element\n    });\n    if (!deserialized) return;\n    node = __spreadValues(__spreadValues({}, node), deserialized.node);\n  });\n  return node;\n};\n\n// src/lib/plugins/html/utils/htmlElementToLeaf.ts\nvar htmlElementToLeaf = (editor, element) => {\n  const node = pipeDeserializeHtmlLeaf(editor, element);\n  return deserializeHtmlNodeChildren(editor, element).reduce(\n    (arr, child) => {\n      if (!child) return arr;\n      if (isElement2(child)) {\n        if (Object.keys(node).length > 0) {\n          mergeDeepToNodes({\n            node: child,\n            query: {\n              filter: ([n]) => isText(n)\n            },\n            source: node\n          });\n        }\n        arr.push(child);\n      } else {\n        const attributes = __spreadValues({}, node);\n        if (isText(child) && child.text) {\n          Object.keys(attributes).forEach((key) => {\n            if (attributes[key] && child[key]) {\n              attributes[key] = child[key];\n            }\n          });\n        }\n        arr.push(jsx3(\"text\", attributes, child));\n      }\n      return arr;\n    },\n    []\n  );\n};\n\n// src/lib/plugins/html/utils/htmlTextNodeToString.ts\nvar htmlTextNodeToString = (node) => {\n  if (isHtmlText(node)) {\n    return node.textContent || \"\";\n  }\n};\n\n// src/lib/plugins/html/utils/deserializeHtmlNode.ts\nvar deserializeHtmlNode = (editor) => (node) => {\n  const textNode = htmlTextNodeToString(node);\n  if (textNode) return textNode;\n  if (!isHtmlElement(node)) return null;\n  const breakLine = htmlBrToNewLine(node);\n  if (breakLine) return breakLine;\n  const fragment = htmlBodyToFragment(editor, node);\n  if (fragment) return fragment;\n  const element = htmlElementToElement(editor, node);\n  if (element) return element;\n  return htmlElementToLeaf(editor, node);\n};\n\n// src/lib/plugins/html/utils/deserializeHtmlElement.ts\nvar deserializeHtmlElement = (editor, element) => {\n  return deserializeHtmlNode(editor)(element);\n};\n\n// src/lib/plugins/html/utils/htmlStringToDOMNode.ts\nvar htmlStringToDOMNode = (rawHtml) => {\n  const node = document.createElement(\"body\");\n  node.innerHTML = rawHtml;\n  return node;\n};\n\n// src/lib/plugins/html/utils/deserializeHtml.ts\nvar deserializeHtml = (editor, {\n  collapseWhiteSpace: shouldCollapseWhiteSpace = true,\n  element\n}) => {\n  if (typeof element === \"string\") {\n    element = htmlStringToDOMNode(element);\n  }\n  if (shouldCollapseWhiteSpace) {\n    element = collapseWhiteSpace(element);\n  }\n  const fragment = deserializeHtmlElement(editor, element);\n  return normalizeDescendantsToDocumentFragment(editor, {\n    descendants: fragment\n  });\n};\n\n// src/lib/plugins/html/utils/parseHtmlDocument.ts\nvar parseHtmlDocument = (html) => {\n  return new DOMParser().parseFromString(html, \"text/html\");\n};\n\n// src/lib/plugins/html/HtmlPlugin.ts\nvar HtmlPlugin = createSlatePlugin({\n  key: \"html\"\n}).extendApi(({ editor }) => ({\n  deserialize: bindFirst2(deserializeHtml, editor)\n})).extend({\n  parser: {\n    deserialize: ({ api, data }) => {\n      const document2 = parseHtmlDocument(data);\n      return api.html.deserialize({\n        element: document2.body\n      });\n    },\n    format: \"text/html\"\n  }\n});\n\n// src/lib/plugins/length/LengthPlugin.ts\nimport { getEditorString, withoutNormalizing } from \"@udecode/slate\";\nvar withLength = ({\n  editor,\n  getOptions\n}) => {\n  const { apply } = editor;\n  editor.apply = (operation) => {\n    withoutNormalizing(editor, () => {\n      apply(operation);\n      const options = getOptions();\n      if (options.maxLength) {\n        const length = getEditorString(editor, []).length;\n        if (length > options.maxLength) {\n          const overflowLength = length - options.maxLength;\n          editor.delete({\n            distance: overflowLength,\n            reverse: true,\n            unit: \"character\"\n          });\n        }\n      }\n    });\n  };\n  return editor;\n};\nvar LengthPlugin = createTSlatePlugin({\n  key: \"length\",\n  extendEditor: withLength\n});\n\n// src/lib/plugins/getCorePlugins.ts\nvar getCorePlugins = ({\n  maxLength,\n  plugins = []\n}) => {\n  let corePlugins = [\n    DebugPlugin,\n    SlateNextPlugin,\n    DOMPlugin,\n    HistoryPlugin,\n    InlineVoidPlugin,\n    ParserPlugin,\n    maxLength ? LengthPlugin.configure({\n      options: { maxLength }\n    }) : LengthPlugin,\n    HtmlPlugin,\n    AstPlugin,\n    BaseParagraphPlugin\n  ];\n  const customPluginsMap = new Map(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n  corePlugins = corePlugins.map((corePlugin) => {\n    const customPlugin = customPluginsMap.get(corePlugin.key);\n    if (customPlugin) {\n      const index = plugins.findIndex((p) => p.key === corePlugin.key);\n      if (index !== -1) {\n        plugins.splice(index, 1);\n      }\n      return customPlugin;\n    }\n    return corePlugin;\n  });\n  return corePlugins;\n};\n\n// src/lib/utils/normalizeDescendantsToDocumentFragment.ts\nvar isInlineNode = (editor) => (node) => isText2(node) || isElement3(node) && editor.isInline(node);\nvar makeBlockLazy = (type) => () => ({\n  children: [],\n  type\n});\nvar hasDifferentChildNodes = (descendants, isInline) => {\n  return descendants.some((descendant, index, arr) => {\n    const prevDescendant = arr[index - 1];\n    if (index !== 0) {\n      return isInline(descendant) !== isInline(prevDescendant);\n    }\n    return false;\n  });\n};\nvar normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock) => {\n  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);\n  const { fragment } = descendants.reduce(\n    (memo, node) => {\n      if (hasDifferentNodes && isInline(node)) {\n        let block = memo.precedingBlock;\n        if (!block) {\n          block = makeDefaultBlock();\n          memo.precedingBlock = block;\n          memo.fragment.push(block);\n        }\n        block.children.push(node);\n      } else {\n        memo.fragment.push(node);\n        memo.precedingBlock = null;\n      }\n      return memo;\n    },\n    {\n      fragment: [],\n      precedingBlock: null\n    }\n  );\n  return fragment;\n};\nvar normalizeEmptyChildren = (descendants) => {\n  if (descendants.length === 0) {\n    return [{ text: \"\" }];\n  }\n  return descendants;\n};\nvar normalize = (descendants, isInline, makeDefaultBlock) => {\n  descendants = normalizeEmptyChildren(descendants);\n  descendants = normalizeDifferentNodeTypes(\n    descendants,\n    isInline,\n    makeDefaultBlock\n  );\n  descendants = descendants.map((node) => {\n    if (isElement3(node)) {\n      return __spreadProps(__spreadValues({}, node), {\n        children: normalize(\n          node.children,\n          isInline,\n          makeDefaultBlock\n        )\n      });\n    }\n    return node;\n  });\n  return descendants;\n};\nvar normalizeDescendantsToDocumentFragment = (editor, { descendants }) => {\n  const isInline = isInlineNode(editor);\n  const defaultType = editor.getType(BaseParagraphPlugin);\n  const makeDefaultBlock = makeBlockLazy(defaultType);\n  return normalize(descendants, isInline, makeDefaultBlock);\n};\n\n// src/lib/utils/pipeInsertDataQuery.ts\nvar pipeInsertDataQuery = (editor, plugins, { data, dataTransfer }) => plugins.every((p) => {\n  var _a;\n  const query = (_a = p.parser) == null ? void 0 : _a.query;\n  return !query || query(__spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n    data,\n    dataTransfer\n  }));\n});\n\n// src/lib/utils/pipeInsertFragment.ts\nimport { withoutNormalizing as withoutNormalizing2 } from \"@udecode/slate\";\nvar pipeInsertFragment = (editor, injectedPlugins, _a) => {\n  var _b = _a, { fragment } = _b, options = __objRest(_b, [\"fragment\"]);\n  withoutNormalizing2(editor, () => {\n    injectedPlugins.some((p) => {\n      var _a2, _b2;\n      return ((_b2 = (_a2 = p.parser) == null ? void 0 : _a2.preInsert) == null ? void 0 : _b2.call(_a2, __spreadValues(__spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n        fragment\n      }), options))) === true;\n    });\n    editor.insertFragment(fragment);\n  });\n};\n\n// src/lib/utils/pipeNormalizeInitialValue.ts\nvar pipeNormalizeInitialValue = (editor) => {\n  editor.pluginList.forEach((p) => {\n    var _a;\n    const normalizedValue = (_a = p.normalizeInitialValue) == null ? void 0 : _a.call(p, __spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n      value: editor.children\n    }));\n    if (normalizedValue) {\n      editor.children = normalizedValue;\n    }\n  });\n};\n\n// src/lib/utils/pipeTransformData.ts\nvar pipeTransformData = (editor, plugins, { data, dataTransfer }) => {\n  plugins.forEach((p) => {\n    var _a;\n    const transformData = (_a = p.parser) == null ? void 0 : _a.transformData;\n    if (!transformData) return;\n    data = transformData(__spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n      data,\n      dataTransfer\n    }));\n  });\n  return data;\n};\n\n// src/lib/utils/pipeTransformFragment.ts\nvar pipeTransformFragment = (editor, plugins, _a) => {\n  var _b = _a, { fragment } = _b, options = __objRest(_b, [\"fragment\"]);\n  plugins.forEach((p) => {\n    var _a2;\n    const transformFragment = (_a2 = p.parser) == null ? void 0 : _a2.transformFragment;\n    if (!transformFragment) return;\n    fragment = transformFragment(__spreadValues(__spreadValues({\n      fragment\n    }, options), getEditorPlugin(editor, p)));\n  });\n  return fragment;\n};\n\n// src/lib/utils/resolvePlugin.ts\nimport merge2 from \"lodash/merge.js\";\nvar resolvePlugin = (editor, _plugin) => {\n  var _a, _b, _c, _d;\n  let plugin = mergePlugins({}, _plugin);\n  plugin.__resolved = true;\n  if (plugin.__configuration) {\n    const configResult = plugin.__configuration(\n      getEditorPlugin(editor, plugin)\n    );\n    plugin = mergePlugins(plugin, configResult);\n    delete plugin.__configuration;\n  }\n  if (plugin.__extensions && plugin.__extensions.length > 0) {\n    plugin.__extensions.forEach((extension) => {\n      plugin = mergePlugins(\n        plugin,\n        extension(getEditorPlugin(editor, plugin))\n      );\n    });\n    plugin.__extensions = [];\n  }\n  const targetPluginToInject = (_a = plugin.inject) == null ? void 0 : _a.targetPluginToInject;\n  const targetPlugins = (_b = plugin.inject) == null ? void 0 : _b.targetPlugins;\n  if (targetPluginToInject && targetPlugins && targetPlugins.length > 0) {\n    plugin.inject = plugin.inject || {};\n    plugin.inject.plugins = merge2(\n      {},\n      plugin.inject.plugins,\n      Object.fromEntries(\n        targetPlugins.map((targetPlugin) => {\n          const injectedPlugin = targetPluginToInject(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n            targetPlugin\n          }));\n          return [targetPlugin, injectedPlugin];\n        })\n      )\n    );\n  }\n  if ((_c = plugin.node) == null ? void 0 : _c.component) {\n    plugin.render.node = plugin.node.component;\n  }\n  if ((_d = plugin.render) == null ? void 0 : _d.node) {\n    plugin.node.component = plugin.render.node;\n  }\n  validatePlugin(editor, plugin);\n  return plugin;\n};\nvar validatePlugin = (editor, plugin) => {\n  if (!plugin.__extensions) {\n    editor.api.debug.error(\n      `Invalid plugin '${plugin.key}', you should use createSlatePlugin.`,\n      \"USE_CREATE_PLUGIN\"\n    );\n  }\n  if (plugin.node.isElement && plugin.node.isLeaf) {\n    editor.api.debug.error(\n      `Plugin ${plugin.key} cannot be both an element and a leaf.`,\n      \"PLUGIN_NODE_TYPE\"\n    );\n  }\n};\n\n// src/lib/utils/resolvePlugins.ts\nimport { isDefined as isDefined2 } from \"@udecode/utils\";\nimport merge3 from \"lodash/merge.js\";\nimport { createZustandStore } from \"zustand-x\";\nvar resolvePlugins = (editor, plugins = []) => {\n  editor.pluginList = [];\n  editor.plugins = {};\n  editor.api = {};\n  editor.transforms = {};\n  editor.tf = editor.transforms;\n  editor.shortcuts = {};\n  const resolvedPlugins = resolveAndSortPlugins(editor, plugins);\n  applyPluginsToEditor(editor, resolvedPlugins);\n  resolvePluginOverrides(editor);\n  resolvePluginStores(editor);\n  resolvePluginApis(editor);\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.extendEditor) {\n      editor = plugin.extendEditor(getEditorPlugin(editor, plugin));\n    }\n  });\n  return editor;\n};\nvar resolvePluginStores = (editor) => {\n  editor.pluginList.forEach((plugin) => {\n    let store = createZustandStore(plugin.key)(plugin.options, {\n      immer: {\n        enableMapSet: true\n      }\n    });\n    if (plugin.__optionExtensions && plugin.__optionExtensions.length > 0) {\n      plugin.__optionExtensions.forEach((extension) => {\n        const extendedOptions = extension(getEditorPlugin(editor, plugin));\n        store = store.extendSelectors(() => extendedOptions);\n      });\n    }\n    plugin.optionsStore = store;\n  });\n};\nvar resolvePluginApis = (editor) => {\n  const shortcutsByPriority = [];\n  editor.pluginList.forEach((plugin) => {\n    Object.entries(plugin.api).forEach(([apiKey, apiFunction]) => {\n      editor.api[apiKey] = apiFunction;\n    });\n    if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {\n      plugin.__apiExtensions.forEach(\n        ({ extension, isPluginSpecific, isTransform }) => {\n          const newExtensions = extension(\n            getEditorPlugin(editor, plugin)\n          );\n          if (isTransform) {\n            if (isPluginSpecific) {\n              if (!editor.transforms[plugin.key]) {\n                editor.transforms[plugin.key] = {};\n              }\n              if (!plugin.transforms[plugin.key]) {\n                plugin.transforms[plugin.key] = {};\n              }\n              merge3(editor.transforms[plugin.key], newExtensions);\n              merge3(plugin.transforms[plugin.key], newExtensions);\n            } else {\n              merge3(editor.transforms, newExtensions);\n              merge3(plugin.transforms, newExtensions);\n            }\n          } else {\n            if (isPluginSpecific) {\n              if (!editor.api[plugin.key]) {\n                editor.api[plugin.key] = {};\n              }\n              if (!plugin.api[plugin.key]) {\n                plugin.api[plugin.key] = {};\n              }\n              merge3(editor.api[plugin.key], newExtensions);\n              merge3(plugin.api[plugin.key], newExtensions);\n            } else {\n              merge3(editor.api, newExtensions);\n              merge3(plugin.api, newExtensions);\n            }\n          }\n        }\n      );\n      delete plugin.__apiExtensions;\n    }\n    Object.entries(plugin.shortcuts).forEach(([key, hotkey]) => {\n      var _a;\n      if (hotkey === null) {\n        const index = shortcutsByPriority.findIndex((item) => item.key === key);\n        if (index !== -1) {\n          shortcutsByPriority.splice(index, 1);\n        }\n      } else {\n        const priority = (_a = hotkey.priority) != null ? _a : plugin.priority;\n        const existingIndex = shortcutsByPriority.findIndex(\n          (item) => item.key === key\n        );\n        if (existingIndex === -1 || priority >= shortcutsByPriority[existingIndex].priority) {\n          if (existingIndex !== -1) {\n            shortcutsByPriority.splice(existingIndex, 1);\n          }\n          shortcutsByPriority.push({ key, hotkey, priority });\n        }\n      }\n    });\n  });\n  shortcutsByPriority.sort((a, b) => b.hotkey.priority - a.hotkey.priority);\n  editor.shortcuts = Object.fromEntries(\n    shortcutsByPriority.map(({ key, hotkey }) => {\n      const _a = hotkey, { priority } = _a, hotkeyWithoutPriority = __objRest(_a, [\"priority\"]);\n      return [key, hotkeyWithoutPriority];\n    })\n  );\n};\nvar flattenAndResolvePlugins = (editor, plugins) => {\n  const pluginMap = /* @__PURE__ */ new Map();\n  const processPlugin = (plugin) => {\n    const resolvedPlugin = resolvePlugin(editor, plugin);\n    const existingPlugin = pluginMap.get(resolvedPlugin.key);\n    if (existingPlugin) {\n      pluginMap.set(\n        resolvedPlugin.key,\n        mergePlugins(existingPlugin, resolvedPlugin)\n      );\n    } else {\n      pluginMap.set(resolvedPlugin.key, resolvedPlugin);\n    }\n    if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {\n      resolvedPlugin.plugins.forEach(processPlugin);\n    }\n  };\n  plugins.forEach(processPlugin);\n  return pluginMap;\n};\nvar resolveAndSortPlugins = (editor, plugins) => {\n  const pluginMap = flattenAndResolvePlugins(editor, plugins);\n  const enabledPlugins = Array.from(pluginMap.values()).filter(\n    (plugin) => plugin.enabled !== false\n  );\n  enabledPlugins.sort((a, b) => b.priority - a.priority);\n  const orderedPlugins = [];\n  const visited = /* @__PURE__ */ new Set();\n  const visit = (plugin) => {\n    var _a;\n    if (visited.has(plugin.key)) return;\n    visited.add(plugin.key);\n    (_a = plugin.dependencies) == null ? void 0 : _a.forEach((depKey) => {\n      const depPlugin = pluginMap.get(depKey);\n      if (depPlugin) {\n        visit(depPlugin);\n      } else {\n        editor.api.debug.warn(\n          `Plugin \"${plugin.key}\" depends on missing plugin \"${depKey}\"`,\n          \"PLUGIN_DEPENDENCY_MISSING\"\n        );\n      }\n    });\n    orderedPlugins.push(plugin);\n  };\n  enabledPlugins.forEach(visit);\n  return orderedPlugins;\n};\nvar applyPluginsToEditor = (editor, plugins) => {\n  editor.pluginList = plugins;\n  editor.plugins = Object.fromEntries(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n};\nvar resolvePluginOverrides = (editor) => {\n  const applyOverrides = (plugins) => {\n    let overriddenPlugins = [...plugins];\n    const enabledOverrides = {};\n    const componentOverrides = {};\n    const pluginOverrides = {};\n    for (const plugin of plugins) {\n      if (plugin.override.enabled) {\n        Object.assign(enabledOverrides, plugin.override.enabled);\n      }\n      if (plugin.override.components) {\n        Object.entries(plugin.override.components).forEach(\n          ([key, component]) => {\n            if (!componentOverrides[key] || plugin.priority > componentOverrides[key].priority) {\n              componentOverrides[key] = {\n                component,\n                priority: plugin.priority\n              };\n            }\n          }\n        );\n      }\n      if (plugin.override.plugins) {\n        Object.entries(plugin.override.plugins).forEach(([key, value]) => {\n          pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);\n          if (value.enabled !== void 0) {\n            enabledOverrides[key] = value.enabled;\n          }\n        });\n      }\n    }\n    overriddenPlugins = overriddenPlugins.map((p) => {\n      var _a;\n      let updatedPlugin = __spreadValues({}, p);\n      if (pluginOverrides[p.key]) {\n        updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);\n      }\n      if (componentOverrides[p.key] && (!p.render.node && !p.node.component || componentOverrides[p.key].priority > p.priority)) {\n        updatedPlugin.render.node = componentOverrides[p.key].component;\n        updatedPlugin.node.component = componentOverrides[p.key].component;\n      }\n      const enabled = (_a = enabledOverrides[p.key]) != null ? _a : updatedPlugin.enabled;\n      if (isDefined2(enabled)) {\n        updatedPlugin.enabled = enabled;\n      }\n      return updatedPlugin;\n    });\n    return overriddenPlugins.filter((p) => p.enabled !== false).map((plugin) => __spreadProps(__spreadValues({}, plugin), {\n      plugins: applyOverrides(plugin.plugins || [])\n    }));\n  };\n  editor.pluginList = applyOverrides(editor.pluginList);\n  editor.plugins = Object.fromEntries(\n    editor.pluginList.map((plugin) => [plugin.key, plugin])\n  );\n};\n\n// src/lib/utils/misc/getSlateClass.ts\nvar getSlateClass = (type) => type ? `slate-${type}` : \"\";\n\n// src/lib/plugin/getSlatePlugin.ts\nfunction getSlatePlugin(editor, p) {\n  let plugin = p;\n  const editorPlugin = editor.plugins[p.key];\n  if (!editorPlugin) {\n    if (!plugin.node) {\n      plugin = createSlatePlugin(plugin);\n    }\n    return plugin.__resolved ? plugin : resolvePlugin(editor, plugin);\n  }\n  return editorPlugin;\n}\nfunction getPluginType(editor, plugin) {\n  var _a, _b;\n  const p = editor.getPlugin(plugin);\n  return (_b = (_a = p.node.type) != null ? _a : p.key) != null ? _b : \"\";\n}\n\n// src/lib/editor/withSlate.ts\nvar withSlate = (e, _a = {}) => {\n  var _b = _a, {\n    id,\n    autoSelect,\n    maxLength,\n    plugins = [],\n    rootPlugin,\n    selection,\n    shouldNormalizeEditor,\n    value\n  } = _b, pluginConfig = __objRest(_b, [\n    \"id\",\n    \"autoSelect\",\n    \"maxLength\",\n    \"plugins\",\n    \"rootPlugin\",\n    \"selection\",\n    \"shouldNormalizeEditor\",\n    \"value\"\n  ]);\n  var _a2, _b2;\n  const editor = e;\n  editor.id = id != null ? id : editor.id;\n  editor.key = (_a2 = editor.key) != null ? _a2 : nanoid();\n  editor.isFallback = false;\n  editor.getApi = () => editor.api;\n  editor.getTransforms = () => editor.transforms;\n  editor.getPlugin = (plugin) => getSlatePlugin(editor, plugin);\n  editor.getType = (plugin) => getPluginType(editor, plugin);\n  editor.getInjectProps = (plugin) => {\n    var _a3, _b3;\n    return (_b3 = (_a3 = editor.getPlugin(plugin).inject) == null ? void 0 : _a3.nodeProps) != null ? _b3 : {};\n  };\n  editor.getOptionsStore = (plugin) => {\n    return editor.getPlugin(plugin).optionsStore;\n  };\n  editor.getOptions = (plugin) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return editor.getPlugin(plugin).options;\n    return editor.getOptionsStore(plugin).get.state();\n  };\n  editor.getOption = (plugin, key, ...args) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return editor.getPlugin(plugin).options[key];\n    const getter = store.get[key];\n    if (getter) {\n      return getter(...args);\n    }\n    editor.api.debug.error(\n      `editor.getOption: ${key} option is not defined in plugin ${plugin.key}.`,\n      \"OPTION_UNDEFINED\"\n    );\n  };\n  editor.setOption = (plugin, key, value2) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return;\n    const setter = store.set[key];\n    if (setter) {\n      setter(value2);\n    } else {\n      editor.api.debug.error(\n        `editor.setOption: ${key} option is not defined in plugin ${plugin.key}.`,\n        \"OPTION_UNDEFINED\"\n      );\n    }\n  };\n  editor.setOptions = (plugin, options) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return;\n    if (typeof options === \"object\") {\n      store.set.mergeState(options);\n    } else if (typeof options === \"function\") {\n      store.set.state(options);\n    }\n  };\n  const corePlugins = getCorePlugins({\n    maxLength,\n    plugins\n  });\n  let rootPluginInstance = createSlatePlugin(__spreadProps(__spreadValues({\n    key: \"root\",\n    priority: 1e4\n  }, pluginConfig), {\n    plugins: [...corePlugins, ...plugins]\n  }));\n  if (rootPlugin) {\n    rootPluginInstance = rootPlugin(rootPluginInstance);\n  }\n  resolvePlugins(editor, [rootPluginInstance]);\n  if (typeof value === \"string\") {\n    editor.children = editor.api.html.deserialize({ element: value });\n  } else if (typeof value === \"function\") {\n    editor.children = value(editor);\n  } else if (value) {\n    editor.children = value;\n  }\n  if (!editor.children || ((_b2 = editor.children) == null ? void 0 : _b2.length) === 0) {\n    editor.children = editor.api.create.value();\n  }\n  if (selection) {\n    editor.selection = selection;\n  } else if (autoSelect) {\n    const edge = autoSelect === \"start\" ? \"start\" : \"end\";\n    const target = edge === \"start\" ? getStartPoint(editor, []) : getEndPoint(editor, []);\n    select(editor, target);\n  }\n  if (editor.children.length > 0) {\n    pipeNormalizeInitialValue(editor);\n  }\n  if (shouldNormalizeEditor) {\n    normalizeEditor(editor, { force: true });\n  }\n  return editor;\n};\n\n// src/lib/libs/zustand.ts\nimport { createZustandStore as createZustandStore2 } from \"zustand-x\";\n\n// src/react/plugin/toPlatePlugin.ts\nvar methodsToWrap = [\n  \"configure\",\n  \"configurePlugin\",\n  \"extendEditorApi\",\n  \"extendApi\",\n  \"extendEditorTransforms\",\n  \"extend\",\n  \"extendPlugin\"\n];\nfunction toPlatePlugin(basePlugin, extendConfig) {\n  const plugin = __spreadValues({}, basePlugin);\n  methodsToWrap.forEach((method) => {\n    const originalMethod = plugin[method];\n    plugin[method] = (...args) => {\n      const slatePlugin = originalMethod(...args);\n      return toPlatePlugin(slatePlugin);\n    };\n  });\n  plugin.withComponent = (component) => {\n    return plugin.extend({\n      node: { component },\n      render: { node: component }\n    });\n  };\n  if (!extendConfig) return plugin;\n  const extendedPlugin = plugin.extend(extendConfig);\n  return extendedPlugin;\n}\nfunction toTPlatePlugin(basePlugin, extendConfig) {\n  return toPlatePlugin(basePlugin, extendConfig);\n}\n\n// src/react/plugin/createPlatePlugin.ts\nvar createPlatePlugin = (config = {}) => {\n  const plugin = createSlatePlugin(config);\n  return toPlatePlugin(plugin);\n};\nfunction createTPlatePlugin(config = {}) {\n  return createPlatePlugin(config);\n}\n\n// src/react/plugin/getEditorPlugin.ts\nfunction getEditorPlugin2(editor, plugin) {\n  return __spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n    useOption: (key, ...args) => editor.useOption(plugin, key, ...args)\n  });\n}\n\n// src/react/plugin/getPlugin.ts\nfunction getPlugin(editor, plugin) {\n  var _a;\n  return (_a = editor.plugins[plugin.key]) != null ? _a : createPlatePlugin({ key: plugin.key });\n}\n\n// src/react/plugin/omitPluginContext.ts\nvar omitPluginContext = (ctx) => {\n  const _a = ctx, {\n    api,\n    editor,\n    getOption,\n    getOptions,\n    plugin,\n    setOption,\n    setOptions,\n    tf,\n    type,\n    useOption\n  } = _a, rest = __objRest(_a, [\n    \"api\",\n    \"editor\",\n    \"getOption\",\n    \"getOptions\",\n    \"plugin\",\n    \"setOption\",\n    \"setOptions\",\n    \"tf\",\n    \"type\",\n    \"useOption\"\n  ]);\n  return rest;\n};\n\n// src/react/components/DefaultLeaf.tsx\nvar useDefaultLeaf = (props) => {\n  const _a = omitPluginContext(props), { attributes, leaf, leafToAttributes, nodeProps, text } = _a, rootProps = __objRest(_a, [\"attributes\", \"leaf\", \"leafToAttributes\", \"nodeProps\", \"text\"]);\n  return {\n    props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, attributes), rootProps), nodeProps), leafToAttributes == null ? void 0 : leafToAttributes(leaf)), {\n      className: clsx(props.className, nodeProps == null ? void 0 : nodeProps.className)\n    })\n  };\n};\nfunction DefaultLeaf(props) {\n  const { props: rootProps } = useDefaultLeaf(props);\n  return /* @__PURE__ */ React.createElement(\"span\", __spreadValues({}, rootProps));\n}\n\n// src/react/components/EditorHotkeysEffect.tsx\nimport React11, { useEffect as useEffect2 } from \"react\";\nimport { useHotkeys } from \"@udecode/react-hotkeys\";\nimport { isDefined as isDefined4 } from \"@udecode/utils\";\n\n// src/react/stores/plate/PlateStore.ts\nvar EXPOSED_STORE_KEYS = [\n  \"readOnly\",\n  \"onChange\",\n  \"decorate\",\n  \"renderElement\",\n  \"renderLeaf\"\n];\n\n// src/react/stores/plate/createPlateStore.ts\nimport React3 from \"react\";\nimport { atom as atom3, createStore } from \"jotai\";\n\n// src/react/libs/jotai.ts\nimport { atom } from \"jotai\";\nimport { createAtomStore } from \"jotai-x\";\n\n// src/react/stores/plate-controller/plateControllerStore.ts\nimport React2 from \"react\";\nimport { atom as atom2 } from \"jotai\";\nvar {\n  PlateControllerProvider: PlateController,\n  plateControllerStore,\n  usePlateControllerStore\n} = createAtomStore(\n  {\n    activeId: atom2(null),\n    editorStores: atom2({}),\n    primaryEditorIds: atom2([])\n  },\n  {\n    name: \"plateController\"\n  }\n);\nvar usePlateControllerSelectors = () => usePlateControllerStore().get;\nvar usePlateControllerActions = () => usePlateControllerStore().set;\nvar usePlateControllerStates = () => usePlateControllerStore().use;\nvar usePlateControllerExists = () => !!usePlateControllerStore().store({ warnIfNoStore: false });\nvar usePlateControllerEditorStore = (idProp) => {\n  const storeAtom = React2.useMemo(\n    () => atom2((get) => {\n      const editorStores = get(plateControllerStore.atom.editorStores);\n      const forId = (id) => {\n        var _a;\n        if (!id) return null;\n        return (_a = editorStores[id]) != null ? _a : null;\n      };\n      if (idProp) return forId(idProp);\n      const lookupOrder = [\n        get(plateControllerStore.atom.activeId),\n        ...get(plateControllerStore.atom.primaryEditorIds)\n      ];\n      for (const id of lookupOrder) {\n        const store = forId(id);\n        if (store) return store;\n      }\n      return null;\n    }),\n    [idProp]\n  );\n  return usePlateControllerSelectors().atom(storeAtom);\n};\n\n// src/react/stores/plate/createPlateStore.ts\nvar PLATE_SCOPE = \"plate\";\nvar GLOBAL_PLATE_SCOPE = Symbol(\"global-plate\");\nvar createPlateStore = (_a = {}) => {\n  var _b = _a, {\n    id,\n    containerRef = { current: null },\n    decorate = null,\n    editor,\n    isMounted = false,\n    primary = true,\n    readOnly = null,\n    renderElement = null,\n    renderLeaf = null,\n    scrollRef = { current: null },\n    versionDecorate = 1,\n    versionEditor = 1,\n    versionSelection = 1,\n    versionValue = 1,\n    onChange = null,\n    onSelectionChange = null,\n    onValueChange = null\n  } = _b, state = __objRest(_b, [\n    \"id\",\n    \"containerRef\",\n    \"decorate\",\n    \"editor\",\n    \"isMounted\",\n    \"primary\",\n    \"readOnly\",\n    \"renderElement\",\n    \"renderLeaf\",\n    \"scrollRef\",\n    \"versionDecorate\",\n    \"versionEditor\",\n    \"versionSelection\",\n    \"versionValue\",\n    \"onChange\",\n    \"onSelectionChange\",\n    \"onValueChange\"\n  ]);\n  return createAtomStore(\n    __spreadValues({\n      containerRef,\n      decorate,\n      editor,\n      isMounted,\n      primary,\n      readOnly,\n      renderElement,\n      renderLeaf,\n      scrollRef,\n      versionDecorate,\n      versionEditor,\n      versionSelection,\n      versionValue,\n      onChange,\n      onSelectionChange,\n      onValueChange\n    }, state),\n    {\n      extend: (atoms) => ({\n        trackedEditor: atom3((get) => ({\n          editor: get(atoms.editor),\n          version: get(atoms.versionEditor)\n        })),\n        trackedSelection: atom3((get) => ({\n          selection: get(atoms.editor).selection,\n          version: get(atoms.versionSelection)\n        })),\n        trackedValue: atom3((get) => ({\n          value: get(atoms.editor).children,\n          version: get(atoms.versionValue)\n        }))\n      }),\n      name: \"plate\"\n    }\n  );\n};\nvar {\n  PlateProvider: PlateStoreProvider,\n  plateStore,\n  usePlateStore\n} = createPlateStore();\nvar usePlateEditorStore = (id, { debugHookName = \"usePlateEditorStore\" } = {}) => {\n  var _a;\n  const localStore = (_a = usePlateStore(id).store({ warnIfNoStore: false })) != null ? _a : null;\n  const [localStoreExists] = React3.useState(!!localStore);\n  const store = localStoreExists ? localStore : (\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    usePlateControllerEditorStore(id)\n  );\n  const plateControllerExists = usePlateControllerExists();\n  const fallbackStore = React3.useMemo(() => createStore(), []);\n  if (!store) {\n    if (plateControllerExists) {\n      return fallbackStore;\n    }\n    throw new Error(\n      `${debugHookName} must be used inside a Plate or PlateController`\n    );\n  }\n  return store;\n};\nvar usePlateSelectors = (id, options) => {\n  const store = usePlateEditorStore(id, __spreadValues({\n    debugHookName: \"usePlateSelectors\"\n  }, options));\n  return usePlateStore({ store }).get;\n};\nvar usePlateActions = (id, options) => {\n  const store = usePlateEditorStore(id, __spreadValues({\n    debugHookName: \"usePlateActions\"\n  }, options));\n  return usePlateStore({ store }).set;\n};\nvar usePlateStates = (id, options) => {\n  const store = usePlateEditorStore(id, __spreadValues({\n    debugHookName: \"usePlateStates\"\n  }, options));\n  return usePlateStore({ store }).use;\n};\n\n// src/react/stores/plate/actions/useIncrementVersion.ts\nimport React4 from \"react\";\nvar useIncrementVersion = (key, id, options = {}) => {\n  const previousVersionRef = React4.useRef(1);\n  const set = usePlateActions(id, __spreadValues({\n    debugHookName: \"useIncrementVersion\"\n  }, options))[key]();\n  return React4.useCallback(() => {\n    const nextVersion = previousVersionRef.current + 1;\n    set(nextVersion);\n    previousVersionRef.current = nextVersion;\n  }, [set]);\n};\n\n// src/react/stores/plate/actions/useRedecorate.ts\nimport React5 from \"react\";\nvar useRedecorate = (id, options = {}) => {\n  const updateDecorate = useIncrementVersion(\"versionDecorate\", id, __spreadValues({\n    debugHookName: \"useRedecorate\"\n  }, options));\n  return React5.useCallback(() => {\n    updateDecorate();\n  }, [updateDecorate]);\n};\n\n// src/react/stores/plate/selectors/useEditorContainerRef.ts\nvar useEditorContainerRef = (id) => {\n  return usePlateSelectors(id, {\n    debugHookName: \"useEditorContainerRef\"\n  }).containerRef();\n};\nvar useEditorScrollRef = (id) => {\n  return usePlateSelectors(id, {\n    debugHookName: \"useEditorScrollRef\"\n  }).scrollRef();\n};\nvar useScrollRef = (id) => {\n  const scrollRef = useEditorScrollRef(id);\n  const containerRef = useEditorContainerRef(id);\n  return scrollRef.current ? scrollRef : containerRef;\n};\n\n// src/react/stores/plate/selectors/useEditorId.ts\nvar useEditorId = () => usePlateSelectors(void 0, { debugHookName: \"useEditorId\" }).editor().id;\n\n// src/react/stores/plate/selectors/useEditorMounted.ts\nvar useEditorMounted = (id, options = {}) => {\n  return !!usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useEditorMounted\"\n  }, options)).isMounted();\n};\n\n// src/react/editor/withPlate.ts\nimport { createTEditor as createTEditor2 } from \"@udecode/slate\";\n\n// src/react/plugins/PlateApiPlugin.ts\nvar PlateApiPlugin = createTPlatePlugin({\n  key: \"plateApi\",\n  dependencies: [\"debug\"]\n}).extendEditorApi(({ editor }) => ({\n  redecorate: () => {\n    editor.api.debug.warn(\n      `The method editor.api.redecorate() has not been overridden. This may cause unexpected behavior. Please ensure that all required editor methods are properly defined.`,\n      \"OVERRIDE_MISSING\"\n    );\n  }\n}));\n\n// src/react/plugins/SlateReactNextPlugin.ts\nvar SlateReactNextPlugin = toPlatePlugin(SlateNextPlugin, {\n  handlers: {\n    onKeyDown: ({ editor, event }) => {\n      event.persist();\n      editor.currentKeyboardEvent = event;\n    }\n  }\n});\n\n// src/react/plugins/event-editor/EventEditorStore.ts\nvar EventEditorStore = createZustandStore2(\"event-editor\")({\n  blur: null,\n  focus: null,\n  last: null\n});\nvar eventEditorActions = EventEditorStore.set;\nvar eventEditorSelectors = EventEditorStore.get;\nvar useEventEditorSelectors = EventEditorStore.use;\n\n// src/react/plugins/event-editor/useFocusEditorEvents.ts\nimport { useEffect } from \"react\";\nvar FOCUS_EDITOR_EVENT = \"focus-editor-event\";\nvar BLUR_EDITOR_EVENT = \"blur-editor-event\";\nvar useFocusEditorEvents = ({\n  editorRef,\n  onEditorBlur,\n  onEditorFocus\n}) => {\n  useEffect(() => {\n    const onFocusEditor = (event) => {\n      const id = event.detail.id;\n      if (!!onEditorFocus && editorRef && editorRef.id === id) {\n        onEditorFocus();\n      }\n    };\n    const onBlurEditor = (event) => {\n      const id = event.detail.id;\n      if (!!onEditorBlur && editorRef && editorRef.id === id) {\n        onEditorBlur();\n      }\n    };\n    document.addEventListener(FOCUS_EDITOR_EVENT, onFocusEditor);\n    document.addEventListener(BLUR_EDITOR_EVENT, onBlurEditor);\n    return () => {\n      document.removeEventListener(FOCUS_EDITOR_EVENT, onFocusEditor);\n      document.removeEventListener(BLUR_EDITOR_EVENT, onBlurEditor);\n    };\n  }, [editorRef, onEditorBlur, onEditorFocus]);\n};\n\n// src/react/plugins/event-editor/EventEditorPlugin.ts\nvar EventEditorPlugin = createPlatePlugin({\n  key: \"eventEditor\",\n  handlers: {\n    onBlur: ({ editor }) => {\n      const focus = eventEditorSelectors.focus();\n      if (focus === editor.id) {\n        eventEditorActions.focus(null);\n      }\n      eventEditorActions.blur(editor.id);\n      document.dispatchEvent(\n        new CustomEvent(BLUR_EDITOR_EVENT, {\n          detail: { id: editor.id }\n        })\n      );\n    },\n    onFocus: ({ editor }) => {\n      eventEditorActions.focus(editor.id);\n      document.dispatchEvent(\n        new CustomEvent(FOCUS_EDITOR_EVENT, {\n          detail: { id: editor.id }\n        })\n      );\n    }\n  }\n});\n\n// src/react/plugins/event-editor/getEventPlateId.ts\nvar getEventPlateId = (id) => {\n  var _a;\n  if (id) return id;\n  const focus = eventEditorSelectors.focus();\n  if (focus) return focus;\n  const blur = eventEditorSelectors.blur();\n  if (blur) return blur;\n  return (_a = eventEditorSelectors.last()) != null ? _a : \"plate\";\n};\n\n// src/react/plugins/paragraph/ParagraphPlugin.tsx\nimport { Key } from \"@udecode/react-hotkeys\";\nvar ParagraphPlugin = toPlatePlugin(\n  BaseParagraphPlugin,\n  ({ editor, type }) => ({\n    shortcuts: {\n      toggleParagraph: {\n        keys: [\n          [Key.Mod, Key.Alt, \"0\"],\n          [Key.Mod, Key.Shift, \"0\"]\n        ],\n        preventDefault: true,\n        handler: () => {\n          editor.tf.toggle.block({ type });\n        }\n      }\n    }\n  })\n);\n\n// src/react/plugins/react/ReactPlugin.ts\nimport { focusEditorEdge, isEditorFocused } from \"@udecode/slate-react\";\n\n// src/react/plugins/react/withPlateReact.ts\nimport { withReact } from \"slate-react\";\nvar withPlateReact = ({ editor }) => {\n  return withReact(editor);\n};\n\n// src/react/plugins/react/ReactPlugin.ts\nvar ReactPlugin = createSlatePlugin({\n  key: \"dom\",\n  extendEditor: withPlateReact\n}).extendEditorTransforms(({ editor }) => {\n  const { reset } = editor.tf;\n  return {\n    reset: () => {\n      const isFocused = isEditorFocused(editor);\n      reset();\n      if (isFocused) {\n        focusEditorEdge(editor, { edge: \"start\" });\n      }\n    }\n  };\n});\n\n// src/react/editor/getPlateCorePlugins.ts\nvar getPlateCorePlugins = () => [\n  SlateReactNextPlugin,\n  ReactPlugin,\n  EventEditorPlugin,\n  PlateApiPlugin,\n  ParagraphPlugin\n];\n\n// src/react/editor/withPlate.ts\nvar withPlate = (e, _a = {}) => {\n  var _b = _a, { plugins = [] } = _b, options = __objRest(_b, [\"plugins\"]);\n  const editor = withSlate(e, __spreadProps(__spreadValues({}, options), {\n    plugins: [...getPlateCorePlugins(), ...plugins]\n  }));\n  editor.useOptions = (plugin, selector, equalityFn) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) {\n      return {};\n    }\n    return store.useStore(selector, equalityFn);\n  };\n  editor.useOption = (plugin, key, ...args) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) {\n      return;\n    }\n    const useState = store == null ? void 0 : store.use[key];\n    if (useState) {\n      return useState(...args);\n    }\n    editor.api.debug.error(\n      `editor.useOption: ${key} option is not defined in plugin ${plugin.key}`,\n      \"OPTION_UNDEFINED\"\n    );\n  };\n  return editor;\n};\nvar createPlateEditor = (_a = {}) => {\n  var _b = _a, {\n    editor = createTEditor2()\n  } = _b, options = __objRest(_b, [\n    \"editor\"\n  ]);\n  return withPlate(editor, options);\n};\n\n// src/react/utils/createPlateFallbackEditor.ts\nvar createPlateFallbackEditor = (options = {}) => {\n  const editor = createPlateEditor(options);\n  editor.isFallback = true;\n  editor.apply = () => {\n    throw new Error(\n      \"Cannot apply operations on the fallback editor. The fallback editor is used when a hook that depends on the Plate store was unable to locate a valid store. If you are using PlateController, use `useEditorMounted(id?: string)` or `!editor.isFallback` to ensure that a valid Plate store is available before attempting to call operations on the editor.\"\n    );\n  };\n  return editor;\n};\n\n// src/react/utils/dom-attributes.ts\nvar DOM_HANDLERS = [\n  // Clipboard Events\n  \"onCopy\",\n  \"onCopyCapture\",\n  \"onCut\",\n  \"onCutCapture\",\n  \"onPaste\",\n  \"onPasteCapture\",\n  // Composition Events\n  \"onCompositionEnd\",\n  \"onCompositionEndCapture\",\n  \"onCompositionStart\",\n  \"onCompositionStartCapture\",\n  \"onCompositionUpdate\",\n  \"onCompositionUpdateCapture\",\n  // Focus Events\n  \"onFocus\",\n  \"onFocusCapture\",\n  \"onBlur\",\n  \"onBlurCapture\",\n  // Form Events\n  \"onDOMBeforeInput\",\n  \"onBeforeInput\",\n  \"onBeforeInputCapture\",\n  \"onInput\",\n  \"onInputCapture\",\n  \"onReset\",\n  \"onResetCapture\",\n  \"onSubmit\",\n  \"onSubmitCapture\",\n  \"onInvalid\",\n  \"onInvalidCapture\",\n  // Image Events\n  \"onLoad\",\n  \"onLoadCapture\",\n  // Keyboard Events\n  \"onKeyDown\",\n  \"onKeyDownCapture\",\n  \"onKeyPress\",\n  \"onKeyPressCapture\",\n  \"onKeyUp\",\n  \"onKeyUpCapture\",\n  // Media Events\n  \"onAbort\",\n  \"onAbortCapture\",\n  \"onCanPlay\",\n  \"onCanPlayCapture\",\n  \"onCanPlayThrough\",\n  \"onCanPlayThroughCapture\",\n  \"onDurationChange\",\n  \"onDurationChangeCapture\",\n  \"onEmptied\",\n  \"onEmptiedCapture\",\n  \"onEncrypted\",\n  \"onEncryptedCapture\",\n  \"onEnded\",\n  \"onEndedCapture\",\n  \"onLoadedData\",\n  \"onLoadedDataCapture\",\n  \"onLoadedMetadata\",\n  \"onLoadedMetadataCapture\",\n  \"onLoadStart\",\n  \"onLoadStartCapture\",\n  \"onPause\",\n  \"onPauseCapture\",\n  \"onPlay\",\n  \"onPlayCapture\",\n  \"onPlaying\",\n  \"onPlayingCapture\",\n  \"onProgress\",\n  \"onProgressCapture\",\n  \"onRateChange\",\n  \"onRateChangeCapture\",\n  \"onSeeked\",\n  \"onSeekedCapture\",\n  \"onSeeking\",\n  \"onSeekingCapture\",\n  \"onStalled\",\n  \"onStalledCapture\",\n  \"onSuspend\",\n  \"onSuspendCapture\",\n  \"onTimeUpdate\",\n  \"onTimeUpdateCapture\",\n  \"onVolumeChange\",\n  \"onVolumeChangeCapture\",\n  \"onWaiting\",\n  \"onWaitingCapture\",\n  // MouseEvents\n  \"onAuxClick\",\n  \"onAuxClickCapture\",\n  \"onClick\",\n  \"onClickCapture\",\n  \"onContextMenu\",\n  \"onContextMenuCapture\",\n  \"onDoubleClick\",\n  \"onDoubleClickCapture\",\n  \"onDrag\",\n  \"onDragCapture\",\n  \"onDragEnd\",\n  \"onDragEndCapture\",\n  \"onDragEnter\",\n  \"onDragEnterCapture\",\n  \"onDragExit\",\n  \"onDragExitCapture\",\n  \"onDragLeave\",\n  \"onDragLeaveCapture\",\n  \"onDragOver\",\n  \"onDragOverCapture\",\n  \"onDragStart\",\n  \"onDragStartCapture\",\n  \"onDrop\",\n  \"onDropCapture\",\n  \"onMouseDown\",\n  \"onMouseDownCapture\",\n  \"onMouseEnter\",\n  \"onMouseLeave\",\n  \"onMouseMove\",\n  \"onMouseMoveCapture\",\n  \"onMouseOut\",\n  \"onMouseOutCapture\",\n  \"onMouseOver\",\n  \"onMouseOverCapture\",\n  \"onMouseUp\",\n  \"onMouseUpCapture\",\n  // Selection Events\n  \"onSelect\",\n  \"onSelectCapture\",\n  // Touch Events\n  \"onTouchCancel\",\n  \"onTouchCancelCapture\",\n  \"onTouchEnd\",\n  \"onTouchEndCapture\",\n  \"onTouchMove\",\n  \"onTouchMoveCapture\",\n  \"onTouchStart\",\n  \"onTouchStartCapture\",\n  // Pointer Events\n  \"onPointerDown\",\n  \"onPointerDownCapture\",\n  \"onPointerMove\",\n  \"onPointerUp\",\n  \"onPointerUpCapture\",\n  \"onPointerCancel\",\n  \"onPointerCancelCapture\",\n  \"onPointerEnter\",\n  \"onPointerLeave\",\n  \"onPointerOver\",\n  \"onPointerOverCapture\",\n  \"onPointerOut\",\n  \"onPointerOutCapture\",\n  \"onGotPointerCapture\",\n  \"onGotPointerCaptureCapture\",\n  \"onLostPointerCapture\",\n  \"onLostPointerCaptureCapture\",\n  // UI Events\n  \"onScroll\",\n  \"onScrollCapture\",\n  // Wheel Events\n  \"onWheel\",\n  \"onWheelCapture\",\n  // Animation Events\n  \"onAnimationStart\",\n  \"onAnimationStartCapture\",\n  \"onAnimationEnd\",\n  \"onAnimationEndCapture\",\n  \"onAnimationIteration\",\n  \"onAnimationIterationCapture\",\n  // Transition Events\n  \"onTransitionEnd\",\n  \"onTransitionEndCapture\"\n];\n\n// src/react/utils/getRenderNodeProps.ts\nimport { clsx as clsx3 } from \"clsx\";\nimport pick from \"lodash/pick.js\";\n\n// src/react/utils/pipeInjectNodeProps.tsx\nimport clsx2 from \"clsx\";\n\n// src/react/utils/pluginInjectNodeProps.ts\nimport { findNodePath } from \"@udecode/slate-react\";\nimport { isDefined as isDefined3 } from \"@udecode/utils\";\nvar pluginInjectNodeProps = (editor, plugin, nodeProps) => {\n  var _a, _b, _c, _d;\n  const {\n    key,\n    inject: { nodeProps: injectNodeProps }\n  } = plugin;\n  const { element, text } = nodeProps;\n  const node = element != null ? element : text;\n  if (!node) return;\n  if (!injectNodeProps) return;\n  const {\n    classNames,\n    defaultNodeValue,\n    nodeKey = key,\n    query,\n    styleKey = nodeKey,\n    transformClassName,\n    transformNodeValue,\n    transformProps,\n    transformStyle,\n    validNodeValues\n  } = injectNodeProps;\n  const injectMatch = getInjectMatch(editor, plugin);\n  if (!injectMatch(node, findNodePath(editor, node))) return;\n  const queryResult = query == null ? void 0 : query(__spreadProps(__spreadValues(__spreadValues({}, injectNodeProps), getEditorPlugin(editor, plugin)), {\n    nodeProps\n  }));\n  if (query && !queryResult) {\n    return;\n  }\n  const nodeValue = node[nodeKey];\n  if (!transformProps && (!isDefined3(nodeValue) || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue)) {\n    return;\n  }\n  const transformOptions = __spreadProps(__spreadValues(__spreadValues({}, nodeProps), getEditorPlugin(editor, plugin)), {\n    nodeValue\n  });\n  const value = (_a = transformNodeValue == null ? void 0 : transformNodeValue(transformOptions)) != null ? _a : nodeValue;\n  transformOptions.value = value;\n  let newProps = {};\n  if (element && nodeKey) {\n    newProps.className = `slate-${nodeKey}-${nodeValue}`;\n  }\n  if ((classNames == null ? void 0 : classNames[nodeValue]) || transformClassName) {\n    newProps.className = (_b = transformClassName == null ? void 0 : transformClassName(transformOptions)) != null ? _b : classNames == null ? void 0 : classNames[value];\n  }\n  if (styleKey) {\n    newProps.style = (_c = transformStyle == null ? void 0 : transformStyle(transformOptions)) != null ? _c : {\n      [styleKey]: value\n    };\n  }\n  if (transformProps) {\n    newProps = (_d = transformProps(__spreadProps(__spreadValues({}, transformOptions), { props: newProps }))) != null ? _d : newProps;\n  }\n  return newProps;\n};\n\n// src/react/utils/pipeInjectNodeProps.tsx\nvar pipeInjectNodeProps = (editor, nodeProps) => {\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.inject.nodeProps) {\n      const newProps = pluginInjectNodeProps(editor, plugin, nodeProps);\n      if (!newProps) return;\n      nodeProps = __spreadProps(__spreadValues(__spreadValues({}, nodeProps), newProps), {\n        className: clsx2(nodeProps.className, newProps.className),\n        style: __spreadValues(__spreadValues({}, nodeProps.style), newProps.style)\n      });\n    }\n  });\n  return nodeProps;\n};\n\n// src/react/utils/getRenderNodeProps.ts\nvar getRenderNodeProps = ({\n  attributes,\n  editor,\n  plugin,\n  props\n}) => {\n  var _a, _b;\n  let newProps = {};\n  if (plugin == null ? void 0 : plugin.node.props) {\n    newProps = (_a = typeof plugin.node.props === \"function\" ? plugin.node.props(props) : plugin.node.props) != null ? _a : {};\n  }\n  if (!newProps.nodeProps && attributes && plugin) {\n    newProps.nodeProps = pick(\n      attributes,\n      (_b = plugin.node.dangerouslyAllowAttributes) != null ? _b : []\n    );\n  }\n  props = __spreadValues(__spreadValues({}, props), newProps);\n  if (props.nodeProps) {\n    Object.keys(props.nodeProps).forEach((key) => {\n      var _a2, _b2;\n      if (((_a2 = props.nodeProps) == null ? void 0 : _a2[key]) === void 0) {\n        (_b2 = props.nodeProps) == null ? true : delete _b2[key];\n      }\n    });\n  }\n  const { className } = props;\n  let nodeProps = __spreadProps(__spreadValues(__spreadValues({}, props), plugin ? getEditorPlugin2(editor, plugin) : {}), {\n    className: clsx3(getSlateClass(plugin == null ? void 0 : plugin.node.type), className)\n  });\n  nodeProps = pipeInjectNodeProps(editor, nodeProps);\n  if (nodeProps.style && Object.keys(nodeProps.style).length === 0) {\n    delete nodeProps.style;\n  }\n  return nodeProps;\n};\n\n// src/react/utils/hotkeys.ts\nimport { isComposing } from \"@udecode/slate-react\";\nvar createComposing = (key) => (editor, event, {\n  composing\n} = {}) => {\n  if (!createHotkey(key)(event)) return false;\n  if (!!composing !== isComposing(editor)) return false;\n  return true;\n};\nvar Hotkeys2 = __spreadProps(__spreadValues({}, Hotkeys), {\n  isTab: createComposing(\"tab\"),\n  isUntab: createComposing(\"untab\")\n});\n\n// src/react/utils/pipeDecorate.ts\nvar pipeDecorate = (editor, decorateProp) => {\n  const relevantPlugins = editor.pluginList.filter((plugin) => plugin.decorate);\n  if (relevantPlugins.length === 0 && !decorateProp) return;\n  return (entry) => {\n    let ranges = [];\n    const addRanges = (newRanges) => {\n      if (newRanges == null ? void 0 : newRanges.length) ranges = [...ranges, ...newRanges];\n    };\n    relevantPlugins.forEach((plugin) => {\n      addRanges(\n        plugin.decorate(__spreadProps(__spreadValues({}, getEditorPlugin2(editor, plugin)), {\n          entry\n        }))\n      );\n    });\n    if (decorateProp) {\n      addRanges(\n        decorateProp({\n          editor,\n          entry\n        })\n      );\n    }\n    return ranges;\n  };\n};\n\n// src/react/utils/pipeHandler.ts\nvar convertDomEventToSyntheticEvent = (domEvent) => {\n  let propagationStopped = false;\n  return __spreadProps(__spreadValues({}, domEvent), {\n    bubbles: domEvent.bubbles,\n    cancelable: domEvent.cancelable,\n    currentTarget: domEvent.currentTarget,\n    defaultPrevented: domEvent.defaultPrevented,\n    eventPhase: domEvent.eventPhase,\n    isDefaultPrevented: () => domEvent.defaultPrevented,\n    isPropagationStopped: () => propagationStopped,\n    isTrusted: domEvent.isTrusted,\n    nativeEvent: domEvent,\n    persist: () => {\n      throw new Error(\n        \"persist is not implemented for synthetic events created using convertDomEventToSyntheticEvent\"\n      );\n    },\n    preventDefault: () => domEvent.preventDefault(),\n    stopPropagation: () => {\n      propagationStopped = true;\n      domEvent.stopPropagation();\n    },\n    target: domEvent.target,\n    timeStamp: domEvent.timeStamp,\n    type: domEvent.type\n  });\n};\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  }\n  const shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isPropagationStopped();\n};\nvar pipeHandler = (editor, {\n  editableProps,\n  handlerKey\n}) => {\n  const propsHandler = editableProps == null ? void 0 : editableProps[handlerKey];\n  const relevantPlugins = editor.pluginList.filter(\n    (plugin) => {\n      var _a;\n      return (_a = plugin.handlers) == null ? void 0 : _a[handlerKey];\n    }\n  );\n  if (relevantPlugins.length === 0 && !propsHandler) return;\n  return (event) => {\n    const isDomEvent = event instanceof Event;\n    const handledEvent = isDomEvent ? convertDomEventToSyntheticEvent(event) : event;\n    const eventIsHandled = relevantPlugins.some((plugin) => {\n      const pluginHandler = plugin.handlers[handlerKey];\n      const shouldTreatEventAsHandled = pluginHandler(__spreadProps(__spreadValues({}, getEditorPlugin2(editor, plugin)), {\n        event: handledEvent\n      }));\n      if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n      }\n      return false;\n    });\n    if (eventIsHandled) return true;\n    return isEventHandled(handledEvent, propsHandler);\n  };\n};\n\n// src/react/utils/pipeOnChange.ts\nvar pipeOnChange = (editor, value) => {\n  return editor.pluginList.some((plugin) => {\n    const handler = plugin.handlers.onChange;\n    if (!handler) {\n      return false;\n    }\n    const shouldTreatEventAsHandled = handler(__spreadProps(__spreadValues({}, getEditorPlugin2(editor, plugin)), {\n      value\n    }));\n    if (shouldTreatEventAsHandled != null) {\n      return shouldTreatEventAsHandled;\n    }\n    return false;\n  });\n};\n\n// src/react/utils/pipeRenderElement.tsx\nimport React7 from \"react\";\nimport { DefaultElement as DefaultElement2 } from \"slate-react\";\n\n// src/react/utils/pluginRenderElement.tsx\nimport React6 from \"react\";\nimport { DefaultElement } from \"slate-react\";\n\n// src/react/stores/element/useElementStore.ts\nvar SCOPE_ELEMENT = \"element\";\nvar initialState = {\n  element: null\n};\nvar { ElementProvider, useElementStore } = createAtomStore(\n  initialState,\n  { name: \"element\" }\n);\n\n// src/react/utils/pluginRenderElement.tsx\nfunction ElementContent({\n  editor,\n  nodeProps,\n  plugin\n}) {\n  var _a, _b;\n  const element = useElement();\n  const { children: _children } = nodeProps;\n  const key = plugin.key;\n  const Element = (_b = (_a = plugin.render) == null ? void 0 : _a.node) != null ? _b : DefaultElement;\n  const aboveNodes = editor.pluginList.flatMap(\n    (o) => {\n      var _a2, _b2;\n      return (_b2 = (_a2 = o.render) == null ? void 0 : _a2.aboveNodes) != null ? _b2 : [];\n    }\n  );\n  const belowNodes = editor.pluginList.flatMap(\n    (o) => {\n      var _a2, _b2;\n      return (_b2 = (_a2 = o.render) == null ? void 0 : _a2.belowNodes) != null ? _b2 : [];\n    }\n  );\n  nodeProps = getRenderNodeProps({\n    attributes: element.attributes,\n    editor,\n    plugin,\n    props: nodeProps\n  });\n  let children = _children;\n  belowNodes.forEach((withHOC2) => {\n    const hoc = withHOC2(__spreadProps(__spreadValues({}, nodeProps), { key }));\n    if (hoc) {\n      children = hoc(__spreadProps(__spreadValues({}, nodeProps), { children }));\n    }\n  });\n  let component = /* @__PURE__ */ React6.createElement(Element, __spreadValues({}, nodeProps), children);\n  aboveNodes.forEach((withHOC2) => {\n    const hoc = withHOC2(__spreadProps(__spreadValues({}, nodeProps), { key }));\n    if (hoc) {\n      component = hoc(__spreadProps(__spreadValues({}, nodeProps), { children: component }));\n    }\n  });\n  return component;\n}\nvar pluginRenderElement = (editor, plugin) => function render(nodeProps) {\n  const { element } = nodeProps;\n  if (element.type === plugin.node.type) {\n    return /* @__PURE__ */ React6.createElement(ElementProvider, { element, scope: plugin.key }, /* @__PURE__ */ React6.createElement(\n      ElementContent,\n      {\n        editor,\n        nodeProps,\n        plugin\n      }\n    ));\n  }\n};\n\n// src/react/utils/pipeRenderElement.tsx\nvar pipeRenderElement = (editor, renderElementProp) => {\n  const renderElements = [];\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isElement) {\n      renderElements.push(pluginRenderElement(editor, plugin));\n    }\n  });\n  return function render(props) {\n    let element;\n    renderElements.some((renderElement) => {\n      element = renderElement(props);\n      return !!element;\n    });\n    if (element) return element;\n    if (renderElementProp) {\n      return renderElementProp(props);\n    }\n    return /* @__PURE__ */ React7.createElement(DefaultElement2, { attributes: props.attributes, element: props.element }, props.children);\n  };\n};\n\n// src/react/utils/pipeRenderLeaf.tsx\nimport React9 from \"react\";\n\n// src/react/utils/pluginRenderLeaf.tsx\nimport React8 from \"react\";\nvar pluginRenderLeaf = (editor, plugin) => function render(nodeProps) {\n  var _a;\n  const {\n    render: { node }\n  } = plugin;\n  const { children, leaf } = nodeProps;\n  if (leaf[(_a = plugin.node.type) != null ? _a : plugin.key]) {\n    const Leaf = node != null ? node : DefaultLeaf;\n    const ctxProps = getRenderNodeProps({\n      attributes: leaf.attributes,\n      editor,\n      plugin,\n      props: nodeProps\n    });\n    return /* @__PURE__ */ React8.createElement(Leaf, __spreadValues({}, ctxProps), children);\n  }\n  return children;\n};\n\n// src/react/utils/pipeRenderLeaf.tsx\nvar pipeRenderLeaf = (editor, renderLeafProp) => {\n  const renderLeafs = [];\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isLeaf && plugin.key) {\n      renderLeafs.push(pluginRenderLeaf(editor, plugin));\n    }\n  });\n  return function render(props) {\n    renderLeafs.forEach((renderLeaf) => {\n      const newChildren = renderLeaf(props);\n      if (newChildren !== void 0) {\n        props.children = newChildren;\n      }\n    });\n    if (renderLeafProp) {\n      return renderLeafProp(props);\n    }\n    const ctxProps = getRenderNodeProps({\n      attributes: props.attributes,\n      editor,\n      props\n    });\n    return /* @__PURE__ */ React9.createElement(DefaultLeaf, __spreadValues({}, ctxProps));\n  };\n};\n\n// src/react/stores/plate/selectors/useEditorRef.ts\nvar useEditorRef = (id, options = {}) => {\n  var _a;\n  return (_a = usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useEditorRef\"\n  }, options)).editor()) != null ? _a : createPlateFallbackEditor();\n};\n\n// src/react/stores/plate/selectors/useEditorPlugin.ts\nfunction useEditorPlugin(p, id) {\n  const editor = useEditorRef(id);\n  return getEditorPlugin2(editor, p);\n}\n\n// src/react/stores/plate/selectors/useEditorReadOnly.ts\nvar useEditorReadOnly = (id, options = {}) => {\n  return !!usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useEditorReadOnly\"\n  }, options)).readOnly();\n};\n\n// src/react/stores/plate/selectors/useEditorSelection.ts\nvar useEditorSelection = (id, options = {}) => usePlateSelectors(id, __spreadValues({\n  debugHookName: \"useEditorSelection\"\n}, options)).trackedSelection().selection;\n\n// src/react/stores/plate/selectors/useEditorSelector.ts\nimport React10 from \"react\";\nimport { selectAtom } from \"jotai/utils\";\nvar useEditorSelector = (selector, deps, _a = {}) => {\n  var _b = _a, {\n    id,\n    equalityFn = (a, b) => a === b\n  } = _b, storeOptions = __objRest(_b, [\n    \"id\",\n    \"equalityFn\"\n  ]);\n  const selectorAtom = React10.useMemo(\n    () => selectAtom(\n      plateStore.atom.trackedEditor,\n      ({ editor }, prev) => selector(editor, prev),\n      equalityFn\n    ),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps\n  );\n  return usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useEditorSelector\"\n  }, storeOptions)).atom(selectorAtom);\n};\n\n// src/react/stores/plate/selectors/useEditorState.ts\nvar useEditorState = (id, options = {}) => {\n  return usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useEditorState\"\n  }, options)).trackedEditor().editor;\n};\n\n// src/react/stores/plate/selectors/useEditorValue.ts\nvar useEditorValue = (id, options = {}) => usePlateSelectors(id, __spreadValues({\n  debugHookName: \"useEditorValue\"\n}, options)).trackedValue().value;\n\n// src/react/stores/plate/selectors/useEditorVersion.ts\nvar useEditorVersion = (id, options = {}) => {\n  return usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useEditorVersion\"\n  }, options)).versionEditor();\n};\n\n// src/react/stores/plate/selectors/useSelectionVersion.ts\nvar useSelectionVersion = (id, options = {}) => {\n  return usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useSelectionVersion\"\n  }, options)).versionSelection();\n};\n\n// src/react/stores/plate/selectors/useValueVersion.ts\nvar useValueVersion = (id, options = {}) => {\n  return usePlateSelectors(id, __spreadValues({\n    debugHookName: \"useValueVersion\"\n  }, options)).versionValue();\n};\n\n// src/react/stores/element/useElement.ts\nvar useElement = (pluginKey = SCOPE_ELEMENT) => {\n  const editor = useEditorRef();\n  const value = useElementStore(pluginKey).get.element();\n  if (!value) {\n    editor.api.debug.warn(\n      `useElement(${pluginKey}) hook must be used inside the node component's context`,\n      \"USE_ELEMENT_CONTEXT\"\n    );\n    return {};\n  }\n  return value;\n};\n\n// src/react/stores/event-editor/useEventPlateId.ts\nvar useEventPlateId = (id) => {\n  var _a;\n  const focus = useEventEditorSelectors.focus();\n  const blur = useEventEditorSelectors.blur();\n  const last = useEventEditorSelectors.last();\n  const providerId = usePlateSelectors().editor().id;\n  if (id) return id;\n  if (focus) return focus;\n  if (blur) return blur;\n  return (_a = last != null ? last : providerId) != null ? _a : PLATE_SCOPE;\n};\n\n// src/react/components/EditorHotkeysEffect.tsx\nfunction EditorHotkeysEffect({\n  id,\n  editableRef\n}) {\n  const editor = useEditorRef(id);\n  return /* @__PURE__ */ React11.createElement(React11.Fragment, null, Object.entries(editor.shortcuts).map(([hotkeyString, hotkeyConfig]) => {\n    if (!hotkeyConfig || !isDefined4(hotkeyConfig.keys) || !hotkeyConfig.handler) {\n      return null;\n    }\n    return /* @__PURE__ */ React11.createElement(\n      HotkeyEffect,\n      {\n        id,\n        key: hotkeyString,\n        editableRef,\n        hotkeyConfig\n      }\n    );\n  }));\n}\nfunction HotkeyEffect({\n  id,\n  editableRef,\n  hotkeyConfig\n}) {\n  const editor = useEditorRef(id);\n  const _a = hotkeyConfig, { keys, handler } = _a, options = __objRest(_a, [\"keys\", \"handler\"]);\n  const setHotkeyRef = useHotkeys(\n    keys,\n    (event, eventDetails) => {\n      handler({\n        editor,\n        event,\n        eventDetails\n      });\n    },\n    __spreadValues({\n      enableOnContentEditable: true\n    }, options),\n    []\n  );\n  useEffect2(() => {\n    if (editableRef.current) {\n      setHotkeyRef(editableRef.current);\n    }\n  }, [setHotkeyRef, editableRef]);\n  return null;\n}\n\n// src/react/components/EditorMethodsEffect.ts\nimport React12 from \"react\";\nimport { useMemoOnce } from \"@udecode/react-utils\";\nvar EditorMethodsEffect = ({ id }) => {\n  const editor = useEditorRef(id);\n  const redecorate = useRedecorate(id);\n  const plateStore2 = usePlateStore(id);\n  const storeSetters = Object.fromEntries(\n    EXPOSED_STORE_KEYS.map((key) => [key, plateStore2.set[key]()])\n  );\n  const memorizedStoreSetters = useMemoOnce(\n    () => storeSetters,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n  React12.useEffect(() => {\n    editor.api.redecorate = redecorate;\n    editor.setPlateState = (optionKey, value) => {\n      var _a;\n      const setter = memorizedStoreSetters;\n      (_a = setter[optionKey]) == null ? void 0 : _a.call(setter, value);\n    };\n  }, [editor, redecorate, memorizedStoreSetters]);\n  return null;\n};\n\n// src/react/components/EditorRefEffect.tsx\nimport React13 from \"react\";\nfunction EditorRefPluginEffect({\n  id,\n  plugin\n}) {\n  var _a;\n  const editor = useEditorRef(id);\n  (_a = plugin.useHooks) == null ? void 0 : _a.call(plugin, getEditorPlugin2(editor, plugin));\n  return null;\n}\nfunction EditorRefEffect({ id }) {\n  const editor = usePlateSelectors(id).editor();\n  const setIsMounted = usePlateActions(id).isMounted();\n  React13.useEffect(() => {\n    setIsMounted(true);\n    return () => {\n      setIsMounted(false);\n    };\n  }, [setIsMounted]);\n  return /* @__PURE__ */ React13.createElement(React13.Fragment, null, editor.pluginList.map((plugin) => /* @__PURE__ */ React13.createElement(EditorRefPluginEffect, { id, key: plugin.key, plugin })));\n}\n\n// src/react/components/EditorStateEffect.tsx\nimport React14 from \"react\";\nimport { Range } from \"slate\";\nimport { useSlate } from \"slate-react\";\nvar EditorStateEffect = React14.memo(({ id }) => {\n  const editorState = useSlate();\n  const updateVersionEditor = useIncrementVersion(\"versionEditor\", id);\n  React14.useEffect(() => {\n    updateVersionEditor();\n  });\n  const updateVersionSelection = useIncrementVersion(\"versionSelection\", id);\n  const prevSelectionRef = React14.useRef(editorState.selection);\n  const sameSelection = isSelectionEqual(\n    prevSelectionRef.current,\n    editorState.selection\n  );\n  React14.useEffect(() => {\n    if (!sameSelection) {\n      updateVersionSelection();\n    }\n    prevSelectionRef.current = editorState.selection;\n  }, [editorState.selection, sameSelection, updateVersionSelection]);\n  return null;\n});\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n// src/react/components/Plate.tsx\nimport React16, { useId } from \"react\";\n\n// src/internal/usePlateInstancesWarn.ts\nimport React15 from \"react\";\nfunction checkPlateInstances() {\n  globalThis.__PLATE_INSTANCES__ = (globalThis.__PLATE_INSTANCES__ || 0) + 1;\n}\ncheckPlateInstances();\nfunction usePlateInstancesWarn(disabled) {\n  React15.useEffect(() => {\n    if (!disabled && globalThis.__PLATE_INSTANCES__ && globalThis.__PLATE_INSTANCES__ > 1) {\n      console.warn(\n        \"Detected multiple @udecode/plate-core instances!\\nChoose only one of these packages in your dependencies:\\n- @udecode/plate\\n- @udecode/plate-core\\n- @udecode/plate-common\\n\\n\"\n      );\n    }\n  }, [disabled]);\n}\n\n// src/react/components/Plate.tsx\nfunction PlateInner({\n  children,\n  containerRef,\n  decorate,\n  editor,\n  primary,\n  readOnly,\n  renderElement,\n  renderLeaf,\n  scrollRef,\n  onChange,\n  onSelectionChange,\n  onValueChange\n}) {\n  return /* @__PURE__ */ React16.createElement(\n    PlateStoreProvider,\n    {\n      readOnly,\n      onChange,\n      onSelectionChange,\n      onValueChange,\n      containerRef,\n      decorate,\n      editor,\n      primary,\n      renderElement,\n      renderLeaf,\n      scope: editor.id,\n      scrollRef\n    },\n    children\n  );\n}\nfunction Plate(props) {\n  const id = useId();\n  const containerRef = React16.useRef(null);\n  const scrollRef = React16.useRef(null);\n  usePlateInstancesWarn(props.suppressInstanceWarning);\n  if (!props.editor) return null;\n  props.editor.uid = \"e-\" + id.replace(/:/g, \"\");\n  return /* @__PURE__ */ React16.createElement(\n    PlateInner,\n    __spreadValues({\n      key: props.editor.key,\n      containerRef,\n      scrollRef\n    }, props)\n  );\n}\n\n// src/react/components/PlateContent.tsx\nimport React21, { useRef } from \"react\";\nimport { useComposedRef } from \"@udecode/react-utils\";\nimport { focusEditorEdge as focusEditorEdge2 } from \"@udecode/slate-react\";\nimport { Editable } from \"slate-react\";\n\n// src/react/hooks/useEditableProps.ts\nimport React17 from \"react\";\nimport { useMemoOnce as useMemoOnce2 } from \"@udecode/react-utils\";\nimport clsx4 from \"clsx\";\nimport omit from \"lodash/omit.js\";\nimport { useDeepCompareMemo } from \"use-deep-compare\";\nvar useEditableProps = (_a = {}) => {\n  var _b = _a, {\n    disabled,\n    readOnly: readOnlyProp\n  } = _b, editableProps = __objRest(_b, [\n    \"disabled\",\n    \"readOnly\"\n  ]);\n  const { id } = editableProps;\n  const editor = useEditorRef(id);\n  const selectors = usePlateSelectors(id);\n  const versionDecorate = selectors.versionDecorate();\n  const storeReadOnly = selectors.readOnly();\n  const storeDecorate = selectors.decorate();\n  const storeRenderLeaf = selectors.renderLeaf();\n  const storeRenderElement = selectors.renderElement();\n  const decorateMemo = useMemoOnce2(() => {\n    return pipeDecorate(editor, storeDecorate != null ? storeDecorate : editableProps == null ? void 0 : editableProps.decorate);\n  }, [editableProps == null ? void 0 : editableProps.decorate, editor, storeDecorate]);\n  const decorate = useMemoOnce2(() => {\n    if (!versionDecorate || !decorateMemo) return;\n    return (entry) => decorateMemo(entry);\n  }, [decorateMemo, versionDecorate]);\n  const renderElement = React17.useMemo(() => {\n    return pipeRenderElement(\n      editor,\n      storeRenderElement != null ? storeRenderElement : editableProps == null ? void 0 : editableProps.renderElement\n    );\n  }, [editableProps == null ? void 0 : editableProps.renderElement, editor, storeRenderElement]);\n  const renderLeaf = React17.useMemo(() => {\n    return pipeRenderLeaf(editor, storeRenderLeaf != null ? storeRenderLeaf : editableProps == null ? void 0 : editableProps.renderLeaf);\n  }, [editableProps == null ? void 0 : editableProps.renderLeaf, editor, storeRenderLeaf]);\n  const props = useDeepCompareMemo(() => {\n    const _props = {\n      decorate,\n      renderElement,\n      renderLeaf\n    };\n    DOM_HANDLERS.forEach((handlerKey) => {\n      const handler = pipeHandler(editor, {\n        editableProps,\n        handlerKey\n      });\n      if (handler) {\n        _props[handlerKey] = handler;\n      }\n    });\n    return _props;\n  }, [decorate, editableProps, renderElement, renderLeaf]);\n  const readOnly = storeReadOnly || readOnlyProp || disabled;\n  return useDeepCompareMemo(\n    () => __spreadProps(__spreadValues(__spreadValues({}, omit(editableProps, [\n      ...DOM_HANDLERS,\n      \"renderElement\",\n      \"renderLeaf\",\n      \"decorate\"\n    ])), props), {\n      \"aria-disabled\": disabled,\n      className: clsx4(\n        \"slate-editor\",\n        \"ignore-click-outside/toolbar\",\n        editableProps.className\n      ),\n      \"data-readonly\": readOnly,\n      readOnly\n    }),\n    [editableProps, props, readOnly]\n  );\n};\n\n// src/react/hooks/useSlateProps.ts\nimport React18 from \"react\";\nvar useSlateProps = ({\n  id\n}) => {\n  const editor = useEditorRef(id);\n  const onChangeProp = usePlateSelectors(id).onChange();\n  const onValueChangeProp = usePlateSelectors(id).onValueChange();\n  const onSelectionChangeProp = usePlateSelectors(id).onSelectionChange();\n  const onChange = React18.useCallback(\n    (newValue) => {\n      const eventIsHandled = pipeOnChange(editor, newValue);\n      if (!eventIsHandled) {\n        onChangeProp == null ? void 0 : onChangeProp({ editor, value: newValue });\n      }\n    },\n    [editor, onChangeProp]\n  );\n  const onValueChange = React18.useMemo(\n    () => (value) => {\n      onValueChangeProp == null ? void 0 : onValueChangeProp({ editor, value });\n    },\n    [editor, onValueChangeProp]\n  );\n  const onSelectionChange = React18.useMemo(\n    () => (selection) => {\n      onSelectionChangeProp == null ? void 0 : onSelectionChangeProp({ editor, selection });\n    },\n    [editor, onSelectionChangeProp]\n  );\n  return React18.useMemo(() => {\n    return {\n      key: editor.key,\n      editor,\n      initialValue: editor.children,\n      value: editor.children,\n      onChange,\n      onSelectionChange,\n      onValueChange\n    };\n  }, [editor, onChange, onSelectionChange, onValueChange]);\n};\n\n// src/react/components/PlateControllerEffect.ts\nimport React19 from \"react\";\nimport { focusAtom } from \"jotai-optics\";\nimport { useFocused } from \"slate-react\";\nvar PlateControllerEffect = ({\n  id: idProp\n}) => {\n  const idFromStore = useEditorId();\n  const id = idProp != null ? idProp : idFromStore;\n  const currentStoreAtom = React19.useMemo(\n    () => focusAtom(\n      plateControllerStore.atom.editorStores,\n      (optic) => optic.prop(id)\n    ),\n    [id]\n  );\n  const setCurrentStore = usePlateControllerActions().atom(currentStoreAtom, {\n    warnIfNoStore: false\n  });\n  const store = usePlateStore(id).store();\n  const primary = usePlateSelectors(id).primary();\n  const setPrimaryEditorIds = usePlateControllerActions().primaryEditorIds({\n    warnIfNoStore: false\n  });\n  const focused = useFocused();\n  const setActiveId = usePlateControllerActions().activeId({\n    warnIfNoStore: false\n  });\n  React19.useEffect(() => {\n    setCurrentStore(store != null ? store : null);\n    return () => {\n      setCurrentStore(null);\n      setActiveId((activeId) => activeId === id ? null : activeId);\n    };\n  }, [store, setCurrentStore, setActiveId, id]);\n  React19.useEffect(() => {\n    if (primary) {\n      setPrimaryEditorIds((ids) => [...ids, id]);\n      return () => {\n        setPrimaryEditorIds((ids) => ids.filter((i) => i !== id));\n      };\n    }\n  }, [id, primary, setPrimaryEditorIds]);\n  React19.useEffect(() => {\n    if (id && focused) {\n      setActiveId(id);\n    }\n  }, [id, focused, setActiveId]);\n  return null;\n};\n\n// src/react/components/PlateSlate.tsx\nimport React20 from \"react\";\nimport { Slate } from \"slate-react\";\nfunction PlateSlate({\n  id,\n  children\n}) {\n  var _a;\n  const slateProps = useSlateProps({ id });\n  const editor = useEditorRef(id);\n  let aboveSlate = /* @__PURE__ */ React20.createElement(Slate, __spreadValues({}, slateProps), children);\n  (_a = editor.pluginList) == null ? void 0 : _a.forEach((plugin) => {\n    const {\n      render: { aboveSlate: AboveSlate }\n    } = plugin;\n    if (AboveSlate) aboveSlate = /* @__PURE__ */ React20.createElement(AboveSlate, null, aboveSlate);\n  });\n  return aboveSlate;\n}\n\n// src/react/components/PlateContent.tsx\nvar PlateContent = React21.forwardRef(\n  (_a, ref) => {\n    var _b = _a, { autoFocusOnEditable, renderEditable } = _b, props = __objRest(_b, [\"autoFocusOnEditable\", \"renderEditable\"]);\n    var _a2;\n    const { id } = props;\n    const editor = useEditorRef(id);\n    if (!editor) {\n      throw new Error(\n        \"Editor not found. Please ensure that PlateContent is rendered below Plate.\"\n      );\n    }\n    const editableProps = useEditableProps(props);\n    const editableRef = useRef(null);\n    const combinedRef = useComposedRef(ref, editableRef);\n    const editable = /* @__PURE__ */ React21.createElement(Editable, __spreadValues({ ref: combinedRef }, editableProps));\n    let afterEditable = null;\n    let beforeEditable = null;\n    editor.pluginList.forEach((plugin) => {\n      const {\n        render: {\n          afterEditable: AfterEditable,\n          beforeEditable: BeforeEditable\n        }\n      } = plugin;\n      if (AfterEditable) {\n        afterEditable = /* @__PURE__ */ React21.createElement(React21.Fragment, null, afterEditable, /* @__PURE__ */ React21.createElement(AfterEditable, __spreadValues({}, editableProps)));\n      }\n      if (BeforeEditable) {\n        beforeEditable = /* @__PURE__ */ React21.createElement(React21.Fragment, null, beforeEditable, /* @__PURE__ */ React21.createElement(BeforeEditable, __spreadValues({}, editableProps)));\n      }\n    });\n    let aboveEditable = /* @__PURE__ */ React21.createElement(React21.Fragment, null, beforeEditable, renderEditable ? renderEditable(editable) : editable, /* @__PURE__ */ React21.createElement(EditorMethodsEffect, { id }), /* @__PURE__ */ React21.createElement(EditorHotkeysEffect, { id, editableRef }), /* @__PURE__ */ React21.createElement(EditorStateEffect, { id }), /* @__PURE__ */ React21.createElement(EditorRefEffect, { id }), /* @__PURE__ */ React21.createElement(PlateControllerEffect, { id }), afterEditable);\n    editor.pluginList.forEach((plugin) => {\n      const {\n        render: { aboveEditable: AboveEditable }\n      } = plugin;\n      if (AboveEditable)\n        aboveEditable = /* @__PURE__ */ React21.createElement(AboveEditable, null, aboveEditable);\n    });\n    const readOnly = (_a2 = props.readOnly) != null ? _a2 : false;\n    const prevReadOnly = React21.useRef(readOnly);\n    React21.useEffect(() => {\n      if (autoFocusOnEditable && prevReadOnly.current && !readOnly) {\n        focusEditorEdge2(editor, { edge: \"end\" });\n      }\n      prevReadOnly.current = readOnly;\n    }, [autoFocusOnEditable, editor, readOnly]);\n    return /* @__PURE__ */ React21.createElement(PlateSlate, { id }, aboveEditable);\n  }\n);\nPlateContent.displayName = \"PlateContent\";\n\n// src/react/components/PlateTest.tsx\nimport React22 from \"react\";\n\n// src/react/editor/usePlateEditor.ts\nimport { useMemoOnce as useMemoOnce3 } from \"@udecode/react-utils\";\nfunction usePlateEditor(options = {}, deps = []) {\n  return useMemoOnce3(\n    () => {\n      if (options.enabled === false) return null;\n      const editor = createPlateEditor(options);\n      return editor;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [options.id, options.enabled, ...deps]\n  );\n}\n\n// src/react/components/PlateTest.tsx\nfunction PlateTest(_a) {\n  var _b = _a, {\n    editableProps,\n    shouldNormalizeEditor,\n    variant = \"wordProcessor\"\n  } = _b, props = __objRest(_b, [\n    \"editableProps\",\n    \"shouldNormalizeEditor\",\n    \"variant\"\n  ]);\n  const { id, editor: _editor, plugins } = props;\n  let editor = _editor;\n  if (editor && !editor.pluginList) {\n    editor = createPlateEditor({\n      id,\n      editor,\n      plugins,\n      shouldNormalizeEditor\n    });\n  }\n  return /* @__PURE__ */ React22.createElement(Plate, __spreadProps(__spreadValues({}, props), { editor }), /* @__PURE__ */ React22.createElement(\n    PlateContent,\n    __spreadValues({\n      \"data-testid\": \"slate-content-editable\",\n      \"data-variant\": variant,\n      autoFocus: true\n    }, editableProps)\n  ));\n}\n\n// src/react/components/withHOC.tsx\nimport React23 from \"react\";\nvar withHOC = (HOC, Component, hocProps, hocRef) => React23.forwardRef((props, componentRef) => /* @__PURE__ */ React23.createElement(HOC, __spreadProps(__spreadValues({}, hocProps), { ref: hocRef }), /* @__PURE__ */ React23.createElement(Component, __spreadProps(__spreadValues({}, props), { ref: componentRef }))));\nexport {\n  BLUR_EDITOR_EVENT,\n  DOM_HANDLERS,\n  DefaultLeaf,\n  EXPOSED_STORE_KEYS,\n  EditorHotkeysEffect,\n  EditorMethodsEffect,\n  EditorRefEffect,\n  EditorRefPluginEffect,\n  EditorStateEffect,\n  ElementProvider,\n  EventEditorPlugin,\n  EventEditorStore,\n  FOCUS_EDITOR_EVENT,\n  GLOBAL_PLATE_SCOPE,\n  Hotkeys2 as Hotkeys,\n  PLATE_SCOPE,\n  ParagraphPlugin,\n  Plate,\n  PlateApiPlugin,\n  PlateContent,\n  PlateController,\n  PlateControllerEffect,\n  PlateSlate,\n  PlateStoreProvider,\n  PlateTest,\n  ReactPlugin,\n  SCOPE_ELEMENT,\n  SlateReactNextPlugin,\n  atom,\n  convertDomEventToSyntheticEvent,\n  createAtomStore,\n  createPlateEditor,\n  createPlateFallbackEditor,\n  createPlatePlugin,\n  createPlateStore,\n  createTPlatePlugin,\n  eventEditorActions,\n  eventEditorSelectors,\n  getEditorPlugin2 as getEditorPlugin,\n  getEventPlateId,\n  getPlateCorePlugins,\n  getPlugin,\n  getRenderNodeProps,\n  isEventHandled,\n  omitPluginContext,\n  pipeDecorate,\n  pipeHandler,\n  pipeInjectNodeProps,\n  pipeOnChange,\n  pipeRenderElement,\n  pipeRenderLeaf,\n  plateControllerStore,\n  plateStore,\n  pluginInjectNodeProps,\n  pluginRenderElement,\n  pluginRenderLeaf,\n  toPlatePlugin,\n  toTPlatePlugin,\n  useEditableProps,\n  useEditorContainerRef,\n  useEditorId,\n  useEditorMounted,\n  useEditorPlugin,\n  useEditorReadOnly,\n  useEditorRef,\n  useEditorScrollRef,\n  useEditorSelection,\n  useEditorSelector,\n  useEditorState,\n  useEditorValue,\n  useEditorVersion,\n  useElement,\n  useElementStore,\n  useEventEditorSelectors,\n  useEventPlateId,\n  useFocusEditorEvents,\n  useIncrementVersion,\n  usePlateActions,\n  usePlateControllerActions,\n  usePlateControllerEditorStore,\n  usePlateControllerExists,\n  usePlateControllerSelectors,\n  usePlateControllerStates,\n  usePlateControllerStore,\n  usePlateEditor,\n  usePlateEditorStore,\n  usePlateSelectors,\n  usePlateStates,\n  usePlateStore,\n  useRedecorate,\n  useScrollRef,\n  useSelectionVersion,\n  useSlateProps,\n  useValueVersion,\n  withHOC,\n  withPlate,\n  withPlateReact\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/react/PlateElement.tsx\nimport React from \"react\";\nimport {\n  omitPluginContext,\n  usePlateStore\n} from \"@udecode/plate-core/react\";\nimport { Box, useComposedRef } from \"@udecode/react-utils\";\nimport { isBlock } from \"@udecode/slate\";\nimport { clsx } from \"clsx\";\nvar usePlateElement = (props) => {\n  const _a = omitPluginContext(props), { attributes, element, elementToAttributes, nodeProps } = _a, rootProps = __objRest(_a, [\"attributes\", \"element\", \"elementToAttributes\", \"nodeProps\"]);\n  const mounted = usePlateStore().get.isMounted();\n  const block = React.useMemo(\n    () => mounted && !!element.id && isBlock(props.editor, element),\n    [element, props.editor, mounted]\n  );\n  return {\n    props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, attributes), rootProps), nodeProps), elementToAttributes == null ? void 0 : elementToAttributes(element)), {\n      className: clsx(props.className, nodeProps == null ? void 0 : nodeProps.className),\n      \"data-block-id\": block ? element.id : void 0\n    }),\n    ref: useComposedRef(props.ref, attributes.ref)\n  };\n};\nvar PlateElement = React.forwardRef(\n  (props, ref) => {\n    const { props: rootProps, ref: rootRef } = usePlateElement(__spreadProps(__spreadValues({}, props), {\n      ref\n    }));\n    const rest = __objRest(rootProps, []);\n    return /* @__PURE__ */ React.createElement(Box, __spreadProps(__spreadValues({}, rest), { ref: rootRef }));\n  }\n);\nPlateElement.displayName = \"PlateElement\";\n\n// src/react/PlateLeaf.tsx\nimport React2 from \"react\";\nimport {\n  omitPluginContext as omitPluginContext2\n} from \"@udecode/plate-core/react\";\nimport { Text, useComposedRef as useComposedRef2 } from \"@udecode/react-utils\";\nimport { clsx as clsx2 } from \"clsx\";\nvar usePlateLeaf = (props) => {\n  const _a = omitPluginContext2(props), { attributes, leaf, leafToAttributes, nodeProps, text } = _a, rootProps = __objRest(_a, [\"attributes\", \"leaf\", \"leafToAttributes\", \"nodeProps\", \"text\"]);\n  return {\n    props: __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, attributes), rootProps), nodeProps), leafToAttributes == null ? void 0 : leafToAttributes(leaf)), {\n      className: clsx2(props.className, nodeProps == null ? void 0 : nodeProps.className)\n    }),\n    ref: useComposedRef2(props.ref, attributes.ref)\n  };\n};\nvar PlateLeaf = React2.forwardRef(\n  (props, ref) => {\n    const { props: rootProps, ref: rootRef } = usePlateLeaf(__spreadProps(__spreadValues({}, props), { ref }));\n    return /* @__PURE__ */ React2.createElement(Text, __spreadProps(__spreadValues({}, rootProps), { ref: rootRef }));\n  }\n);\nPlateLeaf.displayName = \"PlateLeaf\";\n\n// src/react/createNodeHOC.tsx\nimport React3 from \"react\";\nvar createNodeHOC = (HOC) => (Component, props) => function hoc(childrenProps) {\n  return /* @__PURE__ */ React3.createElement(HOC, __spreadValues({}, __spreadValues(__spreadValues({}, childrenProps), props)), /* @__PURE__ */ React3.createElement(Component, __spreadValues({}, childrenProps)));\n};\n\n// src/react/createNodesHOC.tsx\nimport castArray from \"lodash/castArray.js\";\nimport merge from \"lodash/merge.js\";\nvar createHOC = (withHOC) => {\n  return (components, options) => {\n    const _components = __spreadValues({}, components);\n    const optionsByKey = {};\n    const optionsList = castArray(options);\n    optionsList.forEach((_a) => {\n      var _b = _a, { key, keys } = _b, opt = __objRest(_b, [\"key\", \"keys\"]);\n      const _keys = key ? [key] : keys != null ? keys : Object.keys(_components);\n      _keys.forEach((_key) => {\n        optionsByKey[_key] = merge(optionsByKey[_key], opt);\n      });\n    });\n    Object.keys(optionsByKey).forEach((key) => {\n      if (!_components[key]) return;\n      _components[key] = withHOC(_components[key], optionsByKey[key]);\n    });\n    return _components;\n  };\n};\nvar createNodesHOC = (HOC) => {\n  return createHOC(createNodeHOC(HOC));\n};\nvar createNodesWithHOC = (withHOC) => {\n  return createHOC(withHOC);\n};\n\n// src/react/getLastBlockDOMNode.ts\nimport { toDOMNode } from \"@udecode/slate-react\";\nimport { getBlocks } from \"@udecode/slate-utils\";\nvar getLastBlockDOMNode = (editor) => {\n  return toDOMNode(editor, getBlocks(editor).at(-1)[0]);\n};\n\n// src/react/selectEditor.ts\nimport {\n  getEndPoint,\n  getStartPoint,\n  select\n} from \"@udecode/slate\";\nimport { focusEditor } from \"@udecode/slate-react\";\nvar selectEditor = (editor, { at, edge, focus }) => {\n  if (focus) {\n    focusEditor(editor);\n  }\n  let location = at;\n  if (edge === \"start\") {\n    location = getStartPoint(editor, []);\n  }\n  if (edge === \"end\") {\n    location = getEndPoint(editor, []);\n  }\n  if (location) {\n    select(editor, location);\n  }\n};\n\n// src/react/selectSiblingNodePoint.ts\nimport { setSelection } from \"@udecode/slate\";\nimport { findNodePath, focusEditor as focusEditor2 } from \"@udecode/slate-react\";\nimport {\n  getNextNodeStartPoint,\n  getPreviousNodeEndPoint\n} from \"@udecode/slate-utils\";\nvar selectSiblingNodePoint = (editor, {\n  at,\n  focus = true,\n  node,\n  reverse\n} = {}) => {\n  if (node) {\n    at = findNodePath(editor, node);\n  }\n  if (!at) return;\n  const point = reverse ? getPreviousNodeEndPoint(editor, at) : getNextNodeStartPoint(editor, at);\n  if (!point) return;\n  setSelection(editor, {\n    anchor: point,\n    focus: point\n  });\n  if (focus) {\n    focusEditor2(editor);\n  }\n};\n\n// src/react/useEditorString.ts\nimport { useEditorSelector } from \"@udecode/plate-core/react\";\nimport { getEditorString } from \"@udecode/slate\";\nvar useEditorString = () => {\n  return useEditorSelector((editor) => getEditorString(editor, []), []);\n};\n\n// src/react/useFormInputProps.ts\nvar useFormInputProps = (options) => {\n  if (!options) return { props: {} };\n  const { preventDefaultOnEnterKeydown } = options;\n  const handleEnterKeydownCapture = (e) => {\n    if (e.key === \"Enter\" || e.keyCode === 13) {\n      e.preventDefault();\n    }\n  };\n  return {\n    props: {\n      onKeyDownCapture: preventDefaultOnEnterKeydown ? (e) => handleEnterKeydownCapture(e) : void 0\n    }\n  };\n};\n\n// src/react/useLastBlock.ts\nimport { useEditorSelector as useEditorSelector2 } from \"@udecode/plate-core/react\";\nimport { getBlocks as getBlocks2 } from \"@udecode/slate-utils\";\nvar useLastBlock = ({\n  deps,\n  enabled\n}) => {\n  return useEditorSelector2(\n    (editor) => enabled ? getBlocks2(editor).at(-1)[0] : null,\n    [enabled, ...deps || []]\n  );\n};\n\n// src/react/useLastBlockDOMNode.ts\nimport { useMemo } from \"react\";\nimport { toDOMNode as toDOMNode2 } from \"@udecode/slate-react\";\nvar useLastBlockDOMNode = (editor, { deps, enabled }) => {\n  const lastBlock = useLastBlock({ deps, enabled });\n  const anchorElement = useMemo(\n    () => lastBlock ? toDOMNode2(editor, lastBlock) : null,\n    [editor, lastBlock]\n  );\n  return anchorElement;\n};\n\n// src/react/useMarkToolbarButton.ts\nimport { useEditorRef, useEditorSelector as useEditorSelector3 } from \"@udecode/plate-core/react\";\nimport { focusEditor as focusEditor3 } from \"@udecode/slate-react\";\nimport { isMarkActive } from \"@udecode/slate-utils\";\nvar useMarkToolbarButtonState = ({\n  clear,\n  nodeType\n}) => {\n  const pressed = useEditorSelector3(\n    (editor) => isMarkActive(editor, nodeType),\n    [nodeType]\n  );\n  return {\n    clear,\n    nodeType,\n    pressed\n  };\n};\nvar useMarkToolbarButton = (state) => {\n  const editor = useEditorRef();\n  return {\n    props: {\n      pressed: state.pressed,\n      onClick: () => {\n        editor.tf.toggle.mark({ key: state.nodeType, clear: state.clear });\n        focusEditor3(editor);\n      },\n      onMouseDown: (e) => {\n        e.preventDefault();\n      }\n    }\n  };\n};\n\n// src/react/usePlaceholder.ts\nimport { useEditorRef as useEditorRef2 } from \"@udecode/plate-core/react\";\nimport {\n  isCollapsed,\n  isElementEmpty,\n  queryNode\n} from \"@udecode/slate\";\nimport { findNodePath as findNodePath2 } from \"@udecode/slate-react\";\nimport { useComposing, useFocused, useSelected } from \"slate-react\";\nvar usePlaceholderState = ({\n  element,\n  hideOnBlur = true,\n  query\n}) => {\n  const focused = useFocused();\n  const selected = useSelected();\n  const composing = useComposing();\n  const editor = useEditorRef2();\n  const isEmptyBlock = isElementEmpty(editor, element) && !composing;\n  const enabled = isEmptyBlock && (!query || queryNode([element, findNodePath2(editor, element)], query)) && (!hideOnBlur || isCollapsed(editor.selection) && hideOnBlur && focused && selected);\n  return {\n    enabled\n  };\n};\n\n// src/react/useRemoveNodeButton.ts\nimport { useEditorRef as useEditorRef3 } from \"@udecode/plate-core/react\";\nimport { removeNodes } from \"@udecode/slate\";\nimport { findNodePath as findNodePath3 } from \"@udecode/slate-react\";\nvar useRemoveNodeButton = ({ element }) => {\n  const editor = useEditorRef3();\n  return {\n    props: {\n      onClick: () => {\n        const path = findNodePath3(editor, element);\n        removeNodes(editor, { at: path });\n      },\n      onMouseDown: (e) => {\n        e.preventDefault();\n      }\n    }\n  };\n};\n\n// src/react/useSelection.ts\nimport { useEditorSelector as useEditorSelector4 } from \"@udecode/plate-core/react\";\nimport {\n  isRangeAcrossBlocks,\n  isRangeInSameBlock,\n  isSelectionExpanded\n} from \"@udecode/slate-utils\";\nfunction useSelectionCollapsed() {\n  return useEditorSelector4((editor) => !isSelectionExpanded(editor), []);\n}\nfunction useSelectionExpanded() {\n  return useEditorSelector4((editor) => isSelectionExpanded(editor), []);\n}\nfunction useSelectionWithinBlock() {\n  return useEditorSelector4((editor) => isRangeInSameBlock(editor), []);\n}\nfunction useSelectionAcrossBlocks() {\n  return useEditorSelector4((editor) => isRangeAcrossBlocks(editor), []);\n}\n\n// src/react/useSelectionFragment.ts\nimport { useEditorSelector as useEditorSelector5 } from \"@udecode/plate-core/react\";\nimport {\n  getFragmentProp,\n  getSelectionFragment\n} from \"@udecode/slate-utils\";\nvar useSelectionFragment = (options) => {\n  return useEditorSelector5((editor) => {\n    return getSelectionFragment(editor, options);\n  }, []);\n};\nvar useSelectionFragmentProp = (_a = {}) => {\n  var _b = _a, {\n    structuralTypes\n  } = _b, options = __objRest(_b, [\n    \"structuralTypes\"\n  ]);\n  return useEditorSelector5((editor) => {\n    const fragment = getSelectionFragment(editor, { structuralTypes });\n    return getFragmentProp(fragment, options);\n  }, []);\n};\nexport {\n  PlateElement,\n  PlateLeaf,\n  createNodeHOC,\n  createNodesHOC,\n  createNodesWithHOC,\n  getLastBlockDOMNode,\n  selectEditor,\n  selectSiblingNodePoint,\n  useEditorString,\n  useFormInputProps,\n  useLastBlock,\n  useLastBlockDOMNode,\n  useMarkToolbarButton,\n  useMarkToolbarButtonState,\n  usePlaceholderState,\n  usePlateElement,\n  usePlateLeaf,\n  useRemoveNodeButton,\n  useSelectionAcrossBlocks,\n  useSelectionCollapsed,\n  useSelectionExpanded,\n  useSelectionFragment,\n  useSelectionFragmentProp,\n  useSelectionWithinBlock\n};\n//# sourceMappingURL=index.mjs.map","'use client'\n\nimport React from 'react'\nimport type { PlateContentProps } from '@udecode/plate-common/react'\nimport type { VariantProps } from 'class-variance-authority'\n\nimport { cn } from '@udecode/cn'\nimport { PlateContent, useEditorContainerRef, useEditorRef } from '@udecode/plate-common/react'\nimport { cva } from 'class-variance-authority'\n\nconst editorContainerVariants = cva(\n  'relative w-full cursor-text overflow-y-auto caret-primary selection:bg-brand/25 focus-visible:outline-none [&_.slate-selection-area]:border [&_.slate-selection-area]:border-brand/25 [&_.slate-selection-area]:bg-brand/15',\n  {\n    defaultVariants: {\n      variant: 'default',\n    },\n    variants: {\n      variant: {\n        default: 'h-full',\n        demo: 'h-[650px]',\n        select: cn(\n          'group rounded-md border border-input ring-offset-background focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2',\n          'has-[[data-readonly]]:w-fit has-[[data-readonly]]:cursor-default has-[[data-readonly]]:border-transparent has-[[data-readonly]]:focus-within:[box-shadow:none]',\n        ),\n      },\n    },\n  },\n)\n\nexport const EditorContainer = ({\n  className,\n  variant,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof editorContainerVariants>) => {\n  const editor = useEditorRef()\n  const containerRef = useEditorContainerRef()\n\n  return (\n    <div\n      id={editor.uid}\n      ref={containerRef}\n      className={cn(\n        'ignore-click-outside/toolbar',\n        editorContainerVariants({ variant }),\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nEditorContainer.displayName = 'EditorContainer'\n\nconst editorVariants = cva(\n  cn(\n    'group/editor',\n    'relative w-full overflow-x-hidden whitespace-pre-wrap break-words',\n    'rounded-md ring-offset-background placeholder:text-muted-foreground/80 focus-visible:outline-none',\n    '[&_[data-slate-placeholder]]:text-muted-foreground/80 [&_[data-slate-placeholder]]:!opacity-100',\n    '[&_[data-slate-placeholder]]:top-[auto_!important]',\n    '[&_strong]:font-bold',\n  ),\n  {\n    defaultVariants: {\n      variant: 'default',\n    },\n    variants: {\n      disabled: {\n        true: 'cursor-not-allowed opacity-50',\n      },\n      focused: {\n        true: 'ring-2 ring-ring ring-offset-2',\n      },\n      variant: {\n        ai: 'w-full px-0 text-base md:text-sm',\n        aiChat:\n          'max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-3 py-2 text-base md:text-sm',\n        default: 'size-full px-16 pb-72 pt-4 text-base sm:px-[max(64px,calc(50%-350px))]',\n        demo: 'size-full px-16 pb-72 pt-4 text-base sm:px-[max(64px,calc(50%-350px))]',\n        fullWidth: 'size-full px-16 pb-72 pt-4 text-base sm:px-24',\n        none: '',\n        select: 'px-3 py-2 text-base data-[readonly]:w-fit',\n      },\n    },\n  },\n)\n\nexport type EditorProps = PlateContentProps & VariantProps<typeof editorVariants>\n\nexport const Editor = React.forwardRef<HTMLDivElement, EditorProps>(\n  ({ className, disabled, focused, variant, ...props }, ref) => {\n    return (\n      <PlateContent\n        ref={ref}\n        className={cn(\n          editorVariants({\n            disabled,\n            focused,\n            variant,\n          }),\n          className,\n        )}\n        disabled={disabled}\n        disableDefaultStyles\n        {...props}\n      />\n    )\n  },\n)\n\nEditor.displayName = 'Editor'\n","var baseMerge = require('./_baseMerge'),\n    isObject = require('./isObject');\n\n/**\n * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n * objects into destination objects that are passed thru.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to merge.\n * @param {Object} object The parent object of `objValue`.\n * @param {Object} source The parent object of `srcValue`.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n * @returns {*} Returns the value to assign.\n */\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n  if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, objValue);\n    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n    stack['delete'](srcValue);\n  }\n  return objValue;\n}\n\nmodule.exports = customDefaultsMerge;\n","var apply = require('./_apply'),\n    baseRest = require('./_baseRest'),\n    customDefaultsMerge = require('./_customDefaultsMerge'),\n    mergeWith = require('./mergeWith');\n\n/**\n * This method is like `_.defaults` except that it recursively assigns\n * default properties.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 3.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaults\n * @example\n *\n * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n * // => { 'a': { 'b': 2, 'c': 3 } }\n */\nvar defaultsDeep = baseRest(function(args) {\n  args.push(undefined, customDefaultsMerge);\n  return apply(mergeWith, undefined, args);\n});\n\nmodule.exports = defaultsDeep;\n","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/lib/editor/withSlate.ts\nimport {\n  createTEditor,\n  getEndPoint,\n  getStartPoint,\n  normalizeEditor,\n  select\n} from \"@udecode/slate\";\nimport { nanoid } from \"nanoid\";\n\n// src/internal/mergePlugins.ts\nimport mergeWith from \"lodash/mergeWith.js\";\nfunction mergePlugins(basePlugin, ...sourcePlugins) {\n  return mergeWith(\n    {},\n    basePlugin,\n    ...sourcePlugins,\n    (objValue, srcValue, key) => {\n      if (Array.isArray(srcValue)) {\n        return srcValue;\n      }\n      if (key === \"options\") {\n        return __spreadValues(__spreadValues({}, objValue), srcValue);\n      }\n    }\n  );\n}\n\n// src/lib/utils/misc/isFunction.ts\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/lib/plugin/createSlatePlugin.ts\nfunction createSlatePlugin(config = {}) {\n  var _a;\n  let baseConfig;\n  let initialExtension;\n  if (isFunction(config)) {\n    baseConfig = { key: \"\" };\n    initialExtension = (editor) => config(editor);\n  } else {\n    baseConfig = config;\n  }\n  const key = (_a = baseConfig.key) != null ? _a : \"\";\n  const plugin = mergePlugins(\n    {\n      key,\n      __apiExtensions: [],\n      __configuration: null,\n      __extensions: initialExtension ? [initialExtension] : [],\n      __optionExtensions: [],\n      api: {},\n      dependencies: [],\n      editor: {},\n      inject: {},\n      node: { type: key },\n      options: {},\n      override: {},\n      parser: {},\n      parsers: {},\n      plugins: [],\n      priority: 100,\n      render: {},\n      shortcuts: {},\n      transforms: {},\n      handlers: {}\n    },\n    config\n  );\n  plugin.configure = (config2) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__configuration = (ctx) => isFunction(config2) ? config2(ctx) : config2;\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.configurePlugin = (p, config2) => {\n    const newPlugin = __spreadValues({}, plugin);\n    const configureNestedPlugin = (plugins) => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n          return createSlatePlugin(__spreadProps(__spreadValues({}, nestedPlugin), {\n            __configuration: (ctx) => isFunction(config2) ? config2(ctx) : config2\n          }));\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result2 = configureNestedPlugin(nestedPlugin.plugins);\n          if (result2.found) {\n            found = true;\n            return __spreadProps(__spreadValues({}, nestedPlugin), {\n              plugins: result2.plugins\n            });\n          }\n        }\n        return nestedPlugin;\n      });\n      return { found, plugins: updatedPlugins };\n    };\n    const result = configureNestedPlugin(newPlugin.plugins);\n    newPlugin.plugins = result.plugins;\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendEditorApi = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: false }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendOptions = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__optionExtensions = [\n      ...newPlugin.__optionExtensions,\n      extension\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendApi = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: true }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendEditorTransforms = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: false, isTransform: true }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extendTransforms = (extension) => {\n    const newPlugin = __spreadValues({}, plugin);\n    newPlugin.__apiExtensions = [\n      ...newPlugin.__apiExtensions,\n      { extension, isPluginSpecific: true, isTransform: true }\n    ];\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.extend = (extendConfig) => {\n    let newPlugin = __spreadValues({}, plugin);\n    if (isFunction(extendConfig)) {\n      newPlugin.__extensions = [\n        ...newPlugin.__extensions,\n        extendConfig\n      ];\n    } else {\n      newPlugin = mergePlugins(newPlugin, extendConfig);\n    }\n    return createSlatePlugin(newPlugin);\n  };\n  plugin.clone = () => mergePlugins(plugin);\n  plugin.extendPlugin = (p, extendConfig) => {\n    const newPlugin = __spreadValues({}, plugin);\n    const extendNestedPlugin = (plugins) => {\n      let found = false;\n      const updatedPlugins = plugins.map((nestedPlugin) => {\n        if (nestedPlugin.key === p.key) {\n          found = true;\n          return createSlatePlugin(__spreadProps(__spreadValues({}, nestedPlugin), {\n            __extensions: [\n              ...nestedPlugin.__extensions,\n              (ctx) => isFunction(extendConfig) ? extendConfig(ctx) : extendConfig\n            ]\n          }));\n        }\n        if (nestedPlugin.plugins && nestedPlugin.plugins.length > 0) {\n          const result2 = extendNestedPlugin(nestedPlugin.plugins);\n          if (result2.found) {\n            found = true;\n            return __spreadProps(__spreadValues({}, nestedPlugin), {\n              plugins: result2.plugins\n            });\n          }\n        }\n        return nestedPlugin;\n      });\n      return { found, plugins: updatedPlugins };\n    };\n    const result = extendNestedPlugin(newPlugin.plugins);\n    newPlugin.plugins = result.plugins;\n    if (!result.found) {\n      newPlugin.plugins.push(\n        createSlatePlugin({\n          key: p.key,\n          __extensions: [\n            (ctx) => isFunction(extendConfig) ? extendConfig(ctx) : extendConfig\n          ]\n        })\n      );\n    }\n    return createSlatePlugin(newPlugin);\n  };\n  return plugin;\n}\nfunction createTSlatePlugin(config = {}) {\n  return createSlatePlugin(config);\n}\n\n// src/lib/utils/applyDeepToNodes.ts\nimport {\n  isAncestor,\n  queryNode\n} from \"@udecode/slate\";\nvar applyDeepToNodes = ({\n  apply,\n  node,\n  path = [],\n  query,\n  source\n}) => {\n  const entry = [node, path];\n  if (queryNode(entry, query)) {\n    if (source instanceof Function) {\n      apply(node, source());\n    } else {\n      apply(node, source);\n    }\n  }\n  if (!isAncestor(node)) return;\n  node.children.forEach((child, index) => {\n    applyDeepToNodes({\n      apply,\n      node: child,\n      path: path.concat([index]),\n      query,\n      source\n    });\n  });\n};\n\n// src/lib/utils/getInjectMatch.ts\nimport { getAboveNode, isBlock, isElement } from \"@udecode/slate\";\n\n// src/lib/utils/getKeysByTypes.ts\nvar getKeysByTypes = (editor, types) => {\n  return Object.values(editor.plugins).filter((plugin) => types.includes(plugin.node.type)).map((plugin) => plugin.key);\n};\nvar getKeyByType = (editor, type) => {\n  var _a;\n  const plugin = Object.values(editor.plugins).find(\n    (plugin2) => plugin2.node.type === type\n  );\n  return (_a = plugin == null ? void 0 : plugin.key) != null ? _a : type;\n};\n\n// src/lib/utils/getInjectMatch.ts\nvar getInjectMatch = (editor, plugin) => {\n  return (node, path) => {\n    const {\n      inject: {\n        excludeBelowPlugins,\n        excludePlugins,\n        isBlock: _isBlock,\n        isElement: _isElement,\n        isLeaf,\n        maxLevel,\n        targetPlugins\n      }\n    } = plugin;\n    const element = isElement(node) ? node : void 0;\n    if (_isElement && element) return false;\n    if (_isBlock && (!element || !isBlock(editor, element))) return false;\n    if (isLeaf && element) return false;\n    if (element == null ? void 0 : element.type) {\n      if (excludePlugins == null ? void 0 : excludePlugins.includes(getKeyByType(editor, element.type))) {\n        return false;\n      }\n      if (targetPlugins && !targetPlugins.includes(getKeyByType(editor, element.type))) {\n        return false;\n      }\n    }\n    if (excludeBelowPlugins || maxLevel) {\n      if (maxLevel && path.length > maxLevel) {\n        return false;\n      }\n      if (excludeBelowPlugins) {\n        const excludeTypes = getKeysByTypes(editor, excludeBelowPlugins);\n        const isBelow = getAboveNode(editor, {\n          at: path,\n          match: (n) => isElement(n) && excludeTypes.includes(n.type)\n        });\n        if (isBelow) return false;\n      }\n    }\n    return true;\n  };\n};\n\n// src/lib/utils/getInjectedPlugins.ts\nvar getInjectedPlugins = (editor, plugin) => {\n  const injectedPlugins = [];\n  [...editor.pluginList].reverse().forEach((p) => {\n    var _a;\n    const injectedPlugin = (_a = p.inject.plugins) == null ? void 0 : _a[plugin.key];\n    if (injectedPlugin) injectedPlugins.push(injectedPlugin);\n  });\n  return [plugin, ...injectedPlugins];\n};\n\n// src/lib/utils/hotkeys.ts\nimport { IS_APPLE } from \"@udecode/utils\";\nimport { isKeyHotkey } from \"is-hotkey\";\nimport { isHotkey } from \"is-hotkey\";\nvar HOTKEYS = {\n  bold: \"mod+b\",\n  compose: [\"down\", \"left\", \"right\", \"up\", \"backspace\", \"enter\"],\n  deleteBackward: \"shift?+backspace\",\n  deleteForward: \"shift?+delete\",\n  extendBackward: \"shift+left\",\n  extendForward: \"shift+right\",\n  insertSoftBreak: \"shift+enter\",\n  italic: \"mod+i\",\n  moveBackward: \"left\",\n  moveForward: \"right\",\n  moveWordBackward: \"ctrl+left\",\n  moveWordForward: \"ctrl+right\",\n  splitBlock: \"enter\",\n  tab: \"tab\",\n  undo: \"mod+z\",\n  untab: \"shift+tab\"\n};\nvar APPLE_HOTKEYS = {\n  deleteBackward: [\"ctrl+backspace\", \"ctrl+h\"],\n  deleteForward: [\"ctrl+delete\", \"ctrl+d\"],\n  deleteLineBackward: \"cmd+shift?+backspace\",\n  deleteLineForward: [\"cmd+shift?+delete\", \"ctrl+k\"],\n  deleteWordBackward: \"opt+shift?+backspace\",\n  deleteWordForward: \"opt+shift?+delete\",\n  extendLineBackward: \"opt+shift+up\",\n  extendLineForward: \"opt+shift+down\",\n  moveLineBackward: \"opt+up\",\n  moveLineForward: \"opt+down\",\n  moveWordBackward: \"opt+left\",\n  moveWordForward: \"opt+right\",\n  redo: \"cmd+shift+z\",\n  transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: \"ctrl+shift?+backspace\",\n  deleteWordForward: \"ctrl+shift?+delete\",\n  redo: [\"ctrl+y\", \"ctrl+shift+z\"]\n};\nvar createHotkey = (key) => {\n  const generic = HOTKEYS[key];\n  const apple = APPLE_HOTKEYS[key];\n  const windows = WINDOWS_HOTKEYS[key];\n  const isGeneric = generic && isKeyHotkey(generic);\n  const isApple = apple && isKeyHotkey(apple);\n  const isWindows = windows && isKeyHotkey(windows);\n  return (event) => {\n    if (isGeneric == null ? void 0 : isGeneric(event)) return true;\n    if (IS_APPLE && (isApple == null ? void 0 : isApple(event))) return true;\n    if (!IS_APPLE && (isWindows == null ? void 0 : isWindows(event))) return true;\n    return false;\n  };\n};\nvar Hotkeys = {\n  isBold: createHotkey(\"bold\"),\n  isCompose: createHotkey(\"compose\"),\n  isDeleteBackward: createHotkey(\"deleteBackward\"),\n  isDeleteForward: createHotkey(\"deleteForward\"),\n  isDeleteLineBackward: createHotkey(\"deleteLineBackward\"),\n  isDeleteLineForward: createHotkey(\"deleteLineForward\"),\n  isDeleteWordBackward: createHotkey(\"deleteWordBackward\"),\n  isDeleteWordForward: createHotkey(\"deleteWordForward\"),\n  isExtendBackward: createHotkey(\"extendBackward\"),\n  isExtendForward: createHotkey(\"extendForward\"),\n  isExtendLineBackward: createHotkey(\"extendLineBackward\"),\n  isExtendLineForward: createHotkey(\"extendLineForward\"),\n  isItalic: createHotkey(\"italic\"),\n  isMoveBackward: createHotkey(\"moveBackward\"),\n  isMoveForward: createHotkey(\"moveForward\"),\n  isMoveLineBackward: createHotkey(\"moveLineBackward\"),\n  isMoveLineForward: createHotkey(\"moveLineForward\"),\n  isMoveWordBackward: createHotkey(\"moveWordBackward\"),\n  isMoveWordForward: createHotkey(\"moveWordForward\"),\n  isRedo: createHotkey(\"redo\"),\n  isSoftBreak: createHotkey(\"insertSoftBreak\"),\n  isSplitBlock: createHotkey(\"splitBlock\"),\n  isTransposeCharacter: createHotkey(\"transposeCharacter\"),\n  isUndo: createHotkey(\"undo\")\n};\n\n// src/lib/utils/mergeDeepToNodes.ts\nimport merge from \"lodash/merge.js\";\nvar mergeDeepToNodes = (options) => {\n  applyDeepToNodes(__spreadProps(__spreadValues({}, options), { apply: merge }));\n};\n\n// src/lib/utils/normalizeDescendantsToDocumentFragment.ts\nimport {\n  isElement as isElement3,\n  isText as isText2\n} from \"@udecode/slate\";\n\n// src/lib/plugin/getEditorPlugin.ts\nfunction getEditorPlugin(editor, p) {\n  const plugin = editor.getPlugin(p);\n  return {\n    api: editor.api,\n    editor,\n    getOption: (key, ...args) => editor.getOption(plugin, key, ...args),\n    getOptions: () => editor.getOptions(plugin),\n    plugin,\n    setOption: (keyOrOptions, value) => editor.setOption(plugin, keyOrOptions, value),\n    setOptions: (options) => editor.setOptions(plugin, options),\n    tf: editor.transforms,\n    type: plugin.node.type\n  };\n}\n\n// src/lib/plugins/AstPlugin.ts\nvar AstPlugin = createSlatePlugin({\n  key: \"ast\",\n  parser: {\n    deserialize: ({ data }) => {\n      const decoded = decodeURIComponent(window.atob(data));\n      let parsed;\n      try {\n        parsed = JSON.parse(decoded);\n      } catch (e) {\n      }\n      return parsed;\n    },\n    format: \"application/x-slate-fragment\"\n  }\n});\n\n// src/lib/plugins/DOMPlugin.ts\nvar DOMPlugin = createSlatePlugin({\n  key: \"dom\"\n});\n\n// src/lib/plugins/HistoryPlugin.ts\nimport { withHistory } from \"@udecode/slate\";\nvar withPlateHistory = ({ editor }) => withHistory(editor);\nvar HistoryPlugin = createSlatePlugin({\n  key: \"history\",\n  extendEditor: withPlateHistory\n});\n\n// src/lib/plugins/InlineVoidPlugin.ts\nvar withInlineVoid = ({ editor }) => {\n  const { isInline, isVoid, markableVoid } = editor;\n  const voidTypes = [];\n  const inlineTypes = [];\n  const markableVoidTypes = [];\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.node.isInline) {\n      inlineTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isVoid) {\n      voidTypes.push(plugin.node.type);\n    }\n    if (plugin.node.isMarkableVoid) {\n      markableVoidTypes.push(plugin.node.type);\n    }\n  });\n  editor.isInline = (element) => {\n    return inlineTypes.includes(element.type) ? true : isInline(element);\n  };\n  editor.isVoid = (element) => {\n    return voidTypes.includes(element.type) ? true : isVoid(element);\n  };\n  editor.markableVoid = (element) => {\n    return markableVoidTypes.includes(element.type) ? true : markableVoid(element);\n  };\n  return editor;\n};\nvar InlineVoidPlugin = createSlatePlugin({\n  key: \"inlineVoid\",\n  extendEditor: withInlineVoid\n});\n\n// src/lib/plugins/ParserPlugin.ts\nvar withParser = ({ editor }) => {\n  const { insertData } = editor;\n  editor.insertData = (dataTransfer) => {\n    const inserted = [...editor.pluginList].reverse().some((plugin) => {\n      const parser = plugin.parser;\n      if (!parser) return false;\n      const injectedPlugins = getInjectedPlugins(editor, plugin);\n      const { deserialize, format, mimeTypes } = parser;\n      if (!format) return false;\n      const formats = Array.isArray(format) ? format : [format];\n      const mimeTypeList = mimeTypes || formats.map((fmt) => fmt.includes(\"/\") ? fmt : `text/${fmt}`);\n      for (const mimeType of mimeTypeList) {\n        let data = dataTransfer.getData(mimeType);\n        if (!data) continue;\n        if (!pipeInsertDataQuery(editor, injectedPlugins, {\n          data,\n          dataTransfer\n        })) {\n          continue;\n        }\n        data = pipeTransformData(editor, injectedPlugins, {\n          data,\n          dataTransfer\n        });\n        let fragment = deserialize == null ? void 0 : deserialize(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n          data,\n          dataTransfer\n        }));\n        if (!(fragment == null ? void 0 : fragment.length)) continue;\n        fragment = pipeTransformFragment(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n          fragment\n        });\n        if (fragment.length === 0) continue;\n        pipeInsertFragment(editor, injectedPlugins, {\n          data,\n          dataTransfer,\n          fragment\n        });\n        return true;\n      }\n      return false;\n    });\n    if (inserted) return;\n    insertData(dataTransfer);\n  };\n  return editor;\n};\nvar ParserPlugin = createSlatePlugin({\n  key: \"parser\",\n  extendEditor: withParser\n});\n\n// src/lib/plugins/debug/DebugPlugin.ts\nvar PlateError = class extends Error {\n  constructor(message, type = \"DEFAULT\") {\n    super(`[${type}] ${message}`);\n    this.type = type;\n    this.name = \"PlateError\";\n  }\n};\nvar DebugPlugin = createTSlatePlugin({\n  key: \"debug\",\n  options: {\n    isProduction: process.env.NODE_ENV === \"production\",\n    logLevel: process.env.NODE_ENV === \"production\" ? \"error\" : \"log\",\n    logger: {\n      error: (message, type, details) => console.error(`${type ? `[${type}] ` : \"\"}${message}`, details),\n      info: (message, type, details) => console.info(`${type ? `[${type}] ` : \"\"}${message}`, details),\n      log: (message, type, details) => console.log(`${type ? `[${type}] ` : \"\"}${message}`, details),\n      warn: (message, type, details) => console.warn(`${type ? `[${type}] ` : \"\"}${message}`, details)\n    },\n    throwErrors: true\n  }\n}).extendEditorApi(({ getOptions }) => {\n  const logLevels = [\"error\", \"warn\", \"info\", \"log\"];\n  const log = (level, message, type, details) => {\n    var _a, _b;\n    const options = getOptions();\n    if (options.isProduction && level === \"log\") return;\n    if (logLevels.indexOf(level) <= logLevels.indexOf(options.logLevel)) {\n      if (level === \"error\" && options.throwErrors) {\n        const error = message instanceof Error ? message : new PlateError(message, type);\n        throw error;\n      } else {\n        (_b = (_a = options.logger)[level]) == null ? void 0 : _b.call(_a, message, type, details);\n      }\n    }\n  };\n  return {\n    debug: {\n      error: (message, type, details) => log(\"error\", message, type, details),\n      info: (message, type, details) => log(\"info\", message, type, details),\n      log: (message, type, details) => log(\"log\", message, type, details),\n      warn: (message, type, details) => log(\"warn\", message, type, details)\n    }\n  };\n});\n\n// src/lib/plugins/editor-protocol/SlateNextPlugin.ts\nimport {\n  isSelectionAtBlockStart,\n  removeSelectionMark,\n  replaceNodeChildren as replaceNodeChildren2,\n  toggleMark\n} from \"@udecode/slate-utils\";\nimport { bindFirst } from \"@udecode/utils\";\n\n// src/lib/transforms/resetEditorChildren.ts\nimport {\n  replaceNodeChildren\n} from \"@udecode/slate-utils\";\nvar resetEditorChildren = (editor, options) => {\n  replaceNodeChildren(editor, __spreadValues({\n    at: [],\n    nodes: editor.api.create.value()\n  }, options));\n};\n\n// src/lib/transforms/resetEditor.ts\nvar resetEditor = (editor) => {\n  resetEditorChildren(editor);\n  editor.history.undos = [];\n  editor.history.redos = [];\n  editor.operations = [];\n};\n\n// src/lib/transforms/toggleBlock.ts\nimport {\n  someNode\n} from \"@udecode/slate\";\nvar toggleBlock = (editor, options, editorNodesOptions) => {\n  var _a;\n  const { defaultType = editor.getType(BaseParagraphPlugin), type } = options;\n  const at = (_a = editorNodesOptions == null ? void 0 : editorNodesOptions.at) != null ? _a : editor.selection;\n  if (!type || !at) return;\n  const isActive = someNode(editor, __spreadProps(__spreadValues({}, editorNodesOptions), {\n    match: {\n      type\n    }\n  }));\n  if (isActive && type === defaultType) return;\n  editor.setNodes(\n    {\n      type: isActive ? defaultType : type\n    },\n    { at }\n  );\n};\n\n// src/lib/plugins/paragraph/BaseParagraphPlugin.ts\nvar BaseParagraphPlugin = createSlatePlugin({\n  key: \"p\",\n  node: { isElement: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => element.style.fontFamily !== \"Consolas\",\n        rules: [\n          {\n            validNodeName: \"P\"\n          }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/plugins/editor-protocol/SlateNextPlugin.ts\nvar withSlateNext = ({ editor }) => {\n  const { apply, deleteBackward, deleteForward, deleteFragment } = editor;\n  editor.prevSelection = null;\n  editor.currentKeyboardEvent = null;\n  const resetMarks = () => {\n    if (isSelectionAtBlockStart(editor)) {\n      removeSelectionMark(editor);\n    }\n  };\n  editor.deleteBackward = (unit) => {\n    deleteBackward(unit);\n    resetMarks();\n  };\n  editor.deleteForward = (unit) => {\n    deleteForward(unit);\n    resetMarks();\n  };\n  editor.deleteFragment = (direction) => {\n    deleteFragment(direction);\n    resetMarks();\n  };\n  editor.apply = (operation) => {\n    if (operation.type === \"set_selection\") {\n      const { properties } = operation;\n      editor.prevSelection = properties;\n      apply(operation);\n      editor.currentKeyboardEvent = null;\n      return;\n    }\n    apply(operation);\n  };\n  return editor;\n};\nvar SlateNextPlugin = createTSlatePlugin({\n  key: \"slateNext\",\n  extendEditor: withSlateNext\n}).extendEditorApi(({ editor }) => ({\n  create: {\n    /** Default block factory. */\n    block: (node, _path) => __spreadValues({\n      children: [{ text: \"\" }],\n      type: editor.getType(BaseParagraphPlugin)\n    }, node)\n  }\n})).extendEditorApi(({ api }) => ({\n  create: {\n    /** Editor children factory. */\n    value: () => [api.create.block()]\n  }\n})).extendEditorTransforms(({ editor }) => ({\n  reset: () => {\n    resetEditor(editor);\n  },\n  setValue: (value) => {\n    let children = value;\n    if (typeof value === \"string\") {\n      children = editor.api.html.deserialize({\n        element: value\n      });\n    } else if (!value || value.length === 0) {\n      children = editor.api.create.value();\n    }\n    replaceNodeChildren2(editor, {\n      at: [],\n      nodes: children\n    });\n  },\n  toggle: {\n    block: bindFirst(toggleBlock, editor),\n    mark: bindFirst(toggleMark, editor)\n  }\n}));\n\n// src/lib/plugins/html/HtmlPlugin.ts\nimport { bindFirst as bindFirst2 } from \"@udecode/utils\";\n\n// src/lib/plugins/html/constants.ts\nvar CARRIAGE_RETURN = \"\\r\";\nvar LINE_FEED = \"\\n\";\nvar NO_BREAK_SPACE = \"\\xA0\";\nvar SPACE = \" \";\nvar TAB = \"\t\";\nvar ZERO_WIDTH_SPACE = \"\\u200B\";\n\n// src/lib/plugins/html/utils/isHtmlElement.ts\nvar isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;\n\n// src/lib/plugins/html/utils/traverseHtmlNode.ts\nvar traverseHtmlNode = (node, callback) => {\n  const keepTraversing = callback(node);\n  if (!keepTraversing) {\n    return;\n  }\n  let child = node.firstChild;\n  while (child) {\n    const currentChild = child;\n    const previousChild = child.previousSibling;\n    child = child.nextSibling;\n    traverseHtmlNode(currentChild, callback);\n    if (\n      // An unwrap was made. Need to compute the next child again.\n      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode\n    ) {\n      child = previousChild ? previousChild.nextSibling : node.firstChild;\n    } else if (\n      // A list was created. Need to compute the next child again.\n      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode\n    ) {\n      if (previousChild) {\n        child = previousChild.nextSibling ? previousChild.nextSibling.nextSibling : null;\n      } else if (node.firstChild) {\n        child = node.firstChild.nextSibling;\n      }\n    }\n  }\n};\n\n// src/lib/plugins/html/utils/traverseHtmlElements.ts\nvar traverseHtmlElements = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlElement(node)) {\n      return true;\n    }\n    return callback(node);\n  });\n};\n\n// src/lib/plugins/html/utils/cleanHtmlBrElements.ts\nvar cleanHtmlBrElements = (rootNode) => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== \"BR\") {\n      return true;\n    }\n    const replacementTextNode = document.createTextNode(LINE_FEED);\n    if (element.parentElement) {\n      element.parentElement.replaceChild(replacementTextNode, element);\n    }\n    return false;\n  });\n};\n\n// src/lib/plugins/html/utils/cleanHtmlCrLf.ts\nvar cleanHtmlCrLf = (html) => {\n  return html.replaceAll(/\\r\\n|\\r/g, \"\\n\");\n};\n\n// src/lib/plugins/html/utils/cleanHtmlEmptyElements.ts\nvar ALLOWED_EMPTY_ELEMENTS = /* @__PURE__ */ new Set([\"BR\", \"IMG\", \"TD\", \"TH\"]);\nvar isEmpty = (element) => {\n  return !ALLOWED_EMPTY_ELEMENTS.has(element.nodeName) && !element.innerHTML.trim();\n};\nvar removeIfEmpty = (element) => {\n  if (isEmpty(element)) {\n    const { parentElement } = element;\n    element.remove();\n    if (parentElement) {\n      removeIfEmpty(parentElement);\n    }\n  }\n};\nvar cleanHtmlEmptyElements = (rootNode) => {\n  traverseHtmlElements(rootNode, (element) => {\n    removeIfEmpty(element);\n    return true;\n  });\n};\n\n// src/lib/plugins/html/utils/replaceTagName.ts\nvar replaceTagName = (element, tagName) => {\n  const newElement = document.createElement(tagName);\n  newElement.innerHTML = element.innerHTML;\n  for (const { name } of element.attributes) {\n    const value = element.getAttribute(name);\n    if (value) {\n      newElement.setAttribute(name, value);\n    }\n  }\n  if (element.parentNode) {\n    element.parentNode.replaceChild(newElement, element);\n  }\n  return newElement;\n};\n\n// src/lib/plugins/html/utils/cleanHtmlFontElements.ts\nvar cleanHtmlFontElements = (rootNode) => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName === \"FONT\") {\n      if (element.textContent) {\n        replaceTagName(element, \"span\");\n      } else {\n        element.remove();\n      }\n    }\n    return true;\n  });\n};\n\n// src/lib/plugins/html/utils/isHtmlFragmentHref.ts\nvar isHtmlFragmentHref = (href) => href.startsWith(\"#\");\n\n// src/lib/plugins/html/utils/unwrapHtmlElement.ts\nvar unwrapHtmlElement = (element) => {\n  element.outerHTML = element.innerHTML;\n};\n\n// src/lib/plugins/html/utils/cleanHtmlLinkElements.ts\nvar cleanHtmlLinkElements = (rootNode) => {\n  traverseHtmlElements(rootNode, (element) => {\n    if (element.tagName !== \"A\") {\n      return true;\n    }\n    const href = element.getAttribute(\"href\");\n    if (!href || isHtmlFragmentHref(href)) {\n      unwrapHtmlElement(element);\n    }\n    if (href && element.querySelector(\"img\")) {\n      for (const span of element.querySelectorAll(\"span\")) {\n        if (!span.textContent) {\n          unwrapHtmlElement(span);\n        }\n      }\n    }\n    return true;\n  });\n};\n\n// src/lib/plugins/html/utils/isHtmlText.ts\nvar isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;\n\n// src/lib/plugins/html/utils/traverseHtmlTexts.ts\nvar traverseHtmlTexts = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlText(node)) {\n      return true;\n    }\n    return callback(node);\n  });\n};\n\n// src/lib/plugins/html/utils/cleanHtmlTextNodes.ts\nvar cleanHtmlTextNodes = (rootNode) => {\n  traverseHtmlTexts(rootNode, (textNode) => {\n    if (/^\\n\\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {\n      textNode.remove();\n      return true;\n    }\n    textNode.data = textNode.data.replaceAll(/\\n\\s*/g, \"\\n\");\n    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {\n      const hasSpace = textNode.data.includes(SPACE);\n      const hasNonWhitespace = /\\S/.test(textNode.data);\n      const hasLineFeed = textNode.data.includes(LINE_FEED);\n      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {\n        if (textNode.data === NO_BREAK_SPACE) {\n          textNode.data = SPACE;\n          return true;\n        }\n        textNode.remove();\n        return true;\n      }\n      if (textNode.previousSibling && textNode.previousSibling.nodeName === \"BR\" && textNode.parentElement) {\n        textNode.previousSibling.remove();\n        const matches = /^[\\n\\r]+/.exec(textNode.data);\n        const offset = matches ? matches[0].length : 0;\n        textNode.data = textNode.data.slice(Math.max(0, offset)).replaceAll(new RegExp(LINE_FEED, \"g\"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, \"g\"), SPACE);\n        textNode.data = `\n${textNode.data}`;\n      } else {\n        textNode.data = textNode.data.replaceAll(new RegExp(LINE_FEED, \"g\"), SPACE).replaceAll(new RegExp(CARRIAGE_RETURN, \"g\"), SPACE);\n      }\n    }\n    return true;\n  });\n};\n\n// src/lib/plugins/html/utils/inlineTagNames.ts\nvar inlineTagNames = /* @__PURE__ */ new Set([\n  \"A\",\n  \"ABBR\",\n  \"ACRONYM\",\n  \"B\",\n  \"BDI\",\n  \"BDO\",\n  \"BIG\",\n  \"BR\",\n  \"BUTTON\",\n  \"CANVAS\",\n  \"CITE\",\n  \"CODE\",\n  \"CONTENT\",\n  \"DATA\",\n  \"DEL\",\n  \"DFN\",\n  \"EM\",\n  \"EMBED\",\n  \"FONT\",\n  \"I\",\n  \"IFRAME\",\n  \"IMG\",\n  \"IMG\",\n  \"INPUT\",\n  \"INS\",\n  \"KBD\",\n  \"LABEL\",\n  \"MAP\",\n  \"MARK\",\n  \"MARQUEE\",\n  \"MENUITEM\",\n  \"METER\",\n  \"NOBR\",\n  \"OBJECT\",\n  \"OUTPUT\",\n  \"PICTURE\",\n  \"PORTAL\",\n  \"PROGRESS\",\n  \"Q\",\n  \"S\",\n  \"SAMP\",\n  \"SELECT\",\n  \"SHADOW\",\n  \"SMALL\",\n  \"SOURCE\",\n  \"SPAN\",\n  \"STRIKE\",\n  \"STRONG\",\n  \"SUB\",\n  \"SUP\",\n  \"TEXTAREA\",\n  \"TIME\",\n  \"TRACK\",\n  \"TT\",\n  \"U\",\n  \"VAR\",\n  \"VIDEO\",\n  \"WBR\",\n  \"math\",\n  \"svg\"\n]);\n\n// src/lib/plugins/html/utils/isHtmlInlineElement.ts\nvar isHtmlInlineElement = (node) => {\n  if (!isHtmlElement(node)) return false;\n  const element = node;\n  const tagNameIsInline = inlineTagNames.has(element.tagName);\n  const displayProperty = element.style.display.split(\" \")[0];\n  if (displayProperty === \"\") {\n    return tagNameIsInline;\n  }\n  if (displayProperty.startsWith(\"inline\")) {\n    return true;\n  }\n  if (displayProperty === \"inherit\" && element.parentElement) {\n    return isHtmlInlineElement(element.parentElement);\n  }\n  if ([\"contents\", \"initial\", \"none\", \"revert\", \"revert-layer\", \"unset\"].includes(\n    displayProperty\n  )) {\n    return tagNameIsInline;\n  }\n  return false;\n};\n\n// src/lib/plugins/html/utils/isHtmlBlockElement.ts\nvar isHtmlBlockElement = (node) => {\n  if (!isHtmlElement(node)) return false;\n  const element = node;\n  return !isHtmlInlineElement(element);\n};\n\n// src/lib/plugins/html/utils/isHtmlTable.ts\nvar isHtmlTable = (element) => element.nodeName === \"TABLE\";\n\n// src/lib/plugins/html/utils/copyBlockMarksToSpanChild.ts\nvar copyBlockMarksToSpanChild = (rootNode) => {\n  traverseHtmlElements(rootNode, (element) => {\n    const el = element;\n    const styleAttribute = element.getAttribute(\"style\");\n    if (!styleAttribute) return true;\n    if (isHtmlBlockElement(el) && !isHtmlTable(el)) {\n      const {\n        style: {\n          backgroundColor,\n          color,\n          fontFamily,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          textDecoration\n        }\n      } = el;\n      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {\n        const span = document.createElement(\"span\");\n        if (![\"inherit\", \"initial\"].includes(color)) {\n          span.style.color = color;\n        }\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n        if (![\"inherit\", \"initial\", \"normal\"].includes(color)) {\n          span.style.fontStyle = fontStyle;\n        }\n        if (![400, \"normal\"].includes(fontWeight)) {\n          span.style.fontWeight = fontWeight;\n        }\n        span.style.textDecoration = textDecoration;\n        span.innerHTML = el.innerHTML;\n        element.innerHTML = span.outerHTML;\n      }\n    }\n    return true;\n  });\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseString.ts\nvar collapseString = (text, {\n  shouldCollapseWhiteSpace = true,\n  trimEnd = \"collapse\",\n  trimStart = \"collapse\",\n  whiteSpaceIncludesNewlines = true\n} = {}) => {\n  if (trimStart === \"all\") {\n    text = text.replace(/^\\s+/, \"\");\n  }\n  if (trimEnd === \"single-newline\") {\n    text = text.replace(/\\n$/, \"\");\n  }\n  if (shouldCollapseWhiteSpace) {\n    if (whiteSpaceIncludesNewlines) {\n      text = text.replaceAll(/\\s+/g, \" \");\n    } else {\n      text = text.replaceAll(/[^\\S\\n\\r]+/g, \" \");\n      text = text.replaceAll(/^[^\\S\\n\\r]+/gm, \"\");\n      text = text.replaceAll(/[^\\S\\n\\r]+$/gm, \"\");\n    }\n  }\n  return text;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/isLastNonEmptyTextOfInlineFormattingContext.ts\nvar isLastNonEmptyTextOfInlineFormattingContext = (initialText) => {\n  let currentNode = initialText;\n  while (true) {\n    if (currentNode.nextSibling) {\n      currentNode = currentNode.nextSibling;\n    } else {\n      currentNode = currentNode.parentElement;\n      if (currentNode && isHtmlBlockElement(currentNode)) {\n        return true;\n      }\n      currentNode = (currentNode == null ? void 0 : currentNode.nextSibling) || null;\n    }\n    if (!currentNode) {\n      return true;\n    }\n    if (isHtmlBlockElement(currentNode)) {\n      return true;\n    }\n    if ((currentNode.textContent || \"\").length > 0) {\n      return false;\n    }\n  }\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/stateTransforms.ts\nvar upsertInlineFormattingContext = (state) => {\n  if (state.inlineFormattingContext) {\n    state.inlineFormattingContext.atStart = false;\n  } else {\n    state.inlineFormattingContext = {\n      atStart: true,\n      lastHasTrailingWhiteSpace: false\n    };\n  }\n};\nvar endInlineFormattingContext = (state) => {\n  state.inlineFormattingContext = null;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceText.ts\nvar collapseWhiteSpaceText = (text, state) => {\n  const textContent = text.textContent || \"\";\n  const isWhiteSpaceOnly = textContent.trim() === \"\";\n  if (state.inlineFormattingContext || !isWhiteSpaceOnly) {\n    upsertInlineFormattingContext(state);\n  }\n  const { whiteSpaceRule } = state;\n  const trimStart = (() => {\n    if (whiteSpaceRule !== \"normal\") return \"collapse\";\n    if (!state.inlineFormattingContext || state.inlineFormattingContext.atStart || state.inlineFormattingContext.lastHasTrailingWhiteSpace)\n      return \"all\";\n    return \"collapse\";\n  })();\n  const trimEnd = (() => {\n    if (whiteSpaceRule === \"normal\") return \"collapse\";\n    if (isLastNonEmptyTextOfInlineFormattingContext(text))\n      return \"single-newline\";\n    return \"collapse\";\n  })();\n  const shouldCollapseWhiteSpace = {\n    normal: true,\n    pre: false,\n    \"pre-line\": true\n  }[whiteSpaceRule];\n  const whiteSpaceIncludesNewlines = whiteSpaceRule !== \"pre-line\";\n  const collapsedTextContent = collapseString(textContent || \"\", {\n    shouldCollapseWhiteSpace,\n    trimEnd,\n    trimStart,\n    whiteSpaceIncludesNewlines\n  });\n  if (state.inlineFormattingContext && shouldCollapseWhiteSpace) {\n    state.inlineFormattingContext.lastHasTrailingWhiteSpace = collapsedTextContent.endsWith(\" \");\n  }\n  text.textContent = collapsedTextContent;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceNode.ts\nvar collapseWhiteSpaceNode = (node, state) => {\n  if (isHtmlElement(node)) {\n    collapseWhiteSpaceElement(node, state);\n    return;\n  }\n  if (isHtmlText(node)) {\n    collapseWhiteSpaceText(node, state);\n    return;\n  }\n  collapseWhiteSpaceChildren(node, state);\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceChildren.ts\nvar collapseWhiteSpaceChildren = (node, state) => {\n  const childNodes = Array.from(node.childNodes);\n  for (const childNode of childNodes) {\n    collapseWhiteSpaceNode(childNode, state);\n  }\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/inferWhiteSpaceRule.ts\nvar inferWhiteSpaceRule = (element) => {\n  const whiteSpaceProperty = element.style.whiteSpace;\n  switch (whiteSpaceProperty) {\n    case \"break-spaces\":\n    case \"pre\":\n    case \"pre-wrap\": {\n      return \"pre\";\n    }\n    case \"normal\":\n    case \"nowrap\": {\n      return \"normal\";\n    }\n    case \"pre-line\": {\n      return \"pre-line\";\n    }\n  }\n  if (element.tagName === \"PRE\") {\n    return \"pre\";\n  }\n  if (whiteSpaceProperty === \"initial\") {\n    return \"normal\";\n  }\n  return null;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpaceElement.ts\nvar collapseWhiteSpaceElement = (element, state) => {\n  const isInlineElement = isHtmlInlineElement(element);\n  const previousWhiteSpaceRule = state.whiteSpaceRule;\n  const inferredWhiteSpaceRule = inferWhiteSpaceRule(element);\n  if (inferredWhiteSpaceRule) {\n    state.whiteSpaceRule = inferredWhiteSpaceRule;\n  }\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n  collapseWhiteSpaceChildren(element, state);\n  if (!isInlineElement) {\n    endInlineFormattingContext(state);\n  }\n  state.whiteSpaceRule = previousWhiteSpaceRule;\n};\n\n// src/lib/plugins/html/utils/collapse-white-space/collapseWhiteSpace.ts\nvar collapseWhiteSpace = (element) => {\n  const clonedElement = element.cloneNode(true);\n  const state = {\n    inlineFormattingContext: null,\n    whiteSpaceRule: \"normal\"\n  };\n  collapseWhiteSpaceElement(clonedElement, state);\n  return clonedElement;\n};\n\n// src/lib/plugins/html/utils/htmlBodyToFragment.ts\nimport { jsx } from \"slate-hyperscript\";\n\n// src/lib/plugins/html/utils/deserializeHtmlNodeChildren.ts\nvar deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).flatMap(\n  deserializeHtmlNode(editor)\n);\n\n// src/lib/plugins/html/utils/htmlBodyToFragment.ts\nvar htmlBodyToFragment = (editor, element) => {\n  if (element.nodeName === \"BODY\") {\n    return jsx(\n      \"fragment\",\n      {},\n      deserializeHtmlNodeChildren(editor, element)\n    );\n  }\n};\n\n// src/lib/plugins/html/utils/htmlBrToNewLine.ts\nvar htmlBrToNewLine = (node) => {\n  if (node.nodeName === \"BR\") {\n    return \"\\n\";\n  }\n};\n\n// src/lib/plugins/html/utils/htmlElementToElement.ts\nimport { jsx as jsx2 } from \"slate-hyperscript\";\n\n// src/lib/plugins/html/utils/pluginDeserializeHtml.ts\nimport { isDefined } from \"@udecode/utils\";\nimport castArray from \"lodash/castArray.js\";\nvar pluginDeserializeHtml = (editor, plugin, {\n  deserializeLeaf,\n  element: el\n}) => {\n  var _a, _b;\n  const {\n    node: { isElement: isElementRoot, isLeaf: isLeafRoot, type },\n    parsers\n  } = plugin;\n  const deserializer = (_a = parsers == null ? void 0 : parsers.html) == null ? void 0 : _a.deserializer;\n  if (!deserializer) return;\n  const {\n    attributeNames,\n    isElement: isElementRule,\n    isLeaf: isLeafRule,\n    query,\n    rules\n  } = deserializer;\n  let { parse } = deserializer;\n  const isElement4 = isElementRule || isElementRoot;\n  const isLeaf = isLeafRule || isLeafRoot;\n  if (!deserializeLeaf && !isElement4) {\n    return;\n  }\n  if (deserializeLeaf && !isLeaf) {\n    return;\n  }\n  if (rules) {\n    const isValid = rules.some(\n      ({ validAttribute, validClassName, validNodeName = \"*\", validStyle }) => {\n        var _a2;\n        if (validNodeName) {\n          const validNodeNames = castArray(validNodeName);\n          if (validNodeNames.length > 0 && !validNodeNames.includes(el.nodeName) && validNodeName !== \"*\")\n            return false;\n        }\n        if (validClassName && !el.classList.contains(validClassName))\n          return false;\n        if (validStyle) {\n          for (const [key, value] of Object.entries(validStyle)) {\n            const values = castArray(value);\n            if (!values.includes(el.style[key]) && value !== \"*\")\n              return;\n            if (value === \"*\" && !el.style[key]) return;\n            const defaultNodeValue = (_a2 = plugin.inject.nodeProps) == null ? void 0 : _a2.defaultNodeValue;\n            if (defaultNodeValue && defaultNodeValue === el.style[key]) {\n              return false;\n            }\n          }\n        }\n        if (validAttribute) {\n          if (typeof validAttribute === \"string\") {\n            if (!el.getAttributeNames().includes(validAttribute)) return false;\n          } else {\n            for (const [attributeName, attributeValue] of Object.entries(\n              validAttribute\n            )) {\n              const attributeValues = castArray(attributeValue);\n              const elAttribute = el.getAttribute(attributeName);\n              if (!isDefined(elAttribute) || !attributeValues.includes(elAttribute))\n                return false;\n            }\n          }\n        }\n        return true;\n      }\n    );\n    if (!isValid) return;\n  }\n  if (query && !query(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), { element: el }))) {\n    return;\n  }\n  if (!parse) {\n    if (isElement4) {\n      parse = () => ({ type });\n    } else if (isLeaf) {\n      parse = () => ({ [type]: true });\n    } else {\n      return;\n    }\n  }\n  let node = (_b = parse(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n    element: el,\n    node: {}\n  }))) != null ? _b : {};\n  if (Object.keys(node).length === 0) return;\n  const injectedPlugins = getInjectedPlugins(editor, plugin);\n  injectedPlugins.forEach((injectedPlugin) => {\n    var _a2, _b2, _c, _d;\n    const res = (_d = (_c = (_b2 = (_a2 = injectedPlugin.parsers) == null ? void 0 : _a2.html) == null ? void 0 : _b2.deserializer) == null ? void 0 : _c.parse) == null ? void 0 : _d.call(_c, __spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n      element: el,\n      node\n    }));\n    if (res) {\n      node = __spreadValues(__spreadValues({}, node), res);\n    }\n  });\n  if (attributeNames) {\n    const elementAttributes = {};\n    const elementAttributeNames = el.getAttributeNames();\n    for (const elementAttributeName of elementAttributeNames) {\n      if (attributeNames.includes(elementAttributeName)) {\n        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);\n      }\n    }\n    if (Object.keys(elementAttributes).length > 0) {\n      node.attributes = elementAttributes;\n    }\n  }\n  return __spreadProps(__spreadValues({}, deserializer), { node });\n};\n\n// src/lib/plugins/html/utils/pipeDeserializeHtmlElement.ts\nvar pipeDeserializeHtmlElement = (editor, element) => {\n  let result;\n  [...editor.pluginList].reverse().some((plugin) => {\n    result = pluginDeserializeHtml(editor, plugin, { element });\n    return !!result;\n  });\n  return result;\n};\n\n// src/lib/plugins/html/utils/htmlElementToElement.ts\nvar htmlElementToElement = (editor, element) => {\n  var _a;\n  const deserialized = pipeDeserializeHtmlElement(editor, element);\n  if (deserialized) {\n    const { node, withoutChildren } = deserialized;\n    let descendants = (_a = node.children) != null ? _a : deserializeHtmlNodeChildren(editor, element);\n    if (descendants.length === 0 || withoutChildren) {\n      descendants = [{ text: \"\" }];\n    }\n    return jsx2(\"element\", node, descendants);\n  }\n};\n\n// src/lib/plugins/html/utils/htmlElementToLeaf.ts\nimport { isElement as isElement2, isText } from \"@udecode/slate\";\nimport { jsx as jsx3 } from \"slate-hyperscript\";\n\n// src/lib/plugins/html/utils/pipeDeserializeHtmlLeaf.ts\nvar pipeDeserializeHtmlLeaf = (editor, element) => {\n  let node = {};\n  [...editor.pluginList].reverse().forEach((plugin) => {\n    const deserialized = pluginDeserializeHtml(editor, plugin, {\n      deserializeLeaf: true,\n      element\n    });\n    if (!deserialized) return;\n    node = __spreadValues(__spreadValues({}, node), deserialized.node);\n  });\n  return node;\n};\n\n// src/lib/plugins/html/utils/htmlElementToLeaf.ts\nvar htmlElementToLeaf = (editor, element) => {\n  const node = pipeDeserializeHtmlLeaf(editor, element);\n  return deserializeHtmlNodeChildren(editor, element).reduce(\n    (arr, child) => {\n      if (!child) return arr;\n      if (isElement2(child)) {\n        if (Object.keys(node).length > 0) {\n          mergeDeepToNodes({\n            node: child,\n            query: {\n              filter: ([n]) => isText(n)\n            },\n            source: node\n          });\n        }\n        arr.push(child);\n      } else {\n        const attributes = __spreadValues({}, node);\n        if (isText(child) && child.text) {\n          Object.keys(attributes).forEach((key) => {\n            if (attributes[key] && child[key]) {\n              attributes[key] = child[key];\n            }\n          });\n        }\n        arr.push(jsx3(\"text\", attributes, child));\n      }\n      return arr;\n    },\n    []\n  );\n};\n\n// src/lib/plugins/html/utils/htmlTextNodeToString.ts\nvar htmlTextNodeToString = (node) => {\n  if (isHtmlText(node)) {\n    return node.textContent || \"\";\n  }\n};\n\n// src/lib/plugins/html/utils/deserializeHtmlNode.ts\nvar deserializeHtmlNode = (editor) => (node) => {\n  const textNode = htmlTextNodeToString(node);\n  if (textNode) return textNode;\n  if (!isHtmlElement(node)) return null;\n  const breakLine = htmlBrToNewLine(node);\n  if (breakLine) return breakLine;\n  const fragment = htmlBodyToFragment(editor, node);\n  if (fragment) return fragment;\n  const element = htmlElementToElement(editor, node);\n  if (element) return element;\n  return htmlElementToLeaf(editor, node);\n};\n\n// src/lib/plugins/html/utils/deserializeHtmlElement.ts\nvar deserializeHtmlElement = (editor, element) => {\n  return deserializeHtmlNode(editor)(element);\n};\n\n// src/lib/plugins/html/utils/htmlStringToDOMNode.ts\nvar htmlStringToDOMNode = (rawHtml) => {\n  const node = document.createElement(\"body\");\n  node.innerHTML = rawHtml;\n  return node;\n};\n\n// src/lib/plugins/html/utils/deserializeHtml.ts\nvar deserializeHtml = (editor, {\n  collapseWhiteSpace: shouldCollapseWhiteSpace = true,\n  element\n}) => {\n  if (typeof element === \"string\") {\n    element = htmlStringToDOMNode(element);\n  }\n  if (shouldCollapseWhiteSpace) {\n    element = collapseWhiteSpace(element);\n  }\n  const fragment = deserializeHtmlElement(editor, element);\n  return normalizeDescendantsToDocumentFragment(editor, {\n    descendants: fragment\n  });\n};\n\n// src/lib/plugins/html/utils/findHtmlElement.ts\nvar findHtmlElement = (rootNode, predicate) => {\n  let res = null;\n  traverseHtmlElements(rootNode, (node) => {\n    if (predicate(node)) {\n      res = node;\n      return false;\n    }\n    return true;\n  });\n  return res;\n};\nvar someHtmlElement = (rootNode, predicate) => {\n  return !!findHtmlElement(rootNode, predicate);\n};\n\n// src/lib/plugins/html/utils/getHtmlComments.ts\nvar acceptNode = () => NodeFilter.FILTER_ACCEPT;\nvar getHtmlComments = (node) => {\n  const comments = [];\n  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {\n    acceptNode\n  });\n  let currentNode = iterator.nextNode();\n  while (currentNode) {\n    if (currentNode.nodeValue) {\n      comments.push(currentNode.nodeValue);\n    }\n    currentNode = iterator.nextNode();\n  }\n  return comments;\n};\n\n// src/lib/plugins/html/utils/isHtmlComment.ts\nvar isHtmlComment = (node) => node.nodeType === Node.COMMENT_NODE;\n\n// src/lib/plugins/html/utils/isOlSymbol.ts\nvar isOlSymbol = (symbol) => {\n  return /[\\da-np-z]\\S/.test(symbol.toLowerCase());\n};\n\n// src/lib/plugins/html/utils/parseHtmlDocument.ts\nvar parseHtmlDocument = (html) => {\n  return new DOMParser().parseFromString(html, \"text/html\");\n};\n\n// src/lib/plugins/html/utils/parseHtmlElement.ts\nvar parseHtmlElement = (html) => {\n  const { body } = parseHtmlDocument(html);\n  return body.firstElementChild;\n};\n\n// src/lib/plugins/html/utils/postCleanHtml.ts\nvar postCleanHtml = (html) => {\n  const cleanHtml = html.trim().replaceAll(new RegExp(ZERO_WIDTH_SPACE, \"g\"), \"\");\n  return `<body>${cleanHtml}</body>`;\n};\n\n// src/lib/plugins/html/utils/removeHtmlSurroundings.ts\nvar removeBeforeHtml = (html) => {\n  const index = html.indexOf(\"<html\");\n  if (index === -1) {\n    return html;\n  }\n  return html.slice(Math.max(0, index));\n};\nvar removeAfterHtml = (html) => {\n  const index = html.lastIndexOf(\"</html>\");\n  if (index === -1) {\n    return html;\n  }\n  return html.slice(0, Math.max(0, index + \"</html>\".length));\n};\nvar removeHtmlSurroundings = (html) => {\n  return removeBeforeHtml(removeAfterHtml(html));\n};\n\n// src/lib/plugins/html/utils/preCleanHtml.ts\nvar cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];\nvar preCleanHtml = (html) => {\n  return cleaners.reduce((result, clean) => clean(result), html);\n};\n\n// src/lib/plugins/html/utils/traverseHtmlComments.ts\nvar traverseHtmlComments = (rootNode, callback) => {\n  traverseHtmlNode(rootNode, (node) => {\n    if (!isHtmlComment(node)) {\n      return true;\n    }\n    return callback(node);\n  });\n};\n\n// src/lib/plugins/html/utils/removeHtmlNodesBetweenComments.ts\nvar removeHtmlNodesBetweenComments = (rootNode, start, end) => {\n  const isClosingComment = (node) => isHtmlComment(node) && node.data === end;\n  traverseHtmlComments(rootNode, (comment) => {\n    if (comment.data === start) {\n      let node = comment.nextSibling;\n      comment.remove();\n      while (node && !isClosingComment(node)) {\n        const { nextSibling } = node;\n        node.remove();\n        node = nextSibling;\n      }\n      if (node && isClosingComment(node)) {\n        node.remove();\n      }\n    }\n    return true;\n  });\n};\n\n// src/lib/plugins/html/HtmlPlugin.ts\nvar HtmlPlugin = createSlatePlugin({\n  key: \"html\"\n}).extendApi(({ editor }) => ({\n  deserialize: bindFirst2(deserializeHtml, editor)\n})).extend({\n  parser: {\n    deserialize: ({ api, data }) => {\n      const document2 = parseHtmlDocument(data);\n      return api.html.deserialize({\n        element: document2.body\n      });\n    },\n    format: \"text/html\"\n  }\n});\n\n// src/lib/plugins/length/LengthPlugin.ts\nimport { getEditorString, withoutNormalizing } from \"@udecode/slate\";\nvar withLength = ({\n  editor,\n  getOptions\n}) => {\n  const { apply } = editor;\n  editor.apply = (operation) => {\n    withoutNormalizing(editor, () => {\n      apply(operation);\n      const options = getOptions();\n      if (options.maxLength) {\n        const length = getEditorString(editor, []).length;\n        if (length > options.maxLength) {\n          const overflowLength = length - options.maxLength;\n          editor.delete({\n            distance: overflowLength,\n            reverse: true,\n            unit: \"character\"\n          });\n        }\n      }\n    });\n  };\n  return editor;\n};\nvar LengthPlugin = createTSlatePlugin({\n  key: \"length\",\n  extendEditor: withLength\n});\n\n// src/lib/plugins/getCorePlugins.ts\nvar getCorePlugins = ({\n  maxLength,\n  plugins = []\n}) => {\n  let corePlugins = [\n    DebugPlugin,\n    SlateNextPlugin,\n    DOMPlugin,\n    HistoryPlugin,\n    InlineVoidPlugin,\n    ParserPlugin,\n    maxLength ? LengthPlugin.configure({\n      options: { maxLength }\n    }) : LengthPlugin,\n    HtmlPlugin,\n    AstPlugin,\n    BaseParagraphPlugin\n  ];\n  const customPluginsMap = new Map(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n  corePlugins = corePlugins.map((corePlugin) => {\n    const customPlugin = customPluginsMap.get(corePlugin.key);\n    if (customPlugin) {\n      const index = plugins.findIndex((p) => p.key === corePlugin.key);\n      if (index !== -1) {\n        plugins.splice(index, 1);\n      }\n      return customPlugin;\n    }\n    return corePlugin;\n  });\n  return corePlugins;\n};\n\n// src/lib/utils/normalizeDescendantsToDocumentFragment.ts\nvar isInlineNode = (editor) => (node) => isText2(node) || isElement3(node) && editor.isInline(node);\nvar makeBlockLazy = (type) => () => ({\n  children: [],\n  type\n});\nvar hasDifferentChildNodes = (descendants, isInline) => {\n  return descendants.some((descendant, index, arr) => {\n    const prevDescendant = arr[index - 1];\n    if (index !== 0) {\n      return isInline(descendant) !== isInline(prevDescendant);\n    }\n    return false;\n  });\n};\nvar normalizeDifferentNodeTypes = (descendants, isInline, makeDefaultBlock) => {\n  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline);\n  const { fragment } = descendants.reduce(\n    (memo, node) => {\n      if (hasDifferentNodes && isInline(node)) {\n        let block = memo.precedingBlock;\n        if (!block) {\n          block = makeDefaultBlock();\n          memo.precedingBlock = block;\n          memo.fragment.push(block);\n        }\n        block.children.push(node);\n      } else {\n        memo.fragment.push(node);\n        memo.precedingBlock = null;\n      }\n      return memo;\n    },\n    {\n      fragment: [],\n      precedingBlock: null\n    }\n  );\n  return fragment;\n};\nvar normalizeEmptyChildren = (descendants) => {\n  if (descendants.length === 0) {\n    return [{ text: \"\" }];\n  }\n  return descendants;\n};\nvar normalize = (descendants, isInline, makeDefaultBlock) => {\n  descendants = normalizeEmptyChildren(descendants);\n  descendants = normalizeDifferentNodeTypes(\n    descendants,\n    isInline,\n    makeDefaultBlock\n  );\n  descendants = descendants.map((node) => {\n    if (isElement3(node)) {\n      return __spreadProps(__spreadValues({}, node), {\n        children: normalize(\n          node.children,\n          isInline,\n          makeDefaultBlock\n        )\n      });\n    }\n    return node;\n  });\n  return descendants;\n};\nvar normalizeDescendantsToDocumentFragment = (editor, { descendants }) => {\n  const isInline = isInlineNode(editor);\n  const defaultType = editor.getType(BaseParagraphPlugin);\n  const makeDefaultBlock = makeBlockLazy(defaultType);\n  return normalize(descendants, isInline, makeDefaultBlock);\n};\n\n// src/lib/utils/overridePluginsByKey.ts\nimport defaultsDeep from \"lodash/defaultsDeep.js\";\nvar overridePluginsByKey = (plugin, overrideByKey = {}, nested = false) => {\n  if (overrideByKey[plugin.key]) {\n    const _a = overrideByKey[plugin.key], {\n      __extensions: pluginOverridesExtensions,\n      plugins: pluginOverridesPlugins\n    } = _a, pluginOverrides = __objRest(_a, [\n      \"__extensions\",\n      \"plugins\"\n    ]);\n    plugin = defaultsDeep({}, pluginOverrides, plugin);\n    if (pluginOverridesExtensions) {\n      plugin.__extensions = [\n        ...plugin.__extensions || [],\n        ...pluginOverridesExtensions\n      ];\n    }\n    if (!nested) {\n      pluginOverridesPlugins == null ? void 0 : pluginOverridesPlugins.forEach((pOverrides) => {\n        if (!plugin.plugins) plugin.plugins = [];\n        const found = plugin.plugins.find((p) => p.key === pOverrides.key);\n        if (!found) plugin.plugins.push(pOverrides);\n      });\n    }\n  }\n  if (plugin.plugins) {\n    plugin.plugins = plugin.plugins.map(\n      (p) => overridePluginsByKey(p, overrideByKey, true)\n    );\n  }\n  return plugin;\n};\n\n// src/lib/utils/pipeInsertDataQuery.ts\nvar pipeInsertDataQuery = (editor, plugins, { data, dataTransfer }) => plugins.every((p) => {\n  var _a;\n  const query = (_a = p.parser) == null ? void 0 : _a.query;\n  return !query || query(__spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n    data,\n    dataTransfer\n  }));\n});\n\n// src/lib/utils/pipeInsertFragment.ts\nimport { withoutNormalizing as withoutNormalizing2 } from \"@udecode/slate\";\nvar pipeInsertFragment = (editor, injectedPlugins, _a) => {\n  var _b = _a, { fragment } = _b, options = __objRest(_b, [\"fragment\"]);\n  withoutNormalizing2(editor, () => {\n    injectedPlugins.some((p) => {\n      var _a2, _b2;\n      return ((_b2 = (_a2 = p.parser) == null ? void 0 : _a2.preInsert) == null ? void 0 : _b2.call(_a2, __spreadValues(__spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n        fragment\n      }), options))) === true;\n    });\n    editor.insertFragment(fragment);\n  });\n};\n\n// src/lib/utils/pipeNormalizeInitialValue.ts\nvar pipeNormalizeInitialValue = (editor) => {\n  editor.pluginList.forEach((p) => {\n    var _a;\n    const normalizedValue = (_a = p.normalizeInitialValue) == null ? void 0 : _a.call(p, __spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n      value: editor.children\n    }));\n    if (normalizedValue) {\n      editor.children = normalizedValue;\n    }\n  });\n};\n\n// src/lib/utils/pipeTransformData.ts\nvar pipeTransformData = (editor, plugins, { data, dataTransfer }) => {\n  plugins.forEach((p) => {\n    var _a;\n    const transformData = (_a = p.parser) == null ? void 0 : _a.transformData;\n    if (!transformData) return;\n    data = transformData(__spreadProps(__spreadValues({}, getEditorPlugin(editor, p)), {\n      data,\n      dataTransfer\n    }));\n  });\n  return data;\n};\n\n// src/lib/utils/pipeTransformFragment.ts\nvar pipeTransformFragment = (editor, plugins, _a) => {\n  var _b = _a, { fragment } = _b, options = __objRest(_b, [\"fragment\"]);\n  plugins.forEach((p) => {\n    var _a2;\n    const transformFragment = (_a2 = p.parser) == null ? void 0 : _a2.transformFragment;\n    if (!transformFragment) return;\n    fragment = transformFragment(__spreadValues(__spreadValues({\n      fragment\n    }, options), getEditorPlugin(editor, p)));\n  });\n  return fragment;\n};\n\n// src/lib/utils/resolvePlugin.ts\nimport merge2 from \"lodash/merge.js\";\nvar resolvePlugin = (editor, _plugin) => {\n  var _a, _b, _c, _d;\n  let plugin = mergePlugins({}, _plugin);\n  plugin.__resolved = true;\n  if (plugin.__configuration) {\n    const configResult = plugin.__configuration(\n      getEditorPlugin(editor, plugin)\n    );\n    plugin = mergePlugins(plugin, configResult);\n    delete plugin.__configuration;\n  }\n  if (plugin.__extensions && plugin.__extensions.length > 0) {\n    plugin.__extensions.forEach((extension) => {\n      plugin = mergePlugins(\n        plugin,\n        extension(getEditorPlugin(editor, plugin))\n      );\n    });\n    plugin.__extensions = [];\n  }\n  const targetPluginToInject = (_a = plugin.inject) == null ? void 0 : _a.targetPluginToInject;\n  const targetPlugins = (_b = plugin.inject) == null ? void 0 : _b.targetPlugins;\n  if (targetPluginToInject && targetPlugins && targetPlugins.length > 0) {\n    plugin.inject = plugin.inject || {};\n    plugin.inject.plugins = merge2(\n      {},\n      plugin.inject.plugins,\n      Object.fromEntries(\n        targetPlugins.map((targetPlugin) => {\n          const injectedPlugin = targetPluginToInject(__spreadProps(__spreadValues({}, getEditorPlugin(editor, plugin)), {\n            targetPlugin\n          }));\n          return [targetPlugin, injectedPlugin];\n        })\n      )\n    );\n  }\n  if ((_c = plugin.node) == null ? void 0 : _c.component) {\n    plugin.render.node = plugin.node.component;\n  }\n  if ((_d = plugin.render) == null ? void 0 : _d.node) {\n    plugin.node.component = plugin.render.node;\n  }\n  validatePlugin(editor, plugin);\n  return plugin;\n};\nvar validatePlugin = (editor, plugin) => {\n  if (!plugin.__extensions) {\n    editor.api.debug.error(\n      `Invalid plugin '${plugin.key}', you should use createSlatePlugin.`,\n      \"USE_CREATE_PLUGIN\"\n    );\n  }\n  if (plugin.node.isElement && plugin.node.isLeaf) {\n    editor.api.debug.error(\n      `Plugin ${plugin.key} cannot be both an element and a leaf.`,\n      \"PLUGIN_NODE_TYPE\"\n    );\n  }\n};\n\n// src/lib/utils/resolveCreatePluginTest.ts\nvar resolvePluginTest = (p) => {\n  const editor = createSlateEditor({\n    plugins: [p]\n  });\n  let key = p.key;\n  if (!key) {\n    key = resolvePlugin(editor, p).key;\n  }\n  return editor.plugins[key];\n};\nvar resolveCreatePluginTest = (plugin) => {\n  const p = createSlatePlugin(plugin);\n  const editor = createSlateEditor({\n    plugins: [p]\n  });\n  let key = p.key;\n  if (!key) {\n    key = resolvePlugin(editor, p).key;\n  }\n  return editor.plugins[key];\n};\n\n// src/lib/utils/resolvePlugins.ts\nimport { isDefined as isDefined2 } from \"@udecode/utils\";\nimport merge3 from \"lodash/merge.js\";\nimport { createZustandStore } from \"zustand-x\";\nvar resolvePlugins = (editor, plugins = []) => {\n  editor.pluginList = [];\n  editor.plugins = {};\n  editor.api = {};\n  editor.transforms = {};\n  editor.tf = editor.transforms;\n  editor.shortcuts = {};\n  const resolvedPlugins = resolveAndSortPlugins(editor, plugins);\n  applyPluginsToEditor(editor, resolvedPlugins);\n  resolvePluginOverrides(editor);\n  resolvePluginStores(editor);\n  resolvePluginApis(editor);\n  editor.pluginList.forEach((plugin) => {\n    if (plugin.extendEditor) {\n      editor = plugin.extendEditor(getEditorPlugin(editor, plugin));\n    }\n  });\n  return editor;\n};\nvar resolvePluginStores = (editor) => {\n  editor.pluginList.forEach((plugin) => {\n    let store = createZustandStore(plugin.key)(plugin.options, {\n      immer: {\n        enableMapSet: true\n      }\n    });\n    if (plugin.__optionExtensions && plugin.__optionExtensions.length > 0) {\n      plugin.__optionExtensions.forEach((extension) => {\n        const extendedOptions = extension(getEditorPlugin(editor, plugin));\n        store = store.extendSelectors(() => extendedOptions);\n      });\n    }\n    plugin.optionsStore = store;\n  });\n};\nvar resolvePluginApis = (editor) => {\n  const shortcutsByPriority = [];\n  editor.pluginList.forEach((plugin) => {\n    Object.entries(plugin.api).forEach(([apiKey, apiFunction]) => {\n      editor.api[apiKey] = apiFunction;\n    });\n    if (plugin.__apiExtensions && plugin.__apiExtensions.length > 0) {\n      plugin.__apiExtensions.forEach(\n        ({ extension, isPluginSpecific, isTransform }) => {\n          const newExtensions = extension(\n            getEditorPlugin(editor, plugin)\n          );\n          if (isTransform) {\n            if (isPluginSpecific) {\n              if (!editor.transforms[plugin.key]) {\n                editor.transforms[plugin.key] = {};\n              }\n              if (!plugin.transforms[plugin.key]) {\n                plugin.transforms[plugin.key] = {};\n              }\n              merge3(editor.transforms[plugin.key], newExtensions);\n              merge3(plugin.transforms[plugin.key], newExtensions);\n            } else {\n              merge3(editor.transforms, newExtensions);\n              merge3(plugin.transforms, newExtensions);\n            }\n          } else {\n            if (isPluginSpecific) {\n              if (!editor.api[plugin.key]) {\n                editor.api[plugin.key] = {};\n              }\n              if (!plugin.api[plugin.key]) {\n                plugin.api[plugin.key] = {};\n              }\n              merge3(editor.api[plugin.key], newExtensions);\n              merge3(plugin.api[plugin.key], newExtensions);\n            } else {\n              merge3(editor.api, newExtensions);\n              merge3(plugin.api, newExtensions);\n            }\n          }\n        }\n      );\n      delete plugin.__apiExtensions;\n    }\n    Object.entries(plugin.shortcuts).forEach(([key, hotkey]) => {\n      var _a;\n      if (hotkey === null) {\n        const index = shortcutsByPriority.findIndex((item) => item.key === key);\n        if (index !== -1) {\n          shortcutsByPriority.splice(index, 1);\n        }\n      } else {\n        const priority = (_a = hotkey.priority) != null ? _a : plugin.priority;\n        const existingIndex = shortcutsByPriority.findIndex(\n          (item) => item.key === key\n        );\n        if (existingIndex === -1 || priority >= shortcutsByPriority[existingIndex].priority) {\n          if (existingIndex !== -1) {\n            shortcutsByPriority.splice(existingIndex, 1);\n          }\n          shortcutsByPriority.push({ key, hotkey, priority });\n        }\n      }\n    });\n  });\n  shortcutsByPriority.sort((a, b) => b.hotkey.priority - a.hotkey.priority);\n  editor.shortcuts = Object.fromEntries(\n    shortcutsByPriority.map(({ key, hotkey }) => {\n      const _a = hotkey, { priority } = _a, hotkeyWithoutPriority = __objRest(_a, [\"priority\"]);\n      return [key, hotkeyWithoutPriority];\n    })\n  );\n};\nvar flattenAndResolvePlugins = (editor, plugins) => {\n  const pluginMap = /* @__PURE__ */ new Map();\n  const processPlugin = (plugin) => {\n    const resolvedPlugin = resolvePlugin(editor, plugin);\n    const existingPlugin = pluginMap.get(resolvedPlugin.key);\n    if (existingPlugin) {\n      pluginMap.set(\n        resolvedPlugin.key,\n        mergePlugins(existingPlugin, resolvedPlugin)\n      );\n    } else {\n      pluginMap.set(resolvedPlugin.key, resolvedPlugin);\n    }\n    if (resolvedPlugin.plugins && resolvedPlugin.plugins.length > 0) {\n      resolvedPlugin.plugins.forEach(processPlugin);\n    }\n  };\n  plugins.forEach(processPlugin);\n  return pluginMap;\n};\nvar resolveAndSortPlugins = (editor, plugins) => {\n  const pluginMap = flattenAndResolvePlugins(editor, plugins);\n  const enabledPlugins = Array.from(pluginMap.values()).filter(\n    (plugin) => plugin.enabled !== false\n  );\n  enabledPlugins.sort((a, b) => b.priority - a.priority);\n  const orderedPlugins = [];\n  const visited = /* @__PURE__ */ new Set();\n  const visit = (plugin) => {\n    var _a;\n    if (visited.has(plugin.key)) return;\n    visited.add(plugin.key);\n    (_a = plugin.dependencies) == null ? void 0 : _a.forEach((depKey) => {\n      const depPlugin = pluginMap.get(depKey);\n      if (depPlugin) {\n        visit(depPlugin);\n      } else {\n        editor.api.debug.warn(\n          `Plugin \"${plugin.key}\" depends on missing plugin \"${depKey}\"`,\n          \"PLUGIN_DEPENDENCY_MISSING\"\n        );\n      }\n    });\n    orderedPlugins.push(plugin);\n  };\n  enabledPlugins.forEach(visit);\n  return orderedPlugins;\n};\nvar applyPluginsToEditor = (editor, plugins) => {\n  editor.pluginList = plugins;\n  editor.plugins = Object.fromEntries(\n    plugins.map((plugin) => [plugin.key, plugin])\n  );\n};\nvar resolvePluginOverrides = (editor) => {\n  const applyOverrides = (plugins) => {\n    let overriddenPlugins = [...plugins];\n    const enabledOverrides = {};\n    const componentOverrides = {};\n    const pluginOverrides = {};\n    for (const plugin of plugins) {\n      if (plugin.override.enabled) {\n        Object.assign(enabledOverrides, plugin.override.enabled);\n      }\n      if (plugin.override.components) {\n        Object.entries(plugin.override.components).forEach(\n          ([key, component]) => {\n            if (!componentOverrides[key] || plugin.priority > componentOverrides[key].priority) {\n              componentOverrides[key] = {\n                component,\n                priority: plugin.priority\n              };\n            }\n          }\n        );\n      }\n      if (plugin.override.plugins) {\n        Object.entries(plugin.override.plugins).forEach(([key, value]) => {\n          pluginOverrides[key] = mergePlugins(pluginOverrides[key], value);\n          if (value.enabled !== void 0) {\n            enabledOverrides[key] = value.enabled;\n          }\n        });\n      }\n    }\n    overriddenPlugins = overriddenPlugins.map((p) => {\n      var _a;\n      let updatedPlugin = __spreadValues({}, p);\n      if (pluginOverrides[p.key]) {\n        updatedPlugin = mergePlugins(updatedPlugin, pluginOverrides[p.key]);\n      }\n      if (componentOverrides[p.key] && (!p.render.node && !p.node.component || componentOverrides[p.key].priority > p.priority)) {\n        updatedPlugin.render.node = componentOverrides[p.key].component;\n        updatedPlugin.node.component = componentOverrides[p.key].component;\n      }\n      const enabled = (_a = enabledOverrides[p.key]) != null ? _a : updatedPlugin.enabled;\n      if (isDefined2(enabled)) {\n        updatedPlugin.enabled = enabled;\n      }\n      return updatedPlugin;\n    });\n    return overriddenPlugins.filter((p) => p.enabled !== false).map((plugin) => __spreadProps(__spreadValues({}, plugin), {\n      plugins: applyOverrides(plugin.plugins || [])\n    }));\n  };\n  editor.pluginList = applyOverrides(editor.pluginList);\n  editor.plugins = Object.fromEntries(\n    editor.pluginList.map((plugin) => [plugin.key, plugin])\n  );\n};\n\n// src/lib/utils/misc/callOrReturn.ts\nfunction callOrReturn(value, ...props) {\n  if (isFunction(value)) {\n    return value(...props);\n  }\n  return value;\n}\n\n// src/lib/utils/misc/getSlateClass.ts\nvar getSlateClass = (type) => type ? `slate-${type}` : \"\";\n\n// src/lib/utils/misc/mergeDeep.ts\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== \"Object\") {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = __spreadValues({}, target);\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      output[key] = isPlainObject(source[key]) && isPlainObject(target[key]) ? mergeDeep(target[key], source[key]) : source[key];\n    });\n  }\n  return output;\n}\n\n// src/lib/plugin/getSlatePlugin.ts\nfunction getSlatePlugin(editor, p) {\n  let plugin = p;\n  const editorPlugin = editor.plugins[p.key];\n  if (!editorPlugin) {\n    if (!plugin.node) {\n      plugin = createSlatePlugin(plugin);\n    }\n    return plugin.__resolved ? plugin : resolvePlugin(editor, plugin);\n  }\n  return editorPlugin;\n}\nfunction getPluginType(editor, plugin) {\n  var _a, _b;\n  const p = editor.getPlugin(plugin);\n  return (_b = (_a = p.node.type) != null ? _a : p.key) != null ? _b : \"\";\n}\nvar getPluginTypes = (editor, plugins) => plugins.map((plugin) => editor.getType(plugin));\n\n// src/lib/editor/withSlate.ts\nvar withSlate = (e, _a = {}) => {\n  var _b = _a, {\n    id,\n    autoSelect,\n    maxLength,\n    plugins = [],\n    rootPlugin,\n    selection,\n    shouldNormalizeEditor,\n    value\n  } = _b, pluginConfig = __objRest(_b, [\n    \"id\",\n    \"autoSelect\",\n    \"maxLength\",\n    \"plugins\",\n    \"rootPlugin\",\n    \"selection\",\n    \"shouldNormalizeEditor\",\n    \"value\"\n  ]);\n  var _a2, _b2;\n  const editor = e;\n  editor.id = id != null ? id : editor.id;\n  editor.key = (_a2 = editor.key) != null ? _a2 : nanoid();\n  editor.isFallback = false;\n  editor.getApi = () => editor.api;\n  editor.getTransforms = () => editor.transforms;\n  editor.getPlugin = (plugin) => getSlatePlugin(editor, plugin);\n  editor.getType = (plugin) => getPluginType(editor, plugin);\n  editor.getInjectProps = (plugin) => {\n    var _a3, _b3;\n    return (_b3 = (_a3 = editor.getPlugin(plugin).inject) == null ? void 0 : _a3.nodeProps) != null ? _b3 : {};\n  };\n  editor.getOptionsStore = (plugin) => {\n    return editor.getPlugin(plugin).optionsStore;\n  };\n  editor.getOptions = (plugin) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return editor.getPlugin(plugin).options;\n    return editor.getOptionsStore(plugin).get.state();\n  };\n  editor.getOption = (plugin, key, ...args) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return editor.getPlugin(plugin).options[key];\n    const getter = store.get[key];\n    if (getter) {\n      return getter(...args);\n    }\n    editor.api.debug.error(\n      `editor.getOption: ${key} option is not defined in plugin ${plugin.key}.`,\n      \"OPTION_UNDEFINED\"\n    );\n  };\n  editor.setOption = (plugin, key, value2) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return;\n    const setter = store.set[key];\n    if (setter) {\n      setter(value2);\n    } else {\n      editor.api.debug.error(\n        `editor.setOption: ${key} option is not defined in plugin ${plugin.key}.`,\n        \"OPTION_UNDEFINED\"\n      );\n    }\n  };\n  editor.setOptions = (plugin, options) => {\n    const store = editor.getOptionsStore(plugin);\n    if (!store) return;\n    if (typeof options === \"object\") {\n      store.set.mergeState(options);\n    } else if (typeof options === \"function\") {\n      store.set.state(options);\n    }\n  };\n  const corePlugins = getCorePlugins({\n    maxLength,\n    plugins\n  });\n  let rootPluginInstance = createSlatePlugin(__spreadProps(__spreadValues({\n    key: \"root\",\n    priority: 1e4\n  }, pluginConfig), {\n    plugins: [...corePlugins, ...plugins]\n  }));\n  if (rootPlugin) {\n    rootPluginInstance = rootPlugin(rootPluginInstance);\n  }\n  resolvePlugins(editor, [rootPluginInstance]);\n  if (typeof value === \"string\") {\n    editor.children = editor.api.html.deserialize({ element: value });\n  } else if (typeof value === \"function\") {\n    editor.children = value(editor);\n  } else if (value) {\n    editor.children = value;\n  }\n  if (!editor.children || ((_b2 = editor.children) == null ? void 0 : _b2.length) === 0) {\n    editor.children = editor.api.create.value();\n  }\n  if (selection) {\n    editor.selection = selection;\n  } else if (autoSelect) {\n    const edge = autoSelect === \"start\" ? \"start\" : \"end\";\n    const target = edge === \"start\" ? getStartPoint(editor, []) : getEndPoint(editor, []);\n    select(editor, target);\n  }\n  if (editor.children.length > 0) {\n    pipeNormalizeInitialValue(editor);\n  }\n  if (shouldNormalizeEditor) {\n    normalizeEditor(editor, { force: true });\n  }\n  return editor;\n};\nvar createSlateEditor = (_a = {}) => {\n  var _b = _a, {\n    editor = createTEditor()\n  } = _b, options = __objRest(_b, [\n    \"editor\"\n  ]);\n  return withSlate(editor, options);\n};\n\n// src/lib/libs/nanoid.ts\nimport { nanoid as nanoid2 } from \"nanoid\";\n\n// src/lib/libs/zustand.ts\nimport { createZustandStore as createZustandStore2 } from \"zustand-x\";\nexport {\n  AstPlugin,\n  BaseParagraphPlugin,\n  CARRIAGE_RETURN,\n  DOMPlugin,\n  DebugPlugin,\n  HistoryPlugin,\n  Hotkeys,\n  HtmlPlugin,\n  InlineVoidPlugin,\n  LINE_FEED,\n  LengthPlugin,\n  NO_BREAK_SPACE,\n  ParserPlugin,\n  PlateError,\n  SPACE,\n  SlateNextPlugin,\n  TAB,\n  ZERO_WIDTH_SPACE,\n  applyDeepToNodes,\n  applyPluginsToEditor,\n  callOrReturn,\n  cleanHtmlBrElements,\n  cleanHtmlCrLf,\n  cleanHtmlEmptyElements,\n  cleanHtmlFontElements,\n  cleanHtmlLinkElements,\n  cleanHtmlTextNodes,\n  collapseString,\n  collapseWhiteSpace,\n  collapseWhiteSpaceChildren,\n  collapseWhiteSpaceElement,\n  collapseWhiteSpaceNode,\n  collapseWhiteSpaceText,\n  copyBlockMarksToSpanChild,\n  createHotkey,\n  createSlateEditor,\n  createSlatePlugin,\n  createTSlatePlugin,\n  createZustandStore2 as createZustandStore,\n  deserializeHtml,\n  deserializeHtmlElement,\n  deserializeHtmlNode,\n  deserializeHtmlNodeChildren,\n  endInlineFormattingContext,\n  findHtmlElement,\n  getCorePlugins,\n  getEditorPlugin,\n  getHtmlComments,\n  getInjectMatch,\n  getInjectedPlugins,\n  getKeyByType,\n  getKeysByTypes,\n  getPluginType,\n  getPluginTypes,\n  getSlateClass,\n  getSlatePlugin,\n  htmlBodyToFragment,\n  htmlBrToNewLine,\n  htmlElementToElement,\n  htmlElementToLeaf,\n  htmlStringToDOMNode,\n  htmlTextNodeToString,\n  inferWhiteSpaceRule,\n  inlineTagNames,\n  isFunction,\n  isHotkey,\n  isHtmlBlockElement,\n  isHtmlComment,\n  isHtmlElement,\n  isHtmlFragmentHref,\n  isHtmlInlineElement,\n  isHtmlTable,\n  isHtmlText,\n  isLastNonEmptyTextOfInlineFormattingContext,\n  isOlSymbol,\n  mergeDeep,\n  mergeDeepToNodes,\n  nanoid2 as nanoid,\n  normalizeDescendantsToDocumentFragment,\n  overridePluginsByKey,\n  parseHtmlDocument,\n  parseHtmlElement,\n  pipeDeserializeHtmlElement,\n  pipeDeserializeHtmlLeaf,\n  pipeInsertDataQuery,\n  pipeInsertFragment,\n  pipeNormalizeInitialValue,\n  pipeTransformData,\n  pipeTransformFragment,\n  pluginDeserializeHtml,\n  postCleanHtml,\n  preCleanHtml,\n  removeHtmlNodesBetweenComments,\n  removeHtmlSurroundings,\n  replaceTagName,\n  resetEditor,\n  resetEditorChildren,\n  resolveAndSortPlugins,\n  resolveCreatePluginTest,\n  resolvePlugin,\n  resolvePluginOverrides,\n  resolvePluginTest,\n  resolvePlugins,\n  someHtmlElement,\n  toggleBlock,\n  traverseHtmlComments,\n  traverseHtmlElements,\n  traverseHtmlNode,\n  traverseHtmlTexts,\n  unwrapHtmlElement,\n  upsertInlineFormattingContext,\n  validatePlugin,\n  withInlineVoid,\n  withLength,\n  withParser,\n  withPlateHistory,\n  withSlate,\n  withSlateNext\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/react/BlockMenuPlugin.tsx\nimport { createTPlatePlugin } from \"@udecode/plate-common/react\";\nvar BLOCK_CONTEXT_MENU_ID = \"context\";\nvar BlockMenuPlugin = createTPlatePlugin({\n  key: \"blockMenu\",\n  options: {\n    openId: null,\n    position: {\n      x: -1e4,\n      y: -1e4\n    }\n  }\n}).extendApi(({ setOption, setOptions }) => ({\n  hide: () => {\n    setOptions({\n      openId: null,\n      position: {\n        x: -1e4,\n        y: -1e4\n      }\n    });\n  },\n  show: (id, position) => {\n    if (position) {\n      setOptions({\n        openId: id,\n        position\n      });\n    } else {\n      setOption(\"openId\", id);\n    }\n  }\n})).extendApi(({ api, editor }) => ({\n  showContextMenu: (blockId, position) => {\n    var _a;\n    (_a = editor.getApi({ key: \"blockSelection\" }).blockSelection) == null ? void 0 : _a.addSelectedRow(blockId);\n    api.blockMenu.show(BLOCK_CONTEXT_MENU_ID, position);\n  }\n})).extend(({ api }) => ({\n  handlers: {\n    onMouseDown: ({ event, getOptions }) => {\n      if (event.button === 0 && getOptions().openId) {\n        event.preventDefault();\n        api.blockMenu.hide();\n      }\n      if (event.button === 2) event.preventDefault();\n    }\n  }\n}));\n\n// src/react/BlockSelectionPlugin.tsx\nimport { bindFirst, getNodeEntries as getNodeEntries3 } from \"@udecode/plate-common\";\nimport { createTPlatePlugin as createTPlatePlugin3 } from \"@udecode/plate-common/react\";\n\n// src/lib/extractSelectableIds.ts\nvar extractSelectableIds = (els) => {\n  return els.map((v) => v.dataset.blockId);\n};\n\n// src/lib/getAboveDomNode.ts\nvar getSelectedDomNode = (id) => {\n  return document.querySelector(`.slate-selectable[data-block-id=\"${id}\"]`);\n};\nvar getAllSelectableDomNode = () => {\n  return document.querySelectorAll(`.slate-selectable`);\n};\n\n// src/lib/isSelecting.ts\nimport { isSelectionExpanded } from \"@udecode/plate-common\";\nvar isSelecting = (editor) => {\n  const isSelectingSome = editor.getOption(\n    BlockSelectionPlugin,\n    \"isSelectingSome\"\n  );\n  const selectionExpanded = isSelectionExpanded(editor);\n  return selectionExpanded || isSelectingSome;\n};\n\n// src/react/components/BlockSelectionAfterEditable.tsx\nimport React6 from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  findNode,\n  getEndPoint as getEndPoint2,\n  getNextNode,\n  getPreviousNode,\n  isHotkey,\n  removeNodes\n} from \"@udecode/plate-common\";\nimport {\n  focusEditor as focusEditor2,\n  isEditorReadOnly,\n  useEditorPlugin as useEditorPlugin7,\n  useEditorRef as useEditorRef2\n} from \"@udecode/plate-common/react\";\n\n// src/react/hooks/useBlockSelectable.ts\nimport React from \"react\";\nimport { getAboveNode, isVoid } from \"@udecode/plate-common\";\nimport {\n  findNodePath,\n  useEditorPlugin,\n  useElement\n} from \"@udecode/plate-common/react\";\nimport { Path } from \"slate\";\nvar useBlockSelectable = () => {\n  const element = useElement();\n  const { api, editor, getOption, getOptions } = useEditorPlugin(BlockSelectionPlugin);\n  const path = React.useMemo(\n    () => findNodePath(editor, element),\n    [editor, element]\n  );\n  const id = element == null ? void 0 : element.id;\n  return {\n    props: {\n      className: \"slate-selectable\",\n      onContextMenu: (event) => {\n        var _a, _b;\n        if (!element || !path) return;\n        const { enableContextMenu } = getOptions();\n        if (!enableContextMenu) return;\n        if ((_a = editor.selection) == null ? void 0 : _a.focus) {\n          const nodeEntry = getAboveNode(editor);\n          if (nodeEntry && Path.isCommon(path, nodeEntry[1])) {\n            const id2 = nodeEntry[0].id;\n            const isSelected = getOption(\"isSelected\", id2);\n            const isOpenAlways = ((_b = event.target.dataset) == null ? void 0 : _b.plateOpenContextMenu) === \"true\";\n            if (!isSelected && !isVoid(editor, nodeEntry[0]) && !isOpenAlways) {\n              return event.stopPropagation();\n            }\n          }\n        }\n        if (id) {\n          api.blockSelection.addSelectedRow(id, {\n            clear: !(event == null ? void 0 : event.shiftKey)\n          });\n        }\n      }\n    }\n  };\n};\n\n// src/react/hooks/useBlockSelected.ts\nimport { useEditorPlugin as useEditorPlugin2, useElement as useElement2 } from \"@udecode/plate-common/react\";\nvar useBlockSelected = (_id) => {\n  const { useOption } = useEditorPlugin2(BlockSelectionPlugin);\n  const { id } = useElement2();\n  const isBlockSelected = useOption(\"isSelected\", _id != null ? _id : id);\n  return isBlockSelected;\n};\n\n// src/react/hooks/useBlockSelectionNodes.ts\nimport { useMemo } from \"react\";\nimport {\n  getFragmentProp,\n  getNodeEntries\n} from \"@udecode/plate-common\";\nimport { useEditorPlugin as useEditorPlugin3 } from \"@udecode/plate-common/react\";\nfunction useBlockSelectionNodes() {\n  const { editor, useOption } = useEditorPlugin3(BlockSelectionPlugin);\n  const selectedIds = useOption(\"selectedIds\");\n  return useMemo(() => {\n    return [\n      ...getNodeEntries(editor, {\n        at: [],\n        match: (n) => selectedIds == null ? void 0 : selectedIds.has(n.id)\n      })\n    ];\n  }, [editor, selectedIds]);\n}\nfunction useBlockSelectionFragment() {\n  const nodes = useBlockSelectionNodes();\n  return useMemo(() => nodes.map(([node]) => node), [nodes]);\n}\nfunction useBlockSelectionFragmentProp(options) {\n  const fragment = useBlockSelectionFragment();\n  return useMemo(() => getFragmentProp(fragment, options), [fragment, options]);\n}\n\n// src/react/hooks/useCursorOverlay.ts\nimport React4 from \"react\";\nimport {\n  useEditorContainerRef,\n  useEditorRef,\n  useIsomorphicLayoutEffect\n} from \"@udecode/plate-common/react\";\n\n// src/react/CursorOverlayPlugin.tsx\nimport { useEffect } from \"react\";\nimport {\n  createTPlatePlugin as createTPlatePlugin2,\n  findEventRange,\n  useEditorPlugin as useEditorPlugin4\n} from \"@udecode/plate-common/react\";\nvar getRemoveCursorHandler = (id) => ({ api }) => {\n  api.cursorOverlay.removeCursor(id);\n};\nvar CursorOverlayPlugin = createTPlatePlugin2({\n  key: \"cursorOverlay\",\n  options: { cursors: {} }\n}).extendApi(({ editor, plugin }) => ({\n  addCursor: (id, cursor) => {\n    const newCursors = __spreadValues({}, editor.getOptions(plugin).cursors);\n    newCursors[id] = __spreadValues({\n      id\n    }, cursor);\n    editor.setOption(plugin, \"cursors\", newCursors);\n  },\n  removeCursor: (id) => {\n    const newCursors = __spreadValues({}, editor.getOptions(plugin).cursors);\n    if (!newCursors[id]) return;\n    delete newCursors[id];\n    editor.setOption(plugin, \"cursors\", newCursors);\n  }\n})).extend(() => ({\n  extendEditor: ({ api, editor, getOptions }) => {\n    const { setSelection } = editor;\n    editor.setSelection = (...args) => {\n      var _a;\n      if ((_a = getOptions().cursors) == null ? void 0 : _a.selection) {\n        setTimeout(() => {\n          api.cursorOverlay.addCursor(\"selection\", {\n            selection: editor.selection\n          });\n        }, 0);\n      }\n      setSelection(...args);\n    };\n    return editor;\n  },\n  useHooks: ({ api, setOption }) => {\n    const { editor } = useEditorPlugin4(BlockSelectionPlugin);\n    const isSelecting2 = editor.useOption(BlockSelectionPlugin, \"isSelecting\");\n    useEffect(() => {\n      if (isSelecting2) {\n        setTimeout(() => {\n          api.cursorOverlay.removeCursor(\"selection\");\n        }, 0);\n      }\n    }, [isSelecting2, setOption, api.cursorOverlay]);\n  },\n  handlers: {\n    onBlur: ({ api, editor, event }) => {\n      var _a;\n      if (!editor.selection) return;\n      const relatedTarget = event.relatedTarget;\n      const enabled = ((_a = relatedTarget == null ? void 0 : relatedTarget.dataset) == null ? void 0 : _a.plateFocus) === \"true\";\n      if (!enabled) return;\n      api.cursorOverlay.addCursor(\"selection\", {\n        selection: editor.selection\n      });\n    },\n    onDragEnd: getRemoveCursorHandler(\"drag\"),\n    onDragLeave: getRemoveCursorHandler(\"drag\"),\n    onDragOver: ({ api, editor, event }) => {\n      var _a;\n      if (!editor.plugins.dnd || editor.getOptions({ key: \"dnd\" }).isDragging) {\n        return;\n      }\n      const types = ((_a = event.dataTransfer) == null ? void 0 : _a.types) || [];\n      if (types.some((type) => type.startsWith(\"Files\"))) return;\n      const range = findEventRange(editor, event);\n      if (!range) return;\n      api.cursorOverlay.addCursor(\"drag\", {\n        selection: range\n      });\n    },\n    onDrop: getRemoveCursorHandler(\"drag\"),\n    onFocus: getRemoveCursorHandler(\"selection\")\n  }\n}));\n\n// src/react/queries/getCaretPosition.ts\nimport { Range } from \"slate\";\nvar getCaretPosition = (selectionRects, range) => {\n  const isCollapsed = range && Range.isCollapsed(range);\n  const isBackward = range && Range.isBackward(range);\n  const anchorRect = selectionRects[isBackward ? 0 : selectionRects.length - 1];\n  if (!anchorRect) {\n    return null;\n  }\n  return {\n    height: anchorRect.height,\n    left: anchorRect.left + (isBackward || isCollapsed ? 0 : anchorRect.width),\n    top: anchorRect.top\n  };\n};\n\n// src/react/queries/getCursorOverlayState.ts\nvar getCursorOverlayState = ({\n  cursors: cursorStates,\n  selectionRects\n}) => {\n  if (!cursorStates) return [];\n  return Object.entries(cursorStates).map(([key, cursorState]) => {\n    var _a, _b;\n    const selection = (_a = cursorState == null ? void 0 : cursorState.selection) != null ? _a : null;\n    const rects = (_b = selectionRects[key]) != null ? _b : FROZEN_EMPTY_ARRAY;\n    const caretPosition = selection ? getCaretPosition(rects, selection) : null;\n    return __spreadProps(__spreadValues({}, cursorState), {\n      caretPosition,\n      selection,\n      selectionRects: rects\n    });\n  });\n};\n\n// src/react/queries/getSelectionRects.ts\nimport { getNodeEntries as getNodeEntries2, isText } from \"@udecode/plate-common\";\nimport { toDOMNode, toDOMRange } from \"@udecode/plate-common/react\";\nimport { Path as Path2, Range as Range2 } from \"slate\";\nvar getSelectionRects = (editor, {\n  range,\n  xOffset,\n  yOffset\n}) => {\n  const [start, end] = Range2.edges(range);\n  const domRange = toDOMRange(editor, range);\n  if (!domRange) {\n    return [];\n  }\n  const selectionRects = [];\n  const textEntries = getNodeEntries2(editor, {\n    at: range,\n    match: isText\n  });\n  for (const [textNode, textPath] of textEntries) {\n    const domNode = toDOMNode(editor, textNode);\n    if (!(domNode == null ? void 0 : domNode.parentElement)) {\n      return [];\n    }\n    const isStartNode = Path2.equals(textPath, start.path);\n    const isEndNode = Path2.equals(textPath, end.path);\n    let clientRects = null;\n    if (isStartNode || isEndNode) {\n      const nodeRange = document.createRange();\n      nodeRange.selectNode(domNode);\n      if (isStartNode) {\n        nodeRange.setStart(domRange.startContainer, domRange.startOffset);\n      }\n      if (isEndNode) {\n        nodeRange.setEnd(domRange.endContainer, domRange.endOffset);\n      }\n      clientRects = nodeRange.getClientRects();\n    } else {\n      clientRects = domNode.getClientRects();\n    }\n    for (let i = 0; i < clientRects.length; i++) {\n      const clientRect = clientRects.item(i);\n      if (!clientRect) {\n        continue;\n      }\n      selectionRects.push({\n        height: clientRect.height,\n        left: clientRect.left - xOffset,\n        top: clientRect.top - yOffset,\n        width: clientRect.width\n      });\n    }\n  }\n  return selectionRects;\n};\n\n// src/react/hooks/useRefreshOnResize.ts\nimport React3 from \"react\";\n\n// src/react/hooks/useRequestReRender.ts\nimport React2 from \"react\";\nvar useRequestReRender = () => {\n  const [, setUpdateCounter] = React2.useState(0);\n  const animationFrameRef = React2.useRef(null);\n  const requestReRender = React2.useCallback((immediate = false) => {\n    if (animationFrameRef.current && !immediate) {\n      return;\n    }\n    if (!immediate) {\n      animationFrameRef.current = requestAnimationFrame(() => {\n        setUpdateCounter((state) => state + 1);\n        animationFrameRef.current = null;\n      });\n      return;\n    }\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n    setUpdateCounter((state) => state + 1);\n  }, []);\n  React2.useEffect(() => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  });\n  React2.useEffect(\n    () => () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n      }\n    },\n    []\n  );\n  return requestReRender;\n};\n\n// src/react/hooks/useRefreshOnResize.ts\nvar useRefreshOnResize = ({\n  containerRef,\n  refreshOnResize,\n  selectionRectCache\n}) => {\n  const requestReRender = useRequestReRender();\n  const refresh = React3.useCallback(\n    (sync = false) => {\n      selectionRectCache.current = /* @__PURE__ */ new WeakMap();\n      requestReRender(sync);\n    },\n    [requestReRender, selectionRectCache]\n  );\n  React3.useEffect(() => {\n    if (!refreshOnResize || !(containerRef == null ? void 0 : containerRef.current)) {\n      return;\n    }\n    const resizeObserver = new ResizeObserver(() => refresh());\n    resizeObserver.observe(containerRef.current);\n    return () => resizeObserver.disconnect();\n  }, [containerRef, refresh, refreshOnResize]);\n  return {\n    refresh\n  };\n};\n\n// src/react/hooks/useCursorOverlay.ts\nvar FROZEN_EMPTY_ARRAY = Object.freeze(\n  []\n);\nvar useCursorOverlay = ({\n  minSelectionWidth = 1,\n  refreshOnResize = true\n} = {}) => {\n  const editor = useEditorRef();\n  const containerRef = useEditorContainerRef();\n  const cursorStates = editor.useOption(\n    CursorOverlayPlugin,\n    \"cursors\"\n  );\n  const selectionRectCache = React4.useRef(\n    /* @__PURE__ */ new WeakMap()\n  );\n  const [selectionRects, setSelectionRects] = React4.useState({});\n  const updateSelectionRects = React4.useCallback(() => {\n    if (!(containerRef == null ? void 0 : containerRef.current)) return;\n    if (!cursorStates) return;\n    let xOffset = 0;\n    let yOffset = 0;\n    if (containerRef) {\n      const contentRect = containerRef.current.getBoundingClientRect();\n      xOffset = contentRect.x;\n      yOffset = contentRect.y;\n      yOffset -= containerRef.current.scrollTop;\n    }\n    let selectionRectsChanged = Object.keys(selectionRects).length !== Object.keys(cursorStates).length;\n    const getCachedSelectionRects = ({\n      cursor\n    }) => {\n      const range = cursor.selection;\n      if (!range) {\n        return FROZEN_EMPTY_ARRAY;\n      }\n      const cached = selectionRectCache.current.get(range);\n      if (cached) {\n        return cached;\n      }\n      const rects = getSelectionRects(editor, { range, xOffset, yOffset }).map(\n        (rect) => {\n          if (rect.width < minSelectionWidth) {\n            return __spreadProps(__spreadValues({}, rect), {\n              // Adjust left position to account for minimum width\n              left: rect.left - (minSelectionWidth - rect.width) / 2,\n              width: minSelectionWidth\n            });\n          }\n          return rect;\n        }\n      );\n      selectionRectsChanged = true;\n      selectionRectCache.current.set(range, rects);\n      return rects;\n    };\n    const updated = Object.fromEntries(\n      Object.entries(cursorStates).map(([key, cursor]) => [\n        key,\n        getCachedSelectionRects({\n          cursor\n        })\n      ])\n    );\n    if (selectionRectsChanged) {\n      setSelectionRects(updated);\n    }\n  }, [containerRef, cursorStates, editor, selectionRects, minSelectionWidth]);\n  useIsomorphicLayoutEffect(() => {\n    updateSelectionRects();\n  });\n  const cursors = React4.useMemo(\n    () => getCursorOverlayState({\n      cursors: cursorStates,\n      selectionRects\n    }),\n    [cursorStates, selectionRects]\n  );\n  const { refresh } = useRefreshOnResize({\n    containerRef,\n    refreshOnResize,\n    selectionRectCache\n  });\n  return { cursors, refresh };\n};\n\n// src/react/hooks/useIsSelecting.ts\nimport { isSelectionExpanded as isSelectionExpanded2 } from \"@udecode/plate-common\";\nimport {\n  isEditorFocused,\n  useEditorPlugin as useEditorPlugin5,\n  useEditorSelector\n} from \"@udecode/plate-common/react\";\nvar isSelectingOrFocused = (editor) => {\n  return isSelecting(editor) || isEditorFocused(editor);\n};\nvar useIsSelecting = () => {\n  const isSelectingSome = useEditorPlugin5(BlockSelectionPlugin).useOption(\"isSelectingSome\");\n  const selectionExpanded = useEditorSelector((editor) => {\n    return isSelectionExpanded2(editor);\n  }, []);\n  return selectionExpanded || isSelectingSome;\n};\n\n// src/react/hooks/useSelectionArea.ts\nimport React5 from \"react\";\nimport { deselectEditor, useEditorPlugin as useEditorPlugin6 } from \"@udecode/plate-common/react\";\n\n// src/internal/EventEmitter.ts\nvar EventTarget = class {\n  constructor() {\n    this._listeners = /* @__PURE__ */ new Map();\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    this.emit = this.dispatchEvent;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    this.off = this.removeEventListener;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    this.on = this.addEventListener;\n  }\n  addEventListener(event, cb) {\n    var _a;\n    const set = (_a = this._listeners.get(event)) != null ? _a : /* @__PURE__ */ new Set();\n    this._listeners.set(event, set);\n    set.add(cb);\n    return this;\n  }\n  // Let's also support on, off and emit like node\n  dispatchEvent(event, ...data) {\n    var _a;\n    let ok = true;\n    for (const cb of (_a = this._listeners.get(event)) != null ? _a : []) {\n      ok = cb(...data) !== false && ok;\n    }\n    return ok;\n  }\n  removeEventListener(event, cb) {\n    var _a;\n    (_a = this._listeners.get(event)) == null ? void 0 : _a.delete(cb);\n    return this;\n  }\n  unbindAllListeners() {\n    this._listeners.clear();\n  }\n};\n\n// src/internal/utils/css.ts\nvar unitify = (val, unit = \"px\") => {\n  return typeof val === \"number\" ? val + unit : val;\n};\nfunction css({ style }, attr, val) {\n  if (typeof attr === \"object\") {\n    for (const [key, value] of Object.entries(attr)) {\n      value !== void 0 && (style[key] = unitify(value));\n    }\n  } else if (val !== void 0) {\n    style[attr] = unitify(val);\n  }\n}\n\n// src/internal/utils/events.ts\nvar eventListener = (method) => (items, events, fn, options = {}) => {\n  if (items instanceof HTMLCollection || items instanceof NodeList) {\n    items = Array.from(items);\n  } else if (!Array.isArray(items)) {\n    items = [items];\n  }\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  for (const el of items) {\n    if (el) {\n      for (const ev of events) {\n        el[method](ev, fn, __spreadValues({ capture: false }, options));\n      }\n    }\n  }\n  return [items, events, fn, options];\n};\nvar on = eventListener(\"addEventListener\");\nvar off = eventListener(\"removeEventListener\");\nvar simplifyEvent = (evt) => {\n  var _a, _b;\n  const { clientX, clientY, target } = (_b = (_a = evt.touches) == null ? void 0 : _a[0]) != null ? _b : evt;\n  return { target, x: clientX, y: clientY };\n};\n\n// src/internal/utils/intersects.ts\nfunction intersectsScroll(a, b, mode = \"touch\", container) {\n  const containerRect = container.getBoundingClientRect();\n  const scrollLeft = container.scrollLeft;\n  const scrollTop = container.scrollTop;\n  return a.right >= b.left - containerRect.left && a.left + containerRect.left <= b.right + scrollLeft && // 94 is container to top\n  a.bottom - scrollTop >= b.top - containerRect.top && a.top <= b.bottom - containerRect.top + scrollTop;\n}\n\n// src/internal/utils/selectAll.ts\nfunction selectAll(selector, doc = document) {\n  const list = Array.isArray(selector) ? selector : [selector];\n  let nodes = [];\n  for (let i = 0, l = list.length; i < l; i++) {\n    const item = list[i];\n    if (typeof item === \"string\") {\n      nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n    } else if (item instanceof Element) {\n      nodes.push(item);\n    }\n  }\n  return nodes;\n}\n\n// src/internal/utils/constants.ts\nvar isTouchDevice = () => matchMedia(\"(hover: none), (pointer: coarse)\").matches;\nvar isSafariBrowser = () => \"safari\" in window;\n\n// src/internal/utils/frames.ts\nvar frames = (fn) => {\n  let previousArgs;\n  let frameId = -1;\n  let lock = false;\n  return {\n    cancel() {\n      cancelAnimationFrame(frameId);\n      lock = false;\n    },\n    next(...args) {\n      previousArgs = args;\n      if (!lock) {\n        lock = true;\n        frameId = requestAnimationFrame(() => {\n          fn(...previousArgs);\n          lock = false;\n        });\n      }\n    }\n  };\n};\n\n// src/internal/utils/shouldTrigger.ts\nfunction shouldTrigger(event, triggers) {\n  for (const trigger of triggers) {\n    if (typeof trigger === \"number\") {\n      return event.button === trigger;\n    }\n    if (typeof trigger === \"object\") {\n      const reqButtonIsPressed = trigger.button === event.button;\n      const allReqModifiersArePressed = trigger.modifiers.every((modifier) => {\n        switch (modifier) {\n          case \"alt\": {\n            return event.altKey;\n          }\n          case \"ctrl\": {\n            return event.ctrlKey || event.metaKey;\n          }\n          case \"shift\": {\n            return event.shiftKey;\n          }\n        }\n      });\n      return reqButtonIsPressed && allReqModifiersArePressed;\n    }\n  }\n  return false;\n}\n\n// src/internal/SelectionArea.ts\nvar { abs, ceil, max, min } = Math;\nvar SelectionArea = class extends EventTarget {\n  constructor(opt) {\n    var _a, _b, _c, _d, _e;\n    super();\n    this._areaClientLocation = { x1: 0, x2: 0, y1: 0, y2: 0 };\n    // Dynamically constructed area rect\n    this._areaLocation = { x1: 0, x2: 0, y1: 0, y2: 0 };\n    // Caches the position of the selection-area\n    this._areaRect = new DOMRect();\n    this._initScrollDelta = { x: 0, y: 0 };\n    // Is getting set on movement.\n    this._scrollAvailable = true;\n    // The scroll distance of scrollElement (body or html) relative to the initial scroll position\n    this._scrollDelta = { x: 0, y: 0 };\n    this._scrollSpeed = { x: 0, y: 0 };\n    // If a single click is being performed.\n    this._scrollingActive = false;\n    this._selectables = [];\n    // Selection store\n    this._selection = {\n      changed: {\n        added: [],\n        // Added elements since last selection\n        removed: []\n        // Removed elements since last selection\n      },\n      selected: [],\n      stored: [],\n      touched: []\n    };\n    // It's a single-click until the user dragged the mouse.\n    this._singleClick = true;\n    this.wheelTimer = null;\n    this.disable = this._bindStartEvents.bind(this, false);\n    this.enable = this._bindStartEvents;\n    this._options = __spreadProps(__spreadValues({\n      boundaries: [\"html\"],\n      container: \"body\",\n      document: window.document,\n      selectables: [],\n      selectionAreaClass: \"selection-area\",\n      startAreas: [\"html\"]\n    }, opt), {\n      behaviour: __spreadProps(__spreadValues({\n        // TODO: not implemented\n        intersect: \"touch\",\n        overlap: \"invert\",\n        triggers: [0]\n      }, opt.behaviour), {\n        scrolling: __spreadProps(__spreadValues({\n          manualSpeed: 750,\n          speedDivider: 0.7\n        }, (_a = opt.behaviour) == null ? void 0 : _a.scrolling), {\n          startScrollMargins: __spreadValues({\n            x: 20,\n            y: 40\n          }, (_c = (_b = opt.behaviour) == null ? void 0 : _b.scrolling) == null ? void 0 : _c.startScrollMargins)\n        }),\n        startThreshold: ((_d = opt.behaviour) == null ? void 0 : _d.startThreshold) ? typeof opt.behaviour.startThreshold === \"number\" ? opt.behaviour.startThreshold : __spreadValues({ x: 4, y: 4 }, opt.behaviour.startThreshold) : { x: 4, y: 4 }\n      }),\n      features: __spreadProps(__spreadValues({\n        range: true,\n        touch: true\n      }, opt.features), {\n        singleTap: __spreadValues({\n          allow: true,\n          intersect: \"native\"\n        }, (_e = opt.features) == null ? void 0 : _e.singleTap)\n      })\n    });\n    for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n      if (typeof this[key] === \"function\") {\n        this[key] = this[key].bind(this);\n      }\n    }\n    const { document: document2, selectionAreaClass } = this._options;\n    this._area = document2.createElement(\"div\");\n    this._area.classList.add(selectionAreaClass);\n    css(this._area, {\n      left: 0,\n      position: \"absolute\",\n      top: 0,\n      willChange: \"top, left, bottom, right, width, height\"\n    });\n    this._frame = frames((evt) => {\n      this._recalculateSelectionAreaRect();\n      this._updateElementSelection();\n      this._emitEvent(\"move\", evt);\n      this._redrawSelectionArea();\n    });\n    this.enable();\n  }\n  _bindStartEvents(activate = true) {\n    const { document: document2, features } = this._options;\n    const fn = activate ? on : off;\n    fn(document2, \"mousedown\", this._onTapStart);\n    features.touch && fn(document2, \"touchstart\", this._onTapStart, {\n      passive: false\n    });\n  }\n  _delayedTapMove(evt) {\n    const {\n      behaviour: { startThreshold },\n      document: document2\n    } = this._options;\n    const { x1, y1 } = this._areaLocation;\n    const { x1: clientX, y1: clientY } = this._areaClientLocation;\n    const { x, y } = simplifyEvent(evt);\n    if (\n      // Single number for both coordinates\n      typeof startThreshold === \"number\" && abs(x + y - (clientX + clientY)) >= startThreshold || // Different x and y threshold\n      typeof startThreshold === \"object\" && abs(x - x1) >= startThreshold.x || abs(y - y1) >= startThreshold.y\n    ) {\n      off(document2, [\"mousemove\", \"touchmove\"], this._delayedTapMove, {\n        passive: false\n      });\n      if (this._emitEvent(\"beforedrag\", evt) === false) {\n        off(document2, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n        return;\n      }\n      on(document2, [\"mousemove\", \"touchmove\"], this._onTapMove, {\n        passive: false\n      });\n      css(this._area, \"display\", \"block\");\n      this._container.append(this._area);\n      this.resolveSelectables();\n      this._singleClick = false;\n      on(this._container, \"wheel\", this._manualScroll, { passive: true });\n      this._setupSelectionArea();\n      this._emitEvent(\"start\", evt);\n      this._onTapMove(evt);\n    }\n    this._handleMoveEvent(evt);\n  }\n  _emitEvent(name, evt) {\n    return this.emit(name, {\n      event: evt,\n      selection: this,\n      store: this._selection\n    });\n  }\n  _handleMoveEvent(evt) {\n    const { features } = this._options;\n    if (features.touch && isTouchDevice() || this._scrollAvailable && isSafariBrowser()) {\n      evt.preventDefault();\n    }\n  }\n  _keepSelection() {\n    const { _options, _selection } = this;\n    const { changed, selected, stored, touched } = _selection;\n    const addedElements = selected.filter((el) => !stored.includes(el));\n    switch (_options.behaviour.overlap) {\n      case \"drop\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !touched.includes(el))\n          // Elements not touched\n        ];\n        break;\n      }\n      case \"invert\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !changed.removed.includes(el))\n          // Elements not removed from selection\n        ];\n        break;\n      }\n      case \"keep\": {\n        _selection.stored = [\n          ...stored,\n          ...selected.filter((el) => !stored.includes(el))\n          // Newly added\n        ];\n        break;\n      }\n    }\n  }\n  _manualScroll(evt) {\n    this.wheelTimer && clearTimeout(this.wheelTimer);\n    const { x, y } = simplifyEvent(evt);\n    this.wheelTimer = setTimeout(() => {\n      this._areaClientLocation.x2 = x;\n      this._areaClientLocation.y2 = y;\n      const Ry = y - this._containerRect.top;\n      const Rx = x - this._containerRect.left;\n      this._areaLocation.x2 = Rx + this._container.scrollLeft;\n      this._areaLocation.y2 = Ry + this._container.scrollTop;\n      this._frame.next(null);\n    }, 100);\n  }\n  _onScroll(evt) {\n    const { document: document2 } = this._options;\n    this.wheelTimer && clearTimeout(this.wheelTimer);\n    const { x, y } = simplifyEvent(evt);\n    this.wheelTimer = setTimeout(() => {\n      this._areaClientLocation.x2 = x;\n      this._areaClientLocation.y2 = y;\n      const deltaY = y - this._containerRect.top + this._container.scrollTop + document2.scrollingElement.scrollTop - this._initScrollDelta.y;\n      const deltaX = x - this._containerRect.left + this._container.scrollLeft + document2.scrollingElement.scrollLeft;\n      this._scrollDelta.y = document2.scrollingElement.scrollTop - this._initScrollDelta.y;\n      this._scrollDelta.x = document2.scrollingElement.scrollLeft - this._initScrollDelta.x;\n      this._areaLocation.y2 = deltaY;\n      this._areaLocation.x2 = deltaX;\n      this._frame.next(null);\n    }, 100);\n  }\n  _onSingleTap(evt) {\n    const {\n      range,\n      singleTap: { intersect }\n    } = this._options.features;\n    const e = simplifyEvent(evt);\n    let target;\n    if (intersect === \"native\") {\n      target = e.target;\n    } else if (intersect === \"touch\") {\n      this.resolveSelectables();\n      const { x, y } = e;\n      target = this._selectables.find((v) => {\n        const { bottom, left, right, top } = v.getBoundingClientRect();\n        return x < right && x > left && y < bottom && y > top;\n      });\n    }\n    if (!target) {\n      return;\n    }\n    this.resolveSelectables();\n    while (!this._selectables.includes(target)) {\n      if (!target.parentElement) {\n        return;\n      }\n      target = target.parentElement;\n    }\n    const { stored } = this._selection;\n    this._emitEvent(\"start\", evt);\n    if (evt.shiftKey && range && this._latestElement) {\n      const reference = this._latestElement;\n      const [preceding, following] = reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\n      const rangeItems = [\n        ...this._selectables.filter(\n          (el) => el.compareDocumentPosition(preceding) & 4 && el.compareDocumentPosition(following) & 2\n        ),\n        preceding,\n        following\n      ];\n      this.select(rangeItems);\n      this._latestElement = reference;\n    } else if (stored.includes(target) && (stored.length === 1 || evt.ctrlKey || stored.every((v) => this._selection.stored.includes(v)))) {\n      this.deselect(target);\n    } else {\n      this.select(target);\n      this._latestElement = target;\n    }\n  }\n  _onTapMove(evt) {\n    const { x, y } = simplifyEvent(evt);\n    const {\n      _areaClientLocation,\n      _areaLocation,\n      _frame,\n      _options,\n      _scrollSpeed\n    } = this;\n    const { speedDivider } = _options.behaviour.scrolling;\n    const Ry = y - this._containerRect.top;\n    const Rx = x - this._containerRect.left;\n    if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n      this._scrollingActive = true;\n      const scroll = () => {\n        if (!_scrollSpeed.x && !_scrollSpeed.y) {\n          this._scrollingActive = false;\n          return;\n        }\n        if (_scrollSpeed.y) {\n          this._container.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n          _areaLocation.y2 = Ry;\n        }\n        if (_scrollSpeed.x) {\n          this._container.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n          _areaLocation.x2 = Rx;\n        }\n        _frame.next(evt);\n        requestAnimationFrame(scroll);\n      };\n      requestAnimationFrame(scroll);\n    } else {\n      _areaLocation.x2 = Rx + this._container.scrollLeft + this._scrollDelta.x;\n      _areaLocation.y2 = Ry + this._container.scrollTop + this._scrollDelta.y;\n      _areaClientLocation.x2 = x;\n      _areaClientLocation.y2 = y;\n      _frame.next(evt);\n    }\n    this._handleMoveEvent(evt);\n  }\n  _onTapStart(evt, silent = false) {\n    var _a;\n    const { container, document: document2 } = this._options;\n    const { target, x, y } = simplifyEvent(evt);\n    this._container = selectAll(container, document2)[0];\n    if (!this._container) return;\n    if (this._container.contains(target) && target.dataset.slateEditor !== \"true\" && target.dataset.plateSelectable !== \"true\")\n      return;\n    this._containerRect = this._container.getBoundingClientRect();\n    const Rx = x - this._containerRect.left + this._container.scrollLeft;\n    const Ry = y - this._containerRect.top + this._container.scrollTop;\n    const { _options } = this;\n    if (evt instanceof MouseEvent && !shouldTrigger(evt, _options.behaviour.triggers)) {\n      return;\n    }\n    const startAreas = selectAll(_options.startAreas, _options.document);\n    const resolvedBoundaries = selectAll(\n      _options.boundaries,\n      _options.document\n    );\n    const evtPath = evt.composedPath();\n    if (!this._container || // eslint-disable-next-line unicorn/prefer-array-some\n    !startAreas.find((el) => evtPath.includes(el)) || // eslint-disable-next-line unicorn/prefer-array-some\n    !resolvedBoundaries.find((el) => evtPath.includes(el))) {\n      return;\n    }\n    if (!silent && this._emitEvent(\"beforestart\", evt) === false) {\n      return;\n    }\n    this._areaLocation = { x1: Rx, x2: 0, y1: Ry, y2: 0 };\n    this._areaClientLocation = { x1: x, x2: 0, y1: y, y2: 0 };\n    const scrollElement = (_a = document2.scrollingElement) != null ? _a : document2.body;\n    this._initScrollDelta = {\n      x: scrollElement.scrollLeft,\n      y: scrollElement.scrollTop\n    };\n    this._singleClick = true;\n    this.clearSelection(false, true);\n    on(document2, [\"touchmove\", \"mousemove\"], this._delayedTapMove, {\n      passive: false\n    });\n    on(document2, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    on(document2, \"wheel\", this._onScroll, { passive: false });\n  }\n  _onTapStop(evt, silent) {\n    var _a;\n    const { document: document2, features } = this._options;\n    const { _singleClick } = this;\n    off(document2, [\"mousemove\", \"touchmove\"], this._delayedTapMove);\n    off(document2, [\"touchmove\", \"mousemove\"], this._onTapMove);\n    off(document2, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    off(document2, \"wheel\", this._onScroll);\n    this._keepSelection();\n    if (evt && _singleClick && features.singleTap.allow) {\n      this._onSingleTap(evt);\n    } else if (!_singleClick && !silent) {\n      this._updateElementSelection();\n      this._emitEvent(\"stop\", evt);\n    }\n    this._scrollSpeed.x = 0;\n    this._scrollSpeed.y = 0;\n    this._scrollDelta.x = 0;\n    this._scrollDelta.y = 0;\n    off(this._container, \"wheel\", this._manualScroll, { passive: true });\n    this._area.remove();\n    (_a = this._frame) == null ? void 0 : _a.cancel();\n    css(this._area, \"display\", \"none\");\n  }\n  _recalculateSelectionAreaRect() {\n    const {\n      _areaClientLocation,\n      _areaLocation,\n      _areaRect,\n      _container,\n      _containerRect,\n      _scrollSpeed\n    } = this;\n    const {\n      clientHeight,\n      clientWidth,\n      scrollHeight,\n      scrollLeft,\n      scrollTop,\n      scrollWidth\n    } = _container;\n    const { x1, y1 } = _areaLocation;\n    let { x2, y2 } = _areaLocation;\n    const {\n      behaviour: {\n        scrolling: { startScrollMargins }\n      }\n    } = this._options;\n    if (_areaClientLocation.x2 + this._scrollDelta.x < _containerRect.left + startScrollMargins.x) {\n      _scrollSpeed.x = scrollLeft ? -abs(\n        _containerRect.left - _areaClientLocation.x2 - this._scrollDelta.x\n      ) : 0;\n      x2 = max(x2, this._container.scrollLeft);\n    } else if (_areaClientLocation.x2 + this._scrollDelta.x > _containerRect.right - startScrollMargins.x) {\n      _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(\n        _containerRect.left + this._container.clientWidth - _areaClientLocation.x2 - this._scrollDelta.x\n      ) : 0;\n      x2 = clientWidth + scrollLeft;\n    } else {\n      _scrollSpeed.x = 0;\n    }\n    if (_areaClientLocation.y2 + this._scrollDelta.y < _containerRect.top + startScrollMargins.y) {\n      _scrollSpeed.y = scrollTop ? -abs(\n        _containerRect.top - _areaClientLocation.y2 - this._scrollDelta.y + startScrollMargins.y\n      ) : 0;\n      y2 = max(y2, this._container.scrollTop);\n    } else if (_areaClientLocation.y2 + this._scrollDelta.y > _containerRect.bottom - startScrollMargins.y) {\n      _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(\n        _areaClientLocation.y2 + this._scrollDelta.y - (_containerRect.top + this._container.clientHeight - startScrollMargins.y)\n      ) : 0;\n      y2 = clientHeight + scrollTop;\n    } else {\n      _scrollSpeed.y = 0;\n    }\n    const x3 = min(x1, x2);\n    const y3 = min(y1, y2);\n    const x4 = max(x1, x2);\n    const y4 = max(y1, y2);\n    _areaRect.x = x3;\n    _areaRect.y = y3;\n    _areaRect.width = x4 - x3;\n    _areaRect.height = y4 - y3;\n  }\n  _redrawSelectionArea() {\n    const { height, width, x, y } = this._areaRect;\n    const { style } = this._area;\n    style.left = `${x}px`;\n    style.top = `${y}px`;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n  }\n  _setupSelectionArea() {\n  }\n  _updateElementSelection() {\n    const { _areaRect, _options, _selectables, _selection } = this;\n    const { selected, stored, touched } = _selection;\n    const { intersect, overlap } = _options.behaviour;\n    const invert = overlap === \"invert\";\n    const newlyTouched = [];\n    const added = [];\n    const removed = [];\n    for (let i = 0; i < _selectables.length; i++) {\n      const node = _selectables[i];\n      if (intersectsScroll(\n        _areaRect,\n        node.getBoundingClientRect(),\n        intersect,\n        this._container\n      )) {\n        if (!selected.includes(node)) {\n          if (invert && stored.includes(node)) {\n            removed.push(node);\n            continue;\n          } else {\n            added.push(node);\n          }\n        } else if (stored.includes(node) && !touched.includes(node)) {\n          touched.push(node);\n        }\n        newlyTouched.push(node);\n      }\n    }\n    if (invert) {\n      added.push(...stored.filter((v) => !selected.includes(v)));\n    }\n    const keep = overlap === \"keep\";\n    for (let i = 0; i < selected.length; i++) {\n      const node = selected[i];\n      if (!newlyTouched.includes(node) && !// Check if user wants to keep previously selected elements, e.g.\n      // not make them part of the current selection as soon as they're touched.\n      (keep && stored.includes(node))) {\n        removed.push(node);\n      }\n    }\n    _selection.selected = newlyTouched;\n    _selection.changed = { added, removed };\n    this._latestElement = void 0;\n  }\n  /**\n   * Cancel the current selection process.\n   *\n   * @param keepEvent {boolean} true to fire a stop event after cancel.\n   */\n  cancel(keepEvent = false) {\n    this._onTapStop(null, !keepEvent);\n  }\n  /**\n   * Same as deselect, but for all elements currently selected.\n   *\n   * @param includeStored If the store should also get cleared\n   * @param quiet If move / stop events should be fired\n   */\n  clearSelection(includeStored = true, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n    changed.added = [];\n    changed.removed.push(...selected, ...includeStored ? stored : []);\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n    this._selection = {\n      changed: { added: [], removed: [] },\n      selected: [],\n      stored: includeStored ? [] : stored,\n      touched: []\n    };\n  }\n  /**\n   * Removes a particular element from the selection.\n   *\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  deselect(query, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => selected.includes(el) || stored.includes(el)\n    );\n    if (elements.length === 0) {\n      return;\n    }\n    this._selection.stored = stored.filter((el) => !elements.includes(el));\n    this._selection.selected = selected.filter((el) => !elements.includes(el));\n    this._selection.changed.added = [];\n    this._selection.changed.removed.push(\n      ...elements.filter((el) => !changed.removed.includes(el))\n    );\n    this._latestElement = void 0;\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n  }\n  /** Unbinds all events and removes the area-element. */\n  destroy() {\n    this.cancel();\n    this.disable();\n    super.unbindAllListeners();\n  }\n  /** @returns {Array} Selected elements */\n  getSelection() {\n    return this._selection.stored;\n  }\n  /** @returns {HTMLElement} The selection area element */\n  getSelectionArea() {\n    return this._area;\n  }\n  /**\n   * Can be used if during a selection elements have been added. Will update\n   * everything which can be selected.\n   */\n  resolveSelectables() {\n    this._selectables = selectAll(\n      this._options.selectables,\n      this._options.document\n    );\n  }\n  /**\n   * Adds elements to the selection\n   *\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  select(query, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => !selected.includes(el) && !stored.includes(el)\n    );\n    stored.push(...elements);\n    selected.push(...elements);\n    changed.added.push(...elements);\n    changed.removed = [];\n    this._latestElement = void 0;\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n    return elements;\n  }\n  /**\n   * Manually triggers the start of a selection\n   *\n   * @param evt A MouseEvent / TouchEvent -like object\n   * @param silent If beforestart should be fired,\n   */\n  trigger(evt, silent = true) {\n    this._onTapStart(evt, silent);\n  }\n};\n\n// src/react/hooks/useSelectionArea.ts\nvar useSelectionArea = () => {\n  const { api, editor, getOptions, setOption } = useEditorPlugin6(BlockSelectionPlugin);\n  const { areaOptions } = getOptions();\n  React5.useEffect(() => {\n    const selection = new SelectionArea(__spreadValues({\n      boundaries: `#${editor.uid}`,\n      container: `#${editor.uid}`,\n      document: window.document,\n      selectables: `#${editor.uid} .slate-selectable`,\n      selectionAreaClass: \"slate-selection-area\"\n    }, areaOptions)).on(\"beforestart\", () => {\n      setOption(\"isSelecting\", false);\n    }).on(\"start\", ({ event }) => {\n      setOption(\"isSelectionAreaVisible\", true);\n      deselectEditor(editor);\n      if (!(event == null ? void 0 : event.shiftKey)) {\n        selection.clearSelection();\n        api.blockSelection.resetSelectedIds();\n      }\n    }).on(\"move\", ({ store: { changed } }) => {\n      if (!getOptions().isSelectionAreaVisible) {\n        setOption(\"isSelectionAreaVisible\", true);\n      }\n      if (changed.added.length === 0 && changed.removed.length === 0) return;\n      api.blockSelection.setSelectedIds(changed);\n    }).on(\"stop\", () => {\n      setOption(\"isSelectionAreaVisible\", false);\n    });\n    return () => selection.destroy();\n  }, []);\n};\n\n// src/react/utils/copySelectedBlocks.ts\nimport {\n  deselect,\n  getEndPoint,\n  getStartPoint,\n  select,\n  withoutNormalizing\n} from \"@udecode/plate-common\";\nimport copyToClipboard from \"copy-to-clipboard\";\nvar copySelectedBlocks = (editor) => {\n  const { selectedIds } = editor.getOptions(BlockSelectionPlugin);\n  const selectedEntries = editor.getApi(BlockSelectionPlugin).blockSelection.getNodes();\n  const selectedFragment = selectedEntries.map(([node]) => node);\n  copyToClipboard(\" \", {\n    onCopy: (dataTransfer) => {\n      const data = dataTransfer;\n      if (!data) return;\n      let textPlain = \"\";\n      const div = document.createElement(\"div\");\n      withoutNormalizing(editor, () => {\n        selectedEntries.forEach(([, path]) => {\n          select(editor, {\n            anchor: getStartPoint(editor, path),\n            focus: getEndPoint(editor, path)\n          });\n          editor.setFragmentData(data);\n          textPlain += `${data.getData(\"text/plain\")}\n`;\n          const divChild = document.createElement(\"div\");\n          divChild.innerHTML = data.getData(\"text/html\");\n          div.append(divChild);\n        });\n        deselect(editor);\n        editor.setOption(BlockSelectionPlugin, \"selectedIds\", selectedIds);\n      });\n      data.setData(\"text/plain\", textPlain);\n      data.setData(\"text/html\", div.innerHTML);\n      const selectedFragmentStr = JSON.stringify(selectedFragment);\n      const encodedFragment = window.btoa(\n        encodeURIComponent(selectedFragmentStr)\n      );\n      data.setData(\"application/x-slate-fragment\", encodedFragment);\n    }\n  });\n};\n\n// src/react/utils/pasteSelectedBlocks.ts\nimport {\n  deselect as deselect2,\n  getEditorPlugin as getEditorPlugin2,\n  getStartPoint as getStartPoint2,\n  insertNodes,\n  isElementEmpty\n} from \"@udecode/plate-common\";\nimport { focusEditor, insertData } from \"@udecode/plate-common/react\";\nimport { Path as Path3 } from \"slate\";\n\n// src/react/utils/selectInsertedBlocks.ts\nimport {\n  getEditorPlugin,\n  isBlock\n} from \"@udecode/plate-common\";\nvar selectInsertedBlocks = (editor) => {\n  const { setOption } = getEditorPlugin(editor, BlockSelectionPlugin);\n  const ids = /* @__PURE__ */ new Set();\n  editor.operations.forEach((op) => {\n    if (op.type === \"insert_node\" && op.node.id && isBlock(editor, op.node)) {\n      ids.add(op.node.id);\n    }\n  });\n  setTimeout(() => {\n    setOption(\"selectedIds\", ids);\n  }, 0);\n};\n\n// src/react/utils/pasteSelectedBlocks.ts\nvar pasteSelectedBlocks = (editor, e) => {\n  const { api } = getEditorPlugin2(editor, BlockSelectionPlugin);\n  const entries = api.blockSelection.getNodes();\n  if (entries.length > 0) {\n    const entry = entries.at(-1);\n    const [node, path] = entry;\n    focusEditor(editor, getStartPoint2(editor, path));\n    if (!isElementEmpty(editor, node)) {\n      const at = Path3.next(path);\n      insertNodes(editor, editor.api.create.block({}, at), {\n        at,\n        select: true\n      });\n    }\n    insertData(editor, e.clipboardData);\n    deselect2(editor);\n    selectInsertedBlocks(editor);\n  }\n};\n\n// src/react/components/BlockSelectionAfterEditable.tsx\nvar BlockSelectionAfterEditable = () => {\n  const editor = useEditorRef2();\n  const { api, getOption, getOptions, setOption, useOption } = useEditorPlugin7({ key: \"blockSelection\" });\n  const isSelecting2 = useOption(\"isSelecting\");\n  const selectedIds = useOption(\"selectedIds\");\n  useSelectionArea();\n  const inputRef = React6.useRef(null);\n  const [isMounted, setIsMounted] = React6.useState(false);\n  React6.useEffect(() => {\n    setIsMounted(true);\n    setOption(\"shadowInputRef\", inputRef);\n    return () => {\n      setIsMounted(false);\n    };\n  }, [setOption]);\n  React6.useEffect(() => {\n    if (isSelecting2 && inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    } else if (inputRef.current) {\n      inputRef.current.blur();\n    }\n  }, [isSelecting2]);\n  const handleKeyDown = React6.useCallback(\n    (e) => {\n      var _a, _b;\n      const isReadonly = isEditorReadOnly(editor);\n      (_b = (_a = getOptions()).onKeyDownSelecting) == null ? void 0 : _b.call(_a, e.nativeEvent);\n      if (!getOptions().isSelecting) return;\n      if (isHotkey(\"escape\")(e)) {\n        api.blockSelection.unselect();\n      }\n      if (isHotkey(\"mod+z\")(e)) {\n        editor.undo();\n        selectInsertedBlocks(editor);\n      }\n      if (isHotkey(\"mod+shift+z\")(e)) {\n        editor.redo();\n        selectInsertedBlocks(editor);\n      }\n      if (!getOption(\"isSelectingSome\")) return;\n      if (isHotkey(\"enter\")(e)) {\n        const entry = findNode(editor, {\n          at: [],\n          match: (n) => n.id && selectedIds.has(n.id)\n        });\n        if (entry) {\n          const [, path] = entry;\n          focusEditor2(editor, getEndPoint2(editor, path));\n          e.preventDefault();\n        }\n      }\n      if (isHotkey([\"backspace\", \"delete\"])(e) && !isReadonly) {\n        removeNodes(editor, {\n          at: [],\n          match: (n) => !!n.id && selectedIds.has(n.id)\n        });\n      }\n      if (isHotkey(\"up\")(e)) {\n        const firstId = [...selectedIds][0];\n        const node = findNode(editor, {\n          at: [],\n          match: (n) => n.id && n.id === firstId\n        });\n        const prev = getPreviousNode(editor, {\n          at: node == null ? void 0 : node[1]\n        });\n        const prevId = prev == null ? void 0 : prev[0].id;\n        api.blockSelection.addSelectedRow(prevId);\n      }\n      if (isHotkey(\"down\")(e)) {\n        const lastId = [...selectedIds].pop();\n        const node = findNode(editor, {\n          at: [],\n          match: (n) => n.id && n.id === lastId\n        });\n        const next = getNextNode(editor, {\n          at: node == null ? void 0 : node[1]\n        });\n        const nextId = next == null ? void 0 : next[0].id;\n        api.blockSelection.addSelectedRow(nextId);\n      }\n    },\n    [editor, selectedIds, api, getOptions, getOption]\n  );\n  const handleCopy = React6.useCallback(\n    (e) => {\n      e.preventDefault();\n      if (getOption(\"isSelectingSome\")) {\n        copySelectedBlocks(editor);\n      }\n    },\n    [editor, getOption]\n  );\n  const handleCut = React6.useCallback(\n    (e) => {\n      e.preventDefault();\n      if (getOption(\"isSelectingSome\")) {\n        copySelectedBlocks(editor);\n        if (!isEditorReadOnly(editor)) {\n          removeNodes(editor, {\n            at: [],\n            match: (n) => selectedIds.has(n.id)\n          });\n          focusEditor2(editor);\n        }\n      }\n    },\n    [editor, selectedIds, getOption]\n  );\n  const handlePaste = React6.useCallback(\n    (e) => {\n      e.preventDefault();\n      if (!isEditorReadOnly(editor)) {\n        pasteSelectedBlocks(editor, e.nativeEvent);\n      }\n    },\n    [editor]\n  );\n  if (!isMounted || typeof window === \"undefined\") {\n    return null;\n  }\n  return ReactDOM.createPortal(\n    /* @__PURE__ */ React6.createElement(\n      \"input\",\n      {\n        ref: inputRef,\n        className: \"slate-shadow-input\",\n        style: {\n          left: \"-300px\",\n          opacity: 0,\n          position: \"fixed\",\n          top: \"-300px\",\n          zIndex: 999\n        },\n        onCopy: handleCopy,\n        onCut: handleCut,\n        onKeyDown: handleKeyDown,\n        onPaste: handlePaste\n      }\n    ),\n    document.body\n  );\n};\n\n// src/react/onKeyDownSelection.ts\nimport {\n  getAncestorNode,\n  isHotkey as isHotkey2,\n  isRangeInSameBlock,\n  isSelectionCoverBlock,\n  select as select2\n} from \"@udecode/plate-common\";\nvar onKeyDownSelection = ({\n  api,\n  editor,\n  event\n}) => {\n  if (isHotkey2(\"mod+a\", event)) {\n    if (event.defaultPrevented) return;\n    const ancestorNode = getAncestorNode(editor);\n    if (!ancestorNode) return;\n    const [, path] = ancestorNode;\n    if (isSelectionCoverBlock(editor)) {\n      return api.blockSelection.selectedAll();\n    }\n    if (!isRangeInSameBlock(editor)) {\n      return api.blockSelection.selectedAll();\n    }\n    select2(editor, path);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  if (isHotkey2(\"escape\", event)) {\n    if (event.defaultPrevented) return;\n    const ancestorNode = getAncestorNode(editor);\n    const id = ancestorNode == null ? void 0 : ancestorNode[0].id;\n    api.blockSelection.addSelectedRow(id);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n};\n\n// src/react/transforms/duplicateBlockSelectionNodes.ts\nimport {\n  duplicateBlocks,\n  getNodeEntry\n} from \"@udecode/plate-common\";\nimport { Path as Path4 } from \"slate\";\nvar duplicateBlockSelectionNodes = (editor, blocks) => {\n  duplicateBlocks(editor, blocks);\n  const lastBlock = blocks.at(-1);\n  if (!lastBlock) return;\n  const path = Path4.next(lastBlock[1]);\n  const ids = blocks.map((_, index) => {\n    const targetPath = [path[0] + index];\n    const targetNode = getNodeEntry(editor, targetPath);\n    return targetNode == null ? void 0 : targetNode[0].id;\n  }).filter(Boolean);\n  const api = editor.getApi(BlockSelectionPlugin);\n  setTimeout(() => {\n    api.blockSelection.setSelectedIds({ ids });\n  }, 0);\n};\n\n// src/react/transforms/insertBlocksAndSelect.ts\nimport { insertNodes as insertNodes2, nanoid } from \"@udecode/plate-common\";\nvar insertBlocksAndSelect = (editor, nodes, { at }) => {\n  const ids = [];\n  nodes.forEach((node) => {\n    const id = nanoid();\n    ids.push(id);\n    node.id = id;\n  });\n  insertNodes2(editor, nodes, { at });\n  setTimeout(() => {\n    editor.getApi(BlockSelectionPlugin).blockSelection.setSelectedIds({ ids });\n  }, 0);\n};\n\n// src/react/transforms/removeBlockSelectionNodes.ts\nvar removeBlockSelectionNodes = (editor) => {\n  const selectedIds = editor.getOption(BlockSelectionPlugin, \"selectedIds\");\n  if (!selectedIds) return;\n  editor.removeNodes({\n    at: [],\n    match: (n) => selectedIds.has(n.id)\n  });\n};\n\n// src/react/transforms/selectBlockSelectionNodes.ts\nimport { selectNodes } from \"@udecode/plate-common\";\nvar selectBlockSelectionNodes = (editor) => {\n  selectNodes(\n    editor,\n    editor.getApi(BlockSelectionPlugin).blockSelection.getNodes()\n  );\n  editor.getApi(BlockSelectionPlugin).blockSelection.resetSelectedIds();\n};\n\n// src/react/transforms/setBlockSelectionNodes.ts\nimport {\n  setNodes,\n  withoutNormalizing as withoutNormalizing2\n} from \"@udecode/plate-common\";\nvar setBlockSelectionNodes = (editor, props, options) => {\n  withoutNormalizing2(editor, () => {\n    const blocks = editor.getApi(BlockSelectionPlugin).blockSelection.getNodes();\n    blocks.forEach(([, path]) => {\n      setNodes(editor, props, __spreadProps(__spreadValues({}, options), {\n        at: path\n      }));\n    });\n  });\n};\nvar setBlockSelectionIndent = (editor, indent, options) => {\n  const api = editor.getApi(BlockSelectionPlugin);\n  withoutNormalizing2(editor, () => {\n    const blocks = api.blockSelection.getNodes();\n    blocks.forEach(([node, path]) => {\n      var _a;\n      const prevIndent = (_a = node.indent) != null ? _a : 0;\n      const currentIndent = prevIndent + indent;\n      setNodes(\n        editor,\n        { indent: currentIndent < 0 ? 0 : currentIndent },\n        __spreadProps(__spreadValues({}, options), {\n          at: path\n        })\n      );\n    });\n  });\n};\nvar setBlockSelectionTexts = (editor, props, options) => {\n  setBlockSelectionNodes(editor, props, __spreadValues({\n    mode: \"lowest\"\n  }, options));\n};\n\n// src/react/BlockSelectionPlugin.tsx\nvar BlockSelectionPlugin = createTPlatePlugin3({\n  key: \"blockSelection\",\n  extendEditor: ({ api, editor, getOptions }) => {\n    const { setSelection } = editor;\n    editor.setSelection = (...args) => {\n      if (getOptions().selectedIds.size > 0 && !editor.getOption(BlockMenuPlugin, \"openId\")) {\n        api.blockSelection.unselect();\n      }\n      setSelection(...args);\n    };\n    return editor;\n  },\n  inject: {\n    isBlock: true,\n    nodeProps: {\n      transformProps: () => {\n        return useBlockSelectable().props;\n      }\n    }\n  },\n  options: {\n    areaOptions: {\n      features: {\n        singleTap: {\n          allow: false\n        }\n      }\n    },\n    enableContextMenu: false,\n    isSelecting: false,\n    isSelectionAreaVisible: false,\n    selectedIds: /* @__PURE__ */ new Set(),\n    shadowInputRef: { current: null }\n  },\n  plugins: [BlockMenuPlugin],\n  render: {\n    afterEditable: BlockSelectionAfterEditable\n  },\n  handlers: {\n    onKeyDown: onKeyDownSelection,\n    onMouseDown: ({ api, editor, event, getOptions }) => {\n      const target = event.target;\n      if (target.dataset.platePreventUnselect) return;\n      if (event.button === 0 && getOptions().selectedIds.size > 0 && !editor.getOption(BlockMenuPlugin, \"openId\")) {\n        api.blockSelection.unselect();\n      }\n    }\n  }\n}).extend(() => ({\n  inject: {}\n})).extendOptions(({ getOptions }) => ({\n  isSelected: (id) => !!id && getOptions().selectedIds.has(id),\n  isSelectingSome: () => getOptions().selectedIds.size > 0\n})).extendApi(\n  ({ editor, getOption, getOptions, setOption }) => ({\n    focus: () => {\n      const shadowInputRef = getOption(\"shadowInputRef\");\n      if (shadowInputRef == null ? void 0 : shadowInputRef.current) {\n        shadowInputRef.current.focus({ preventScroll: true });\n      }\n    },\n    getNodes: () => {\n      const selectedIds = getOption(\"selectedIds\");\n      return [\n        ...getNodeEntries3(editor, {\n          at: [],\n          match: (n) => selectedIds == null ? void 0 : selectedIds.has(n.id)\n        })\n      ];\n    },\n    resetSelectedIds: () => {\n      setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n    },\n    setSelectedIds: ({ added, ids, removed }) => {\n      if (ids) {\n        setOption(\"selectedIds\", new Set(ids));\n      }\n      if (added || removed) {\n        const { selectedIds: prev } = getOptions();\n        const next = new Set(prev);\n        if (added) {\n          extractSelectableIds(added).forEach((id) => next.add(id));\n        }\n        if (removed) {\n          extractSelectableIds(removed).forEach((id) => next.delete(id));\n        }\n        setOption(\"selectedIds\", next);\n      }\n      setOption(\"isSelecting\", true);\n    },\n    unselect: () => {\n      setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n      setOption(\"isSelecting\", false);\n    }\n  })\n).extendApi(({ api, getOptions, setOption }) => ({\n  addSelectedRow: (id, options = {}) => {\n    const { clear = true, delay } = options;\n    const element = getSelectedDomNode(id);\n    if (!element) return;\n    if (!getOptions().selectedIds.has(id) && clear) {\n      setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n    }\n    api.blockSelection.setSelectedIds({\n      added: [element],\n      removed: []\n    });\n    if (delay) {\n      setTimeout(() => {\n        api.blockSelection.setSelectedIds({\n          added: [],\n          removed: [element]\n        });\n      }, delay);\n    }\n  },\n  selectedAll: () => {\n    const all = getAllSelectableDomNode();\n    setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n    api.blockSelection.setSelectedIds({\n      added: Array.from(all),\n      removed: []\n    });\n  }\n})).extendTransforms(({ editor }) => ({\n  duplicate: bindFirst(duplicateBlockSelectionNodes, editor),\n  insertBlocksAndSelect: bindFirst(insertBlocksAndSelect, editor),\n  removeNodes: bindFirst(removeBlockSelectionNodes, editor),\n  select: bindFirst(selectBlockSelectionNodes, editor),\n  setIndent: bindFirst(setBlockSelectionIndent, editor),\n  setNodes: bindFirst(setBlockSelectionNodes, editor),\n  setTexts: bindFirst(setBlockSelectionTexts, editor)\n}));\nexport {\n  BLOCK_CONTEXT_MENU_ID,\n  BlockMenuPlugin,\n  BlockSelectionAfterEditable,\n  BlockSelectionPlugin,\n  CursorOverlayPlugin,\n  FROZEN_EMPTY_ARRAY,\n  copySelectedBlocks,\n  duplicateBlockSelectionNodes,\n  getCaretPosition,\n  getCursorOverlayState,\n  getSelectionRects,\n  insertBlocksAndSelect,\n  isSelectingOrFocused,\n  onKeyDownSelection,\n  pasteSelectedBlocks,\n  removeBlockSelectionNodes,\n  selectBlockSelectionNodes,\n  selectInsertedBlocks,\n  setBlockSelectionIndent,\n  setBlockSelectionNodes,\n  setBlockSelectionTexts,\n  useBlockSelectable,\n  useBlockSelected,\n  useBlockSelectionFragment,\n  useBlockSelectionFragmentProp,\n  useBlockSelectionNodes,\n  useCursorOverlay,\n  useIsSelecting,\n  useRefreshOnResize,\n  useRequestReRender,\n  useSelectionArea\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/lib/MarkdownPlugin.ts\nimport {\n  bindFirst,\n  createTSlatePlugin,\n  isUrl\n} from \"@udecode/plate-common\";\n\n// src/lib/deserializer/utils/stripMarkdown.ts\nvar stripMarkdownBlocks = (text) => {\n  text = text.replaceAll(/^#{1,6}\\s+/gm, \"\");\n  text = text.replaceAll(/^\\s*>\\s?/gm, \"\");\n  text = text.replaceAll(/^([*_-]){3,}\\s*$/gm, \"\");\n  text = text.replaceAll(/^(\\s*)([*+-]|\\d+\\.)\\s/gm, \"$1\");\n  text = text.replaceAll(/^```[\\S\\s]*?^```/gm, \"\");\n  text = text.replaceAll(\"<br>\", \"\\n\");\n  return text;\n};\nvar stripMarkdownInline = (text) => {\n  text = text.replaceAll(/(\\*\\*|__)(.*?)\\1/g, \"$2\");\n  text = text.replaceAll(/(\\*|_)(.*?)\\1/g, \"$2\");\n  text = text.replaceAll(/\\[([^\\]]+)]\\(([^)]+)\\)/g, \"$1\");\n  text = text.replaceAll(/`(.+?)`/g, \"$1\");\n  text = text.replaceAll(\"&nbsp;\", \" \");\n  text = text.replaceAll(\"&lt;\", \"<\");\n  text = text.replaceAll(\"&gt;\", \">\");\n  text = text.replaceAll(\"&amp;\", \"&\");\n  return text;\n};\nvar stripMarkdown = (text) => {\n  text = stripMarkdownBlocks(text);\n  text = stripMarkdownInline(text);\n  return text;\n};\n\n// src/lib/deserializer/utils/deserializeInlineMd.ts\nvar deserializeInlineMd = (editor, text) => {\n  var _a, _b;\n  const leadingSpaces = ((_a = /^\\s*/.exec(text)) == null ? void 0 : _a[0]) || \"\";\n  const trailingSpaces = ((_b = /\\s*$/.exec(text)) == null ? void 0 : _b[0]) || \"\";\n  const strippedText = stripMarkdownBlocks(text.trim());\n  const fragment = [];\n  if (leadingSpaces) {\n    fragment.push({ text: leadingSpaces });\n  }\n  if (strippedText) {\n    fragment.push(\n      ...editor.getApi(MarkdownPlugin).markdown.deserialize(strippedText)[0].children\n    );\n  }\n  if (trailingSpaces) {\n    fragment.push({ text: trailingSpaces });\n  }\n  return fragment;\n};\n\n// src/lib/deserializer/utils/deserializeMd.ts\nimport remarkGfm from \"remark-gfm\";\nimport remarkParse from \"remark-parse\";\nimport { unified } from \"unified\";\n\n// src/lib/remark-slate/remarkTextTypes.ts\nvar remarkTextTypes = [\n  \"emphasis\",\n  \"strong\",\n  \"delete\",\n  \"inlineCode\",\n  \"html\",\n  \"text\"\n];\n\n// src/lib/remark-slate/remarkTransformElement.ts\nvar remarkTransformElement = (node, options) => {\n  const { elementRules } = options;\n  const { type } = node;\n  const elementRule = elementRules[type];\n  if (!elementRule) return [];\n  return elementRule.transform(node, options);\n};\n\n// src/lib/remark-slate/remarkDefaultTextRules.ts\nvar remarkDefaultTextRules = {\n  delete: { mark: ({ editor }) => editor.getType({ key: \"strikethrough\" }) },\n  emphasis: { mark: ({ editor }) => editor.getType({ key: \"italic\" }) },\n  html: { transform: (text) => text.replaceAll(\"<br>\", \"\\n\") },\n  inlineCode: { mark: ({ editor }) => editor.getType({ key: \"code\" }) },\n  strong: { mark: ({ editor }) => editor.getType({ key: \"bold\" }) },\n  text: {}\n};\n\n// src/lib/remark-slate/remarkTransformText.ts\nvar remarkTransformText = (node, options, inheritedMarkProps = {}) => {\n  const { editor, textRules } = options;\n  const { children, type, value } = node;\n  const textRule = textRules[type] || remarkDefaultTextRules.text;\n  const { mark, transform = (text) => text } = textRule;\n  const markProps = mark ? __spreadProps(__spreadValues({}, inheritedMarkProps), {\n    [mark({ editor })]: true\n  }) : inheritedMarkProps;\n  const childTextNodes = (children == null ? void 0 : children.flatMap(\n    (child) => remarkTransformText(child, options, markProps)\n  )) || [];\n  const currentTextNodes = value || childTextNodes.length === 0 ? [__spreadValues({ text: transform(value || \"\") }, markProps)] : [];\n  return [...currentTextNodes, ...childTextNodes];\n};\n\n// src/lib/remark-slate/remarkTransformNode.ts\nvar remarkTransformNode = (node, options) => {\n  const { type } = node;\n  if (remarkTextTypes.includes(type)) {\n    return remarkTransformText(node, options);\n  }\n  return remarkTransformElement(node, options);\n};\n\n// src/lib/remark-slate/remarkTransformElementChildren.ts\nvar remarkTransformElementChildren = (node, options) => {\n  const { children } = node;\n  if (!children || children.length === 0) {\n    return [{ text: \"\" }];\n  }\n  return children.flatMap((child) => remarkTransformNode(child, options));\n};\n\n// src/lib/remark-slate/remarkDefaultElementRules.ts\nvar remarkDefaultElementRules = {\n  blockquote: {\n    transform: (node, options) => {\n      var _a;\n      const children = ((_a = node.children) == null ? void 0 : _a.length) ? node.children.flatMap(\n        (paragraph) => remarkTransformElementChildren(paragraph, options)\n      ) : [{ text: \"\" }];\n      const flattenedChildren = children.flatMap(\n        (child) => child.type ? child.children : [child]\n      );\n      return {\n        children: flattenedChildren,\n        type: options.editor.getType({ key: \"blockquote\" })\n      };\n    }\n  },\n  code: {\n    transform: (node, options) => {\n      var _a;\n      return {\n        children: (node.value || \"\").split(\"\\n\").map((line) => ({\n          children: [{ text: line }],\n          type: options.editor.getType({ key: \"code_line\" })\n        })),\n        lang: (_a = node.lang) != null ? _a : void 0,\n        type: options.editor.getType({ key: \"code_block\" })\n      };\n    }\n  },\n  heading: {\n    transform: (node, options) => {\n      var _a;\n      const headingType = {\n        1: \"h1\",\n        2: \"h2\",\n        3: \"h3\",\n        4: \"h4\",\n        5: \"h5\",\n        6: \"h6\"\n      }[(_a = node.depth) != null ? _a : 1];\n      return {\n        children: remarkTransformElementChildren(node, options),\n        type: options.editor.getType({ key: headingType })\n      };\n    }\n  },\n  image: {\n    transform: (node, options) => ({\n      caption: [{ text: node.alt }],\n      children: [{ text: \"\" }],\n      type: options.editor.getType({ key: \"img\" }),\n      url: node.url\n    })\n  },\n  link: {\n    transform: (node, options) => ({\n      children: remarkTransformElementChildren(node, options),\n      type: options.editor.getType({ key: \"a\" }),\n      url: node.url\n    })\n  },\n  list: {\n    transform: (node, options) => {\n      if (options.indentList) {\n        const listStyleType = node.ordered ? \"decimal\" : \"disc\";\n        const parseListItems = (_node, listItems = [], indent = 1) => {\n          var _a;\n          (_a = _node.children) == null ? void 0 : _a.forEach((listItem) => {\n            if (!listItem.children) {\n              listItems.push({\n                children: remarkTransformElementChildren(listItem, options),\n                type: options.editor.getType({ key: \"p\" })\n              });\n              return listItems;\n            }\n            const [paragraph, ...subLists] = listItem.children;\n            listItems.push({\n              children: remarkTransformElementChildren(\n                paragraph || \"\",\n                options\n              ),\n              indent,\n              listStyleType,\n              type: options.editor.getType({ key: \"p\" })\n            });\n            subLists.forEach((subList) => {\n              if (subList.type === \"list\") {\n                parseListItems(subList, listItems, indent + 1);\n              } else {\n                const result = remarkTransformNode(subList, options);\n                if (Array.isArray(result)) {\n                  listItems.push(\n                    ...result.map((v) => __spreadProps(__spreadValues({}, v), { indent: indent + 1 }))\n                  );\n                } else {\n                  listItems.push(__spreadProps(__spreadValues({}, result), { indent: indent + 1 }));\n                }\n              }\n            });\n          });\n          return listItems;\n        };\n        return parseListItems(node);\n      }\n      return {\n        children: remarkTransformElementChildren(node, options),\n        type: options.editor.getType({ key: node.ordered ? \"ol\" : \"ul\" })\n      };\n    }\n  },\n  listItem: {\n    transform: (node, options) => ({\n      children: remarkTransformElementChildren(node, options).map(\n        (child) => __spreadProps(__spreadValues({}, child), {\n          type: child.type === options.editor.getType({ key: \"p\" }) ? options.editor.getType({ key: \"lic\" }) : child.type\n        })\n      ),\n      type: options.editor.getType({ key: \"li\" })\n    })\n  },\n  paragraph: {\n    transform: (node, options) => {\n      const isKeepLineBreak = options.editor.getOptions(MarkdownPlugin).splitLineBreaks;\n      const children = remarkTransformElementChildren(node, options);\n      const paragraphType = options.editor.getType({ key: \"p\" });\n      const splitBlockTypes = /* @__PURE__ */ new Set([options.editor.getType({ key: \"img\" })]);\n      const elements = [];\n      let inlineNodes = [];\n      const flushInlineNodes = () => {\n        if (inlineNodes.length > 0) {\n          elements.push({\n            children: inlineNodes,\n            type: paragraphType\n          });\n          inlineNodes = [];\n        }\n      };\n      children.forEach((child) => {\n        const { type } = child;\n        if (type && splitBlockTypes.has(type)) {\n          flushInlineNodes();\n          elements.push(child);\n        } else if (isKeepLineBreak && \"text\" in child && typeof child.text === \"string\") {\n          const isSingleLineBreak = child.text === \"\\n\" && inlineNodes.length === 0;\n          if (isSingleLineBreak) {\n            inlineNodes.push(__spreadProps(__spreadValues({}, child), { text: \"\" }));\n            flushInlineNodes();\n            return;\n          }\n          const textParts = child.text.split(\"\\n\");\n          textParts.forEach((part, index, array) => {\n            const isNotFirstPart = index > 0;\n            const isNotLastPart = index < array.length - 1;\n            if (isNotFirstPart) {\n              flushInlineNodes();\n            }\n            if (part) {\n              inlineNodes.push(__spreadProps(__spreadValues({}, child), { text: part }));\n            }\n            if (isNotLastPart) {\n              flushInlineNodes();\n            }\n          });\n        } else {\n          inlineNodes.push(child);\n        }\n      });\n      flushInlineNodes();\n      return elements;\n    }\n  },\n  table: {\n    transform: (node, options) => {\n      var _a;\n      const rows = ((_a = node.children) == null ? void 0 : _a.map((row, rowIndex) => {\n        var _a2;\n        return {\n          children: ((_a2 = row.children) == null ? void 0 : _a2.map((cell) => {\n            const cellType = rowIndex === 0 ? \"th\" : \"td\";\n            return {\n              children: remarkTransformElementChildren(cell, options).map(\n                (child) => {\n                  if (!child.type) {\n                    return {\n                      children: [child],\n                      type: options.editor.getType({ key: \"p\" })\n                    };\n                  }\n                  return child;\n                }\n              ),\n              type: options.editor.getType({ key: cellType })\n            };\n          })) || [],\n          type: options.editor.getType({ key: \"tr\" })\n        };\n      })) || [];\n      return {\n        children: rows,\n        type: options.editor.getType({ key: \"table\" })\n      };\n    }\n  },\n  thematicBreak: {\n    transform: (node, options) => ({\n      children: [{ text: \"\" }],\n      type: options.editor.getType({ key: \"hr\" })\n    })\n  }\n};\n\n// src/lib/remark-slate/remarkSplitLineBreaksCompiler.ts\nvar remarkSplitLineBreaksCompiler = (node, options) => {\n  var _a;\n  const results = [];\n  let startLine = node.position.start.line;\n  const addEmptyParagraphs = (count) => {\n    if (count > 0) {\n      results.push(\n        ...Array.from({ length: count }).map(() => {\n          return {\n            children: [{ text: \"\" }],\n            type: options.editor.getType({ key: \"p\" })\n          };\n        })\n      );\n    }\n  };\n  (_a = node == null ? void 0 : node.children) == null ? void 0 : _a.forEach((child, index) => {\n    const isFirstChild = index === 0;\n    const isLastChild = index === node.children.length - 1;\n    const emptyLinesBefore = child.position.start.line - (isFirstChild ? startLine : startLine + 1);\n    addEmptyParagraphs(emptyLinesBefore);\n    const transformValue = remarkTransformNode(child, options);\n    results.push(\n      ...Array.isArray(transformValue) ? transformValue : [transformValue]\n    );\n    if (isLastChild) {\n      const emptyLinesAfter = node.position.end.line - child.position.end.line - 1;\n      addEmptyParagraphs(emptyLinesAfter);\n    }\n    startLine = child.position.end.line;\n  });\n  return results;\n};\n\n// src/lib/remark-slate/remarkDefaultCompiler.ts\nvar remarkDefaultCompiler = (node, options) => {\n  return (node.children || []).flatMap(\n    (child) => remarkTransformNode(child, options)\n  );\n};\n\n// src/lib/remark-slate/remarkPlugin.ts\nfunction remarkPlugin(options) {\n  const shouldSplitLineBreaks = options.editor.getOptions(MarkdownPlugin).splitLineBreaks;\n  const compiler = (node) => {\n    if (shouldSplitLineBreaks) {\n      return remarkSplitLineBreaksCompiler(node, options);\n    }\n    return remarkDefaultCompiler(node, options);\n  };\n  this.compiler = compiler;\n}\n\n// src/lib/deserializer/utils/deserializeMd.ts\nvar deserializeMd = (editor, data, {\n  processor\n} = {}) => {\n  const elementRules = {};\n  const textRules = {};\n  const options = editor.getOptions(MarkdownPlugin);\n  Object.assign(elementRules, options.elementRules);\n  Object.assign(textRules, options.textRules);\n  let tree = unified().use(remarkParse);\n  if (processor) {\n    tree = processor(tree);\n  }\n  tree = tree.use(remarkGfm).use(remarkPlugin, {\n    editor,\n    elementRules,\n    indentList: options.indentList,\n    textRules\n  }).processSync(data);\n  return tree.result;\n};\n\n// src/lib/deserializer/utils/filterBreakLines.ts\nvar filterBreaklines = (item) => !item.text;\n\n// src/lib/serializer/serializeMdNode.ts\nvar isLeafNode = (node) => {\n  return typeof node.text === \"string\";\n};\nfunction serializeMdNode(node, opts) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const { customNodes, nodes } = opts;\n  opts.breakTag = (_a = opts.breakTag) != null ? _a : \"<br>\";\n  opts.ignoreParagraphNewline = (_b = opts.ignoreParagraphNewline) != null ? _b : false;\n  opts.listDepth = (_c = opts.listDepth) != null ? _c : 0;\n  opts.ulListStyleTypes = (_d = opts.ulListStyleTypes) != null ? _d : [\"disc\", \"circle\", \"square\"];\n  const markFormats = __spreadValues({\n    bold: \"**\",\n    boldItalic: \"***\",\n    boldItalicStrikethrough: \"~~***\",\n    code: \"`\",\n    italic: \"_\",\n    strikethrough: \"~~\",\n    underline: null\n  }, opts.markFormats);\n  const elOptions = isLeafNode(node) ? void 0 : Object.values(__spreadValues(__spreadValues({}, nodes), customNodes)).find((n) => {\n    return n.type === node.type;\n  });\n  const text = node.text || \"\";\n  let type = node.type || \"\";\n  let children = text;\n  if (elOptions == null ? void 0 : elOptions.skip) {\n    return \"\";\n  }\n  if (!isLeafNode(node)) {\n    children = node.children.map((c, index, all) => {\n      var _a2;\n      let ignoreParagraphNewlineProp = opts.ignoreParagraphNewline;\n      let listDepth = (_a2 = opts.listDepth) != null ? _a2 : 0;\n      const listProps = {};\n      const isIndentList = isLeafNode(c) ? false : !!c.listStyleType;\n      if (isIndentList) {\n        ignoreParagraphNewlineProp = true;\n        listProps.isList = true;\n      } else {\n        const LIST_TYPES = [nodes.ul.type, nodes.ol.type];\n        const isList = isLeafNode(c) ? false : LIST_TYPES.includes(c.type || \"\");\n        const selfIsList = LIST_TYPES.includes(node.type || \"\");\n        if (isList || selfIsList) {\n          listProps.index = index;\n          listProps.isList = true;\n          listProps.length = all.length;\n        }\n        ignoreParagraphNewlineProp = ignoreParagraphNewlineProp || isList || selfIsList;\n        listDepth = LIST_TYPES.includes(\n          c.type || \"\"\n        ) ? listDepth + 1 : listDepth;\n      }\n      if (!isLeafNode(c) && Array.isArray(node.children)) {\n        ignoreParagraphNewlineProp = true;\n      }\n      return serializeMdNode(\n        __spreadProps(__spreadValues({}, c), {\n          parent: __spreadValues({\n            type\n          }, listProps)\n        }),\n        __spreadProps(__spreadValues({}, opts), {\n          // to respect neighboring paragraphs\n          ignoreParagraphNewline: ignoreParagraphNewlineProp && // if we have c.break, never ignore empty paragraph new line\n          !c.break,\n          listDepth\n        })\n      );\n    }).join(\"\");\n  }\n  if (!opts.ignoreParagraphNewline && (text === \"\" || text === \"\\n\") && ((_e = node.parent) == null ? void 0 : _e.type) === nodes.p.type && !((_f = node.parent) == null ? void 0 : _f.isList)) {\n    type = nodes.p.type;\n    children = opts.breakTag;\n  }\n  if (children === \"\" && !((_g = node.parent) == null ? void 0 : _g.isList) && !(elOptions == null ? void 0 : elOptions.isVoid)) {\n    return;\n  }\n  if (isLeafNode(node)) {\n    if (children !== opts.breakTag) {\n      const leaf = node;\n      if (markFormats.boldItalicStrikethrough && leaf[nodes.strikethrough.type] && leaf[nodes.bold.type] && leaf[nodes.italic.type]) {\n        children = retainWhitespaceAndFormat(\n          children,\n          markFormats.boldItalicStrikethrough\n        );\n      } else if (markFormats.boldItalic && leaf[nodes.bold.type] && leaf[nodes.italic.type]) {\n        children = retainWhitespaceAndFormat(children, markFormats.boldItalic);\n      } else {\n        if (markFormats.underline && leaf[nodes.underline.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.underline);\n        }\n        if (markFormats.bold && leaf[nodes.bold.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.bold);\n        }\n        if (markFormats.italic && leaf[nodes.italic.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.italic);\n        }\n        if (markFormats.strikethrough && leaf[nodes.strikethrough.type]) {\n          children = retainWhitespaceAndFormat(\n            children,\n            markFormats.strikethrough\n          );\n        }\n        if (markFormats.code && leaf[nodes.code.type]) {\n          children = retainWhitespaceAndFormat(children, markFormats.code);\n        }\n        const leafOptions = Object.values(__spreadValues(__spreadValues({}, nodes), customNodes)).find(\n          (n) => {\n            return leaf[n.type];\n          }\n        );\n        if (leafOptions == null ? void 0 : leafOptions.serialize) {\n          children = leafOptions.serialize(children, leaf, opts);\n        }\n      }\n    }\n    return children;\n  }\n  if ((elOptions == null ? void 0 : elOptions.enabled) === false) {\n    return children;\n  }\n  return (_i = (_h = elOptions == null ? void 0 : elOptions.serialize) == null ? void 0 : _h.call(elOptions, children, node, opts)) != null ? _i : children;\n}\nfunction retainWhitespaceAndFormat(string, format) {\n  var _a;\n  const formats = Array.isArray(format) ? format : [format];\n  const start = formats[0];\n  const end = (_a = formats[1]) != null ? _a : reverseStr(formats[0]);\n  const frozenString = string.trim();\n  const children = frozenString;\n  const fullFormat = `${start}${children}${end}`;\n  if (children.length === string.length) {\n    return fullFormat;\n  }\n  const formattedString = start + children + end;\n  return string.replace(frozenString, formattedString);\n}\nvar reverseStr = (string) => string.split(\"\").reverse().join(\"\");\n\n// src/lib/serializer/defaultSerializeMdNodesOptions.ts\nvar isLeafNode2 = (node) => {\n  return typeof node.text === \"string\";\n};\nvar defaultSerializeMdNodesOptions = {\n  a: {\n    serialize: (children, node) => {\n      return `[${children}](${node.url || \"\"})`;\n    },\n    type: \"a\"\n  },\n  blockquote: {\n    serialize: (children) => `\n> ${children}\n`,\n    type: \"blockquote\"\n  },\n  bold: {\n    isLeaf: true,\n    type: \"bold\"\n  },\n  code: { isLeaf: true, type: \"code\" },\n  code_block: {\n    serialize: (children, node) => `\n\\`\\`\\`${node.language || \"\"}\n${children}\n\\`\\`\\`\n`,\n    type: \"code_block\"\n  },\n  h1: { serialize: (children) => `\n# ${children}\n`, type: \"h1\" },\n  h2: { serialize: (children) => `\n## ${children}\n`, type: \"h2\" },\n  h3: { serialize: (children) => `\n### ${children}\n`, type: \"h3\" },\n  h4: { serialize: (children) => `\n#### ${children}\n`, type: \"h4\" },\n  h5: {\n    serialize: (children) => `\n##### ${children}\n`,\n    type: \"h5\"\n  },\n  h6: {\n    serialize: (children) => `\n###### ${children}\n`,\n    type: \"h6\"\n  },\n  hr: { isVoid: true, serialize: () => \"\\n---\\n\", type: \"hr\" },\n  img: {\n    isVoid: true,\n    serialize: (_, node, opts) => {\n      var _a, _b;\n      const caption = (_b = (_a = node.caption) == null ? void 0 : _a.map((c) => serializeMdNode(c, opts)).join(\"\")) != null ? _b : \"\";\n      return `\n![${caption}](${node.url || \"\"})\n`;\n    },\n    type: \"img\"\n  },\n  italic: { isLeaf: true, type: \"italic\" },\n  li: {\n    serialize: (children, node, { listDepth = 0, nodes }) => {\n      var _a, _b, _c;\n      const isOL = node && ((_a = node.parent) == null ? void 0 : _a.type) === nodes.ol.type;\n      let spacer = \"\";\n      for (let k = 0; listDepth > k; k++) {\n        spacer += isOL ? \"   \" : \"  \";\n      }\n      const isNewLine = node && (((_b = node.parent) == null ? void 0 : _b.type) === nodes.ol.type || ((_c = node.parent) == null ? void 0 : _c.type) === nodes.ul.type);\n      const emptyBefore = isNewLine ? \"\\n\" : \"\";\n      return `${emptyBefore}${spacer}${isOL ? \"1.\" : \"-\"} ${children}`;\n    },\n    type: \"li\"\n  },\n  ol: {\n    serialize: (children, _, { listDepth }) => {\n      const newLineAfter = listDepth === 0 ? \"\\n\" : \"\";\n      return `${children}${newLineAfter}`;\n    },\n    type: \"ol\"\n  },\n  p: {\n    serialize: (children, node, { ulListStyleTypes = [] }) => {\n      var _a;\n      const listStyleType = node.listStyleType;\n      if (listStyleType) {\n        let pre = \"\";\n        const listDepth = node.indent ? node.indent - 1 : 0;\n        pre += \"  \".repeat(listDepth);\n        const listStart = (_a = node.listStart) != null ? _a : 1;\n        const isOL = !ulListStyleTypes.includes(listStyleType);\n        const treatAsLeaf = node.children.length === 1 && isLeafNode2(node.children[0]);\n        if (isOL && listDepth > 0) {\n          pre += \" \";\n        }\n        return `${pre}${isOL ? listStart + \".\" : \"-\"} ${children}${treatAsLeaf ? \"\\n\" : \"\"}`;\n      }\n      return `\n${children}\n`;\n    },\n    type: \"p\"\n  },\n  strikethrough: { isLeaf: true, type: \"strikethrough\" },\n  ul: {\n    serialize: (children, _, { listDepth }) => {\n      const newLineAfter = listDepth === 0 ? \"\\n\" : \"\";\n      return `${children}${newLineAfter}`;\n    },\n    type: \"ul\"\n  },\n  underline: { isLeaf: true, type: \"underline\" }\n};\n\n// src/lib/serializer/serializeInlineMd.ts\nimport { getNodeString } from \"@udecode/plate-common\";\n\n// src/lib/serializer/serializeMdNodes.ts\nimport merge from \"lodash/merge.js\";\nvar serializeMdNodes = (nodes, options = {}) => {\n  Object.keys(options.customNodes || {}).forEach((key) => {\n    if (options.customNodes[key]) {\n      if (!options.customNodes[key].type) {\n        options.customNodes[key].type = key;\n      }\n    } else {\n      options.customNodes[key] = { type: key };\n    }\n  });\n  const optionsNodes = merge(\n    defaultSerializeMdNodesOptions,\n    options.nodes\n  );\n  if (!nodes || nodes.length === 0 || nodes.length === 1 && nodes[0].type === optionsNodes.p.type && nodes[0].children[0].text === \"\") {\n    return \"\";\n  }\n  return nodes == null ? void 0 : nodes.map(\n    (v) => serializeMdNode(v, __spreadProps(__spreadValues({}, options), {\n      customNodes: options.customNodes,\n      nodes: optionsNodes\n    }))\n  ).join(\"\").trim();\n};\n\n// src/lib/serializer/serializeInlineMd.ts\nvar serializeInlineMd = (nodes) => {\n  if (nodes.length === 0) return \"\";\n  let leadingSpaces = \"\";\n  const firstNodeText = getNodeString(nodes[0]);\n  const leadingMatch = /^\\s*/.exec(firstNodeText);\n  leadingSpaces = leadingMatch ? leadingMatch[0] : \"\";\n  const serializedContent = serializeMdNodes(nodes);\n  return leadingSpaces + serializedContent;\n};\n\n// src/lib/serializer/serializeMd.ts\nimport merge2 from \"lodash/merge.js\";\nvar serializeMd = (editor, options) => {\n  const plugins = editor.pluginList.filter(\n    (p) => p.node.isElement || p.node.isLeaf\n  );\n  const nodes = plugins.reduce(\n    (acc, plugin) => {\n      acc[plugin.key] = {\n        isLeaf: plugin.node.isLeaf,\n        isVoid: plugin.node.isVoid,\n        type: plugin.node.type\n      };\n      return acc;\n    },\n    {}\n  );\n  return serializeMdNodes(editor.children, __spreadProps(__spreadValues({}, options), {\n    nodes: merge2(nodes, options == null ? void 0 : options.nodes)\n  }));\n};\n\n// src/lib/MarkdownPlugin.ts\nvar MarkdownPlugin = createTSlatePlugin({\n  key: \"markdown\",\n  options: {\n    elementRules: remarkDefaultElementRules,\n    indentList: false,\n    splitLineBreaks: false,\n    textRules: remarkDefaultTextRules\n  }\n}).extendApi(({ editor }) => ({\n  deserialize: bindFirst(deserializeMd, editor),\n  serialize: bindFirst(serializeMd, editor)\n})).extend(({ api }) => ({\n  parser: {\n    deserialize: ({ data }) => api.markdown.deserialize(data),\n    format: \"text/plain\",\n    query: ({ data, dataTransfer }) => {\n      const htmlData = dataTransfer.getData(\"text/html\");\n      if (htmlData) return false;\n      const { files } = dataTransfer;\n      if (!(files == null ? void 0 : files.length) && // if content is simply a URL pass through to not break LinkPlugin\n      isUrl(data)) {\n        return false;\n      }\n      return true;\n    }\n  }\n}));\nexport {\n  MarkdownPlugin,\n  defaultSerializeMdNodesOptions,\n  deserializeInlineMd,\n  deserializeMd,\n  filterBreaklines,\n  remarkDefaultElementRules,\n  remarkDefaultTextRules,\n  remarkPlugin,\n  remarkSplitLineBreaksCompiler,\n  remarkTextTypes,\n  remarkTransformElement,\n  remarkTransformElementChildren,\n  remarkTransformNode,\n  remarkTransformText,\n  retainWhitespaceAndFormat,\n  serializeInlineMd,\n  serializeMd,\n  serializeMdNode,\n  serializeMdNodes,\n  stripMarkdown,\n  stripMarkdownBlocks,\n  stripMarkdownInline\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/lib/extractSelectableIds.ts\nvar extractSelectableIds = (els) => {\n  return els.map((v) => v.dataset.blockId);\n};\nvar extractSelectableId = (el) => el.dataset.blockId;\n\n// src/lib/getAboveDomNode.ts\nvar getSelectedDomNode = (id) => {\n  return document.querySelector(`.slate-selectable[data-block-id=\"${id}\"]`);\n};\nvar getAllSelectableDomNode = () => {\n  return document.querySelectorAll(`.slate-selectable`);\n};\n\n// src/lib/isSelecting.ts\nimport { isSelectionExpanded } from \"@udecode/plate-common\";\n\n// src/react/BlockMenuPlugin.tsx\nimport { createTPlatePlugin } from \"@udecode/plate-common/react\";\nvar BLOCK_CONTEXT_MENU_ID = \"context\";\nvar BlockMenuPlugin = createTPlatePlugin({\n  key: \"blockMenu\",\n  options: {\n    openId: null,\n    position: {\n      x: -1e4,\n      y: -1e4\n    }\n  }\n}).extendApi(({ setOption, setOptions }) => ({\n  hide: () => {\n    setOptions({\n      openId: null,\n      position: {\n        x: -1e4,\n        y: -1e4\n      }\n    });\n  },\n  show: (id, position) => {\n    if (position) {\n      setOptions({\n        openId: id,\n        position\n      });\n    } else {\n      setOption(\"openId\", id);\n    }\n  }\n})).extendApi(({ api, editor }) => ({\n  showContextMenu: (blockId, position) => {\n    var _a;\n    (_a = editor.getApi({ key: \"blockSelection\" }).blockSelection) == null ? void 0 : _a.addSelectedRow(blockId);\n    api.blockMenu.show(BLOCK_CONTEXT_MENU_ID, position);\n  }\n})).extend(({ api }) => ({\n  handlers: {\n    onMouseDown: ({ event, getOptions }) => {\n      if (event.button === 0 && getOptions().openId) {\n        event.preventDefault();\n        api.blockMenu.hide();\n      }\n      if (event.button === 2) event.preventDefault();\n    }\n  }\n}));\n\n// src/react/BlockSelectionPlugin.tsx\nimport { bindFirst, getNodeEntries } from \"@udecode/plate-common\";\nimport { createTPlatePlugin as createTPlatePlugin2 } from \"@udecode/plate-common/react\";\n\n// src/react/components/BlockSelectionAfterEditable.tsx\nimport React3 from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  findNode,\n  getEndPoint as getEndPoint2,\n  getNextNode,\n  getPreviousNode,\n  isHotkey,\n  removeNodes\n} from \"@udecode/plate-common\";\nimport {\n  focusEditor as focusEditor2,\n  isEditorReadOnly,\n  useEditorPlugin as useEditorPlugin3,\n  useEditorRef\n} from \"@udecode/plate-common/react\";\n\n// src/react/hooks/useBlockSelectable.ts\nimport React from \"react\";\nimport { getAboveNode, isVoid } from \"@udecode/plate-common\";\nimport {\n  findNodePath,\n  useEditorPlugin,\n  useElement\n} from \"@udecode/plate-common/react\";\nimport { Path } from \"slate\";\nvar useBlockSelectable = () => {\n  const element = useElement();\n  const { api, editor, getOption, getOptions } = useEditorPlugin(BlockSelectionPlugin);\n  const path = React.useMemo(\n    () => findNodePath(editor, element),\n    [editor, element]\n  );\n  const id = element == null ? void 0 : element.id;\n  return {\n    props: {\n      className: \"slate-selectable\",\n      onContextMenu: (event) => {\n        var _a, _b;\n        if (!element || !path) return;\n        const { enableContextMenu } = getOptions();\n        if (!enableContextMenu) return;\n        if ((_a = editor.selection) == null ? void 0 : _a.focus) {\n          const nodeEntry = getAboveNode(editor);\n          if (nodeEntry && Path.isCommon(path, nodeEntry[1])) {\n            const id2 = nodeEntry[0].id;\n            const isSelected = getOption(\"isSelected\", id2);\n            const isOpenAlways = ((_b = event.target.dataset) == null ? void 0 : _b.plateOpenContextMenu) === \"true\";\n            if (!isSelected && !isVoid(editor, nodeEntry[0]) && !isOpenAlways) {\n              return event.stopPropagation();\n            }\n          }\n        }\n        if (id) {\n          api.blockSelection.addSelectedRow(id, {\n            clear: !(event == null ? void 0 : event.shiftKey)\n          });\n        }\n      }\n    }\n  };\n};\n\n// src/react/hooks/useSelectionArea.ts\nimport React2 from \"react\";\nimport { deselectEditor, useEditorPlugin as useEditorPlugin2 } from \"@udecode/plate-common/react\";\n\n// src/internal/EventEmitter.ts\nvar EventTarget = class {\n  constructor() {\n    this._listeners = /* @__PURE__ */ new Map();\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    this.emit = this.dispatchEvent;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    this.off = this.removeEventListener;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    this.on = this.addEventListener;\n  }\n  addEventListener(event, cb) {\n    var _a;\n    const set = (_a = this._listeners.get(event)) != null ? _a : /* @__PURE__ */ new Set();\n    this._listeners.set(event, set);\n    set.add(cb);\n    return this;\n  }\n  // Let's also support on, off and emit like node\n  dispatchEvent(event, ...data) {\n    var _a;\n    let ok = true;\n    for (const cb of (_a = this._listeners.get(event)) != null ? _a : []) {\n      ok = cb(...data) !== false && ok;\n    }\n    return ok;\n  }\n  removeEventListener(event, cb) {\n    var _a;\n    (_a = this._listeners.get(event)) == null ? void 0 : _a.delete(cb);\n    return this;\n  }\n  unbindAllListeners() {\n    this._listeners.clear();\n  }\n};\n\n// src/internal/utils/css.ts\nvar unitify = (val, unit = \"px\") => {\n  return typeof val === \"number\" ? val + unit : val;\n};\nfunction css({ style }, attr, val) {\n  if (typeof attr === \"object\") {\n    for (const [key, value] of Object.entries(attr)) {\n      value !== void 0 && (style[key] = unitify(value));\n    }\n  } else if (val !== void 0) {\n    style[attr] = unitify(val);\n  }\n}\n\n// src/internal/utils/events.ts\nvar eventListener = (method) => (items, events, fn, options = {}) => {\n  if (items instanceof HTMLCollection || items instanceof NodeList) {\n    items = Array.from(items);\n  } else if (!Array.isArray(items)) {\n    items = [items];\n  }\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  for (const el of items) {\n    if (el) {\n      for (const ev of events) {\n        el[method](ev, fn, __spreadValues({ capture: false }, options));\n      }\n    }\n  }\n  return [items, events, fn, options];\n};\nvar on = eventListener(\"addEventListener\");\nvar off = eventListener(\"removeEventListener\");\nvar simplifyEvent = (evt) => {\n  var _a, _b;\n  const { clientX, clientY, target } = (_b = (_a = evt.touches) == null ? void 0 : _a[0]) != null ? _b : evt;\n  return { target, x: clientX, y: clientY };\n};\n\n// src/internal/utils/intersects.ts\nfunction intersectsScroll(a, b, mode = \"touch\", container) {\n  const containerRect = container.getBoundingClientRect();\n  const scrollLeft = container.scrollLeft;\n  const scrollTop = container.scrollTop;\n  return a.right >= b.left - containerRect.left && a.left + containerRect.left <= b.right + scrollLeft && // 94 is container to top\n  a.bottom - scrollTop >= b.top - containerRect.top && a.top <= b.bottom - containerRect.top + scrollTop;\n}\n\n// src/internal/utils/selectAll.ts\nfunction selectAll(selector, doc = document) {\n  const list = Array.isArray(selector) ? selector : [selector];\n  let nodes = [];\n  for (let i = 0, l = list.length; i < l; i++) {\n    const item = list[i];\n    if (typeof item === \"string\") {\n      nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n    } else if (item instanceof Element) {\n      nodes.push(item);\n    }\n  }\n  return nodes;\n}\n\n// src/internal/utils/constants.ts\nvar isTouchDevice = () => matchMedia(\"(hover: none), (pointer: coarse)\").matches;\nvar isSafariBrowser = () => \"safari\" in window;\n\n// src/internal/utils/frames.ts\nvar frames = (fn) => {\n  let previousArgs;\n  let frameId = -1;\n  let lock = false;\n  return {\n    cancel() {\n      cancelAnimationFrame(frameId);\n      lock = false;\n    },\n    next(...args) {\n      previousArgs = args;\n      if (!lock) {\n        lock = true;\n        frameId = requestAnimationFrame(() => {\n          fn(...previousArgs);\n          lock = false;\n        });\n      }\n    }\n  };\n};\n\n// src/internal/utils/shouldTrigger.ts\nfunction shouldTrigger(event, triggers) {\n  for (const trigger of triggers) {\n    if (typeof trigger === \"number\") {\n      return event.button === trigger;\n    }\n    if (typeof trigger === \"object\") {\n      const reqButtonIsPressed = trigger.button === event.button;\n      const allReqModifiersArePressed = trigger.modifiers.every((modifier) => {\n        switch (modifier) {\n          case \"alt\": {\n            return event.altKey;\n          }\n          case \"ctrl\": {\n            return event.ctrlKey || event.metaKey;\n          }\n          case \"shift\": {\n            return event.shiftKey;\n          }\n        }\n      });\n      return reqButtonIsPressed && allReqModifiersArePressed;\n    }\n  }\n  return false;\n}\n\n// src/internal/SelectionArea.ts\nvar { abs, ceil, max, min } = Math;\nvar SelectionArea = class extends EventTarget {\n  constructor(opt) {\n    var _a, _b, _c, _d, _e;\n    super();\n    this._areaClientLocation = { x1: 0, x2: 0, y1: 0, y2: 0 };\n    // Dynamically constructed area rect\n    this._areaLocation = { x1: 0, x2: 0, y1: 0, y2: 0 };\n    // Caches the position of the selection-area\n    this._areaRect = new DOMRect();\n    this._initScrollDelta = { x: 0, y: 0 };\n    // Is getting set on movement.\n    this._scrollAvailable = true;\n    // The scroll distance of scrollElement (body or html) relative to the initial scroll position\n    this._scrollDelta = { x: 0, y: 0 };\n    this._scrollSpeed = { x: 0, y: 0 };\n    // If a single click is being performed.\n    this._scrollingActive = false;\n    this._selectables = [];\n    // Selection store\n    this._selection = {\n      changed: {\n        added: [],\n        // Added elements since last selection\n        removed: []\n        // Removed elements since last selection\n      },\n      selected: [],\n      stored: [],\n      touched: []\n    };\n    // It's a single-click until the user dragged the mouse.\n    this._singleClick = true;\n    this.wheelTimer = null;\n    this.disable = this._bindStartEvents.bind(this, false);\n    this.enable = this._bindStartEvents;\n    this._options = __spreadProps(__spreadValues({\n      boundaries: [\"html\"],\n      container: \"body\",\n      document: window.document,\n      selectables: [],\n      selectionAreaClass: \"selection-area\",\n      startAreas: [\"html\"]\n    }, opt), {\n      behaviour: __spreadProps(__spreadValues({\n        // TODO: not implemented\n        intersect: \"touch\",\n        overlap: \"invert\",\n        triggers: [0]\n      }, opt.behaviour), {\n        scrolling: __spreadProps(__spreadValues({\n          manualSpeed: 750,\n          speedDivider: 0.7\n        }, (_a = opt.behaviour) == null ? void 0 : _a.scrolling), {\n          startScrollMargins: __spreadValues({\n            x: 20,\n            y: 40\n          }, (_c = (_b = opt.behaviour) == null ? void 0 : _b.scrolling) == null ? void 0 : _c.startScrollMargins)\n        }),\n        startThreshold: ((_d = opt.behaviour) == null ? void 0 : _d.startThreshold) ? typeof opt.behaviour.startThreshold === \"number\" ? opt.behaviour.startThreshold : __spreadValues({ x: 4, y: 4 }, opt.behaviour.startThreshold) : { x: 4, y: 4 }\n      }),\n      features: __spreadProps(__spreadValues({\n        range: true,\n        touch: true\n      }, opt.features), {\n        singleTap: __spreadValues({\n          allow: true,\n          intersect: \"native\"\n        }, (_e = opt.features) == null ? void 0 : _e.singleTap)\n      })\n    });\n    for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n      if (typeof this[key] === \"function\") {\n        this[key] = this[key].bind(this);\n      }\n    }\n    const { document: document2, selectionAreaClass } = this._options;\n    this._area = document2.createElement(\"div\");\n    this._area.classList.add(selectionAreaClass);\n    css(this._area, {\n      left: 0,\n      position: \"absolute\",\n      top: 0,\n      willChange: \"top, left, bottom, right, width, height\"\n    });\n    this._frame = frames((evt) => {\n      this._recalculateSelectionAreaRect();\n      this._updateElementSelection();\n      this._emitEvent(\"move\", evt);\n      this._redrawSelectionArea();\n    });\n    this.enable();\n  }\n  _bindStartEvents(activate = true) {\n    const { document: document2, features } = this._options;\n    const fn = activate ? on : off;\n    fn(document2, \"mousedown\", this._onTapStart);\n    features.touch && fn(document2, \"touchstart\", this._onTapStart, {\n      passive: false\n    });\n  }\n  _delayedTapMove(evt) {\n    const {\n      behaviour: { startThreshold },\n      document: document2\n    } = this._options;\n    const { x1, y1 } = this._areaLocation;\n    const { x1: clientX, y1: clientY } = this._areaClientLocation;\n    const { x, y } = simplifyEvent(evt);\n    if (\n      // Single number for both coordinates\n      typeof startThreshold === \"number\" && abs(x + y - (clientX + clientY)) >= startThreshold || // Different x and y threshold\n      typeof startThreshold === \"object\" && abs(x - x1) >= startThreshold.x || abs(y - y1) >= startThreshold.y\n    ) {\n      off(document2, [\"mousemove\", \"touchmove\"], this._delayedTapMove, {\n        passive: false\n      });\n      if (this._emitEvent(\"beforedrag\", evt) === false) {\n        off(document2, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n        return;\n      }\n      on(document2, [\"mousemove\", \"touchmove\"], this._onTapMove, {\n        passive: false\n      });\n      css(this._area, \"display\", \"block\");\n      this._container.append(this._area);\n      this.resolveSelectables();\n      this._singleClick = false;\n      on(this._container, \"wheel\", this._manualScroll, { passive: true });\n      this._setupSelectionArea();\n      this._emitEvent(\"start\", evt);\n      this._onTapMove(evt);\n    }\n    this._handleMoveEvent(evt);\n  }\n  _emitEvent(name, evt) {\n    return this.emit(name, {\n      event: evt,\n      selection: this,\n      store: this._selection\n    });\n  }\n  _handleMoveEvent(evt) {\n    const { features } = this._options;\n    if (features.touch && isTouchDevice() || this._scrollAvailable && isSafariBrowser()) {\n      evt.preventDefault();\n    }\n  }\n  _keepSelection() {\n    const { _options, _selection } = this;\n    const { changed, selected, stored, touched } = _selection;\n    const addedElements = selected.filter((el) => !stored.includes(el));\n    switch (_options.behaviour.overlap) {\n      case \"drop\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !touched.includes(el))\n          // Elements not touched\n        ];\n        break;\n      }\n      case \"invert\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !changed.removed.includes(el))\n          // Elements not removed from selection\n        ];\n        break;\n      }\n      case \"keep\": {\n        _selection.stored = [\n          ...stored,\n          ...selected.filter((el) => !stored.includes(el))\n          // Newly added\n        ];\n        break;\n      }\n    }\n  }\n  _manualScroll(evt) {\n    this.wheelTimer && clearTimeout(this.wheelTimer);\n    const { x, y } = simplifyEvent(evt);\n    this.wheelTimer = setTimeout(() => {\n      this._areaClientLocation.x2 = x;\n      this._areaClientLocation.y2 = y;\n      const Ry = y - this._containerRect.top;\n      const Rx = x - this._containerRect.left;\n      this._areaLocation.x2 = Rx + this._container.scrollLeft;\n      this._areaLocation.y2 = Ry + this._container.scrollTop;\n      this._frame.next(null);\n    }, 100);\n  }\n  _onScroll(evt) {\n    const { document: document2 } = this._options;\n    this.wheelTimer && clearTimeout(this.wheelTimer);\n    const { x, y } = simplifyEvent(evt);\n    this.wheelTimer = setTimeout(() => {\n      this._areaClientLocation.x2 = x;\n      this._areaClientLocation.y2 = y;\n      const deltaY = y - this._containerRect.top + this._container.scrollTop + document2.scrollingElement.scrollTop - this._initScrollDelta.y;\n      const deltaX = x - this._containerRect.left + this._container.scrollLeft + document2.scrollingElement.scrollLeft;\n      this._scrollDelta.y = document2.scrollingElement.scrollTop - this._initScrollDelta.y;\n      this._scrollDelta.x = document2.scrollingElement.scrollLeft - this._initScrollDelta.x;\n      this._areaLocation.y2 = deltaY;\n      this._areaLocation.x2 = deltaX;\n      this._frame.next(null);\n    }, 100);\n  }\n  _onSingleTap(evt) {\n    const {\n      range,\n      singleTap: { intersect }\n    } = this._options.features;\n    const e = simplifyEvent(evt);\n    let target;\n    if (intersect === \"native\") {\n      target = e.target;\n    } else if (intersect === \"touch\") {\n      this.resolveSelectables();\n      const { x, y } = e;\n      target = this._selectables.find((v) => {\n        const { bottom, left, right, top } = v.getBoundingClientRect();\n        return x < right && x > left && y < bottom && y > top;\n      });\n    }\n    if (!target) {\n      return;\n    }\n    this.resolveSelectables();\n    while (!this._selectables.includes(target)) {\n      if (!target.parentElement) {\n        return;\n      }\n      target = target.parentElement;\n    }\n    const { stored } = this._selection;\n    this._emitEvent(\"start\", evt);\n    if (evt.shiftKey && range && this._latestElement) {\n      const reference = this._latestElement;\n      const [preceding, following] = reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\n      const rangeItems = [\n        ...this._selectables.filter(\n          (el) => el.compareDocumentPosition(preceding) & 4 && el.compareDocumentPosition(following) & 2\n        ),\n        preceding,\n        following\n      ];\n      this.select(rangeItems);\n      this._latestElement = reference;\n    } else if (stored.includes(target) && (stored.length === 1 || evt.ctrlKey || stored.every((v) => this._selection.stored.includes(v)))) {\n      this.deselect(target);\n    } else {\n      this.select(target);\n      this._latestElement = target;\n    }\n  }\n  _onTapMove(evt) {\n    const { x, y } = simplifyEvent(evt);\n    const {\n      _areaClientLocation,\n      _areaLocation,\n      _frame,\n      _options,\n      _scrollSpeed\n    } = this;\n    const { speedDivider } = _options.behaviour.scrolling;\n    const Ry = y - this._containerRect.top;\n    const Rx = x - this._containerRect.left;\n    if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n      this._scrollingActive = true;\n      const scroll = () => {\n        if (!_scrollSpeed.x && !_scrollSpeed.y) {\n          this._scrollingActive = false;\n          return;\n        }\n        if (_scrollSpeed.y) {\n          this._container.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n          _areaLocation.y2 = Ry;\n        }\n        if (_scrollSpeed.x) {\n          this._container.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n          _areaLocation.x2 = Rx;\n        }\n        _frame.next(evt);\n        requestAnimationFrame(scroll);\n      };\n      requestAnimationFrame(scroll);\n    } else {\n      _areaLocation.x2 = Rx + this._container.scrollLeft + this._scrollDelta.x;\n      _areaLocation.y2 = Ry + this._container.scrollTop + this._scrollDelta.y;\n      _areaClientLocation.x2 = x;\n      _areaClientLocation.y2 = y;\n      _frame.next(evt);\n    }\n    this._handleMoveEvent(evt);\n  }\n  _onTapStart(evt, silent = false) {\n    var _a;\n    const { container, document: document2 } = this._options;\n    const { target, x, y } = simplifyEvent(evt);\n    this._container = selectAll(container, document2)[0];\n    if (!this._container) return;\n    if (this._container.contains(target) && target.dataset.slateEditor !== \"true\" && target.dataset.plateSelectable !== \"true\")\n      return;\n    this._containerRect = this._container.getBoundingClientRect();\n    const Rx = x - this._containerRect.left + this._container.scrollLeft;\n    const Ry = y - this._containerRect.top + this._container.scrollTop;\n    const { _options } = this;\n    if (evt instanceof MouseEvent && !shouldTrigger(evt, _options.behaviour.triggers)) {\n      return;\n    }\n    const startAreas = selectAll(_options.startAreas, _options.document);\n    const resolvedBoundaries = selectAll(\n      _options.boundaries,\n      _options.document\n    );\n    const evtPath = evt.composedPath();\n    if (!this._container || // eslint-disable-next-line unicorn/prefer-array-some\n    !startAreas.find((el) => evtPath.includes(el)) || // eslint-disable-next-line unicorn/prefer-array-some\n    !resolvedBoundaries.find((el) => evtPath.includes(el))) {\n      return;\n    }\n    if (!silent && this._emitEvent(\"beforestart\", evt) === false) {\n      return;\n    }\n    this._areaLocation = { x1: Rx, x2: 0, y1: Ry, y2: 0 };\n    this._areaClientLocation = { x1: x, x2: 0, y1: y, y2: 0 };\n    const scrollElement = (_a = document2.scrollingElement) != null ? _a : document2.body;\n    this._initScrollDelta = {\n      x: scrollElement.scrollLeft,\n      y: scrollElement.scrollTop\n    };\n    this._singleClick = true;\n    this.clearSelection(false, true);\n    on(document2, [\"touchmove\", \"mousemove\"], this._delayedTapMove, {\n      passive: false\n    });\n    on(document2, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    on(document2, \"wheel\", this._onScroll, { passive: false });\n  }\n  _onTapStop(evt, silent) {\n    var _a;\n    const { document: document2, features } = this._options;\n    const { _singleClick } = this;\n    off(document2, [\"mousemove\", \"touchmove\"], this._delayedTapMove);\n    off(document2, [\"touchmove\", \"mousemove\"], this._onTapMove);\n    off(document2, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    off(document2, \"wheel\", this._onScroll);\n    this._keepSelection();\n    if (evt && _singleClick && features.singleTap.allow) {\n      this._onSingleTap(evt);\n    } else if (!_singleClick && !silent) {\n      this._updateElementSelection();\n      this._emitEvent(\"stop\", evt);\n    }\n    this._scrollSpeed.x = 0;\n    this._scrollSpeed.y = 0;\n    this._scrollDelta.x = 0;\n    this._scrollDelta.y = 0;\n    off(this._container, \"wheel\", this._manualScroll, { passive: true });\n    this._area.remove();\n    (_a = this._frame) == null ? void 0 : _a.cancel();\n    css(this._area, \"display\", \"none\");\n  }\n  _recalculateSelectionAreaRect() {\n    const {\n      _areaClientLocation,\n      _areaLocation,\n      _areaRect,\n      _container,\n      _containerRect,\n      _scrollSpeed\n    } = this;\n    const {\n      clientHeight,\n      clientWidth,\n      scrollHeight,\n      scrollLeft,\n      scrollTop,\n      scrollWidth\n    } = _container;\n    const { x1, y1 } = _areaLocation;\n    let { x2, y2 } = _areaLocation;\n    const {\n      behaviour: {\n        scrolling: { startScrollMargins }\n      }\n    } = this._options;\n    if (_areaClientLocation.x2 + this._scrollDelta.x < _containerRect.left + startScrollMargins.x) {\n      _scrollSpeed.x = scrollLeft ? -abs(\n        _containerRect.left - _areaClientLocation.x2 - this._scrollDelta.x\n      ) : 0;\n      x2 = max(x2, this._container.scrollLeft);\n    } else if (_areaClientLocation.x2 + this._scrollDelta.x > _containerRect.right - startScrollMargins.x) {\n      _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(\n        _containerRect.left + this._container.clientWidth - _areaClientLocation.x2 - this._scrollDelta.x\n      ) : 0;\n      x2 = clientWidth + scrollLeft;\n    } else {\n      _scrollSpeed.x = 0;\n    }\n    if (_areaClientLocation.y2 + this._scrollDelta.y < _containerRect.top + startScrollMargins.y) {\n      _scrollSpeed.y = scrollTop ? -abs(\n        _containerRect.top - _areaClientLocation.y2 - this._scrollDelta.y + startScrollMargins.y\n      ) : 0;\n      y2 = max(y2, this._container.scrollTop);\n    } else if (_areaClientLocation.y2 + this._scrollDelta.y > _containerRect.bottom - startScrollMargins.y) {\n      _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(\n        _areaClientLocation.y2 + this._scrollDelta.y - (_containerRect.top + this._container.clientHeight - startScrollMargins.y)\n      ) : 0;\n      y2 = clientHeight + scrollTop;\n    } else {\n      _scrollSpeed.y = 0;\n    }\n    const x3 = min(x1, x2);\n    const y3 = min(y1, y2);\n    const x4 = max(x1, x2);\n    const y4 = max(y1, y2);\n    _areaRect.x = x3;\n    _areaRect.y = y3;\n    _areaRect.width = x4 - x3;\n    _areaRect.height = y4 - y3;\n  }\n  _redrawSelectionArea() {\n    const { height, width, x, y } = this._areaRect;\n    const { style } = this._area;\n    style.left = `${x}px`;\n    style.top = `${y}px`;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n  }\n  _setupSelectionArea() {\n  }\n  _updateElementSelection() {\n    const { _areaRect, _options, _selectables, _selection } = this;\n    const { selected, stored, touched } = _selection;\n    const { intersect, overlap } = _options.behaviour;\n    const invert = overlap === \"invert\";\n    const newlyTouched = [];\n    const added = [];\n    const removed = [];\n    for (let i = 0; i < _selectables.length; i++) {\n      const node = _selectables[i];\n      if (intersectsScroll(\n        _areaRect,\n        node.getBoundingClientRect(),\n        intersect,\n        this._container\n      )) {\n        if (!selected.includes(node)) {\n          if (invert && stored.includes(node)) {\n            removed.push(node);\n            continue;\n          } else {\n            added.push(node);\n          }\n        } else if (stored.includes(node) && !touched.includes(node)) {\n          touched.push(node);\n        }\n        newlyTouched.push(node);\n      }\n    }\n    if (invert) {\n      added.push(...stored.filter((v) => !selected.includes(v)));\n    }\n    const keep = overlap === \"keep\";\n    for (let i = 0; i < selected.length; i++) {\n      const node = selected[i];\n      if (!newlyTouched.includes(node) && !// Check if user wants to keep previously selected elements, e.g.\n      // not make them part of the current selection as soon as they're touched.\n      (keep && stored.includes(node))) {\n        removed.push(node);\n      }\n    }\n    _selection.selected = newlyTouched;\n    _selection.changed = { added, removed };\n    this._latestElement = void 0;\n  }\n  /**\n   * Cancel the current selection process.\n   *\n   * @param keepEvent {boolean} true to fire a stop event after cancel.\n   */\n  cancel(keepEvent = false) {\n    this._onTapStop(null, !keepEvent);\n  }\n  /**\n   * Same as deselect, but for all elements currently selected.\n   *\n   * @param includeStored If the store should also get cleared\n   * @param quiet If move / stop events should be fired\n   */\n  clearSelection(includeStored = true, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n    changed.added = [];\n    changed.removed.push(...selected, ...includeStored ? stored : []);\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n    this._selection = {\n      changed: { added: [], removed: [] },\n      selected: [],\n      stored: includeStored ? [] : stored,\n      touched: []\n    };\n  }\n  /**\n   * Removes a particular element from the selection.\n   *\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  deselect(query, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => selected.includes(el) || stored.includes(el)\n    );\n    if (elements.length === 0) {\n      return;\n    }\n    this._selection.stored = stored.filter((el) => !elements.includes(el));\n    this._selection.selected = selected.filter((el) => !elements.includes(el));\n    this._selection.changed.added = [];\n    this._selection.changed.removed.push(\n      ...elements.filter((el) => !changed.removed.includes(el))\n    );\n    this._latestElement = void 0;\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n  }\n  /** Unbinds all events and removes the area-element. */\n  destroy() {\n    this.cancel();\n    this.disable();\n    super.unbindAllListeners();\n  }\n  /** @returns {Array} Selected elements */\n  getSelection() {\n    return this._selection.stored;\n  }\n  /** @returns {HTMLElement} The selection area element */\n  getSelectionArea() {\n    return this._area;\n  }\n  /**\n   * Can be used if during a selection elements have been added. Will update\n   * everything which can be selected.\n   */\n  resolveSelectables() {\n    this._selectables = selectAll(\n      this._options.selectables,\n      this._options.document\n    );\n  }\n  /**\n   * Adds elements to the selection\n   *\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  select(query, quiet = false) {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => !selected.includes(el) && !stored.includes(el)\n    );\n    stored.push(...elements);\n    selected.push(...elements);\n    changed.added.push(...elements);\n    changed.removed = [];\n    this._latestElement = void 0;\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n    return elements;\n  }\n  /**\n   * Manually triggers the start of a selection\n   *\n   * @param evt A MouseEvent / TouchEvent -like object\n   * @param silent If beforestart should be fired,\n   */\n  trigger(evt, silent = true) {\n    this._onTapStart(evt, silent);\n  }\n};\n\n// src/react/hooks/useSelectionArea.ts\nvar useSelectionArea = () => {\n  const { api, editor, getOptions, setOption } = useEditorPlugin2(BlockSelectionPlugin);\n  const { areaOptions } = getOptions();\n  React2.useEffect(() => {\n    const selection = new SelectionArea(__spreadValues({\n      boundaries: `#${editor.uid}`,\n      container: `#${editor.uid}`,\n      document: window.document,\n      selectables: `#${editor.uid} .slate-selectable`,\n      selectionAreaClass: \"slate-selection-area\"\n    }, areaOptions)).on(\"beforestart\", () => {\n      setOption(\"isSelecting\", false);\n    }).on(\"start\", ({ event }) => {\n      setOption(\"isSelectionAreaVisible\", true);\n      deselectEditor(editor);\n      if (!(event == null ? void 0 : event.shiftKey)) {\n        selection.clearSelection();\n        api.blockSelection.resetSelectedIds();\n      }\n    }).on(\"move\", ({ store: { changed } }) => {\n      if (!getOptions().isSelectionAreaVisible) {\n        setOption(\"isSelectionAreaVisible\", true);\n      }\n      if (changed.added.length === 0 && changed.removed.length === 0) return;\n      api.blockSelection.setSelectedIds(changed);\n    }).on(\"stop\", () => {\n      setOption(\"isSelectionAreaVisible\", false);\n    });\n    return () => selection.destroy();\n  }, []);\n};\n\n// src/react/utils/copySelectedBlocks.ts\nimport {\n  deselect,\n  getEndPoint,\n  getStartPoint,\n  select,\n  withoutNormalizing\n} from \"@udecode/plate-common\";\nimport copyToClipboard from \"copy-to-clipboard\";\nvar copySelectedBlocks = (editor) => {\n  const { selectedIds } = editor.getOptions(BlockSelectionPlugin);\n  const selectedEntries = editor.getApi(BlockSelectionPlugin).blockSelection.getNodes();\n  const selectedFragment = selectedEntries.map(([node]) => node);\n  copyToClipboard(\" \", {\n    onCopy: (dataTransfer) => {\n      const data = dataTransfer;\n      if (!data) return;\n      let textPlain = \"\";\n      const div = document.createElement(\"div\");\n      withoutNormalizing(editor, () => {\n        selectedEntries.forEach(([, path]) => {\n          select(editor, {\n            anchor: getStartPoint(editor, path),\n            focus: getEndPoint(editor, path)\n          });\n          editor.setFragmentData(data);\n          textPlain += `${data.getData(\"text/plain\")}\n`;\n          const divChild = document.createElement(\"div\");\n          divChild.innerHTML = data.getData(\"text/html\");\n          div.append(divChild);\n        });\n        deselect(editor);\n        editor.setOption(BlockSelectionPlugin, \"selectedIds\", selectedIds);\n      });\n      data.setData(\"text/plain\", textPlain);\n      data.setData(\"text/html\", div.innerHTML);\n      const selectedFragmentStr = JSON.stringify(selectedFragment);\n      const encodedFragment = window.btoa(\n        encodeURIComponent(selectedFragmentStr)\n      );\n      data.setData(\"application/x-slate-fragment\", encodedFragment);\n    }\n  });\n};\n\n// src/react/utils/pasteSelectedBlocks.ts\nimport {\n  deselect as deselect2,\n  getEditorPlugin as getEditorPlugin2,\n  getStartPoint as getStartPoint2,\n  insertNodes,\n  isElementEmpty\n} from \"@udecode/plate-common\";\nimport { focusEditor, insertData } from \"@udecode/plate-common/react\";\nimport { Path as Path2 } from \"slate\";\n\n// src/react/utils/selectInsertedBlocks.ts\nimport {\n  getEditorPlugin,\n  isBlock\n} from \"@udecode/plate-common\";\nvar selectInsertedBlocks = (editor) => {\n  const { setOption } = getEditorPlugin(editor, BlockSelectionPlugin);\n  const ids = /* @__PURE__ */ new Set();\n  editor.operations.forEach((op) => {\n    if (op.type === \"insert_node\" && op.node.id && isBlock(editor, op.node)) {\n      ids.add(op.node.id);\n    }\n  });\n  setTimeout(() => {\n    setOption(\"selectedIds\", ids);\n  }, 0);\n};\n\n// src/react/utils/pasteSelectedBlocks.ts\nvar pasteSelectedBlocks = (editor, e) => {\n  const { api } = getEditorPlugin2(editor, BlockSelectionPlugin);\n  const entries = api.blockSelection.getNodes();\n  if (entries.length > 0) {\n    const entry = entries.at(-1);\n    const [node, path] = entry;\n    focusEditor(editor, getStartPoint2(editor, path));\n    if (!isElementEmpty(editor, node)) {\n      const at = Path2.next(path);\n      insertNodes(editor, editor.api.create.block({}, at), {\n        at,\n        select: true\n      });\n    }\n    insertData(editor, e.clipboardData);\n    deselect2(editor);\n    selectInsertedBlocks(editor);\n  }\n};\n\n// src/react/components/BlockSelectionAfterEditable.tsx\nvar BlockSelectionAfterEditable = () => {\n  const editor = useEditorRef();\n  const { api, getOption, getOptions, setOption, useOption } = useEditorPlugin3({ key: \"blockSelection\" });\n  const isSelecting2 = useOption(\"isSelecting\");\n  const selectedIds = useOption(\"selectedIds\");\n  useSelectionArea();\n  const inputRef = React3.useRef(null);\n  const [isMounted, setIsMounted] = React3.useState(false);\n  React3.useEffect(() => {\n    setIsMounted(true);\n    setOption(\"shadowInputRef\", inputRef);\n    return () => {\n      setIsMounted(false);\n    };\n  }, [setOption]);\n  React3.useEffect(() => {\n    if (isSelecting2 && inputRef.current) {\n      inputRef.current.focus({ preventScroll: true });\n    } else if (inputRef.current) {\n      inputRef.current.blur();\n    }\n  }, [isSelecting2]);\n  const handleKeyDown = React3.useCallback(\n    (e) => {\n      var _a, _b;\n      const isReadonly = isEditorReadOnly(editor);\n      (_b = (_a = getOptions()).onKeyDownSelecting) == null ? void 0 : _b.call(_a, e.nativeEvent);\n      if (!getOptions().isSelecting) return;\n      if (isHotkey(\"escape\")(e)) {\n        api.blockSelection.unselect();\n      }\n      if (isHotkey(\"mod+z\")(e)) {\n        editor.undo();\n        selectInsertedBlocks(editor);\n      }\n      if (isHotkey(\"mod+shift+z\")(e)) {\n        editor.redo();\n        selectInsertedBlocks(editor);\n      }\n      if (!getOption(\"isSelectingSome\")) return;\n      if (isHotkey(\"enter\")(e)) {\n        const entry = findNode(editor, {\n          at: [],\n          match: (n) => n.id && selectedIds.has(n.id)\n        });\n        if (entry) {\n          const [, path] = entry;\n          focusEditor2(editor, getEndPoint2(editor, path));\n          e.preventDefault();\n        }\n      }\n      if (isHotkey([\"backspace\", \"delete\"])(e) && !isReadonly) {\n        removeNodes(editor, {\n          at: [],\n          match: (n) => !!n.id && selectedIds.has(n.id)\n        });\n      }\n      if (isHotkey(\"up\")(e)) {\n        const firstId = [...selectedIds][0];\n        const node = findNode(editor, {\n          at: [],\n          match: (n) => n.id && n.id === firstId\n        });\n        const prev = getPreviousNode(editor, {\n          at: node == null ? void 0 : node[1]\n        });\n        const prevId = prev == null ? void 0 : prev[0].id;\n        api.blockSelection.addSelectedRow(prevId);\n      }\n      if (isHotkey(\"down\")(e)) {\n        const lastId = [...selectedIds].pop();\n        const node = findNode(editor, {\n          at: [],\n          match: (n) => n.id && n.id === lastId\n        });\n        const next = getNextNode(editor, {\n          at: node == null ? void 0 : node[1]\n        });\n        const nextId = next == null ? void 0 : next[0].id;\n        api.blockSelection.addSelectedRow(nextId);\n      }\n    },\n    [editor, selectedIds, api, getOptions, getOption]\n  );\n  const handleCopy = React3.useCallback(\n    (e) => {\n      e.preventDefault();\n      if (getOption(\"isSelectingSome\")) {\n        copySelectedBlocks(editor);\n      }\n    },\n    [editor, getOption]\n  );\n  const handleCut = React3.useCallback(\n    (e) => {\n      e.preventDefault();\n      if (getOption(\"isSelectingSome\")) {\n        copySelectedBlocks(editor);\n        if (!isEditorReadOnly(editor)) {\n          removeNodes(editor, {\n            at: [],\n            match: (n) => selectedIds.has(n.id)\n          });\n          focusEditor2(editor);\n        }\n      }\n    },\n    [editor, selectedIds, getOption]\n  );\n  const handlePaste = React3.useCallback(\n    (e) => {\n      e.preventDefault();\n      if (!isEditorReadOnly(editor)) {\n        pasteSelectedBlocks(editor, e.nativeEvent);\n      }\n    },\n    [editor]\n  );\n  if (!isMounted || typeof window === \"undefined\") {\n    return null;\n  }\n  return ReactDOM.createPortal(\n    /* @__PURE__ */ React3.createElement(\n      \"input\",\n      {\n        ref: inputRef,\n        className: \"slate-shadow-input\",\n        style: {\n          left: \"-300px\",\n          opacity: 0,\n          position: \"fixed\",\n          top: \"-300px\",\n          zIndex: 999\n        },\n        onCopy: handleCopy,\n        onCut: handleCut,\n        onKeyDown: handleKeyDown,\n        onPaste: handlePaste\n      }\n    ),\n    document.body\n  );\n};\n\n// src/react/onKeyDownSelection.ts\nimport {\n  getAncestorNode,\n  isHotkey as isHotkey2,\n  isRangeInSameBlock,\n  isSelectionCoverBlock,\n  select as select2\n} from \"@udecode/plate-common\";\nvar onKeyDownSelection = ({\n  api,\n  editor,\n  event\n}) => {\n  if (isHotkey2(\"mod+a\", event)) {\n    if (event.defaultPrevented) return;\n    const ancestorNode = getAncestorNode(editor);\n    if (!ancestorNode) return;\n    const [, path] = ancestorNode;\n    if (isSelectionCoverBlock(editor)) {\n      return api.blockSelection.selectedAll();\n    }\n    if (!isRangeInSameBlock(editor)) {\n      return api.blockSelection.selectedAll();\n    }\n    select2(editor, path);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  if (isHotkey2(\"escape\", event)) {\n    if (event.defaultPrevented) return;\n    const ancestorNode = getAncestorNode(editor);\n    const id = ancestorNode == null ? void 0 : ancestorNode[0].id;\n    api.blockSelection.addSelectedRow(id);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n};\n\n// src/react/transforms/duplicateBlockSelectionNodes.ts\nimport {\n  duplicateBlocks,\n  getNodeEntry\n} from \"@udecode/plate-common\";\nimport { Path as Path3 } from \"slate\";\nvar duplicateBlockSelectionNodes = (editor, blocks) => {\n  duplicateBlocks(editor, blocks);\n  const lastBlock = blocks.at(-1);\n  if (!lastBlock) return;\n  const path = Path3.next(lastBlock[1]);\n  const ids = blocks.map((_, index) => {\n    const targetPath = [path[0] + index];\n    const targetNode = getNodeEntry(editor, targetPath);\n    return targetNode == null ? void 0 : targetNode[0].id;\n  }).filter(Boolean);\n  const api = editor.getApi(BlockSelectionPlugin);\n  setTimeout(() => {\n    api.blockSelection.setSelectedIds({ ids });\n  }, 0);\n};\n\n// src/react/transforms/insertBlocksAndSelect.ts\nimport { insertNodes as insertNodes2, nanoid } from \"@udecode/plate-common\";\nvar insertBlocksAndSelect = (editor, nodes, { at }) => {\n  const ids = [];\n  nodes.forEach((node) => {\n    const id = nanoid();\n    ids.push(id);\n    node.id = id;\n  });\n  insertNodes2(editor, nodes, { at });\n  setTimeout(() => {\n    editor.getApi(BlockSelectionPlugin).blockSelection.setSelectedIds({ ids });\n  }, 0);\n};\n\n// src/react/transforms/removeBlockSelectionNodes.ts\nvar removeBlockSelectionNodes = (editor) => {\n  const selectedIds = editor.getOption(BlockSelectionPlugin, \"selectedIds\");\n  if (!selectedIds) return;\n  editor.removeNodes({\n    at: [],\n    match: (n) => selectedIds.has(n.id)\n  });\n};\n\n// src/react/transforms/selectBlockSelectionNodes.ts\nimport { selectNodes } from \"@udecode/plate-common\";\nvar selectBlockSelectionNodes = (editor) => {\n  selectNodes(\n    editor,\n    editor.getApi(BlockSelectionPlugin).blockSelection.getNodes()\n  );\n  editor.getApi(BlockSelectionPlugin).blockSelection.resetSelectedIds();\n};\n\n// src/react/transforms/setBlockSelectionNodes.ts\nimport {\n  setNodes,\n  withoutNormalizing as withoutNormalizing2\n} from \"@udecode/plate-common\";\nvar setBlockSelectionNodes = (editor, props, options) => {\n  withoutNormalizing2(editor, () => {\n    const blocks = editor.getApi(BlockSelectionPlugin).blockSelection.getNodes();\n    blocks.forEach(([, path]) => {\n      setNodes(editor, props, __spreadProps(__spreadValues({}, options), {\n        at: path\n      }));\n    });\n  });\n};\nvar setBlockSelectionIndent = (editor, indent, options) => {\n  const api = editor.getApi(BlockSelectionPlugin);\n  withoutNormalizing2(editor, () => {\n    const blocks = api.blockSelection.getNodes();\n    blocks.forEach(([node, path]) => {\n      var _a;\n      const prevIndent = (_a = node.indent) != null ? _a : 0;\n      const currentIndent = prevIndent + indent;\n      setNodes(\n        editor,\n        { indent: currentIndent < 0 ? 0 : currentIndent },\n        __spreadProps(__spreadValues({}, options), {\n          at: path\n        })\n      );\n    });\n  });\n};\nvar setBlockSelectionTexts = (editor, props, options) => {\n  setBlockSelectionNodes(editor, props, __spreadValues({\n    mode: \"lowest\"\n  }, options));\n};\n\n// src/react/BlockSelectionPlugin.tsx\nvar BlockSelectionPlugin = createTPlatePlugin2({\n  key: \"blockSelection\",\n  extendEditor: ({ api, editor, getOptions }) => {\n    const { setSelection } = editor;\n    editor.setSelection = (...args) => {\n      if (getOptions().selectedIds.size > 0 && !editor.getOption(BlockMenuPlugin, \"openId\")) {\n        api.blockSelection.unselect();\n      }\n      setSelection(...args);\n    };\n    return editor;\n  },\n  inject: {\n    isBlock: true,\n    nodeProps: {\n      transformProps: () => {\n        return useBlockSelectable().props;\n      }\n    }\n  },\n  options: {\n    areaOptions: {\n      features: {\n        singleTap: {\n          allow: false\n        }\n      }\n    },\n    enableContextMenu: false,\n    isSelecting: false,\n    isSelectionAreaVisible: false,\n    selectedIds: /* @__PURE__ */ new Set(),\n    shadowInputRef: { current: null }\n  },\n  plugins: [BlockMenuPlugin],\n  render: {\n    afterEditable: BlockSelectionAfterEditable\n  },\n  handlers: {\n    onKeyDown: onKeyDownSelection,\n    onMouseDown: ({ api, editor, event, getOptions }) => {\n      const target = event.target;\n      if (target.dataset.platePreventUnselect) return;\n      if (event.button === 0 && getOptions().selectedIds.size > 0 && !editor.getOption(BlockMenuPlugin, \"openId\")) {\n        api.blockSelection.unselect();\n      }\n    }\n  }\n}).extend(() => ({\n  inject: {}\n})).extendOptions(({ getOptions }) => ({\n  isSelected: (id) => !!id && getOptions().selectedIds.has(id),\n  isSelectingSome: () => getOptions().selectedIds.size > 0\n})).extendApi(\n  ({ editor, getOption, getOptions, setOption }) => ({\n    focus: () => {\n      const shadowInputRef = getOption(\"shadowInputRef\");\n      if (shadowInputRef == null ? void 0 : shadowInputRef.current) {\n        shadowInputRef.current.focus({ preventScroll: true });\n      }\n    },\n    getNodes: () => {\n      const selectedIds = getOption(\"selectedIds\");\n      return [\n        ...getNodeEntries(editor, {\n          at: [],\n          match: (n) => selectedIds == null ? void 0 : selectedIds.has(n.id)\n        })\n      ];\n    },\n    resetSelectedIds: () => {\n      setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n    },\n    setSelectedIds: ({ added, ids, removed }) => {\n      if (ids) {\n        setOption(\"selectedIds\", new Set(ids));\n      }\n      if (added || removed) {\n        const { selectedIds: prev } = getOptions();\n        const next = new Set(prev);\n        if (added) {\n          extractSelectableIds(added).forEach((id) => next.add(id));\n        }\n        if (removed) {\n          extractSelectableIds(removed).forEach((id) => next.delete(id));\n        }\n        setOption(\"selectedIds\", next);\n      }\n      setOption(\"isSelecting\", true);\n    },\n    unselect: () => {\n      setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n      setOption(\"isSelecting\", false);\n    }\n  })\n).extendApi(({ api, getOptions, setOption }) => ({\n  addSelectedRow: (id, options = {}) => {\n    const { clear = true, delay } = options;\n    const element = getSelectedDomNode(id);\n    if (!element) return;\n    if (!getOptions().selectedIds.has(id) && clear) {\n      setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n    }\n    api.blockSelection.setSelectedIds({\n      added: [element],\n      removed: []\n    });\n    if (delay) {\n      setTimeout(() => {\n        api.blockSelection.setSelectedIds({\n          added: [],\n          removed: [element]\n        });\n      }, delay);\n    }\n  },\n  selectedAll: () => {\n    const all = getAllSelectableDomNode();\n    setOption(\"selectedIds\", /* @__PURE__ */ new Set());\n    api.blockSelection.setSelectedIds({\n      added: Array.from(all),\n      removed: []\n    });\n  }\n})).extendTransforms(({ editor }) => ({\n  duplicate: bindFirst(duplicateBlockSelectionNodes, editor),\n  insertBlocksAndSelect: bindFirst(insertBlocksAndSelect, editor),\n  removeNodes: bindFirst(removeBlockSelectionNodes, editor),\n  select: bindFirst(selectBlockSelectionNodes, editor),\n  setIndent: bindFirst(setBlockSelectionIndent, editor),\n  setNodes: bindFirst(setBlockSelectionNodes, editor),\n  setTexts: bindFirst(setBlockSelectionTexts, editor)\n}));\n\n// src/lib/isSelecting.ts\nvar isSelecting = (editor) => {\n  const isSelectingSome = editor.getOption(\n    BlockSelectionPlugin,\n    \"isSelectingSome\"\n  );\n  const selectionExpanded = isSelectionExpanded(editor);\n  return selectionExpanded || isSelectingSome;\n};\nexport {\n  extractSelectableId,\n  extractSelectableIds,\n  getAllSelectableDomNode,\n  getSelectedDomNode,\n  isSelecting\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// src/react/ai/AIPlugin.ts\nimport { toPlatePlugin } from \"@udecode/plate-common/react\";\n\n// src/lib/BaseAIPlugin.ts\nimport {\n  bindFirst,\n  createTSlatePlugin\n} from \"@udecode/plate-common\";\n\n// src/lib/transforms/insertAINodes.ts\nimport {\n  collapseSelection,\n  getEndPoint,\n  insertNodes,\n  withoutNormalizing\n} from \"@udecode/plate-common\";\nvar insertAINodes = (editor, nodes, {\n  target\n} = {}) => {\n  var _a;\n  if (!target && !((_a = editor.selection) == null ? void 0 : _a.focus.path)) return;\n  const aiNodes = nodes.map((node) => __spreadProps(__spreadValues({}, node), {\n    ai: true\n  }));\n  withoutNormalizing(editor, () => {\n    insertNodes(editor, aiNodes, {\n      at: getEndPoint(editor, target || editor.selection.focus.path),\n      select: true\n    });\n    collapseSelection(editor, { edge: \"end\" });\n  });\n};\n\n// src/lib/transforms/removeAIMarks.ts\nimport { unsetNodes } from \"@udecode/plate-common\";\nvar removeAIMarks = (editor, { at = [] } = {}) => {\n  unsetNodes(editor, \"ai\", {\n    at,\n    match: (n) => n.ai\n  });\n};\n\n// src/lib/transforms/removeAINodes.ts\nimport { isText, removeNodes } from \"@udecode/plate-common\";\nvar removeAINodes = (editor, { at = [] } = {}) => {\n  removeNodes(editor, {\n    at,\n    match: (n) => isText(n) && !!n.ai\n  });\n};\n\n// src/lib/transforms/undoAI.ts\nimport { someNode } from \"@udecode/plate-common\";\nvar undoAI = (editor) => {\n  var _a;\n  if (((_a = editor.history.undos.at(-1)) == null ? void 0 : _a.ai) && someNode(editor, {\n    at: [],\n    match: (n) => !!n.ai\n  })) {\n    editor.undo();\n    editor.history.redos.pop();\n  }\n};\n\n// src/lib/transforms/withAIBatch.ts\nimport {\n  withMerging,\n  withNewBatch\n} from \"@udecode/plate-common\";\nvar withAIBatch = (editor, fn, {\n  split\n} = {}) => {\n  var _a;\n  if (split) {\n    withNewBatch(editor, fn);\n  } else {\n    withMerging(editor, fn);\n  }\n  const lastBatch = (_a = editor.history.undos) == null ? void 0 : _a.at(-1);\n  if (lastBatch) {\n    lastBatch.ai = true;\n  }\n};\n\n// src/lib/BaseAIPlugin.ts\nvar BaseAIPlugin = createTSlatePlugin({\n  key: \"ai\",\n  node: { isLeaf: true }\n}).extendTransforms(({ editor }) => ({\n  insertNodes: bindFirst(insertAINodes, editor),\n  removeMarks: bindFirst(removeAIMarks, editor),\n  removeNodes: bindFirst(removeAINodes, editor),\n  undo: bindFirst(undoAI, editor)\n}));\n\n// src/react/ai/AIPlugin.ts\nvar AIPlugin = toPlatePlugin(BaseAIPlugin);\n\n// src/react/ai-chat/AIChatPlugin.ts\nimport {\n  bindFirst as bindFirst2\n} from \"@udecode/plate-common\";\nimport {\n  createPlateEditor,\n  createTPlatePlugin,\n  focusEditor as focusEditor3\n} from \"@udecode/plate-common/react\";\nimport { BlockSelectionPlugin as BlockSelectionPlugin5 } from \"@udecode/plate-selection/react\";\n\n// src/react/ai-chat/transforms/acceptAIChat.ts\nimport {\n  focusEditor,\n  getEditorPlugin\n} from \"@udecode/plate-common/react\";\nvar acceptAIChat = (editor) => {\n  const { tf } = getEditorPlugin(editor, AIPlugin);\n  withAIBatch(editor, () => {\n    tf.ai.removeMarks();\n  });\n  editor.getApi({ key: \"ai\" }).aiChat.hide();\n  focusEditor(editor);\n};\n\n// src/react/ai-chat/transforms/insertBelowAIChat.ts\nimport { isEditorEmpty } from \"@udecode/plate-common\";\nimport { BlockSelectionPlugin } from \"@udecode/plate-selection/react\";\nimport cloneDeep from \"lodash/cloneDeep.js\";\nimport { Path, Range } from \"slate\";\nvar insertBelowAIChat = (editor, sourceEditor) => {\n  if (!sourceEditor || isEditorEmpty(sourceEditor)) return;\n  const isBlockSelecting = editor.getOption(\n    BlockSelectionPlugin,\n    \"isSelectingSome\"\n  );\n  editor.getApi({ key: \"ai\" }).aiChat.hide();\n  const insertBlocksAndSelect = editor.getTransforms(BlockSelectionPlugin).blockSelection.insertBlocksAndSelect;\n  if (isBlockSelecting) {\n    const selectedBlocks = editor.getApi(BlockSelectionPlugin).blockSelection.getNodes();\n    const selectedIds = editor.getOptions(BlockSelectionPlugin).selectedIds;\n    if (!selectedIds || selectedIds.size === 0) return;\n    const lastBlock = selectedBlocks.at(-1);\n    if (!lastBlock) return;\n    const nextPath = Path.next(lastBlock[1]);\n    insertBlocksAndSelect(cloneDeep(sourceEditor.children), {\n      at: nextPath\n    });\n  } else {\n    const [, end] = Range.edges(editor.selection);\n    const endPath = [end.path[0]];\n    insertBlocksAndSelect(cloneDeep(sourceEditor.children), {\n      at: Path.next(endPath)\n    });\n  }\n};\n\n// src/react/ai-chat/transforms/replaceSelectionAIChat.ts\nimport { isEditorEmpty as isEditorEmpty2, withNewBatch as withNewBatch2 } from \"@udecode/plate-common\";\nimport { focusEditor as focusEditor2 } from \"@udecode/plate-common/react\";\nimport {\n  BlockSelectionPlugin as BlockSelectionPlugin2,\n  removeBlockSelectionNodes\n} from \"@udecode/plate-selection/react\";\nimport cloneDeep2 from \"lodash/cloneDeep.js\";\nvar replaceSelectionAIChat = (editor, sourceEditor) => {\n  if (!sourceEditor || isEditorEmpty2(sourceEditor)) return;\n  const isBlockSelecting = editor.getOption(\n    BlockSelectionPlugin2,\n    \"isSelectingSome\"\n  );\n  editor.getApi({ key: \"ai\" }).aiChat.hide();\n  if (isBlockSelecting) {\n    const firstBlockPath = editor.getApi(BlockSelectionPlugin2).blockSelection.getNodes()[0][1];\n    editor.withoutNormalizing(() => {\n      removeBlockSelectionNodes(editor);\n      withNewBatch2(editor, () => {\n        editor.getTransforms(BlockSelectionPlugin2).blockSelection.insertBlocksAndSelect(\n          cloneDeep2(sourceEditor.children),\n          {\n            at: firstBlockPath\n          }\n        );\n      });\n    });\n  } else {\n    editor.insertFragment(sourceEditor.children);\n    focusEditor2(editor);\n  }\n};\n\n// src/react/ai-chat/useAIChatHook.ts\nimport { getBlockAbove } from \"@udecode/plate-common\";\nimport { useEditorPlugin as useEditorPlugin2 } from \"@udecode/plate-common/react\";\nimport { deserializeInlineMd } from \"@udecode/plate-markdown\";\n\n// src/react/ai-chat/hooks/useChatChunk.ts\nimport { useEffect, useRef } from \"react\";\nimport { useEditorPlugin } from \"@udecode/plate-common/react\";\n\n// src/react/ai-chat/utils/getLastAssistantMessage.ts\nimport { useEditorRef } from \"@udecode/plate-common/react\";\nfunction getLastAssistantMessage(editor) {\n  const messages = editor.getOptions(AIChatPlugin).chat.messages;\n  return messages == null ? void 0 : messages.findLast((message) => message.role === \"assistant\");\n}\nfunction useLastAssistantMessage() {\n  var _a;\n  const editor = useEditorRef();\n  const chat = editor.useOption(AIChatPlugin, \"chat\");\n  return (_a = chat.messages) == null ? void 0 : _a.findLast((message) => message.role === \"assistant\");\n}\n\n// src/react/ai-chat/hooks/useChatChunk.ts\nvar useChatChunk = ({\n  onChunk,\n  onFinish\n}) => {\n  var _a;\n  const { useOption } = useEditorPlugin({ key: \"aiChat\" });\n  const { isLoading } = useOption(\"chat\");\n  const content = (_a = useLastAssistantMessage()) == null ? void 0 : _a.content;\n  const insertedTextRef = useRef(\"\");\n  const prevIsLoadingRef = useRef(isLoading);\n  useEffect(() => {\n    if (!isLoading) {\n      insertedTextRef.current = \"\";\n    }\n    if (prevIsLoadingRef.current && !isLoading) {\n      onFinish == null ? void 0 : onFinish({ content: content != null ? content : \"\" });\n    }\n    prevIsLoadingRef.current = isLoading;\n  }, [isLoading]);\n  useEffect(() => {\n    if (!content) {\n      return;\n    }\n    const chunk = content.slice(insertedTextRef.current.length);\n    const nodes = [];\n    if (chunk) {\n      const isFirst = insertedTextRef.current === \"\";\n      nodes.push({ text: chunk });\n      onChunk({\n        isFirst,\n        nodes,\n        text: content\n      });\n    }\n    insertedTextRef.current = content;\n  }, [content]);\n};\n\n// src/react/ai-chat/useAIChatHook.ts\nvar useAIChatHooks = () => {\n  const { editor, tf } = useEditorPlugin2({ key: \"ai\" });\n  const { useOption } = useEditorPlugin2({ key: \"aiChat\" });\n  const mode = useOption(\"mode\");\n  useChatChunk({\n    onChunk: ({ isFirst, nodes }) => {\n      if (mode === \"insert\" && nodes.length > 0) {\n        withAIBatch(\n          editor,\n          () => {\n            tf.ai.insertNodes(nodes);\n          },\n          { split: isFirst }\n        );\n      }\n    },\n    onFinish: ({ content }) => {\n      if (mode !== \"insert\") return;\n      const blockAbove = getBlockAbove(editor);\n      if (!blockAbove) return;\n      editor.undo();\n      editor.history.redos.pop();\n      const nodes = deserializeInlineMd(editor, content);\n      withAIBatch(\n        editor,\n        () => {\n          tf.ai.insertNodes(nodes);\n        },\n        { split: true }\n      );\n    }\n  });\n};\n\n// src/react/ai-chat/utils/getEditorPrompt.ts\nimport { isSelecting } from \"@udecode/plate-selection\";\nimport { BlockSelectionPlugin as BlockSelectionPlugin4 } from \"@udecode/plate-selection/react\";\n\n// src/react/ai-chat/utils/getMarkdown.ts\nimport {\n  getNodeEntries,\n  getSelectionFragment,\n  isBlock\n} from \"@udecode/plate-common\";\nimport { serializeMd, serializeMdNodes } from \"@udecode/plate-markdown\";\nimport { BlockSelectionPlugin as BlockSelectionPlugin3 } from \"@udecode/plate-selection/react\";\nvar getMarkdown = (editor, type) => {\n  if (type === \"editor\") {\n    return serializeMd(editor);\n  }\n  if (type === \"block\") {\n    const blocks = editor.getOption(BlockSelectionPlugin3, \"isSelectingSome\") ? editor.getApi(BlockSelectionPlugin3).blockSelection.getNodes() : getNodeEntries(editor, {\n      match: (n) => isBlock(editor, n),\n      mode: \"highest\"\n    });\n    const nodes = Array.from(blocks, (entry) => entry[0]);\n    return serializeMdNodes(nodes);\n  }\n  if (type === \"selection\") {\n    const fragment = getSelectionFragment(editor);\n    if (fragment.length === 1) {\n      fragment[0] = {\n        children: fragment[0].children,\n        type: \"p\"\n      };\n    }\n    return serializeMdNodes(fragment);\n  }\n  return \"\";\n};\n\n// src/react/ai-chat/utils/getEditorPrompt.ts\nvar replacePlaceholders = (editor, text, {\n  prompt\n}) => {\n  let result = text.replace(\"{prompt}\", prompt || \"\");\n  const placeholders = {\n    \"{block}\": \"block\",\n    \"{editor}\": \"editor\",\n    \"{selection}\": \"selection\"\n  };\n  Object.entries(placeholders).forEach(([placeholder, type]) => {\n    if (result.includes(placeholder)) {\n      result = result.replace(placeholder, getMarkdown(editor, type));\n    }\n  });\n  return result;\n};\nvar createPromptFromConfig = (config, params) => {\n  var _a, _b;\n  const { isBlockSelecting, isSelecting: isSelecting3 } = params;\n  if (isBlockSelecting && config.blockSelecting) {\n    return (_a = config.blockSelecting) != null ? _a : config.default;\n  } else if (isSelecting3 && config.selecting) {\n    return (_b = config.selecting) != null ? _b : config.default;\n  } else {\n    return config.default;\n  }\n};\nvar getEditorPrompt = (editor, {\n  prompt = \"\",\n  promptTemplate = () => \"{prompt}\"\n} = {}) => {\n  const params = {\n    editor,\n    isBlockSelecting: editor.getOption(BlockSelectionPlugin4, \"isSelectingSome\"),\n    isSelecting: isSelecting(editor)\n  };\n  const template = promptTemplate(params);\n  if (!template) return;\n  let promptText = \"\";\n  if (typeof prompt === \"function\") {\n    promptText = prompt(params);\n  } else if (typeof prompt === \"object\") {\n    promptText = createPromptFromConfig(prompt, params);\n  } else {\n    promptText = prompt;\n  }\n  return replacePlaceholders(editor, template, {\n    prompt: promptText\n  });\n};\n\n// src/react/ai-chat/utils/resetAIChat.ts\nimport { getEditorPlugin as getEditorPlugin2 } from \"@udecode/plate-common/react\";\nvar resetAIChat = (editor) => {\n  var _a;\n  const { api, getOptions } = getEditorPlugin2(editor, {\n    key: \"aiChat\"\n  });\n  api.aiChat.stop();\n  const chat = getOptions().chat;\n  if (chat.messages && chat.messages.length > 0) {\n    (_a = chat.setMessages) == null ? void 0 : _a.call(chat, []);\n  }\n  editor.getTransforms(AIPlugin).ai.removeNodes();\n};\n\n// src/react/ai-chat/utils/submitAIChat.ts\nimport { getEditorPlugin as getEditorPlugin3 } from \"@udecode/plate-common/react\";\nimport { isSelecting as isSelecting2 } from \"@udecode/plate-selection\";\nvar submitAIChat = (editor, {\n  mode,\n  prompt,\n  system\n} = {}) => {\n  var _a, _b, _c, _d;\n  const { getOptions, setOption } = getEditorPlugin3(\n    editor,\n    {\n      key: \"aiChat\"\n    }\n  );\n  const { chat, promptTemplate, systemTemplate } = getOptions();\n  if (!prompt && ((_a = chat.input) == null ? void 0 : _a.length) === 0) {\n    return;\n  }\n  if (!prompt) {\n    prompt = chat.input;\n  }\n  if (!mode) {\n    mode = isSelecting2(editor) ? \"chat\" : \"insert\";\n  }\n  if (mode === \"insert\") {\n    editor.getTransforms(AIPlugin).ai.undo();\n  }\n  setOption(\"mode\", mode);\n  (_b = chat.setInput) == null ? void 0 : _b.call(chat, \"\");\n  void ((_d = chat.append) == null ? void 0 : _d.call(\n    chat,\n    {\n      content: (_c = getEditorPrompt(editor, {\n        prompt,\n        promptTemplate\n      })) != null ? _c : \"\",\n      role: \"user\"\n    },\n    {\n      body: {\n        system: getEditorPrompt(editor, {\n          prompt: system,\n          promptTemplate: systemTemplate\n        })\n      }\n    }\n  ));\n};\n\n// src/react/ai-chat/withAIChat.ts\nimport {\n  getAncestorNode,\n  getEditorString,\n  getPointBefore,\n  getRange,\n  isElementEmpty\n} from \"@udecode/plate-common\";\nvar withAIChat = ({\n  api,\n  editor,\n  getOptions\n}) => {\n  const tf = editor.getTransforms(AIPlugin);\n  const { insertText, normalizeNode } = editor;\n  const matchesTrigger = (text) => {\n    const { trigger } = getOptions();\n    if (trigger instanceof RegExp) {\n      return trigger.test(text);\n    }\n    if (Array.isArray(trigger)) {\n      return trigger.includes(text);\n    }\n    return text === trigger;\n  };\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n    if (node[AIPlugin.key] && !getOptions().open) {\n      tf.ai.removeMarks({ at: path });\n      return;\n    }\n    return normalizeNode(entry);\n  };\n  editor.insertText = (text) => {\n    const { triggerPreviousCharPattern, triggerQuery } = getOptions();\n    const fn = () => {\n      if (!editor.selection || !matchesTrigger(text) || triggerQuery && !triggerQuery(editor)) {\n        return;\n      }\n      const previousChar = getEditorString(\n        editor,\n        getRange(\n          editor,\n          editor.selection,\n          getPointBefore(editor, editor.selection)\n        )\n      );\n      const matchesPreviousCharPattern = triggerPreviousCharPattern == null ? void 0 : triggerPreviousCharPattern.test(previousChar);\n      if (!matchesPreviousCharPattern) return;\n      const nodeEntry = getAncestorNode(editor);\n      if (!nodeEntry || !isElementEmpty(editor, nodeEntry[0]))\n        return;\n      api.aiChat.show();\n      return true;\n    };\n    if (fn()) return;\n    return insertText(text);\n  };\n  return editor;\n};\n\n// src/react/ai-chat/AIChatPlugin.ts\nvar AIChatPlugin = createTPlatePlugin({\n  key: \"aiChat\",\n  dependencies: [\"ai\"],\n  extendEditor: withAIChat,\n  options: {\n    chat: { messages: [] },\n    createAIEditor: () => createPlateEditor({\n      id: \"ai\"\n    }),\n    mode: \"chat\",\n    open: false,\n    promptTemplate: () => \"{prompt}\",\n    systemTemplate: () => {\n    },\n    trigger: \" \",\n    triggerPreviousCharPattern: /^\\s?$/\n  }\n}).extend(() => ({\n  useHooks: useAIChatHooks\n})).extendApi(\n  ({ editor, getOptions }) => {\n    return {\n      reload: () => {\n        var _a;\n        const { chat, mode } = getOptions();\n        if (mode === \"insert\") {\n          editor.getTransforms(AIPlugin).ai.undo();\n        }\n        void ((_a = chat.reload) == null ? void 0 : _a.call(chat, {\n          body: {\n            system: getEditorPrompt(editor, {\n              promptTemplate: getOptions().systemTemplate\n            })\n          }\n        }));\n      },\n      reset: bindFirst2(resetAIChat, editor),\n      stop: () => {\n        var _a, _b;\n        (_b = (_a = getOptions().chat).stop) == null ? void 0 : _b.call(_a);\n      },\n      submit: bindFirst2(submitAIChat, editor)\n    };\n  }\n).extendApi(({ api, editor, getOptions, setOption }) => ({\n  hide: () => {\n    api.aiChat.reset();\n    setOption(\"open\", false);\n    if (editor.getOption(BlockSelectionPlugin5, \"isSelectingSome\")) {\n    } else {\n      focusEditor3(editor);\n    }\n    const lastBatch = editor.history.undos.at(-1);\n    if (lastBatch == null ? void 0 : lastBatch.ai) {\n      delete lastBatch.ai;\n    }\n  },\n  show: () => {\n    var _a, _b;\n    api.aiChat.reset();\n    (_b = (_a = getOptions().chat).setMessages) == null ? void 0 : _b.call(_a, []);\n    setOption(\"open\", true);\n  }\n})).extendTransforms(({ editor }) => ({\n  accept: bindFirst2(acceptAIChat, editor),\n  insertBelow: bindFirst2(insertBelowAIChat, editor),\n  replaceSelection: bindFirst2(replaceSelectionAIChat, editor)\n}));\n\n// src/react/ai-chat/hooks/useEditorChat.ts\nimport { useEffect as useEffect2 } from \"react\";\nimport {\n  isCollapsed,\n  isSelectionExpanded\n} from \"@udecode/plate-common\";\nimport { useEditorPlugin as useEditorPlugin3 } from \"@udecode/plate-common/react\";\nimport { BlockSelectionPlugin as BlockSelectionPlugin6 } from \"@udecode/plate-selection/react\";\nvar useEditorChat = ({\n  chat,\n  onOpenBlockSelection,\n  onOpenChange,\n  onOpenCursor,\n  onOpenSelection\n}) => {\n  const { editor, setOption, setOptions, useOption } = useEditorPlugin3(AIChatPlugin);\n  const open = useOption(\"open\");\n  useEffect2(() => {\n    setOption(\"chat\", chat);\n  }, [chat, setOption, setOptions]);\n  useEffect2(() => {\n    onOpenChange == null ? void 0 : onOpenChange(open);\n    if (open) {\n      if (onOpenBlockSelection) {\n        const blockSelectionApi = editor.getApi(BlockSelectionPlugin6).blockSelection;\n        const isBlockSelecting = editor.getOption(\n          BlockSelectionPlugin6,\n          \"isSelectingSome\"\n        );\n        if (isBlockSelecting) {\n          onOpenBlockSelection(blockSelectionApi.getNodes());\n          return;\n        }\n      }\n      if (onOpenCursor && isCollapsed(editor.selection)) {\n        onOpenCursor();\n        return;\n      }\n      if (onOpenSelection && isSelectionExpanded(editor)) {\n        onOpenSelection();\n        return;\n      }\n    }\n  }, [open]);\n};\n\n// src/react/copilot/CopilotPlugin.tsx\nimport {\n  bindFirst as bindFirst3,\n  getAncestorNode as getAncestorNode2,\n  getBlockAbove as getBlockAbove2,\n  getNodeString,\n  isBlockAboveEmpty,\n  isExpanded,\n  isSelectionAtBlockEnd\n} from \"@udecode/plate-common\";\nimport {\n  Key,\n  createTPlatePlugin as createTPlatePlugin2\n} from \"@udecode/plate-common/react\";\nimport { serializeMdNodes as serializeMdNodes2 } from \"@udecode/plate-markdown\";\n\n// src/react/copilot/renderCopilotBelowNodes.tsx\nimport React from \"react\";\nimport {\n  getEditorPlugin as getEditorPlugin4\n} from \"@udecode/plate-common/react\";\nvar renderCopilotBelowNodes = ({\n  editor\n}) => {\n  const copilot = getEditorPlugin4(editor, {\n    key: \"copilot\"\n  });\n  const { renderGhostText: GhostText } = copilot.getOptions();\n  if (!GhostText) return;\n  return function Component({ children }) {\n    return /* @__PURE__ */ React.createElement(React.Fragment, null, children, /* @__PURE__ */ React.createElement(GhostText, null));\n  };\n};\n\n// src/react/copilot/transforms/acceptCopilot.ts\nimport { deserializeInlineMd as deserializeInlineMd2 } from \"@udecode/plate-markdown\";\nvar acceptCopilot = (editor) => {\n  const { suggestionText } = editor.getOptions({\n    key: \"copilot\"\n  });\n  if (suggestionText == null ? void 0 : suggestionText.length) {\n    editor.insertFragment(deserializeInlineMd2(editor, suggestionText));\n  }\n};\n\n// src/react/copilot/transforms/acceptCopilotNextWord.ts\nimport { getEditorPlugin as getEditorPlugin6 } from \"@udecode/plate-common/react\";\nimport { deserializeInlineMd as deserializeInlineMd3 } from \"@udecode/plate-markdown\";\n\n// src/react/copilot/utils/callCompletionApi.ts\nvar getOriginalFetch = () => fetch;\nasync function callCompletionApi({\n  api = \"/api/completion\",\n  body,\n  credentials,\n  fetch: fetch2 = getOriginalFetch(),\n  headers,\n  prompt,\n  setAbortController = () => {\n  },\n  setCompletion = () => {\n  },\n  setError = () => {\n  },\n  setLoading = () => {\n  },\n  onError,\n  onFinish,\n  onResponse\n}) {\n  try {\n    setLoading(true);\n    setError(null);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const res = await fetch2(api, {\n      body: JSON.stringify(__spreadValues({\n        prompt\n      }, body)),\n      credentials,\n      headers: __spreadValues({\n        \"Content-Type\": \"application/json\"\n      }, headers),\n      method: \"POST\",\n      signal: abortController.signal\n    }).catch((error) => {\n      throw error;\n    });\n    if (onResponse) {\n      await onResponse(res);\n    }\n    if (!res.ok) {\n      throw new Error(\n        await res.text() || \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!res.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    const { text } = await res.json();\n    if (!text) {\n      throw new Error(\"The response does not contain a text field.\");\n    }\n    setCompletion(text);\n    if (onFinish) {\n      onFinish(prompt, text);\n    }\n    setAbortController(null);\n    return text;\n  } catch (error) {\n    if (error.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (error instanceof Error && onError) {\n      onError(error);\n    }\n    setError(error);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/react/copilot/utils/getNextWord.ts\nvar getNextWord = ({ text }) => {\n  if (!text) return { firstWord: \"\", remainingText: \"\" };\n  const nonSpaceMatch = /^\\s*(\\S)/.exec(text);\n  if (!nonSpaceMatch) return { firstWord: \"\", remainingText: \"\" };\n  const firstNonSpaceChar = nonSpaceMatch[1];\n  const isCJKChar = /[\\u1100-\\u11FF\\u3040-\\u30FF\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uAC00-\\uD7AF\\uF900-\\uFAFF]/.test(\n    firstNonSpaceChar\n  );\n  let firstWord, remainingText;\n  if (isCJKChar) {\n    const match = /^(\\s*)([\\u1100-\\u11FF\\u3040-\\u30FF\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uAC00-\\uD7AF\\uF900-\\uFAFF])([\\u3000-\\u303F\\uFF00-\\uFFEF])?/.exec(\n      text\n    );\n    if (match) {\n      const [fullMatch, spaces = \"\", char = \"\", punctuation = \"\"] = match;\n      firstWord = spaces + char + punctuation;\n      remainingText = text.slice(firstWord.length);\n    } else {\n      firstWord = \"\";\n      remainingText = text;\n    }\n  } else {\n    const match = /^(\\s*\\S+?)(?=[\\s\\u1100-\\u11FF\\u3040-\\u30FF\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uAC00-\\uD7AF\\uF900-\\uFAFF]|$)/.exec(\n      text\n    );\n    if (match) {\n      firstWord = match[0];\n      remainingText = text.slice(firstWord.length);\n    } else {\n      firstWord = text;\n      remainingText = \"\";\n    }\n  }\n  return { firstWord, remainingText };\n};\n\n// src/react/copilot/utils/triggerCopilotSuggestion.ts\nimport { getEditorPlugin as getEditorPlugin5 } from \"@udecode/plate-common/react\";\nvar triggerCopilotSuggestion = async (editor) => {\n  var _a;\n  const { api, getOptions, setOption } = getEditorPlugin5(\n    editor,\n    {\n      key: \"copilot\"\n    }\n  );\n  const { completeOptions, getPrompt, isLoading, triggerQuery } = getOptions();\n  if (isLoading || ((_a = editor.getOptions(AIChatPlugin).chat) == null ? void 0 : _a.isLoading)) return;\n  if (!triggerQuery({ editor })) return;\n  const prompt = getPrompt({ editor });\n  if (prompt.length === 0) return;\n  api.copilot.stop();\n  await callCompletionApi(__spreadProps(__spreadValues({\n    prompt,\n    onFinish: (_, completion) => {\n      api.copilot.setBlockSuggestion({ text: completion });\n    }\n  }, completeOptions), {\n    setAbortController: (controller) => setOption(\"abortController\", controller),\n    setCompletion: (completion) => setOption(\"completion\", completion),\n    setError: (error) => setOption(\"error\", error),\n    setLoading: (loading) => setOption(\"isLoading\", loading),\n    onError: (error) => {\n      var _a2;\n      setOption(\"error\", error);\n      (_a2 = completeOptions == null ? void 0 : completeOptions.onError) == null ? void 0 : _a2.call(completeOptions, error);\n    }\n  }));\n};\n\n// src/react/copilot/utils/withoutAbort.ts\nvar withoutAbort = (editor, fn) => {\n  editor.setOption(CopilotPlugin, \"shouldAbort\", false);\n  fn();\n  editor.setOption(CopilotPlugin, \"shouldAbort\", true);\n};\n\n// src/react/copilot/transforms/acceptCopilotNextWord.ts\nvar acceptCopilotNextWord = (editor) => {\n  const { api, getOptions } = getEditorPlugin6(editor, {\n    key: \"copilot\"\n  });\n  const { getNextWord: getNextWord2, suggestionText } = getOptions();\n  if (suggestionText == null ? void 0 : suggestionText.length) {\n    const { firstWord, remainingText } = getNextWord2({ text: suggestionText });\n    api.copilot.setBlockSuggestion({\n      text: remainingText\n    });\n    withoutAbort(editor, () => {\n      editor.insertFragment(deserializeInlineMd3(editor, firstWord));\n    });\n  }\n};\n\n// src/react/copilot/withCopilot.ts\nimport { withoutMergingHistory } from \"@udecode/plate-common\";\nimport {\n  isEditorFocused\n} from \"@udecode/plate-common/react\";\nimport { serializeInlineMd } from \"@udecode/plate-markdown\";\nimport debounce from \"lodash/debounce.js\";\nimport { Range as Range2 } from \"slate\";\nvar getPatchString = (operations) => {\n  let string = \"\";\n  for (const operation of operations) {\n    if (operation.type === \"insert_node\") {\n      const node = operation.node;\n      const text = serializeInlineMd([node]);\n      string += text;\n    } else if (operation.type === \"insert_text\") {\n      string += operation.text;\n    }\n  }\n  return string;\n};\nvar withCopilot = ({\n  api,\n  editor,\n  getOptions,\n  setOption\n}) => {\n  const { apply, insertText, redo, setSelection, undo, writeHistory } = editor;\n  const debounceDelay = getOptions().debounceDelay;\n  if (debounceDelay) {\n    api.copilot.triggerSuggestion = debounce(\n      api.copilot.triggerSuggestion,\n      debounceDelay\n    );\n  }\n  editor.undo = () => {\n    if (!getOptions().suggestionText) return undo();\n    const lastUndos = editor.history.undos.at(-1);\n    const oldText = getOptions().suggestionText;\n    if (lastUndos && lastUndos.shouldAbort === false && oldText) {\n      withoutAbort(editor, () => {\n        const shouldInsertText = getPatchString(lastUndos.operations);\n        const newText = shouldInsertText + oldText;\n        setOption(\"suggestionText\", newText);\n        undo();\n      });\n      return;\n    }\n    return undo();\n  };\n  editor.redo = () => {\n    if (!getOptions().suggestionText) return redo();\n    const topRedo = editor.history.redos.at(-1);\n    const prevSuggestion = getOptions().suggestionText;\n    if (topRedo && topRedo.shouldAbort === false && prevSuggestion) {\n      withoutAbort(editor, () => {\n        const shouldRemoveText = getPatchString(topRedo.operations);\n        const newText = prevSuggestion.slice(shouldRemoveText.length);\n        setOption(\"suggestionText\", newText);\n        redo();\n      });\n      return;\n    }\n    return redo();\n  };\n  editor.writeHistory = (stacks, batch) => {\n    if (!getOptions().isLoading) {\n      batch.shouldAbort = getOptions().shouldAbort;\n    }\n    return writeHistory(stacks, batch);\n  };\n  editor.apply = (operation) => {\n    const { shouldAbort } = getOptions();\n    if (shouldAbort) {\n      api.copilot.reset();\n    }\n    apply(operation);\n  };\n  editor.insertText = (text) => {\n    const suggestionText = getOptions().suggestionText;\n    if (suggestionText == null ? void 0 : suggestionText.startsWith(text)) {\n      withoutAbort(editor, () => {\n        withoutMergingHistory(editor, () => {\n          const newText = suggestionText == null ? void 0 : suggestionText.slice(text.length);\n          setOption(\"suggestionText\", newText);\n          insertText(text);\n        });\n      });\n      return;\n    }\n    insertText(text);\n  };\n  let prevSelection = null;\n  editor.setSelection = (selection) => {\n    setSelection(selection);\n    if (editor.selection && (!prevSelection || !Range2.equals(prevSelection, editor.selection)) && getOptions().autoTriggerQuery({ editor }) && isEditorFocused(editor)) {\n      void api.copilot.triggerSuggestion();\n    }\n    prevSelection = editor.selection;\n  };\n  return editor;\n};\n\n// src/react/copilot/CopilotPlugin.tsx\nvar CopilotPlugin = createTPlatePlugin2({\n  key: \"copilot\",\n  options: {\n    abortController: null,\n    autoTriggerQuery: ({ editor }) => {\n      if (editor.getOptions({ key: \"copilot\" }).suggestionText) {\n        return false;\n      }\n      const isEmpty = isBlockAboveEmpty(editor);\n      if (isEmpty) return false;\n      const blockAbove = getBlockAbove2(editor);\n      if (!blockAbove) return false;\n      const blockString = getNodeString(blockAbove[0]);\n      return blockString.at(-1) === \" \";\n    },\n    completeOptions: {},\n    completion: \"\",\n    debounceDelay: 0,\n    error: null,\n    getNextWord,\n    getPrompt: ({ editor }) => {\n      const contextEntry = getAncestorNode2(editor);\n      if (!contextEntry) return \"\";\n      return serializeMdNodes2([contextEntry[0]]);\n    },\n    isLoading: false,\n    renderGhostText: null,\n    shouldAbort: true,\n    suggestionNodeId: null,\n    suggestionText: null,\n    triggerQuery: ({ editor }) => {\n      if (isExpanded(editor.selection)) return false;\n      const isEnd = isSelectionAtBlockEnd(editor);\n      if (!isEnd) return false;\n      return true;\n    }\n  },\n  handlers: {\n    onBlur: ({ api }) => {\n      api.copilot.reset();\n    },\n    onMouseDown: ({ api }) => {\n      api.copilot.reset();\n    }\n  }\n}).extendOptions(({ getOptions }) => ({\n  isSuggested: (id) => getOptions().suggestionNodeId === id\n})).extendApi(\n  ({ api, editor, getOptions, setOption, setOptions }) => ({\n    accept: bindFirst3(acceptCopilot, editor),\n    acceptNextWord: bindFirst3(acceptCopilotNextWord, editor),\n    setBlockSuggestion: ({ id = getOptions().suggestionNodeId, text }) => {\n      if (!id) {\n        id = getBlockAbove2(editor)[0].id;\n      }\n      setOptions({\n        suggestionNodeId: id,\n        suggestionText: text\n      });\n    },\n    stop: () => {\n      var _a;\n      const { abortController } = getOptions();\n      (_a = api.copilot.triggerSuggestion) == null ? void 0 : _a.cancel();\n      if (abortController) {\n        abortController.abort();\n        setOption(\"abortController\", null);\n      }\n    },\n    triggerSuggestion: bindFirst3(triggerCopilotSuggestion, editor)\n  })\n).extendApi(({ api, setOptions }) => ({\n  reset: () => {\n    api.copilot.stop();\n    setOptions({\n      completion: null,\n      suggestionNodeId: null,\n      suggestionText: null\n    });\n  }\n})).extend({\n  extendEditor: withCopilot,\n  render: {\n    belowNodes: renderCopilotBelowNodes\n  }\n}).extend(({ api, getOptions }) => {\n  return {\n    shortcuts: {\n      acceptCopilot: {\n        keys: [[Key.Tab]],\n        handler: ({ event }) => {\n          var _a;\n          if (!((_a = getOptions().suggestionText) == null ? void 0 : _a.length)) return;\n          event.preventDefault();\n          api.copilot.accept();\n        }\n      },\n      acceptCopilotNextWord: {\n        keys: [[Key.Meta, Key.ArrowRight]],\n        handler: ({ event }) => {\n          var _a;\n          if (!((_a = getOptions().suggestionText) == null ? void 0 : _a.length)) return;\n          event.preventDefault();\n          api.copilot.acceptNextWord();\n        }\n      },\n      hideCopilot: {\n        keys: [[Key.Escape]],\n        handler: ({ event }) => {\n          var _a;\n          if (!((_a = getOptions().suggestionText) == null ? void 0 : _a.length)) return;\n          event.preventDefault();\n          api.copilot.reset();\n        }\n      },\n      triggerCopilot: {\n        keys: [[Key.Control, \"space\"]],\n        preventDefault: true,\n        handler: () => {\n          void api.copilot.triggerSuggestion();\n        }\n      }\n    }\n  };\n});\nexport {\n  AIChatPlugin,\n  AIPlugin,\n  CopilotPlugin,\n  acceptAIChat,\n  acceptCopilot,\n  acceptCopilotNextWord,\n  callCompletionApi,\n  getEditorPrompt,\n  getLastAssistantMessage,\n  getMarkdown,\n  getNextWord,\n  insertBelowAIChat,\n  renderCopilotBelowNodes,\n  replaceSelectionAIChat,\n  resetAIChat,\n  submitAIChat,\n  triggerCopilotSuggestion,\n  useAIChatHooks,\n  useChatChunk,\n  useEditorChat,\n  useLastAssistantMessage,\n  withAIChat,\n  withCopilot,\n  withoutAbort\n};\n//# sourceMappingURL=index.mjs.map","// src/react/BasicMarksPlugin.tsx\nimport { toPlatePlugin as toPlatePlugin8 } from \"@udecode/plate-common/react\";\n\n// src/lib/BaseBasicMarksPlugin.ts\nimport { createSlatePlugin as createSlatePlugin8 } from \"@udecode/plate-common\";\n\n// src/lib/BaseBoldPlugin.ts\nimport { createSlatePlugin, someHtmlElement } from \"@udecode/plate-common\";\nvar BaseBoldPlugin = createSlatePlugin({\n  key: \"bold\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => !someHtmlElement(\n          element,\n          (node) => node.style.fontWeight === \"normal\"\n        ),\n        rules: [\n          { validNodeName: [\"STRONG\", \"B\"] },\n          {\n            validStyle: {\n              fontWeight: [\"600\", \"700\", \"bold\"]\n            }\n          }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseCodePlugin.ts\nimport {\n  createSlatePlugin as createSlatePlugin2,\n  findHtmlParentElement\n} from \"@udecode/plate-common\";\nvar BaseCodePlugin = createSlatePlugin2({\n  key: \"code\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query({ element }) {\n          const blockAbove = findHtmlParentElement(element, \"P\");\n          if ((blockAbove == null ? void 0 : blockAbove.style.fontFamily) === \"Consolas\") return false;\n          return !findHtmlParentElement(element, \"PRE\");\n        },\n        rules: [\n          { validNodeName: [\"CODE\"] },\n          { validStyle: { fontFamily: \"Consolas\" } }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseItalicPlugin.ts\nimport { createSlatePlugin as createSlatePlugin3, someHtmlElement as someHtmlElement2 } from \"@udecode/plate-common\";\nvar BaseItalicPlugin = createSlatePlugin3({\n  key: \"italic\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => !someHtmlElement2(\n          element,\n          (node) => node.style.fontStyle === \"normal\"\n        ),\n        rules: [\n          { validNodeName: [\"EM\", \"I\"] },\n          { validStyle: { fontStyle: \"italic\" } }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseStrikethroughPlugin.ts\nimport { createSlatePlugin as createSlatePlugin4, someHtmlElement as someHtmlElement3 } from \"@udecode/plate-common\";\nvar BaseStrikethroughPlugin = createSlatePlugin4({\n  key: \"strikethrough\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => !someHtmlElement3(\n          element,\n          (node) => node.style.textDecoration === \"none\"\n        ),\n        rules: [\n          { validNodeName: [\"S\", \"DEL\", \"STRIKE\"] },\n          { validStyle: { textDecoration: \"line-through\" } }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseSubscriptPlugin.ts\nimport { createSlatePlugin as createSlatePlugin5 } from \"@udecode/plate-common\";\nvar BaseSubscriptPlugin = createSlatePlugin5({\n  key: \"subscript\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [\n          { validNodeName: [\"SUB\"] },\n          { validStyle: { verticalAlign: \"sub\" } }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseSuperscriptPlugin.ts\nimport { createSlatePlugin as createSlatePlugin6 } from \"@udecode/plate-common\";\nvar BaseSuperscriptPlugin = createSlatePlugin6({\n  key: \"superscript\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [\n          { validNodeName: [\"SUP\"] },\n          { validStyle: { verticalAlign: \"super\" } }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseUnderlinePlugin.ts\nimport { createSlatePlugin as createSlatePlugin7, someHtmlElement as someHtmlElement4 } from \"@udecode/plate-common\";\nvar BaseUnderlinePlugin = createSlatePlugin7({\n  key: \"underline\",\n  node: { isLeaf: true },\n  parsers: {\n    html: {\n      deserializer: {\n        query: ({ element }) => !someHtmlElement4(\n          element,\n          (node) => node.style.textDecoration === \"none\"\n        ),\n        rules: [\n          { validNodeName: [\"U\"] },\n          { validStyle: { textDecoration: [\"underline\"] } }\n        ]\n      }\n    }\n  }\n});\n\n// src/lib/BaseBasicMarksPlugin.ts\nvar BaseBasicMarksPlugin = createSlatePlugin8({\n  key: \"basicMarks\",\n  plugins: [\n    BaseBoldPlugin,\n    BaseCodePlugin,\n    BaseItalicPlugin,\n    BaseStrikethroughPlugin,\n    BaseSubscriptPlugin,\n    BaseSuperscriptPlugin,\n    BaseUnderlinePlugin\n  ]\n});\n\n// src/react/BoldPlugin.tsx\nimport { Key, toPlatePlugin } from \"@udecode/plate-common/react\";\nvar BoldPlugin = toPlatePlugin(BaseBoldPlugin, ({ editor, type }) => ({\n  shortcuts: {\n    toggleBold: {\n      keys: [[Key.Mod, \"b\"]],\n      preventDefault: true,\n      handler: () => {\n        editor.tf.toggle.mark({ key: type });\n      }\n    }\n  }\n}));\n\n// src/react/CodePlugin.tsx\nimport { Key as Key2, toPlatePlugin as toPlatePlugin2 } from \"@udecode/plate-common/react\";\nvar CodePlugin = toPlatePlugin2(BaseCodePlugin, ({ editor, type }) => ({\n  shortcuts: {\n    toggleCode: {\n      keys: [[Key2.Mod, \"e\"]],\n      preventDefault: true,\n      handler: () => {\n        editor.tf.toggle.mark({ key: type });\n      }\n    }\n  }\n}));\n\n// src/react/ItalicPlugin.tsx\nimport { Key as Key3, toPlatePlugin as toPlatePlugin3 } from \"@udecode/plate-common/react\";\nvar ItalicPlugin = toPlatePlugin3(\n  BaseItalicPlugin,\n  ({ editor, type }) => ({\n    shortcuts: {\n      toggleItalic: {\n        keys: [[Key3.Mod, \"i\"]],\n        preventDefault: true,\n        handler: () => {\n          editor.tf.toggle.mark({ key: type });\n        }\n      }\n    }\n  })\n);\n\n// src/react/StrikethroughPlugin.tsx\nimport { Key as Key4, toPlatePlugin as toPlatePlugin4 } from \"@udecode/plate-common/react\";\nvar StrikethroughPlugin = toPlatePlugin4(\n  BaseStrikethroughPlugin,\n  ({ editor, type }) => ({\n    shortcuts: {\n      toggleStrikethrough: {\n        keys: [[Key4.Mod, Key4.Shift, \"x\"]],\n        preventDefault: true,\n        handler: () => {\n          editor.tf.toggle.mark({ key: type });\n        }\n      }\n    }\n  })\n);\n\n// src/react/SubscriptPlugin.tsx\nimport { Key as Key6, toPlatePlugin as toPlatePlugin6 } from \"@udecode/plate-common/react\";\n\n// src/react/SuperscriptPlugin.tsx\nimport { Key as Key5, toPlatePlugin as toPlatePlugin5 } from \"@udecode/plate-common/react\";\nvar SuperscriptPlugin = toPlatePlugin5(\n  BaseSuperscriptPlugin,\n  ({ editor, type }) => ({\n    shortcuts: {\n      toggleSuperscript: {\n        keys: [[Key5.Mod, \".\"]],\n        preventDefault: true,\n        handler: () => {\n          editor.tf.toggle.mark({\n            key: type,\n            clear: editor.getType(SubscriptPlugin)\n          });\n        }\n      }\n    }\n  })\n);\n\n// src/react/SubscriptPlugin.tsx\nvar SubscriptPlugin = toPlatePlugin6(\n  BaseSubscriptPlugin,\n  ({ editor, type }) => ({\n    shortcuts: {\n      toggleSubscript: {\n        keys: [[Key6.Mod, \",\"]],\n        preventDefault: true,\n        handler: () => {\n          editor.tf.toggle.mark({\n            key: type,\n            clear: editor.getType(SuperscriptPlugin)\n          });\n        }\n      }\n    }\n  })\n);\n\n// src/react/UnderlinePlugin.tsx\nimport { Key as Key7, toPlatePlugin as toPlatePlugin7 } from \"@udecode/plate-common/react\";\nvar UnderlinePlugin = toPlatePlugin7(\n  BaseUnderlinePlugin,\n  ({ editor, type }) => ({\n    shortcuts: {\n      toggleUnderline: {\n        keys: [[Key7.Mod, \"u\"]],\n        preventDefault: true,\n        handler: () => {\n          editor.tf.toggle.mark({ key: type });\n        }\n      }\n    }\n  })\n);\n\n// src/react/BasicMarksPlugin.tsx\nvar BasicMarksPlugin = toPlatePlugin8(BaseBasicMarksPlugin, {\n  plugins: [\n    BoldPlugin,\n    CodePlugin,\n    ItalicPlugin,\n    StrikethroughPlugin,\n    SubscriptPlugin,\n    SuperscriptPlugin,\n    UnderlinePlugin\n  ]\n});\nexport {\n  BasicMarksPlugin,\n  BoldPlugin,\n  CodePlugin,\n  ItalicPlugin,\n  StrikethroughPlugin,\n  SubscriptPlugin,\n  SuperscriptPlugin,\n  UnderlinePlugin\n};\n//# sourceMappingURL=index.mjs.map","// src/react/CodeBlockPlugin.tsx\nimport { Key, toPlatePlugin } from \"@udecode/plate-common/react\";\n\n// src/lib/BaseCodeBlockPlugin.ts\nimport {\n  HtmlPlugin,\n  createSlatePlugin,\n  createTSlatePlugin,\n  someNode as someNode3\n} from \"@udecode/plate-common\";\n\n// src/lib/insertFragmentCodeBlock.ts\nimport {\n  getBlockAbove,\n  getNodeString\n} from \"@udecode/plate-common\";\nfunction extractCodeLinesFromCodeBlock(node) {\n  return node.children;\n}\nvar insertFragmentCodeBlock = (editor) => {\n  const { insertFragment } = editor;\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const codeLineType = editor.getType(BaseCodeLinePlugin);\n  function convertNodeToCodeLine(node) {\n    return {\n      children: [{ text: getNodeString(node) }],\n      type: codeLineType\n    };\n  }\n  return (fragment) => {\n    var _a;\n    const [blockAbove] = (_a = getBlockAbove(editor)) != null ? _a : [];\n    if (blockAbove && [codeBlockType, codeLineType].includes(blockAbove == null ? void 0 : blockAbove.type)) {\n      return insertFragment(\n        fragment.flatMap((node) => {\n          const element = node;\n          return element.type === codeBlockType ? extractCodeLinesFromCodeBlock(element) : convertNodeToCodeLine(element);\n        })\n      );\n    }\n    return insertFragment(fragment);\n  };\n};\n\n// src/lib/normalizers/normalizeCodeBlock.tsx\nimport {\n  getChildren,\n  isElement,\n  setNodes\n} from \"@udecode/plate-common\";\nvar normalizeCodeBlock = (editor) => {\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const codeLineType = editor.getType(BaseCodeLinePlugin);\n  const { normalizeNode } = editor;\n  return ([node, path]) => {\n    normalizeNode([node, path]);\n    if (!isElement(node)) {\n      return;\n    }\n    const isCodeBlockRoot = node.type === codeBlockType;\n    if (isCodeBlockRoot) {\n      const nonCodeLine = getChildren([node, path]).find(\n        ([child]) => child.type !== codeLineType\n      );\n      if (nonCodeLine) {\n        setNodes(\n          editor,\n          { type: codeLineType },\n          { at: nonCodeLine[1] }\n        );\n      }\n    }\n  };\n};\n\n// src/lib/queries/getCodeLineEntry.ts\nimport {\n  getAboveNode,\n  getParentNode,\n  isElement as isElement2,\n  someNode\n} from \"@udecode/plate-common\";\nvar getCodeLineEntry = (editor, { at = editor.selection } = {}) => {\n  if (at && someNode(editor, {\n    at,\n    match: { type: editor.getType(BaseCodeLinePlugin) }\n  })) {\n    const selectionParent = getParentNode(editor, at);\n    if (!selectionParent) return;\n    const [, parentPath] = selectionParent;\n    const codeLine = getAboveNode(editor, {\n      at,\n      match: { type: editor.getType(BaseCodeLinePlugin) }\n    }) || getParentNode(editor, parentPath);\n    if (!codeLine) return;\n    const [codeLineNode, codeLinePath] = codeLine;\n    if (isElement2(codeLineNode) && codeLineNode.type !== editor.getType(BaseCodeLinePlugin))\n      return;\n    const codeBlock = getParentNode(editor, codeLinePath);\n    if (!codeBlock) return;\n    return {\n      codeBlock,\n      codeLine\n    };\n  }\n};\n\n// src/lib/queries/getIndentDepth.ts\nimport { getEditorString } from \"@udecode/plate-common\";\nvar getIndentDepth = (editor, { codeLine }) => {\n  const [, codeLinePath] = codeLine;\n  const text = getEditorString(editor, codeLinePath);\n  return text.search(/\\S|$/);\n};\n\n// src/lib/transforms/deleteStartSpace.ts\nimport {\n  deleteText,\n  getEditorString as getEditorString2,\n  getPointAfter,\n  getRange,\n  getStartPoint\n} from \"@udecode/plate-common\";\nvar deleteStartSpace = (editor, { codeLine }) => {\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = getStartPoint(editor, codeLinePath);\n  const codeLineEnd = codeLineStart && getPointAfter(editor, codeLineStart);\n  const spaceRange = codeLineEnd && getRange(editor, codeLineStart, codeLineEnd);\n  const spaceText = getEditorString2(editor, spaceRange);\n  if (/\\s/.test(spaceText)) {\n    deleteText(editor, { at: spaceRange });\n    return true;\n  }\n  return false;\n};\n\n// src/lib/transforms/indentCodeLine.ts\nimport {\n  getEditorString as getEditorString3,\n  getRange as getRange2,\n  getStartPoint as getStartPoint2,\n  insertText,\n  isExpanded\n} from \"@udecode/plate-common\";\nvar indentCodeLine = (editor, { codeLine, indentDepth = 2 }) => {\n  var _a;\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = getStartPoint2(editor, codeLinePath);\n  const indent = \" \".repeat(indentDepth);\n  if (!isExpanded(editor.selection)) {\n    const cursor = (_a = editor.selection) == null ? void 0 : _a.anchor;\n    const range = getRange2(editor, codeLineStart, cursor);\n    const text = getEditorString3(editor, range);\n    if (/\\S/.test(text)) {\n      insertText(editor, indent, { at: editor.selection });\n      return;\n    }\n  }\n  insertText(editor, indent, { at: codeLineStart });\n};\n\n// src/lib/transforms/outdentCodeLine.ts\nvar outdentCodeLine = (editor, { codeBlock, codeLine }) => {\n  const deleted = deleteStartSpace(editor, { codeBlock, codeLine });\n  deleted && deleteStartSpace(editor, { codeBlock, codeLine });\n};\n\n// src/lib/transforms/toggleCodeBlock.ts\nimport {\n  setElements as setElements2,\n  someNode as someNode2,\n  withoutNormalizing as withoutNormalizing2,\n  wrapNodes\n} from \"@udecode/plate-common\";\n\n// src/lib/transforms/unwrapCodeBlock.ts\nimport {\n  BaseParagraphPlugin,\n  getChildren as getChildren2,\n  getNodeEntries,\n  setElements,\n  unwrapNodes,\n  withoutNormalizing\n} from \"@udecode/plate-common\";\nvar unwrapCodeBlock = (editor) => {\n  if (!editor.selection) return;\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const defaultType = editor.getType(BaseParagraphPlugin);\n  withoutNormalizing(editor, () => {\n    const codeBlockEntries = getNodeEntries(editor, {\n      at: editor.selection,\n      match: { type: codeBlockType }\n    });\n    const reversedCodeBlockEntries = Array.from(codeBlockEntries).reverse();\n    for (const codeBlockEntry of reversedCodeBlockEntries) {\n      const codeLineEntries = getChildren2(codeBlockEntry);\n      for (const [, path] of codeLineEntries) {\n        setElements(editor, { type: defaultType }, { at: path });\n      }\n      unwrapNodes(editor, {\n        at: codeBlockEntry[1],\n        match: { type: codeBlockType },\n        split: true\n      });\n    }\n  });\n};\n\n// src/lib/transforms/toggleCodeBlock.ts\nvar toggleCodeBlock = (editor) => {\n  if (!editor.selection) return;\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const codeLineType = editor.getType(BaseCodeLinePlugin);\n  const isActive = someNode2(editor, {\n    match: { type: codeBlockType }\n  });\n  withoutNormalizing2(editor, () => {\n    unwrapCodeBlock(editor);\n    if (!isActive) {\n      setElements2(editor, {\n        type: codeLineType\n      });\n      const codeBlock = {\n        children: [],\n        type: codeBlockType\n      };\n      wrapNodes(editor, codeBlock);\n    }\n  });\n};\n\n// src/lib/withCodeBlock.ts\nvar withCodeBlock = ({ editor }) => {\n  const { insertBreak } = editor;\n  const insertBreakCodeBlock = () => {\n    if (!editor.selection) return;\n    const res = getCodeLineEntry(editor, {});\n    if (!res) return;\n    const { codeBlock, codeLine } = res;\n    const indentDepth = getIndentDepth(editor, {\n      codeBlock,\n      codeLine\n    });\n    insertBreak();\n    indentCodeLine(editor, {\n      codeBlock,\n      codeLine,\n      indentDepth\n    });\n    return true;\n  };\n  editor.insertBreak = () => {\n    if (insertBreakCodeBlock()) return;\n    insertBreak();\n  };\n  editor.insertFragment = insertFragmentCodeBlock(editor);\n  editor.normalizeNode = normalizeCodeBlock(editor);\n  return editor;\n};\n\n// src/lib/decorateCodeLine.ts\nimport { getNodeString as getNodeString2, getParentNode as getParentNode2 } from \"@udecode/plate-common\";\nvar decorateCodeLine = ({\n  editor,\n  entry: [node, path],\n  type\n}) => {\n  var _a;\n  const codeBlockOptions = editor.getOptions(BaseCodeBlockPlugin);\n  const { prism: Prism } = codeBlockOptions;\n  if (!Prism) return [];\n  const { Token, languages, tokenize } = Prism;\n  const ranges = [];\n  if (!codeBlockOptions.syntax || node.type !== type) {\n    return ranges;\n  }\n  const codeBlock = getParentNode2(editor, path);\n  if (!codeBlock) {\n    return ranges;\n  }\n  let langName = (_a = codeBlock[0].lang) != null ? _a : \"\";\n  if (langName === \"plain\") {\n    langName = \"\";\n  }\n  const lang = languages[langName];\n  if (!lang) {\n    return ranges;\n  }\n  const text = getNodeString2(node);\n  const tokens = tokenize(text, lang);\n  let offset = 0;\n  for (const element of tokens) {\n    if (element instanceof Token) {\n      ranges.push({\n        [BaseCodeSyntaxPlugin.key]: true,\n        anchor: { offset, path },\n        focus: { offset: offset + element.length, path },\n        tokenType: element.type\n      });\n    }\n    offset += element.length;\n  }\n  return ranges;\n};\n\n// src/lib/htmlDeserializerCodeBlock.ts\nvar htmlDeserializerCodeBlock = {\n  parse: ({ element }) => {\n    var _a, _b;\n    const languageSelectorText = ((_a = [...element.childNodes].find(\n      (node) => node.nodeName === \"SELECT\"\n    )) == null ? void 0 : _a.textContent) || \"\";\n    const textContent = ((_b = element.textContent) == null ? void 0 : _b.replace(languageSelectorText, \"\")) || \"\";\n    let lines = textContent.split(\"\\n\");\n    if (!(lines == null ? void 0 : lines.length)) {\n      lines = [textContent];\n    }\n    const codeLines = lines.map((line) => ({\n      children: [{ text: line }],\n      type: BaseCodeLinePlugin.key\n    }));\n    return {\n      children: codeLines,\n      type: BaseCodeBlockPlugin.key\n    };\n  },\n  rules: [\n    {\n      validNodeName: \"PRE\"\n    },\n    {\n      validNodeName: \"P\",\n      validStyle: {\n        fontFamily: \"Consolas\"\n      }\n    }\n  ]\n};\n\n// src/lib/BaseCodeBlockPlugin.ts\nvar BaseCodeLinePlugin = createSlatePlugin({\n  key: \"code_line\",\n  decorate: decorateCodeLine,\n  node: { isElement: true }\n});\nvar BaseCodeSyntaxPlugin = createSlatePlugin({\n  key: \"code_syntax\",\n  node: { isLeaf: true }\n});\nvar BaseCodeBlockPlugin = createTSlatePlugin({\n  key: \"code_block\",\n  extendEditor: withCodeBlock,\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          query: ({ editor }) => {\n            const codeLineType = editor.getType(BaseCodeLinePlugin);\n            return !someNode3(editor, {\n              match: { type: codeLineType }\n            });\n          }\n        }\n      }\n    }\n  },\n  node: { isElement: true },\n  options: {\n    syntax: true,\n    syntaxPopularFirst: false\n  },\n  parsers: { html: { deserializer: htmlDeserializerCodeBlock } },\n  plugins: [BaseCodeLinePlugin, BaseCodeSyntaxPlugin]\n});\n\n// src/react/onKeyDownCodeBlock.ts\nimport {\n  getNodeEntries as getNodeEntries2,\n  getParentNode as getParentNode3,\n  isHotkey,\n  isSelectionAtBlockEnd,\n  isSelectionAtBlockStart,\n  select,\n  withoutNormalizing as withoutNormalizing3\n} from \"@udecode/plate-common\";\nimport { Hotkeys } from \"@udecode/plate-common/react\";\nvar onKeyDownCodeBlock = ({ editor, event }) => {\n  if (event.defaultPrevented) return;\n  const isTab = Hotkeys.isTab(editor, event);\n  const isUntab = Hotkeys.isUntab(editor, event);\n  if (isTab || isUntab) {\n    const _codeLines = getNodeEntries2(editor, {\n      match: { type: editor.getType(BaseCodeLinePlugin) }\n    });\n    const codeLines = Array.from(_codeLines);\n    if (codeLines.length > 0) {\n      event.preventDefault();\n      const [, firstLinePath] = codeLines[0];\n      const codeBlock = getParentNode3(editor, firstLinePath);\n      if (!codeBlock) return;\n      withoutNormalizing3(editor, () => {\n        for (const codeLine of codeLines) {\n          if (isUntab) {\n            outdentCodeLine(editor, { codeBlock, codeLine });\n          }\n          if (isTab) {\n            indentCodeLine(editor, { codeBlock, codeLine });\n          }\n        }\n      });\n    }\n  }\n  if (isHotkey(\"mod+a\", event)) {\n    const res = getCodeLineEntry(editor, {});\n    if (!res) return;\n    const { codeBlock } = res;\n    const [, codeBlockPath] = codeBlock;\n    if (isSelectionAtBlockEnd(editor) && isSelectionAtBlockStart(editor))\n      return;\n    select(editor, codeBlockPath);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n};\n\n// src/react/CodeBlockPlugin.tsx\nvar CodeLinePlugin = toPlatePlugin(BaseCodeLinePlugin);\nvar CodeSyntaxPlugin = toPlatePlugin(BaseCodeSyntaxPlugin);\nvar CodeBlockPlugin = toPlatePlugin(BaseCodeBlockPlugin, {\n  plugins: [CodeLinePlugin, CodeSyntaxPlugin],\n  handlers: {\n    onKeyDown: onKeyDownCodeBlock\n  }\n}).extend(({ editor, type }) => ({\n  shortcuts: {\n    toggleCodeBlock: {\n      keys: [[Key.Mod, Key.Alt, \"8\"]],\n      preventDefault: true,\n      handler: () => {\n        editor.tf.toggle.block({ type });\n      }\n    }\n  }\n}));\n\n// src/react/hooks/useCodeBlockCombobox.ts\nimport React from \"react\";\nimport { setNodes as setNodes2 } from \"@udecode/plate-common\";\nimport {\n  findNodePath,\n  useEditorRef,\n  useElement\n} from \"@udecode/plate-common/react\";\nimport { useReadOnly } from \"slate-react\";\nvar useCodeBlockComboboxState = () => {\n  var _a;\n  const editor = useEditorRef();\n  const readOnly = useReadOnly();\n  const element = useElement();\n  const [value, setValue] = React.useState((_a = element.lang) != null ? _a : \"text\");\n  const { syntaxPopularFirst } = editor.getOptions(BaseCodeBlockPlugin);\n  React.useEffect(() => {\n    var _a2;\n    setValue((_a2 = element.lang) != null ? _a2 : \"text\");\n  }, [element.lang]);\n  return {\n    element,\n    readOnly,\n    setValue,\n    syntaxPopularFirst,\n    value\n  };\n};\nvar useCodeBlockCombobox = ({\n  element,\n  setValue\n}) => {\n  const editor = useEditorRef();\n  return {\n    commandItemProps: {\n      onSelect: (_value) => {\n        const path = findNodePath(editor, element);\n        path && setNodes2(editor, { lang: _value }, { at: path });\n        setValue(_value);\n      }\n    }\n  };\n};\n\n// src/react/hooks/useCodeBlockElement.ts\nimport React2 from \"react\";\nimport { useEditorRef as useEditorRef2 } from \"@udecode/plate-common/react\";\nvar useCodeBlockElementState = ({\n  element\n}) => {\n  const editor = useEditorRef2();\n  const [domLoaded, setDomLoaded] = React2.useState(false);\n  const { lang } = element;\n  const codeClassName = lang ? `${lang} language-${lang}` : \"\";\n  React2.useEffect(() => {\n    setDomLoaded(true);\n  }, []);\n  const { syntax } = editor.getOptions(BaseCodeBlockPlugin);\n  return {\n    className: domLoaded && codeClassName,\n    syntax\n  };\n};\n\n// src/react/hooks/useCodeSyntaxLeaf.tsx\nvar useCodeSyntaxLeaf = ({ leaf }) => {\n  return {\n    tokenProps: {\n      className: `prism-token token ${leaf.tokenType}`\n    }\n  };\n};\n\n// src/react/hooks/useToggleCodeBlockButton.ts\nimport { useEditorRef as useEditorRef3 } from \"@udecode/plate-common/react\";\nvar useToggleCodeBlockButton = () => {\n  const editor = useEditorRef3();\n  return {\n    props: {\n      onClick: () => {\n        toggleCodeBlock(editor);\n      },\n      onMouseDown: (e) => {\n        e.preventDefault();\n      }\n    }\n  };\n};\nexport {\n  CodeBlockPlugin,\n  CodeLinePlugin,\n  CodeSyntaxPlugin,\n  onKeyDownCodeBlock,\n  useCodeBlockCombobox,\n  useCodeBlockComboboxState,\n  useCodeBlockElementState,\n  useCodeSyntaxLeaf,\n  useToggleCodeBlockButton\n};\n//# sourceMappingURL=index.mjs.map","var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n// src/react/TablePlugin.tsx\nimport { toPlatePlugin } from \"@udecode/plate-common/react\";\n\n// src/lib/BaseTablePlugin.ts\nimport {\n  bindFirst,\n  createSlatePlugin,\n  createTSlatePlugin\n} from \"@udecode/plate-common\";\n\n// src/lib/transforms/deleteTable.ts\nimport {\n  getAboveNode,\n  removeNodes,\n  someNode\n} from \"@udecode/plate-common\";\nvar deleteTable = (editor) => {\n  if (someNode(editor, {\n    match: { type: editor.getType(BaseTablePlugin) }\n  })) {\n    const tableItem = getAboveNode(editor, {\n      match: { type: editor.getType(BaseTablePlugin) }\n    });\n    if (tableItem) {\n      removeNodes(editor, {\n        at: tableItem[1]\n      });\n    }\n  }\n};\n\n// src/lib/transforms/insertTableColumn.ts\nimport {\n  findNode as findNode6,\n  getBlockAbove as getBlockAbove3,\n  getEditorPlugin as getEditorPlugin3,\n  insertElements as insertElements2,\n  setNodes as setNodes2,\n  withoutNormalizing as withoutNormalizing2\n} from \"@udecode/plate-common\";\nimport { Path as Path6 } from \"slate\";\n\n// src/lib/merge/insertTableColumn.ts\nimport {\n  findNode as findNode5,\n  getBlockAbove as getBlockAbove2,\n  getParentNode,\n  insertElements,\n  setNodes,\n  withoutNormalizing\n} from \"@udecode/plate-common\";\nimport { getEditorPlugin as getEditorPlugin2 } from \"@udecode/plate-common\";\nimport cloneDeep from \"lodash/cloneDeep.js\";\nimport { Path as Path5 } from \"slate\";\n\n// src/lib/queries/getColSpan.ts\nvar getColSpan = (cellElem) => {\n  var _a;\n  return cellElem.colSpan || Number((_a = cellElem.attributes) == null ? void 0 : _a.colspan) || 1;\n};\n\n// src/lib/queries/getRowSpan.ts\nvar getRowSpan = (cellElem) => {\n  var _a;\n  return cellElem.rowSpan || Number((_a = cellElem.attributes) == null ? void 0 : _a.rowspan) || 1;\n};\n\n// src/lib/utils/getCellRowIndexByPath.ts\nvar getCellRowIndexByPath = (cellPath) => {\n  const index = cellPath.at(-2);\n  if (index === void 0)\n    throw new Error(`can not get rowIndex of path ${cellPath}`);\n  return index;\n};\n\n// src/lib/utils/getCellType.ts\nimport { getPluginTypes } from \"@udecode/plate-common\";\nvar getCellTypes = (editor) => getPluginTypes(editor, [BaseTableCellPlugin, BaseTableCellHeaderPlugin]);\n\n// src/lib/utils/getEmptyCellNode.ts\nvar getEmptyCellNode = (editor, { children, header, row } = {}) => {\n  header = header != null ? header : row ? row.children.every(\n    (c) => c.type === editor.getType(BaseTableCellHeaderPlugin)\n  ) : false;\n  return {\n    children: children != null ? children : [editor.api.create.block()],\n    type: header ? editor.getType(BaseTableCellHeaderPlugin) : editor.getType(BaseTableCellPlugin)\n  };\n};\n\n// src/lib/utils/getEmptyRowNode.ts\nimport { getEditorPlugin } from \"@udecode/plate-common\";\nvar getEmptyRowNode = (editor, _a = {}) => {\n  var _b = _a, { colCount = 1 } = _b, cellOptions = __objRest(_b, [\"colCount\"]);\n  const { api } = getEditorPlugin(editor, BaseTablePlugin);\n  return {\n    children: Array.from({ length: colCount }).fill(colCount).map(() => api.create.cell(cellOptions)),\n    type: editor.getType(BaseTableRowPlugin)\n  };\n};\n\n// src/lib/utils/getEmptyTableNode.ts\nvar getEmptyTableNode = (editor, _a = {}) => {\n  var _b = _a, {\n    colCount,\n    header,\n    rowCount = 0\n  } = _b, cellOptions = __objRest(_b, [\n    \"colCount\",\n    \"header\",\n    \"rowCount\"\n  ]);\n  const rows = Array.from({ length: rowCount }).fill(rowCount).map(\n    (_, index) => getEmptyRowNode(editor, __spreadProps(__spreadValues({\n      colCount\n    }, cellOptions), {\n      header: header && index === 0\n    }))\n  );\n  return {\n    children: rows,\n    type: editor.getType(BaseTablePlugin)\n  };\n};\n\n// src/lib/queries/getCellInNextTableRow.ts\nimport {\n  getNodeEntry\n} from \"@udecode/plate-common\";\nimport { Path } from \"slate\";\nvar getCellInNextTableRow = (editor, currentRowPath) => {\n  var _a;\n  const nextRow = getNodeEntry(editor, Path.next(currentRowPath));\n  if (!nextRow) return;\n  const [nextRowNode, nextRowPath] = nextRow;\n  const nextCell = (_a = nextRowNode == null ? void 0 : nextRowNode.children) == null ? void 0 : _a[0];\n  const nextCellPath = nextRowPath.concat(0);\n  if (nextCell && nextCellPath) {\n    return getNodeEntry(editor, nextCellPath);\n  }\n};\n\n// src/lib/queries/getCellInPreviousTableRow.ts\nimport {\n  getNodeEntry as getNodeEntry2,\n  getPreviousPath\n} from \"@udecode/plate-common\";\nvar getCellInPreviousTableRow = (editor, currentRowPath) => {\n  var _a;\n  const prevPath = getPreviousPath(currentRowPath);\n  if (!prevPath) return;\n  const previousRow = getNodeEntry2(editor, prevPath);\n  if (!previousRow) return;\n  const [previousRowNode, previousRowPath] = previousRow;\n  const previousCell = (_a = previousRowNode == null ? void 0 : previousRowNode.children) == null ? void 0 : _a[previousRowNode.children.length - 1];\n  const previousCellPath = previousRowPath.concat(\n    previousRowNode.children.length - 1\n  );\n  if (previousCell && previousCellPath) {\n    return getNodeEntry2(editor, previousCellPath);\n  }\n};\n\n// src/lib/queries/getLeftTableCell.ts\nimport {\n  findNode,\n  getNodeEntry as getNodeEntry3\n} from \"@udecode/plate-common\";\nimport { Path as Path2 } from \"slate\";\nvar getLeftTableCell = (editor, {\n  at: cellPath\n} = {}) => {\n  var _a;\n  if (!cellPath) {\n    cellPath = (_a = findNode(editor, {\n      match: { type: getCellTypes(editor) }\n    })) == null ? void 0 : _a[1];\n    if (!cellPath) return;\n  }\n  const cellIndex = cellPath.at(-1);\n  if (!cellIndex) return;\n  const prevCellPath = Path2.previous(cellPath);\n  return getNodeEntry3(editor, prevCellPath);\n};\n\n// src/lib/queries/getNextTableCell.ts\nimport {\n  getNodeEntry as getNodeEntry4\n} from \"@udecode/plate-common\";\nimport { Path as Path3 } from \"slate\";\nvar getNextTableCell = (editor, currentCell, currentPath, currentRow) => {\n  const cell = getNodeEntry4(editor, Path3.next(currentPath));\n  if (cell) return cell;\n  const [, currentRowPath] = currentRow;\n  return getCellInNextTableRow(editor, currentRowPath);\n};\n\n// src/lib/queries/getPreviousTableCell.ts\nimport {\n  getNodeEntry as getNodeEntry5,\n  getPreviousPath as getPreviousPath2\n} from \"@udecode/plate-common\";\nvar getPreviousTableCell = (editor, currentCell, currentPath, currentRow) => {\n  const prevPath = getPreviousPath2(currentPath);\n  if (!prevPath) {\n    const [, currentRowPath] = currentRow;\n    return getCellInPreviousTableRow(editor, currentRowPath);\n  }\n  const cell = getNodeEntry5(editor, prevPath);\n  if (cell) return cell;\n};\n\n// src/lib/queries/getTableAbove.ts\nimport {\n  getBlockAbove\n} from \"@udecode/plate-common\";\nvar getTableAbove = (editor, options) => getBlockAbove(editor, __spreadValues({\n  match: {\n    type: editor.getType(BaseTablePlugin)\n  }\n}, options));\n\n// src/lib/queries/getTableColumnCount.ts\nvar getTableColumnCount = (tableNode) => {\n  var _a, _b;\n  if ((_b = (_a = tableNode.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.children) {\n    return tableNode.children[0].children.map(\n      (element) => {\n        var _a2;\n        return element.colSpan || ((_a2 = element == null ? void 0 : element.attributes) == null ? void 0 : _a2.colspan) || 1;\n      }\n    ).reduce((total, num) => Number(total) + Number(num));\n  }\n  return 0;\n};\n\n// src/lib/queries/getTableEntries.ts\nimport {\n  findNode as findNode2,\n  getAboveNode as getAboveNode2\n} from \"@udecode/plate-common\";\nvar getTableEntries = (editor, { at = editor.selection } = {}) => {\n  if (!at) return;\n  const cellEntry = findNode2(editor, {\n    at,\n    match: {\n      type: getCellTypes(editor)\n    }\n  });\n  if (!cellEntry) return;\n  const [, cellPath] = cellEntry;\n  const rowEntry = getAboveNode2(editor, {\n    at: cellPath,\n    match: { type: editor.getType(BaseTableRowPlugin) }\n  });\n  if (!rowEntry) return;\n  const [, rowPath] = rowEntry;\n  const tableEntry = getAboveNode2(editor, {\n    at: rowPath,\n    match: { type: editor.getType(BaseTablePlugin) }\n  });\n  if (!tableEntry) return;\n  return {\n    cell: cellEntry,\n    row: rowEntry,\n    table: tableEntry\n  };\n};\n\n// src/lib/queries/getTableOverriddenColSizes.ts\nvar getTableOverriddenColSizes = (tableNode, colSizeOverrides) => {\n  const colCount = getTableColumnCount(tableNode);\n  const colSizes = (tableNode.colSizes ? [...tableNode.colSizes] : Array.from({ length: colCount }).fill(0)).map((size, index) => {\n    var _a, _b;\n    return (_b = (_a = colSizeOverrides == null ? void 0 : colSizeOverrides.get) == null ? void 0 : _a.call(colSizeOverrides, index)) != null ? _b : size;\n  });\n  return colSizes;\n};\n\n// src/lib/queries/getTopTableCell.ts\nimport {\n  findNode as findNode3,\n  getNodeEntry as getNodeEntry6\n} from \"@udecode/plate-common\";\nimport { Path as Path4 } from \"slate\";\nvar getTopTableCell = (editor, {\n  at: cellPath\n} = {}) => {\n  var _a;\n  if (!cellPath) {\n    cellPath = (_a = findNode3(editor, {\n      match: { type: getCellTypes(editor) }\n    })) == null ? void 0 : _a[1];\n    if (!cellPath) return;\n  }\n  const cellIndex = cellPath.at(-1);\n  const rowIndex = cellPath.at(-2);\n  if (rowIndex === 0) return;\n  const cellAbovePath = [\n    ...Path4.parent(Path4.parent(cellPath)),\n    rowIndex - 1,\n    cellIndex\n  ];\n  return getNodeEntry6(editor, cellAbovePath);\n};\n\n// src/lib/queries/isTableBorderHidden.ts\nimport { findNode as findNode4 } from \"@udecode/plate-common\";\nvar isTableBorderHidden = (editor, border) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  if (border === \"left\") {\n    const node = (_a = getLeftTableCell(editor)) == null ? void 0 : _a[0];\n    if (node) {\n      return ((_c = (_b = node.borders) == null ? void 0 : _b.right) == null ? void 0 : _c.size) === 0;\n    }\n  }\n  if (border === \"top\") {\n    const node = (_d = getTopTableCell(editor)) == null ? void 0 : _d[0];\n    if (node) {\n      return ((_f = (_e = node.borders) == null ? void 0 : _e.bottom) == null ? void 0 : _f.size) === 0;\n    }\n  }\n  return ((_i = (_h = (_g = findNode4(editor, {\n    match: { type: getCellTypes(editor) }\n  })) == null ? void 0 : _g[0].borders) == null ? void 0 : _h[border]) == null ? void 0 : _i.size) === 0;\n};\n\n// src/lib/merge/computeCellIndices.ts\nfunction computeCellIndices(editor, tableNode, cellNode) {\n  var _a, _b;\n  const options = editor.getOptions(BaseTablePlugin);\n  const skipCells = [];\n  let targetIndices;\n  for (let rowIndex = 0; rowIndex < tableNode.children.length; rowIndex++) {\n    const row = tableNode.children[rowIndex];\n    let colIndex = 0;\n    for (const cellElement of row.children) {\n      while ((_a = skipCells[rowIndex]) == null ? void 0 : _a[colIndex]) {\n        colIndex++;\n      }\n      const currentIndices = { col: colIndex, row: rowIndex };\n      (_b = options._cellIndices) == null ? void 0 : _b.set(cellElement, currentIndices);\n      if (cellElement === cellNode) {\n        targetIndices = currentIndices;\n        break;\n      }\n      const colSpan = getColSpan(cellElement);\n      const rowSpan = getRowSpan(cellElement);\n      for (let r = 0; r < rowSpan; r++) {\n        skipCells[rowIndex + r] = skipCells[rowIndex + r] || [];\n        for (let c = 0; c < colSpan; c++) {\n          skipCells[rowIndex + r][colIndex + c] = true;\n        }\n      }\n      colIndex += colSpan;\n    }\n    if (targetIndices) break;\n  }\n  return targetIndices;\n}\n\n// src/lib/merge/getCellIndices.ts\nvar getCellIndices = (cellIndices, startCell) => {\n  return cellIndices == null ? void 0 : cellIndices.get(startCell);\n};\n\n// src/lib/merge/getCellIndicesWithSpans.ts\nvar getCellIndicesWithSpans = ({ col, row }, endCell) => {\n  return {\n    col: col + getColSpan(endCell) - 1,\n    row: row + getRowSpan(endCell) - 1\n  };\n};\n\n// src/lib/merge/findCellByIndexes.ts\nvar findCellByIndexes = (editor, table, searchRowIndex, searchColIndex) => {\n  const { _cellIndices: cellIndices } = editor.getOptions(BaseTablePlugin);\n  const allCells = table.children.flatMap(\n    (current) => current.children\n  );\n  const foundCell = allCells.find((cell) => {\n    const cellElement = cell;\n    const indices = getCellIndices(cellIndices, cellElement) || computeCellIndices(editor, table, cellElement);\n    const { col: _startColIndex, row: _startRowIndex } = indices;\n    const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(\n      indices,\n      cellElement\n    );\n    if (searchColIndex >= _startColIndex && searchColIndex <= _endColIndex && searchRowIndex >= _startRowIndex && searchRowIndex <= _endRowIndex) {\n      return true;\n    }\n    return false;\n  });\n  return foundCell;\n};\n\n// src/lib/merge/getCellPath.ts\nvar getCellPath = (editor, tableEntry, curRowIndex, curColIndex) => {\n  const { _cellIndices: cellIndices } = editor.getOptions(BaseTablePlugin);\n  const [tableNode, tablePath] = tableEntry;\n  const rowElem = tableNode.children[curRowIndex];\n  const foundColIndex = rowElem.children.findIndex((c) => {\n    const cE = c;\n    const { col: colIndex } = getCellIndices(cellIndices, cE);\n    return colIndex === curColIndex;\n  });\n  return tablePath.concat([curRowIndex, foundColIndex]);\n};\n\n// src/lib/merge/insertTableColumn.ts\nvar insertTableMergeColumn = (editor, {\n  at,\n  fromCell,\n  header\n} = {}) => {\n  const { api, getOptions, type } = getEditorPlugin2(editor, BaseTablePlugin);\n  const {\n    _cellIndices: cellIndices,\n    initialTableWidth,\n    minColumnWidth\n  } = getOptions();\n  const cellEntry = fromCell ? findNode5(editor, {\n    at: fromCell,\n    match: { type: getCellTypes(editor) }\n  }) : getBlockAbove2(editor, {\n    match: { type: getCellTypes(editor) }\n  });\n  if (!cellEntry) return;\n  const [, cellPath] = cellEntry;\n  const cell = cellEntry[0];\n  const tableEntry = getBlockAbove2(editor, {\n    at: cellPath,\n    match: { type }\n  });\n  if (!tableEntry) return;\n  const [tableNode, tablePath] = tableEntry;\n  const { col: cellColIndex } = getCellIndices(cellIndices, cell) || computeCellIndices(editor, tableNode, cell);\n  const cellColSpan = getColSpan(cell);\n  let nextColIndex;\n  let checkingColIndex;\n  if (Path5.isPath(at)) {\n    nextColIndex = cellColIndex;\n    checkingColIndex = cellColIndex - 1;\n  } else {\n    nextColIndex = cellColIndex + cellColSpan;\n    checkingColIndex = cellColIndex + cellColSpan - 1;\n  }\n  const rowNumber = tableNode.children.length;\n  const firstCol = nextColIndex <= 0;\n  let placementCorrection = 1;\n  if (firstCol) {\n    checkingColIndex = 0;\n    placementCorrection = 0;\n  }\n  const affectedCellsSet = /* @__PURE__ */ new Set();\n  Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {\n    const found = findCellByIndexes(editor, tableNode, rI, checkingColIndex);\n    if (found) {\n      affectedCellsSet.add(found);\n    }\n  });\n  const affectedCells = Array.from(affectedCellsSet);\n  affectedCells.forEach((cur) => {\n    var _a;\n    const curCell = cur;\n    const { col: curColIndex, row: curRowIndex } = getCellIndices(cellIndices, curCell) || computeCellIndices(editor, tableNode, curCell);\n    const curRowSpan = getRowSpan(curCell);\n    const curColSpan = getColSpan(curCell);\n    const currentCellPath = getCellPath(\n      editor,\n      tableEntry,\n      curRowIndex,\n      curColIndex\n    );\n    const endCurI = curColIndex + curColSpan - 1;\n    if (endCurI >= nextColIndex && !firstCol) {\n      const colSpan = curColSpan + 1;\n      const newCell = cloneDeep(__spreadProps(__spreadValues({}, curCell), { colSpan }));\n      if ((_a = newCell.attributes) == null ? void 0 : _a.colspan) {\n        newCell.attributes.colspan = colSpan.toString();\n      }\n      setNodes(editor, newCell, { at: currentCellPath });\n    } else {\n      const curRowPath = currentCellPath.slice(0, -1);\n      const curColPath = currentCellPath.at(-1);\n      const placementPath = [...curRowPath, curColPath + placementCorrection];\n      const row = getParentNode(editor, currentCellPath);\n      const rowElement = row[0];\n      const emptyCell = __spreadProps(__spreadValues({}, api.create.cell({ header, row: rowElement })), {\n        colSpan: 1,\n        rowSpan: curRowSpan\n      });\n      insertElements(editor, emptyCell, {\n        at: placementPath\n        // select: !disableSelect && curRowIndex === currentRowIndex,\n      });\n    }\n  });\n  withoutNormalizing(editor, () => {\n    var _a, _b;\n    const { colSizes } = tableNode;\n    if (colSizes) {\n      let newColSizes = [\n        ...colSizes.slice(0, nextColIndex),\n        0,\n        ...colSizes.slice(nextColIndex)\n      ];\n      if (initialTableWidth) {\n        newColSizes[nextColIndex] = (_b = (_a = colSizes[nextColIndex]) != null ? _a : colSizes[nextColIndex - 1]) != null ? _b : initialTableWidth / colSizes.length;\n        const oldTotal = colSizes.reduce((a, b) => a + b, 0);\n        const newTotal = newColSizes.reduce((a, b) => a + b, 0);\n        const maxTotal = Math.max(oldTotal, initialTableWidth);\n        if (newTotal > maxTotal) {\n          const factor = maxTotal / newTotal;\n          newColSizes = newColSizes.map(\n            (size) => Math.max(minColumnWidth != null ? minColumnWidth : 0, Math.floor(size * factor))\n          );\n        }\n      }\n      setNodes(\n        editor,\n        {\n          colSizes: newColSizes\n        },\n        {\n          at: tablePath\n        }\n      );\n    }\n  });\n};\n\n// src/lib/transforms/insertTableColumn.ts\nvar insertTableColumn = (editor, options = {}) => {\n  const { api, getOptions, type } = getEditorPlugin3(editor, BaseTablePlugin);\n  const { enableMerging, initialTableWidth, minColumnWidth } = getOptions();\n  if (enableMerging) {\n    return insertTableMergeColumn(editor, options);\n  }\n  const { at, disableSelect, fromCell, header } = options;\n  const cellEntry = fromCell ? findNode6(editor, {\n    at: fromCell,\n    match: { type: getCellTypes(editor) }\n  }) : getBlockAbove3(editor, {\n    match: { type: getCellTypes(editor) }\n  });\n  if (!cellEntry) return;\n  const [, cellPath] = cellEntry;\n  const tableEntry = getBlockAbove3(editor, {\n    at: cellPath,\n    match: { type }\n  });\n  if (!tableEntry) return;\n  const [tableNode, tablePath] = tableEntry;\n  let nextCellPath;\n  let nextColIndex;\n  if (Path6.isPath(at)) {\n    nextCellPath = at;\n    nextColIndex = at.at(-1);\n  } else {\n    nextCellPath = Path6.next(cellPath);\n    nextColIndex = cellPath.at(-1) + 1;\n  }\n  const currentRowIndex = cellPath.at(-2);\n  withoutNormalizing2(editor, () => {\n    var _a, _b;\n    tableNode.children.forEach((row, rowIndex) => {\n      const insertCellPath = [...nextCellPath];\n      if (Path6.isPath(at)) {\n        insertCellPath[at.length - 2] = rowIndex;\n      } else {\n        insertCellPath[cellPath.length - 2] = rowIndex;\n      }\n      const isHeaderRow = header === void 0 ? row.children.every(\n        (c) => c.type === editor.getType(BaseTableCellHeaderPlugin)\n      ) : header;\n      insertElements2(\n        editor,\n        api.create.cell({\n          header: isHeaderRow\n        }),\n        {\n          at: insertCellPath,\n          select: !disableSelect && rowIndex === currentRowIndex\n        }\n      );\n    });\n    const { colSizes } = tableNode;\n    if (colSizes) {\n      let newColSizes = [\n        ...colSizes.slice(0, nextColIndex),\n        0,\n        ...colSizes.slice(nextColIndex)\n      ];\n      if (initialTableWidth) {\n        newColSizes[nextColIndex] = (_b = (_a = colSizes[nextColIndex]) != null ? _a : colSizes[nextColIndex - 1]) != null ? _b : initialTableWidth / colSizes.length;\n        const oldTotal = colSizes.reduce((a, b) => a + b, 0);\n        const newTotal = newColSizes.reduce((a, b) => a + b, 0);\n        const maxTotal = Math.max(oldTotal, initialTableWidth);\n        if (newTotal > maxTotal) {\n          const factor = maxTotal / newTotal;\n          newColSizes = newColSizes.map(\n            (size) => Math.max(minColumnWidth != null ? minColumnWidth : 0, Math.floor(size * factor))\n          );\n        }\n      }\n      setNodes2(\n        editor,\n        {\n          colSizes: newColSizes\n        },\n        {\n          at: tablePath\n        }\n      );\n    }\n  });\n};\n\n// src/lib/transforms/insertTableRow.ts\nimport {\n  findNode as findNode8,\n  getBlockAbove as getBlockAbove5,\n  getEditorPlugin as getEditorPlugin5,\n  insertElements as insertElements4,\n  select,\n  withoutNormalizing as withoutNormalizing4\n} from \"@udecode/plate-common\";\nimport { Path as Path8 } from \"slate\";\n\n// src/lib/merge/insertTableRow.ts\nimport {\n  findNode as findNode7,\n  getBlockAbove as getBlockAbove4,\n  getEditorPlugin as getEditorPlugin4,\n  getParentNode as getParentNode2,\n  insertElements as insertElements3,\n  setNodes as setNodes3,\n  withoutNormalizing as withoutNormalizing3\n} from \"@udecode/plate-common\";\nimport cloneDeep2 from \"lodash/cloneDeep.js\";\nimport { Path as Path7 } from \"slate\";\nvar insertTableMergeRow = (editor, {\n  at,\n  fromRow,\n  header\n} = {}) => {\n  const { api, getOptions, type } = getEditorPlugin4(editor, BaseTablePlugin);\n  const { _cellIndices: cellIndices } = getOptions();\n  const trEntry = fromRow ? findNode7(editor, {\n    at: fromRow,\n    match: { type: editor.getType(BaseTableRowPlugin) }\n  }) : getBlockAbove4(editor, {\n    match: { type: editor.getType(BaseTableRowPlugin) }\n  });\n  if (!trEntry) return;\n  const [, trPath] = trEntry;\n  const tableEntry = getBlockAbove4(editor, {\n    at: trPath,\n    match: { type }\n  });\n  if (!tableEntry) return;\n  const tableNode = tableEntry[0];\n  const cellEntry = findNode7(editor, {\n    at: fromRow,\n    match: { type: getCellTypes(editor) }\n  });\n  if (!cellEntry) return;\n  const [cellNode, cellPath] = cellEntry;\n  const cellElement = cellNode;\n  const cellRowSpan = getRowSpan(cellElement);\n  const { row: cellRowIndex } = getCellIndices(cellIndices, cellElement) || computeCellIndices(editor, tableNode, cellElement);\n  const rowPath = cellPath.at(-2);\n  const tablePath = cellPath.slice(0, -2);\n  let nextRowIndex;\n  let checkingRowIndex;\n  let nextRowPath;\n  if (Path7.isPath(at)) {\n    nextRowIndex = at.at(-1);\n    checkingRowIndex = cellRowIndex - 1;\n    nextRowPath = at;\n  } else {\n    nextRowIndex = cellRowIndex + cellRowSpan;\n    checkingRowIndex = cellRowIndex + cellRowSpan - 1;\n    nextRowPath = [...tablePath, rowPath + cellRowSpan];\n  }\n  const firstRow = nextRowIndex === 0;\n  if (firstRow) {\n    checkingRowIndex = 0;\n  }\n  const colCount = getTableColumnCount(tableNode);\n  const affectedCellsSet = /* @__PURE__ */ new Set();\n  Array.from({ length: colCount }, (_, i) => i).forEach((cI) => {\n    const found = findCellByIndexes(editor, tableNode, checkingRowIndex, cI);\n    if (found) {\n      affectedCellsSet.add(found);\n    }\n  });\n  const affectedCells = Array.from(affectedCellsSet);\n  const newRowChildren = [];\n  affectedCells.forEach((cur) => {\n    var _a;\n    if (!cur) return;\n    const curCell = cur;\n    const { col: curColIndex, row: curRowIndex } = getCellIndices(cellIndices, curCell) || computeCellIndices(editor, tableNode, curCell);\n    const curRowSpan = getRowSpan(curCell);\n    const curColSpan = getColSpan(curCell);\n    const currentCellPath = getCellPath(\n      editor,\n      tableEntry,\n      curRowIndex,\n      curColIndex\n    );\n    const endCurI = curRowIndex + curRowSpan - 1;\n    if (endCurI >= nextRowIndex && !firstRow) {\n      const rowSpan = curRowSpan + 1;\n      const newCell = cloneDeep2(__spreadProps(__spreadValues({}, curCell), { rowSpan }));\n      if ((_a = newCell.attributes) == null ? void 0 : _a.rowspan) {\n        newCell.attributes.rowspan = rowSpan.toString();\n      }\n      setNodes3(editor, newCell, { at: currentCellPath });\n    } else {\n      const row = getParentNode2(editor, currentCellPath);\n      const rowElement = row[0];\n      const emptyCell = api.create.cell({ header, row: rowElement });\n      newRowChildren.push(__spreadProps(__spreadValues({}, emptyCell), {\n        colSpan: curColSpan,\n        rowSpan: 1\n      }));\n    }\n  });\n  withoutNormalizing3(editor, () => {\n    insertElements3(\n      editor,\n      {\n        children: newRowChildren,\n        type: editor.getType(BaseTableRowPlugin)\n      },\n      {\n        at: nextRowPath\n        // select: !disableSelect\n      }\n    );\n  });\n};\n\n// src/lib/transforms/insertTableRow.ts\nvar insertTableRow = (editor, options = {}) => {\n  const { api, getOptions, type } = getEditorPlugin5(editor, BaseTablePlugin);\n  const { enableMerging } = getOptions();\n  if (enableMerging) {\n    return insertTableMergeRow(editor, options);\n  }\n  const { at, disableSelect, fromRow, header } = options;\n  const trEntry = fromRow ? findNode8(editor, {\n    at: fromRow,\n    match: { type: editor.getType(BaseTableRowPlugin) }\n  }) : getBlockAbove5(editor, {\n    match: { type: editor.getType(BaseTableRowPlugin) }\n  });\n  if (!trEntry) return;\n  const [trNode, trPath] = trEntry;\n  const tableEntry = getBlockAbove5(editor, {\n    at: trPath,\n    match: { type }\n  });\n  if (!tableEntry) return;\n  const getEmptyRowNode2 = () => ({\n    children: trNode.children.map((_, i) => {\n      const hasSingleRow = tableEntry[0].children.length === 1;\n      const isHeaderColumn = !hasSingleRow && tableEntry[0].children.every(\n        (n) => n.children[i].type === editor.getType(BaseTableCellHeaderPlugin)\n      );\n      return api.create.cell({\n        header: header != null ? header : isHeaderColumn\n      });\n    }),\n    type: editor.getType(BaseTableRowPlugin)\n  });\n  withoutNormalizing4(editor, () => {\n    insertElements4(editor, getEmptyRowNode2(), {\n      at: Path8.isPath(at) ? at : Path8.next(trPath)\n    });\n  });\n  if (!disableSelect) {\n    const cellEntry = getBlockAbove5(editor, {\n      match: { type: getCellTypes(editor) }\n    });\n    if (!cellEntry) return;\n    const [, nextCellPath] = cellEntry;\n    if (Path8.isPath(at)) {\n      nextCellPath[nextCellPath.length - 2] = at.at(-2);\n    } else {\n      nextCellPath[nextCellPath.length - 2] += 1;\n    }\n    select(editor, nextCellPath);\n  }\n};\n\n// src/lib/transforms/setBorderSize.ts\nimport {\n  findNode as findNode9,\n  isElement,\n  setNodes as setNodes4,\n  withoutNormalizing as withoutNormalizing5\n} from \"@udecode/plate-common\";\nvar setBorderSize = (editor, size, {\n  at,\n  border = \"all\"\n} = {}) => {\n  const cellEntry = findNode9(editor, {\n    at,\n    match: { type: getCellTypes(editor) }\n  });\n  if (!cellEntry) return;\n  const [cellNode, cellPath] = cellEntry;\n  const cellIndex = cellPath.at(-1);\n  const rowIndex = cellPath.at(-2);\n  const borderStyle = {\n    size\n  };\n  const setNodesOptions = {\n    match: (n) => isElement(n) && getCellTypes(editor).includes(n.type)\n  };\n  if (border === \"top\") {\n    const isFirstRow = rowIndex === 0;\n    if (isFirstRow) {\n      const newBorders2 = __spreadProps(__spreadValues({}, cellNode.borders), {\n        top: borderStyle\n      });\n      setNodes4(\n        editor,\n        { borders: newBorders2 },\n        __spreadValues({\n          at: cellPath\n        }, setNodesOptions)\n      );\n      return;\n    }\n    const cellAboveEntry = getTopTableCell(editor, { at: cellPath });\n    if (!cellAboveEntry) return;\n    const [cellAboveNode, cellAbovePath] = cellAboveEntry;\n    const newBorders = __spreadProps(__spreadValues({}, cellAboveNode.borders), {\n      bottom: borderStyle\n    });\n    setNodes4(\n      editor,\n      { borders: newBorders },\n      __spreadValues({\n        at: cellAbovePath\n      }, setNodesOptions)\n    );\n  } else if (border === \"bottom\") {\n    const newBorders = __spreadProps(__spreadValues({}, cellNode.borders), {\n      bottom: borderStyle\n    });\n    setNodes4(\n      editor,\n      { borders: newBorders },\n      __spreadValues({\n        at: cellPath\n      }, setNodesOptions)\n    );\n  }\n  if (border === \"left\") {\n    const isFirstCell = cellIndex === 0;\n    if (isFirstCell) {\n      const newBorders2 = __spreadProps(__spreadValues({}, cellNode.borders), {\n        left: borderStyle\n      });\n      setNodes4(\n        editor,\n        { borders: newBorders2 },\n        __spreadValues({\n          at: cellPath\n        }, setNodesOptions)\n      );\n      return;\n    }\n    const prevCellEntry = getLeftTableCell(editor, { at: cellPath });\n    if (!prevCellEntry) return;\n    const [prevCellNode, prevCellPath] = prevCellEntry;\n    const newBorders = __spreadProps(__spreadValues({}, prevCellNode.borders), {\n      right: borderStyle\n    });\n    setNodes4(\n      editor,\n      { borders: newBorders },\n      __spreadValues({\n        at: prevCellPath\n      }, setNodesOptions)\n    );\n  } else if (border === \"right\") {\n    const newBorders = __spreadProps(__spreadValues({}, cellNode.borders), {\n      right: borderStyle\n    });\n    setNodes4(\n      editor,\n      { borders: newBorders },\n      __spreadValues({\n        at: cellPath\n      }, setNodesOptions)\n    );\n  }\n  if (border === \"all\") {\n    withoutNormalizing5(editor, () => {\n      setBorderSize(editor, size, { at, border: \"top\" });\n      setBorderSize(editor, size, { at, border: \"bottom\" });\n      setBorderSize(editor, size, { at, border: \"left\" });\n      setBorderSize(editor, size, { at, border: \"right\" });\n    });\n  }\n};\n\n// src/lib/transforms/setTableColSize.ts\nimport {\n  findNode as findNode10,\n  setNodes as setNodes5\n} from \"@udecode/plate-common\";\nvar setTableColSize = (editor, { colIndex, width }, options = {}) => {\n  const table = findNode10(editor, __spreadValues({\n    match: { type: BaseTablePlugin.key }\n  }, options));\n  if (!table) return;\n  const [tableNode, tablePath] = table;\n  const colSizes = tableNode.colSizes ? [...tableNode.colSizes] : Array.from({ length: getTableColumnCount(tableNode) }).fill(0);\n  colSizes[colIndex] = width;\n  setNodes5(editor, { colSizes }, { at: tablePath });\n};\n\n// src/lib/transforms/setTableMarginLeft.ts\nimport {\n  findNode as findNode11,\n  setNodes as setNodes6\n} from \"@udecode/plate-common\";\nvar setTableMarginLeft = (editor, { marginLeft }, options = {}) => {\n  const table = findNode11(editor, __spreadValues({\n    match: { type: BaseTablePlugin.key }\n  }, options));\n  if (!table) return;\n  const [, tablePath] = table;\n  setNodes6(editor, { marginLeft }, { at: tablePath });\n};\n\n// src/lib/transforms/setTableRowSize.ts\nimport {\n  findNode as findNode12,\n  setNodes as setNodes7\n} from \"@udecode/plate-common\";\nvar setTableRowSize = (editor, { height, rowIndex }, options = {}) => {\n  const table = findNode12(editor, __spreadValues({\n    match: { type: BaseTablePlugin.key }\n  }, options));\n  if (!table) return;\n  const [, tablePath] = table;\n  const tableRowPath = [...tablePath, rowIndex];\n  setNodes7(editor, { size: height }, { at: tableRowPath });\n};\n\n// src/lib/withNormalizeTable.ts\nimport {\n  getBlockAbove as getBlockAbove6,\n  getParentNode as getParentNode3,\n  isElement as isElement2,\n  isText,\n  setNodes as setNodes8,\n  unwrapNodes,\n  wrapNodeChildren\n} from \"@udecode/plate-common\";\nvar withNormalizeTable = ({\n  editor,\n  getOptions,\n  type\n}) => {\n  const { normalizeNode } = editor;\n  editor.normalizeNode = ([node, path]) => {\n    var _a, _b;\n    const { initialTableWidth } = getOptions();\n    if (isElement2(node)) {\n      if (node.type === type) {\n        if (!node.children.some(\n          (child) => isElement2(child) && child.type === editor.getType(BaseTableRowPlugin)\n        )) {\n          editor.removeNodes({ at: path });\n          return;\n        }\n        const tableEntry = getBlockAbove6(editor, {\n          at: path,\n          match: { type }\n        });\n        if (tableEntry) {\n          unwrapNodes(editor, {\n            at: path\n          });\n          return;\n        }\n        if (initialTableWidth) {\n          const tableNode = node;\n          const colCount = (_b = (_a = tableNode.children[0]) == null ? void 0 : _a.children) == null ? void 0 : _b.length;\n          if (colCount) {\n            const colSizes = [];\n            if (!tableNode.colSizes) {\n              for (let i = 0; i < colCount; i++) {\n                colSizes.push(initialTableWidth / colCount);\n              }\n            } else if (tableNode.colSizes.some((size) => !size)) {\n              tableNode.colSizes.forEach((colSize) => {\n                colSizes.push(colSize || initialTableWidth / colCount);\n              });\n            }\n            if (colSizes.length > 0) {\n              setNodes8(editor, { colSizes }, { at: path });\n              return;\n            }\n          }\n        }\n      }\n      if (node.type === editor.getType(BaseTableRowPlugin)) {\n        const parentEntry = getParentNode3(editor, path);\n        if ((parentEntry == null ? void 0 : parentEntry[0].type) !== type) {\n          unwrapNodes(editor, {\n            at: path\n          });\n          return;\n        }\n      }\n      if (getCellTypes(editor).includes(node.type)) {\n        const { children } = node;\n        const parentEntry = getParentNode3(editor, path);\n        if ((parentEntry == null ? void 0 : parentEntry[0].type) !== editor.getType(BaseTableRowPlugin)) {\n          unwrapNodes(editor, {\n            at: path\n          });\n          return;\n        }\n        if (isText(children[0])) {\n          wrapNodeChildren(\n            editor,\n            editor.api.create.block({}, path),\n            {\n              at: path\n            }\n          );\n          return;\n        }\n      }\n    }\n    return normalizeNode([node, path]);\n  };\n  return editor;\n};\n\n// src/lib/withTable.ts\nvar withTable = (_a) => {\n  var _b = _a, { editor } = _b, ctx = __objRest(_b, [\"editor\"]);\n  editor = withNormalizeTable(__spreadValues({ editor }, ctx));\n  return editor;\n};\n\n// src/lib/BaseTablePlugin.ts\nvar BaseTableRowPlugin = createSlatePlugin({\n  key: \"tr\",\n  node: { isElement: true },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [{ validNodeName: \"TR\" }]\n      }\n    }\n  }\n});\nvar BaseTableCellPlugin = createSlatePlugin({\n  key: \"td\",\n  node: {\n    dangerouslyAllowAttributes: [\"colspan\", \"rowspan\"],\n    isElement: true\n  }\n}).extend(({ type }) => ({\n  parsers: {\n    html: {\n      deserializer: {\n        attributeNames: [\"rowspan\", \"colspan\"],\n        parse: getParse(type),\n        rules: [{ validNodeName: \"TD\" }]\n      }\n    }\n  }\n}));\nvar BaseTableCellHeaderPlugin = createSlatePlugin({\n  key: \"th\",\n  node: {\n    dangerouslyAllowAttributes: [\"colspan\", \"rowspan\"],\n    isElement: true\n  }\n}).extend(({ type }) => ({\n  parsers: {\n    html: {\n      deserializer: {\n        attributeNames: [\"rowspan\", \"colspan\"],\n        parse: getParse(type),\n        rules: [{ validNodeName: \"TH\" }]\n      }\n    }\n  }\n}));\nvar BaseTablePlugin = createTSlatePlugin({\n  key: \"table\",\n  extendEditor: withTable,\n  node: { isElement: true },\n  options: {\n    _cellIndices: /* @__PURE__ */ new WeakMap(),\n    enableMerging: false,\n    minColumnWidth: 48\n  },\n  parsers: {\n    html: {\n      deserializer: {\n        rules: [{ validNodeName: \"TABLE\" }]\n      }\n    }\n  },\n  plugins: [BaseTableRowPlugin, BaseTableCellPlugin, BaseTableCellHeaderPlugin]\n}).extendEditorApi(({ editor }) => ({\n  create: {\n    cell: bindFirst(getEmptyCellNode, editor)\n  },\n  table: {\n    getCellChildren: (cell) => cell.children\n  }\n})).extendEditorTransforms(({ editor }) => ({\n  insert: {\n    tableColumn: bindFirst(insertTableColumn, editor),\n    tableRow: bindFirst(insertTableRow, editor)\n  }\n}));\nvar getParse = (type) => {\n  return ({ element }) => {\n    const background = element.style.background || element.style.backgroundColor;\n    if (background) {\n      return {\n        background,\n        type\n      };\n    }\n    return { type };\n  };\n};\n\n// src/react/onKeyDownTable.ts\nimport {\n  getAboveNode as getAboveNode8,\n  isHotkey as isHotkey2,\n  select as select3\n} from \"@udecode/plate-common\";\nimport { Hotkeys } from \"@udecode/plate-common/react\";\n\n// src/lib/constants.ts\nvar KEY_SHIFT_EDGES = {\n  \"shift+down\": \"bottom\",\n  \"shift+left\": \"left\",\n  \"shift+right\": \"right\",\n  \"shift+up\": \"top\"\n};\n\n// src/lib/merge/getTableMergedColumnCount.ts\nvar getTableMergedColumnCount = (tableNode) => {\n  var _a, _b, _c;\n  return (_c = (_b = (_a = tableNode.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.children) == null ? void 0 : _c.reduce(\n    (prev, cur) => {\n      var _a2;\n      return prev + ((_a2 = getColSpan(cur)) != null ? _a2 : 1);\n    },\n    0\n  );\n};\n\n// src/lib/merge/isTableRectangular.ts\nvar allEqual = (arr) => arr.every((val) => val === arr[0]);\nvar isTableRectangular = (table) => {\n  var _a;\n  const arr = [];\n  (_a = table == null ? void 0 : table.children) == null ? void 0 : _a.forEach((row, rI) => {\n    var _a2;\n    const rowEl = row;\n    (_a2 = rowEl.children) == null ? void 0 : _a2.forEach((cell) => {\n      const cellElem = cell;\n      Array.from({\n        length: getRowSpan(cellElem) || 1\n      }).forEach((_, i) => {\n        if (!arr[rI + i]) {\n          arr[rI + i] = 0;\n        }\n        arr[rI + i] += getColSpan(cellElem);\n      });\n    });\n  });\n  return allEqual(arr);\n};\n\n// src/react/transforms/deleteColumn.ts\nimport {\n  getAboveNode as getAboveNode5,\n  getEditorPlugin as getEditorPlugin8,\n  isExpanded as isExpanded2,\n  removeNodes as removeNodes4,\n  setNodes as setNodes10,\n  someNode as someNode3,\n  withoutNormalizing as withoutNormalizing7\n} from \"@udecode/plate-common\";\n\n// src/react/merge/deleteColumn.ts\nimport {\n  getAboveNode as getAboveNode4,\n  getEditorPlugin as getEditorPlugin7,\n  isExpanded,\n  removeNodes as removeNodes3,\n  setNodes as setNodes9,\n  someNode as someNode2,\n  withoutNormalizing as withoutNormalizing6\n} from \"@udecode/plate-common\";\nimport cloneDeep3 from \"lodash/cloneDeep.js\";\n\n// src/react/merge/deleteColumnWhenExpanded.ts\nimport {\n  createPathRef,\n  getAboveNode as getAboveNode3,\n  removeNodes as removeNodes2\n} from \"@udecode/plate-common\";\nimport { Node, Range } from \"slate\";\n\n// src/react/queries/getTableGridAbove.ts\nimport {\n  getEdgeBlocksAbove\n} from \"@udecode/plate-common\";\nimport { Path as Path9 } from \"slate\";\n\n// src/react/queries/getTableGridByRange.ts\nimport {\n  getNode\n} from \"@udecode/plate-common\";\n\n// src/react/merge/getTableGridByRange.ts\nimport {\n  findNode as findNode13,\n  getEditorPlugin as getEditorPlugin6\n} from \"@udecode/plate-common\";\nimport { findNodePath } from \"@udecode/plate-common/react\";\nvar getTableMergeGridByRange = (editor, { at, format }) => {\n  var _a;\n  const { api, getOptions, type } = getEditorPlugin6(editor, BaseTablePlugin);\n  const { _cellIndices: cellIndices } = getOptions();\n  const startCellEntry = findNode13(editor, {\n    at: at.anchor.path,\n    match: { type: getCellTypes(editor) }\n  });\n  const endCellEntry = findNode13(editor, {\n    at: at.focus.path,\n    match: { type: getCellTypes(editor) }\n  });\n  const startCell = startCellEntry[0];\n  const endCell = endCellEntry[0];\n  const startCellPath = at.anchor.path;\n  const tablePath = startCellPath.slice(0, -2);\n  const tableEntry = findNode13(editor, {\n    at: tablePath,\n    match: { type }\n  });\n  const realTable = tableEntry[0];\n  const { col: _startColIndex, row: _startRowIndex } = getCellIndicesWithSpans(\n    getCellIndices(cellIndices, startCell) || computeCellIndices(editor, realTable, startCell),\n    startCell\n  );\n  const { col: _endColIndex, row: _endRowIndex } = getCellIndicesWithSpans(\n    getCellIndices(cellIndices, endCell) || computeCellIndices(editor, realTable, endCell),\n    endCell\n  );\n  let startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  let endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  let startColIndex = Math.min(_startColIndex, _endColIndex);\n  let endColIndex = Math.max(_startColIndex, _endColIndex);\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n  let table = getEmptyTableNode(editor, {\n    children: [],\n    colCount: relativeColIndex + 1,\n    rowCount: relativeRowIndex + 1\n  });\n  let cellEntries = [];\n  let cellsSet = /* @__PURE__ */ new WeakSet();\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n  while (true) {\n    const cell = findCellByIndexes(editor, realTable, rowIndex, colIndex);\n    if (!cell) {\n      break;\n    }\n    const indicies = getCellIndices(cellIndices, cell) || computeCellIndices(editor, realTable, cell);\n    const { col: cellColWithSpan, row: cellRowWithSpan } = getCellIndicesWithSpans(indicies, cell);\n    const { col: cellCol, row: cellRow } = indicies;\n    const hasOverflowTop = cellRow < startRowIndex;\n    const hasOverflowBottom = cellRowWithSpan > endRowIndex;\n    const hasOverflowLeft = cellCol < startColIndex;\n    const hasOverflowRight = cellColWithSpan > endColIndex;\n    if (hasOverflowTop || hasOverflowBottom || hasOverflowLeft || hasOverflowRight) {\n      cellsSet = /* @__PURE__ */ new WeakSet();\n      cellEntries = [];\n      startRowIndex = Math.min(startRowIndex, cellRow);\n      endRowIndex = Math.max(endRowIndex, cellRowWithSpan);\n      startColIndex = Math.min(startColIndex, cellCol);\n      endColIndex = Math.max(endColIndex, cellColWithSpan);\n      rowIndex = startRowIndex;\n      colIndex = startColIndex;\n      const newRelativeRowIndex = endRowIndex - startRowIndex;\n      const newRelativeColIndex = endColIndex - startColIndex;\n      table = getEmptyTableNode(editor, {\n        children: [],\n        colCount: newRelativeColIndex + 1,\n        rowCount: newRelativeRowIndex + 1\n      });\n      continue;\n    }\n    if (!cellsSet.has(cell)) {\n      cellsSet.add(cell);\n      const rows = table.children[rowIndex - startRowIndex].children;\n      rows[colIndex - startColIndex] = cell;\n      const cellPath = findNodePath(editor, cell);\n      cellEntries.push([cell, cellPath]);\n    }\n    if (colIndex + 1 <= endColIndex) {\n      colIndex = colIndex + 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex = rowIndex + 1;\n    } else {\n      break;\n    }\n  }\n  const formatType = format || \"table\";\n  if (formatType === \"cell\") {\n    return cellEntries;\n  }\n  (_a = table.children) == null ? void 0 : _a.forEach((rowEl) => {\n    var _a2;\n    const rowElement = rowEl;\n    const filteredChildren = (_a2 = rowElement.children) == null ? void 0 : _a2.filter((cellEl) => {\n      const cellElement = cellEl;\n      return api.table.getCellChildren(cellElement).length > 0;\n    });\n    rowElement.children = filteredChildren;\n  });\n  if (formatType === \"table\") {\n    return [[table, tablePath]];\n  }\n  return {\n    cellEntries,\n    tableEntries: [[table, tablePath]]\n  };\n};\n\n// src/react/queries/getTableGridByRange.ts\nvar getTableGridByRange = (editor, { at, format = \"table\" }) => {\n  const { enableMerging } = editor.getOptions(BaseTablePlugin);\n  if (enableMerging) {\n    return getTableMergeGridByRange(editor, { at, format });\n  }\n  const startCellPath = at.anchor.path;\n  const endCellPath = at.focus.path;\n  const _startRowIndex = startCellPath.at(-2);\n  const _endRowIndex = endCellPath.at(-2);\n  const _startColIndex = startCellPath.at(-1);\n  const _endColIndex = endCellPath.at(-1);\n  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);\n  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);\n  const startColIndex = Math.min(_startColIndex, _endColIndex);\n  const endColIndex = Math.max(_startColIndex, _endColIndex);\n  const tablePath = startCellPath.slice(0, -2);\n  const relativeRowIndex = endRowIndex - startRowIndex;\n  const relativeColIndex = endColIndex - startColIndex;\n  const table = getEmptyTableNode(editor, {\n    children: [],\n    colCount: relativeColIndex + 1,\n    rowCount: relativeRowIndex + 1\n  });\n  let rowIndex = startRowIndex;\n  let colIndex = startColIndex;\n  const cellEntries = [];\n  while (true) {\n    const cellPath = tablePath.concat([rowIndex, colIndex]);\n    const cell = getNode(editor, cellPath);\n    if (!cell) break;\n    const rows = table.children[rowIndex - startRowIndex].children;\n    rows[colIndex - startColIndex] = cell;\n    cellEntries.push([cell, cellPath]);\n    if (colIndex + 1 <= endColIndex) {\n      colIndex += 1;\n    } else if (rowIndex + 1 <= endRowIndex) {\n      colIndex = startColIndex;\n      rowIndex += 1;\n    } else {\n      break;\n    }\n  }\n  if (format === \"cell\") {\n    return cellEntries;\n  }\n  return [[table, tablePath]];\n};\n\n// src/react/queries/getTableGridAbove.ts\nvar getTableGridAbove = (editor, _a = {}) => {\n  var _b = _a, { format = \"table\" } = _b, options = __objRest(_b, [\"format\"]);\n  const edges = getEdgeBlocksAbove(editor, __spreadValues({\n    match: {\n      type: getCellTypes(editor)\n    }\n  }, options));\n  if (edges) {\n    const [start, end] = edges;\n    if (!Path9.equals(start[1], end[1])) {\n      return getTableGridByRange(editor, {\n        at: {\n          anchor: {\n            offset: 0,\n            path: start[1]\n          },\n          focus: {\n            offset: 0,\n            path: end[1]\n          }\n        },\n        format\n      });\n    }\n    if (format === \"table\") {\n      const table = getEmptyTableNode(editor, { rowCount: 1 });\n      table.children[0].children = [start[0]];\n      return [[table, start[1].slice(0, -2)]];\n    }\n    return [start];\n  }\n  return [];\n};\n\n// src/react/queries/getTableRowIndex.ts\nimport { findNodePath as findNodePath2 } from \"@udecode/plate-common/react\";\nimport { Path as Path10 } from \"slate\";\nvar getTableRowIndex = (editor, cellNode) => {\n  const path = findNodePath2(editor, cellNode);\n  if (!path) return 0;\n  const rowPath = Path10.parent(path);\n  return rowPath.at(-1);\n};\n\n// src/react/merge/deleteColumnWhenExpanded.ts\nvar deleteColumnWhenExpanded = (editor, tableEntry) => {\n  const [start, end] = Range.edges(editor.selection);\n  const firstRow = Node.child(tableEntry[0], 0);\n  const lastRow = Node.child(\n    tableEntry[0],\n    tableEntry[0].children.length - 1\n  );\n  const firstSelectionRow = getAboveNode3(editor, {\n    at: start,\n    match: (n) => n.type === BaseTableRowPlugin.key\n  });\n  const lastSelectionRow = getAboveNode3(editor, {\n    at: end,\n    match: (n) => n.type === BaseTableRowPlugin.key\n  });\n  if (!firstSelectionRow || !lastSelectionRow) return;\n  if (firstRow.id === firstSelectionRow[0].id && lastSelectionRow[0].id === lastRow.id)\n    deleteSelection(editor);\n};\nvar deleteSelection = (editor) => {\n  const cells = getTableGridAbove(editor, {\n    format: \"cell\"\n  });\n  const pathRefs = [];\n  cells.forEach(([_cell, cellPath]) => {\n    pathRefs.push(createPathRef(editor, cellPath));\n  });\n  pathRefs.forEach((pathRef) => {\n    removeNodes2(editor, { at: pathRef.unref() });\n  });\n};\n\n// src/react/merge/deleteColumn.ts\nvar deleteTableMergeColumn = (editor) => {\n  const { getOptions, type } = getEditorPlugin7(editor, TablePlugin);\n  if (someNode2(editor, {\n    match: { type }\n  })) {\n    const { _cellIndices: cellIndices } = getOptions();\n    const tableEntry = getAboveNode4(editor, {\n      match: { type }\n    });\n    if (!tableEntry) return;\n    if (isExpanded(editor.selection))\n      return deleteColumnWhenExpanded(editor, tableEntry);\n    const table = tableEntry[0];\n    const selectedCellEntry = getAboveNode4(editor, {\n      match: {\n        type: getCellTypes(editor)\n      }\n    });\n    if (!selectedCellEntry) return;\n    const selectedCell = selectedCellEntry[0];\n    const { col: deletingColIndex } = getCellIndices(\n      cellIndices,\n      selectedCell\n    );\n    const colsDeleteNumber = getColSpan(selectedCell);\n    const endingColIndex = deletingColIndex + colsDeleteNumber - 1;\n    const rowNumber = table.children.length;\n    const affectedCellsSet = /* @__PURE__ */ new Set();\n    Array.from({ length: rowNumber }, (_, i) => i).forEach((rI) => {\n      return Array.from({ length: colsDeleteNumber }, (_, i) => i).forEach(\n        (cI) => {\n          const colIndex = deletingColIndex + cI;\n          const found = findCellByIndexes(editor, table, rI, colIndex);\n          if (found) {\n            affectedCellsSet.add(found);\n          }\n        }\n      );\n    });\n    const affectedCells = Array.from(affectedCellsSet);\n    const { squizeColSpanCells } = affectedCells.reduce(\n      (acc, cur) => {\n        if (!cur) return acc;\n        const currentCell = cur;\n        const { col: curColIndex } = getCellIndices(cellIndices, currentCell);\n        const curColSpan = getColSpan(currentCell);\n        if (curColIndex < deletingColIndex && curColSpan > 1) {\n          acc.squizeColSpanCells.push(currentCell);\n        } else if (curColSpan > 1 && curColIndex + curColSpan - 1 > endingColIndex) {\n          acc.squizeColSpanCells.push(currentCell);\n        }\n        return acc;\n      },\n      { squizeColSpanCells: [] }\n    );\n    squizeColSpanCells.forEach((cur) => {\n      var _a;\n      const curCell = cur;\n      const { col: curColIndex, row: curColRowIndex } = getCellIndices(\n        cellIndices,\n        curCell\n      );\n      const curColSpan = getColSpan(curCell);\n      const curCellPath = getCellPath(\n        editor,\n        tableEntry,\n        curColRowIndex,\n        curColIndex\n      );\n      const curCellEndingColIndex = Math.min(\n        curColIndex + curColSpan - 1,\n        endingColIndex\n      );\n      const colsNumberAffected = curCellEndingColIndex - deletingColIndex + 1;\n      const colSpan = curColSpan - colsNumberAffected;\n      const newCell = cloneDeep3(__spreadProps(__spreadValues({}, curCell), { colSpan }));\n      if ((_a = newCell.attributes) == null ? void 0 : _a.colspan) {\n        newCell.attributes.colspan = colSpan.toString();\n      }\n      setNodes9(editor, newCell, { at: curCellPath });\n    });\n    const trEntry = getAboveNode4(editor, {\n      match: { type: editor.getType(BaseTableRowPlugin) }\n    });\n    if (selectedCell && trEntry && tableEntry && // Cannot delete the last cell\n    trEntry[0].children.length > 1) {\n      const [tableNode, tablePath] = tableEntry;\n      const paths = [];\n      affectedCells.forEach((cur) => {\n        const curCell = cur;\n        const { col: curColIndex, row: curRowIndex } = getCellIndices(\n          cellIndices,\n          curCell\n        );\n        if (!squizeColSpanCells.includes(curCell) && curColIndex >= deletingColIndex && curColIndex <= endingColIndex) {\n          const cellPath = getCellPath(\n            editor,\n            tableEntry,\n            curRowIndex,\n            curColIndex\n          );\n          if (!paths[curRowIndex]) {\n            paths[curRowIndex] = [];\n          }\n          paths[curRowIndex].push(cellPath);\n        }\n      });\n      withoutNormalizing6(editor, () => {\n        paths.forEach((cellPaths) => {\n          const pathToDelete = cellPaths[0];\n          cellPaths.forEach(() => {\n            removeNodes3(editor, {\n              at: pathToDelete\n            });\n          });\n        });\n        const { colSizes } = tableNode;\n        if (colSizes) {\n          const newColSizes = [...colSizes];\n          newColSizes.splice(deletingColIndex, 1);\n          setNodes9(\n            editor,\n            { colSizes: newColSizes },\n            { at: tablePath }\n          );\n        }\n      });\n    }\n  }\n};\n\n// src/react/transforms/deleteColumn.ts\nvar deleteColumn = (editor) => {\n  const { getOptions, type } = getEditorPlugin8(editor, BaseTablePlugin);\n  const { enableMerging } = getOptions();\n  if (enableMerging) {\n    return deleteTableMergeColumn(editor);\n  }\n  if (!someNode3(editor, {\n    match: { type }\n  })) {\n    return;\n  }\n  const tableEntry = getAboveNode5(editor, {\n    match: { type }\n  });\n  if (!tableEntry) return;\n  if (isExpanded2(editor.selection))\n    return deleteColumnWhenExpanded(editor, tableEntry);\n  const tdEntry = getAboveNode5(editor, {\n    match: {\n      type: [\n        editor.getType(BaseTableCellPlugin),\n        editor.getType(BaseTableCellHeaderPlugin)\n      ]\n    }\n  });\n  const trEntry = getAboveNode5(editor, {\n    match: { type: editor.getType(BaseTableRowPlugin) }\n  });\n  if (tdEntry && trEntry && tableEntry && // Cannot delete the last cell\n  trEntry[0].children.length > 1) {\n    const [tableNode, tablePath] = tableEntry;\n    const tdPath = tdEntry[1];\n    const colIndex = tdPath.at(-1);\n    const pathToDelete = tdPath.slice();\n    const replacePathPos = pathToDelete.length - 2;\n    withoutNormalizing7(editor, () => {\n      tableNode.children.forEach((row, rowIdx) => {\n        pathToDelete[replacePathPos] = rowIdx;\n        if (row.children.length === 1 || colIndex > row.children.length - 1)\n          return;\n        removeNodes4(editor, {\n          at: pathToDelete\n        });\n      });\n      const { colSizes } = tableNode;\n      if (colSizes) {\n        const newColSizes = [...colSizes];\n        newColSizes.splice(colIndex, 1);\n        setNodes10(\n          editor,\n          {\n            colSizes: newColSizes\n          },\n          {\n            at: tablePath\n          }\n        );\n      }\n    });\n  }\n};\n\n// src/react/transforms/deleteRow.ts\nimport {\n  getAboveNode as getAboveNode7,\n  getEditorPlugin as getEditorPlugin12,\n  isExpanded as isExpanded4,\n  removeNodes as removeNodes9,\n  someNode as someNode5\n} from \"@udecode/plate-common\";\n\n// src/react/merge/deleteRow.ts\nimport {\n  getAboveNode as getAboveNode6,\n  getEditorPlugin as getEditorPlugin9,\n  insertElements as insertElements5,\n  isExpanded as isExpanded3,\n  removeNodes as removeNodes6,\n  setNodes as setNodes11,\n  someNode as someNode4\n} from \"@udecode/plate-common\";\nimport { findNodePath as findNodePath3 } from \"@udecode/plate-common/react\";\nimport cloneDeep4 from \"lodash/cloneDeep.js\";\n\n// src/react/merge/deleteRowWhenExpanded.ts\nimport {\n  createPathRef as createPathRef2,\n  removeNodes as removeNodes5\n} from \"@udecode/plate-common\";\nvar deleteRowWhenExpanded = (editor, [table, tablePath]) => {\n  const columnCount = getTableMergedColumnCount(table);\n  const cells = getTableGridAbove(editor, {\n    format: \"cell\"\n  });\n  const firsRowIndex = getCellRowIndexByPath(cells[0][1]);\n  if (firsRowIndex === null) return;\n  let acrossColumn = 0;\n  let lastRowIndex = -1;\n  let rowSpanCarry = 0;\n  let acrossRow = 0;\n  cells.forEach(([cell, cellPath]) => {\n    var _a;\n    if (cellPath.at(-2) === firsRowIndex) {\n      acrossColumn += (_a = cell.colSpan) != null ? _a : 1;\n    }\n    const currentRowIndex = getCellRowIndexByPath(cellPath);\n    if (lastRowIndex !== currentRowIndex) {\n      if (rowSpanCarry !== 0) {\n        rowSpanCarry--;\n        return;\n      }\n      const rowSpan = getRowSpan(cell);\n      rowSpanCarry = rowSpan && rowSpan > 1 ? rowSpan - 1 : 0;\n      acrossRow += rowSpan != null ? rowSpan : 1;\n    }\n    lastRowIndex = currentRowIndex;\n  });\n  if (acrossColumn === columnCount) {\n    const pathRefs = [];\n    for (let i = firsRowIndex; i < firsRowIndex + acrossRow; i++) {\n      const removedPath = tablePath.concat(i);\n      pathRefs.push(createPathRef2(editor, removedPath));\n    }\n    pathRefs.forEach((item) => {\n      removeNodes5(editor, { at: item.unref() });\n    });\n  }\n};\n\n// src/react/merge/deleteRow.ts\nvar deleteTableMergeRow = (editor) => {\n  var _a, _b;\n  const { getOptions, type } = getEditorPlugin9(editor, TablePlugin);\n  if (someNode4(editor, {\n    match: { type }\n  })) {\n    const { _cellIndices: cellIndices } = getOptions();\n    const currentTableItem = getAboveNode6(editor, {\n      match: { type }\n    });\n    if (!currentTableItem) return;\n    if (isExpanded3(editor.selection))\n      return deleteRowWhenExpanded(editor, currentTableItem);\n    const table = currentTableItem[0];\n    const selectedCellEntry = getAboveNode6(editor, {\n      match: { type: getCellTypes(editor) }\n    });\n    if (!selectedCellEntry) return;\n    const selectedCell = selectedCellEntry[0];\n    const { row: deletingRowIndex } = getCellIndices(\n      cellIndices,\n      selectedCell\n    );\n    const rowsDeleteNumber = getRowSpan(selectedCell);\n    const endingRowIndex = deletingRowIndex + rowsDeleteNumber - 1;\n    const colNumber = getTableColumnCount(table);\n    const affectedCellsSet = /* @__PURE__ */ new Set();\n    Array.from({ length: colNumber }, (_, i) => i).forEach((cI) => {\n      return Array.from({ length: rowsDeleteNumber }, (_, i) => i).forEach(\n        (rI) => {\n          const rowIndex = deletingRowIndex + rI;\n          const found = findCellByIndexes(editor, table, rowIndex, cI);\n          affectedCellsSet.add(found);\n        }\n      );\n    });\n    const affectedCells = Array.from(affectedCellsSet);\n    const { moveToNextRowCells, squizeRowSpanCells } = affectedCells.reduce(\n      (acc, cur) => {\n        if (!cur) return acc;\n        const currentCell = cur;\n        const { row: curRowIndex } = getCellIndices(cellIndices, currentCell);\n        const curRowSpan = getRowSpan(currentCell);\n        if (curRowIndex < deletingRowIndex && curRowSpan > 1) {\n          acc.squizeRowSpanCells.push(currentCell);\n        } else if (curRowSpan > 1 && curRowIndex + curRowSpan - 1 > endingRowIndex) {\n          acc.moveToNextRowCells.push(currentCell);\n        }\n        return acc;\n      },\n      { moveToNextRowCells: [], squizeRowSpanCells: [] }\n    );\n    const nextRowIndex = deletingRowIndex + rowsDeleteNumber;\n    const nextRow = table.children[nextRowIndex];\n    if (nextRow === void 0 && deletingRowIndex === 0) {\n      deleteTable(editor);\n      return;\n    }\n    if (nextRow) {\n      for (let index = 0; index < moveToNextRowCells.length; index++) {\n        const curRowCell = moveToNextRowCells[index];\n        const { col: curRowCellColIndex, row: curRowCellRowIndex } = getCellIndices(cellIndices, curRowCell);\n        const curRowCellRowSpan = getRowSpan(curRowCell);\n        const startingCellIndex = nextRow.children.findIndex((curC) => {\n          const cell = curC;\n          const { col: curColIndex } = getCellIndices(cellIndices, cell);\n          return curColIndex >= curRowCellColIndex;\n        });\n        if (startingCellIndex === -1) {\n          const startingCell2 = nextRow.children.at(-1);\n          const startingCellPath2 = findNodePath3(editor, startingCell2);\n          const tablePath2 = startingCellPath2.slice(0, -2);\n          const colPath2 = startingCellPath2.at(-1) + index + 1;\n          const nextRowStartCellPath2 = [...tablePath2, nextRowIndex, colPath2];\n          const rowsNumberAffected2 = endingRowIndex - curRowCellRowIndex + 1;\n          const rowSpan2 = curRowCellRowSpan - rowsNumberAffected2;\n          const newCell2 = cloneDeep4(__spreadProps(__spreadValues({}, curRowCell), { rowSpan: rowSpan2 }));\n          if ((_a = newCell2.attributes) == null ? void 0 : _a.rowspan) {\n            newCell2.attributes.rowspan = rowSpan2.toString();\n          }\n          insertElements5(editor, newCell2, {\n            at: nextRowStartCellPath2\n          });\n          continue;\n        }\n        const startingCell = nextRow.children[startingCellIndex];\n        const { col: startingColIndex } = getCellIndices(\n          cellIndices,\n          startingCell\n        );\n        let incrementBy = index;\n        if (startingColIndex < curRowCellColIndex) {\n          incrementBy += 1;\n        }\n        const startingCellPath = findNodePath3(editor, startingCell);\n        const tablePath = startingCellPath.slice(0, -2);\n        const colPath = startingCellPath.at(-1);\n        const nextRowStartCellPath = [\n          ...tablePath,\n          nextRowIndex,\n          colPath + incrementBy\n        ];\n        const rowsNumberAffected = endingRowIndex - curRowCellRowIndex + 1;\n        const rowSpan = curRowCellRowSpan - rowsNumberAffected;\n        const newCell = cloneDeep4(__spreadProps(__spreadValues({}, curRowCell), { rowSpan }));\n        if ((_b = newCell.attributes) == null ? void 0 : _b.rowspan) {\n          newCell.attributes.rowspan = rowSpan.toString();\n        }\n        insertElements5(editor, newCell, {\n          at: nextRowStartCellPath\n        });\n      }\n    }\n    squizeRowSpanCells.forEach((cur) => {\n      var _a2;\n      const curRowCell = cur;\n      const { row: curRowCellRowIndex } = getCellIndices(\n        cellIndices,\n        curRowCell\n      );\n      const curRowCellRowSpan = getRowSpan(curRowCell);\n      const curCellPath = findNodePath3(editor, curRowCell);\n      const curCellEndingRowIndex = Math.min(\n        curRowCellRowIndex + curRowCellRowSpan - 1,\n        endingRowIndex\n      );\n      const rowsNumberAffected = curCellEndingRowIndex - deletingRowIndex + 1;\n      const rowSpan = curRowCellRowSpan - rowsNumberAffected;\n      const newCell = cloneDeep4(__spreadProps(__spreadValues({}, curRowCell), { rowSpan }));\n      if ((_a2 = newCell.attributes) == null ? void 0 : _a2.rowspan) {\n        newCell.attributes.rowspan = rowSpan.toString();\n      }\n      setNodes11(editor, newCell, { at: curCellPath });\n    });\n    const rowToDelete = table.children[deletingRowIndex];\n    const rowPath = findNodePath3(editor, rowToDelete);\n    Array.from({ length: rowsDeleteNumber }).forEach(() => {\n      removeNodes6(editor, {\n        at: rowPath\n      });\n    });\n  }\n};\n\n// src/react/merge/getTableColumnIndex.ts\nimport {\n  getParentNode as getParentNode4\n} from \"@udecode/plate-common\";\nimport { findNodePath as findNodePath4 } from \"@udecode/plate-common/react\";\nvar getTableColumnIndex = (editor, cellNode) => {\n  var _a;\n  const path = findNodePath4(editor, cellNode);\n  if (!path) return -1;\n  const [trNode] = (_a = getParentNode4(editor, path)) != null ? _a : [];\n  if (!trNode) return -1;\n  let colIndex = -1;\n  trNode.children.some((item, index) => {\n    if (item === cellNode) {\n      colIndex = index;\n      return true;\n    }\n    return false;\n  });\n  return colIndex;\n};\n\n// src/react/merge/mergeTableCells.ts\nimport {\n  collapseSelection,\n  getBlockAbove as getBlockAbove7,\n  getEditorPlugin as getEditorPlugin10,\n  insertElements as insertElements6,\n  isElementEmpty,\n  removeNodes as removeNodes7,\n  withoutNormalizing as withoutNormalizing8\n} from \"@udecode/plate-common\";\nimport cloneDeep5 from \"lodash/cloneDeep.js\";\nvar mergeTableCells = (editor) => {\n  const { api, getOptions, type } = getEditorPlugin10(editor, TablePlugin);\n  const { _cellIndices } = getOptions();\n  withoutNormalizing8(editor, () => {\n    var _a;\n    const tableEntry = getBlockAbove7(editor, {\n      at: (_a = editor.selection) == null ? void 0 : _a.anchor.path,\n      match: { type }\n    });\n    const cellEntries = getTableGridAbove(editor, {\n      format: \"cell\"\n    });\n    let colSpan = 0;\n    for (const entry of cellEntries) {\n      const [cell, path] = entry;\n      const rowIndex = path.at(-2);\n      if (rowIndex === cellEntries[0][1].at(-2)) {\n        const cellColSpan = getColSpan(cell);\n        colSpan += cellColSpan;\n      }\n    }\n    let rowSpan = 0;\n    const { col } = getCellIndices(\n      _cellIndices,\n      cellEntries[0][0]\n    );\n    cellEntries.forEach((entry) => {\n      const cell = entry[0];\n      const { col: curCol } = (_cellIndices == null ? void 0 : _cellIndices.get(cell)) || computeCellIndices(editor, tableEntry[0], cell);\n      if (col === curCol) {\n        rowSpan += getRowSpan(cell);\n      }\n    });\n    const mergingCellChildren = [];\n    for (const cellEntry of cellEntries) {\n      const [el] = cellEntry;\n      const cellChildren = api.table.getCellChildren(el);\n      if (cellChildren.length !== 1 || !isElementEmpty(editor, cellChildren[0])) {\n        mergingCellChildren.push(...cloneDeep5(cellChildren));\n      }\n    }\n    const cols = {};\n    cellEntries.forEach(([_entry, path]) => {\n      const rowIndex = path.at(-2);\n      if (cols[rowIndex]) {\n        cols[rowIndex].push(path);\n      } else {\n        cols[rowIndex] = [path];\n      }\n    });\n    Object.values(cols).forEach((paths) => {\n      paths == null ? void 0 : paths.forEach(() => {\n        removeNodes7(editor, { at: paths[0] });\n      });\n    });\n    const mergedCell = __spreadProps(__spreadValues({}, api.create.cell({\n      children: mergingCellChildren,\n      header: cellEntries[0][0].type === editor.getType(TableCellHeaderPlugin)\n    })), {\n      colSpan,\n      rowSpan\n    });\n    insertElements6(editor, mergedCell, { at: cellEntries[0][1] });\n    collapseSelection(editor);\n  });\n};\n\n// src/react/merge/unmergeTableCells.ts\nimport {\n  findNode as findNode14,\n  getEditorPlugin as getEditorPlugin11,\n  insertElements as insertElements7,\n  removeNodes as removeNodes8,\n  withoutNormalizing as withoutNormalizing9\n} from \"@udecode/plate-common\";\nimport { findNodePath as findNodePath5 } from \"@udecode/plate-common/react\";\nvar unmergeTableCells = (editor) => {\n  const { api, getOptions } = getEditorPlugin11(editor, TablePlugin);\n  const { _cellIndices: cellIndices } = getOptions();\n  const tableRowType = editor.getType(TableRowPlugin);\n  withoutNormalizing9(editor, () => {\n    var _a;\n    const cellEntries = getTableGridAbove(editor, { format: \"cell\" });\n    const [[cellElem, path]] = cellEntries;\n    const createEmptyCell = (children) => {\n      return __spreadProps(__spreadValues({}, api.create.cell({\n        children,\n        header: cellElem.type === editor.getType(TableCellHeaderPlugin)\n      })), {\n        colSpan: 1,\n        rowSpan: 1\n      });\n    };\n    const tablePath = path.slice(0, -2);\n    const cellPath = path.slice(-2);\n    const [rowPath, colPath] = cellPath;\n    const colSpan = getColSpan(cellElem);\n    const rowSpan = getRowSpan(cellElem);\n    const colPaths = [];\n    for (let i = 0; i < colSpan; i++) {\n      colPaths.push(colPath + i);\n    }\n    removeNodes8(editor, { at: path });\n    const { col } = getCellIndices(\n      cellIndices,\n      cellElem\n    );\n    const getClosestColPathForRow = (row, targetCol) => {\n      const rowEntry = findNode14(editor, {\n        at: [...tablePath, row],\n        match: { type: tableRowType }\n      });\n      if (!rowEntry) {\n        return 0;\n      }\n      const rowEl = rowEntry[0];\n      let closestColPath = [];\n      let smallestDiff = Number.POSITIVE_INFINITY;\n      let isDirectionLeft = false;\n      rowEl.children.forEach((cell) => {\n        const cellElement = cell;\n        const { col: cellCol } = getCellIndices(cellIndices, cellElement);\n        const diff = Math.abs(cellCol - targetCol);\n        if (diff < smallestDiff) {\n          smallestDiff = diff;\n          closestColPath = findNodePath5(editor, cellElement);\n          isDirectionLeft = cellCol < targetCol;\n        }\n      });\n      if (closestColPath.length > 0) {\n        const lastIndex = closestColPath.at(-1);\n        if (isDirectionLeft) {\n          return lastIndex + 1;\n        }\n        return lastIndex;\n      }\n      return 1;\n    };\n    for (let i = 0; i < rowSpan; i++) {\n      const currentRowPath = rowPath + i;\n      const pathForNextRows = getClosestColPathForRow(currentRowPath, col);\n      const newRowChildren = [];\n      const _rowPath = [...tablePath, currentRowPath];\n      const rowEntry = findNode14(editor, {\n        at: _rowPath,\n        match: { type: tableRowType }\n      });\n      for (let j = 0; j < colPaths.length; j++) {\n        const cellChildren = api.table.getCellChildren(cellElem);\n        const cellToInsert = i === 0 && j === 0 ? createEmptyCell(cellChildren) : createEmptyCell();\n        if (rowEntry) {\n          const currentColPath = i === 0 ? colPaths[j] : pathForNextRows;\n          const pathForNewCell = [...tablePath, currentRowPath, currentColPath];\n          insertElements7(editor, cellToInsert, { at: pathForNewCell });\n        } else {\n          newRowChildren.push(cellToInsert);\n        }\n      }\n      if (!rowEntry) {\n        insertElements7(\n          editor,\n          {\n            children: newRowChildren,\n            type: editor.getType(BaseTableRowPlugin)\n          },\n          { at: _rowPath }\n        );\n      }\n    }\n    const tableElement = (_a = findNode14(editor, {\n      at: tablePath\n    })) == null ? void 0 : _a[0];\n    if (tableElement) {\n      computeCellIndices(editor, tableElement);\n    }\n  });\n};\n\n// src/react/transforms/deleteRow.ts\nvar deleteRow = (editor) => {\n  const { getOptions, type } = getEditorPlugin12(editor, TablePlugin);\n  const { enableMerging } = getOptions();\n  if (enableMerging) {\n    return deleteTableMergeRow(editor);\n  }\n  if (someNode5(editor, {\n    match: { type }\n  })) {\n    const currentTableItem = getAboveNode7(editor, {\n      match: { type }\n    });\n    if (!currentTableItem) return;\n    if (isExpanded4(editor.selection))\n      return deleteRowWhenExpanded(editor, currentTableItem);\n    const currentRowItem = getAboveNode7(editor, {\n      match: { type: editor.getType(BaseTableRowPlugin) }\n    });\n    if (currentRowItem && currentTableItem && // Cannot delete the last row\n    currentTableItem[0].children.length > 1) {\n      removeNodes9(editor, {\n        at: currentRowItem[1]\n      });\n    }\n  }\n};\n\n// src/react/transforms/insertTable.ts\nimport {\n  getBlockAbove as getBlockAbove8,\n  getEditorPlugin as getEditorPlugin13,\n  getStartPoint,\n  insertNodes,\n  someNode as someNode6,\n  withoutNormalizing as withoutNormalizing10\n} from \"@udecode/plate-common\";\nimport { selectEditor } from \"@udecode/plate-common/react\";\nvar insertTable = (editor, { colCount = 2, header, rowCount = 2 } = {}, options = {}) => {\n  const { type } = getEditorPlugin13(editor, BaseTablePlugin);\n  withoutNormalizing10(editor, () => {\n    if (!someNode6(editor, {\n      match: { type }\n    })) {\n      insertNodes(\n        editor,\n        getEmptyTableNode(editor, {\n          colCount,\n          header,\n          rowCount\n        }),\n        __spreadValues({\n          nextBlock: true\n        }, options)\n      );\n      if (editor.selection) {\n        const tableEntry = getBlockAbove8(editor, {\n          match: { type }\n        });\n        if (!tableEntry) return;\n        selectEditor(editor, { at: getStartPoint(editor, tableEntry[1]) });\n      }\n    }\n  });\n};\n\n// src/react/transforms/moveSelectionFromCell.ts\nimport {\n  getBlockAbove as getBlockAbove9,\n  getEndPoint,\n  getStartPoint as getStartPoint2,\n  hasNode,\n  moveSelection,\n  select as select2,\n  withoutNormalizing as withoutNormalizing11\n} from \"@udecode/plate-common\";\nvar moveSelectionFromCell = (editor, {\n  at,\n  edge,\n  fromOneCell,\n  reverse\n} = {}) => {\n  if (edge) {\n    const cellEntries = getTableGridAbove(editor, { at, format: \"cell\" });\n    const minCell = fromOneCell ? 0 : 1;\n    if (cellEntries.length > minCell) {\n      const [, firstCellPath] = cellEntries[0];\n      const [, lastCellPath] = cellEntries.at(-1);\n      const anchorPath = [...firstCellPath];\n      const focusPath = [...lastCellPath];\n      switch (edge) {\n        case \"bottom\": {\n          focusPath[focusPath.length - 2] += 1;\n          break;\n        }\n        case \"left\": {\n          anchorPath[anchorPath.length - 1] -= 1;\n          break;\n        }\n        case \"right\": {\n          focusPath[focusPath.length - 1] += 1;\n          break;\n        }\n        case \"top\": {\n          anchorPath[anchorPath.length - 2] -= 1;\n          break;\n        }\n      }\n      if (hasNode(editor, anchorPath) && hasNode(editor, focusPath)) {\n        select2(editor, {\n          anchor: getStartPoint2(editor, anchorPath),\n          focus: getStartPoint2(editor, focusPath)\n        });\n      }\n      return true;\n    }\n    return;\n  }\n  const cellEntry = getBlockAbove9(editor, {\n    at,\n    match: { type: getCellTypes(editor) }\n  });\n  if (cellEntry) {\n    const [, cellPath] = cellEntry;\n    const nextCellPath = [...cellPath];\n    const offset = reverse ? -1 : 1;\n    nextCellPath[nextCellPath.length - 2] += offset;\n    if (hasNode(editor, nextCellPath)) {\n      select2(editor, getStartPoint2(editor, nextCellPath));\n    } else {\n      const tablePath = cellPath.slice(0, -2);\n      if (reverse) {\n        withoutNormalizing11(editor, () => {\n          select2(editor, getStartPoint2(editor, tablePath));\n          moveSelection(editor, { reverse: true });\n        });\n      } else {\n        withoutNormalizing11(editor, () => {\n          select2(editor, getEndPoint(editor, tablePath));\n          moveSelection(editor);\n        });\n      }\n    }\n    return true;\n  }\n};\n\n// src/react/transforms/overrideSelectionFromCell.ts\nimport {\n  isHotkey,\n  isRangeAcrossBlocks,\n  isRangeInSameBlock\n} from \"@udecode/plate-common\";\nvar overrideSelectionFromCell = (editor, newSelection) => {\n  var _a;\n  let hotkey;\n  if (!editor.currentKeyboardEvent || ![\"up\", \"down\", \"shift+up\", \"shift+right\", \"shift+down\", \"shift+left\"].some(\n    (key) => {\n      const valid = isHotkey(key, editor.currentKeyboardEvent);\n      if (valid) hotkey = key;\n      return valid;\n    }\n  ) || !((_a = editor.selection) == null ? void 0 : _a.focus) || !(newSelection == null ? void 0 : newSelection.focus) || !isRangeAcrossBlocks(editor, {\n    at: {\n      anchor: editor.selection.focus,\n      focus: newSelection.focus\n    },\n    match: { type: getCellTypes(editor) }\n  })) {\n    return;\n  }\n  if (!hotkey) return;\n  const edge = KEY_SHIFT_EDGES[hotkey];\n  if (edge && !isRangeInSameBlock(editor, {\n    at: editor.selection,\n    match: { type: getCellTypes(editor) }\n  })) {\n    return;\n  }\n  const prevSelection = editor.selection;\n  const reverse = [\"shift+up\", \"up\"].includes(hotkey);\n  setTimeout(() => {\n    moveSelectionFromCell(editor, {\n      at: prevSelection,\n      edge,\n      fromOneCell: true,\n      reverse\n    });\n  }, 0);\n};\n\n// src/react/onKeyDownTable.ts\nvar onKeyDownTable = ({\n  editor,\n  event,\n  type\n}) => {\n  if (event.defaultPrevented) return;\n  const isKeyDown = {\n    \"shift+down\": isHotkey2(\"shift+down\", event),\n    \"shift+left\": isHotkey2(\"shift+left\", event),\n    \"shift+right\": isHotkey2(\"shift+right\", event),\n    \"shift+up\": isHotkey2(\"shift+up\", event)\n  };\n  Object.keys(isKeyDown).forEach((key) => {\n    if (isKeyDown[key] && // if many cells are selected\n    moveSelectionFromCell(editor, {\n      edge: KEY_SHIFT_EDGES[key],\n      reverse: key === \"shift+up\"\n    })) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  });\n  const isTab = Hotkeys.isTab(editor, event);\n  const isUntab = Hotkeys.isUntab(editor, event);\n  if (isTab || isUntab) {\n    const entries = getTableEntries(editor);\n    if (!entries) return;\n    const { cell, row } = entries;\n    const [, cellPath] = cell;\n    if (isUntab) {\n      const previousCell = getPreviousTableCell(editor, cell, cellPath, row);\n      if (previousCell) {\n        const [, previousCellPath] = previousCell;\n        select3(editor, previousCellPath);\n      }\n    } else if (isTab) {\n      const nextCell = getNextTableCell(editor, cell, cellPath, row);\n      if (nextCell) {\n        const [, nextCellPath] = nextCell;\n        select3(editor, nextCellPath);\n      }\n    }\n    event.preventDefault();\n    event.stopPropagation();\n  }\n  if (isHotkey2(\"mod+a\", event)) {\n    const res = getAboveNode8(editor, { match: { type } });\n    if (!res) return;\n    const [, tablePath] = res;\n    select3(editor, tablePath);\n    event.preventDefault();\n    event.stopPropagation();\n  }\n};\n\n// src/react/withDeleteTable.ts\nimport {\n  getBlockAbove as getBlockAbove10,\n  getEndPoint as getEndPoint2,\n  getPointAfter,\n  getPointBefore,\n  getStartPoint as getStartPoint3,\n  isCollapsed,\n  isRangeInSameBlock as isRangeInSameBlock2,\n  moveSelection as moveSelection2,\n  replaceNodeChildren,\n  select as select4,\n  withoutNormalizing as withoutNormalizing12\n} from \"@udecode/plate-common\";\nimport { Point } from \"slate\";\nvar preventDeleteTableCell = (editor, {\n  reverse,\n  unit\n}) => {\n  const { selection } = editor;\n  const getPoint = reverse ? getEndPoint2 : getStartPoint3;\n  const getNextPoint = reverse ? getPointAfter : getPointBefore;\n  if (isCollapsed(selection)) {\n    const cellEntry = getBlockAbove10(editor, {\n      match: { type: getCellTypes(editor) }\n    });\n    if (cellEntry) {\n      const [, cellPath] = cellEntry;\n      const start = getPoint(editor, cellPath);\n      if (selection && Point.equals(selection.anchor, start)) {\n        return true;\n      }\n    } else {\n      const nextPoint = getNextPoint(editor, selection, { unit });\n      const nextCellEntry = getBlockAbove10(editor, {\n        at: nextPoint,\n        match: { type: getCellTypes(editor) }\n      });\n      if (nextCellEntry) {\n        moveSelection2(editor, { reverse: !reverse });\n        return true;\n      }\n    }\n  }\n};\nvar withDeleteTable = ({\n  editor,\n  type\n}) => {\n  const { deleteBackward, deleteForward, deleteFragment } = editor;\n  editor.deleteBackward = (unit) => {\n    if (preventDeleteTableCell(editor, { unit })) return;\n    return deleteBackward(unit);\n  };\n  editor.deleteForward = (unit) => {\n    if (preventDeleteTableCell(editor, { reverse: true, unit })) return;\n    return deleteForward(unit);\n  };\n  editor.deleteFragment = (direction) => {\n    if (isRangeInSameBlock2(editor, {\n      match: (n) => n.type === type\n    })) {\n      const cellEntries = getTableGridAbove(editor, { format: \"cell\" });\n      if (cellEntries.length > 1) {\n        withoutNormalizing12(editor, () => {\n          cellEntries.forEach(([, cellPath]) => {\n            replaceNodeChildren(editor, {\n              at: cellPath,\n              nodes: editor.api.create.block()\n            });\n          });\n          select4(editor, {\n            anchor: getStartPoint3(editor, cellEntries[0][1]),\n            focus: getEndPoint2(editor, cellEntries.at(-1)[1])\n          });\n        });\n        return;\n      }\n    }\n    deleteFragment(direction);\n  };\n  return editor;\n};\n\n// src/react/withGetFragmentTable.ts\nvar withGetFragmentTable = ({\n  api,\n  editor,\n  type\n}) => {\n  const { getFragment } = editor;\n  editor.getFragment = () => {\n    const fragment = getFragment();\n    const newFragment = [];\n    fragment.forEach((node) => {\n      if (node.type === type) {\n        const rows = node.children;\n        const rowCount = rows.length;\n        if (!rowCount) return;\n        const colCount = rows[0].children.length;\n        const hasOneCell = rowCount <= 1 && colCount <= 1;\n        if (hasOneCell) {\n          const cell = rows[0];\n          const cellChildren = api.table.getCellChildren(cell);\n          newFragment.push(...cellChildren[0].children);\n          return;\n        } else {\n          const subTable = getTableGridAbove(editor);\n          if (subTable.length > 0) {\n            newFragment.push(subTable[0][0]);\n            return;\n          }\n        }\n      }\n      newFragment.push(node);\n    });\n    return newFragment;\n  };\n  return editor;\n};\n\n// src/react/withInsertFragmentTable.ts\nimport {\n  getEndPoint as getEndPoint3,\n  getStartPoint as getStartPoint4,\n  hasNode as hasNode2,\n  replaceNodeChildren as replaceNodeChildren2,\n  select as select5,\n  withoutNormalizing as withoutNormalizing13\n} from \"@udecode/plate-common\";\nimport cloneDeep6 from \"lodash/cloneDeep.js\";\nvar withInsertFragmentTable = ({\n  api,\n  editor,\n  getOptions,\n  tf,\n  type\n}) => {\n  const { insertFragment } = editor;\n  editor.insertFragment = (fragment) => {\n    var _a, _b, _c;\n    const insertedTable = fragment.find(\n      (n) => n.type === type\n    );\n    if (!insertedTable) {\n      const tableEntry = getTableAbove(editor, {\n        at: (_a = editor.selection) == null ? void 0 : _a.anchor\n      });\n      if (tableEntry) {\n        const cellEntries = getTableGridAbove(editor, {\n          format: \"cell\"\n        });\n        if (cellEntries.length > 1) {\n          cellEntries.forEach((cellEntry) => {\n            if (cellEntry) {\n              const [, cellPath] = cellEntry;\n              replaceNodeChildren2(editor, {\n                at: cellPath,\n                nodes: cloneDeep6(fragment)\n              });\n            }\n          });\n          select5(editor, {\n            anchor: getStartPoint4(editor, cellEntries[0][1]),\n            focus: getEndPoint3(editor, cellEntries.at(-1)[1])\n          });\n          return;\n        }\n      }\n    }\n    if (insertedTable) {\n      const tableEntry = getTableAbove(editor, {\n        at: (_b = editor.selection) == null ? void 0 : _b.anchor\n      });\n      if (tableEntry) {\n        const [cellEntry] = getTableGridAbove(editor, {\n          at: (_c = editor.selection) == null ? void 0 : _c.anchor,\n          format: \"cell\"\n        });\n        if (cellEntry) {\n          withoutNormalizing13(editor, () => {\n            const [, startCellPath] = cellEntry;\n            const cellPath = [...startCellPath];\n            const startColIndex = cellPath.at(-1);\n            let lastCellPath = null;\n            let initRow = true;\n            const insertedRows = insertedTable.children;\n            insertedRows.forEach((row) => {\n              cellPath[cellPath.length - 1] = startColIndex;\n              if (!initRow) {\n                const fromRow = cellPath.slice(0, -1);\n                cellPath[cellPath.length - 2] += 1;\n                if (!hasNode2(editor, cellPath)) {\n                  if (getOptions().disableExpandOnInsert) {\n                    return;\n                  } else {\n                    tf.insert.tableRow({\n                      disableSelect: true,\n                      fromRow\n                    });\n                  }\n                }\n              }\n              initRow = false;\n              const insertedCells = row.children;\n              let initCell = true;\n              insertedCells.forEach((cell) => {\n                if (!initCell) {\n                  const fromCell = [...cellPath];\n                  cellPath[cellPath.length - 1] += 1;\n                  if (!hasNode2(editor, cellPath)) {\n                    if (getOptions().disableExpandOnInsert) {\n                      return;\n                    } else {\n                      tf.insert.tableColumn({\n                        disableSelect: true,\n                        fromCell\n                      });\n                    }\n                  }\n                }\n                initCell = false;\n                const cellChildren = api.table.getCellChildren(\n                  cell\n                );\n                replaceNodeChildren2(editor, {\n                  at: cellPath,\n                  nodes: cloneDeep6(cellChildren)\n                });\n                lastCellPath = [...cellPath];\n              });\n            });\n            if (lastCellPath) {\n              select5(editor, {\n                anchor: getStartPoint4(editor, startCellPath),\n                focus: getEndPoint3(editor, lastCellPath)\n              });\n            }\n          });\n          return;\n        }\n      } else if (fragment.length === 1 && fragment[0].type === TablePlugin.key) {\n        editor.insertNode(fragment[0]);\n        return;\n      }\n    }\n    insertFragment(fragment);\n  };\n  return editor;\n};\n\n// src/react/withInsertTextTable.ts\nimport { collapseSelection as collapseSelection2, isExpanded as isExpanded5 } from \"@udecode/plate-common\";\nvar withInsertTextTable = ({ editor }) => {\n  const { insertText } = editor;\n  editor.insertText = (text) => {\n    var _a;\n    if (isExpanded5(editor.selection)) {\n      const entry = getTableAbove(editor, {\n        at: (_a = editor.selection) == null ? void 0 : _a.anchor\n      });\n      if (entry) {\n        const cellEntries = getTableGridAbove(editor, {\n          format: \"cell\"\n        });\n        if (cellEntries.length > 1) {\n          collapseSelection2(editor, {\n            edge: \"focus\"\n          });\n        }\n      }\n    }\n    insertText(text);\n  };\n  return editor;\n};\n\n// src/react/withMarkTable.tsx\nimport {\n  getNodeEntries,\n  isCollapsed as isCollapsed2,\n  isText as isText2,\n  setNodes as setNodes12,\n  unsetNodes\n} from \"@udecode/plate-common\";\nvar withMarkTable = ({ editor }) => {\n  const { addMark, getMarks, removeMark } = editor;\n  editor.addMark = (key, value) => {\n    const { selection } = editor;\n    if (!selection || isCollapsed2(selection)) return addMark(key, value);\n    const matchesCell = getTableGridAbove(editor, { format: \"cell\" });\n    if (matchesCell.length <= 1) return addMark(key, value);\n    matchesCell.forEach(([_cell, cellPath]) => {\n      setNodes12(\n        editor,\n        {\n          [key]: value\n        },\n        {\n          at: cellPath,\n          match: (n) => isText2(n),\n          split: true,\n          voids: true\n        }\n      );\n    });\n  };\n  editor.removeMark = (key) => {\n    const { selection } = editor;\n    if (!selection || isCollapsed2(selection)) return removeMark(key);\n    const matchesCell = getTableGridAbove(editor, { format: \"cell\" });\n    if (matchesCell.length === 0) return removeMark(key);\n    matchesCell.forEach(([_cell, cellPath]) => {\n      unsetNodes(editor, key, {\n        at: cellPath,\n        match: (n) => isText2(n),\n        split: true,\n        voids: true\n      });\n    });\n  };\n  editor.getMarks = () => {\n    const { selection } = editor;\n    if (!selection || isCollapsed2(selection)) return getMarks();\n    const matchesCell = getTableGridAbove(editor, { format: \"cell\" });\n    if (matchesCell.length === 0) return getMarks();\n    const totalMarks = {};\n    matchesCell.forEach(([_cell, cellPath]) => {\n      const textNodeEntry = getNodeEntries(editor, {\n        at: cellPath,\n        match: (n) => isText2(n)\n      });\n      Array.from(textNodeEntry, (item) => item[0]).forEach((item) => {\n        const keys = Object.keys(item);\n        if (keys.length === 1) return;\n        keys.splice(keys.indexOf(\"text\"), 1);\n        keys.forEach((k) => {\n          totalMarks[k] = item[k];\n        });\n      });\n    });\n    return totalMarks;\n  };\n  return editor;\n};\n\n// src/react/withSelectionTable.ts\nimport {\n  getBlockAbove as getBlockAbove11,\n  getEndPoint as getEndPoint4,\n  getPointBefore as getPointBefore2,\n  getStartPoint as getStartPoint5,\n  isRangeAcrossBlocks as isRangeAcrossBlocks2\n} from \"@udecode/plate-common\";\nimport { Range as Range2 } from \"slate\";\nvar withSelectionTable = ({\n  editor,\n  type\n}) => {\n  const { apply } = editor;\n  editor.apply = (op) => {\n    if (op.type === \"set_selection\" && op.newProperties) {\n      const newSelection = __spreadValues(__spreadValues({}, editor.selection), op.newProperties);\n      if (Range2.isRange(newSelection) && isRangeAcrossBlocks2(editor, {\n        at: newSelection,\n        match: (n) => n.type === type\n      })) {\n        const anchorEntry = getBlockAbove11(editor, {\n          at: newSelection.anchor,\n          match: (n) => n.type === type\n        });\n        if (anchorEntry) {\n          const [, anchorPath] = anchorEntry;\n          const isBackward = Range2.isBackward(newSelection);\n          if (isBackward) {\n            op.newProperties.focus = getStartPoint5(editor, anchorPath);\n          } else {\n            const pointBefore = getPointBefore2(editor, anchorPath);\n            if (pointBefore) {\n              op.newProperties.focus = getEndPoint4(editor, anchorPath);\n            }\n          }\n        } else {\n          const focusEntry = getBlockAbove11(editor, {\n            at: newSelection.focus,\n            match: (n) => n.type === type\n          });\n          if (focusEntry) {\n            const [, focusPath] = focusEntry;\n            const isBackward = Range2.isBackward(newSelection);\n            if (isBackward) {\n              const startPoint = getStartPoint5(editor, focusPath);\n              const pointBefore = getPointBefore2(editor, startPoint);\n              op.newProperties.focus = pointBefore != null ? pointBefore : startPoint;\n            } else {\n              op.newProperties.focus = getEndPoint4(editor, focusPath);\n            }\n          }\n        }\n      }\n      overrideSelectionFromCell(editor, newSelection);\n    }\n    apply(op);\n  };\n  return editor;\n};\n\n// src/react/withSetFragmentDataTable.ts\nimport {\n  findNode as findNode15,\n  getEndPoint as getEndPoint5,\n  getStartPoint as getStartPoint6,\n  select as select6,\n  withoutNormalizing as withoutNormalizing14\n} from \"@udecode/plate-common\";\nimport { findNodePath as findNodePath6 } from \"@udecode/plate-common/react\";\nvar withSetFragmentDataTable = ({\n  editor,\n  plugin\n}) => {\n  const { setFragmentData } = editor;\n  editor.setFragmentData = (data, originEvent) => {\n    var _a;\n    const tableEntry = (_a = getTableGridAbove(editor, {\n      format: \"table\"\n    })) == null ? void 0 : _a[0];\n    const selectedCellEntries = getTableGridAbove(editor, {\n      format: \"cell\"\n    });\n    const initialSelection = editor.selection;\n    if (!tableEntry || !initialSelection) {\n      setFragmentData(data, originEvent);\n      return;\n    }\n    const [tableNode, tablePath] = tableEntry;\n    const tableRows = tableNode.children;\n    tableNode.children = tableNode.children.filter(\n      (v) => v.children.length > 0\n    );\n    let textCsv = \"\";\n    let textTsv = \"\";\n    const divElement = document.createElement(\"div\");\n    const tableElement = document.createElement(\"table\");\n    if (tableEntry && initialSelection && selectedCellEntries.length === 1 && (originEvent === \"copy\" || originEvent === \"cut\")) {\n      setFragmentData(data);\n      return;\n    }\n    withoutNormalizing14(editor, () => {\n      tableRows.forEach((row) => {\n        const rowCells = row.children;\n        const cellStrings = [];\n        const rowElement = row.type === editor.getType(TableCellHeaderPlugin) ? document.createElement(\"th\") : document.createElement(\"tr\");\n        rowCells.forEach((cell) => {\n          data.clearData();\n          const cellPath = findNodePath6(editor, cell);\n          select6(editor, {\n            anchor: getStartPoint6(editor, cellPath),\n            focus: getEndPoint5(editor, cellPath)\n          });\n          setFragmentData(data);\n          cellStrings.push(data.getData(\"text/plain\"));\n          const cellElement = document.createElement(\"td\");\n          const colSpan = getColSpan(cell);\n          cellElement.colSpan = colSpan;\n          const rowSpan = getRowSpan(cell);\n          cellElement.rowSpan = rowSpan;\n          cellElement.innerHTML = data.getData(\"text/html\");\n          rowElement.append(cellElement);\n        });\n        tableElement.append(rowElement);\n        textCsv += `${cellStrings.join(\",\")}\n`;\n        textTsv += `${cellStrings.join(\"\t\")}\n`;\n      });\n      const _tableEntry = findNode15(editor, {\n        at: tablePath,\n        match: { type: TablePlugin.key }\n      });\n      if (_tableEntry != null && _tableEntry.length > 0) {\n        const realTable = _tableEntry[0];\n        if (realTable.attributes != null) {\n          Object.entries(realTable.attributes).forEach(([key, value]) => {\n            var _a2;\n            if (value != null && ((_a2 = plugin.node.dangerouslyAllowAttributes) == null ? void 0 : _a2.includes(key))) {\n              tableElement.setAttribute(key, String(value));\n            }\n          });\n        }\n      }\n      select6(editor, initialSelection);\n      divElement.append(tableElement);\n    });\n    data.setData(\"text/csv\", textCsv);\n    data.setData(\"text/tsv\", textTsv);\n    data.setData(\"text/plain\", textTsv);\n    data.setData(\"text/html\", divElement.innerHTML);\n    const selectedFragmentStr = JSON.stringify(tableNode);\n    const encodedFragment = window.btoa(\n      encodeURIComponent(selectedFragmentStr)\n    );\n    data.setData(\"application/x-slate-fragment\", encodedFragment);\n  };\n  return editor;\n};\n\n// src/react/withTable.ts\nvar withTable2 = (_a) => {\n  var _b = _a, { editor } = _b, ctx = __objRest(_b, [\"editor\"]);\n  editor = withNormalizeTable(__spreadValues({ editor }, ctx));\n  editor = withDeleteTable(__spreadValues({ editor }, ctx));\n  editor = withGetFragmentTable(__spreadValues({ editor }, ctx));\n  editor = withInsertFragmentTable(__spreadValues({ editor }, ctx));\n  editor = withInsertTextTable(__spreadValues({ editor }, ctx));\n  editor = withSelectionTable(__spreadValues({ editor }, ctx));\n  editor = withSetFragmentDataTable(__spreadValues({ editor }, ctx));\n  editor = withMarkTable(__spreadValues({ editor }, ctx));\n  return editor;\n};\n\n// src/react/TablePlugin.tsx\nvar TableRowPlugin = toPlatePlugin(BaseTableRowPlugin);\nvar TableCellPlugin = toPlatePlugin(BaseTableCellPlugin, {\n  node: {\n    props: ({ element }) => {\n      var _a, _b;\n      return {\n        nodeProps: {\n          colSpan: (_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.colspan,\n          rowSpan: (_b = element == null ? void 0 : element.attributes) == null ? void 0 : _b.rowspan\n        }\n      };\n    }\n  }\n});\nvar TableCellHeaderPlugin = toPlatePlugin(BaseTableCellHeaderPlugin, {\n  node: {\n    props: ({ element }) => {\n      var _a, _b;\n      return {\n        nodeProps: {\n          colSpan: (_a = element == null ? void 0 : element.attributes) == null ? void 0 : _a.colspan,\n          rowSpan: (_b = element == null ? void 0 : element.attributes) == null ? void 0 : _b.rowspan\n        }\n      };\n    }\n  }\n});\nvar TablePlugin = toPlatePlugin(BaseTablePlugin, {\n  extendEditor: withTable2,\n  plugins: [TableRowPlugin, TableCellPlugin, TableCellHeaderPlugin],\n  handlers: {\n    onKeyDown: onKeyDownTable\n  }\n});\n\n// src/react/components/TableCellElement/getOnSelectTableBorderFactory.ts\nimport { focusEditor } from \"@udecode/plate-common/react\";\nvar getOnSelectTableBorderFactory = (editor, selectedCells) => (border) => () => {\n  if (selectedCells) return;\n  if (border === \"none\") {\n    setBorderSize(editor, 0, { border: \"all\" });\n  } else if (border === \"outer\") {\n    setBorderSize(editor, 1, { border: \"all\" });\n  } else {\n    const size = isTableBorderHidden(editor, border) ? 1 : 0;\n    setBorderSize(editor, size, { border });\n  }\n  setTimeout(() => {\n    focusEditor(editor);\n  }, 50);\n};\n\n// src/react/components/TableCellElement/getTableCellBorders.ts\nvar getTableCellBorders = (element, {\n  defaultBorder = {\n    color: \"rgb(209 213 219)\",\n    size: 1,\n    style: \"solid\"\n  },\n  isFirstCell,\n  isFirstRow\n} = {}) => {\n  const getBorder = (dir) => {\n    var _a, _b, _c, _d;\n    const border = (_a = element.borders) == null ? void 0 : _a[dir];\n    return {\n      color: (_b = border == null ? void 0 : border.color) != null ? _b : defaultBorder.color,\n      size: (_c = border == null ? void 0 : border.size) != null ? _c : defaultBorder.size,\n      style: (_d = border == null ? void 0 : border.style) != null ? _d : defaultBorder.style\n    };\n  };\n  return {\n    bottom: getBorder(\"bottom\"),\n    left: isFirstCell ? getBorder(\"left\") : void 0,\n    right: getBorder(\"right\"),\n    top: isFirstRow ? getBorder(\"top\") : void 0\n  };\n};\n\n// src/react/components/TableCellElement/roundCellSizeToStep.ts\nvar roundCellSizeToStep = (size, step) => {\n  return step ? Math.round(size / step) * step : size;\n};\n\n// src/react/components/TableCellElement/useIsCellSelected.ts\nimport React2 from \"react\";\n\n// src/react/stores/tableStore.ts\nimport React from \"react\";\nimport { atom, createAtomStore } from \"@udecode/plate-common/react\";\nvar { TableProvider, tableStore, useTableStore } = createAtomStore(\n  {\n    colSizeOverrides: atom(/* @__PURE__ */ new Map()),\n    hoveredColIndex: null,\n    marginLeftOverride: null,\n    rowSizeOverrides: atom(/* @__PURE__ */ new Map()),\n    selectedCells: null,\n    selectedTable: null\n  },\n  { name: \"table\" }\n);\nvar useOverrideSizeFactory = (setOverrides) => React.useCallback(\n  (index, size) => {\n    setOverrides((overrides) => {\n      const newOverrides = new Map(overrides);\n      if (size === null) {\n        newOverrides.delete(index);\n      } else {\n        newOverrides.set(index, size);\n      }\n      return newOverrides;\n    });\n  },\n  [setOverrides]\n);\nvar useOverrideColSize = () => {\n  const setColSizeOverrides = useTableStore().set.colSizeOverrides();\n  return useOverrideSizeFactory(setColSizeOverrides);\n};\nvar useOverrideRowSize = () => {\n  const setRowSizeOverrides = useTableStore().set.rowSizeOverrides();\n  return useOverrideSizeFactory(setRowSizeOverrides);\n};\nvar useOverrideMarginLeft = () => useTableStore().set.marginLeftOverride();\n\n// src/react/components/TableCellElement/useIsCellSelected.ts\nvar useIsCellSelected = (element) => {\n  const selectedCells = useTableStore().get.selectedCells();\n  return React2.useMemo(\n    () => !!(selectedCells == null ? void 0 : selectedCells.includes(element)),\n    [element, selectedCells]\n  );\n};\n\n// src/react/components/TableCellElement/useTableBordersDropdownMenuContentState.ts\nimport { useEditorRef, useEditorSelector } from \"@udecode/plate-common/react\";\nvar useTableBordersDropdownMenuContentState = () => {\n  const editor = useEditorRef();\n  const selectedCells = useTableStore().get.selectedCells();\n  const hasBottomBorder = useEditorSelector(\n    (editor2) => !isTableBorderHidden(editor2, \"bottom\"),\n    []\n  );\n  const hasTopBorder = useEditorSelector(\n    (editor2) => !isTableBorderHidden(editor2, \"top\"),\n    []\n  );\n  const hasLeftBorder = useEditorSelector(\n    (editor2) => !isTableBorderHidden(editor2, \"left\"),\n    []\n  );\n  const hasRightBorder = useEditorSelector(\n    (editor2) => !isTableBorderHidden(editor2, \"right\"),\n    []\n  );\n  const hasOuterBorders = hasBottomBorder && hasTopBorder && hasLeftBorder && hasRightBorder;\n  const hasNoBorders = !hasBottomBorder && !hasTopBorder && !hasLeftBorder && !hasRightBorder;\n  return {\n    getOnSelectTableBorder: getOnSelectTableBorderFactory(\n      editor,\n      selectedCells\n    ),\n    hasBottomBorder,\n    hasLeftBorder,\n    hasNoBorders,\n    hasOuterBorders,\n    hasRightBorder,\n    hasTopBorder\n  };\n};\n\n// src/react/components/TableCellElement/useTableCellElementResizable.ts\nimport React4 from \"react\";\nimport {\n  findNodePath as findNodePath8,\n  useEditorPlugin,\n  useElement\n} from \"@udecode/plate-common/react\";\nimport {\n  resizeLengthClampStatic\n} from \"@udecode/plate-resizable\";\n\n// src/react/components/TableElement/useTableColSizes.ts\nimport React3 from \"react\";\nimport { unsetNodes as unsetNodes2 } from \"@udecode/plate-common\";\nimport { findNodePath as findNodePath7, useEditorRef as useEditorRef2 } from \"@udecode/plate-common/react\";\nvar useTableColSizes = (tableNode, { disableOverrides = false } = {}) => {\n  const editor = useEditorRef2();\n  const colSizeOverrides = useTableStore().get.colSizeOverrides();\n  const { enableUnsetSingleColSize } = editor.getOptions(TablePlugin);\n  const overriddenColSizes = getTableOverriddenColSizes(\n    tableNode,\n    disableOverrides ? void 0 : colSizeOverrides\n  );\n  const colCount = getTableColumnCount(tableNode);\n  React3.useEffect(() => {\n    var _a;\n    if (enableUnsetSingleColSize && colCount < 2 && ((_a = tableNode.colSizes) == null ? void 0 : _a.length)) {\n      unsetNodes2(editor, \"colSizes\", {\n        at: findNodePath7(editor, tableNode)\n      });\n    }\n  }, [colCount, enableUnsetSingleColSize, editor, tableNode]);\n  return overriddenColSizes;\n};\n\n// src/react/components/TableCellElement/useTableCellElementResizable.ts\nvar useTableCellElementResizableState = ({\n  colIndex,\n  colSpan,\n  rowIndex,\n  step,\n  stepX = step,\n  stepY = step\n}) => {\n  const { getOptions } = useEditorPlugin(TablePlugin);\n  const { disableMarginLeft } = getOptions();\n  return {\n    colIndex,\n    colSpan,\n    disableMarginLeft,\n    rowIndex,\n    stepX,\n    stepY\n  };\n};\nvar useTableCellElementResizable = ({\n  colIndex,\n  colSpan,\n  disableMarginLeft,\n  rowIndex,\n  stepX,\n  stepY\n}) => {\n  var _a;\n  const { editor, getOptions } = useEditorPlugin(TablePlugin);\n  const element = useElement();\n  const tableElement = useElement(TablePlugin.key);\n  const { minColumnWidth = 0 } = getOptions();\n  let initialWidth;\n  if (colSpan > 1) {\n    initialWidth = (_a = tableElement.colSizes) == null ? void 0 : _a[colIndex];\n  }\n  const [hoveredColIndex, setHoveredColIndex] = useTableStore().use.hoveredColIndex();\n  const colSizesWithoutOverrides = useTableColSizes(tableElement, {\n    disableOverrides: true\n  });\n  const { marginLeft = 0 } = tableElement;\n  const overrideColSize = useOverrideColSize();\n  const overrideRowSize = useOverrideRowSize();\n  const overrideMarginLeft = useOverrideMarginLeft();\n  const setColSize = React4.useCallback(\n    (colIndex2, width) => {\n      setTableColSize(\n        editor,\n        { colIndex: colIndex2, width },\n        { at: findNodePath8(editor, element) }\n      );\n      setTimeout(() => overrideColSize(colIndex2, null), 0);\n    },\n    [editor, element, overrideColSize]\n  );\n  const setRowSize = React4.useCallback(\n    (rowIndex2, height) => {\n      setTableRowSize(\n        editor,\n        { height, rowIndex: rowIndex2 },\n        { at: findNodePath8(editor, element) }\n      );\n      setTimeout(() => overrideRowSize(rowIndex2, null), 0);\n    },\n    [editor, element, overrideRowSize]\n  );\n  const setMarginLeft = React4.useCallback(\n    (marginLeft2) => {\n      setTableMarginLeft(\n        editor,\n        { marginLeft: marginLeft2 },\n        { at: findNodePath8(editor, element) }\n      );\n      setTimeout(() => overrideMarginLeft(null), 0);\n    },\n    [editor, element, overrideMarginLeft]\n  );\n  const handleResizeRight = React4.useCallback(\n    ({ delta, finished, initialSize: currentInitial }) => {\n      const nextInitial = colSizesWithoutOverrides[colIndex + 1];\n      const complement = (width) => currentInitial + nextInitial - width;\n      const currentNew = roundCellSizeToStep(\n        resizeLengthClampStatic(currentInitial + delta, {\n          max: nextInitial ? complement(minColumnWidth) : void 0,\n          min: minColumnWidth\n        }),\n        stepX\n      );\n      const nextNew = nextInitial ? complement(currentNew) : void 0;\n      const fn = finished ? setColSize : overrideColSize;\n      fn(colIndex, currentNew);\n      if (nextNew) fn(colIndex + 1, nextNew);\n    },\n    [\n      colIndex,\n      colSizesWithoutOverrides,\n      minColumnWidth,\n      overrideColSize,\n      setColSize,\n      stepX\n    ]\n  );\n  const handleResizeBottom = React4.useCallback(\n    (event) => {\n      const newHeight = roundCellSizeToStep(\n        event.initialSize + event.delta,\n        stepY\n      );\n      if (event.finished) {\n        setRowSize(rowIndex, newHeight);\n      } else {\n        overrideRowSize(rowIndex, newHeight);\n      }\n    },\n    [overrideRowSize, rowIndex, setRowSize, stepY]\n  );\n  const handleResizeLeft = React4.useCallback(\n    (event) => {\n      const initial = colSizesWithoutOverrides[colIndex];\n      const complement = (width) => initial + marginLeft - width;\n      const newMargin = roundCellSizeToStep(\n        resizeLengthClampStatic(marginLeft + event.delta, {\n          max: complement(minColumnWidth),\n          min: 0\n        }),\n        stepX\n      );\n      const newWidth = complement(newMargin);\n      if (event.finished) {\n        setMarginLeft(newMargin);\n        setColSize(colIndex, newWidth);\n      } else {\n        overrideMarginLeft(newMargin);\n        overrideColSize(colIndex, newWidth);\n      }\n    },\n    [\n      colIndex,\n      colSizesWithoutOverrides,\n      marginLeft,\n      minColumnWidth,\n      overrideColSize,\n      overrideMarginLeft,\n      setColSize,\n      setMarginLeft,\n      stepX\n    ]\n  );\n  const getHandleHoverProps = (colIndex2) => ({\n    onHover: () => {\n      if (hoveredColIndex === null) {\n        setHoveredColIndex(colIndex2);\n      }\n    },\n    onHoverEnd: () => {\n      if (hoveredColIndex === colIndex2) {\n        setHoveredColIndex(null);\n      }\n    }\n  });\n  const hasLeftHandle = colIndex === 0 && !disableMarginLeft;\n  return {\n    bottomProps: {\n      options: {\n        direction: \"bottom\",\n        onResize: handleResizeBottom\n      }\n    },\n    hiddenLeft: !hasLeftHandle,\n    leftProps: {\n      options: __spreadValues({\n        direction: \"left\",\n        onResize: handleResizeLeft\n      }, getHandleHoverProps(-1))\n    },\n    rightProps: {\n      options: __spreadValues({\n        direction: \"right\",\n        initialSize: initialWidth,\n        onResize: handleResizeRight\n      }, getHandleHoverProps(colIndex))\n    }\n  };\n};\n\n// src/react/components/TableCellElement/useTableCellElementState.ts\nimport React5 from \"react\";\nimport { useEditorRef as useEditorRef3, useElement as useElement2 } from \"@udecode/plate-common/react\";\nimport { useReadOnly } from \"slate-react\";\nvar useTableCellElementState = ({\n  ignoreReadOnly\n} = {}) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const editor = useEditorRef3();\n  const cellElement = useElement2();\n  const colSpan = getColSpan(cellElement);\n  const rowSpan = getRowSpan(cellElement);\n  const readOnly = useReadOnly();\n  const isCellSelected = useIsCellSelected(cellElement);\n  const hoveredColIndex = useTableStore().get.hoveredColIndex();\n  const selectedCells = useTableStore().get.selectedCells();\n  const tableElement = useElement2(TablePlugin.key);\n  const rowElement = useElement2(BaseTableRowPlugin.key);\n  const rowSizeOverrides = useTableStore().get.rowSizeOverrides();\n  const { _cellIndices, enableMerging } = editor.getOptions(TablePlugin);\n  if (!enableMerging) {\n    const colIndex2 = getTableColumnIndex(editor, cellElement);\n    const rowIndex2 = getTableRowIndex(editor, cellElement);\n    const rowSize2 = (_c = (_b = (_a = rowSizeOverrides.get) == null ? void 0 : _a.call(rowSizeOverrides, rowIndex2)) != null ? _b : rowElement == null ? void 0 : rowElement.size) != null ? _c : void 0;\n    const isFirstCell2 = colIndex2 === 0;\n    const isFirstRow2 = ((_d = tableElement.children) == null ? void 0 : _d[0]) === rowElement;\n    const borders2 = getTableCellBorders(cellElement, {\n      isFirstCell: isFirstCell2,\n      isFirstRow: isFirstRow2\n    });\n    return {\n      borders: borders2,\n      colIndex: colIndex2,\n      colSpan,\n      hovered: hoveredColIndex === colIndex2,\n      hoveredLeft: isFirstCell2 && hoveredColIndex === -1,\n      isSelectingCell: !!selectedCells,\n      readOnly: !ignoreReadOnly && readOnly,\n      rowIndex: rowIndex2,\n      rowSize: rowSize2,\n      selected: isCellSelected\n    };\n  }\n  let result;\n  const calculated = getCellIndices(_cellIndices, cellElement) || computeCellIndices(editor, tableElement, cellElement);\n  if (calculated) {\n    result = calculated;\n  } else {\n    const defaultColIndex = getTableColumnIndex(editor, cellElement);\n    const defaultRowIndex = getTableRowIndex(editor, cellElement);\n    result = { col: defaultColIndex, row: defaultRowIndex };\n  }\n  const colIndex = result.col;\n  const rowIndex = result.row;\n  const endingRowIndex = rowIndex + rowSpan - 1;\n  const endingColIndex = colIndex + colSpan - 1;\n  const rowSize = (_g = (_f = (_e = rowSizeOverrides.get) == null ? void 0 : _e.call(rowSizeOverrides, endingRowIndex)) != null ? _f : rowElement == null ? void 0 : rowElement.size) != null ? _g : void 0;\n  const isFirstCell = colIndex === 0;\n  const isFirstRow = ((_h = tableElement.children) == null ? void 0 : _h[0]) === rowElement;\n  const borders = getTableCellBorders(cellElement, {\n    isFirstCell,\n    isFirstRow\n  });\n  return {\n    borders,\n    colIndex: endingColIndex,\n    colSpan,\n    hovered: hoveredColIndex === endingColIndex,\n    hoveredLeft: isFirstCell && hoveredColIndex === -1,\n    isSelectingCell: !!selectedCells,\n    readOnly: !ignoreReadOnly && readOnly,\n    rowIndex: endingRowIndex,\n    rowSize,\n    selected: isCellSelected\n  };\n};\nvar useTableCellElement = ({\n  element\n}) => {\n  const setHoveredColIndex = useTableStore().set.hoveredColIndex();\n  React5.useEffect(() => {\n    setHoveredColIndex(null);\n  }, [element, setHoveredColIndex]);\n  return {\n    props: {\n      colSpan: getColSpan(element),\n      rowSpan: getRowSpan(element)\n    }\n  };\n};\n\n// src/react/components/TableElement/useSelectedCells.ts\nimport React6 from \"react\";\nimport { useEditorRef as useEditorRef4 } from \"@udecode/plate-common/react\";\nimport { useReadOnly as useReadOnly2, useSelected } from \"slate-react\";\nvar useSelectedCells = () => {\n  const readOnly = useReadOnly2();\n  const selected = useSelected();\n  const editor = useEditorRef4();\n  const [selectedCells, setSelectedCells] = useTableStore().use.selectedCells();\n  const setSelectedTable = useTableStore().set.selectedTable();\n  React6.useEffect(() => {\n    if (!selected || readOnly) {\n      setSelectedCells(null);\n      setSelectedTable(null);\n    }\n  }, [selected, editor, setSelectedCells, readOnly, setSelectedTable]);\n  React6.useEffect(() => {\n    if (readOnly) return;\n    const tableEntries = getTableGridAbove(editor, { format: \"table\" });\n    const cellEntries = getTableGridAbove(editor, { format: \"cell\" });\n    if ((cellEntries == null ? void 0 : cellEntries.length) > 1) {\n      const cells = cellEntries.map((entry) => entry[0]);\n      const tables = tableEntries.map((entry) => entry[0]);\n      if (JSON.stringify(cells) !== JSON.stringify(selectedCells)) {\n        setSelectedCells(cells);\n        setSelectedTable(tables);\n      }\n    } else if (selectedCells) {\n      setSelectedCells(null);\n      setSelectedTable(null);\n    }\n  }, [\n    editor,\n    editor.selection,\n    readOnly,\n    selectedCells,\n    setSelectedCells,\n    setSelectedTable\n  ]);\n};\n\n// src/react/components/TableElement/useTableElement.ts\nimport React7 from \"react\";\nimport { collapseSelection as collapseSelection3 } from \"@udecode/plate-common\";\nimport { useEditorRef as useEditorRef5, useElement as useElement3 } from \"@udecode/plate-common/react\";\nvar useTableElementState = ({\n  transformColSizes\n} = {}) => {\n  var _a;\n  const editor = useEditorRef5();\n  const { disableMarginLeft, enableMerging, minColumnWidth } = editor.getOptions(TablePlugin);\n  const element = useElement3();\n  const selectedCells = useTableStore().get.selectedCells();\n  const marginLeftOverride = useTableStore().get.marginLeftOverride();\n  const marginLeft = disableMarginLeft ? 0 : (_a = marginLeftOverride != null ? marginLeftOverride : element.marginLeft) != null ? _a : 0;\n  let colSizes = useTableColSizes(element);\n  React7.useEffect(() => {\n    if (enableMerging) {\n      computeCellIndices(editor, element);\n    }\n  }, [editor, element, enableMerging]);\n  if (transformColSizes) {\n    colSizes = transformColSizes(colSizes);\n  }\n  if (!colSizes.includes(0)) {\n    colSizes.push(\"100%\");\n  }\n  return {\n    colSizes,\n    isSelectingCell: !!selectedCells,\n    marginLeft,\n    minColumnWidth\n  };\n};\nvar useTableElement = () => {\n  const editor = useEditorRef5();\n  const selectedCells = useTableStore().get.selectedCells();\n  useSelectedCells();\n  return {\n    colGroupProps: {\n      contentEditable: false,\n      style: { width: \"100%\" }\n    },\n    props: {\n      onMouseDown: () => {\n        if (selectedCells) {\n          collapseSelection3(editor);\n        }\n      }\n    }\n  };\n};\n\n// src/react/hooks/useTableMergeState.ts\nimport { isSelectionExpanded } from \"@udecode/plate-common\";\nimport { useEditorRef as useEditorRef6, useEditorSelector as useEditorSelector2 } from \"@udecode/plate-common/react\";\nimport { useReadOnly as useReadOnly3, useSelected as useSelected2 } from \"slate-react\";\nvar useTableMergeState = () => {\n  const editor = useEditorRef6();\n  const { enableMerging } = editor.getOptions(TablePlugin);\n  if (!enableMerging) return { canMerge: false, canUnmerge: false };\n  const readOnly = useReadOnly3();\n  const selected = useSelected2();\n  const selectionExpanded = useEditorSelector2(isSelectionExpanded, []);\n  const collapsed = !readOnly && selected && !selectionExpanded;\n  const selectedTables = useTableStore().get.selectedTable();\n  const selectedTable = selectedTables == null ? void 0 : selectedTables[0];\n  const selectedCellEntries = useEditorSelector2(\n    (editor2) => getTableGridAbove(editor2, {\n      format: \"cell\"\n    }),\n    []\n  );\n  if (!selectedCellEntries) return { canMerge: false, canUnmerge: false };\n  const canMerge = !readOnly && selected && selectionExpanded && selectedCellEntries.length > 1 && isTableRectangular(selectedTable);\n  const canUnmerge = collapsed && selectedCellEntries.length === 1 && (getColSpan(selectedCellEntries[0][0]) > 1 || getRowSpan(selectedCellEntries[0][0]) > 1);\n  return { canMerge, canUnmerge };\n};\nexport {\n  TableCellHeaderPlugin,\n  TableCellPlugin,\n  TablePlugin,\n  TableProvider,\n  TableRowPlugin,\n  deleteColumn,\n  deleteColumnWhenExpanded,\n  deleteRow,\n  deleteRowWhenExpanded,\n  deleteTableMergeColumn,\n  deleteTableMergeRow,\n  getOnSelectTableBorderFactory,\n  getTableCellBorders,\n  getTableColumnIndex,\n  getTableGridAbove,\n  getTableGridByRange,\n  getTableMergeGridByRange,\n  getTableRowIndex,\n  insertTable,\n  mergeTableCells,\n  moveSelectionFromCell,\n  onKeyDownTable,\n  overrideSelectionFromCell,\n  preventDeleteTableCell,\n  roundCellSizeToStep,\n  tableStore,\n  unmergeTableCells,\n  useIsCellSelected,\n  useOverrideColSize,\n  useOverrideMarginLeft,\n  useOverrideRowSize,\n  useSelectedCells,\n  useTableBordersDropdownMenuContentState,\n  useTableCellElement,\n  useTableCellElementResizable,\n  useTableCellElementResizableState,\n  useTableCellElementState,\n  useTableColSizes,\n  useTableElement,\n  useTableElementState,\n  useTableMergeState,\n  useTableStore,\n  withDeleteTable,\n  withGetFragmentTable,\n  withInsertFragmentTable,\n  withInsertTextTable,\n  withMarkTable,\n  withSelectionTable,\n  withSetFragmentDataTable,\n  withTable2 as withTable\n};\n//# sourceMappingURL=index.mjs.map","\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prisms API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\t}\n\n\tvar LOADING_MESSAGE = 'Loading';\n\tvar FAILURE_MESSAGE = function (status, message) {\n\t\treturn ' Error ' + status + ' while fetching file: ' + message;\n\t};\n\tvar FAILURE_EMPTY_MESSAGE = ' Error: File does not exist or is empty';\n\n\tvar EXTENSIONS = {\n\t\t'js': 'javascript',\n\t\t'py': 'python',\n\t\t'rb': 'ruby',\n\t\t'ps1': 'powershell',\n\t\t'psm1': 'powershell',\n\t\t'sh': 'bash',\n\t\t'bat': 'batch',\n\t\t'h': 'c',\n\t\t'tex': 'latex'\n\t};\n\n\tvar STATUS_ATTR = 'data-src-status';\n\tvar STATUS_LOADING = 'loading';\n\tvar STATUS_LOADED = 'loaded';\n\tvar STATUS_FAILED = 'failed';\n\n\tvar SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])'\n\t\t+ ':not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n\n\t/**\n\t * Loads the given file.\n\t *\n\t * @param {string} src The URL or path of the source file to load.\n\t * @param {(result: string) => void} success\n\t * @param {(reason: string) => void} error\n\t */\n\tfunction loadFile(src, success, error) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open('GET', src, true);\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState == 4) {\n\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\tsuccess(xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.status >= 400) {\n\t\t\t\t\t\terror(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(FAILURE_EMPTY_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\t/**\n\t * Parses the given range.\n\t *\n\t * This returns a range with inclusive ends.\n\t *\n\t * @param {string | null | undefined} range\n\t * @returns {[number, number | undefined] | undefined}\n\t */\n\tfunction parseRange(range) {\n\t\tvar m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || '');\n\t\tif (m) {\n\t\t\tvar start = Number(m[1]);\n\t\t\tvar comma = m[2];\n\t\t\tvar end = m[3];\n\n\t\t\tif (!comma) {\n\t\t\t\treturn [start, start];\n\t\t\t}\n\t\t\tif (!end) {\n\t\t\t\treturn [start, undefined];\n\t\t\t}\n\t\t\treturn [start, Number(end)];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tPrism.hooks.add('before-highlightall', function (env) {\n\t\tenv.selector += ', ' + SELECTOR;\n\t});\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar pre = /** @type {HTMLPreElement} */ (env.element);\n\t\tif (pre.matches(SELECTOR)) {\n\t\t\tenv.code = ''; // fast-path the whole thing and go to complete\n\n\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n\n\t\t\t// add code element with loading message\n\t\t\tvar code = pre.appendChild(document.createElement('CODE'));\n\t\t\tcode.textContent = LOADING_MESSAGE;\n\n\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\tvar language = env.language;\n\t\t\tif (language === 'none') {\n\t\t\t\t// the language might be 'none' because there is no language set;\n\t\t\t\t// in this case, we want to use the extension as the language\n\t\t\t\tvar extension = (/\\.(\\w+)$/.exec(src) || [, 'none'])[1];\n\t\t\t\tlanguage = EXTENSIONS[extension] || extension;\n\t\t\t}\n\n\t\t\t// set language classes\n\t\t\tPrism.util.setLanguage(code, language);\n\t\t\tPrism.util.setLanguage(pre, language);\n\n\t\t\t// preload the language\n\t\t\tvar autoloader = Prism.plugins.autoloader;\n\t\t\tif (autoloader) {\n\t\t\t\tautoloader.loadLanguages(language);\n\t\t\t}\n\n\t\t\t// load file\n\t\t\tloadFile(\n\t\t\t\tsrc,\n\t\t\t\tfunction (text) {\n\t\t\t\t\t// mark as loaded\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n\n\t\t\t\t\t// handle data-range\n\t\t\t\t\tvar range = parseRange(pre.getAttribute('data-range'));\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tvar lines = text.split(/\\r\\n?|\\n/g);\n\n\t\t\t\t\t\t// the range is one-based and inclusive on both ends\n\t\t\t\t\t\tvar start = range[0];\n\t\t\t\t\t\tvar end = range[1] == null ? lines.length : range[1];\n\n\t\t\t\t\t\tif (start < 0) { start += lines.length; }\n\t\t\t\t\t\tstart = Math.max(0, Math.min(start - 1, lines.length));\n\t\t\t\t\t\tif (end < 0) { end += lines.length; }\n\t\t\t\t\t\tend = Math.max(0, Math.min(end, lines.length));\n\n\t\t\t\t\t\ttext = lines.slice(start, end).join('\\n');\n\n\t\t\t\t\t\t// add data-start for line numbers\n\t\t\t\t\t\tif (!pre.hasAttribute('data-start')) {\n\t\t\t\t\t\t\tpre.setAttribute('data-start', String(start + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// highlight code\n\t\t\t\t\tcode.textContent = text;\n\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\t// mark as failed\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n\n\t\t\t\t\tcode.textContent = error;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t});\n\n\tPrism.plugins.fileHighlight = {\n\t\t/**\n\t\t * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n\t\t *\n\t\t * Note: Elements which are already loaded or currently loading will not be touched by this method.\n\t\t *\n\t\t * @param {ParentNode} [container=document]\n\t\t */\n\t\thighlight: function highlight(container) {\n\t\t\tvar elements = (container || document).querySelectorAll(SELECTOR);\n\n\t\t\tfor (var i = 0, element; (element = elements[i++]);) {\n\t\t\t\tPrism.highlightElement(element);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar logged = false;\n\t/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */\n\tPrism.fileHighlight = function () {\n\t\tif (!logged) {\n\t\t\tconsole.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');\n\t\t\tlogged = true;\n\t\t}\n\t\tPrism.plugins.fileHighlight.highlight.apply(this, arguments);\n\t};\n\n}());\n","var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\n// src/lib/BaseCodeBlockPlugin.ts\nimport {\n  HtmlPlugin,\n  createSlatePlugin,\n  createTSlatePlugin,\n  someNode as someNode4\n} from \"@udecode/plate-common\";\n\n// src/lib/insertFragmentCodeBlock.ts\nimport {\n  getBlockAbove,\n  getNodeString\n} from \"@udecode/plate-common\";\nfunction extractCodeLinesFromCodeBlock(node) {\n  return node.children;\n}\nvar insertFragmentCodeBlock = (editor) => {\n  const { insertFragment } = editor;\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const codeLineType = editor.getType(BaseCodeLinePlugin);\n  function convertNodeToCodeLine(node) {\n    return {\n      children: [{ text: getNodeString(node) }],\n      type: codeLineType\n    };\n  }\n  return (fragment) => {\n    var _a;\n    const [blockAbove] = (_a = getBlockAbove(editor)) != null ? _a : [];\n    if (blockAbove && [codeBlockType, codeLineType].includes(blockAbove == null ? void 0 : blockAbove.type)) {\n      return insertFragment(\n        fragment.flatMap((node) => {\n          const element = node;\n          return element.type === codeBlockType ? extractCodeLinesFromCodeBlock(element) : convertNodeToCodeLine(element);\n        })\n      );\n    }\n    return insertFragment(fragment);\n  };\n};\n\n// src/lib/normalizers/normalizeCodeBlock.tsx\nimport {\n  getChildren,\n  isElement,\n  setNodes\n} from \"@udecode/plate-common\";\nvar normalizeCodeBlock = (editor) => {\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const codeLineType = editor.getType(BaseCodeLinePlugin);\n  const { normalizeNode } = editor;\n  return ([node, path]) => {\n    normalizeNode([node, path]);\n    if (!isElement(node)) {\n      return;\n    }\n    const isCodeBlockRoot = node.type === codeBlockType;\n    if (isCodeBlockRoot) {\n      const nonCodeLine = getChildren([node, path]).find(\n        ([child]) => child.type !== codeLineType\n      );\n      if (nonCodeLine) {\n        setNodes(\n          editor,\n          { type: codeLineType },\n          { at: nonCodeLine[1] }\n        );\n      }\n    }\n  };\n};\n\n// src/lib/queries/getCodeLineEntry.ts\nimport {\n  getAboveNode,\n  getParentNode,\n  isElement as isElement2,\n  someNode\n} from \"@udecode/plate-common\";\nvar getCodeLineEntry = (editor, { at = editor.selection } = {}) => {\n  if (at && someNode(editor, {\n    at,\n    match: { type: editor.getType(BaseCodeLinePlugin) }\n  })) {\n    const selectionParent = getParentNode(editor, at);\n    if (!selectionParent) return;\n    const [, parentPath] = selectionParent;\n    const codeLine = getAboveNode(editor, {\n      at,\n      match: { type: editor.getType(BaseCodeLinePlugin) }\n    }) || getParentNode(editor, parentPath);\n    if (!codeLine) return;\n    const [codeLineNode, codeLinePath] = codeLine;\n    if (isElement2(codeLineNode) && codeLineNode.type !== editor.getType(BaseCodeLinePlugin))\n      return;\n    const codeBlock = getParentNode(editor, codeLinePath);\n    if (!codeBlock) return;\n    return {\n      codeBlock,\n      codeLine\n    };\n  }\n};\n\n// src/lib/queries/getIndentDepth.ts\nimport { getEditorString } from \"@udecode/plate-common\";\nvar getIndentDepth = (editor, { codeLine }) => {\n  const [, codeLinePath] = codeLine;\n  const text = getEditorString(editor, codeLinePath);\n  return text.search(/\\S|$/);\n};\n\n// src/lib/queries/isCodeBlockEmpty.ts\nimport {\n  getChildren as getChildren2,\n  getNodeString as getNodeString2\n} from \"@udecode/plate-common\";\nvar isCodeBlockEmpty = (editor) => {\n  var _a;\n  const { codeBlock } = (_a = getCodeLineEntry(editor)) != null ? _a : {};\n  if (!codeBlock) return false;\n  const codeLines = Array.from(getChildren2(codeBlock));\n  if (codeLines.length === 0) return true;\n  if (codeLines.length > 1) return false;\n  const firstCodeLineNode = codeLines[0][0];\n  return !getNodeString2(firstCodeLineNode);\n};\n\n// src/lib/queries/isSelectionAtCodeBlockStart.ts\nimport {\n  isExpanded,\n  isStartPoint\n} from \"@udecode/plate-common\";\nvar isSelectionAtCodeBlockStart = (editor) => {\n  var _a;\n  const { selection } = editor;\n  if (!selection || isExpanded(selection)) return false;\n  const { codeBlock } = (_a = getCodeLineEntry(editor)) != null ? _a : {};\n  if (!codeBlock) return false;\n  return isStartPoint(editor, selection.anchor, codeBlock[1]);\n};\n\n// src/lib/transforms/deleteStartSpace.ts\nimport {\n  deleteText,\n  getEditorString as getEditorString2,\n  getPointAfter,\n  getRange,\n  getStartPoint\n} from \"@udecode/plate-common\";\nvar deleteStartSpace = (editor, { codeLine }) => {\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = getStartPoint(editor, codeLinePath);\n  const codeLineEnd = codeLineStart && getPointAfter(editor, codeLineStart);\n  const spaceRange = codeLineEnd && getRange(editor, codeLineStart, codeLineEnd);\n  const spaceText = getEditorString2(editor, spaceRange);\n  if (/\\s/.test(spaceText)) {\n    deleteText(editor, { at: spaceRange });\n    return true;\n  }\n  return false;\n};\n\n// src/lib/transforms/indentCodeLine.ts\nimport {\n  getEditorString as getEditorString3,\n  getRange as getRange2,\n  getStartPoint as getStartPoint2,\n  insertText,\n  isExpanded as isExpanded2\n} from \"@udecode/plate-common\";\nvar indentCodeLine = (editor, { codeLine, indentDepth = 2 }) => {\n  var _a;\n  const [, codeLinePath] = codeLine;\n  const codeLineStart = getStartPoint2(editor, codeLinePath);\n  const indent = \" \".repeat(indentDepth);\n  if (!isExpanded2(editor.selection)) {\n    const cursor = (_a = editor.selection) == null ? void 0 : _a.anchor;\n    const range = getRange2(editor, codeLineStart, cursor);\n    const text = getEditorString3(editor, range);\n    if (/\\S/.test(text)) {\n      insertText(editor, indent, { at: editor.selection });\n      return;\n    }\n  }\n  insertText(editor, indent, { at: codeLineStart });\n};\n\n// src/lib/transforms/insertCodeBlock.ts\nimport {\n  isExpanded as isExpanded3,\n  isSelectionAtBlockStart,\n  setElements,\n  someNode as someNode2,\n  wrapNodes\n} from \"@udecode/plate-common\";\nvar insertCodeBlock = (editor, insertNodesOptions = {}) => {\n  if (!editor.selection || isExpanded3(editor.selection)) return;\n  const matchCodeElements = (node) => node.type === editor.getType(BaseCodeBlockPlugin) || node.type === editor.getType(BaseCodeLinePlugin);\n  if (someNode2(editor, {\n    match: matchCodeElements\n  })) {\n    return;\n  }\n  if (!isSelectionAtBlockStart(editor)) {\n    editor.insertBreak();\n  }\n  setElements(\n    editor,\n    {\n      children: [{ text: \"\" }],\n      type: editor.getType(BaseCodeLinePlugin)\n    },\n    insertNodesOptions\n  );\n  wrapNodes(\n    editor,\n    {\n      children: [],\n      type: editor.getType(BaseCodeBlockPlugin)\n    },\n    insertNodesOptions\n  );\n};\n\n// src/lib/transforms/insertCodeLine.ts\nimport { insertElements } from \"@udecode/plate-common\";\nvar insertCodeLine = (editor, indentDepth = 0) => {\n  if (editor.selection) {\n    const indent = \" \".repeat(indentDepth);\n    insertElements(editor, {\n      children: [{ text: indent }],\n      type: editor.getType(BaseCodeLinePlugin)\n    });\n  }\n};\n\n// src/lib/transforms/insertEmptyCodeBlock.ts\nimport {\n  BaseParagraphPlugin,\n  insertElements as insertElements2,\n  isBlockAboveEmpty,\n  isExpanded as isExpanded4\n} from \"@udecode/plate-common\";\nvar insertEmptyCodeBlock = (editor, {\n  defaultType = editor.getType(BaseParagraphPlugin),\n  insertNodesOptions\n} = {}) => {\n  if (!editor.selection) return;\n  if (isExpanded4(editor.selection) || !isBlockAboveEmpty(editor)) {\n    insertElements2(\n      editor,\n      editor.api.create.block({ children: [{ text: \"\" }], type: defaultType }),\n      __spreadValues({\n        nextBlock: true,\n        select: true\n      }, insertNodesOptions)\n    );\n  }\n  insertCodeBlock(editor, insertNodesOptions);\n};\n\n// src/lib/transforms/outdentCodeLine.ts\nvar outdentCodeLine = (editor, { codeBlock, codeLine }) => {\n  const deleted = deleteStartSpace(editor, { codeBlock, codeLine });\n  deleted && deleteStartSpace(editor, { codeBlock, codeLine });\n};\n\n// src/lib/transforms/toggleCodeBlock.ts\nimport {\n  setElements as setElements3,\n  someNode as someNode3,\n  withoutNormalizing as withoutNormalizing2,\n  wrapNodes as wrapNodes2\n} from \"@udecode/plate-common\";\n\n// src/lib/transforms/unwrapCodeBlock.ts\nimport {\n  BaseParagraphPlugin as BaseParagraphPlugin2,\n  getChildren as getChildren3,\n  getNodeEntries,\n  setElements as setElements2,\n  unwrapNodes,\n  withoutNormalizing\n} from \"@udecode/plate-common\";\nvar unwrapCodeBlock = (editor) => {\n  if (!editor.selection) return;\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const defaultType = editor.getType(BaseParagraphPlugin2);\n  withoutNormalizing(editor, () => {\n    const codeBlockEntries = getNodeEntries(editor, {\n      at: editor.selection,\n      match: { type: codeBlockType }\n    });\n    const reversedCodeBlockEntries = Array.from(codeBlockEntries).reverse();\n    for (const codeBlockEntry of reversedCodeBlockEntries) {\n      const codeLineEntries = getChildren3(codeBlockEntry);\n      for (const [, path] of codeLineEntries) {\n        setElements2(editor, { type: defaultType }, { at: path });\n      }\n      unwrapNodes(editor, {\n        at: codeBlockEntry[1],\n        match: { type: codeBlockType },\n        split: true\n      });\n    }\n  });\n};\n\n// src/lib/transforms/toggleCodeBlock.ts\nvar toggleCodeBlock = (editor) => {\n  if (!editor.selection) return;\n  const codeBlockType = editor.getType(BaseCodeBlockPlugin);\n  const codeLineType = editor.getType(BaseCodeLinePlugin);\n  const isActive = someNode3(editor, {\n    match: { type: codeBlockType }\n  });\n  withoutNormalizing2(editor, () => {\n    unwrapCodeBlock(editor);\n    if (!isActive) {\n      setElements3(editor, {\n        type: codeLineType\n      });\n      const codeBlock = {\n        children: [],\n        type: codeBlockType\n      };\n      wrapNodes2(editor, codeBlock);\n    }\n  });\n};\n\n// src/lib/withCodeBlock.ts\nvar withCodeBlock = ({ editor }) => {\n  const { insertBreak } = editor;\n  const insertBreakCodeBlock = () => {\n    if (!editor.selection) return;\n    const res = getCodeLineEntry(editor, {});\n    if (!res) return;\n    const { codeBlock, codeLine } = res;\n    const indentDepth = getIndentDepth(editor, {\n      codeBlock,\n      codeLine\n    });\n    insertBreak();\n    indentCodeLine(editor, {\n      codeBlock,\n      codeLine,\n      indentDepth\n    });\n    return true;\n  };\n  editor.insertBreak = () => {\n    if (insertBreakCodeBlock()) return;\n    insertBreak();\n  };\n  editor.insertFragment = insertFragmentCodeBlock(editor);\n  editor.normalizeNode = normalizeCodeBlock(editor);\n  return editor;\n};\n\n// src/lib/decorateCodeLine.ts\nimport { getNodeString as getNodeString3, getParentNode as getParentNode2 } from \"@udecode/plate-common\";\nvar decorateCodeLine = ({\n  editor,\n  entry: [node, path],\n  type\n}) => {\n  var _a;\n  const codeBlockOptions = editor.getOptions(BaseCodeBlockPlugin);\n  const { prism: Prism } = codeBlockOptions;\n  if (!Prism) return [];\n  const { Token, languages, tokenize } = Prism;\n  const ranges = [];\n  if (!codeBlockOptions.syntax || node.type !== type) {\n    return ranges;\n  }\n  const codeBlock = getParentNode2(editor, path);\n  if (!codeBlock) {\n    return ranges;\n  }\n  let langName = (_a = codeBlock[0].lang) != null ? _a : \"\";\n  if (langName === \"plain\") {\n    langName = \"\";\n  }\n  const lang = languages[langName];\n  if (!lang) {\n    return ranges;\n  }\n  const text = getNodeString3(node);\n  const tokens = tokenize(text, lang);\n  let offset = 0;\n  for (const element of tokens) {\n    if (element instanceof Token) {\n      ranges.push({\n        [BaseCodeSyntaxPlugin.key]: true,\n        anchor: { offset, path },\n        focus: { offset: offset + element.length, path },\n        tokenType: element.type\n      });\n    }\n    offset += element.length;\n  }\n  return ranges;\n};\n\n// src/lib/htmlDeserializerCodeBlock.ts\nvar htmlDeserializerCodeBlock = {\n  parse: ({ element }) => {\n    var _a, _b;\n    const languageSelectorText = ((_a = [...element.childNodes].find(\n      (node) => node.nodeName === \"SELECT\"\n    )) == null ? void 0 : _a.textContent) || \"\";\n    const textContent = ((_b = element.textContent) == null ? void 0 : _b.replace(languageSelectorText, \"\")) || \"\";\n    let lines = textContent.split(\"\\n\");\n    if (!(lines == null ? void 0 : lines.length)) {\n      lines = [textContent];\n    }\n    const codeLines = lines.map((line) => ({\n      children: [{ text: line }],\n      type: BaseCodeLinePlugin.key\n    }));\n    return {\n      children: codeLines,\n      type: BaseCodeBlockPlugin.key\n    };\n  },\n  rules: [\n    {\n      validNodeName: \"PRE\"\n    },\n    {\n      validNodeName: \"P\",\n      validStyle: {\n        fontFamily: \"Consolas\"\n      }\n    }\n  ]\n};\n\n// src/lib/BaseCodeBlockPlugin.ts\nvar BaseCodeLinePlugin = createSlatePlugin({\n  key: \"code_line\",\n  decorate: decorateCodeLine,\n  node: { isElement: true }\n});\nvar BaseCodeSyntaxPlugin = createSlatePlugin({\n  key: \"code_syntax\",\n  node: { isLeaf: true }\n});\nvar BaseCodeBlockPlugin = createTSlatePlugin({\n  key: \"code_block\",\n  extendEditor: withCodeBlock,\n  inject: {\n    plugins: {\n      [HtmlPlugin.key]: {\n        parser: {\n          query: ({ editor }) => {\n            const codeLineType = editor.getType(BaseCodeLinePlugin);\n            return !someNode4(editor, {\n              match: { type: codeLineType }\n            });\n          }\n        }\n      }\n    }\n  },\n  node: { isElement: true },\n  options: {\n    syntax: true,\n    syntaxPopularFirst: false\n  },\n  parsers: { html: { deserializer: htmlDeserializerCodeBlock } },\n  plugins: [BaseCodeLinePlugin, BaseCodeSyntaxPlugin]\n});\nexport {\n  BaseCodeBlockPlugin,\n  BaseCodeLinePlugin,\n  BaseCodeSyntaxPlugin,\n  decorateCodeLine,\n  deleteStartSpace,\n  getCodeLineEntry,\n  getIndentDepth,\n  htmlDeserializerCodeBlock,\n  indentCodeLine,\n  insertCodeBlock,\n  insertCodeLine,\n  insertEmptyCodeBlock,\n  insertFragmentCodeBlock,\n  isCodeBlockEmpty,\n  isSelectionAtCodeBlockStart,\n  normalizeCodeBlock,\n  outdentCodeLine,\n  toggleCodeBlock,\n  unwrapCodeBlock,\n  withCodeBlock\n};\n//# sourceMappingURL=index.mjs.map","/**\n * Lexing or parsing positional information for error reporting.\n * This object is immutable.\n */\nclass SourceLocation {\n  // The + prefix indicates that these fields aren't writeable\n  // Lexer holding the input string.\n  // Start offset, zero-based inclusive.\n  // End offset, zero-based exclusive.\n  constructor(lexer, start, end) {\n    this.lexer = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.lexer = lexer;\n    this.start = start;\n    this.end = end;\n  }\n  /**\n   * Merges two `SourceLocation`s from location providers, given they are\n   * provided in order of appearance.\n   * - Returns the first one's location if only the first is provided.\n   * - Returns a merged range of the first and the last if both are provided\n   *   and their lexers match.\n   * - Otherwise, returns null.\n   */\n\n\n  static range(first, second) {\n    if (!second) {\n      return first && first.loc;\n    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {\n      return null;\n    } else {\n      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);\n    }\n  }\n\n}\n\n/**\n * Interface required to break circular dependency between Token, Lexer, and\n * ParseError.\n */\n\n/**\n * The resulting token returned from `lex`.\n *\n * It consists of the token text plus some position information.\n * The position information is essentially a range in an input string,\n * but instead of referencing the bare input string, we refer to the lexer.\n * That way it is possible to attach extra metadata to the input string,\n * like for example a file name or similar.\n *\n * The position information is optional, so it is OK to construct synthetic\n * tokens if appropriate. Not providing available position information may\n * lead to degraded error reporting, though.\n */\nclass Token {\n  // don't expand the token\n  // used in \\noexpand\n  constructor(text, // the text of this token\n  loc) {\n    this.text = void 0;\n    this.loc = void 0;\n    this.noexpand = void 0;\n    this.treatAsRelax = void 0;\n    this.text = text;\n    this.loc = loc;\n  }\n  /**\n   * Given a pair of tokens (this and endToken), compute a `Token` encompassing\n   * the whole input range enclosed by these two.\n   */\n\n\n  range(endToken, // last token of the range, inclusive\n  text // the text of the newly constructed token\n  ) {\n    return new Token(text, SourceLocation.range(this, endToken));\n  }\n\n}\n\n/**\n * This is the ParseError class, which is the main error thrown by KaTeX\n * functions when something has gone wrong. This is used to distinguish internal\n * errors from errors in the expression that the user provided.\n *\n * If possible, a caller should provide a Token or ParseNode with information\n * about where in the source string the problem occurred.\n */\nclass ParseError {\n  // Error start position based on passed-in Token or ParseNode.\n  // Length of affected text based on passed-in Token or ParseNode.\n  // The underlying error message without any context added.\n  constructor(message, // The error message\n  token // An object providing position information\n  ) {\n    this.name = void 0;\n    this.position = void 0;\n    this.length = void 0;\n    this.rawMessage = void 0;\n    var error = \"KaTeX parse error: \" + message;\n    var start;\n    var end;\n    var loc = token && token.loc;\n\n    if (loc && loc.start <= loc.end) {\n      // If we have the input and a position, make the error a bit fancier\n      // Get the input\n      var input = loc.lexer.input; // Prepend some information\n\n      start = loc.start;\n      end = loc.end;\n\n      if (start === input.length) {\n        error += \" at end of input: \";\n      } else {\n        error += \" at position \" + (start + 1) + \": \";\n      } // Underline token in question using combining underscores\n\n\n      var underlined = input.slice(start, end).replace(/[^]/g, \"$&\\u0332\"); // Extract some context from the input and add it to the error\n\n      var left;\n\n      if (start > 15) {\n        left = \"\" + input.slice(start - 15, start);\n      } else {\n        left = input.slice(0, start);\n      }\n\n      var right;\n\n      if (end + 15 < input.length) {\n        right = input.slice(end, end + 15) + \"\";\n      } else {\n        right = input.slice(end);\n      }\n\n      error += left + underlined + right;\n    } // Some hackery to make ParseError a prototype of Error\n    // See http://stackoverflow.com/a/8460753\n    // $FlowFixMe\n\n\n    var self = new Error(error);\n    self.name = \"ParseError\"; // $FlowFixMe\n\n    self.__proto__ = ParseError.prototype;\n    self.position = start;\n\n    if (start != null && end != null) {\n      self.length = end - start;\n    }\n\n    self.rawMessage = message;\n    return self;\n  }\n\n} // $FlowFixMe More hackery\n\n\nParseError.prototype.__proto__ = Error.prototype;\n\n/**\n * This file contains a list of utility functions which are useful in other\n * files.\n */\n\n/**\n * Return whether an element is contained in a list\n */\nvar contains = function contains(list, elem) {\n  return list.indexOf(elem) !== -1;\n};\n/**\n * Provide a default value if a setting is undefined\n * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.\n */\n\n\nvar deflt = function deflt(setting, defaultIfUndefined) {\n  return setting === undefined ? defaultIfUndefined : setting;\n}; // hyphenate and escape adapted from Facebook's React under Apache 2 license\n\n\nvar uppercase = /([A-Z])/g;\n\nvar hyphenate = function hyphenate(str) {\n  return str.replace(uppercase, \"-$1\").toLowerCase();\n};\n\nvar ESCAPE_LOOKUP = {\n  \"&\": \"&amp;\",\n  \">\": \"&gt;\",\n  \"<\": \"&lt;\",\n  \"\\\"\": \"&quot;\",\n  \"'\": \"&#x27;\"\n};\nvar ESCAPE_REGEX = /[&><\"']/g;\n/**\n * Escapes text to prevent scripting attacks.\n */\n\nfunction escape(text) {\n  return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\n\n\nvar getBaseElem = function getBaseElem(group) {\n  if (group.type === \"ordgroup\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"color\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"font\") {\n    return getBaseElem(group.body);\n  } else {\n    return group;\n  }\n};\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\n\n\nvar isCharacterBox = function isCharacterBox(group) {\n  var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters\n\n  return baseElem.type === \"mathord\" || baseElem.type === \"textord\" || baseElem.type === \"atom\";\n};\n\nvar assert = function assert(value) {\n  if (!value) {\n    throw new Error('Expected non-null, but got ' + String(value));\n  }\n\n  return value;\n};\n/**\n * Return the protocol of a URL, or \"_relative\" if the URL does not specify a\n * protocol (and thus is relative), or `null` if URL has invalid protocol\n * (so should be outright rejected).\n */\n\nvar protocolFromUrl = function protocolFromUrl(url) {\n  // Check for possible leading protocol.\n  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace\n  // (U+20) or C0 control (U+00-U+1F) characters.\n  // eslint-disable-next-line no-control-regex\n  var protocol = /^[\\x00-\\x20]*([^\\\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);\n\n  if (!protocol) {\n    return \"_relative\";\n  } // Reject weird colons\n\n\n  if (protocol[2] !== \":\") {\n    return null;\n  } // Reject invalid characters in scheme according to\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n\n\n  if (!/^[a-zA-Z][a-zA-Z0-9+\\-.]*$/.test(protocol[1])) {\n    return null;\n  } // Lowercase the protocol\n\n\n  return protocol[1].toLowerCase();\n};\nvar utils = {\n  contains,\n  deflt,\n  escape,\n  hyphenate,\n  getBaseElem,\n  isCharacterBox,\n  protocolFromUrl\n};\n\n/* eslint no-console:0 */\n// TODO: automatically generate documentation\n// TODO: check all properties on Settings exist\n// TODO: check the type of a property on Settings matches\nvar SETTINGS_SCHEMA = {\n  displayMode: {\n    type: \"boolean\",\n    description: \"Render math in display mode, which puts the math in \" + \"display style (so \\\\int and \\\\sum are large, for example), and \" + \"centers the math on the page on its own line.\",\n    cli: \"-d, --display-mode\"\n  },\n  output: {\n    type: {\n      enum: [\"htmlAndMathml\", \"html\", \"mathml\"]\n    },\n    description: \"Determines the markup language of the output.\",\n    cli: \"-F, --format <type>\"\n  },\n  leqno: {\n    type: \"boolean\",\n    description: \"Render display math in leqno style (left-justified tags).\"\n  },\n  fleqn: {\n    type: \"boolean\",\n    description: \"Render display math flush left.\"\n  },\n  throwOnError: {\n    type: \"boolean\",\n    default: true,\n    cli: \"-t, --no-throw-on-error\",\n    cliDescription: \"Render errors (in the color given by --error-color) ins\" + \"tead of throwing a ParseError exception when encountering an error.\"\n  },\n  errorColor: {\n    type: \"string\",\n    default: \"#cc0000\",\n    cli: \"-c, --error-color <color>\",\n    cliDescription: \"A color string given in the format 'rgb' or 'rrggbb' \" + \"(no #). This option determines the color of errors rendered by the \" + \"-t option.\",\n    cliProcessor: color => \"#\" + color\n  },\n  macros: {\n    type: \"object\",\n    cli: \"-m, --macro <def>\",\n    cliDescription: \"Define custom macro of the form '\\\\foo:expansion' (use \" + \"multiple -m arguments for multiple macros).\",\n    cliDefault: [],\n    cliProcessor: (def, defs) => {\n      defs.push(def);\n      return defs;\n    }\n  },\n  minRuleThickness: {\n    type: \"number\",\n    description: \"Specifies a minimum thickness, in ems, for fraction lines,\" + \" `\\\\sqrt` top lines, `{array}` vertical lines, `\\\\hline`, \" + \"`\\\\hdashline`, `\\\\underline`, `\\\\overline`, and the borders of \" + \"`\\\\fbox`, `\\\\boxed`, and `\\\\fcolorbox`.\",\n    processor: t => Math.max(0, t),\n    cli: \"--min-rule-thickness <size>\",\n    cliProcessor: parseFloat\n  },\n  colorIsTextColor: {\n    type: \"boolean\",\n    description: \"Makes \\\\color behave like LaTeX's 2-argument \\\\textcolor, \" + \"instead of LaTeX's one-argument \\\\color mode change.\",\n    cli: \"-b, --color-is-text-color\"\n  },\n  strict: {\n    type: [{\n      enum: [\"warn\", \"ignore\", \"error\"]\n    }, \"boolean\", \"function\"],\n    description: \"Turn on strict / LaTeX faithfulness mode, which throws an \" + \"error if the input uses features that are not supported by LaTeX.\",\n    cli: \"-S, --strict\",\n    cliDefault: false\n  },\n  trust: {\n    type: [\"boolean\", \"function\"],\n    description: \"Trust the input, enabling all HTML features such as \\\\url.\",\n    cli: \"-T, --trust\"\n  },\n  maxSize: {\n    type: \"number\",\n    default: Infinity,\n    description: \"If non-zero, all user-specified sizes, e.g. in \" + \"\\\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, \" + \"elements and spaces can be arbitrarily large\",\n    processor: s => Math.max(0, s),\n    cli: \"-s, --max-size <n>\",\n    cliProcessor: parseInt\n  },\n  maxExpand: {\n    type: \"number\",\n    default: 1000,\n    description: \"Limit the number of macro expansions to the specified \" + \"number, to prevent e.g. infinite macro loops. If set to Infinity, \" + \"the macro expander will try to fully expand as in LaTeX.\",\n    processor: n => Math.max(0, n),\n    cli: \"-e, --max-expand <n>\",\n    cliProcessor: n => n === \"Infinity\" ? Infinity : parseInt(n)\n  },\n  globalGroup: {\n    type: \"boolean\",\n    cli: false\n  }\n};\n\nfunction getDefaultValue(schema) {\n  if (schema.default) {\n    return schema.default;\n  }\n\n  var type = schema.type;\n  var defaultType = Array.isArray(type) ? type[0] : type;\n\n  if (typeof defaultType !== 'string') {\n    return defaultType.enum[0];\n  }\n\n  switch (defaultType) {\n    case 'boolean':\n      return false;\n\n    case 'string':\n      return '';\n\n    case 'number':\n      return 0;\n\n    case 'object':\n      return {};\n  }\n}\n/**\n * The main Settings object\n *\n * The current options stored are:\n *  - displayMode: Whether the expression should be typeset as inline math\n *                 (false, the default), meaning that the math starts in\n *                 \\textstyle and is placed in an inline-block); or as display\n *                 math (true), meaning that the math starts in \\displaystyle\n *                 and is placed in a block with vertical margin.\n */\n\n\nclass Settings {\n  constructor(options) {\n    this.displayMode = void 0;\n    this.output = void 0;\n    this.leqno = void 0;\n    this.fleqn = void 0;\n    this.throwOnError = void 0;\n    this.errorColor = void 0;\n    this.macros = void 0;\n    this.minRuleThickness = void 0;\n    this.colorIsTextColor = void 0;\n    this.strict = void 0;\n    this.trust = void 0;\n    this.maxSize = void 0;\n    this.maxExpand = void 0;\n    this.globalGroup = void 0;\n    // allow null options\n    options = options || {};\n\n    for (var prop in SETTINGS_SCHEMA) {\n      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {\n        // $FlowFixMe\n        var schema = SETTINGS_SCHEMA[prop]; // TODO: validate options\n        // $FlowFixMe\n\n        this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);\n      }\n    }\n  }\n  /**\n   * Report nonstrict (non-LaTeX-compatible) input.\n   * Can safely not be called if `this.strict` is false in JavaScript.\n   */\n\n\n  reportNonstrict(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      strict = strict(errorCode, errorMsg, token);\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return;\n    } else if (strict === true || strict === \"error\") {\n      throw new ParseError(\"LaTeX-incompatible input and strict mode is set to 'error': \" + (errorMsg + \" [\" + errorCode + \"]\"), token);\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n    }\n  }\n  /**\n   * Check whether to apply strict (LaTeX-adhering) behavior for unusual\n   * input (like `\\\\`).  Unlike `nonstrict`, will not throw an error;\n   * instead, \"error\" translates to a return value of `true`, while \"ignore\"\n   * translates to a return value of `false`.  May still print a warning:\n   * \"warn\" prints a warning and returns `false`.\n   * This is for the second category of `errorCode`s listed in the README.\n   */\n\n\n  useStrictBehavior(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      // But catch any exceptions thrown by function, treating them\n      // like \"error\".\n      try {\n        strict = strict(errorCode, errorMsg, token);\n      } catch (error) {\n        strict = \"error\";\n      }\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return false;\n    } else if (strict === true || strict === \"error\") {\n      return true;\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    }\n  }\n  /**\n   * Check whether to test potentially dangerous input, and return\n   * `true` (trusted) or `false` (untrusted).  The sole argument `context`\n   * should be an object with `command` field specifying the relevant LaTeX\n   * command (as a string starting with `\\`), and any other arguments, etc.\n   * If `context` has a `url` field, a `protocol` field will automatically\n   * get added by this function (changing the specified object).\n   */\n\n\n  isTrusted(context) {\n    if (context.url && !context.protocol) {\n      var protocol = utils.protocolFromUrl(context.url);\n\n      if (protocol == null) {\n        return false;\n      }\n\n      context.protocol = protocol;\n    }\n\n    var trust = typeof this.trust === \"function\" ? this.trust(context) : this.trust;\n    return Boolean(trust);\n  }\n\n}\n\n/**\n * This file contains information and classes for the various kinds of styles\n * used in TeX. It provides a generic `Style` class, which holds information\n * about a specific style. It then provides instances of all the different kinds\n * of styles possible, and provides functions to move between them and get\n * information about them.\n */\n\n/**\n * The main style class. Contains a unique id for the style, a size (which is\n * the same for cramped and uncramped version of a style), and a cramped flag.\n */\nclass Style {\n  constructor(id, size, cramped) {\n    this.id = void 0;\n    this.size = void 0;\n    this.cramped = void 0;\n    this.id = id;\n    this.size = size;\n    this.cramped = cramped;\n  }\n  /**\n   * Get the style of a superscript given a base in the current style.\n   */\n\n\n  sup() {\n    return styles[sup[this.id]];\n  }\n  /**\n   * Get the style of a subscript given a base in the current style.\n   */\n\n\n  sub() {\n    return styles[sub[this.id]];\n  }\n  /**\n   * Get the style of a fraction numerator given the fraction in the current\n   * style.\n   */\n\n\n  fracNum() {\n    return styles[fracNum[this.id]];\n  }\n  /**\n   * Get the style of a fraction denominator given the fraction in the current\n   * style.\n   */\n\n\n  fracDen() {\n    return styles[fracDen[this.id]];\n  }\n  /**\n   * Get the cramped version of a style (in particular, cramping a cramped style\n   * doesn't change the style).\n   */\n\n\n  cramp() {\n    return styles[cramp[this.id]];\n  }\n  /**\n   * Get a text or display version of this style.\n   */\n\n\n  text() {\n    return styles[text$1[this.id]];\n  }\n  /**\n   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)\n   */\n\n\n  isTight() {\n    return this.size >= 2;\n  }\n\n} // Export an interface for type checking, but don't expose the implementation.\n// This way, no more styles can be generated.\n\n\n// IDs of the different styles\nvar D = 0;\nvar Dc = 1;\nvar T = 2;\nvar Tc = 3;\nvar S = 4;\nvar Sc = 5;\nvar SS = 6;\nvar SSc = 7; // Instances of the different styles\n\nvar styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another\n\nvar sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];\nvar sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];\nvar fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];\nvar text$1 = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.\n\nvar Style$1 = {\n  DISPLAY: styles[D],\n  TEXT: styles[T],\n  SCRIPT: styles[S],\n  SCRIPTSCRIPT: styles[SS]\n};\n\n/*\n * This file defines the Unicode scripts and script families that we\n * support. To add new scripts or families, just add a new entry to the\n * scriptData array below. Adding scripts to the scriptData array allows\n * characters from that script to appear in \\text{} environments.\n */\n\n/**\n * Each script or script family has a name and an array of blocks.\n * Each block is an array of two numbers which specify the start and\n * end points (inclusive) of a block of Unicode codepoints.\n */\n\n/**\n * Unicode block data for the families of scripts we support in \\text{}.\n * Scripts only need to appear here if they do not have font metrics.\n */\nvar scriptData = [{\n  // Latin characters beyond the Latin-1 characters we have metrics for.\n  // Needed for Czech, Hungarian and Turkish text, for example.\n  name: 'latin',\n  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B\n  [0x0300, 0x036f] // Combining Diacritical marks\n  ]\n}, {\n  // The Cyrillic script used by Russian and related languages.\n  // A Cyrillic subset used to be supported as explicitly defined\n  // symbols in symbols.js\n  name: 'cyrillic',\n  blocks: [[0x0400, 0x04ff]]\n}, {\n  // Armenian\n  name: 'armenian',\n  blocks: [[0x0530, 0x058F]]\n}, {\n  // The Brahmic scripts of South and Southeast Asia\n  // Devanagari (0900097F)\n  // Bengali (098009FF)\n  // Gurmukhi (0A000A7F)\n  // Gujarati (0A800AFF)\n  // Oriya (0B000B7F)\n  // Tamil (0B800BFF)\n  // Telugu (0C000C7F)\n  // Kannada (0C800CFF)\n  // Malayalam (0D000D7F)\n  // Sinhala (0D800DFF)\n  // Thai (0E000E7F)\n  // Lao (0E800EFF)\n  // Tibetan (0F000FFF)\n  // Myanmar (1000109F)\n  name: 'brahmic',\n  blocks: [[0x0900, 0x109F]]\n}, {\n  name: 'georgian',\n  blocks: [[0x10A0, 0x10ff]]\n}, {\n  // Chinese and Japanese.\n  // The \"k\" in cjk is for Korean, but we've separated Korean out\n  name: \"cjk\",\n  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana\n  [0x4E00, 0x9FAF], // CJK ideograms\n  [0xFF00, 0xFF60] // Fullwidth punctuation\n  // TODO: add halfwidth Katakana and Romanji glyphs\n  ]\n}, {\n  // Korean\n  name: 'hangul',\n  blocks: [[0xAC00, 0xD7AF]]\n}];\n/**\n * Given a codepoint, return the name of the script or script family\n * it is from, or null if it is not part of a known block\n */\n\nfunction scriptFromCodepoint(codepoint) {\n  for (var i = 0; i < scriptData.length; i++) {\n    var script = scriptData[i];\n\n    for (var _i = 0; _i < script.blocks.length; _i++) {\n      var block = script.blocks[_i];\n\n      if (codepoint >= block[0] && codepoint <= block[1]) {\n        return script.name;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * A flattened version of all the supported blocks in a single array.\n * This is an optimization to make supportedCodepoint() fast.\n */\n\nvar allBlocks = [];\nscriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));\n/**\n * Given a codepoint, return true if it falls within one of the\n * scripts or script families defined above and false otherwise.\n *\n * Micro benchmarks shows that this is faster than\n * /[\\u3000-\\u30FF\\u4E00-\\u9FAF\\uFF00-\\uFF60\\uAC00-\\uD7AF\\u0900-\\u109F]/.test()\n * in Firefox, Chrome and Node.\n */\n\nfunction supportedCodepoint(codepoint) {\n  for (var i = 0; i < allBlocks.length; i += 2) {\n    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * This file provides support to domTree.js and delimiter.js.\n * It's a storehouse of path geometry for SVG images.\n */\n// In all paths below, the viewBox-to-em scale is 1000:1.\nvar hLinePad = 80; // padding above a sqrt vinculum. Prevents image cropping.\n// The vinculum of a \\sqrt can be made thicker by a KaTeX rendering option.\n// Think of variable extraVinculum as two detours in the SVG path.\n// The detour begins at the lower left of the area labeled extraVinculum below.\n// The detour proceeds one extraVinculum distance up and slightly to the right,\n// displacing the radiused corner between surd and vinculum. The radius is\n// traversed as usual, then the detour resumes. It goes right, to the end of\n// the very long vinculum, then down one extraVinculum distance,\n// after which it resumes regular path geometry for the radical.\n\n/*                                                  vinculum\n                                                   /\n         /extraVinculum\n        / 0.04em (40 unit) std vinculum thickness\n       / /\n      / /\n     / /\\\n    / / surd\n*/\n\nvar sqrtMain = function sqrtMain(extraVinculum, hLinePad) {\n  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main\n  return \"M95,\" + (622 + extraVinculum + hLinePad) + \"\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl\" + extraVinculum / 2.075 + \" -\" + extraVinculum + \"\\nc5.3,-9.3,12,-14,20,-14\\nH400000v\" + (40 + extraVinculum) + \"H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM\" + (834 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize1 = function sqrtSize1(extraVinculum, hLinePad) {\n  // size1 is from glyph U221A in the font KaTeX_Size1-Regular\n  return \"M263,\" + (601 + extraVinculum + hLinePad) + \"c0.7,0,18,39.7,52,119\\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\\nc340,-704.7,510.7,-1060.3,512,-1067\\nl\" + extraVinculum / 2.084 + \" -\" + extraVinculum + \"\\nc4.7,-7.3,11,-11,19,-11\\nH40000v\" + (40 + extraVinculum) + \"H1012.3\\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\\nM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize2 = function sqrtSize2(extraVinculum, hLinePad) {\n  // size2 is from glyph U221A in the font KaTeX_Size2-Regular\n  return \"M983 \" + (10 + extraVinculum + hLinePad) + \"\\nl\" + extraVinculum / 3.13 + \" -\" + extraVinculum + \"\\nc4,-6.7,10,-10,18,-10 H400000v\" + (40 + extraVinculum) + \"\\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\\nM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize3 = function sqrtSize3(extraVinculum, hLinePad) {\n  // size3 is from glyph U221A in the font KaTeX_Size3-Regular\n  return \"M424,\" + (2398 + extraVinculum + hLinePad) + \"\\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\\nl\" + extraVinculum / 4.223 + \" -\" + extraVinculum + \"c4,-6.7,10,-10,18,-10 H400000\\nv\" + (40 + extraVinculum) + \"H1014.6\\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\\nc-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2z M\" + (1001 + extraVinculum) + \" \" + hLinePad + \"\\nh400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize4 = function sqrtSize4(extraVinculum, hLinePad) {\n  // size4 is from glyph U221A in the font KaTeX_Size4-Regular\n  return \"M473,\" + (2713 + extraVinculum + hLinePad) + \"\\nc339.3,-1799.3,509.3,-2700,510,-2702 l\" + extraVinculum / 5.298 + \" -\" + extraVinculum + \"\\nc3.3,-7.3,9.3,-11,18,-11 H400000v\" + (40 + extraVinculum) + \"H1017.7\\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\\n606zM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"H1017.7z\";\n};\n\nvar phasePath = function phasePath(y) {\n  var x = y / 2; // x coordinate at top of angle\n\n  return \"M400000 \" + y + \" H0 L\" + x + \" 0 l65 45 L145 \" + (y - 80) + \" H400000z\";\n};\n\nvar sqrtTall = function sqrtTall(extraVinculum, hLinePad, viewBoxHeight) {\n  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular\n  // One path edge has a variable length. It runs vertically from the vinculum\n  // to a point near (14 units) the bottom of the surd. The vinculum\n  // is normally 40 units thick. So the length of the line in question is:\n  var vertSegment = viewBoxHeight - 54 - hLinePad - extraVinculum;\n  return \"M702 \" + (extraVinculum + hLinePad) + \"H400000\" + (40 + extraVinculum) + \"\\nH742v\" + vertSegment + \"l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\\n219 661 l218 661zM702 \" + hLinePad + \"H400000v\" + (40 + extraVinculum) + \"H742z\";\n};\n\nvar sqrtPath = function sqrtPath(size, extraVinculum, viewBoxHeight) {\n  extraVinculum = 1000 * extraVinculum; // Convert from document ems to viewBox.\n\n  var path = \"\";\n\n  switch (size) {\n    case \"sqrtMain\":\n      path = sqrtMain(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize1\":\n      path = sqrtSize1(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize2\":\n      path = sqrtSize2(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize3\":\n      path = sqrtSize3(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize4\":\n      path = sqrtSize4(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtTall\":\n      path = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);\n  }\n\n  return path;\n};\nvar innerPath = function innerPath(name, height) {\n  // The inner part of stretchy tall delimiters\n  switch (name) {\n    case \"\\u239c\":\n      return \"M291 0 H417 V\" + height + \" H291z M291 0 H417 V\" + height + \" H291z\";\n\n    case \"\\u2223\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\";\n\n    case \"\\u2225\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\" + (\"M367 0 H410 V\" + height + \" H367z M367 0 H410 V\" + height + \" H367z\");\n\n    case \"\\u239f\":\n      return \"M457 0 H583 V\" + height + \" H457z M457 0 H583 V\" + height + \" H457z\";\n\n    case \"\\u23a2\":\n      return \"M319 0 H403 V\" + height + \" H319z M319 0 H403 V\" + height + \" H319z\";\n\n    case \"\\u23a5\":\n      return \"M263 0 H347 V\" + height + \" H263z M263 0 H347 V\" + height + \" H263z\";\n\n    case \"\\u23aa\":\n      return \"M384 0 H504 V\" + height + \" H384z M384 0 H504 V\" + height + \" H384z\";\n\n    case \"\\u23d0\":\n      return \"M312 0 H355 V\" + height + \" H312z M312 0 H355 V\" + height + \" H312z\";\n\n    case \"\\u2016\":\n      return \"M257 0 H300 V\" + height + \" H257z M257 0 H300 V\" + height + \" H257z\" + (\"M478 0 H521 V\" + height + \" H478z M478 0 H521 V\" + height + \" H478z\");\n\n    default:\n      return \"\";\n  }\n};\nvar path = {\n  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main\n  doubleleftarrow: \"M262 157\\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\\nm8 0v40h399730v-40zm0 194v40h399730v-40z\",\n  // doublerightarrow is from glyph U+21D2 in font KaTeX Main\n  doublerightarrow: \"M399738 392l\\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z\",\n  // leftarrow is from glyph U+2190 in font KaTeX Main\n  leftarrow: \"M400000 241H110l3-3c68.7-52.7 113.7-120\\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\\n l-3-3h399890zM100 241v40h399900v-40z\",\n  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular\n  leftbrace: \"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z\",\n  leftbraceunder: \"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z\",\n  // overgroup is from the MnSymbol package (public domain)\n  leftgroup: \"M400000 80\\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\\n 435 0h399565z\",\n  leftgroupunder: \"M400000 262\\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\\n 435 219h399565z\",\n  // Harpoons are from glyph U+21BD in font KaTeX Main\n  leftharpoon: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z\",\n  leftharpoonplus: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\\nm0 0v40h400000v-40z\",\n  leftharpoondown: \"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z\",\n  leftharpoondownplus: \"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z\",\n  // hook is from glyph U+21A9 in font KaTeX Main\n  lefthook: \"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\\n 71.5 23h399859zM103 281v-40h399897v40z\",\n  leftlinesegment: \"M40 281 V428 H0 V94 H40 V241 H400000 v40z\\nM40 281 V428 H0 V94 H40 V241 H400000 v40z\",\n  leftmapsto: \"M40 281 V448H0V74H40V241H400000v40z\\nM40 281 V448H0V74H40V241H400000v40z\",\n  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular\n  leftToFrom: \"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z\",\n  longequal: \"M0 50 h400000 v40H0z m0 194h40000v40H0z\\nM0 50 h400000 v40H0z m0 194h40000v40H0z\",\n  midbrace: \"M200428 334\\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z\",\n  midbraceunder: \"M199572 214\\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z\",\n  oiintSize1: \"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z\",\n  oiintSize2: \"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\\nc0 110 84 276 504 276s502.4-166 502.4-276z\",\n  oiiintSize1: \"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z\",\n  oiiintSize2: \"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z\",\n  rightarrow: \"M0 241v40h399891c-47.3 35.3-84 78-110 128\\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n 151.7 139 205zm0 0v40h399900v-40z\",\n  rightbrace: \"M400000 542l\\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z\",\n  rightbraceunder: \"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z\",\n  rightgroup: \"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\\n 3-1 3-3v-38c-76-158-257-219-435-219H0z\",\n  rightgroupunder: \"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z\",\n  rightharpoon: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\\n 69.2 92 94.5zm0 0v40h399900v-40z\",\n  rightharpoonplus: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z\",\n  rightharpoondown: \"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z\",\n  rightharpoondownplus: \"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\\nm0-194v40h400000v-40zm0 0v40h400000v-40z\",\n  righthook: \"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z\",\n  rightlinesegment: \"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z\",\n  rightToFrom: \"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z\",\n  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular\n  twoheadleftarrow: \"M0 167c68 40\\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z\",\n  twoheadrightarrow: \"M400000 167\\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z\",\n  // tilde1 is a modified version of a glyph from the MnSymbol package\n  tilde1: \"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\\n-68.267.847-113-73.952-191-73.952z\",\n  // ditto tilde2, tilde3, & tilde4\n  tilde2: \"M344 55.266c-142 0-300.638 81.316-311.5 86.418\\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z\",\n  tilde3: \"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\\n -338 0-409-156.573-744-156.573z\",\n  tilde4: \"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\\n -175.236-744-175.236z\",\n  // vec is from glyph U+20D7 in font KaTeX Main\n  vec: \"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\\nc-16-25.333-24-45-24-59z\",\n  // widehat1 is a modified version of a glyph from the MnSymbol package\n  widehat1: \"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\",\n  // ditto widehat2, widehat3, & widehat4\n  widehat2: \"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat3: \"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat4: \"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  // widecheck paths are all inverted versions of widehat\n  widecheck1: \"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z\",\n  widecheck2: \"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck3: \"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck4: \"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  // The next ten paths support reaction arrows from the mhchem package.\n  // Arrows for \\ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX\n  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main\n  baraboveleftarrow: \"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z\",\n  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main\n  rightarrowabovebar: \"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z\",\n  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.\n  // Ref from mhchem.sty: \\rlap{\\raisebox{-.22ex}{$\\kern0.5em\n  baraboveshortleftharpoon: \"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z\",\n  rightharpoonaboveshortbar: \"M0,241 l0,40c399126,0,399993,0,399993,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z\",\n  shortbaraboveleftharpoon: \"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z\",\n  shortrightharpoonabovebar: \"M53,241l0,40c398570,0,399437,0,399437,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z\"\n};\nvar tallDelim = function tallDelim(label, midHeight) {\n  switch (label) {\n    case \"lbrack\":\n      return \"M403 1759 V84 H666 V0 H319 V1759 v\" + midHeight + \" v1759 h347 v-84\\nH403z M403 1759 V0 H319 V1759 v\" + midHeight + \" v1759 h84z\";\n\n    case \"rbrack\":\n      return \"M347 1759 V0 H0 V84 H263 V1759 v\" + midHeight + \" v1759 H0 v84 H347z\\nM347 1759 V0 H263 V1759 v\" + midHeight + \" v1759 h84z\";\n\n    case \"vert\":\n      return \"M145 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v\" + midHeight + \" v585 h43z\";\n\n    case \"doublevert\":\n      return \"M145 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v\" + midHeight + \" v585 h43z\\nM367 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v\" + midHeight + \" v585 h43z\";\n\n    case \"lfloor\":\n      return \"M319 602 V0 H403 V602 v\" + midHeight + \" v1715 h263 v84 H319z\\nMM319 602 V0 H403 V602 v\" + midHeight + \" v1715 H319z\";\n\n    case \"rfloor\":\n      return \"M319 602 V0 H403 V602 v\" + midHeight + \" v1799 H0 v-84 H319z\\nMM319 602 V0 H403 V602 v\" + midHeight + \" v1715 H319z\";\n\n    case \"lceil\":\n      return \"M403 1759 V84 H666 V0 H319 V1759 v\" + midHeight + \" v602 h84z\\nM403 1759 V0 H319 V1759 v\" + midHeight + \" v602 h84z\";\n\n    case \"rceil\":\n      return \"M347 1759 V0 H0 V84 H263 V1759 v\" + midHeight + \" v602 h84z\\nM347 1759 V0 h-84 V1759 v\" + midHeight + \" v602 h84z\";\n\n    case \"lparen\":\n      return \"M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\\n-36,557 l0,\" + (midHeight + 84) + \"c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\\nl0,-\" + (midHeight + 92) + \"c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z\";\n\n    case \"rparen\":\n      return \"M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,\" + (midHeight + 9) + \"\\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\\nl0,-\" + (midHeight + 144) + \"c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z\";\n\n    default:\n      // We should not ever get here.\n      throw new Error(\"Unknown stretchy delimiter.\");\n  }\n};\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. It only contains\n * children and doesn't have any DOM node properties.\n */\nclass DocumentFragment {\n  // HtmlDomNode\n  // Never used; needed for satisfying interface.\n  constructor(children) {\n    this.children = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.children = children;\n    this.classes = [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = {};\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /** Convert the fragment into a node. */\n\n\n  toNode() {\n    var frag = document.createDocumentFragment();\n\n    for (var i = 0; i < this.children.length; i++) {\n      frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n  }\n  /** Convert the fragment into HTML markup. */\n\n\n  toMarkup() {\n    var markup = \"\"; // Simply concatenate the markup for the children together.\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText. Applies to\n   * MathDomNode's only.\n   */\n\n\n  toText() {\n    // To avoid this, we would subclass documentFragment separately for\n    // MathML, but polyfills for subclassing is expensive per PR 1469.\n    // $FlowFixMe: Only works for ChildType = MathDomNode.\n    var toText = child => child.toText();\n\n    return this.children.map(toText).join(\"\");\n  }\n\n}\n\n// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.\nvar fontMetricsData = {\n  \"AMS-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68889, 0, 0, 0.72222],\n    \"66\": [0, 0.68889, 0, 0, 0.66667],\n    \"67\": [0, 0.68889, 0, 0, 0.72222],\n    \"68\": [0, 0.68889, 0, 0, 0.72222],\n    \"69\": [0, 0.68889, 0, 0, 0.66667],\n    \"70\": [0, 0.68889, 0, 0, 0.61111],\n    \"71\": [0, 0.68889, 0, 0, 0.77778],\n    \"72\": [0, 0.68889, 0, 0, 0.77778],\n    \"73\": [0, 0.68889, 0, 0, 0.38889],\n    \"74\": [0.16667, 0.68889, 0, 0, 0.5],\n    \"75\": [0, 0.68889, 0, 0, 0.77778],\n    \"76\": [0, 0.68889, 0, 0, 0.66667],\n    \"77\": [0, 0.68889, 0, 0, 0.94445],\n    \"78\": [0, 0.68889, 0, 0, 0.72222],\n    \"79\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"80\": [0, 0.68889, 0, 0, 0.61111],\n    \"81\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"82\": [0, 0.68889, 0, 0, 0.72222],\n    \"83\": [0, 0.68889, 0, 0, 0.55556],\n    \"84\": [0, 0.68889, 0, 0, 0.66667],\n    \"85\": [0, 0.68889, 0, 0, 0.72222],\n    \"86\": [0, 0.68889, 0, 0, 0.72222],\n    \"87\": [0, 0.68889, 0, 0, 1.0],\n    \"88\": [0, 0.68889, 0, 0, 0.72222],\n    \"89\": [0, 0.68889, 0, 0, 0.72222],\n    \"90\": [0, 0.68889, 0, 0, 0.66667],\n    \"107\": [0, 0.68889, 0, 0, 0.55556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"165\": [0, 0.675, 0.025, 0, 0.75],\n    \"174\": [0.15559, 0.69224, 0, 0, 0.94666],\n    \"240\": [0, 0.68889, 0, 0, 0.55556],\n    \"295\": [0, 0.68889, 0, 0, 0.54028],\n    \"710\": [0, 0.825, 0, 0, 2.33334],\n    \"732\": [0, 0.9, 0, 0, 2.33334],\n    \"770\": [0, 0.825, 0, 0, 2.33334],\n    \"771\": [0, 0.9, 0, 0, 2.33334],\n    \"989\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"1008\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"8245\": [0, 0.54986, 0, 0, 0.275],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8487\": [0, 0.68889, 0, 0, 0.72222],\n    \"8498\": [0, 0.68889, 0, 0, 0.55556],\n    \"8502\": [0, 0.68889, 0, 0, 0.66667],\n    \"8503\": [0, 0.68889, 0, 0, 0.44445],\n    \"8504\": [0, 0.68889, 0, 0, 0.66667],\n    \"8513\": [0, 0.68889, 0, 0, 0.63889],\n    \"8592\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8594\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8602\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8603\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8606\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8608\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8610\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8611\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8619\": [0, 0.54986, 0, 0, 1.0],\n    \"8620\": [0, 0.54986, 0, 0, 1.0],\n    \"8621\": [-0.13313, 0.37788, 0, 0, 1.38889],\n    \"8622\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8624\": [0, 0.69224, 0, 0, 0.5],\n    \"8625\": [0, 0.69224, 0, 0, 0.5],\n    \"8630\": [0, 0.43056, 0, 0, 1.0],\n    \"8631\": [0, 0.43056, 0, 0, 1.0],\n    \"8634\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8635\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8638\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8639\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8642\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8643\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8644\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8646\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8647\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8648\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8649\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8650\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8651\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8652\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8653\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8654\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8655\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8666\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8667\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8669\": [-0.13313, 0.37788, 0, 0, 1.0],\n    \"8672\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8674\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8705\": [0, 0.825, 0, 0, 0.5],\n    \"8708\": [0, 0.68889, 0, 0, 0.55556],\n    \"8709\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8717\": [0, 0.43056, 0, 0, 0.42917],\n    \"8722\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8724\": [0.08198, 0.69224, 0, 0, 0.77778],\n    \"8726\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8733\": [0, 0.69224, 0, 0, 0.77778],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8737\": [0, 0.69224, 0, 0, 0.72222],\n    \"8738\": [0.03517, 0.52239, 0, 0, 0.72222],\n    \"8739\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"8740\": [0.25142, 0.74111, 0, 0, 0.27778],\n    \"8741\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"8742\": [0.25142, 0.74111, 0, 0, 0.5],\n    \"8756\": [0, 0.69224, 0, 0, 0.66667],\n    \"8757\": [0, 0.69224, 0, 0, 0.66667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8765\": [-0.13313, 0.37788, 0, 0, 0.77778],\n    \"8769\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8770\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8774\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8778\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8782\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8783\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8785\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8786\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8787\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8790\": [0, 0.69224, 0, 0, 0.77778],\n    \"8791\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8796\": [0.08198, 0.91667, 0, 0, 0.77778],\n    \"8806\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8807\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8808\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8809\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8812\": [0.25583, 0.75583, 0, 0, 0.5],\n    \"8814\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8815\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8816\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8817\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8818\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8819\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8822\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8823\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8828\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8829\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8830\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8831\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8832\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8833\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8840\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8841\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8842\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8843\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8847\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8848\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8858\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8859\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8861\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8862\": [0, 0.675, 0, 0, 0.77778],\n    \"8863\": [0, 0.675, 0, 0, 0.77778],\n    \"8864\": [0, 0.675, 0, 0, 0.77778],\n    \"8865\": [0, 0.675, 0, 0, 0.77778],\n    \"8872\": [0, 0.69224, 0, 0, 0.61111],\n    \"8873\": [0, 0.69224, 0, 0, 0.72222],\n    \"8874\": [0, 0.69224, 0, 0, 0.88889],\n    \"8876\": [0, 0.68889, 0, 0, 0.61111],\n    \"8877\": [0, 0.68889, 0, 0, 0.61111],\n    \"8878\": [0, 0.68889, 0, 0, 0.72222],\n    \"8879\": [0, 0.68889, 0, 0, 0.72222],\n    \"8882\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8883\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8884\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8885\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8888\": [0, 0.54986, 0, 0, 1.11111],\n    \"8890\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"8891\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8892\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8901\": [0, 0.54986, 0, 0, 0.27778],\n    \"8903\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8905\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8906\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8907\": [0, 0.69224, 0, 0, 0.77778],\n    \"8908\": [0, 0.69224, 0, 0, 0.77778],\n    \"8909\": [-0.03598, 0.46402, 0, 0, 0.77778],\n    \"8910\": [0, 0.54986, 0, 0, 0.76042],\n    \"8911\": [0, 0.54986, 0, 0, 0.76042],\n    \"8912\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8913\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8914\": [0, 0.54986, 0, 0, 0.66667],\n    \"8915\": [0, 0.54986, 0, 0, 0.66667],\n    \"8916\": [0, 0.69224, 0, 0, 0.66667],\n    \"8918\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8919\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8920\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8921\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8922\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8923\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8926\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8927\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8928\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8929\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8934\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8935\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8936\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8937\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8938\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8939\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8940\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8941\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8994\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"8995\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"9416\": [0.15559, 0.69224, 0, 0, 0.90222],\n    \"9484\": [0, 0.69224, 0, 0, 0.5],\n    \"9488\": [0, 0.69224, 0, 0, 0.5],\n    \"9492\": [0, 0.37788, 0, 0, 0.5],\n    \"9496\": [0, 0.37788, 0, 0, 0.5],\n    \"9585\": [0.19444, 0.68889, 0, 0, 0.88889],\n    \"9586\": [0.19444, 0.74111, 0, 0, 0.88889],\n    \"9632\": [0, 0.675, 0, 0, 0.77778],\n    \"9633\": [0, 0.675, 0, 0, 0.77778],\n    \"9650\": [0, 0.54986, 0, 0, 0.72222],\n    \"9651\": [0, 0.54986, 0, 0, 0.72222],\n    \"9654\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9660\": [0, 0.54986, 0, 0, 0.72222],\n    \"9661\": [0, 0.54986, 0, 0, 0.72222],\n    \"9664\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9674\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"9733\": [0.19444, 0.69224, 0, 0, 0.94445],\n    \"10003\": [0, 0.69224, 0, 0, 0.83334],\n    \"10016\": [0, 0.69224, 0, 0, 0.83334],\n    \"10731\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"10846\": [0.19444, 0.75583, 0, 0, 0.61111],\n    \"10877\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10878\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10885\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10886\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10887\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10888\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10889\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10890\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10891\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10892\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10901\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10902\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10933\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10934\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10935\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10936\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10937\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10938\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10949\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10950\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10955\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"10956\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"57350\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"57351\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"57352\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"57353\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"57356\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57357\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57358\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57359\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57360\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57361\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57366\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57367\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57368\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57369\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57370\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57371\": [0.13597, 0.63597, 0, 0, 0.77778]\n  },\n  \"Caligraphic-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68333, 0, 0.19445, 0.79847],\n    \"66\": [0, 0.68333, 0.03041, 0.13889, 0.65681],\n    \"67\": [0, 0.68333, 0.05834, 0.13889, 0.52653],\n    \"68\": [0, 0.68333, 0.02778, 0.08334, 0.77139],\n    \"69\": [0, 0.68333, 0.08944, 0.11111, 0.52778],\n    \"70\": [0, 0.68333, 0.09931, 0.11111, 0.71875],\n    \"71\": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],\n    \"72\": [0, 0.68333, 0.00965, 0.11111, 0.84452],\n    \"73\": [0, 0.68333, 0.07382, 0, 0.54452],\n    \"74\": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],\n    \"75\": [0, 0.68333, 0.01445, 0.05556, 0.76195],\n    \"76\": [0, 0.68333, 0, 0.13889, 0.68972],\n    \"77\": [0, 0.68333, 0, 0.13889, 1.2009],\n    \"78\": [0, 0.68333, 0.14736, 0.08334, 0.82049],\n    \"79\": [0, 0.68333, 0.02778, 0.11111, 0.79611],\n    \"80\": [0, 0.68333, 0.08222, 0.08334, 0.69556],\n    \"81\": [0.09722, 0.68333, 0, 0.11111, 0.81667],\n    \"82\": [0, 0.68333, 0, 0.08334, 0.8475],\n    \"83\": [0, 0.68333, 0.075, 0.13889, 0.60556],\n    \"84\": [0, 0.68333, 0.25417, 0, 0.54464],\n    \"85\": [0, 0.68333, 0.09931, 0.08334, 0.62583],\n    \"86\": [0, 0.68333, 0.08222, 0, 0.61278],\n    \"87\": [0, 0.68333, 0.08222, 0.08334, 0.98778],\n    \"88\": [0, 0.68333, 0.14643, 0.13889, 0.7133],\n    \"89\": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],\n    \"90\": [0, 0.68333, 0.07944, 0.13889, 0.72473],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Fraktur-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69141, 0, 0, 0.29574],\n    \"34\": [0, 0.69141, 0, 0, 0.21471],\n    \"38\": [0, 0.69141, 0, 0, 0.73786],\n    \"39\": [0, 0.69141, 0, 0, 0.21201],\n    \"40\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"41\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"42\": [0, 0.62119, 0, 0, 0.27764],\n    \"43\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"44\": [0, 0.10803, 0, 0, 0.27764],\n    \"45\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"46\": [0, 0.10803, 0, 0, 0.27764],\n    \"47\": [0.24982, 0.74947, 0, 0, 0.50181],\n    \"48\": [0, 0.47534, 0, 0, 0.50181],\n    \"49\": [0, 0.47534, 0, 0, 0.50181],\n    \"50\": [0, 0.47534, 0, 0, 0.50181],\n    \"51\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"52\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"53\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"54\": [0, 0.69141, 0, 0, 0.50181],\n    \"55\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"56\": [0, 0.69141, 0, 0, 0.50181],\n    \"57\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"58\": [0, 0.47534, 0, 0, 0.21606],\n    \"59\": [0.12604, 0.47534, 0, 0, 0.21606],\n    \"61\": [-0.13099, 0.36866, 0, 0, 0.75623],\n    \"63\": [0, 0.69141, 0, 0, 0.36245],\n    \"65\": [0, 0.69141, 0, 0, 0.7176],\n    \"66\": [0, 0.69141, 0, 0, 0.88397],\n    \"67\": [0, 0.69141, 0, 0, 0.61254],\n    \"68\": [0, 0.69141, 0, 0, 0.83158],\n    \"69\": [0, 0.69141, 0, 0, 0.66278],\n    \"70\": [0.12604, 0.69141, 0, 0, 0.61119],\n    \"71\": [0, 0.69141, 0, 0, 0.78539],\n    \"72\": [0.06302, 0.69141, 0, 0, 0.7203],\n    \"73\": [0, 0.69141, 0, 0, 0.55448],\n    \"74\": [0.12604, 0.69141, 0, 0, 0.55231],\n    \"75\": [0, 0.69141, 0, 0, 0.66845],\n    \"76\": [0, 0.69141, 0, 0, 0.66602],\n    \"77\": [0, 0.69141, 0, 0, 1.04953],\n    \"78\": [0, 0.69141, 0, 0, 0.83212],\n    \"79\": [0, 0.69141, 0, 0, 0.82699],\n    \"80\": [0.18906, 0.69141, 0, 0, 0.82753],\n    \"81\": [0.03781, 0.69141, 0, 0, 0.82699],\n    \"82\": [0, 0.69141, 0, 0, 0.82807],\n    \"83\": [0, 0.69141, 0, 0, 0.82861],\n    \"84\": [0, 0.69141, 0, 0, 0.66899],\n    \"85\": [0, 0.69141, 0, 0, 0.64576],\n    \"86\": [0, 0.69141, 0, 0, 0.83131],\n    \"87\": [0, 0.69141, 0, 0, 1.04602],\n    \"88\": [0, 0.69141, 0, 0, 0.71922],\n    \"89\": [0.18906, 0.69141, 0, 0, 0.83293],\n    \"90\": [0.12604, 0.69141, 0, 0, 0.60201],\n    \"91\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"93\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"94\": [0, 0.69141, 0, 0, 0.49965],\n    \"97\": [0, 0.47534, 0, 0, 0.50046],\n    \"98\": [0, 0.69141, 0, 0, 0.51315],\n    \"99\": [0, 0.47534, 0, 0, 0.38946],\n    \"100\": [0, 0.62119, 0, 0, 0.49857],\n    \"101\": [0, 0.47534, 0, 0, 0.40053],\n    \"102\": [0.18906, 0.69141, 0, 0, 0.32626],\n    \"103\": [0.18906, 0.47534, 0, 0, 0.5037],\n    \"104\": [0.18906, 0.69141, 0, 0, 0.52126],\n    \"105\": [0, 0.69141, 0, 0, 0.27899],\n    \"106\": [0, 0.69141, 0, 0, 0.28088],\n    \"107\": [0, 0.69141, 0, 0, 0.38946],\n    \"108\": [0, 0.69141, 0, 0, 0.27953],\n    \"109\": [0, 0.47534, 0, 0, 0.76676],\n    \"110\": [0, 0.47534, 0, 0, 0.52666],\n    \"111\": [0, 0.47534, 0, 0, 0.48885],\n    \"112\": [0.18906, 0.52396, 0, 0, 0.50046],\n    \"113\": [0.18906, 0.47534, 0, 0, 0.48912],\n    \"114\": [0, 0.47534, 0, 0, 0.38919],\n    \"115\": [0, 0.47534, 0, 0, 0.44266],\n    \"116\": [0, 0.62119, 0, 0, 0.33301],\n    \"117\": [0, 0.47534, 0, 0, 0.5172],\n    \"118\": [0, 0.52396, 0, 0, 0.5118],\n    \"119\": [0, 0.52396, 0, 0, 0.77351],\n    \"120\": [0.18906, 0.47534, 0, 0, 0.38865],\n    \"121\": [0.18906, 0.47534, 0, 0, 0.49884],\n    \"122\": [0.18906, 0.47534, 0, 0, 0.39054],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"8216\": [0, 0.69141, 0, 0, 0.21471],\n    \"8217\": [0, 0.69141, 0, 0, 0.21471],\n    \"58112\": [0, 0.62119, 0, 0, 0.49749],\n    \"58113\": [0, 0.62119, 0, 0, 0.4983],\n    \"58114\": [0.18906, 0.69141, 0, 0, 0.33328],\n    \"58115\": [0.18906, 0.69141, 0, 0, 0.32923],\n    \"58116\": [0.18906, 0.47534, 0, 0, 0.50343],\n    \"58117\": [0, 0.69141, 0, 0, 0.33301],\n    \"58118\": [0, 0.62119, 0, 0, 0.33409],\n    \"58119\": [0, 0.47534, 0, 0, 0.50073]\n  },\n  \"Main-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.35],\n    \"34\": [0, 0.69444, 0, 0, 0.60278],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.95833],\n    \"36\": [0.05556, 0.75, 0, 0, 0.575],\n    \"37\": [0.05556, 0.75, 0, 0, 0.95833],\n    \"38\": [0, 0.69444, 0, 0, 0.89444],\n    \"39\": [0, 0.69444, 0, 0, 0.31944],\n    \"40\": [0.25, 0.75, 0, 0, 0.44722],\n    \"41\": [0.25, 0.75, 0, 0, 0.44722],\n    \"42\": [0, 0.75, 0, 0, 0.575],\n    \"43\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"44\": [0.19444, 0.15556, 0, 0, 0.31944],\n    \"45\": [0, 0.44444, 0, 0, 0.38333],\n    \"46\": [0, 0.15556, 0, 0, 0.31944],\n    \"47\": [0.25, 0.75, 0, 0, 0.575],\n    \"48\": [0, 0.64444, 0, 0, 0.575],\n    \"49\": [0, 0.64444, 0, 0, 0.575],\n    \"50\": [0, 0.64444, 0, 0, 0.575],\n    \"51\": [0, 0.64444, 0, 0, 0.575],\n    \"52\": [0, 0.64444, 0, 0, 0.575],\n    \"53\": [0, 0.64444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0, 0.64444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0, 0.64444, 0, 0, 0.575],\n    \"58\": [0, 0.44444, 0, 0, 0.31944],\n    \"59\": [0.19444, 0.44444, 0, 0, 0.31944],\n    \"60\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"61\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"62\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"63\": [0, 0.69444, 0, 0, 0.54305],\n    \"64\": [0, 0.69444, 0, 0, 0.89444],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0, 0, 0.81805],\n    \"67\": [0, 0.68611, 0, 0, 0.83055],\n    \"68\": [0, 0.68611, 0, 0, 0.88194],\n    \"69\": [0, 0.68611, 0, 0, 0.75555],\n    \"70\": [0, 0.68611, 0, 0, 0.72361],\n    \"71\": [0, 0.68611, 0, 0, 0.90416],\n    \"72\": [0, 0.68611, 0, 0, 0.9],\n    \"73\": [0, 0.68611, 0, 0, 0.43611],\n    \"74\": [0, 0.68611, 0, 0, 0.59444],\n    \"75\": [0, 0.68611, 0, 0, 0.90138],\n    \"76\": [0, 0.68611, 0, 0, 0.69166],\n    \"77\": [0, 0.68611, 0, 0, 1.09166],\n    \"78\": [0, 0.68611, 0, 0, 0.9],\n    \"79\": [0, 0.68611, 0, 0, 0.86388],\n    \"80\": [0, 0.68611, 0, 0, 0.78611],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86388],\n    \"82\": [0, 0.68611, 0, 0, 0.8625],\n    \"83\": [0, 0.68611, 0, 0, 0.63889],\n    \"84\": [0, 0.68611, 0, 0, 0.8],\n    \"85\": [0, 0.68611, 0, 0, 0.88472],\n    \"86\": [0, 0.68611, 0.01597, 0, 0.86944],\n    \"87\": [0, 0.68611, 0.01597, 0, 1.18888],\n    \"88\": [0, 0.68611, 0, 0, 0.86944],\n    \"89\": [0, 0.68611, 0.02875, 0, 0.86944],\n    \"90\": [0, 0.68611, 0, 0, 0.70277],\n    \"91\": [0.25, 0.75, 0, 0, 0.31944],\n    \"92\": [0.25, 0.75, 0, 0, 0.575],\n    \"93\": [0.25, 0.75, 0, 0, 0.31944],\n    \"94\": [0, 0.69444, 0, 0, 0.575],\n    \"95\": [0.31, 0.13444, 0.03194, 0, 0.575],\n    \"97\": [0, 0.44444, 0, 0, 0.55902],\n    \"98\": [0, 0.69444, 0, 0, 0.63889],\n    \"99\": [0, 0.44444, 0, 0, 0.51111],\n    \"100\": [0, 0.69444, 0, 0, 0.63889],\n    \"101\": [0, 0.44444, 0, 0, 0.52708],\n    \"102\": [0, 0.69444, 0.10903, 0, 0.35139],\n    \"103\": [0.19444, 0.44444, 0.01597, 0, 0.575],\n    \"104\": [0, 0.69444, 0, 0, 0.63889],\n    \"105\": [0, 0.69444, 0, 0, 0.31944],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.35139],\n    \"107\": [0, 0.69444, 0, 0, 0.60694],\n    \"108\": [0, 0.69444, 0, 0, 0.31944],\n    \"109\": [0, 0.44444, 0, 0, 0.95833],\n    \"110\": [0, 0.44444, 0, 0, 0.63889],\n    \"111\": [0, 0.44444, 0, 0, 0.575],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.63889],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.60694],\n    \"114\": [0, 0.44444, 0, 0, 0.47361],\n    \"115\": [0, 0.44444, 0, 0, 0.45361],\n    \"116\": [0, 0.63492, 0, 0, 0.44722],\n    \"117\": [0, 0.44444, 0, 0, 0.63889],\n    \"118\": [0, 0.44444, 0.01597, 0, 0.60694],\n    \"119\": [0, 0.44444, 0.01597, 0, 0.83055],\n    \"120\": [0, 0.44444, 0, 0, 0.60694],\n    \"121\": [0.19444, 0.44444, 0.01597, 0, 0.60694],\n    \"122\": [0, 0.44444, 0, 0, 0.51111],\n    \"123\": [0.25, 0.75, 0, 0, 0.575],\n    \"124\": [0.25, 0.75, 0, 0, 0.31944],\n    \"125\": [0.25, 0.75, 0, 0, 0.575],\n    \"126\": [0.35, 0.34444, 0, 0, 0.575],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.86853],\n    \"168\": [0, 0.69444, 0, 0, 0.575],\n    \"172\": [0, 0.44444, 0, 0, 0.76666],\n    \"176\": [0, 0.69444, 0, 0, 0.86944],\n    \"177\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"184\": [0.17014, 0, 0, 0, 0.51111],\n    \"198\": [0, 0.68611, 0, 0, 1.04166],\n    \"215\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"216\": [0.04861, 0.73472, 0, 0, 0.89444],\n    \"223\": [0, 0.69444, 0, 0, 0.59722],\n    \"230\": [0, 0.44444, 0, 0, 0.83055],\n    \"247\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"248\": [0.09722, 0.54167, 0, 0, 0.575],\n    \"305\": [0, 0.44444, 0, 0, 0.31944],\n    \"338\": [0, 0.68611, 0, 0, 1.16944],\n    \"339\": [0, 0.44444, 0, 0, 0.89444],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.35139],\n    \"710\": [0, 0.69444, 0, 0, 0.575],\n    \"711\": [0, 0.63194, 0, 0, 0.575],\n    \"713\": [0, 0.59611, 0, 0, 0.575],\n    \"714\": [0, 0.69444, 0, 0, 0.575],\n    \"715\": [0, 0.69444, 0, 0, 0.575],\n    \"728\": [0, 0.69444, 0, 0, 0.575],\n    \"729\": [0, 0.69444, 0, 0, 0.31944],\n    \"730\": [0, 0.69444, 0, 0, 0.86944],\n    \"732\": [0, 0.69444, 0, 0, 0.575],\n    \"733\": [0, 0.69444, 0, 0, 0.575],\n    \"915\": [0, 0.68611, 0, 0, 0.69166],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0, 0, 0.89444],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0, 0, 0.76666],\n    \"928\": [0, 0.68611, 0, 0, 0.9],\n    \"931\": [0, 0.68611, 0, 0, 0.83055],\n    \"933\": [0, 0.68611, 0, 0, 0.89444],\n    \"934\": [0, 0.68611, 0, 0, 0.83055],\n    \"936\": [0, 0.68611, 0, 0, 0.89444],\n    \"937\": [0, 0.68611, 0, 0, 0.83055],\n    \"8211\": [0, 0.44444, 0.03194, 0, 0.575],\n    \"8212\": [0, 0.44444, 0.03194, 0, 1.14999],\n    \"8216\": [0, 0.69444, 0, 0, 0.31944],\n    \"8217\": [0, 0.69444, 0, 0, 0.31944],\n    \"8220\": [0, 0.69444, 0, 0, 0.60278],\n    \"8221\": [0, 0.69444, 0, 0, 0.60278],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8242\": [0, 0.55556, 0, 0, 0.34444],\n    \"8407\": [0, 0.72444, 0.15486, 0, 0.575],\n    \"8463\": [0, 0.69444, 0, 0, 0.66759],\n    \"8465\": [0, 0.69444, 0, 0, 0.83055],\n    \"8467\": [0, 0.69444, 0, 0, 0.47361],\n    \"8472\": [0.19444, 0.44444, 0, 0, 0.74027],\n    \"8476\": [0, 0.69444, 0, 0, 0.83055],\n    \"8501\": [0, 0.69444, 0, 0, 0.70277],\n    \"8592\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8594\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8596\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8597\": [0.25, 0.75, 0, 0, 0.575],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8636\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8637\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8640\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8641\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8656\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8658\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8660\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8661\": [0.25, 0.75, 0, 0, 0.70277],\n    \"8704\": [0, 0.69444, 0, 0, 0.63889],\n    \"8706\": [0, 0.69444, 0.06389, 0, 0.62847],\n    \"8707\": [0, 0.69444, 0, 0, 0.63889],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.575],\n    \"8711\": [0, 0.68611, 0, 0, 0.95833],\n    \"8712\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8715\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8722\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8723\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8725\": [0.25, 0.75, 0, 0, 0.575],\n    \"8726\": [0.25, 0.75, 0, 0, 0.575],\n    \"8727\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8728\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8729\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8730\": [0.18, 0.82, 0, 0, 0.95833],\n    \"8733\": [0, 0.44444, 0, 0, 0.89444],\n    \"8734\": [0, 0.44444, 0, 0, 1.14999],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.31944],\n    \"8741\": [0.25, 0.75, 0, 0, 0.575],\n    \"8743\": [0, 0.55556, 0, 0, 0.76666],\n    \"8744\": [0, 0.55556, 0, 0, 0.76666],\n    \"8745\": [0, 0.55556, 0, 0, 0.76666],\n    \"8746\": [0, 0.55556, 0, 0, 0.76666],\n    \"8747\": [0.19444, 0.69444, 0.12778, 0, 0.56875],\n    \"8764\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.31944],\n    \"8771\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8773\": [0.027, 0.638, 0, 0, 0.894],\n    \"8776\": [0.02444, 0.52444, 0, 0, 0.89444],\n    \"8781\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8801\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8804\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8805\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8810\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8811\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8826\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8827\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8834\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8835\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8838\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8839\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8846\": [0, 0.55556, 0, 0, 0.76666],\n    \"8849\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8850\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8851\": [0, 0.55556, 0, 0, 0.76666],\n    \"8852\": [0, 0.55556, 0, 0, 0.76666],\n    \"8853\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8854\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8855\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8856\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8857\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8866\": [0, 0.69444, 0, 0, 0.70277],\n    \"8867\": [0, 0.69444, 0, 0, 0.70277],\n    \"8868\": [0, 0.69444, 0, 0, 0.89444],\n    \"8869\": [0, 0.69444, 0, 0, 0.89444],\n    \"8900\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8901\": [-0.02639, 0.47361, 0, 0, 0.31944],\n    \"8902\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8968\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8969\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8970\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8971\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8994\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"8995\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"9651\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9657\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9661\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9667\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9837\": [0, 0.75, 0, 0, 0.44722],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"10216\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10217\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10815\": [0, 0.68611, 0, 0, 0.9],\n    \"10927\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"10928\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Main-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.11417, 0, 0.38611],\n    \"34\": [0, 0.69444, 0.07939, 0, 0.62055],\n    \"35\": [0.19444, 0.69444, 0.06833, 0, 0.94444],\n    \"37\": [0.05556, 0.75, 0.12861, 0, 0.94444],\n    \"38\": [0, 0.69444, 0.08528, 0, 0.88555],\n    \"39\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"40\": [0.25, 0.75, 0.15806, 0, 0.47333],\n    \"41\": [0.25, 0.75, 0.03306, 0, 0.47333],\n    \"42\": [0, 0.75, 0.14333, 0, 0.59111],\n    \"43\": [0.10333, 0.60333, 0.03306, 0, 0.88555],\n    \"44\": [0.19444, 0.14722, 0, 0, 0.35555],\n    \"45\": [0, 0.44444, 0.02611, 0, 0.41444],\n    \"46\": [0, 0.14722, 0, 0, 0.35555],\n    \"47\": [0.25, 0.75, 0.15806, 0, 0.59111],\n    \"48\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"49\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"50\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"51\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"52\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"53\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"54\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"55\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"56\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"57\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"58\": [0, 0.44444, 0.06695, 0, 0.35555],\n    \"59\": [0.19444, 0.44444, 0.06695, 0, 0.35555],\n    \"61\": [-0.10889, 0.39111, 0.06833, 0, 0.88555],\n    \"63\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"64\": [0, 0.69444, 0.09208, 0, 0.88555],\n    \"65\": [0, 0.68611, 0, 0, 0.86555],\n    \"66\": [0, 0.68611, 0.0992, 0, 0.81666],\n    \"67\": [0, 0.68611, 0.14208, 0, 0.82666],\n    \"68\": [0, 0.68611, 0.09062, 0, 0.87555],\n    \"69\": [0, 0.68611, 0.11431, 0, 0.75666],\n    \"70\": [0, 0.68611, 0.12903, 0, 0.72722],\n    \"71\": [0, 0.68611, 0.07347, 0, 0.89527],\n    \"72\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"73\": [0, 0.68611, 0.15681, 0, 0.47166],\n    \"74\": [0, 0.68611, 0.145, 0, 0.61055],\n    \"75\": [0, 0.68611, 0.14208, 0, 0.89499],\n    \"76\": [0, 0.68611, 0, 0, 0.69777],\n    \"77\": [0, 0.68611, 0.17208, 0, 1.07277],\n    \"78\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"79\": [0, 0.68611, 0.09062, 0, 0.85499],\n    \"80\": [0, 0.68611, 0.0992, 0, 0.78721],\n    \"81\": [0.19444, 0.68611, 0.09062, 0, 0.85499],\n    \"82\": [0, 0.68611, 0.02559, 0, 0.85944],\n    \"83\": [0, 0.68611, 0.11264, 0, 0.64999],\n    \"84\": [0, 0.68611, 0.12903, 0, 0.7961],\n    \"85\": [0, 0.68611, 0.17208, 0, 0.88083],\n    \"86\": [0, 0.68611, 0.18625, 0, 0.86555],\n    \"87\": [0, 0.68611, 0.18625, 0, 1.15999],\n    \"88\": [0, 0.68611, 0.15681, 0, 0.86555],\n    \"89\": [0, 0.68611, 0.19803, 0, 0.86555],\n    \"90\": [0, 0.68611, 0.14208, 0, 0.70888],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.35611],\n    \"93\": [0.25, 0.75, 0.09972, 0, 0.35611],\n    \"94\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"95\": [0.31, 0.13444, 0.09811, 0, 0.59111],\n    \"97\": [0, 0.44444, 0.09426, 0, 0.59111],\n    \"98\": [0, 0.69444, 0.07861, 0, 0.53222],\n    \"99\": [0, 0.44444, 0.05222, 0, 0.53222],\n    \"100\": [0, 0.69444, 0.10861, 0, 0.59111],\n    \"101\": [0, 0.44444, 0.085, 0, 0.53222],\n    \"102\": [0.19444, 0.69444, 0.21778, 0, 0.4],\n    \"103\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"104\": [0, 0.69444, 0.09426, 0, 0.59111],\n    \"105\": [0, 0.69326, 0.11387, 0, 0.35555],\n    \"106\": [0.19444, 0.69326, 0.1672, 0, 0.35555],\n    \"107\": [0, 0.69444, 0.11111, 0, 0.53222],\n    \"108\": [0, 0.69444, 0.10861, 0, 0.29666],\n    \"109\": [0, 0.44444, 0.09426, 0, 0.94444],\n    \"110\": [0, 0.44444, 0.09426, 0, 0.64999],\n    \"111\": [0, 0.44444, 0.07861, 0, 0.59111],\n    \"112\": [0.19444, 0.44444, 0.07861, 0, 0.59111],\n    \"113\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"114\": [0, 0.44444, 0.11111, 0, 0.50167],\n    \"115\": [0, 0.44444, 0.08167, 0, 0.48694],\n    \"116\": [0, 0.63492, 0.09639, 0, 0.385],\n    \"117\": [0, 0.44444, 0.09426, 0, 0.62055],\n    \"118\": [0, 0.44444, 0.11111, 0, 0.53222],\n    \"119\": [0, 0.44444, 0.11111, 0, 0.76777],\n    \"120\": [0, 0.44444, 0.12583, 0, 0.56055],\n    \"121\": [0.19444, 0.44444, 0.105, 0, 0.56166],\n    \"122\": [0, 0.44444, 0.13889, 0, 0.49055],\n    \"126\": [0.35, 0.34444, 0.11472, 0, 0.59111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0.11473, 0, 0.59111],\n    \"176\": [0, 0.69444, 0, 0, 0.94888],\n    \"184\": [0.17014, 0, 0, 0, 0.53222],\n    \"198\": [0, 0.68611, 0.11431, 0, 1.02277],\n    \"216\": [0.04861, 0.73472, 0.09062, 0, 0.88555],\n    \"223\": [0.19444, 0.69444, 0.09736, 0, 0.665],\n    \"230\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"248\": [0.09722, 0.54167, 0.09458, 0, 0.59111],\n    \"305\": [0, 0.44444, 0.09426, 0, 0.35555],\n    \"338\": [0, 0.68611, 0.11431, 0, 1.14054],\n    \"339\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"567\": [0.19444, 0.44444, 0.04611, 0, 0.385],\n    \"710\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"711\": [0, 0.63194, 0.08271, 0, 0.59111],\n    \"713\": [0, 0.59444, 0.10444, 0, 0.59111],\n    \"714\": [0, 0.69444, 0.08528, 0, 0.59111],\n    \"715\": [0, 0.69444, 0, 0, 0.59111],\n    \"728\": [0, 0.69444, 0.10333, 0, 0.59111],\n    \"729\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"730\": [0, 0.69444, 0, 0, 0.94888],\n    \"732\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"733\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"915\": [0, 0.68611, 0.12903, 0, 0.69777],\n    \"916\": [0, 0.68611, 0, 0, 0.94444],\n    \"920\": [0, 0.68611, 0.09062, 0, 0.88555],\n    \"923\": [0, 0.68611, 0, 0, 0.80666],\n    \"926\": [0, 0.68611, 0.15092, 0, 0.76777],\n    \"928\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"931\": [0, 0.68611, 0.11431, 0, 0.82666],\n    \"933\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"934\": [0, 0.68611, 0.05632, 0, 0.82666],\n    \"936\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"937\": [0, 0.68611, 0.0992, 0, 0.82666],\n    \"8211\": [0, 0.44444, 0.09811, 0, 0.59111],\n    \"8212\": [0, 0.44444, 0.09811, 0, 1.18221],\n    \"8216\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8217\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8220\": [0, 0.69444, 0.16772, 0, 0.62055],\n    \"8221\": [0, 0.69444, 0.07939, 0, 0.62055]\n  },\n  \"Main-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"34\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"35\": [0.19444, 0.69444, 0.06616, 0, 0.81777],\n    \"37\": [0.05556, 0.75, 0.13639, 0, 0.81777],\n    \"38\": [0, 0.69444, 0.09694, 0, 0.76666],\n    \"39\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"40\": [0.25, 0.75, 0.16194, 0, 0.40889],\n    \"41\": [0.25, 0.75, 0.03694, 0, 0.40889],\n    \"42\": [0, 0.75, 0.14917, 0, 0.51111],\n    \"43\": [0.05667, 0.56167, 0.03694, 0, 0.76666],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.30667],\n    \"45\": [0, 0.43056, 0.02826, 0, 0.35778],\n    \"46\": [0, 0.10556, 0, 0, 0.30667],\n    \"47\": [0.25, 0.75, 0.16194, 0, 0.51111],\n    \"48\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"49\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"50\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"51\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"52\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"53\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"54\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"55\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"56\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"57\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"58\": [0, 0.43056, 0.0582, 0, 0.30667],\n    \"59\": [0.19444, 0.43056, 0.0582, 0, 0.30667],\n    \"61\": [-0.13313, 0.36687, 0.06616, 0, 0.76666],\n    \"63\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"64\": [0, 0.69444, 0.09597, 0, 0.76666],\n    \"65\": [0, 0.68333, 0, 0, 0.74333],\n    \"66\": [0, 0.68333, 0.10257, 0, 0.70389],\n    \"67\": [0, 0.68333, 0.14528, 0, 0.71555],\n    \"68\": [0, 0.68333, 0.09403, 0, 0.755],\n    \"69\": [0, 0.68333, 0.12028, 0, 0.67833],\n    \"70\": [0, 0.68333, 0.13305, 0, 0.65277],\n    \"71\": [0, 0.68333, 0.08722, 0, 0.77361],\n    \"72\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"73\": [0, 0.68333, 0.15806, 0, 0.38555],\n    \"74\": [0, 0.68333, 0.14028, 0, 0.525],\n    \"75\": [0, 0.68333, 0.14528, 0, 0.76888],\n    \"76\": [0, 0.68333, 0, 0, 0.62722],\n    \"77\": [0, 0.68333, 0.16389, 0, 0.89666],\n    \"78\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"79\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"80\": [0, 0.68333, 0.10257, 0, 0.67833],\n    \"81\": [0.19444, 0.68333, 0.09403, 0, 0.76666],\n    \"82\": [0, 0.68333, 0.03868, 0, 0.72944],\n    \"83\": [0, 0.68333, 0.11972, 0, 0.56222],\n    \"84\": [0, 0.68333, 0.13305, 0, 0.71555],\n    \"85\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"86\": [0, 0.68333, 0.18361, 0, 0.74333],\n    \"87\": [0, 0.68333, 0.18361, 0, 0.99888],\n    \"88\": [0, 0.68333, 0.15806, 0, 0.74333],\n    \"89\": [0, 0.68333, 0.19383, 0, 0.74333],\n    \"90\": [0, 0.68333, 0.14528, 0, 0.61333],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.30667],\n    \"93\": [0.25, 0.75, 0.10528, 0, 0.30667],\n    \"94\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"95\": [0.31, 0.12056, 0.09208, 0, 0.51111],\n    \"97\": [0, 0.43056, 0.07671, 0, 0.51111],\n    \"98\": [0, 0.69444, 0.06312, 0, 0.46],\n    \"99\": [0, 0.43056, 0.05653, 0, 0.46],\n    \"100\": [0, 0.69444, 0.10333, 0, 0.51111],\n    \"101\": [0, 0.43056, 0.07514, 0, 0.46],\n    \"102\": [0.19444, 0.69444, 0.21194, 0, 0.30667],\n    \"103\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"104\": [0, 0.69444, 0.07671, 0, 0.51111],\n    \"105\": [0, 0.65536, 0.1019, 0, 0.30667],\n    \"106\": [0.19444, 0.65536, 0.14467, 0, 0.30667],\n    \"107\": [0, 0.69444, 0.10764, 0, 0.46],\n    \"108\": [0, 0.69444, 0.10333, 0, 0.25555],\n    \"109\": [0, 0.43056, 0.07671, 0, 0.81777],\n    \"110\": [0, 0.43056, 0.07671, 0, 0.56222],\n    \"111\": [0, 0.43056, 0.06312, 0, 0.51111],\n    \"112\": [0.19444, 0.43056, 0.06312, 0, 0.51111],\n    \"113\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"114\": [0, 0.43056, 0.10764, 0, 0.42166],\n    \"115\": [0, 0.43056, 0.08208, 0, 0.40889],\n    \"116\": [0, 0.61508, 0.09486, 0, 0.33222],\n    \"117\": [0, 0.43056, 0.07671, 0, 0.53666],\n    \"118\": [0, 0.43056, 0.10764, 0, 0.46],\n    \"119\": [0, 0.43056, 0.10764, 0, 0.66444],\n    \"120\": [0, 0.43056, 0.12042, 0, 0.46389],\n    \"121\": [0.19444, 0.43056, 0.08847, 0, 0.48555],\n    \"122\": [0, 0.43056, 0.12292, 0, 0.40889],\n    \"126\": [0.35, 0.31786, 0.11585, 0, 0.51111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.66786, 0.10474, 0, 0.51111],\n    \"176\": [0, 0.69444, 0, 0, 0.83129],\n    \"184\": [0.17014, 0, 0, 0, 0.46],\n    \"198\": [0, 0.68333, 0.12028, 0, 0.88277],\n    \"216\": [0.04861, 0.73194, 0.09403, 0, 0.76666],\n    \"223\": [0.19444, 0.69444, 0.10514, 0, 0.53666],\n    \"230\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"248\": [0.09722, 0.52778, 0.09194, 0, 0.51111],\n    \"338\": [0, 0.68333, 0.12028, 0, 0.98499],\n    \"339\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"710\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"711\": [0, 0.62847, 0.08295, 0, 0.51111],\n    \"713\": [0, 0.56167, 0.10333, 0, 0.51111],\n    \"714\": [0, 0.69444, 0.09694, 0, 0.51111],\n    \"715\": [0, 0.69444, 0, 0, 0.51111],\n    \"728\": [0, 0.69444, 0.10806, 0, 0.51111],\n    \"729\": [0, 0.66786, 0.11752, 0, 0.30667],\n    \"730\": [0, 0.69444, 0, 0, 0.83129],\n    \"732\": [0, 0.66786, 0.11585, 0, 0.51111],\n    \"733\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"915\": [0, 0.68333, 0.13305, 0, 0.62722],\n    \"916\": [0, 0.68333, 0, 0, 0.81777],\n    \"920\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"923\": [0, 0.68333, 0, 0, 0.69222],\n    \"926\": [0, 0.68333, 0.15294, 0, 0.66444],\n    \"928\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"931\": [0, 0.68333, 0.12028, 0, 0.71555],\n    \"933\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"934\": [0, 0.68333, 0.05986, 0, 0.71555],\n    \"936\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"937\": [0, 0.68333, 0.10257, 0, 0.71555],\n    \"8211\": [0, 0.43056, 0.09208, 0, 0.51111],\n    \"8212\": [0, 0.43056, 0.09208, 0, 1.02222],\n    \"8216\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8217\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8220\": [0, 0.69444, 0.1685, 0, 0.51444],\n    \"8221\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028]\n  },\n  \"Main-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.27778],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.77778],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.27778],\n    \"45\": [0, 0.43056, 0, 0, 0.33333],\n    \"46\": [0, 0.10556, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.64444, 0, 0, 0.5],\n    \"49\": [0, 0.64444, 0, 0, 0.5],\n    \"50\": [0, 0.64444, 0, 0, 0.5],\n    \"51\": [0, 0.64444, 0, 0, 0.5],\n    \"52\": [0, 0.64444, 0, 0, 0.5],\n    \"53\": [0, 0.64444, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0, 0.64444, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0, 0.64444, 0, 0, 0.5],\n    \"58\": [0, 0.43056, 0, 0, 0.27778],\n    \"59\": [0.19444, 0.43056, 0, 0, 0.27778],\n    \"60\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"61\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"62\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.77778],\n    \"65\": [0, 0.68333, 0, 0, 0.75],\n    \"66\": [0, 0.68333, 0, 0, 0.70834],\n    \"67\": [0, 0.68333, 0, 0, 0.72222],\n    \"68\": [0, 0.68333, 0, 0, 0.76389],\n    \"69\": [0, 0.68333, 0, 0, 0.68056],\n    \"70\": [0, 0.68333, 0, 0, 0.65278],\n    \"71\": [0, 0.68333, 0, 0, 0.78472],\n    \"72\": [0, 0.68333, 0, 0, 0.75],\n    \"73\": [0, 0.68333, 0, 0, 0.36111],\n    \"74\": [0, 0.68333, 0, 0, 0.51389],\n    \"75\": [0, 0.68333, 0, 0, 0.77778],\n    \"76\": [0, 0.68333, 0, 0, 0.625],\n    \"77\": [0, 0.68333, 0, 0, 0.91667],\n    \"78\": [0, 0.68333, 0, 0, 0.75],\n    \"79\": [0, 0.68333, 0, 0, 0.77778],\n    \"80\": [0, 0.68333, 0, 0, 0.68056],\n    \"81\": [0.19444, 0.68333, 0, 0, 0.77778],\n    \"82\": [0, 0.68333, 0, 0, 0.73611],\n    \"83\": [0, 0.68333, 0, 0, 0.55556],\n    \"84\": [0, 0.68333, 0, 0, 0.72222],\n    \"85\": [0, 0.68333, 0, 0, 0.75],\n    \"86\": [0, 0.68333, 0.01389, 0, 0.75],\n    \"87\": [0, 0.68333, 0.01389, 0, 1.02778],\n    \"88\": [0, 0.68333, 0, 0, 0.75],\n    \"89\": [0, 0.68333, 0.025, 0, 0.75],\n    \"90\": [0, 0.68333, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.27778],\n    \"92\": [0.25, 0.75, 0, 0, 0.5],\n    \"93\": [0.25, 0.75, 0, 0, 0.27778],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.31, 0.12056, 0.02778, 0, 0.5],\n    \"97\": [0, 0.43056, 0, 0, 0.5],\n    \"98\": [0, 0.69444, 0, 0, 0.55556],\n    \"99\": [0, 0.43056, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.55556],\n    \"101\": [0, 0.43056, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.07778, 0, 0.30556],\n    \"103\": [0.19444, 0.43056, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.55556],\n    \"105\": [0, 0.66786, 0, 0, 0.27778],\n    \"106\": [0.19444, 0.66786, 0, 0, 0.30556],\n    \"107\": [0, 0.69444, 0, 0, 0.52778],\n    \"108\": [0, 0.69444, 0, 0, 0.27778],\n    \"109\": [0, 0.43056, 0, 0, 0.83334],\n    \"110\": [0, 0.43056, 0, 0, 0.55556],\n    \"111\": [0, 0.43056, 0, 0, 0.5],\n    \"112\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"113\": [0.19444, 0.43056, 0, 0, 0.52778],\n    \"114\": [0, 0.43056, 0, 0, 0.39167],\n    \"115\": [0, 0.43056, 0, 0, 0.39445],\n    \"116\": [0, 0.61508, 0, 0, 0.38889],\n    \"117\": [0, 0.43056, 0, 0, 0.55556],\n    \"118\": [0, 0.43056, 0.01389, 0, 0.52778],\n    \"119\": [0, 0.43056, 0.01389, 0, 0.72222],\n    \"120\": [0, 0.43056, 0, 0, 0.52778],\n    \"121\": [0.19444, 0.43056, 0.01389, 0, 0.52778],\n    \"122\": [0, 0.43056, 0, 0, 0.44445],\n    \"123\": [0.25, 0.75, 0, 0, 0.5],\n    \"124\": [0.25, 0.75, 0, 0, 0.27778],\n    \"125\": [0.25, 0.75, 0, 0, 0.5],\n    \"126\": [0.35, 0.31786, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.76909],\n    \"167\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"168\": [0, 0.66786, 0, 0, 0.5],\n    \"172\": [0, 0.43056, 0, 0, 0.66667],\n    \"176\": [0, 0.69444, 0, 0, 0.75],\n    \"177\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"182\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"198\": [0, 0.68333, 0, 0, 0.90278],\n    \"215\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"216\": [0.04861, 0.73194, 0, 0, 0.77778],\n    \"223\": [0, 0.69444, 0, 0, 0.5],\n    \"230\": [0, 0.43056, 0, 0, 0.72222],\n    \"247\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"248\": [0.09722, 0.52778, 0, 0, 0.5],\n    \"305\": [0, 0.43056, 0, 0, 0.27778],\n    \"338\": [0, 0.68333, 0, 0, 1.01389],\n    \"339\": [0, 0.43056, 0, 0, 0.77778],\n    \"567\": [0.19444, 0.43056, 0, 0, 0.30556],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.62847, 0, 0, 0.5],\n    \"713\": [0, 0.56778, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.66786, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.75],\n    \"732\": [0, 0.66786, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.68333, 0, 0, 0.625],\n    \"916\": [0, 0.68333, 0, 0, 0.83334],\n    \"920\": [0, 0.68333, 0, 0, 0.77778],\n    \"923\": [0, 0.68333, 0, 0, 0.69445],\n    \"926\": [0, 0.68333, 0, 0, 0.66667],\n    \"928\": [0, 0.68333, 0, 0, 0.75],\n    \"931\": [0, 0.68333, 0, 0, 0.72222],\n    \"933\": [0, 0.68333, 0, 0, 0.77778],\n    \"934\": [0, 0.68333, 0, 0, 0.72222],\n    \"936\": [0, 0.68333, 0, 0, 0.77778],\n    \"937\": [0, 0.68333, 0, 0, 0.72222],\n    \"8211\": [0, 0.43056, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.43056, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8230\": [0, 0.123, 0, 0, 1.172],\n    \"8242\": [0, 0.55556, 0, 0, 0.275],\n    \"8407\": [0, 0.71444, 0.15382, 0, 0.5],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8465\": [0, 0.69444, 0, 0, 0.72222],\n    \"8467\": [0, 0.69444, 0, 0.11111, 0.41667],\n    \"8472\": [0.19444, 0.43056, 0, 0.11111, 0.63646],\n    \"8476\": [0, 0.69444, 0, 0, 0.72222],\n    \"8501\": [0, 0.69444, 0, 0, 0.61111],\n    \"8592\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8594\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8596\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8597\": [0.25, 0.75, 0, 0, 0.5],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8614\": [0.011, 0.511, 0, 0, 1.0],\n    \"8617\": [0.011, 0.511, 0, 0, 1.126],\n    \"8618\": [0.011, 0.511, 0, 0, 1.126],\n    \"8636\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8637\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8640\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8641\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8652\": [0.011, 0.671, 0, 0, 1.0],\n    \"8656\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8658\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8660\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8661\": [0.25, 0.75, 0, 0, 0.61111],\n    \"8704\": [0, 0.69444, 0, 0, 0.55556],\n    \"8706\": [0, 0.69444, 0.05556, 0.08334, 0.5309],\n    \"8707\": [0, 0.69444, 0, 0, 0.55556],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.5],\n    \"8711\": [0, 0.68333, 0, 0, 0.83334],\n    \"8712\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8715\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8722\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8723\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8725\": [0.25, 0.75, 0, 0, 0.5],\n    \"8726\": [0.25, 0.75, 0, 0, 0.5],\n    \"8727\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8728\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8729\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8730\": [0.2, 0.8, 0, 0, 0.83334],\n    \"8733\": [0, 0.43056, 0, 0, 0.77778],\n    \"8734\": [0, 0.43056, 0, 0, 1.0],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.27778],\n    \"8741\": [0.25, 0.75, 0, 0, 0.5],\n    \"8743\": [0, 0.55556, 0, 0, 0.66667],\n    \"8744\": [0, 0.55556, 0, 0, 0.66667],\n    \"8745\": [0, 0.55556, 0, 0, 0.66667],\n    \"8746\": [0, 0.55556, 0, 0, 0.66667],\n    \"8747\": [0.19444, 0.69444, 0.11111, 0, 0.41667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.27778],\n    \"8771\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8773\": [-0.022, 0.589, 0, 0, 0.778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8781\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8784\": [-0.133, 0.673, 0, 0, 0.778],\n    \"8801\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8804\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8805\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8810\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8811\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8826\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8827\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8834\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8835\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8838\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8839\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8846\": [0, 0.55556, 0, 0, 0.66667],\n    \"8849\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8850\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8851\": [0, 0.55556, 0, 0, 0.66667],\n    \"8852\": [0, 0.55556, 0, 0, 0.66667],\n    \"8853\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8854\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8855\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8856\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8857\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8866\": [0, 0.69444, 0, 0, 0.61111],\n    \"8867\": [0, 0.69444, 0, 0, 0.61111],\n    \"8868\": [0, 0.69444, 0, 0, 0.77778],\n    \"8869\": [0, 0.69444, 0, 0, 0.77778],\n    \"8872\": [0.249, 0.75, 0, 0, 0.867],\n    \"8900\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8901\": [-0.05555, 0.44445, 0, 0, 0.27778],\n    \"8902\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8904\": [0.005, 0.505, 0, 0, 0.9],\n    \"8942\": [0.03, 0.903, 0, 0, 0.278],\n    \"8943\": [-0.19, 0.313, 0, 0, 1.172],\n    \"8945\": [-0.1, 0.823, 0, 0, 1.282],\n    \"8968\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8969\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8970\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8971\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8994\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"8995\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"9136\": [0.244, 0.744, 0, 0, 0.412],\n    \"9137\": [0.244, 0.745, 0, 0, 0.412],\n    \"9651\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9657\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9661\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9667\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9837\": [0, 0.75, 0, 0, 0.38889],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"10216\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10217\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10222\": [0.244, 0.744, 0, 0, 0.412],\n    \"10223\": [0.244, 0.745, 0, 0, 0.412],\n    \"10229\": [0.011, 0.511, 0, 0, 1.609],\n    \"10230\": [0.011, 0.511, 0, 0, 1.638],\n    \"10231\": [0.011, 0.511, 0, 0, 1.859],\n    \"10232\": [0.024, 0.525, 0, 0, 1.609],\n    \"10233\": [0.024, 0.525, 0, 0, 1.638],\n    \"10234\": [0.024, 0.525, 0, 0, 1.858],\n    \"10236\": [0.011, 0.511, 0, 0, 1.638],\n    \"10815\": [0, 0.68333, 0, 0, 0.75],\n    \"10927\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10928\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Math-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.44444, 0, 0, 0.575],\n    \"49\": [0, 0.44444, 0, 0, 0.575],\n    \"50\": [0, 0.44444, 0, 0, 0.575],\n    \"51\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"52\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"53\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0.04835, 0, 0.8664],\n    \"67\": [0, 0.68611, 0.06979, 0, 0.81694],\n    \"68\": [0, 0.68611, 0.03194, 0, 0.93812],\n    \"69\": [0, 0.68611, 0.05451, 0, 0.81007],\n    \"70\": [0, 0.68611, 0.15972, 0, 0.68889],\n    \"71\": [0, 0.68611, 0, 0, 0.88673],\n    \"72\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"73\": [0, 0.68611, 0.07778, 0, 0.51111],\n    \"74\": [0, 0.68611, 0.10069, 0, 0.63125],\n    \"75\": [0, 0.68611, 0.06979, 0, 0.97118],\n    \"76\": [0, 0.68611, 0, 0, 0.75555],\n    \"77\": [0, 0.68611, 0.11424, 0, 1.14201],\n    \"78\": [0, 0.68611, 0.11424, 0, 0.95034],\n    \"79\": [0, 0.68611, 0.03194, 0, 0.83666],\n    \"80\": [0, 0.68611, 0.15972, 0, 0.72309],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86861],\n    \"82\": [0, 0.68611, 0.00421, 0, 0.87235],\n    \"83\": [0, 0.68611, 0.05382, 0, 0.69271],\n    \"84\": [0, 0.68611, 0.15972, 0, 0.63663],\n    \"85\": [0, 0.68611, 0.11424, 0, 0.80027],\n    \"86\": [0, 0.68611, 0.25555, 0, 0.67778],\n    \"87\": [0, 0.68611, 0.15972, 0, 1.09305],\n    \"88\": [0, 0.68611, 0.07778, 0, 0.94722],\n    \"89\": [0, 0.68611, 0.25555, 0, 0.67458],\n    \"90\": [0, 0.68611, 0.06979, 0, 0.77257],\n    \"97\": [0, 0.44444, 0, 0, 0.63287],\n    \"98\": [0, 0.69444, 0, 0, 0.52083],\n    \"99\": [0, 0.44444, 0, 0, 0.51342],\n    \"100\": [0, 0.69444, 0, 0, 0.60972],\n    \"101\": [0, 0.44444, 0, 0, 0.55361],\n    \"102\": [0.19444, 0.69444, 0.11042, 0, 0.56806],\n    \"103\": [0.19444, 0.44444, 0.03704, 0, 0.5449],\n    \"104\": [0, 0.69444, 0, 0, 0.66759],\n    \"105\": [0, 0.69326, 0, 0, 0.4048],\n    \"106\": [0.19444, 0.69326, 0.0622, 0, 0.47083],\n    \"107\": [0, 0.69444, 0.01852, 0, 0.6037],\n    \"108\": [0, 0.69444, 0.0088, 0, 0.34815],\n    \"109\": [0, 0.44444, 0, 0, 1.0324],\n    \"110\": [0, 0.44444, 0, 0, 0.71296],\n    \"111\": [0, 0.44444, 0, 0, 0.58472],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.60092],\n    \"113\": [0.19444, 0.44444, 0.03704, 0, 0.54213],\n    \"114\": [0, 0.44444, 0.03194, 0, 0.5287],\n    \"115\": [0, 0.44444, 0, 0, 0.53125],\n    \"116\": [0, 0.63492, 0, 0, 0.41528],\n    \"117\": [0, 0.44444, 0, 0, 0.68102],\n    \"118\": [0, 0.44444, 0.03704, 0, 0.56666],\n    \"119\": [0, 0.44444, 0.02778, 0, 0.83148],\n    \"120\": [0, 0.44444, 0, 0, 0.65903],\n    \"121\": [0.19444, 0.44444, 0.03704, 0, 0.59028],\n    \"122\": [0, 0.44444, 0.04213, 0, 0.55509],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68611, 0.15972, 0, 0.65694],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0.03194, 0, 0.86722],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0.07458, 0, 0.84125],\n    \"928\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"931\": [0, 0.68611, 0.05451, 0, 0.88507],\n    \"933\": [0, 0.68611, 0.15972, 0, 0.67083],\n    \"934\": [0, 0.68611, 0, 0, 0.76666],\n    \"936\": [0, 0.68611, 0.11653, 0, 0.71402],\n    \"937\": [0, 0.68611, 0.04835, 0, 0.8789],\n    \"945\": [0, 0.44444, 0, 0, 0.76064],\n    \"946\": [0.19444, 0.69444, 0.03403, 0, 0.65972],\n    \"947\": [0.19444, 0.44444, 0.06389, 0, 0.59003],\n    \"948\": [0, 0.69444, 0.03819, 0, 0.52222],\n    \"949\": [0, 0.44444, 0, 0, 0.52882],\n    \"950\": [0.19444, 0.69444, 0.06215, 0, 0.50833],\n    \"951\": [0.19444, 0.44444, 0.03704, 0, 0.6],\n    \"952\": [0, 0.69444, 0.03194, 0, 0.5618],\n    \"953\": [0, 0.44444, 0, 0, 0.41204],\n    \"954\": [0, 0.44444, 0, 0, 0.66759],\n    \"955\": [0, 0.69444, 0, 0, 0.67083],\n    \"956\": [0.19444, 0.44444, 0, 0, 0.70787],\n    \"957\": [0, 0.44444, 0.06898, 0, 0.57685],\n    \"958\": [0.19444, 0.69444, 0.03021, 0, 0.50833],\n    \"959\": [0, 0.44444, 0, 0, 0.58472],\n    \"960\": [0, 0.44444, 0.03704, 0, 0.68241],\n    \"961\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"962\": [0.09722, 0.44444, 0.07917, 0, 0.42361],\n    \"963\": [0, 0.44444, 0.03704, 0, 0.68588],\n    \"964\": [0, 0.44444, 0.13472, 0, 0.52083],\n    \"965\": [0, 0.44444, 0.03704, 0, 0.63055],\n    \"966\": [0.19444, 0.44444, 0, 0, 0.74722],\n    \"967\": [0.19444, 0.44444, 0, 0, 0.71805],\n    \"968\": [0.19444, 0.69444, 0.03704, 0, 0.75833],\n    \"969\": [0, 0.44444, 0.03704, 0, 0.71782],\n    \"977\": [0, 0.69444, 0, 0, 0.69155],\n    \"981\": [0.19444, 0.69444, 0, 0, 0.7125],\n    \"982\": [0, 0.44444, 0.03194, 0, 0.975],\n    \"1009\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"1013\": [0, 0.44444, 0, 0, 0.48333],\n    \"57649\": [0, 0.44444, 0, 0, 0.39352],\n    \"57911\": [0.19444, 0.44444, 0, 0, 0.43889]\n  },\n  \"Math-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.43056, 0, 0, 0.5],\n    \"49\": [0, 0.43056, 0, 0, 0.5],\n    \"50\": [0, 0.43056, 0, 0, 0.5],\n    \"51\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"52\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"53\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"65\": [0, 0.68333, 0, 0.13889, 0.75],\n    \"66\": [0, 0.68333, 0.05017, 0.08334, 0.75851],\n    \"67\": [0, 0.68333, 0.07153, 0.08334, 0.71472],\n    \"68\": [0, 0.68333, 0.02778, 0.05556, 0.82792],\n    \"69\": [0, 0.68333, 0.05764, 0.08334, 0.7382],\n    \"70\": [0, 0.68333, 0.13889, 0.08334, 0.64306],\n    \"71\": [0, 0.68333, 0, 0.08334, 0.78625],\n    \"72\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"73\": [0, 0.68333, 0.07847, 0.11111, 0.43958],\n    \"74\": [0, 0.68333, 0.09618, 0.16667, 0.55451],\n    \"75\": [0, 0.68333, 0.07153, 0.05556, 0.84931],\n    \"76\": [0, 0.68333, 0, 0.02778, 0.68056],\n    \"77\": [0, 0.68333, 0.10903, 0.08334, 0.97014],\n    \"78\": [0, 0.68333, 0.10903, 0.08334, 0.80347],\n    \"79\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"80\": [0, 0.68333, 0.13889, 0.08334, 0.64201],\n    \"81\": [0.19444, 0.68333, 0, 0.08334, 0.79056],\n    \"82\": [0, 0.68333, 0.00773, 0.08334, 0.75929],\n    \"83\": [0, 0.68333, 0.05764, 0.08334, 0.6132],\n    \"84\": [0, 0.68333, 0.13889, 0.08334, 0.58438],\n    \"85\": [0, 0.68333, 0.10903, 0.02778, 0.68278],\n    \"86\": [0, 0.68333, 0.22222, 0, 0.58333],\n    \"87\": [0, 0.68333, 0.13889, 0, 0.94445],\n    \"88\": [0, 0.68333, 0.07847, 0.08334, 0.82847],\n    \"89\": [0, 0.68333, 0.22222, 0, 0.58056],\n    \"90\": [0, 0.68333, 0.07153, 0.08334, 0.68264],\n    \"97\": [0, 0.43056, 0, 0, 0.52859],\n    \"98\": [0, 0.69444, 0, 0, 0.42917],\n    \"99\": [0, 0.43056, 0, 0.05556, 0.43276],\n    \"100\": [0, 0.69444, 0, 0.16667, 0.52049],\n    \"101\": [0, 0.43056, 0, 0.05556, 0.46563],\n    \"102\": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],\n    \"103\": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],\n    \"104\": [0, 0.69444, 0, 0, 0.57616],\n    \"105\": [0, 0.65952, 0, 0, 0.34451],\n    \"106\": [0.19444, 0.65952, 0.05724, 0, 0.41181],\n    \"107\": [0, 0.69444, 0.03148, 0, 0.5206],\n    \"108\": [0, 0.69444, 0.01968, 0.08334, 0.29838],\n    \"109\": [0, 0.43056, 0, 0, 0.87801],\n    \"110\": [0, 0.43056, 0, 0, 0.60023],\n    \"111\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"112\": [0.19444, 0.43056, 0, 0.08334, 0.50313],\n    \"113\": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],\n    \"114\": [0, 0.43056, 0.02778, 0.05556, 0.45116],\n    \"115\": [0, 0.43056, 0, 0.05556, 0.46875],\n    \"116\": [0, 0.61508, 0, 0.08334, 0.36111],\n    \"117\": [0, 0.43056, 0, 0.02778, 0.57246],\n    \"118\": [0, 0.43056, 0.03588, 0.02778, 0.48472],\n    \"119\": [0, 0.43056, 0.02691, 0.08334, 0.71592],\n    \"120\": [0, 0.43056, 0, 0.02778, 0.57153],\n    \"121\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],\n    \"122\": [0, 0.43056, 0.04398, 0.05556, 0.46505],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68333, 0.13889, 0.08334, 0.61528],\n    \"916\": [0, 0.68333, 0, 0.16667, 0.83334],\n    \"920\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"923\": [0, 0.68333, 0, 0.16667, 0.69445],\n    \"926\": [0, 0.68333, 0.07569, 0.08334, 0.74236],\n    \"928\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"931\": [0, 0.68333, 0.05764, 0.08334, 0.77986],\n    \"933\": [0, 0.68333, 0.13889, 0.05556, 0.58333],\n    \"934\": [0, 0.68333, 0, 0.08334, 0.66667],\n    \"936\": [0, 0.68333, 0.11, 0.05556, 0.61222],\n    \"937\": [0, 0.68333, 0.05017, 0.08334, 0.7724],\n    \"945\": [0, 0.43056, 0.0037, 0.02778, 0.6397],\n    \"946\": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],\n    \"947\": [0.19444, 0.43056, 0.05556, 0, 0.51773],\n    \"948\": [0, 0.69444, 0.03785, 0.05556, 0.44444],\n    \"949\": [0, 0.43056, 0, 0.08334, 0.46632],\n    \"950\": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],\n    \"951\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],\n    \"952\": [0, 0.69444, 0.02778, 0.08334, 0.46944],\n    \"953\": [0, 0.43056, 0, 0.05556, 0.35394],\n    \"954\": [0, 0.43056, 0, 0, 0.57616],\n    \"955\": [0, 0.69444, 0, 0, 0.58334],\n    \"956\": [0.19444, 0.43056, 0, 0.02778, 0.60255],\n    \"957\": [0, 0.43056, 0.06366, 0.02778, 0.49398],\n    \"958\": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],\n    \"959\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"960\": [0, 0.43056, 0.03588, 0, 0.57003],\n    \"961\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"962\": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],\n    \"963\": [0, 0.43056, 0.03588, 0, 0.57141],\n    \"964\": [0, 0.43056, 0.1132, 0.02778, 0.43715],\n    \"965\": [0, 0.43056, 0.03588, 0.02778, 0.54028],\n    \"966\": [0.19444, 0.43056, 0, 0.08334, 0.65417],\n    \"967\": [0.19444, 0.43056, 0, 0.05556, 0.62569],\n    \"968\": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],\n    \"969\": [0, 0.43056, 0.03588, 0, 0.62245],\n    \"977\": [0, 0.69444, 0, 0.08334, 0.59144],\n    \"981\": [0.19444, 0.69444, 0, 0.08334, 0.59583],\n    \"982\": [0, 0.43056, 0.02778, 0, 0.82813],\n    \"1009\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"1013\": [0, 0.43056, 0, 0.05556, 0.4059],\n    \"57649\": [0, 0.43056, 0, 0.02778, 0.32246],\n    \"57911\": [0.19444, 0.43056, 0, 0.08334, 0.38403]\n  },\n  \"SansSerif-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.36667],\n    \"34\": [0, 0.69444, 0, 0, 0.55834],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.91667],\n    \"36\": [0.05556, 0.75, 0, 0, 0.55],\n    \"37\": [0.05556, 0.75, 0, 0, 1.02912],\n    \"38\": [0, 0.69444, 0, 0, 0.83056],\n    \"39\": [0, 0.69444, 0, 0, 0.30556],\n    \"40\": [0.25, 0.75, 0, 0, 0.42778],\n    \"41\": [0.25, 0.75, 0, 0, 0.42778],\n    \"42\": [0, 0.75, 0, 0, 0.55],\n    \"43\": [0.11667, 0.61667, 0, 0, 0.85556],\n    \"44\": [0.10556, 0.13056, 0, 0, 0.30556],\n    \"45\": [0, 0.45833, 0, 0, 0.36667],\n    \"46\": [0, 0.13056, 0, 0, 0.30556],\n    \"47\": [0.25, 0.75, 0, 0, 0.55],\n    \"48\": [0, 0.69444, 0, 0, 0.55],\n    \"49\": [0, 0.69444, 0, 0, 0.55],\n    \"50\": [0, 0.69444, 0, 0, 0.55],\n    \"51\": [0, 0.69444, 0, 0, 0.55],\n    \"52\": [0, 0.69444, 0, 0, 0.55],\n    \"53\": [0, 0.69444, 0, 0, 0.55],\n    \"54\": [0, 0.69444, 0, 0, 0.55],\n    \"55\": [0, 0.69444, 0, 0, 0.55],\n    \"56\": [0, 0.69444, 0, 0, 0.55],\n    \"57\": [0, 0.69444, 0, 0, 0.55],\n    \"58\": [0, 0.45833, 0, 0, 0.30556],\n    \"59\": [0.10556, 0.45833, 0, 0, 0.30556],\n    \"61\": [-0.09375, 0.40625, 0, 0, 0.85556],\n    \"63\": [0, 0.69444, 0, 0, 0.51945],\n    \"64\": [0, 0.69444, 0, 0, 0.73334],\n    \"65\": [0, 0.69444, 0, 0, 0.73334],\n    \"66\": [0, 0.69444, 0, 0, 0.73334],\n    \"67\": [0, 0.69444, 0, 0, 0.70278],\n    \"68\": [0, 0.69444, 0, 0, 0.79445],\n    \"69\": [0, 0.69444, 0, 0, 0.64167],\n    \"70\": [0, 0.69444, 0, 0, 0.61111],\n    \"71\": [0, 0.69444, 0, 0, 0.73334],\n    \"72\": [0, 0.69444, 0, 0, 0.79445],\n    \"73\": [0, 0.69444, 0, 0, 0.33056],\n    \"74\": [0, 0.69444, 0, 0, 0.51945],\n    \"75\": [0, 0.69444, 0, 0, 0.76389],\n    \"76\": [0, 0.69444, 0, 0, 0.58056],\n    \"77\": [0, 0.69444, 0, 0, 0.97778],\n    \"78\": [0, 0.69444, 0, 0, 0.79445],\n    \"79\": [0, 0.69444, 0, 0, 0.79445],\n    \"80\": [0, 0.69444, 0, 0, 0.70278],\n    \"81\": [0.10556, 0.69444, 0, 0, 0.79445],\n    \"82\": [0, 0.69444, 0, 0, 0.70278],\n    \"83\": [0, 0.69444, 0, 0, 0.61111],\n    \"84\": [0, 0.69444, 0, 0, 0.73334],\n    \"85\": [0, 0.69444, 0, 0, 0.76389],\n    \"86\": [0, 0.69444, 0.01528, 0, 0.73334],\n    \"87\": [0, 0.69444, 0.01528, 0, 1.03889],\n    \"88\": [0, 0.69444, 0, 0, 0.73334],\n    \"89\": [0, 0.69444, 0.0275, 0, 0.73334],\n    \"90\": [0, 0.69444, 0, 0, 0.67223],\n    \"91\": [0.25, 0.75, 0, 0, 0.34306],\n    \"93\": [0.25, 0.75, 0, 0, 0.34306],\n    \"94\": [0, 0.69444, 0, 0, 0.55],\n    \"95\": [0.35, 0.10833, 0.03056, 0, 0.55],\n    \"97\": [0, 0.45833, 0, 0, 0.525],\n    \"98\": [0, 0.69444, 0, 0, 0.56111],\n    \"99\": [0, 0.45833, 0, 0, 0.48889],\n    \"100\": [0, 0.69444, 0, 0, 0.56111],\n    \"101\": [0, 0.45833, 0, 0, 0.51111],\n    \"102\": [0, 0.69444, 0.07639, 0, 0.33611],\n    \"103\": [0.19444, 0.45833, 0.01528, 0, 0.55],\n    \"104\": [0, 0.69444, 0, 0, 0.56111],\n    \"105\": [0, 0.69444, 0, 0, 0.25556],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.28611],\n    \"107\": [0, 0.69444, 0, 0, 0.53056],\n    \"108\": [0, 0.69444, 0, 0, 0.25556],\n    \"109\": [0, 0.45833, 0, 0, 0.86667],\n    \"110\": [0, 0.45833, 0, 0, 0.56111],\n    \"111\": [0, 0.45833, 0, 0, 0.55],\n    \"112\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"113\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"114\": [0, 0.45833, 0.01528, 0, 0.37222],\n    \"115\": [0, 0.45833, 0, 0, 0.42167],\n    \"116\": [0, 0.58929, 0, 0, 0.40417],\n    \"117\": [0, 0.45833, 0, 0, 0.56111],\n    \"118\": [0, 0.45833, 0.01528, 0, 0.5],\n    \"119\": [0, 0.45833, 0.01528, 0, 0.74445],\n    \"120\": [0, 0.45833, 0, 0, 0.5],\n    \"121\": [0.19444, 0.45833, 0.01528, 0, 0.5],\n    \"122\": [0, 0.45833, 0, 0, 0.47639],\n    \"126\": [0.35, 0.34444, 0, 0, 0.55],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0, 0, 0.55],\n    \"176\": [0, 0.69444, 0, 0, 0.73334],\n    \"180\": [0, 0.69444, 0, 0, 0.55],\n    \"184\": [0.17014, 0, 0, 0, 0.48889],\n    \"305\": [0, 0.45833, 0, 0, 0.25556],\n    \"567\": [0.19444, 0.45833, 0, 0, 0.28611],\n    \"710\": [0, 0.69444, 0, 0, 0.55],\n    \"711\": [0, 0.63542, 0, 0, 0.55],\n    \"713\": [0, 0.63778, 0, 0, 0.55],\n    \"728\": [0, 0.69444, 0, 0, 0.55],\n    \"729\": [0, 0.69444, 0, 0, 0.30556],\n    \"730\": [0, 0.69444, 0, 0, 0.73334],\n    \"732\": [0, 0.69444, 0, 0, 0.55],\n    \"733\": [0, 0.69444, 0, 0, 0.55],\n    \"915\": [0, 0.69444, 0, 0, 0.58056],\n    \"916\": [0, 0.69444, 0, 0, 0.91667],\n    \"920\": [0, 0.69444, 0, 0, 0.85556],\n    \"923\": [0, 0.69444, 0, 0, 0.67223],\n    \"926\": [0, 0.69444, 0, 0, 0.73334],\n    \"928\": [0, 0.69444, 0, 0, 0.79445],\n    \"931\": [0, 0.69444, 0, 0, 0.79445],\n    \"933\": [0, 0.69444, 0, 0, 0.85556],\n    \"934\": [0, 0.69444, 0, 0, 0.79445],\n    \"936\": [0, 0.69444, 0, 0, 0.85556],\n    \"937\": [0, 0.69444, 0, 0, 0.79445],\n    \"8211\": [0, 0.45833, 0.03056, 0, 0.55],\n    \"8212\": [0, 0.45833, 0.03056, 0, 1.10001],\n    \"8216\": [0, 0.69444, 0, 0, 0.30556],\n    \"8217\": [0, 0.69444, 0, 0, 0.30556],\n    \"8220\": [0, 0.69444, 0, 0, 0.55834],\n    \"8221\": [0, 0.69444, 0, 0, 0.55834]\n  },\n  \"SansSerif-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.05733, 0, 0.31945],\n    \"34\": [0, 0.69444, 0.00316, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0.05087, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0.11156, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0.03126, 0, 0.83334],\n    \"38\": [0, 0.69444, 0.03058, 0, 0.75834],\n    \"39\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0.13164, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0.02536, 0, 0.38889],\n    \"42\": [0, 0.75, 0.11775, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0.02536, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0.01946, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0.13164, 0, 0.5],\n    \"48\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"49\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"50\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"51\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"52\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"53\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"54\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"55\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"56\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"57\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"58\": [0, 0.44444, 0.02502, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0.02502, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0.05087, 0, 0.77778],\n    \"63\": [0, 0.69444, 0.11809, 0, 0.47222],\n    \"64\": [0, 0.69444, 0.07555, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0.08293, 0, 0.66667],\n    \"67\": [0, 0.69444, 0.11983, 0, 0.63889],\n    \"68\": [0, 0.69444, 0.07555, 0, 0.72223],\n    \"69\": [0, 0.69444, 0.11983, 0, 0.59722],\n    \"70\": [0, 0.69444, 0.13372, 0, 0.56945],\n    \"71\": [0, 0.69444, 0.11983, 0, 0.66667],\n    \"72\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"73\": [0, 0.69444, 0.13372, 0, 0.27778],\n    \"74\": [0, 0.69444, 0.08094, 0, 0.47222],\n    \"75\": [0, 0.69444, 0.11983, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0.08094, 0, 0.875],\n    \"78\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"79\": [0, 0.69444, 0.07555, 0, 0.73611],\n    \"80\": [0, 0.69444, 0.08293, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0.07555, 0, 0.73611],\n    \"82\": [0, 0.69444, 0.08293, 0, 0.64584],\n    \"83\": [0, 0.69444, 0.09205, 0, 0.55556],\n    \"84\": [0, 0.69444, 0.13372, 0, 0.68056],\n    \"85\": [0, 0.69444, 0.08094, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.1615, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.1615, 0, 0.94445],\n    \"88\": [0, 0.69444, 0.13372, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.17261, 0, 0.66667],\n    \"90\": [0, 0.69444, 0.11983, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0.15942, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0.08719, 0, 0.28889],\n    \"94\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.08616, 0, 0.5],\n    \"97\": [0, 0.44444, 0.00981, 0, 0.48056],\n    \"98\": [0, 0.69444, 0.03057, 0, 0.51667],\n    \"99\": [0, 0.44444, 0.08336, 0, 0.44445],\n    \"100\": [0, 0.69444, 0.09483, 0, 0.51667],\n    \"101\": [0, 0.44444, 0.06778, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.21705, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.10836, 0, 0.5],\n    \"104\": [0, 0.69444, 0.01778, 0, 0.51667],\n    \"105\": [0, 0.67937, 0.09718, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0.09162, 0, 0.26667],\n    \"107\": [0, 0.69444, 0.08336, 0, 0.48889],\n    \"108\": [0, 0.69444, 0.09483, 0, 0.23889],\n    \"109\": [0, 0.44444, 0.01778, 0, 0.79445],\n    \"110\": [0, 0.44444, 0.01778, 0, 0.51667],\n    \"111\": [0, 0.44444, 0.06613, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0.0389, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0.04169, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.10836, 0, 0.34167],\n    \"115\": [0, 0.44444, 0.0778, 0, 0.38333],\n    \"116\": [0, 0.57143, 0.07225, 0, 0.36111],\n    \"117\": [0, 0.44444, 0.04169, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.10836, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.10836, 0, 0.68334],\n    \"120\": [0, 0.44444, 0.09169, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.10836, 0, 0.46111],\n    \"122\": [0, 0.44444, 0.08752, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0.08826, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0.06385, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.73752],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0.04169, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0.04169, 0, 0.26667],\n    \"710\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"711\": [0, 0.63194, 0.08432, 0, 0.5],\n    \"713\": [0, 0.60889, 0.08776, 0, 0.5],\n    \"714\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0.09483, 0, 0.5],\n    \"729\": [0, 0.67937, 0.07774, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.73752],\n    \"732\": [0, 0.67659, 0.08826, 0, 0.5],\n    \"733\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"915\": [0, 0.69444, 0.13372, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0.07555, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0.12816, 0, 0.66667],\n    \"928\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"931\": [0, 0.69444, 0.11983, 0, 0.72222],\n    \"933\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"934\": [0, 0.69444, 0.04603, 0, 0.72222],\n    \"936\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"937\": [0, 0.69444, 0.08293, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.08616, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.08616, 0, 1.0],\n    \"8216\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0.14205, 0, 0.5],\n    \"8221\": [0, 0.69444, 0.00316, 0, 0.5]\n  },\n  \"SansSerif-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.31945],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.75834],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.65556, 0, 0, 0.5],\n    \"49\": [0, 0.65556, 0, 0, 0.5],\n    \"50\": [0, 0.65556, 0, 0, 0.5],\n    \"51\": [0, 0.65556, 0, 0, 0.5],\n    \"52\": [0, 0.65556, 0, 0, 0.5],\n    \"53\": [0, 0.65556, 0, 0, 0.5],\n    \"54\": [0, 0.65556, 0, 0, 0.5],\n    \"55\": [0, 0.65556, 0, 0, 0.5],\n    \"56\": [0, 0.65556, 0, 0, 0.5],\n    \"57\": [0, 0.65556, 0, 0, 0.5],\n    \"58\": [0, 0.44444, 0, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0, 0, 0.66667],\n    \"67\": [0, 0.69444, 0, 0, 0.63889],\n    \"68\": [0, 0.69444, 0, 0, 0.72223],\n    \"69\": [0, 0.69444, 0, 0, 0.59722],\n    \"70\": [0, 0.69444, 0, 0, 0.56945],\n    \"71\": [0, 0.69444, 0, 0, 0.66667],\n    \"72\": [0, 0.69444, 0, 0, 0.70834],\n    \"73\": [0, 0.69444, 0, 0, 0.27778],\n    \"74\": [0, 0.69444, 0, 0, 0.47222],\n    \"75\": [0, 0.69444, 0, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0, 0, 0.875],\n    \"78\": [0, 0.69444, 0, 0, 0.70834],\n    \"79\": [0, 0.69444, 0, 0, 0.73611],\n    \"80\": [0, 0.69444, 0, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0, 0, 0.73611],\n    \"82\": [0, 0.69444, 0, 0, 0.64584],\n    \"83\": [0, 0.69444, 0, 0, 0.55556],\n    \"84\": [0, 0.69444, 0, 0, 0.68056],\n    \"85\": [0, 0.69444, 0, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.01389, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.01389, 0, 0.94445],\n    \"88\": [0, 0.69444, 0, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.025, 0, 0.66667],\n    \"90\": [0, 0.69444, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0, 0, 0.28889],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.02778, 0, 0.5],\n    \"97\": [0, 0.44444, 0, 0, 0.48056],\n    \"98\": [0, 0.69444, 0, 0, 0.51667],\n    \"99\": [0, 0.44444, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.51667],\n    \"101\": [0, 0.44444, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.06944, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.51667],\n    \"105\": [0, 0.67937, 0, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0, 0, 0.26667],\n    \"107\": [0, 0.69444, 0, 0, 0.48889],\n    \"108\": [0, 0.69444, 0, 0, 0.23889],\n    \"109\": [0, 0.44444, 0, 0, 0.79445],\n    \"110\": [0, 0.44444, 0, 0, 0.51667],\n    \"111\": [0, 0.44444, 0, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.01389, 0, 0.34167],\n    \"115\": [0, 0.44444, 0, 0, 0.38333],\n    \"116\": [0, 0.57143, 0, 0, 0.36111],\n    \"117\": [0, 0.44444, 0, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.01389, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.01389, 0, 0.68334],\n    \"120\": [0, 0.44444, 0, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.01389, 0, 0.46111],\n    \"122\": [0, 0.44444, 0, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.66667],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.26667],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.63194, 0, 0, 0.5],\n    \"713\": [0, 0.60889, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.67937, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.66667],\n    \"732\": [0, 0.67659, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.69444, 0, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0, 0, 0.66667],\n    \"928\": [0, 0.69444, 0, 0, 0.70834],\n    \"931\": [0, 0.69444, 0, 0, 0.72222],\n    \"933\": [0, 0.69444, 0, 0, 0.77778],\n    \"934\": [0, 0.69444, 0, 0, 0.72222],\n    \"936\": [0, 0.69444, 0, 0, 0.77778],\n    \"937\": [0, 0.69444, 0, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5]\n  },\n  \"Script-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.7, 0.22925, 0, 0.80253],\n    \"66\": [0, 0.7, 0.04087, 0, 0.90757],\n    \"67\": [0, 0.7, 0.1689, 0, 0.66619],\n    \"68\": [0, 0.7, 0.09371, 0, 0.77443],\n    \"69\": [0, 0.7, 0.18583, 0, 0.56162],\n    \"70\": [0, 0.7, 0.13634, 0, 0.89544],\n    \"71\": [0, 0.7, 0.17322, 0, 0.60961],\n    \"72\": [0, 0.7, 0.29694, 0, 0.96919],\n    \"73\": [0, 0.7, 0.19189, 0, 0.80907],\n    \"74\": [0.27778, 0.7, 0.19189, 0, 1.05159],\n    \"75\": [0, 0.7, 0.31259, 0, 0.91364],\n    \"76\": [0, 0.7, 0.19189, 0, 0.87373],\n    \"77\": [0, 0.7, 0.15981, 0, 1.08031],\n    \"78\": [0, 0.7, 0.3525, 0, 0.9015],\n    \"79\": [0, 0.7, 0.08078, 0, 0.73787],\n    \"80\": [0, 0.7, 0.08078, 0, 1.01262],\n    \"81\": [0, 0.7, 0.03305, 0, 0.88282],\n    \"82\": [0, 0.7, 0.06259, 0, 0.85],\n    \"83\": [0, 0.7, 0.19189, 0, 0.86767],\n    \"84\": [0, 0.7, 0.29087, 0, 0.74697],\n    \"85\": [0, 0.7, 0.25815, 0, 0.79996],\n    \"86\": [0, 0.7, 0.27523, 0, 0.62204],\n    \"87\": [0, 0.7, 0.27523, 0, 0.80532],\n    \"88\": [0, 0.7, 0.26006, 0, 0.94445],\n    \"89\": [0, 0.7, 0.2939, 0, 0.70961],\n    \"90\": [0, 0.7, 0.24037, 0, 0.8212],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Size1-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"41\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"47\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"91\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"92\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"93\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"123\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"125\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.72222, 0, 0, 0.55556],\n    \"732\": [0, 0.72222, 0, 0, 0.55556],\n    \"770\": [0, 0.72222, 0, 0, 0.55556],\n    \"771\": [0, 0.72222, 0, 0, 0.55556],\n    \"8214\": [-0.00099, 0.601, 0, 0, 0.77778],\n    \"8593\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8595\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8657\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8659\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8719\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8720\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8721\": [0.25001, 0.75, 0, 0, 1.05556],\n    \"8730\": [0.35001, 0.85, 0, 0, 1.0],\n    \"8739\": [-0.00599, 0.606, 0, 0, 0.33333],\n    \"8741\": [-0.00599, 0.606, 0, 0, 0.55556],\n    \"8747\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8748\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8749\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8750\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8896\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8897\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8898\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8899\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8968\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8969\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8970\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8971\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"9168\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"10216\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10217\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10752\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10753\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10754\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10756\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"10758\": [0.25001, 0.75, 0, 0, 0.83334]\n  },\n  \"Size2-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"41\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"47\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"91\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"92\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"93\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"123\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"125\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.0],\n    \"732\": [0, 0.75, 0, 0, 1.0],\n    \"770\": [0, 0.75, 0, 0, 1.0],\n    \"771\": [0, 0.75, 0, 0, 1.0],\n    \"8719\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8720\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8721\": [0.55001, 1.05, 0, 0, 1.44445],\n    \"8730\": [0.65002, 1.15, 0, 0, 1.0],\n    \"8747\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8748\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8749\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8750\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8896\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8897\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8898\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8899\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8968\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8969\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8970\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8971\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"10216\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10217\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10752\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10753\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10754\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10756\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"10758\": [0.55001, 1.05, 0, 0, 1.11111]\n  },\n  \"Size3-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"41\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"47\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"91\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"92\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"93\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"123\": [0.95003, 1.45, 0, 0, 0.75],\n    \"125\": [0.95003, 1.45, 0, 0, 0.75],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.44445],\n    \"732\": [0, 0.75, 0, 0, 1.44445],\n    \"770\": [0, 0.75, 0, 0, 1.44445],\n    \"771\": [0, 0.75, 0, 0, 1.44445],\n    \"8730\": [0.95003, 1.45, 0, 0, 1.0],\n    \"8968\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8969\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8970\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8971\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"10216\": [0.95003, 1.45, 0, 0, 0.75],\n    \"10217\": [0.95003, 1.45, 0, 0, 0.75]\n  },\n  \"Size4-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"41\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"47\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"91\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"92\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"93\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"123\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"125\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.825, 0, 0, 1.8889],\n    \"732\": [0, 0.825, 0, 0, 1.8889],\n    \"770\": [0, 0.825, 0, 0, 1.8889],\n    \"771\": [0, 0.825, 0, 0, 1.8889],\n    \"8730\": [1.25003, 1.75, 0, 0, 1.0],\n    \"8968\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8969\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8970\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8971\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"9115\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9116\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9117\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9118\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9119\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9120\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9121\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9122\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9123\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9124\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9125\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9126\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9127\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9128\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9129\": [0.90001, 0, 0, 0, 0.88889],\n    \"9130\": [0, 0.3, 0, 0, 0.88889],\n    \"9131\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9132\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9133\": [0.90001, 0, 0, 0, 0.88889],\n    \"9143\": [0.88502, 0.915, 0, 0, 1.05556],\n    \"10216\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"10217\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"57344\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57345\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57680\": [0, 0.12, 0, 0, 0.45],\n    \"57681\": [0, 0.12, 0, 0, 0.45],\n    \"57682\": [0, 0.12, 0, 0, 0.45],\n    \"57683\": [0, 0.12, 0, 0, 0.45]\n  },\n  \"Typewriter-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.525],\n    \"33\": [0, 0.61111, 0, 0, 0.525],\n    \"34\": [0, 0.61111, 0, 0, 0.525],\n    \"35\": [0, 0.61111, 0, 0, 0.525],\n    \"36\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"37\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"38\": [0, 0.61111, 0, 0, 0.525],\n    \"39\": [0, 0.61111, 0, 0, 0.525],\n    \"40\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"41\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"42\": [0, 0.52083, 0, 0, 0.525],\n    \"43\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"44\": [0.13889, 0.125, 0, 0, 0.525],\n    \"45\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"46\": [0, 0.125, 0, 0, 0.525],\n    \"47\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"48\": [0, 0.61111, 0, 0, 0.525],\n    \"49\": [0, 0.61111, 0, 0, 0.525],\n    \"50\": [0, 0.61111, 0, 0, 0.525],\n    \"51\": [0, 0.61111, 0, 0, 0.525],\n    \"52\": [0, 0.61111, 0, 0, 0.525],\n    \"53\": [0, 0.61111, 0, 0, 0.525],\n    \"54\": [0, 0.61111, 0, 0, 0.525],\n    \"55\": [0, 0.61111, 0, 0, 0.525],\n    \"56\": [0, 0.61111, 0, 0, 0.525],\n    \"57\": [0, 0.61111, 0, 0, 0.525],\n    \"58\": [0, 0.43056, 0, 0, 0.525],\n    \"59\": [0.13889, 0.43056, 0, 0, 0.525],\n    \"60\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"61\": [-0.19549, 0.41562, 0, 0, 0.525],\n    \"62\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"63\": [0, 0.61111, 0, 0, 0.525],\n    \"64\": [0, 0.61111, 0, 0, 0.525],\n    \"65\": [0, 0.61111, 0, 0, 0.525],\n    \"66\": [0, 0.61111, 0, 0, 0.525],\n    \"67\": [0, 0.61111, 0, 0, 0.525],\n    \"68\": [0, 0.61111, 0, 0, 0.525],\n    \"69\": [0, 0.61111, 0, 0, 0.525],\n    \"70\": [0, 0.61111, 0, 0, 0.525],\n    \"71\": [0, 0.61111, 0, 0, 0.525],\n    \"72\": [0, 0.61111, 0, 0, 0.525],\n    \"73\": [0, 0.61111, 0, 0, 0.525],\n    \"74\": [0, 0.61111, 0, 0, 0.525],\n    \"75\": [0, 0.61111, 0, 0, 0.525],\n    \"76\": [0, 0.61111, 0, 0, 0.525],\n    \"77\": [0, 0.61111, 0, 0, 0.525],\n    \"78\": [0, 0.61111, 0, 0, 0.525],\n    \"79\": [0, 0.61111, 0, 0, 0.525],\n    \"80\": [0, 0.61111, 0, 0, 0.525],\n    \"81\": [0.13889, 0.61111, 0, 0, 0.525],\n    \"82\": [0, 0.61111, 0, 0, 0.525],\n    \"83\": [0, 0.61111, 0, 0, 0.525],\n    \"84\": [0, 0.61111, 0, 0, 0.525],\n    \"85\": [0, 0.61111, 0, 0, 0.525],\n    \"86\": [0, 0.61111, 0, 0, 0.525],\n    \"87\": [0, 0.61111, 0, 0, 0.525],\n    \"88\": [0, 0.61111, 0, 0, 0.525],\n    \"89\": [0, 0.61111, 0, 0, 0.525],\n    \"90\": [0, 0.61111, 0, 0, 0.525],\n    \"91\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"92\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"93\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"94\": [0, 0.61111, 0, 0, 0.525],\n    \"95\": [0.09514, 0, 0, 0, 0.525],\n    \"96\": [0, 0.61111, 0, 0, 0.525],\n    \"97\": [0, 0.43056, 0, 0, 0.525],\n    \"98\": [0, 0.61111, 0, 0, 0.525],\n    \"99\": [0, 0.43056, 0, 0, 0.525],\n    \"100\": [0, 0.61111, 0, 0, 0.525],\n    \"101\": [0, 0.43056, 0, 0, 0.525],\n    \"102\": [0, 0.61111, 0, 0, 0.525],\n    \"103\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"104\": [0, 0.61111, 0, 0, 0.525],\n    \"105\": [0, 0.61111, 0, 0, 0.525],\n    \"106\": [0.22222, 0.61111, 0, 0, 0.525],\n    \"107\": [0, 0.61111, 0, 0, 0.525],\n    \"108\": [0, 0.61111, 0, 0, 0.525],\n    \"109\": [0, 0.43056, 0, 0, 0.525],\n    \"110\": [0, 0.43056, 0, 0, 0.525],\n    \"111\": [0, 0.43056, 0, 0, 0.525],\n    \"112\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"113\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"114\": [0, 0.43056, 0, 0, 0.525],\n    \"115\": [0, 0.43056, 0, 0, 0.525],\n    \"116\": [0, 0.55358, 0, 0, 0.525],\n    \"117\": [0, 0.43056, 0, 0, 0.525],\n    \"118\": [0, 0.43056, 0, 0, 0.525],\n    \"119\": [0, 0.43056, 0, 0, 0.525],\n    \"120\": [0, 0.43056, 0, 0, 0.525],\n    \"121\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"122\": [0, 0.43056, 0, 0, 0.525],\n    \"123\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"124\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"125\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"126\": [0, 0.61111, 0, 0, 0.525],\n    \"127\": [0, 0.61111, 0, 0, 0.525],\n    \"160\": [0, 0, 0, 0, 0.525],\n    \"176\": [0, 0.61111, 0, 0, 0.525],\n    \"184\": [0.19445, 0, 0, 0, 0.525],\n    \"305\": [0, 0.43056, 0, 0, 0.525],\n    \"567\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"711\": [0, 0.56597, 0, 0, 0.525],\n    \"713\": [0, 0.56555, 0, 0, 0.525],\n    \"714\": [0, 0.61111, 0, 0, 0.525],\n    \"715\": [0, 0.61111, 0, 0, 0.525],\n    \"728\": [0, 0.61111, 0, 0, 0.525],\n    \"730\": [0, 0.61111, 0, 0, 0.525],\n    \"770\": [0, 0.61111, 0, 0, 0.525],\n    \"771\": [0, 0.61111, 0, 0, 0.525],\n    \"776\": [0, 0.61111, 0, 0, 0.525],\n    \"915\": [0, 0.61111, 0, 0, 0.525],\n    \"916\": [0, 0.61111, 0, 0, 0.525],\n    \"920\": [0, 0.61111, 0, 0, 0.525],\n    \"923\": [0, 0.61111, 0, 0, 0.525],\n    \"926\": [0, 0.61111, 0, 0, 0.525],\n    \"928\": [0, 0.61111, 0, 0, 0.525],\n    \"931\": [0, 0.61111, 0, 0, 0.525],\n    \"933\": [0, 0.61111, 0, 0, 0.525],\n    \"934\": [0, 0.61111, 0, 0, 0.525],\n    \"936\": [0, 0.61111, 0, 0, 0.525],\n    \"937\": [0, 0.61111, 0, 0, 0.525],\n    \"8216\": [0, 0.61111, 0, 0, 0.525],\n    \"8217\": [0, 0.61111, 0, 0, 0.525],\n    \"8242\": [0, 0.61111, 0, 0, 0.525],\n    \"9251\": [0.11111, 0.21944, 0, 0, 0.525]\n  }\n};\n\n/**\n * This file contains metrics regarding fonts and individual symbols. The sigma\n * and xi variables, as well as the metricMap map contain data extracted from\n * TeX, TeX font metrics, and the TTF files. These data are then exposed via the\n * `metrics` variable and the getCharacterMetrics function.\n */\n// In TeX, there are actually three sets of dimensions, one for each of\n// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:\n// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are\n// provided in the arrays below, in that order.\n//\n// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respectively.\n// This was determined by running the following script:\n//\n//     latex -interaction=nonstopmode \\\n//     '\\documentclass{article}\\usepackage{amsmath}\\begin{document}' \\\n//     '$a$ \\expandafter\\show\\the\\textfont2' \\\n//     '\\expandafter\\show\\the\\scriptfont2' \\\n//     '\\expandafter\\show\\the\\scriptscriptfont2' \\\n//     '\\stop'\n//\n// The metrics themselves were retrieved using the following commands:\n//\n//     tftopl cmsy10\n//     tftopl cmsy7\n//     tftopl cmsy5\n//\n// The output of each of these commands is quite lengthy.  The only part we\n// care about is the FONTDIMEN section. Each value is measured in EMs.\nvar sigmasAndXis = {\n  slant: [0.250, 0.250, 0.250],\n  // sigma1\n  space: [0.000, 0.000, 0.000],\n  // sigma2\n  stretch: [0.000, 0.000, 0.000],\n  // sigma3\n  shrink: [0.000, 0.000, 0.000],\n  // sigma4\n  xHeight: [0.431, 0.431, 0.431],\n  // sigma5\n  quad: [1.000, 1.171, 1.472],\n  // sigma6\n  extraSpace: [0.000, 0.000, 0.000],\n  // sigma7\n  num1: [0.677, 0.732, 0.925],\n  // sigma8\n  num2: [0.394, 0.384, 0.387],\n  // sigma9\n  num3: [0.444, 0.471, 0.504],\n  // sigma10\n  denom1: [0.686, 0.752, 1.025],\n  // sigma11\n  denom2: [0.345, 0.344, 0.532],\n  // sigma12\n  sup1: [0.413, 0.503, 0.504],\n  // sigma13\n  sup2: [0.363, 0.431, 0.404],\n  // sigma14\n  sup3: [0.289, 0.286, 0.294],\n  // sigma15\n  sub1: [0.150, 0.143, 0.200],\n  // sigma16\n  sub2: [0.247, 0.286, 0.400],\n  // sigma17\n  supDrop: [0.386, 0.353, 0.494],\n  // sigma18\n  subDrop: [0.050, 0.071, 0.100],\n  // sigma19\n  delim1: [2.390, 1.700, 1.980],\n  // sigma20\n  delim2: [1.010, 1.157, 1.420],\n  // sigma21\n  axisHeight: [0.250, 0.250, 0.250],\n  // sigma22\n  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;\n  // they correspond to the font parameters of the extension fonts (family 3).\n  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to\n  // match cmex7, we'd use cmex7.tfm values for script and scriptscript\n  // values.\n  defaultRuleThickness: [0.04, 0.049, 0.049],\n  // xi8; cmex7: 0.049\n  bigOpSpacing1: [0.111, 0.111, 0.111],\n  // xi9\n  bigOpSpacing2: [0.166, 0.166, 0.166],\n  // xi10\n  bigOpSpacing3: [0.2, 0.2, 0.2],\n  // xi11\n  bigOpSpacing4: [0.6, 0.611, 0.611],\n  // xi12; cmex7: 0.611\n  bigOpSpacing5: [0.1, 0.143, 0.143],\n  // xi13; cmex7: 0.143\n  // The \\sqrt rule width is taken from the height of the surd character.\n  // Since we use the same font at all sizes, this thickness doesn't scale.\n  sqrtRuleThickness: [0.04, 0.04, 0.04],\n  // This value determines how large a pt is, for metrics which are defined\n  // in terms of pts.\n  // This value is also used in katex.scss; if you change it make sure the\n  // values match.\n  ptPerEm: [10.0, 10.0, 10.0],\n  // The space between adjacent `|` columns in an array definition. From\n  // `\\showthe\\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.\n  doubleRuleSep: [0.2, 0.2, 0.2],\n  // The width of separator lines in {array} environments. From\n  // `\\showthe\\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.\n  arrayRuleWidth: [0.04, 0.04, 0.04],\n  // Two values from LaTeX source2e:\n  fboxsep: [0.3, 0.3, 0.3],\n  //        3 pt / ptPerEm\n  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm\n\n}; // This map contains a mapping from font name and character code to character\n// should have Latin-1 and Cyrillic characters, but may not depending on the\n// operating system.  The metrics do not account for extra height from the\n// accents.  In the case of Cyrillic characters which have both ascenders and\n// descenders we prefer approximations with ascenders, primarily to prevent\n// the fraction bar or root line from intersecting the glyph.\n// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.\n\nvar extraCharacterMap = {\n  // Latin-1\n  '': 'A',\n  '': 'D',\n  '': 'o',\n  '': 'a',\n  '': 'd',\n  '': 'o',\n  // Cyrillic\n  '': 'A',\n  '': 'B',\n  '': 'B',\n  '': 'F',\n  '': 'A',\n  '': 'E',\n  '': 'K',\n  '': '3',\n  '': 'N',\n  '': 'N',\n  '': 'K',\n  '': 'N',\n  '': 'M',\n  '': 'H',\n  '': 'O',\n  '': 'N',\n  '': 'P',\n  '': 'C',\n  '': 'T',\n  '': 'y',\n  '': 'O',\n  '': 'X',\n  '': 'U',\n  '': 'h',\n  '': 'W',\n  '': 'W',\n  '': 'B',\n  '': 'X',\n  '': 'B',\n  '': '3',\n  '': 'X',\n  '': 'R',\n  '': 'a',\n  '': 'b',\n  '': 'a',\n  '': 'r',\n  '': 'y',\n  '': 'e',\n  '': 'm',\n  '': 'e',\n  '': 'n',\n  '': 'n',\n  '': 'n',\n  '': 'n',\n  '': 'm',\n  '': 'n',\n  '': 'o',\n  '': 'n',\n  '': 'p',\n  '': 'c',\n  '': 'o',\n  '': 'y',\n  '': 'b',\n  '': 'x',\n  '': 'n',\n  '': 'n',\n  '': 'w',\n  '': 'w',\n  '': 'a',\n  '': 'm',\n  '': 'a',\n  '': 'e',\n  '': 'm',\n  '': 'r'\n};\n\n/**\n * This function adds new font metrics to default metricMap\n * It can also override existing metrics\n */\nfunction setFontMetrics(fontName, metrics) {\n  fontMetricsData[fontName] = metrics;\n}\n/**\n * This function is a convenience function for looking up information in the\n * metricMap table. It takes a character as a string, and a font.\n *\n * Note: the `width` property may be undefined if fontMetricsData.js wasn't\n * built using `Make extended_metrics`.\n */\n\nfunction getCharacterMetrics(character, font, mode) {\n  if (!fontMetricsData[font]) {\n    throw new Error(\"Font metrics not found for font: \" + font + \".\");\n  }\n\n  var ch = character.charCodeAt(0);\n  var metrics = fontMetricsData[font][ch];\n\n  if (!metrics && character[0] in extraCharacterMap) {\n    ch = extraCharacterMap[character[0]].charCodeAt(0);\n    metrics = fontMetricsData[font][ch];\n  }\n\n  if (!metrics && mode === 'text') {\n    // We don't typically have font metrics for Asian scripts.\n    // But since we support them in text mode, we need to return\n    // some sort of metrics.\n    // So if the character is in a script we support but we\n    // don't have metrics for it, just use the metrics for\n    // the Latin capital letter M. This is close enough because\n    // we (currently) only care about the height of the glyph\n    // not its width.\n    if (supportedCodepoint(ch)) {\n      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'\n    }\n  }\n\n  if (metrics) {\n    return {\n      depth: metrics[0],\n      height: metrics[1],\n      italic: metrics[2],\n      skew: metrics[3],\n      width: metrics[4]\n    };\n  }\n}\nvar fontMetricsBySizeIndex = {};\n/**\n * Get the font metrics for a given size.\n */\n\nfunction getGlobalMetrics(size) {\n  var sizeIndex;\n\n  if (size >= 5) {\n    sizeIndex = 0;\n  } else if (size >= 3) {\n    sizeIndex = 1;\n  } else {\n    sizeIndex = 2;\n  }\n\n  if (!fontMetricsBySizeIndex[sizeIndex]) {\n    var metrics = fontMetricsBySizeIndex[sizeIndex] = {\n      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18\n    };\n\n    for (var key in sigmasAndXis) {\n      if (sigmasAndXis.hasOwnProperty(key)) {\n        metrics[key] = sigmasAndXis[key][sizeIndex];\n      }\n    }\n  }\n\n  return fontMetricsBySizeIndex[sizeIndex];\n}\n\n/**\n * This file contains information about the options that the Parser carries\n * around with it while parsing. Data is held in an `Options` object, and when\n * recursing, a new `Options` object can be created with the `.with*` and\n * `.reset` functions.\n */\nvar sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].\n// The size mappings are taken from TeX with \\normalsize=10pt.\n[1, 1, 1], // size1: [5, 5, 5]              \\tiny\n[2, 1, 1], // size2: [6, 5, 5]\n[3, 1, 1], // size3: [7, 5, 5]              \\scriptsize\n[4, 2, 1], // size4: [8, 6, 5]              \\footnotesize\n[5, 2, 1], // size5: [9, 6, 5]              \\small\n[6, 3, 1], // size6: [10, 7, 5]             \\normalsize\n[7, 4, 2], // size7: [12, 8, 6]             \\large\n[8, 6, 3], // size8: [14.4, 10, 7]          \\Large\n[9, 7, 6], // size9: [17.28, 12, 10]        \\LARGE\n[10, 8, 7], // size10: [20.74, 14.4, 12]     \\huge\n[11, 10, 9] // size11: [24.88, 20.74, 17.28] \\HUGE\n];\nvar sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if\n// you change size indexes, change that function.\n0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];\n\nvar sizeAtStyle = function sizeAtStyle(size, style) {\n  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];\n}; // In these types, \"\" (empty string) means \"no change\".\n\n\n/**\n * This is the main options class. It contains the current style, size, color,\n * and font.\n *\n * Options objects should not be modified. To create a new Options with\n * different properties, call a `.having*` method.\n */\nclass Options {\n  // A font family applies to a group of fonts (i.e. SansSerif), while a font\n  // represents a specific font (i.e. SansSerif Bold).\n  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm\n\n  /**\n   * The base size index.\n   */\n  constructor(data) {\n    this.style = void 0;\n    this.color = void 0;\n    this.size = void 0;\n    this.textSize = void 0;\n    this.phantom = void 0;\n    this.font = void 0;\n    this.fontFamily = void 0;\n    this.fontWeight = void 0;\n    this.fontShape = void 0;\n    this.sizeMultiplier = void 0;\n    this.maxSize = void 0;\n    this.minRuleThickness = void 0;\n    this._fontMetrics = void 0;\n    this.style = data.style;\n    this.color = data.color;\n    this.size = data.size || Options.BASESIZE;\n    this.textSize = data.textSize || this.size;\n    this.phantom = !!data.phantom;\n    this.font = data.font || \"\";\n    this.fontFamily = data.fontFamily || \"\";\n    this.fontWeight = data.fontWeight || '';\n    this.fontShape = data.fontShape || '';\n    this.sizeMultiplier = sizeMultipliers[this.size - 1];\n    this.maxSize = data.maxSize;\n    this.minRuleThickness = data.minRuleThickness;\n    this._fontMetrics = undefined;\n  }\n  /**\n   * Returns a new options object with the same properties as \"this\".  Properties\n   * from \"extension\" will be copied to the new options object.\n   */\n\n\n  extend(extension) {\n    var data = {\n      style: this.style,\n      size: this.size,\n      textSize: this.textSize,\n      color: this.color,\n      phantom: this.phantom,\n      font: this.font,\n      fontFamily: this.fontFamily,\n      fontWeight: this.fontWeight,\n      fontShape: this.fontShape,\n      maxSize: this.maxSize,\n      minRuleThickness: this.minRuleThickness\n    };\n\n    for (var key in extension) {\n      if (extension.hasOwnProperty(key)) {\n        data[key] = extension[key];\n      }\n    }\n\n    return new Options(data);\n  }\n  /**\n   * Return an options object with the given style. If `this.style === style`,\n   * returns `this`.\n   */\n\n\n  havingStyle(style) {\n    if (this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: sizeAtStyle(this.textSize, style)\n      });\n    }\n  }\n  /**\n   * Return an options object with a cramped version of the current style. If\n   * the current style is cramped, returns `this`.\n   */\n\n\n  havingCrampedStyle() {\n    return this.havingStyle(this.style.cramp());\n  }\n  /**\n   * Return an options object with the given size and in at least `\\textstyle`.\n   * Returns `this` if appropriate.\n   */\n\n\n  havingSize(size) {\n    if (this.size === size && this.textSize === size) {\n      return this;\n    } else {\n      return this.extend({\n        style: this.style.text(),\n        size: size,\n        textSize: size,\n        sizeMultiplier: sizeMultipliers[size - 1]\n      });\n    }\n  }\n  /**\n   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,\n   * changes to at least `\\textstyle`.\n   */\n\n\n  havingBaseStyle(style) {\n    style = style || this.style.text();\n    var wantSize = sizeAtStyle(Options.BASESIZE, style);\n\n    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: wantSize\n      });\n    }\n  }\n  /**\n   * Remove the effect of sizing changes such as \\Huge.\n   * Keep the effect of the current style, such as \\scriptstyle.\n   */\n\n\n  havingBaseSizing() {\n    var size;\n\n    switch (this.style.id) {\n      case 4:\n      case 5:\n        size = 3; // normalsize in scriptstyle\n\n        break;\n\n      case 6:\n      case 7:\n        size = 1; // normalsize in scriptscriptstyle\n\n        break;\n\n      default:\n        size = 6;\n      // normalsize in textstyle or displaystyle\n    }\n\n    return this.extend({\n      style: this.style.text(),\n      size: size\n    });\n  }\n  /**\n   * Create a new options object with the given color.\n   */\n\n\n  withColor(color) {\n    return this.extend({\n      color: color\n    });\n  }\n  /**\n   * Create a new options object with \"phantom\" set to true.\n   */\n\n\n  withPhantom() {\n    return this.extend({\n      phantom: true\n    });\n  }\n  /**\n   * Creates a new options object with the given math font or old text font.\n   * @type {[type]}\n   */\n\n\n  withFont(font) {\n    return this.extend({\n      font\n    });\n  }\n  /**\n   * Create a new options objects with the given fontFamily.\n   */\n\n\n  withTextFontFamily(fontFamily) {\n    return this.extend({\n      fontFamily,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontWeight(fontWeight) {\n    return this.extend({\n      fontWeight,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontShape(fontShape) {\n    return this.extend({\n      fontShape,\n      font: \"\"\n    });\n  }\n  /**\n   * Return the CSS sizing classes required to switch from enclosing options\n   * `oldOptions` to `this`. Returns an array of classes.\n   */\n\n\n  sizingClasses(oldOptions) {\n    if (oldOptions.size !== this.size) {\n      return [\"sizing\", \"reset-size\" + oldOptions.size, \"size\" + this.size];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the CSS sizing classes required to switch to the base size. Like\n   * `this.havingSize(BASESIZE).sizingClasses(this)`.\n   */\n\n\n  baseSizingClasses() {\n    if (this.size !== Options.BASESIZE) {\n      return [\"sizing\", \"reset-size\" + this.size, \"size\" + Options.BASESIZE];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the font metrics for this size.\n   */\n\n\n  fontMetrics() {\n    if (!this._fontMetrics) {\n      this._fontMetrics = getGlobalMetrics(this.size);\n    }\n\n    return this._fontMetrics;\n  }\n  /**\n   * Gets the CSS color of the current options object\n   */\n\n\n  getColor() {\n    if (this.phantom) {\n      return \"transparent\";\n    } else {\n      return this.color;\n    }\n  }\n\n}\n\nOptions.BASESIZE = 6;\n\n/**\n * This file does conversion between units.  In particular, it provides\n * calculateSize to convert other units into ems.\n */\n// Thus, multiplying a length by this number converts the length from units\n// into pts.  Dividing the result by ptPerEm gives the number of ems\n// *assuming* a font size of ptPerEm (normal size, normal style).\n\nvar ptPerUnit = {\n  // https://en.wikibooks.org/wiki/LaTeX/Lengths and\n  // https://tex.stackexchange.com/a/8263\n  \"pt\": 1,\n  // TeX point\n  \"mm\": 7227 / 2540,\n  // millimeter\n  \"cm\": 7227 / 254,\n  // centimeter\n  \"in\": 72.27,\n  // inch\n  \"bp\": 803 / 800,\n  // big (PostScript) points\n  \"pc\": 12,\n  // pica\n  \"dd\": 1238 / 1157,\n  // didot\n  \"cc\": 14856 / 1157,\n  // cicero (12 didot)\n  \"nd\": 685 / 642,\n  // new didot\n  \"nc\": 1370 / 107,\n  // new cicero (12 new didot)\n  \"sp\": 1 / 65536,\n  // scaled point (TeX's internal smallest unit)\n  // https://tex.stackexchange.com/a/41371\n  \"px\": 803 / 800 // \\pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX\n\n}; // Dictionary of relative units, for fast validity testing.\n\nvar relativeUnit = {\n  \"ex\": true,\n  \"em\": true,\n  \"mu\": true\n};\n\n/**\n * Determine whether the specified unit (either a string defining the unit\n * or a \"size\" parse node containing a unit field) is valid.\n */\nvar validUnit = function validUnit(unit) {\n  if (typeof unit !== \"string\") {\n    unit = unit.unit;\n  }\n\n  return unit in ptPerUnit || unit in relativeUnit || unit === \"ex\";\n};\n/*\n * Convert a \"size\" parse node (with numeric \"number\" and string \"unit\" fields,\n * as parsed by functions.js argType \"size\") into a CSS em value for the\n * current style/scale.  `options` gives the current options.\n */\n\nvar calculateSize = function calculateSize(sizeValue, options) {\n  var scale;\n\n  if (sizeValue.unit in ptPerUnit) {\n    // Absolute units\n    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt\n    / options.fontMetrics().ptPerEm // Convert pt to CSS em\n    / options.sizeMultiplier; // Unscale to make absolute units\n  } else if (sizeValue.unit === \"mu\") {\n    // `mu` units scale with scriptstyle/scriptscriptstyle.\n    scale = options.fontMetrics().cssEmPerMu;\n  } else {\n    // Other relative units always refer to the *textstyle* font\n    // in the current size.\n    var unitOptions;\n\n    if (options.style.isTight()) {\n      // isTight() means current style is script/scriptscript.\n      unitOptions = options.havingStyle(options.style.text());\n    } else {\n      unitOptions = options;\n    } // TODO: In TeX these units are relative to the quad of the current\n    // *text* font, e.g. cmr10. KaTeX instead uses values from the\n    // comparably-sized *Computer Modern symbol* font. At 10pt, these\n    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;\n    // cmr5=1.361133, cmsy5=1.472241. Consider $\\scriptsize a\\kern1emb$.\n    // TeX \\showlists shows a kern of 1.13889 * fontsize;\n    // KaTeX shows a kern of 1.171 * fontsize.\n\n\n    if (sizeValue.unit === \"ex\") {\n      scale = unitOptions.fontMetrics().xHeight;\n    } else if (sizeValue.unit === \"em\") {\n      scale = unitOptions.fontMetrics().quad;\n    } else {\n      throw new ParseError(\"Invalid unit: '\" + sizeValue.unit + \"'\");\n    }\n\n    if (unitOptions !== options) {\n      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;\n    }\n  }\n\n  return Math.min(sizeValue.number * scale, options.maxSize);\n};\n/**\n * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See\n * https://github.com/KaTeX/KaTeX/pull/2460.\n */\n\nvar makeEm = function makeEm(n) {\n  return +n.toFixed(4) + \"em\";\n};\n\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n *\n * TODO: refactor `span` and `anchor` into common superclass when\n * target environments support class inheritance\n */\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove empty classes.\n */\nvar createClass = function createClass(classes) {\n  return classes.filter(cls => cls).join(\" \");\n};\n\nvar initNode = function initNode(classes, options, style) {\n  this.classes = classes || [];\n  this.attributes = {};\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n  this.style = style || {};\n\n  if (options) {\n    if (options.style.isTight()) {\n      this.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      this.style.color = color;\n    }\n  }\n};\n/**\n * Convert into an HTML node\n */\n\n\nvar toNode = function toNode(tagName) {\n  var node = document.createElement(tagName); // Apply the class\n\n  node.className = createClass(this.classes); // Apply inline styles\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      // $FlowFixMe Flow doesn't seem to understand span.style's type.\n      node.style[style] = this.style[style];\n    }\n  } // Apply attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  } // Append the children, also as HTML nodes\n\n\n  for (var i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n\n  return node;\n};\n/**\n * Convert into an HTML markup string\n */\n\n\nvar toMarkup = function toMarkup(tagName) {\n  var markup = \"<\" + tagName; // Add the class\n\n  if (this.classes.length) {\n    markup += \" class=\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n  }\n\n  var styles = \"\"; // Add the styles, after hyphenation\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  } // Add the attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n    }\n  }\n\n  markup += \">\"; // Add the markup of the children, also as markup\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</\" + tagName + \">\";\n  return markup;\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n// This type does not include all CSS properties. Additional properties should\n// be added as needed.\n\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n *\n * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan\n * otherwise. This typesafety is important when HTML builders access a span's\n * children.\n */\nclass Span {\n  constructor(classes, children, options, style) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options, style);\n    this.children = children || [];\n  }\n  /**\n   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not\n   * all browsers support attributes the same, and having too many custom\n   * attributes is probably bad.\n   */\n\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"span\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"span\");\n  }\n\n}\n/**\n * This node represents an anchor (<a>) element with a hyperlink.  See `span`\n * for further details.\n */\n\nclass Anchor {\n  constructor(href, classes, children, options) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options);\n    this.children = children || [];\n    this.setAttribute('href', href);\n  }\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"a\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"a\");\n  }\n\n}\n/**\n * This node represents an image embed (<img>) element.\n */\n\nclass Img {\n  constructor(src, alt, style) {\n    this.src = void 0;\n    this.alt = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.alt = alt;\n    this.src = src;\n    this.classes = [\"mord\"];\n    this.style = style;\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n\n  toNode() {\n    var node = document.createElement(\"img\");\n    node.src = this.src;\n    node.alt = this.alt;\n    node.className = \"mord\"; // Apply inline styles\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        // $FlowFixMe\n        node.style[style] = this.style[style];\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<img src=\\\"\" + utils.escape(this.src) + \"\\\"\" + (\" alt=\\\"\" + utils.escape(this.alt) + \"\\\"\"); // Add the styles, after hyphenation\n\n    var styles = \"\";\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    markup += \"'/>\";\n    return markup;\n  }\n\n}\nvar iCombinations = {\n  '': '\\u0131\\u0302',\n  '': '\\u0131\\u0308',\n  '': '\\u0131\\u0301',\n  // '': '\\u0131\\u0304', // enable when we add Extended Latin\n  '': '\\u0131\\u0300'\n};\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\n\nclass SymbolNode {\n  constructor(text, height, depth, italic, skew, width, classes, style) {\n    this.text = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.italic = void 0;\n    this.skew = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.classes = void 0;\n    this.style = void 0;\n    this.text = text;\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.width = width || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we\n    // can specify which fonts to use.  This allows us to render these\n    // characters with a serif font in situations where the browser would\n    // either default to a sans serif or render a placeholder character.\n    // We use CSS class names like cjk_fallback, hangul_fallback and\n    // brahmic_fallback. See ./unicodeScripts.js for the set of possible\n    // script names\n\n    var script = scriptFromCodepoint(this.text.charCodeAt(0));\n\n    if (script) {\n      this.classes.push(script + \"_fallback\");\n    }\n\n    if (/[]/.test(this.text)) {\n      // add  when we add Extended Latin\n      this.text = iCombinations[this.text];\n    }\n  }\n\n  hasClass(className) {\n    return utils.contains(this.classes, className);\n  }\n  /**\n   * Creates a text node or span from a symbol node. Note that a span is only\n   * created if it is needed.\n   */\n\n\n  toNode() {\n    var node = document.createTextNode(this.text);\n    var span = null;\n\n    if (this.italic > 0) {\n      span = document.createElement(\"span\");\n      span.style.marginRight = makeEm(this.italic);\n    }\n\n    if (this.classes.length > 0) {\n      span = span || document.createElement(\"span\");\n      span.className = createClass(this.classes);\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        span = span || document.createElement(\"span\"); // $FlowFixMe Flow doesn't seem to understand span.style's type.\n\n        span.style[style] = this.style[style];\n      }\n    }\n\n    if (span) {\n      span.appendChild(node);\n      return span;\n    } else {\n      return node;\n    }\n  }\n  /**\n   * Creates markup for a symbol node.\n   */\n\n\n  toMarkup() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    var needsSpan = false;\n    var markup = \"<span\";\n\n    if (this.classes.length) {\n      needsSpan = true;\n      markup += \" class=\\\"\";\n      markup += utils.escape(createClass(this.classes));\n      markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    if (this.italic > 0) {\n      styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      needsSpan = true;\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    var escaped = utils.escape(this.text);\n\n    if (needsSpan) {\n      markup += \">\";\n      markup += escaped;\n      markup += \"</span>\";\n      return markup;\n    } else {\n      return escaped;\n    }\n  }\n\n}\n/**\n * SVG nodes are used to render stretchy wide elements.\n */\n\nclass SvgNode {\n  constructor(children, attributes) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.children = children || [];\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"svg\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"; // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n      }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</svg>\";\n    return markup;\n  }\n\n}\nclass PathNode {\n  constructor(pathName, alternate) {\n    this.pathName = void 0;\n    this.alternate = void 0;\n    this.pathName = pathName;\n    this.alternate = alternate; // Used only for \\sqrt, \\phase, & tall delims\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"path\");\n\n    if (this.alternate) {\n      node.setAttribute(\"d\", this.alternate);\n    } else {\n      node.setAttribute(\"d\", path[this.pathName]);\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    if (this.alternate) {\n      return \"<path d=\\\"\" + utils.escape(this.alternate) + \"\\\"/>\";\n    } else {\n      return \"<path d=\\\"\" + utils.escape(path[this.pathName]) + \"\\\"/>\";\n    }\n  }\n\n}\nclass LineNode {\n  constructor(attributes) {\n    this.attributes = void 0;\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"line\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<line\";\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n      }\n    }\n\n    markup += \"/>\";\n    return markup;\n  }\n\n}\nfunction assertSymbolDomNode(group) {\n  if (group instanceof SymbolNode) {\n    return group;\n  } else {\n    throw new Error(\"Expected symbolNode but got \" + String(group) + \".\");\n  }\n}\nfunction assertSpan(group) {\n  if (group instanceof Span) {\n    return group;\n  } else {\n    throw new Error(\"Expected span<HtmlDomNode> but got \" + String(group) + \".\");\n  }\n}\n\n/**\n * This file holds a list of all no-argument functions and single-character\n * symbols (like 'a' or ';').\n *\n * For each of the symbols, there are three properties they can have:\n * - font (required): the font to be used for this symbol. Either \"main\" (the\n     normal font), or \"ams\" (the ams fonts).\n * - group (required): the ParseNode group type the symbol should have (i.e.\n     \"textord\", \"mathord\", etc).\n     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types\n * - replace: the character that this symbol or function should be\n *   replaced with (i.e. \"\\phi\" has a replace value of \"\\u03d5\", the phi\n *   character in the main font).\n *\n * The outermost map in the table indicates what mode the symbols should be\n * accepted in (e.g. \"math\" or \"text\").\n */\n// Some of these have a \"-token\" suffix since these are also used as `ParseNode`\n// types for raw text tokens, and we want to avoid conflicts with higher-level\n// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by\n// looking up the `symbols` map.\nvar ATOMS = {\n  \"bin\": 1,\n  \"close\": 1,\n  \"inner\": 1,\n  \"open\": 1,\n  \"punct\": 1,\n  \"rel\": 1\n};\nvar NON_ATOMS = {\n  \"accent-token\": 1,\n  \"mathord\": 1,\n  \"op-token\": 1,\n  \"spacing\": 1,\n  \"textord\": 1\n};\nvar symbols = {\n  \"math\": {},\n  \"text\": {}\n};\n/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */\n\nfunction defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {\n  symbols[mode][name] = {\n    font,\n    group,\n    replace\n  };\n\n  if (acceptUnicodeChar && replace) {\n    symbols[mode][replace] = symbols[mode][name];\n  }\n} // Some abbreviations for commonly used strings.\n// This helps minify the code, and also spotting typos using jshint.\n// modes:\n\nvar math = \"math\";\nvar text = \"text\"; // fonts:\n\nvar main = \"main\";\nvar ams = \"ams\"; // groups:\n\nvar accent = \"accent-token\";\nvar bin = \"bin\";\nvar close = \"close\";\nvar inner = \"inner\";\nvar mathord = \"mathord\";\nvar op = \"op-token\";\nvar open = \"open\";\nvar punct = \"punct\";\nvar rel = \"rel\";\nvar spacing = \"spacing\";\nvar textord = \"textord\"; // Now comes the symbol table\n// Relation Symbols\n\ndefineSymbol(math, main, rel, \"\\u2261\", \"\\\\equiv\", true);\ndefineSymbol(math, main, rel, \"\\u227a\", \"\\\\prec\", true);\ndefineSymbol(math, main, rel, \"\\u227b\", \"\\\\succ\", true);\ndefineSymbol(math, main, rel, \"\\u223c\", \"\\\\sim\", true);\ndefineSymbol(math, main, rel, \"\\u22a5\", \"\\\\perp\");\ndefineSymbol(math, main, rel, \"\\u2aaf\", \"\\\\preceq\", true);\ndefineSymbol(math, main, rel, \"\\u2ab0\", \"\\\\succeq\", true);\ndefineSymbol(math, main, rel, \"\\u2243\", \"\\\\simeq\", true);\ndefineSymbol(math, main, rel, \"\\u2223\", \"\\\\mid\", true);\ndefineSymbol(math, main, rel, \"\\u226a\", \"\\\\ll\", true);\ndefineSymbol(math, main, rel, \"\\u226b\", \"\\\\gg\", true);\ndefineSymbol(math, main, rel, \"\\u224d\", \"\\\\asymp\", true);\ndefineSymbol(math, main, rel, \"\\u2225\", \"\\\\parallel\");\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\bowtie\", true);\ndefineSymbol(math, main, rel, \"\\u2323\", \"\\\\smile\", true);\ndefineSymbol(math, main, rel, \"\\u2291\", \"\\\\sqsubseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2292\", \"\\\\sqsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2250\", \"\\\\doteq\", true);\ndefineSymbol(math, main, rel, \"\\u2322\", \"\\\\frown\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\ni\", true);\ndefineSymbol(math, main, rel, \"\\u221d\", \"\\\\propto\", true);\ndefineSymbol(math, main, rel, \"\\u22a2\", \"\\\\vdash\", true);\ndefineSymbol(math, main, rel, \"\\u22a3\", \"\\\\dashv\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\owns\"); // Punctuation\n\ndefineSymbol(math, main, punct, \"\\u002e\", \"\\\\ldotp\");\ndefineSymbol(math, main, punct, \"\\u22c5\", \"\\\\cdotp\"); // Misc Symbols\n\ndefineSymbol(math, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(text, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(math, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(text, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(math, main, textord, \"\\u2135\", \"\\\\aleph\", true);\ndefineSymbol(math, main, textord, \"\\u2200\", \"\\\\forall\", true);\ndefineSymbol(math, main, textord, \"\\u210f\", \"\\\\hbar\", true);\ndefineSymbol(math, main, textord, \"\\u2203\", \"\\\\exists\", true);\ndefineSymbol(math, main, textord, \"\\u2207\", \"\\\\nabla\", true);\ndefineSymbol(math, main, textord, \"\\u266d\", \"\\\\flat\", true);\ndefineSymbol(math, main, textord, \"\\u2113\", \"\\\\ell\", true);\ndefineSymbol(math, main, textord, \"\\u266e\", \"\\\\natural\", true);\ndefineSymbol(math, main, textord, \"\\u2663\", \"\\\\clubsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2118\", \"\\\\wp\", true);\ndefineSymbol(math, main, textord, \"\\u266f\", \"\\\\sharp\", true);\ndefineSymbol(math, main, textord, \"\\u2662\", \"\\\\diamondsuit\", true);\ndefineSymbol(math, main, textord, \"\\u211c\", \"\\\\Re\", true);\ndefineSymbol(math, main, textord, \"\\u2661\", \"\\\\heartsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2111\", \"\\\\Im\", true);\ndefineSymbol(math, main, textord, \"\\u2660\", \"\\\\spadesuit\", true);\ndefineSymbol(math, main, textord, \"\\u00a7\", \"\\\\S\", true);\ndefineSymbol(text, main, textord, \"\\u00a7\", \"\\\\S\");\ndefineSymbol(math, main, textord, \"\\u00b6\", \"\\\\P\", true);\ndefineSymbol(text, main, textord, \"\\u00b6\", \"\\\\P\"); // Math and Text\n\ndefineSymbol(math, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(text, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(text, main, textord, \"\\u2020\", \"\\\\textdagger\");\ndefineSymbol(math, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(text, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(text, main, textord, \"\\u2021\", \"\\\\textdaggerdbl\"); // Large Delimiters\n\ndefineSymbol(math, main, close, \"\\u23b1\", \"\\\\rmoustache\", true);\ndefineSymbol(math, main, open, \"\\u23b0\", \"\\\\lmoustache\", true);\ndefineSymbol(math, main, close, \"\\u27ef\", \"\\\\rgroup\", true);\ndefineSymbol(math, main, open, \"\\u27ee\", \"\\\\lgroup\", true); // Binary Operators\n\ndefineSymbol(math, main, bin, \"\\u2213\", \"\\\\mp\", true);\ndefineSymbol(math, main, bin, \"\\u2296\", \"\\\\ominus\", true);\ndefineSymbol(math, main, bin, \"\\u228e\", \"\\\\uplus\", true);\ndefineSymbol(math, main, bin, \"\\u2293\", \"\\\\sqcap\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"\\\\ast\");\ndefineSymbol(math, main, bin, \"\\u2294\", \"\\\\sqcup\", true);\ndefineSymbol(math, main, bin, \"\\u25ef\", \"\\\\bigcirc\", true);\ndefineSymbol(math, main, bin, \"\\u2219\", \"\\\\bullet\", true);\ndefineSymbol(math, main, bin, \"\\u2021\", \"\\\\ddagger\");\ndefineSymbol(math, main, bin, \"\\u2240\", \"\\\\wr\", true);\ndefineSymbol(math, main, bin, \"\\u2a3f\", \"\\\\amalg\");\ndefineSymbol(math, main, bin, \"\\u0026\", \"\\\\And\"); // from amsmath\n// Arrow Symbols\n\ndefineSymbol(math, main, rel, \"\\u27f5\", \"\\\\longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d0\", \"\\\\Leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f8\", \"\\\\Longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f6\", \"\\\\longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d2\", \"\\\\Rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f9\", \"\\\\Longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2194\", \"\\\\leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f7\", \"\\\\longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d4\", \"\\\\Leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27fa\", \"\\\\Longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a6\", \"\\\\mapsto\", true);\ndefineSymbol(math, main, rel, \"\\u27fc\", \"\\\\longmapsto\", true);\ndefineSymbol(math, main, rel, \"\\u2197\", \"\\\\nearrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a9\", \"\\\\hookleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21aa\", \"\\\\hookrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2198\", \"\\\\searrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bc\", \"\\\\leftharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u21c0\", \"\\\\rightharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u2199\", \"\\\\swarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bd\", \"\\\\leftharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u21c1\", \"\\\\rightharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u2196\", \"\\\\nwarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21cc\", \"\\\\rightleftharpoons\", true); // AMS Negated Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u226e\", \"\\\\nless\", true); // Symbol names preceded by \"@\" each have a corresponding macro.\n\ndefineSymbol(math, ams, rel, \"\\ue010\", \"\\\\@nleqslant\");\ndefineSymbol(math, ams, rel, \"\\ue011\", \"\\\\@nleqq\");\ndefineSymbol(math, ams, rel, \"\\u2a87\", \"\\\\lneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2268\", \"\\\\lneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00c\", \"\\\\@lvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e6\", \"\\\\lnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a89\", \"\\\\lnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2280\", \"\\\\nprec\", true); // unicode-math maps \\u22e0 to \\npreccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e0\", \"\\\\npreceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e8\", \"\\\\precnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab9\", \"\\\\precnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2241\", \"\\\\nsim\", true);\ndefineSymbol(math, ams, rel, \"\\ue006\", \"\\\\@nshortmid\");\ndefineSymbol(math, ams, rel, \"\\u2224\", \"\\\\nmid\", true);\ndefineSymbol(math, ams, rel, \"\\u22ac\", \"\\\\nvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ad\", \"\\\\nvDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ea\", \"\\\\ntriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22ec\", \"\\\\ntrianglelefteq\", true);\ndefineSymbol(math, ams, rel, \"\\u228a\", \"\\\\subsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01a\", \"\\\\@varsubsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acb\", \"\\\\subsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue017\", \"\\\\@varsubsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u226f\", \"\\\\ngtr\", true);\ndefineSymbol(math, ams, rel, \"\\ue00f\", \"\\\\@ngeqslant\");\ndefineSymbol(math, ams, rel, \"\\ue00e\", \"\\\\@ngeqq\");\ndefineSymbol(math, ams, rel, \"\\u2a88\", \"\\\\gneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2269\", \"\\\\gneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00d\", \"\\\\@gvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e7\", \"\\\\gnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8a\", \"\\\\gnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2281\", \"\\\\nsucc\", true); // unicode-math maps \\u22e1 to \\nsucccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e1\", \"\\\\nsucceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e9\", \"\\\\succnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2aba\", \"\\\\succnapprox\", true); // unicode-math maps \\u2246 to \\simneqq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u2246\", \"\\\\ncong\", true);\ndefineSymbol(math, ams, rel, \"\\ue007\", \"\\\\@nshortparallel\");\ndefineSymbol(math, ams, rel, \"\\u2226\", \"\\\\nparallel\", true);\ndefineSymbol(math, ams, rel, \"\\u22af\", \"\\\\nVDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22eb\", \"\\\\ntriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22ed\", \"\\\\ntrianglerighteq\", true);\ndefineSymbol(math, ams, rel, \"\\ue018\", \"\\\\@nsupseteqq\");\ndefineSymbol(math, ams, rel, \"\\u228b\", \"\\\\supsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01b\", \"\\\\@varsupsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acc\", \"\\\\supsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue019\", \"\\\\@varsupsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u22ae\", \"\\\\nVdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab5\", \"\\\\precneqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab6\", \"\\\\succneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue016\", \"\\\\@nsubseteqq\");\ndefineSymbol(math, ams, bin, \"\\u22b4\", \"\\\\unlhd\");\ndefineSymbol(math, ams, bin, \"\\u22b5\", \"\\\\unrhd\"); // AMS Negated Arrows\n\ndefineSymbol(math, ams, rel, \"\\u219a\", \"\\\\nleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219b\", \"\\\\nrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cd\", \"\\\\nLeftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cf\", \"\\\\nRightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ae\", \"\\\\nleftrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ce\", \"\\\\nLeftrightarrow\", true); // AMS Misc\n\ndefineSymbol(math, ams, rel, \"\\u25b3\", \"\\\\vartriangle\");\ndefineSymbol(math, ams, textord, \"\\u210f\", \"\\\\hslash\");\ndefineSymbol(math, ams, textord, \"\\u25bd\", \"\\\\triangledown\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\lozenge\");\ndefineSymbol(math, ams, textord, \"\\u24c8\", \"\\\\circledS\");\ndefineSymbol(math, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(text, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(math, ams, textord, \"\\u2221\", \"\\\\measuredangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2204\", \"\\\\nexists\");\ndefineSymbol(math, ams, textord, \"\\u2127\", \"\\\\mho\");\ndefineSymbol(math, ams, textord, \"\\u2132\", \"\\\\Finv\", true);\ndefineSymbol(math, ams, textord, \"\\u2141\", \"\\\\Game\", true);\ndefineSymbol(math, ams, textord, \"\\u2035\", \"\\\\backprime\");\ndefineSymbol(math, ams, textord, \"\\u25b2\", \"\\\\blacktriangle\");\ndefineSymbol(math, ams, textord, \"\\u25bc\", \"\\\\blacktriangledown\");\ndefineSymbol(math, ams, textord, \"\\u25a0\", \"\\\\blacksquare\");\ndefineSymbol(math, ams, textord, \"\\u29eb\", \"\\\\blacklozenge\");\ndefineSymbol(math, ams, textord, \"\\u2605\", \"\\\\bigstar\");\ndefineSymbol(math, ams, textord, \"\\u2222\", \"\\\\sphericalangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2201\", \"\\\\complement\", true); // unicode-math maps U+F0 to \\matheth. We map to AMS function \\eth\n\ndefineSymbol(math, ams, textord, \"\\u00f0\", \"\\\\eth\", true);\ndefineSymbol(text, main, textord, \"\\u00f0\", \"\\u00f0\");\ndefineSymbol(math, ams, textord, \"\\u2571\", \"\\\\diagup\");\ndefineSymbol(math, ams, textord, \"\\u2572\", \"\\\\diagdown\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\square\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\Box\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\Diamond\"); // unicode-math maps U+A5 to \\mathyen. We map to AMS function \\yen\n\ndefineSymbol(math, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(text, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(math, ams, textord, \"\\u2713\", \"\\\\checkmark\", true);\ndefineSymbol(text, ams, textord, \"\\u2713\", \"\\\\checkmark\"); // AMS Hebrew\n\ndefineSymbol(math, ams, textord, \"\\u2136\", \"\\\\beth\", true);\ndefineSymbol(math, ams, textord, \"\\u2138\", \"\\\\daleth\", true);\ndefineSymbol(math, ams, textord, \"\\u2137\", \"\\\\gimel\", true); // AMS Greek\n\ndefineSymbol(math, ams, textord, \"\\u03dd\", \"\\\\digamma\", true);\ndefineSymbol(math, ams, textord, \"\\u03f0\", \"\\\\varkappa\"); // AMS Delimiters\n\ndefineSymbol(math, ams, open, \"\\u250c\", \"\\\\@ulcorner\", true);\ndefineSymbol(math, ams, close, \"\\u2510\", \"\\\\@urcorner\", true);\ndefineSymbol(math, ams, open, \"\\u2514\", \"\\\\@llcorner\", true);\ndefineSymbol(math, ams, close, \"\\u2518\", \"\\\\@lrcorner\", true); // AMS Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u2266\", \"\\\\leqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7d\", \"\\\\leqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a95\", \"\\\\eqslantless\", true);\ndefineSymbol(math, ams, rel, \"\\u2272\", \"\\\\lesssim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a85\", \"\\\\lessapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u224a\", \"\\\\approxeq\", true);\ndefineSymbol(math, ams, bin, \"\\u22d6\", \"\\\\lessdot\");\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\lll\", true);\ndefineSymbol(math, ams, rel, \"\\u2276\", \"\\\\lessgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u22da\", \"\\\\lesseqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8b\", \"\\\\lesseqqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\doteqdot\");\ndefineSymbol(math, ams, rel, \"\\u2253\", \"\\\\risingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u2252\", \"\\\\fallingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u223d\", \"\\\\backsim\", true);\ndefineSymbol(math, ams, rel, \"\\u22cd\", \"\\\\backsimeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ac5\", \"\\\\subseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d0\", \"\\\\Subset\", true);\ndefineSymbol(math, ams, rel, \"\\u228f\", \"\\\\sqsubset\", true);\ndefineSymbol(math, ams, rel, \"\\u227c\", \"\\\\preccurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22de\", \"\\\\curlyeqprec\", true);\ndefineSymbol(math, ams, rel, \"\\u227e\", \"\\\\precsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab7\", \"\\\\precapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b2\", \"\\\\vartriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22b4\", \"\\\\trianglelefteq\");\ndefineSymbol(math, ams, rel, \"\\u22a8\", \"\\\\vDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22aa\", \"\\\\Vvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2323\", \"\\\\smallsmile\");\ndefineSymbol(math, ams, rel, \"\\u2322\", \"\\\\smallfrown\");\ndefineSymbol(math, ams, rel, \"\\u224f\", \"\\\\bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u224e\", \"\\\\Bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2267\", \"\\\\geqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7e\", \"\\\\geqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a96\", \"\\\\eqslantgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2273\", \"\\\\gtrsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a86\", \"\\\\gtrapprox\", true);\ndefineSymbol(math, ams, bin, \"\\u22d7\", \"\\\\gtrdot\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\ggg\", true);\ndefineSymbol(math, ams, rel, \"\\u2277\", \"\\\\gtrless\", true);\ndefineSymbol(math, ams, rel, \"\\u22db\", \"\\\\gtreqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8c\", \"\\\\gtreqqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2256\", \"\\\\eqcirc\", true);\ndefineSymbol(math, ams, rel, \"\\u2257\", \"\\\\circeq\", true);\ndefineSymbol(math, ams, rel, \"\\u225c\", \"\\\\triangleq\", true);\ndefineSymbol(math, ams, rel, \"\\u223c\", \"\\\\thicksim\");\ndefineSymbol(math, ams, rel, \"\\u2248\", \"\\\\thickapprox\");\ndefineSymbol(math, ams, rel, \"\\u2ac6\", \"\\\\supseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d1\", \"\\\\Supset\", true);\ndefineSymbol(math, ams, rel, \"\\u2290\", \"\\\\sqsupset\", true);\ndefineSymbol(math, ams, rel, \"\\u227d\", \"\\\\succcurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22df\", \"\\\\curlyeqsucc\", true);\ndefineSymbol(math, ams, rel, \"\\u227f\", \"\\\\succsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab8\", \"\\\\succapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b3\", \"\\\\vartriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22b5\", \"\\\\trianglerighteq\");\ndefineSymbol(math, ams, rel, \"\\u22a9\", \"\\\\Vdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2223\", \"\\\\shortmid\");\ndefineSymbol(math, ams, rel, \"\\u2225\", \"\\\\shortparallel\");\ndefineSymbol(math, ams, rel, \"\\u226c\", \"\\\\between\", true);\ndefineSymbol(math, ams, rel, \"\\u22d4\", \"\\\\pitchfork\", true);\ndefineSymbol(math, ams, rel, \"\\u221d\", \"\\\\varpropto\");\ndefineSymbol(math, ams, rel, \"\\u25c0\", \"\\\\blacktriangleleft\"); // unicode-math says that \\therefore is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2234\", \"\\\\therefore\", true);\ndefineSymbol(math, ams, rel, \"\\u220d\", \"\\\\backepsilon\");\ndefineSymbol(math, ams, rel, \"\\u25b6\", \"\\\\blacktriangleright\"); // unicode-math says that \\because is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2235\", \"\\\\because\", true);\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\llless\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\gggtr\");\ndefineSymbol(math, ams, bin, \"\\u22b2\", \"\\\\lhd\");\ndefineSymbol(math, ams, bin, \"\\u22b3\", \"\\\\rhd\");\ndefineSymbol(math, ams, rel, \"\\u2242\", \"\\\\eqsim\", true);\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\Join\");\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\Doteq\", true); // AMS Binary Operators\n\ndefineSymbol(math, ams, bin, \"\\u2214\", \"\\\\dotplus\", true);\ndefineSymbol(math, ams, bin, \"\\u2216\", \"\\\\smallsetminus\");\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\Cap\", true);\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\Cup\", true);\ndefineSymbol(math, ams, bin, \"\\u2a5e\", \"\\\\doublebarwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u229f\", \"\\\\boxminus\", true);\ndefineSymbol(math, ams, bin, \"\\u229e\", \"\\\\boxplus\", true);\ndefineSymbol(math, ams, bin, \"\\u22c7\", \"\\\\divideontimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22c9\", \"\\\\ltimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22ca\", \"\\\\rtimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cb\", \"\\\\leftthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cc\", \"\\\\rightthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cf\", \"\\\\curlywedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22ce\", \"\\\\curlyvee\", true);\ndefineSymbol(math, ams, bin, \"\\u229d\", \"\\\\circleddash\", true);\ndefineSymbol(math, ams, bin, \"\\u229b\", \"\\\\circledast\", true);\ndefineSymbol(math, ams, bin, \"\\u22c5\", \"\\\\centerdot\");\ndefineSymbol(math, ams, bin, \"\\u22ba\", \"\\\\intercal\", true);\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\doublecap\");\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\doublecup\");\ndefineSymbol(math, ams, bin, \"\\u22a0\", \"\\\\boxtimes\", true); // AMS Arrows\n// Note: unicode-math maps \\u21e2 to their own function \\rightdasharrow.\n// We'll map it to AMS function \\dashrightarrow. It produces the same atom.\n\ndefineSymbol(math, ams, rel, \"\\u21e2\", \"\\\\dashrightarrow\", true); // unicode-math maps \\u21e0 to \\leftdasharrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21e0\", \"\\\\dashleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c7\", \"\\\\leftleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c6\", \"\\\\leftrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21da\", \"\\\\Lleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219e\", \"\\\\twoheadleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a2\", \"\\\\leftarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ab\", \"\\\\looparrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21cb\", \"\\\\leftrightharpoons\", true);\ndefineSymbol(math, ams, rel, \"\\u21b6\", \"\\\\curvearrowleft\", true); // unicode-math maps \\u21ba to \\acwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21ba\", \"\\\\circlearrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21b0\", \"\\\\Lsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21c8\", \"\\\\upuparrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21bf\", \"\\\\upharpoonleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21c3\", \"\\\\downharpoonleft\", true);\ndefineSymbol(math, main, rel, \"\\u22b6\", \"\\\\origof\", true); // not in font\n\ndefineSymbol(math, main, rel, \"\\u22b7\", \"\\\\imageof\", true); // not in font\n\ndefineSymbol(math, ams, rel, \"\\u22b8\", \"\\\\multimap\", true);\ndefineSymbol(math, ams, rel, \"\\u21ad\", \"\\\\leftrightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c9\", \"\\\\rightrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c4\", \"\\\\rightleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21a0\", \"\\\\twoheadrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a3\", \"\\\\rightarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ac\", \"\\\\looparrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b7\", \"\\\\curvearrowright\", true); // unicode-math maps \\u21bb to \\cwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21bb\", \"\\\\circlearrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b1\", \"\\\\Rsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21ca\", \"\\\\downdownarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\upharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21c2\", \"\\\\downharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\rightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\leadsto\");\ndefineSymbol(math, ams, rel, \"\\u21db\", \"\\\\Rrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\restriction\");\ndefineSymbol(math, main, textord, \"\\u2018\", \"`\");\ndefineSymbol(math, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(text, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(text, main, textord, \"$\", \"\\\\textdollar\");\ndefineSymbol(math, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(text, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(math, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(text, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(text, main, textord, \"_\", \"\\\\textunderscore\");\ndefineSymbol(math, main, textord, \"\\u2220\", \"\\\\angle\", true);\ndefineSymbol(math, main, textord, \"\\u221e\", \"\\\\infty\", true);\ndefineSymbol(math, main, textord, \"\\u2032\", \"\\\\prime\");\ndefineSymbol(math, main, textord, \"\\u25b3\", \"\\\\triangle\");\ndefineSymbol(math, main, textord, \"\\u0393\", \"\\\\Gamma\", true);\ndefineSymbol(math, main, textord, \"\\u0394\", \"\\\\Delta\", true);\ndefineSymbol(math, main, textord, \"\\u0398\", \"\\\\Theta\", true);\ndefineSymbol(math, main, textord, \"\\u039b\", \"\\\\Lambda\", true);\ndefineSymbol(math, main, textord, \"\\u039e\", \"\\\\Xi\", true);\ndefineSymbol(math, main, textord, \"\\u03a0\", \"\\\\Pi\", true);\ndefineSymbol(math, main, textord, \"\\u03a3\", \"\\\\Sigma\", true);\ndefineSymbol(math, main, textord, \"\\u03a5\", \"\\\\Upsilon\", true);\ndefineSymbol(math, main, textord, \"\\u03a6\", \"\\\\Phi\", true);\ndefineSymbol(math, main, textord, \"\\u03a8\", \"\\\\Psi\", true);\ndefineSymbol(math, main, textord, \"\\u03a9\", \"\\\\Omega\", true);\ndefineSymbol(math, main, textord, \"A\", \"\\u0391\");\ndefineSymbol(math, main, textord, \"B\", \"\\u0392\");\ndefineSymbol(math, main, textord, \"E\", \"\\u0395\");\ndefineSymbol(math, main, textord, \"Z\", \"\\u0396\");\ndefineSymbol(math, main, textord, \"H\", \"\\u0397\");\ndefineSymbol(math, main, textord, \"I\", \"\\u0399\");\ndefineSymbol(math, main, textord, \"K\", \"\\u039A\");\ndefineSymbol(math, main, textord, \"M\", \"\\u039C\");\ndefineSymbol(math, main, textord, \"N\", \"\\u039D\");\ndefineSymbol(math, main, textord, \"O\", \"\\u039F\");\ndefineSymbol(math, main, textord, \"P\", \"\\u03A1\");\ndefineSymbol(math, main, textord, \"T\", \"\\u03A4\");\ndefineSymbol(math, main, textord, \"X\", \"\\u03A7\");\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\neg\", true);\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\lnot\");\ndefineSymbol(math, main, textord, \"\\u22a4\", \"\\\\top\");\ndefineSymbol(math, main, textord, \"\\u22a5\", \"\\\\bot\");\ndefineSymbol(math, main, textord, \"\\u2205\", \"\\\\emptyset\");\ndefineSymbol(math, ams, textord, \"\\u2205\", \"\\\\varnothing\");\ndefineSymbol(math, main, mathord, \"\\u03b1\", \"\\\\alpha\", true);\ndefineSymbol(math, main, mathord, \"\\u03b2\", \"\\\\beta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b3\", \"\\\\gamma\", true);\ndefineSymbol(math, main, mathord, \"\\u03b4\", \"\\\\delta\", true);\ndefineSymbol(math, main, mathord, \"\\u03f5\", \"\\\\epsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03b6\", \"\\\\zeta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b7\", \"\\\\eta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b8\", \"\\\\theta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b9\", \"\\\\iota\", true);\ndefineSymbol(math, main, mathord, \"\\u03ba\", \"\\\\kappa\", true);\ndefineSymbol(math, main, mathord, \"\\u03bb\", \"\\\\lambda\", true);\ndefineSymbol(math, main, mathord, \"\\u03bc\", \"\\\\mu\", true);\ndefineSymbol(math, main, mathord, \"\\u03bd\", \"\\\\nu\", true);\ndefineSymbol(math, main, mathord, \"\\u03be\", \"\\\\xi\", true);\ndefineSymbol(math, main, mathord, \"\\u03bf\", \"\\\\omicron\", true);\ndefineSymbol(math, main, mathord, \"\\u03c0\", \"\\\\pi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c1\", \"\\\\rho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c3\", \"\\\\sigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c4\", \"\\\\tau\", true);\ndefineSymbol(math, main, mathord, \"\\u03c5\", \"\\\\upsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d5\", \"\\\\phi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c7\", \"\\\\chi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c8\", \"\\\\psi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c9\", \"\\\\omega\", true);\ndefineSymbol(math, main, mathord, \"\\u03b5\", \"\\\\varepsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d1\", \"\\\\vartheta\", true);\ndefineSymbol(math, main, mathord, \"\\u03d6\", \"\\\\varpi\", true);\ndefineSymbol(math, main, mathord, \"\\u03f1\", \"\\\\varrho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c2\", \"\\\\varsigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c6\", \"\\\\varphi\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"*\", true);\ndefineSymbol(math, main, bin, \"+\", \"+\");\ndefineSymbol(math, main, bin, \"\\u2212\", \"-\", true);\ndefineSymbol(math, main, bin, \"\\u22c5\", \"\\\\cdot\", true);\ndefineSymbol(math, main, bin, \"\\u2218\", \"\\\\circ\", true);\ndefineSymbol(math, main, bin, \"\\u00f7\", \"\\\\div\", true);\ndefineSymbol(math, main, bin, \"\\u00b1\", \"\\\\pm\", true);\ndefineSymbol(math, main, bin, \"\\u00d7\", \"\\\\times\", true);\ndefineSymbol(math, main, bin, \"\\u2229\", \"\\\\cap\", true);\ndefineSymbol(math, main, bin, \"\\u222a\", \"\\\\cup\", true);\ndefineSymbol(math, main, bin, \"\\u2216\", \"\\\\setminus\", true);\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\land\");\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\lor\");\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\wedge\", true);\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\vee\", true);\ndefineSymbol(math, main, textord, \"\\u221a\", \"\\\\surd\");\ndefineSymbol(math, main, open, \"\\u27e8\", \"\\\\langle\", true);\ndefineSymbol(math, main, open, \"\\u2223\", \"\\\\lvert\");\ndefineSymbol(math, main, open, \"\\u2225\", \"\\\\lVert\");\ndefineSymbol(math, main, close, \"?\", \"?\");\ndefineSymbol(math, main, close, \"!\", \"!\");\ndefineSymbol(math, main, close, \"\\u27e9\", \"\\\\rangle\", true);\ndefineSymbol(math, main, close, \"\\u2223\", \"\\\\rvert\");\ndefineSymbol(math, main, close, \"\\u2225\", \"\\\\rVert\");\ndefineSymbol(math, main, rel, \"=\", \"=\");\ndefineSymbol(math, main, rel, \":\", \":\");\ndefineSymbol(math, main, rel, \"\\u2248\", \"\\\\approx\", true);\ndefineSymbol(math, main, rel, \"\\u2245\", \"\\\\cong\", true);\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\ge\");\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\geq\", true);\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\gets\");\ndefineSymbol(math, main, rel, \">\", \"\\\\gt\", true);\ndefineSymbol(math, main, rel, \"\\u2208\", \"\\\\in\", true);\ndefineSymbol(math, main, rel, \"\\ue020\", \"\\\\@not\");\ndefineSymbol(math, main, rel, \"\\u2282\", \"\\\\subset\", true);\ndefineSymbol(math, main, rel, \"\\u2283\", \"\\\\supset\", true);\ndefineSymbol(math, main, rel, \"\\u2286\", \"\\\\subseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2287\", \"\\\\supseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2288\", \"\\\\nsubseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2289\", \"\\\\nsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u22a8\", \"\\\\models\");\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\le\");\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\leq\", true);\ndefineSymbol(math, main, rel, \"<\", \"\\\\lt\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\to\");\ndefineSymbol(math, ams, rel, \"\\u2271\", \"\\\\ngeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2270\", \"\\\\nleq\", true);\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\space\"); // Ref: LaTeX Source 2e: \\DeclareRobustCommand{\\nobreakspace}{%\n\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \" \");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\space\");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(math, main, spacing, null, \"\\\\nobreak\");\ndefineSymbol(math, main, spacing, null, \"\\\\allowbreak\");\ndefineSymbol(math, main, punct, \",\", \",\");\ndefineSymbol(math, main, punct, \";\", \";\");\ndefineSymbol(math, ams, bin, \"\\u22bc\", \"\\\\barwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22bb\", \"\\\\veebar\", true);\ndefineSymbol(math, main, bin, \"\\u2299\", \"\\\\odot\", true);\ndefineSymbol(math, main, bin, \"\\u2295\", \"\\\\oplus\", true);\ndefineSymbol(math, main, bin, \"\\u2297\", \"\\\\otimes\", true);\ndefineSymbol(math, main, textord, \"\\u2202\", \"\\\\partial\", true);\ndefineSymbol(math, main, bin, \"\\u2298\", \"\\\\oslash\", true);\ndefineSymbol(math, ams, bin, \"\\u229a\", \"\\\\circledcirc\", true);\ndefineSymbol(math, ams, bin, \"\\u22a1\", \"\\\\boxdot\", true);\ndefineSymbol(math, main, bin, \"\\u25b3\", \"\\\\bigtriangleup\");\ndefineSymbol(math, main, bin, \"\\u25bd\", \"\\\\bigtriangledown\");\ndefineSymbol(math, main, bin, \"\\u2020\", \"\\\\dagger\");\ndefineSymbol(math, main, bin, \"\\u22c4\", \"\\\\diamond\");\ndefineSymbol(math, main, bin, \"\\u22c6\", \"\\\\star\");\ndefineSymbol(math, main, bin, \"\\u25c3\", \"\\\\triangleleft\");\ndefineSymbol(math, main, bin, \"\\u25b9\", \"\\\\triangleright\");\ndefineSymbol(math, main, open, \"{\", \"\\\\{\");\ndefineSymbol(text, main, textord, \"{\", \"\\\\{\");\ndefineSymbol(text, main, textord, \"{\", \"\\\\textbraceleft\");\ndefineSymbol(math, main, close, \"}\", \"\\\\}\");\ndefineSymbol(text, main, textord, \"}\", \"\\\\}\");\ndefineSymbol(text, main, textord, \"}\", \"\\\\textbraceright\");\ndefineSymbol(math, main, open, \"{\", \"\\\\lbrace\");\ndefineSymbol(math, main, close, \"}\", \"\\\\rbrace\");\ndefineSymbol(math, main, open, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(text, main, textord, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(math, main, close, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(text, main, textord, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(math, main, open, \"(\", \"\\\\lparen\", true);\ndefineSymbol(math, main, close, \")\", \"\\\\rparen\", true);\ndefineSymbol(text, main, textord, \"<\", \"\\\\textless\", true); // in T1 fontenc\n\ndefineSymbol(text, main, textord, \">\", \"\\\\textgreater\", true); // in T1 fontenc\n\ndefineSymbol(math, main, open, \"\\u230a\", \"\\\\lfloor\", true);\ndefineSymbol(math, main, close, \"\\u230b\", \"\\\\rfloor\", true);\ndefineSymbol(math, main, open, \"\\u2308\", \"\\\\lceil\", true);\ndefineSymbol(math, main, close, \"\\u2309\", \"\\\\rceil\", true);\ndefineSymbol(math, main, textord, \"\\\\\", \"\\\\backslash\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"|\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"\\\\vert\");\ndefineSymbol(text, main, textord, \"|\", \"\\\\textbar\", true); // in T1 fontenc\n\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\|\");\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\Vert\");\ndefineSymbol(text, main, textord, \"\\u2225\", \"\\\\textbardbl\");\ndefineSymbol(text, main, textord, \"~\", \"\\\\textasciitilde\");\ndefineSymbol(text, main, textord, \"\\\\\", \"\\\\textbackslash\");\ndefineSymbol(text, main, textord, \"^\", \"\\\\textasciicircum\");\ndefineSymbol(math, main, rel, \"\\u2191\", \"\\\\uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d1\", \"\\\\Uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u2193\", \"\\\\downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d3\", \"\\\\Downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2195\", \"\\\\updownarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d5\", \"\\\\Updownarrow\", true);\ndefineSymbol(math, main, op, \"\\u2210\", \"\\\\coprod\");\ndefineSymbol(math, main, op, \"\\u22c1\", \"\\\\bigvee\");\ndefineSymbol(math, main, op, \"\\u22c0\", \"\\\\bigwedge\");\ndefineSymbol(math, main, op, \"\\u2a04\", \"\\\\biguplus\");\ndefineSymbol(math, main, op, \"\\u22c2\", \"\\\\bigcap\");\ndefineSymbol(math, main, op, \"\\u22c3\", \"\\\\bigcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\int\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\intop\");\ndefineSymbol(math, main, op, \"\\u222c\", \"\\\\iint\");\ndefineSymbol(math, main, op, \"\\u222d\", \"\\\\iiint\");\ndefineSymbol(math, main, op, \"\\u220f\", \"\\\\prod\");\ndefineSymbol(math, main, op, \"\\u2211\", \"\\\\sum\");\ndefineSymbol(math, main, op, \"\\u2a02\", \"\\\\bigotimes\");\ndefineSymbol(math, main, op, \"\\u2a01\", \"\\\\bigoplus\");\ndefineSymbol(math, main, op, \"\\u2a00\", \"\\\\bigodot\");\ndefineSymbol(math, main, op, \"\\u222e\", \"\\\\oint\");\ndefineSymbol(math, main, op, \"\\u222f\", \"\\\\oiint\");\ndefineSymbol(math, main, op, \"\\u2230\", \"\\\\oiiint\");\ndefineSymbol(math, main, op, \"\\u2a06\", \"\\\\bigsqcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\smallint\");\ndefineSymbol(text, main, inner, \"\\u2026\", \"\\\\textellipsis\");\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\mathellipsis\");\ndefineSymbol(text, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u22ef\", \"\\\\@cdots\", true);\ndefineSymbol(math, main, inner, \"\\u22f1\", \"\\\\ddots\", true);\ndefineSymbol(math, main, textord, \"\\u22ee\", \"\\\\varvdots\"); // \\vdots is a macro\n\ndefineSymbol(math, main, accent, \"\\u02ca\", \"\\\\acute\");\ndefineSymbol(math, main, accent, \"\\u02cb\", \"\\\\grave\");\ndefineSymbol(math, main, accent, \"\\u00a8\", \"\\\\ddot\");\ndefineSymbol(math, main, accent, \"\\u007e\", \"\\\\tilde\");\ndefineSymbol(math, main, accent, \"\\u02c9\", \"\\\\bar\");\ndefineSymbol(math, main, accent, \"\\u02d8\", \"\\\\breve\");\ndefineSymbol(math, main, accent, \"\\u02c7\", \"\\\\check\");\ndefineSymbol(math, main, accent, \"\\u005e\", \"\\\\hat\");\ndefineSymbol(math, main, accent, \"\\u20d7\", \"\\\\vec\");\ndefineSymbol(math, main, accent, \"\\u02d9\", \"\\\\dot\");\ndefineSymbol(math, main, accent, \"\\u02da\", \"\\\\mathring\"); // \\imath and \\jmath should be invariant to \\mathrm, \\mathbf, etc., so use PUA\n\ndefineSymbol(math, main, mathord, \"\\ue131\", \"\\\\@imath\");\ndefineSymbol(math, main, mathord, \"\\ue237\", \"\\\\@jmath\");\ndefineSymbol(math, main, textord, \"\\u0131\", \"\\u0131\");\ndefineSymbol(math, main, textord, \"\\u0237\", \"\\u0237\");\ndefineSymbol(text, main, textord, \"\\u0131\", \"\\\\i\", true);\ndefineSymbol(text, main, textord, \"\\u0237\", \"\\\\j\", true);\ndefineSymbol(text, main, textord, \"\\u00df\", \"\\\\ss\", true);\ndefineSymbol(text, main, textord, \"\\u00e6\", \"\\\\ae\", true);\ndefineSymbol(text, main, textord, \"\\u0153\", \"\\\\oe\", true);\ndefineSymbol(text, main, textord, \"\\u00f8\", \"\\\\o\", true);\ndefineSymbol(text, main, textord, \"\\u00c6\", \"\\\\AE\", true);\ndefineSymbol(text, main, textord, \"\\u0152\", \"\\\\OE\", true);\ndefineSymbol(text, main, textord, \"\\u00d8\", \"\\\\O\", true);\ndefineSymbol(text, main, accent, \"\\u02ca\", \"\\\\'\"); // acute\n\ndefineSymbol(text, main, accent, \"\\u02cb\", \"\\\\`\"); // grave\n\ndefineSymbol(text, main, accent, \"\\u02c6\", \"\\\\^\"); // circumflex\n\ndefineSymbol(text, main, accent, \"\\u02dc\", \"\\\\~\"); // tilde\n\ndefineSymbol(text, main, accent, \"\\u02c9\", \"\\\\=\"); // macron\n\ndefineSymbol(text, main, accent, \"\\u02d8\", \"\\\\u\"); // breve\n\ndefineSymbol(text, main, accent, \"\\u02d9\", \"\\\\.\"); // dot above\n\ndefineSymbol(text, main, accent, \"\\u00b8\", \"\\\\c\"); // cedilla\n\ndefineSymbol(text, main, accent, \"\\u02da\", \"\\\\r\"); // ring above\n\ndefineSymbol(text, main, accent, \"\\u02c7\", \"\\\\v\"); // caron\n\ndefineSymbol(text, main, accent, \"\\u00a8\", '\\\\\"'); // diaresis\n\ndefineSymbol(text, main, accent, \"\\u02dd\", \"\\\\H\"); // double acute\n\ndefineSymbol(text, main, accent, \"\\u25ef\", \"\\\\textcircled\"); // \\bigcirc glyph\n// These ligatures are detected and created in Parser.js's `formLigatures`.\n\nvar ligatures = {\n  \"--\": true,\n  \"---\": true,\n  \"``\": true,\n  \"''\": true\n};\ndefineSymbol(text, main, textord, \"\\u2013\", \"--\", true);\ndefineSymbol(text, main, textord, \"\\u2013\", \"\\\\textendash\");\ndefineSymbol(text, main, textord, \"\\u2014\", \"---\", true);\ndefineSymbol(text, main, textord, \"\\u2014\", \"\\\\textemdash\");\ndefineSymbol(text, main, textord, \"\\u2018\", \"`\", true);\ndefineSymbol(text, main, textord, \"\\u2018\", \"\\\\textquoteleft\");\ndefineSymbol(text, main, textord, \"\\u2019\", \"'\", true);\ndefineSymbol(text, main, textord, \"\\u2019\", \"\\\\textquoteright\");\ndefineSymbol(text, main, textord, \"\\u201c\", \"``\", true);\ndefineSymbol(text, main, textord, \"\\u201c\", \"\\\\textquotedblleft\");\ndefineSymbol(text, main, textord, \"\\u201d\", \"''\", true);\ndefineSymbol(text, main, textord, \"\\u201d\", \"\\\\textquotedblright\"); //  \\degree from gensymb package\n\ndefineSymbol(math, main, textord, \"\\u00b0\", \"\\\\degree\", true);\ndefineSymbol(text, main, textord, \"\\u00b0\", \"\\\\degree\"); // \\textdegree from inputenc package\n\ndefineSymbol(text, main, textord, \"\\u00b0\", \"\\\\textdegree\", true); // TODO: In LaTeX, \\pounds can generate a different character in text and math\n// mode, but among our fonts, only Main-Regular defines this character \"163\".\n\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\mathsterling\", true);\ndefineSymbol(text, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(text, main, textord, \"\\u00a3\", \"\\\\textsterling\", true);\ndefineSymbol(math, ams, textord, \"\\u2720\", \"\\\\maltese\");\ndefineSymbol(text, ams, textord, \"\\u2720\", \"\\\\maltese\"); // There are lots of symbols which are the same, so we add them in afterwards.\n// All of these are textords in math mode\n\nvar mathTextSymbols = \"0123456789/@.\\\"\";\n\nfor (var i = 0; i < mathTextSymbols.length; i++) {\n  var ch = mathTextSymbols.charAt(i);\n  defineSymbol(math, main, textord, ch, ch);\n} // All of these are textords in text mode\n\n\nvar textSymbols = \"0123456789!@*()-=+\\\";:?/.,\";\n\nfor (var _i = 0; _i < textSymbols.length; _i++) {\n  var _ch = textSymbols.charAt(_i);\n\n  defineSymbol(text, main, textord, _ch, _ch);\n} // All of these are textords in text mode, and mathords in math mode\n\n\nvar letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfor (var _i2 = 0; _i2 < letters.length; _i2++) {\n  var _ch2 = letters.charAt(_i2);\n\n  defineSymbol(math, main, mathord, _ch2, _ch2);\n  defineSymbol(text, main, textord, _ch2, _ch2);\n} // Blackboard bold and script letters in Unicode range\n\n\ndefineSymbol(math, ams, textord, \"C\", \"\\u2102\"); // blackboard bold\n\ndefineSymbol(text, ams, textord, \"C\", \"\\u2102\");\ndefineSymbol(math, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(text, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(math, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(text, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(math, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(text, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(math, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(text, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(math, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(text, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(math, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(text, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(math, main, mathord, \"h\", \"\\u210E\"); // italic h, Planck constant\n\ndefineSymbol(text, main, mathord, \"h\", \"\\u210E\"); // The next loop loads wide (surrogate pair) characters.\n// We support some letters in the Unicode range U+1D400 to U+1D7FF,\n// Mathematical Alphanumeric Symbols.\n// Some editors do not deal well with wide characters. So don't write the\n// string into this file. Instead, create the string from the surrogate pair.\n\nvar wideChar = \"\";\n\nfor (var _i3 = 0; _i3 < letters.length; _i3++) {\n  var _ch3 = letters.charAt(_i3); // The hex numbers in the next line are a surrogate pair.\n  // 0xD835 is the high surrogate for all letters in the range we support.\n  // 0xDC00 is the low surrogate for bold A.\n\n\n  wideChar = String.fromCharCode(0xD835, 0xDC00 + _i3); // A-Z a-z bold\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC34 + _i3); // A-Z a-z italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC68 + _i3); // A-Z a-z bold italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD04 + _i3); // A-Z a-z Fraktur\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD6C + _i3); // A-Z a-z bold Fraktur\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDA0 + _i3); // A-Z a-z sans-serif\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDD4 + _i3); // A-Z a-z sans bold\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE08 + _i3); // A-Z a-z sans italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE70 + _i3); // A-Z a-z monospace\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n\n  if (_i3 < 26) {\n    // KaTeX fonts have only capital letters for blackboard bold and script.\n    // See exception for k below.\n    wideChar = String.fromCharCode(0xD835, 0xDD38 + _i3); // A-Z double struck\n\n    defineSymbol(math, main, mathord, _ch3, wideChar);\n    defineSymbol(text, main, textord, _ch3, wideChar);\n    wideChar = String.fromCharCode(0xD835, 0xDC9C + _i3); // A-Z script\n\n    defineSymbol(math, main, mathord, _ch3, wideChar);\n    defineSymbol(text, main, textord, _ch3, wideChar);\n  } // TODO: Add bold script when it is supported by a KaTeX font.\n\n} // \"k\" is the only double struck lower case letter in the KaTeX fonts.\n\n\nwideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck\n\ndefineSymbol(math, main, mathord, \"k\", wideChar);\ndefineSymbol(text, main, textord, \"k\", wideChar); // Next, some wide character numerals\n\nfor (var _i4 = 0; _i4 < 10; _i4++) {\n  var _ch4 = _i4.toString();\n\n  wideChar = String.fromCharCode(0xD835, 0xDFCE + _i4); // 0-9 bold\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFE2 + _i4); // 0-9 sans serif\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFEC + _i4); // 0-9 bold sans\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFF6 + _i4); // 0-9 monospace\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n} // We add these Latin-1 letters as symbols for backwards-compatibility,\n// but they are not actually in the font, nor are they supported by the\n// Unicode accent mechanism, so they fall back to Times font and look ugly.\n// TODO(edemaine): Fix this.\n\n\nvar extraLatin = \"\\u00d0\\u00de\\u00fe\";\n\nfor (var _i5 = 0; _i5 < extraLatin.length; _i5++) {\n  var _ch5 = extraLatin.charAt(_i5);\n\n  defineSymbol(math, main, mathord, _ch5, _ch5);\n  defineSymbol(text, main, textord, _ch5, _ch5);\n}\n\n/**\n * This file provides support for Unicode range U+1D400 to U+1D7FF,\n * Mathematical Alphanumeric Symbols.\n *\n * Function wideCharacterFont takes a wide character as input and returns\n * the font information necessary to render it properly.\n */\n/**\n * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf\n * That document sorts characters into groups by font type, say bold or italic.\n *\n * In the arrays below, each subarray consists three elements:\n *      * The CSS class of that group when in math mode.\n *      * The CSS class of that group when in text mode.\n *      * The font name, so that KaTeX can get font metrics.\n */\n\nvar wideLatinLetterData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // A-Z bold upright\n[\"mathbf\", \"textbf\", \"Main-Bold\"], // a-z bold upright\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // A-Z italic\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // a-z italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // A-Z bold italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // a-z bold italic\n// Map fancy A-Z letters to script, not calligraphic.\n// This aligns with unicode-math and math fonts (except Cambria Math).\n[\"mathscr\", \"textscr\", \"Script-Regular\"], // A-Z script\n[\"\", \"\", \"\"], // a-z script.  No font\n[\"\", \"\", \"\"], // A-Z bold script. No font\n[\"\", \"\", \"\"], // a-z bold script. No font\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // A-Z Fraktur\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // a-z Fraktur\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // A-Z double-struck\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // k double-struck\n// Note that we are using a bold font, but font metrics for regular Fraktur.\n[\"mathboldfrak\", \"textboldfrak\", \"Fraktur-Regular\"], // A-Z bold Fraktur\n[\"mathboldfrak\", \"textboldfrak\", \"Fraktur-Regular\"], // a-z bold Fraktur\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // A-Z sans-serif\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // a-z sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // A-Z bold sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // a-z bold sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // A-Z italic sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // a-z italic sans-serif\n[\"\", \"\", \"\"], // A-Z bold italic sans. No font\n[\"\", \"\", \"\"], // a-z bold italic sans. No font\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"], // A-Z monospace\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // a-z monospace\n];\nvar wideNumeralData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // 0-9 bold\n[\"\", \"\", \"\"], // 0-9 double-struck. No KaTeX font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // 0-9 sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // 0-9 bold sans-serif\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // 0-9 monospace\n];\nvar wideCharacterFont = function wideCharacterFont(wideChar, mode) {\n  // IE doesn't support codePointAt(). So work with the surrogate pair.\n  var H = wideChar.charCodeAt(0); // high surrogate\n\n  var L = wideChar.charCodeAt(1); // low surrogate\n\n  var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;\n  var j = mode === \"math\" ? 0 : 1; // column index for CSS class.\n\n  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {\n    // wideLatinLetterData contains exactly 26 chars on each row.\n    // So we can calculate the relevant row. No traverse necessary.\n    var i = Math.floor((codePoint - 0x1D400) / 26);\n    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];\n  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {\n    // Numerals, ten per row.\n    var _i = Math.floor((codePoint - 0x1D7CE) / 10);\n\n    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];\n  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {\n    // dotless i or j\n    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];\n  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {\n    // Greek letters. Not supported, yet.\n    return [\"\", \"\"];\n  } else {\n    // We don't support any wide characters outside 1D4001D7FF.\n    throw new ParseError(\"Unsupported character: \" + wideChar);\n  }\n};\n\n/* eslint no-console:0 */\n\n/**\n * Looks up the given symbol in fontMetrics, after applying any symbol\n * replacements defined in symbol.js\n */\nvar lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.\nfontName, mode) {\n  // Replace the value with its replaced value from symbol.js\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n\n  return {\n    value: value,\n    metrics: getCharacterMetrics(value, fontName, mode)\n  };\n};\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n * TODO(#953): Make `options` mandatory and always pass it in.\n */\n\n\nvar makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {\n  var lookup = lookupSymbol(value, fontName, mode);\n  var metrics = lookup.metrics;\n  value = lookup.value;\n  var symbolNode;\n\n  if (metrics) {\n    var italic = metrics.italic;\n\n    if (mode === \"text\" || options && options.font === \"mathit\") {\n      italic = 0;\n    }\n\n    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);\n  } else {\n    // TODO(emily): Figure out a good way to only print this in development\n    typeof console !== \"undefined\" && console.warn(\"No character metrics \" + (\"for '\" + value + \"' in style '\" + fontName + \"' and mode '\" + mode + \"'\"));\n    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);\n  }\n\n  if (options) {\n    symbolNode.maxFontSize = options.sizeMultiplier;\n\n    if (options.style.isTight()) {\n      symbolNode.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      symbolNode.style.color = color;\n    }\n  }\n\n  return symbolNode;\n};\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\n\n\nvar mathsym = function mathsym(value, mode, options, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n\n  // Decide what font to render the symbol in by its entry in the symbols\n  // table.\n  // Have a special case for when the value = \\ because the \\ is used as a\n  // textord in unsupported command errors but cannot be parsed as a regular\n  // text ordinal and is therefore not present as a symbol in the symbols\n  // table for text, as well as a special case for boldsymbol because it\n  // can be used for bold + and -\n  if (options.font === \"boldsymbol\" && lookupSymbol(value, \"Main-Bold\", mode).metrics) {\n    return makeSymbol(value, \"Main-Bold\", mode, options, classes.concat([\"mathbf\"]));\n  } else if (value === \"\\\\\" || symbols[mode][value].font === \"main\") {\n    return makeSymbol(value, \"Main-Regular\", mode, options, classes);\n  } else {\n    return makeSymbol(value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n  }\n};\n/**\n * Determines which of the two font names (Main-Bold and Math-BoldItalic) and\n * corresponding style tags (mathbf or boldsymbol) to use for font \"boldsymbol\",\n * depending on the symbol.  Use this function instead of fontMap for font\n * \"boldsymbol\".\n */\n\n\nvar boldsymbol = function boldsymbol(value, mode, options, classes, type) {\n  if (type !== \"textord\" && lookupSymbol(value, \"Math-BoldItalic\", mode).metrics) {\n    return {\n      fontName: \"Math-BoldItalic\",\n      fontClass: \"boldsymbol\"\n    };\n  } else {\n    // Some glyphs do not exist in Math-BoldItalic so we need to use\n    // Main-Bold instead.\n    return {\n      fontName: \"Main-Bold\",\n      fontClass: \"mathbf\"\n    };\n  }\n};\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\n\n\nvar makeOrd = function makeOrd(group, options, type) {\n  var mode = group.mode;\n  var text = group.text;\n  var classes = [\"mord\"]; // Math mode or Old font (i.e. \\rm)\n\n  var isFont = mode === \"math\" || mode === \"text\" && options.font;\n  var fontOrFamily = isFont ? options.font : options.fontFamily;\n  var wideFontName = \"\";\n  var wideFontClass = \"\";\n\n  if (text.charCodeAt(0) === 0xD835) {\n    [wideFontName, wideFontClass] = wideCharacterFont(text, mode);\n  }\n\n  if (wideFontName.length > 0) {\n    // surrogate pairs get special treatment\n    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));\n  } else if (fontOrFamily) {\n    var fontName;\n    var fontClasses;\n\n    if (fontOrFamily === \"boldsymbol\") {\n      var fontData = boldsymbol(text, mode, options, classes, type);\n      fontName = fontData.fontName;\n      fontClasses = [fontData.fontClass];\n    } else if (isFont) {\n      fontName = fontMap[fontOrFamily].fontName;\n      fontClasses = [fontOrFamily];\n    } else {\n      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);\n      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];\n    }\n\n    if (lookupSymbol(text, fontName, mode).metrics) {\n      return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));\n    } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === \"Typewriter\") {\n      // Deconstruct ligatures in monospace fonts (\\texttt, \\tt).\n      var parts = [];\n\n      for (var i = 0; i < text.length; i++) {\n        parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));\n      }\n\n      return makeFragment(parts);\n    }\n  } // Makes a symbol in the default font for mathords and textords.\n\n\n  if (type === \"mathord\") {\n    return makeSymbol(text, \"Math-Italic\", mode, options, classes.concat([\"mathnormal\"]));\n  } else if (type === \"textord\") {\n    var font = symbols[mode][text] && symbols[mode][text].font;\n\n    if (font === \"ams\") {\n      var _fontName = retrieveTextFontName(\"amsrm\", options.fontWeight, options.fontShape);\n\n      return makeSymbol(text, _fontName, mode, options, classes.concat(\"amsrm\", options.fontWeight, options.fontShape));\n    } else if (font === \"main\" || !font) {\n      var _fontName2 = retrieveTextFontName(\"textrm\", options.fontWeight, options.fontShape);\n\n      return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));\n    } else {\n      // fonts added by plugins\n      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class\n\n\n      return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));\n    }\n  } else {\n    throw new Error(\"unexpected type: \" + type + \" in makeOrd\");\n  }\n};\n/**\n * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,\n * and styles.\n */\n\n\nvar canCombine = (prev, next) => {\n  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {\n    return false;\n  } // If prev and next both are just \"mbin\"s or \"mord\"s we don't combine them\n  // so that the proper spacing can be preserved.\n\n\n  if (prev.classes.length === 1) {\n    var cls = prev.classes[0];\n\n    if (cls === \"mbin\" || cls === \"mord\") {\n      return false;\n    }\n  }\n\n  for (var style in prev.style) {\n    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {\n      return false;\n    }\n  }\n\n  for (var _style in next.style) {\n    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Combine consecutive domTree.symbolNodes into a single symbolNode.\n * Note: this function mutates the argument.\n */\n\n\nvar tryCombineChars = chars => {\n  for (var i = 0; i < chars.length - 1; i++) {\n    var prev = chars[i];\n    var next = chars[i + 1];\n\n    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {\n      prev.text += next.text;\n      prev.height = Math.max(prev.height, next.height);\n      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use\n      // it to add padding to the right of the span created from\n      // the combined characters.\n\n      prev.italic = next.italic;\n      chars.splice(i + 1, 1);\n      i--;\n    }\n  }\n\n  return chars;\n};\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\n\n\nvar sizeElementFromChildren = function sizeElementFromChildren(elem) {\n  var height = 0;\n  var depth = 0;\n  var maxFontSize = 0;\n\n  for (var i = 0; i < elem.children.length; i++) {\n    var child = elem.children[i];\n\n    if (child.height > height) {\n      height = child.height;\n    }\n\n    if (child.depth > depth) {\n      depth = child.depth;\n    }\n\n    if (child.maxFontSize > maxFontSize) {\n      maxFontSize = child.maxFontSize;\n    }\n  }\n\n  elem.height = height;\n  elem.depth = depth;\n  elem.maxFontSize = maxFontSize;\n};\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO(#953): Ensure that `options` is always provided (currently some call\n * sites don't pass it) and make the type below mandatory.\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\n\nvar makeSpan$2 = function makeSpan(classes, children, options, style) {\n  var span = new Span(classes, children, options, style);\n  sizeElementFromChildren(span);\n  return span;\n}; // SVG one is simpler -- doesn't require height, depth, max-font setting.\n// This is also a separate method for typesafety.\n\n\nvar makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);\n\nvar makeLineSpan = function makeLineSpan(className, options, thickness) {\n  var line = makeSpan$2([className], [], options);\n  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n  line.style.borderBottomWidth = makeEm(line.height);\n  line.maxFontSize = 1.0;\n  return line;\n};\n/**\n * Makes an anchor with the given href, list of classes, list of children,\n * and options.\n */\n\n\nvar makeAnchor = function makeAnchor(href, classes, children, options) {\n  var anchor = new Anchor(href, classes, children, options);\n  sizeElementFromChildren(anchor);\n  return anchor;\n};\n/**\n * Makes a document fragment with the given list of children.\n */\n\n\nvar makeFragment = function makeFragment(children) {\n  var fragment = new DocumentFragment(children);\n  sizeElementFromChildren(fragment);\n  return fragment;\n};\n/**\n * Wraps group in a span if it's a document fragment, allowing to apply classes\n * and styles\n */\n\n\nvar wrapFragment = function wrapFragment(group, options) {\n  if (group instanceof DocumentFragment) {\n    return makeSpan$2([], [group], options);\n  }\n\n  return group;\n}; // These are exact object types to catch typos in the names of the optional fields.\n\n\n// Computes the updated `children` list and the overall depth.\n//\n// This helper function for makeVList makes it easier to enforce type safety by\n// allowing early exits (returns) in the logic.\nvar getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {\n  if (params.positionType === \"individualShift\") {\n    var oldChildren = params.children;\n    var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be\n    // shifted to the correct specified shift\n\n    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n\n    var currPos = _depth;\n\n    for (var i = 1; i < oldChildren.length; i++) {\n      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;\n      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);\n      currPos = currPos + diff;\n      children.push({\n        type: \"kern\",\n        size\n      });\n      children.push(oldChildren[i]);\n    }\n\n    return {\n      children,\n      depth: _depth\n    };\n  }\n\n  var depth;\n\n  if (params.positionType === \"top\") {\n    // We always start at the bottom, so calculate the bottom by adding up\n    // all the sizes\n    var bottom = params.positionData;\n\n    for (var _i = 0; _i < params.children.length; _i++) {\n      var child = params.children[_i];\n      bottom -= child.type === \"kern\" ? child.size : child.elem.height + child.elem.depth;\n    }\n\n    depth = bottom;\n  } else if (params.positionType === \"bottom\") {\n    depth = -params.positionData;\n  } else {\n    var firstChild = params.children[0];\n\n    if (firstChild.type !== \"elem\") {\n      throw new Error('First child must have type \"elem\".');\n    }\n\n    if (params.positionType === \"shift\") {\n      depth = -firstChild.elem.depth - params.positionData;\n    } else if (params.positionType === \"firstBaseline\") {\n      depth = -firstChild.elem.depth;\n    } else {\n      throw new Error(\"Invalid positionType \" + params.positionType + \".\");\n    }\n  }\n\n  return {\n    children: params.children,\n    depth\n  };\n};\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * See VListParam documentation above.\n */\n\n\nvar makeVList = function makeVList(params, options) {\n  var {\n    children,\n    depth\n  } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to\n  // each item, where it will determine the item's baseline. Since it has\n  // `overflow:hidden`, the strut's top edge will sit on the item's line box's\n  // top edge and the strut's bottom edge will sit on the item's baseline,\n  // with no additional line-height spacing. This allows the item baseline to\n  // be positioned precisely without worrying about font ascent and\n  // line-height.\n\n  var pstrutSize = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child.type === \"elem\") {\n      var elem = child.elem;\n      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);\n    }\n  }\n\n  pstrutSize += 2;\n  var pstrut = makeSpan$2([\"pstrut\"], []);\n  pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets\n\n  var realChildren = [];\n  var minPos = depth;\n  var maxPos = depth;\n  var currPos = depth;\n\n  for (var _i2 = 0; _i2 < children.length; _i2++) {\n    var _child = children[_i2];\n\n    if (_child.type === \"kern\") {\n      currPos += _child.size;\n    } else {\n      var _elem = _child.elem;\n      var classes = _child.wrapperClasses || [];\n      var style = _child.wrapperStyle || {};\n      var childWrap = makeSpan$2(classes, [pstrut, _elem], undefined, style);\n      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);\n\n      if (_child.marginLeft) {\n        childWrap.style.marginLeft = _child.marginLeft;\n      }\n\n      if (_child.marginRight) {\n        childWrap.style.marginRight = _child.marginRight;\n      }\n\n      realChildren.push(childWrap);\n      currPos += _elem.height + _elem.depth;\n    }\n\n    minPos = Math.min(minPos, currPos);\n    maxPos = Math.max(maxPos, currPos);\n  } // The vlist contents go in a table-cell with `vertical-align:bottom`.\n  // This cell's bottom edge will determine the containing table's baseline\n  // without overly expanding the containing line-box.\n\n\n  var vlist = makeSpan$2([\"vlist\"], realChildren);\n  vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.\n\n  var rows;\n\n  if (minPos < 0) {\n    // We will define depth in an empty span with display: table-cell.\n    // It should render with the height that we define. But Chrome, in\n    // contenteditable mode only, treats that span as if it contains some\n    // text content. And that min-height over-rides our desired height.\n    // So we put another empty span inside the depth strut span.\n    var emptySpan = makeSpan$2([], []);\n    var depthStrut = makeSpan$2([\"vlist\"], [emptySpan]);\n    depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it\n    // puts the bottom of the *second* row on the baseline.\n\n    var topStrut = makeSpan$2([\"vlist-s\"], [new SymbolNode(\"\\u200b\")]);\n    rows = [makeSpan$2([\"vlist-r\"], [vlist, topStrut]), makeSpan$2([\"vlist-r\"], [depthStrut])];\n  } else {\n    rows = [makeSpan$2([\"vlist-r\"], [vlist])];\n  }\n\n  var vtable = makeSpan$2([\"vlist-t\"], rows);\n\n  if (rows.length === 2) {\n    vtable.classes.push(\"vlist-t2\");\n  }\n\n  vtable.height = maxPos;\n  vtable.depth = -minPos;\n  return vtable;\n}; // Glue is a concept from TeX which is a flexible space between elements in\n// either a vertical or horizontal list. In KaTeX, at least for now, it's\n// static space between elements in a horizontal layout.\n\n\nvar makeGlue = (measurement, options) => {\n  // Make an empty span for the space\n  var rule = makeSpan$2([\"mspace\"], [], options);\n  var size = calculateSize(measurement, options);\n  rule.style.marginRight = makeEm(size);\n  return rule;\n}; // Takes font options, and returns the appropriate fontLookup name\n\n\nvar retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {\n  var baseFontName = \"\";\n\n  switch (fontFamily) {\n    case \"amsrm\":\n      baseFontName = \"AMS\";\n      break;\n\n    case \"textrm\":\n      baseFontName = \"Main\";\n      break;\n\n    case \"textsf\":\n      baseFontName = \"SansSerif\";\n      break;\n\n    case \"texttt\":\n      baseFontName = \"Typewriter\";\n      break;\n\n    default:\n      baseFontName = fontFamily;\n    // use fonts added by a plugin\n  }\n\n  var fontStylesName;\n\n  if (fontWeight === \"textbf\" && fontShape === \"textit\") {\n    fontStylesName = \"BoldItalic\";\n  } else if (fontWeight === \"textbf\") {\n    fontStylesName = \"Bold\";\n  } else if (fontWeight === \"textit\") {\n    fontStylesName = \"Italic\";\n  } else {\n    fontStylesName = \"Regular\";\n  }\n\n  return baseFontName + \"-\" + fontStylesName;\n};\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\n\n\nvar fontMap = {\n  // styles\n  \"mathbf\": {\n    variant: \"bold\",\n    fontName: \"Main-Bold\"\n  },\n  \"mathrm\": {\n    variant: \"normal\",\n    fontName: \"Main-Regular\"\n  },\n  \"textit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathnormal\": {\n    variant: \"italic\",\n    fontName: \"Math-Italic\"\n  },\n  // \"boldsymbol\" is missing because they require the use of multiple fonts:\n  // Math-BoldItalic and Main-Bold.  This is handled by a special case in\n  // makeOrd which ends up calling boldsymbol.\n  // families\n  \"mathbb\": {\n    variant: \"double-struck\",\n    fontName: \"AMS-Regular\"\n  },\n  \"mathcal\": {\n    variant: \"script\",\n    fontName: \"Caligraphic-Regular\"\n  },\n  \"mathfrak\": {\n    variant: \"fraktur\",\n    fontName: \"Fraktur-Regular\"\n  },\n  \"mathscr\": {\n    variant: \"script\",\n    fontName: \"Script-Regular\"\n  },\n  \"mathsf\": {\n    variant: \"sans-serif\",\n    fontName: \"SansSerif-Regular\"\n  },\n  \"mathtt\": {\n    variant: \"monospace\",\n    fontName: \"Typewriter-Regular\"\n  }\n};\nvar svgData = {\n  //   path, width, height\n  vec: [\"vec\", 0.471, 0.714],\n  // values from the font glyph\n  oiintSize1: [\"oiintSize1\", 0.957, 0.499],\n  // oval to overlay the integrand\n  oiintSize2: [\"oiintSize2\", 1.472, 0.659],\n  oiiintSize1: [\"oiiintSize1\", 1.304, 0.499],\n  oiiintSize2: [\"oiiintSize2\", 1.98, 0.659]\n};\n\nvar staticSvg = function staticSvg(value, options) {\n  // Create a span with inline SVG for the element.\n  var [pathName, width, height] = svgData[value];\n  var path = new PathNode(pathName);\n  var svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + 1000 * height,\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = makeSvgSpan([\"overlay\"], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return span;\n};\n\nvar buildCommon = {\n  fontMap,\n  makeSymbol,\n  mathsym,\n  makeSpan: makeSpan$2,\n  makeSvgSpan,\n  makeLineSpan,\n  makeAnchor,\n  makeFragment,\n  wrapFragment,\n  makeVList,\n  makeOrd,\n  makeGlue,\n  staticSvg,\n  svgData,\n  tryCombineChars\n};\n\n/**\n * Describes spaces between different classes of atoms.\n */\nvar thinspace = {\n  number: 3,\n  unit: \"mu\"\n};\nvar mediumspace = {\n  number: 4,\n  unit: \"mu\"\n};\nvar thickspace = {\n  number: 5,\n  unit: \"mu\"\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n\n// Spacing relationships for display and text styles\nvar spacings = {\n  mord: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mbin: {\n    mord: mediumspace,\n    mop: mediumspace,\n    mopen: mediumspace,\n    minner: mediumspace\n  },\n  mrel: {\n    mord: thickspace,\n    mop: thickspace,\n    mopen: thickspace,\n    minner: thickspace\n  },\n  mopen: {},\n  mclose: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mpunct: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mclose: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  },\n  minner: {\n    mord: thinspace,\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  }\n}; // Spacing relationships for script and scriptscript styles\n\nvar tightSpacings = {\n  mord: {\n    mop: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace\n  },\n  mbin: {},\n  mrel: {},\n  mopen: {},\n  mclose: {\n    mop: thinspace\n  },\n  mpunct: {},\n  minner: {\n    mop: thinspace\n  }\n};\n\n/** Context provided to function handlers for error messages. */\n// Note: reverse the order of the return type union will cause a flow error.\n// See https://github.com/facebook/flow/issues/3663.\n// More general version of `HtmlBuilder` for nodes (e.g. \\sum, accent types)\n// whose presence impacts super/subscripting. In this case, ParseNode<\"supsub\">\n// delegates its HTML building to the HtmlBuilder corresponding to these nodes.\n\n/**\n * Final function spec for use at parse time.\n * This is almost identical to `FunctionPropSpec`, except it\n * 1. includes the function handler, and\n * 2. requires all arguments except argTypes.\n * It is generated by `defineFunction()` below.\n */\n\n/**\n * All registered functions.\n * `functions.js` just exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary.\n */\nvar _functions = {};\n/**\n * All HTML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _htmlGroupBuilders = {};\n/**\n * All MathML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _mathmlGroupBuilders = {};\nfunction defineFunction(_ref) {\n  var {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of functions\n  var data = {\n    type,\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    allowedInArgument: !!props.allowedInArgument,\n    allowedInText: !!props.allowedInText,\n    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    infix: !!props.infix,\n    primitive: !!props.primitive,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    _functions[names[i]] = data;\n  }\n\n  if (type) {\n    if (htmlBuilder) {\n      _htmlGroupBuilders[type] = htmlBuilder;\n    }\n\n    if (mathmlBuilder) {\n      _mathmlGroupBuilders[type] = mathmlBuilder;\n    }\n  }\n}\n/**\n * Use this to register only the HTML and MathML builders for a function (e.g.\n * if the function's ParseNode is generated in Parser.js rather than via a\n * stand-alone handler provided to `defineFunction`).\n */\n\nfunction defineFunctionBuilders(_ref2) {\n  var {\n    type,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref2;\n  defineFunction({\n    type,\n    names: [],\n    props: {\n      numArgs: 0\n    },\n\n    handler() {\n      throw new Error('Should never be called.');\n    },\n\n    htmlBuilder,\n    mathmlBuilder\n  });\n}\nvar normalizeArgument = function normalizeArgument(arg) {\n  return arg.type === \"ordgroup\" && arg.body.length === 1 ? arg.body[0] : arg;\n}; // Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\n\nvar ordargument = function ordargument(arg) {\n  return arg.type === \"ordgroup\" ? arg.body : [arg];\n};\n\n/**\n * This file does the main work of building a domTree structure from a parse\n * tree. The entry point is the `buildHTML` function, which takes a parse tree.\n * Then, the buildExpression, buildGroup, and various groupBuilders functions\n * are called, to produce a final HTML tree.\n */\nvar makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)\n// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,\n// and the text before Rule 19.\n\nvar binLeftCanceller = [\"leftmost\", \"mbin\", \"mopen\", \"mrel\", \"mop\", \"mpunct\"];\nvar binRightCanceller = [\"rightmost\", \"mrel\", \"mclose\", \"mpunct\"];\nvar styleMap$1 = {\n  \"display\": Style$1.DISPLAY,\n  \"text\": Style$1.TEXT,\n  \"script\": Style$1.SCRIPT,\n  \"scriptscript\": Style$1.SCRIPTSCRIPT\n};\nvar DomEnum = {\n  mord: \"mord\",\n  mop: \"mop\",\n  mbin: \"mbin\",\n  mrel: \"mrel\",\n  mopen: \"mopen\",\n  mclose: \"mclose\",\n  mpunct: \"mpunct\",\n  minner: \"minner\"\n};\n\n/**\n * Take a list of nodes, build them in order, and return a list of the built\n * nodes. documentFragments are flattened into their contents, so the\n * returned list contains no fragments. `isRealGroup` is true if `expression`\n * is a real group (no atoms will be added on either side), as opposed to\n * a partial group (e.g. one created by \\color). `surrounding` is an array\n * consisting type of nodes that will be added to the left and right.\n */\nvar buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {\n  if (surrounding === void 0) {\n    surrounding = [null, null];\n  }\n\n  // Parse expressions into `groups`.\n  var groups = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    var output = buildGroup$1(expression[i], options);\n\n    if (output instanceof DocumentFragment) {\n      var children = output.children;\n      groups.push(...children);\n    } else {\n      groups.push(output);\n    }\n  } // Combine consecutive domTree.symbolNodes into a single symbolNode.\n\n\n  buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings\n  // to avoid processing groups multiple times.\n\n  if (!isRealGroup) {\n    return groups;\n  }\n\n  var glueOptions = options;\n\n  if (expression.length === 1) {\n    var node = expression[0];\n\n    if (node.type === \"sizing\") {\n      glueOptions = options.havingSize(node.size);\n    } else if (node.type === \"styling\") {\n      glueOptions = options.havingStyle(styleMap$1[node.style]);\n    }\n  } // Dummy spans for determining spacings between surrounding atoms.\n  // If `expression` has no atoms on the left or right, class \"leftmost\"\n  // or \"rightmost\", respectively, is used to indicate it.\n\n\n  var dummyPrev = makeSpan$1([surrounding[0] || \"leftmost\"], [], options);\n  var dummyNext = makeSpan$1([surrounding[1] || \"rightmost\"], [], options); // TODO: These code assumes that a node's math class is the first element\n  // of its `classes` array. A later cleanup should ensure this, for\n  // instance by changing the signature of `makeSpan`.\n  // Before determining what spaces to insert, perform bin cancellation.\n  // Binary operators change to ordinary symbols in some contexts.\n\n  var isRoot = isRealGroup === \"root\";\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    var prevType = prev.classes[0];\n    var type = node.classes[0];\n\n    if (prevType === \"mbin\" && utils.contains(binRightCanceller, type)) {\n      prev.classes[0] = \"mord\";\n    } else if (type === \"mbin\" && utils.contains(binLeftCanceller, prevType)) {\n      node.classes[0] = \"mord\";\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    var prevType = getTypeOfDomTree(prev);\n    var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.\n\n    var space = prevType && type ? node.hasClass(\"mtight\") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;\n\n    if (space) {\n      // Insert glue (spacing) after the `prev`.\n      return buildCommon.makeGlue(space, glueOptions);\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  return groups;\n}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and\n// previous node as arguments, optionally returning a node to insert after the\n// previous node. `prev` is an object with the previous node and `insertAfter`\n// function to insert after it. `next` is a node that will be added to the right.\n// Used for bin cancellation and inserting spacings.\n\nvar traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next, isRoot) {\n  if (next) {\n    // temporarily append the right node, if exists\n    nodes.push(next);\n  }\n\n  var i = 0;\n\n  for (; i < nodes.length; i++) {\n    var node = nodes[i];\n    var partialGroup = checkPartialGroup(node);\n\n    if (partialGroup) {\n      // Recursive DFS\n      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array\n      traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);\n      continue;\n    } // Ignore explicit spaces (e.g., \\;, \\,) when determining what implicit\n    // spacing should go between atoms of different classes\n\n\n    var nonspace = !node.hasClass(\"mspace\");\n\n    if (nonspace) {\n      var result = callback(node, prev.node);\n\n      if (result) {\n        if (prev.insertAfter) {\n          prev.insertAfter(result);\n        } else {\n          // insert at front\n          nodes.unshift(result);\n          i++;\n        }\n      }\n    }\n\n    if (nonspace) {\n      prev.node = node;\n    } else if (isRoot && node.hasClass(\"newline\")) {\n      prev.node = makeSpan$1([\"leftmost\"]); // treat like beginning of line\n    }\n\n    prev.insertAfter = (index => n => {\n      nodes.splice(index + 1, 0, n);\n      i++;\n    })(i);\n  }\n\n  if (next) {\n    nodes.pop();\n  }\n}; // Check if given node is a partial group, i.e., does not affect spacing around.\n\n\nvar checkPartialGroup = function checkPartialGroup(node) {\n  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass(\"enclosing\")) {\n    return node;\n  }\n\n  return null;\n}; // Return the outermost node of a domTree.\n\n\nvar getOutermostNode = function getOutermostNode(node, side) {\n  var partialGroup = checkPartialGroup(node);\n\n  if (partialGroup) {\n    var children = partialGroup.children;\n\n    if (children.length) {\n      if (side === \"right\") {\n        return getOutermostNode(children[children.length - 1], \"right\");\n      } else if (side === \"left\") {\n        return getOutermostNode(children[0], \"left\");\n      }\n    }\n  }\n\n  return node;\n}; // Return math atom class (mclass) of a domTree.\n// If `side` is given, it will get the type of the outermost node at given side.\n\n\nvar getTypeOfDomTree = function getTypeOfDomTree(node, side) {\n  if (!node) {\n    return null;\n  }\n\n  if (side) {\n    node = getOutermostNode(node, side);\n  } // This makes a lot of assumptions as to where the type of atom\n  // appears.  We should do a better job of enforcing this.\n\n\n  return DomEnum[node.classes[0]] || null;\n};\nvar makeNullDelimiter = function makeNullDelimiter(options, classes) {\n  var moreClasses = [\"nulldelimiter\"].concat(options.baseSizingClasses());\n  return makeSpan$1(classes.concat(moreClasses));\n};\n/**\n * buildGroup is the function that takes a group and calls the correct groupType\n * function for it. It also handles the interaction of size and style changes\n * between parents and children.\n */\n\nvar buildGroup$1 = function buildGroup(group, options, baseOptions) {\n  if (!group) {\n    return makeSpan$1();\n  }\n\n  if (_htmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account\n    // for that size difference.\n\n    if (baseOptions && options.size !== baseOptions.size) {\n      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);\n      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n\n    return groupNode;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)\n * into an unbreakable HTML node of class .base, with proper struts to\n * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to\n * make up the entire expression as a sequence of unbreakable units.\n */\n\nfunction buildHTMLUnbreakable(children, options) {\n  // Compute height and depth of this chunk.\n  var body = makeSpan$1([\"base\"], children, options); // Add strut, which ensures that the top of the HTML element falls at\n  // the height of the expression, and the bottom of the HTML element\n  // falls at the depth of the expression.\n\n  var strut = makeSpan$1([\"strut\"]);\n  strut.style.height = makeEm(body.height + body.depth);\n\n  if (body.depth) {\n    strut.style.verticalAlign = makeEm(-body.depth);\n  }\n\n  body.children.unshift(strut);\n  return body;\n}\n/**\n * Take an entire parse tree, and build it into an appropriate set of HTML\n * nodes.\n */\n\n\nfunction buildHTML(tree, options) {\n  // Strip off outer tag wrapper for processing below.\n  var tag = null;\n\n  if (tree.length === 1 && tree[0].type === \"tag\") {\n    tag = tree[0].tag;\n    tree = tree[0].body;\n  } // Build the expression contained in the tree\n\n\n  var expression = buildExpression$1(tree, options, \"root\");\n  var eqnNum;\n\n  if (expression.length === 2 && expression[1].hasClass(\"tag\")) {\n    // An environment with automatic equation numbers, e.g. {gather}.\n    eqnNum = expression.pop();\n  }\n\n  var children = []; // Create one base node for each chunk between potential line breaks.\n  // The TeXBook [p.173] says \"A formula will be broken only after a\n  // relation symbol like $=$ or $<$ or $\\rightarrow$, or after a binary\n  // operation symbol like $+$ or $-$ or $\\times$, where the relation or\n  // binary operation is on the ``outer level'' of the formula (i.e., not\n  // enclosed in {...} and not part of an \\over construction).\"\n\n  var parts = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    parts.push(expression[i]);\n\n    if (expression[i].hasClass(\"mbin\") || expression[i].hasClass(\"mrel\") || expression[i].hasClass(\"allowbreak\")) {\n      // Put any post-operator glue on same line as operator.\n      // Watch for \\nobreak along the way, and stop at \\newline.\n      var nobreak = false;\n\n      while (i < expression.length - 1 && expression[i + 1].hasClass(\"mspace\") && !expression[i + 1].hasClass(\"newline\")) {\n        i++;\n        parts.push(expression[i]);\n\n        if (expression[i].hasClass(\"nobreak\")) {\n          nobreak = true;\n        }\n      } // Don't allow break if \\nobreak among the post-operator glue.\n\n\n      if (!nobreak) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      }\n    } else if (expression[i].hasClass(\"newline\")) {\n      // Write the line except the newline\n      parts.pop();\n\n      if (parts.length > 0) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      } // Put the newline at the top level\n\n\n      children.push(expression[i]);\n    }\n  }\n\n  if (parts.length > 0) {\n    children.push(buildHTMLUnbreakable(parts, options));\n  } // Now, if there was a tag, build it too and append it as a final child.\n\n\n  var tagChild;\n\n  if (tag) {\n    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));\n    tagChild.classes = [\"tag\"];\n    children.push(tagChild);\n  } else if (eqnNum) {\n    children.push(eqnNum);\n  }\n\n  var htmlNode = makeSpan$1([\"katex-html\"], children);\n  htmlNode.setAttribute(\"aria-hidden\", \"true\"); // Adjust the strut of the tag to be the maximum height of all children\n  // (the height of the enclosing htmlNode) for proper vertical alignment.\n\n  if (tagChild) {\n    var strut = tagChild.children[0];\n    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);\n\n    if (htmlNode.depth) {\n      strut.style.verticalAlign = makeEm(-htmlNode.depth);\n    }\n  }\n\n  return htmlNode;\n}\n\n/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work similarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\nfunction newDocumentFragment(children) {\n  return new DocumentFragment(children);\n}\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\n\nclass MathNode {\n  constructor(type, children, classes) {\n    this.type = void 0;\n    this.attributes = void 0;\n    this.children = void 0;\n    this.classes = void 0;\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n    this.classes = classes || [];\n  }\n  /**\n   * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n   * semantic content, so this is used heavily.\n   */\n\n\n  setAttribute(name, value) {\n    this.attributes[name] = value;\n  }\n  /**\n   * Gets an attribute on a MathML node.\n   */\n\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    if (this.classes.length > 0) {\n      node.className = createClass(this.classes);\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    var markup = \"<\" + this.type; // Add the attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\";\n        markup += utils.escape(this.attributes[attr]);\n        markup += \"\\\"\";\n      }\n    }\n\n    if (this.classes.length > 0) {\n      markup += \" class =\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText, but escaped.\n   */\n\n\n  toText() {\n    return this.children.map(child => child.toText()).join(\"\");\n  }\n\n}\n/**\n * This node represents a piece of text.\n */\n\nclass TextNode {\n  constructor(text) {\n    this.text = void 0;\n    this.text = text;\n  }\n  /**\n   * Converts the text node into a DOM text node.\n   */\n\n\n  toNode() {\n    return document.createTextNode(this.text);\n  }\n  /**\n   * Converts the text node into escaped HTML markup\n   * (representing the text itself).\n   */\n\n\n  toMarkup() {\n    return utils.escape(this.toText());\n  }\n  /**\n   * Converts the text node into a string\n   * (representing the text itself).\n   */\n\n\n  toText() {\n    return this.text;\n  }\n\n}\n/**\n * This node represents a space, but may render as <mspace.../> or as text,\n * depending on the width.\n */\n\nclass SpaceNode {\n  /**\n   * Create a Space node with width given in CSS ems.\n   */\n  constructor(width) {\n    this.width = void 0;\n    this.character = void 0;\n    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html\n    // for a table of space-like characters.  We use Unicode\n    // representations instead of &LongNames; as it's not clear how to\n    // make the latter via document.createTextNode.\n\n    if (width >= 0.05555 && width <= 0.05556) {\n      this.character = \"\\u200a\"; // &VeryThinSpace;\n    } else if (width >= 0.1666 && width <= 0.1667) {\n      this.character = \"\\u2009\"; // &ThinSpace;\n    } else if (width >= 0.2222 && width <= 0.2223) {\n      this.character = \"\\u2005\"; // &MediumSpace;\n    } else if (width >= 0.2777 && width <= 0.2778) {\n      this.character = \"\\u2005\\u200a\"; // &ThickSpace;\n    } else if (width >= -0.05556 && width <= -0.05555) {\n      this.character = \"\\u200a\\u2063\"; // &NegativeVeryThinSpace;\n    } else if (width >= -0.1667 && width <= -0.1666) {\n      this.character = \"\\u2009\\u2063\"; // &NegativeThinSpace;\n    } else if (width >= -0.2223 && width <= -0.2222) {\n      this.character = \"\\u205f\\u2063\"; // &NegativeMediumSpace;\n    } else if (width >= -0.2778 && width <= -0.2777) {\n      this.character = \"\\u2005\\u2063\"; // &NegativeThickSpace;\n    } else {\n      this.character = null;\n    }\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    if (this.character) {\n      return document.createTextNode(this.character);\n    } else {\n      var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"mspace\");\n      node.setAttribute(\"width\", makeEm(this.width));\n      return node;\n    }\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    if (this.character) {\n      return \"<mtext>\" + this.character + \"</mtext>\";\n    } else {\n      return \"<mspace width=\\\"\" + makeEm(this.width) + \"\\\"/>\";\n    }\n  }\n  /**\n   * Converts the math node into a string, similar to innerText.\n   */\n\n\n  toText() {\n    if (this.character) {\n      return this.character;\n    } else {\n      return \" \";\n    }\n  }\n\n}\n\nvar mathMLTree = {\n  MathNode,\n  TextNode,\n  SpaceNode,\n  newDocumentFragment\n};\n\n/**\n * This file converts a parse tree into a corresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar makeText = function makeText(text, mode, options) {\n  if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === \"tt\" || options.font && options.font.slice(4, 6) === \"tt\"))) {\n    text = symbols[mode][text].replace;\n  }\n\n  return new mathMLTree.TextNode(text);\n};\n/**\n * Wrap the given array of nodes in an <mrow> node if needed, i.e.,\n * unless the array has length 1.  Always returns a single node.\n */\n\nvar makeRow = function makeRow(body) {\n  if (body.length === 1) {\n    return body[0];\n  } else {\n    return new mathMLTree.MathNode(\"mrow\", body);\n  }\n};\n/**\n * Returns the math variant as a string or null if none is required.\n */\n\nvar getVariant = function getVariant(group, options) {\n  // Handle \\text... font specifiers as best we can.\n  // MathML has a limited list of allowable mathvariant specifiers; see\n  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt\n  if (options.fontFamily === \"texttt\") {\n    return \"monospace\";\n  } else if (options.fontFamily === \"textsf\") {\n    if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n      return \"sans-serif-bold-italic\";\n    } else if (options.fontShape === \"textit\") {\n      return \"sans-serif-italic\";\n    } else if (options.fontWeight === \"textbf\") {\n      return \"bold-sans-serif\";\n    } else {\n      return \"sans-serif\";\n    }\n  } else if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n    return \"bold-italic\";\n  } else if (options.fontShape === \"textit\") {\n    return \"italic\";\n  } else if (options.fontWeight === \"textbf\") {\n    return \"bold\";\n  }\n\n  var font = options.font;\n\n  if (!font || font === \"mathnormal\") {\n    return null;\n  }\n\n  var mode = group.mode;\n\n  if (font === \"mathit\") {\n    return \"italic\";\n  } else if (font === \"boldsymbol\") {\n    return group.type === \"textord\" ? \"bold\" : \"bold-italic\";\n  } else if (font === \"mathbf\") {\n    return \"bold\";\n  } else if (font === \"mathbb\") {\n    return \"double-struck\";\n  } else if (font === \"mathfrak\") {\n    return \"fraktur\";\n  } else if (font === \"mathscr\" || font === \"mathcal\") {\n    // MathML makes no distinction between script and calligraphic\n    return \"script\";\n  } else if (font === \"mathsf\") {\n    return \"sans-serif\";\n  } else if (font === \"mathtt\") {\n    return \"monospace\";\n  }\n\n  var text = group.text;\n\n  if (utils.contains([\"\\\\imath\", \"\\\\jmath\"], text)) {\n    return null;\n  }\n\n  if (symbols[mode][text] && symbols[mode][text].replace) {\n    text = symbols[mode][text].replace;\n  }\n\n  var fontName = buildCommon.fontMap[font].fontName;\n\n  if (getCharacterMetrics(text, fontName, mode)) {\n    return buildCommon.fontMap[font].variant;\n  }\n\n  return null;\n};\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes.  Also combine consecutive <mtext> outputs into a single\n * <mtext> tag.\n */\n\nvar buildExpression = function buildExpression(expression, options, isOrdgroup) {\n  if (expression.length === 1) {\n    var group = buildGroup(expression[0], options);\n\n    if (isOrdgroup && group instanceof MathNode && group.type === \"mo\") {\n      // When TeX writers want to suppress spacing on an operator,\n      // they often put the operator by itself inside braces.\n      group.setAttribute(\"lspace\", \"0em\");\n      group.setAttribute(\"rspace\", \"0em\");\n    }\n\n    return [group];\n  }\n\n  var groups = [];\n  var lastGroup;\n\n  for (var i = 0; i < expression.length; i++) {\n    var _group = buildGroup(expression[i], options);\n\n    if (_group instanceof MathNode && lastGroup instanceof MathNode) {\n      // Concatenate adjacent <mtext>s\n      if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate adjacent <mn>s\n      } else if (_group.type === 'mn' && lastGroup.type === 'mn') {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>\n      } else if (_group.type === 'mi' && _group.children.length === 1 && lastGroup.type === 'mn') {\n        var child = _group.children[0];\n\n        if (child instanceof TextNode && child.text === '.') {\n          lastGroup.children.push(..._group.children);\n          continue;\n        }\n      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {\n        var lastChild = lastGroup.children[0];\n\n        if (lastChild instanceof TextNode && lastChild.text === '\\u0338' && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {\n          var _child = _group.children[0];\n\n          if (_child instanceof TextNode && _child.text.length > 0) {\n            // Overlay with combining character long solidus\n            _child.text = _child.text.slice(0, 1) + \"\\u0338\" + _child.text.slice(1);\n            groups.pop();\n          }\n        }\n      }\n    }\n\n    groups.push(_group);\n    lastGroup = _group;\n  }\n\n  return groups;\n};\n/**\n * Equivalent to buildExpression, but wraps the elements in an <mrow>\n * if there's more than one.  Returns a single node instead of an array.\n */\n\nvar buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {\n  return makeRow(buildExpression(expression, options, isOrdgroup));\n};\n/**\n * Takes a group from the parser and calls the appropriate groupBuilders function\n * on it to produce a MathML node.\n */\n\nvar buildGroup = function buildGroup(group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n\n  if (_mathmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    var result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe\n\n    return result;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\n\nfunction buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {\n  var expression = buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes\n  // and add spacing nodes. This is necessary only adjacent to math operators\n  // like \\sin or \\lim or to subsup elements that contain math operators.\n  // MathML takes care of the other spacing issues.\n  // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly, unless it's a single <mrow> or <mtable>.\n\n  var wrapper;\n\n  if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains([\"mrow\", \"mtable\"], expression[0].type)) {\n    wrapper = expression[0];\n  } else {\n    wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n  } // Build a TeX annotation of the source\n\n\n  var annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  var semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  var math = new mathMLTree.MathNode(\"math\", [semantics]);\n  math.setAttribute(\"xmlns\", \"http://www.w3.org/1998/Math/MathML\");\n\n  if (isDisplayMode) {\n    math.setAttribute(\"display\", \"block\");\n  } // You can't style <math> nodes, so we wrap the node in a span.\n  // NOTE: The span class is not typed to have <math> nodes as children, and\n  // we don't want to make the children type more generic since the children\n  // of span are expected to have more fields in `buildHtml` contexts.\n\n\n  var wrapperClass = forMathmlOnly ? \"katex\" : \"katex-mathml\"; // $FlowFixMe\n\n  return buildCommon.makeSpan([wrapperClass], [math]);\n}\n\nvar optionsFromSettings = function optionsFromSettings(settings) {\n  return new Options({\n    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,\n    maxSize: settings.maxSize,\n    minRuleThickness: settings.minRuleThickness\n  });\n};\n\nvar displayWrap = function displayWrap(node, settings) {\n  if (settings.displayMode) {\n    var classes = [\"katex-display\"];\n\n    if (settings.leqno) {\n      classes.push(\"leqno\");\n    }\n\n    if (settings.fleqn) {\n      classes.push(\"fleqn\");\n    }\n\n    node = buildCommon.makeSpan(classes, [node]);\n  }\n\n  return node;\n};\n\nvar buildTree = function buildTree(tree, expression, settings) {\n  var options = optionsFromSettings(settings);\n  var katexNode;\n\n  if (settings.output === \"mathml\") {\n    return buildMathML(tree, expression, options, settings.displayMode, true);\n  } else if (settings.output === \"html\") {\n    var htmlNode = buildHTML(tree, options);\n    katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  } else {\n    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);\n\n    var _htmlNode = buildHTML(tree, options);\n\n    katexNode = buildCommon.makeSpan([\"katex\"], [mathMLNode, _htmlNode]);\n  }\n\n  return displayWrap(katexNode, settings);\n};\nvar buildHTMLTree = function buildHTMLTree(tree, expression, settings) {\n  var options = optionsFromSettings(settings);\n  var htmlNode = buildHTML(tree, options);\n  var katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  return displayWrap(katexNode, settings);\n};\n\n/**\n * This file provides support to buildMathML.js and buildHTML.js\n * for stretchy wide elements rendered from SVG files\n * and other CSS trickery.\n */\nvar stretchyCodePoint = {\n  widehat: \"^\",\n  widecheck: \"\",\n  widetilde: \"~\",\n  utilde: \"~\",\n  overleftarrow: \"\\u2190\",\n  underleftarrow: \"\\u2190\",\n  xleftarrow: \"\\u2190\",\n  overrightarrow: \"\\u2192\",\n  underrightarrow: \"\\u2192\",\n  xrightarrow: \"\\u2192\",\n  underbrace: \"\\u23df\",\n  overbrace: \"\\u23de\",\n  overgroup: \"\\u23e0\",\n  undergroup: \"\\u23e1\",\n  overleftrightarrow: \"\\u2194\",\n  underleftrightarrow: \"\\u2194\",\n  xleftrightarrow: \"\\u2194\",\n  Overrightarrow: \"\\u21d2\",\n  xRightarrow: \"\\u21d2\",\n  overleftharpoon: \"\\u21bc\",\n  xleftharpoonup: \"\\u21bc\",\n  overrightharpoon: \"\\u21c0\",\n  xrightharpoonup: \"\\u21c0\",\n  xLeftarrow: \"\\u21d0\",\n  xLeftrightarrow: \"\\u21d4\",\n  xhookleftarrow: \"\\u21a9\",\n  xhookrightarrow: \"\\u21aa\",\n  xmapsto: \"\\u21a6\",\n  xrightharpoondown: \"\\u21c1\",\n  xleftharpoondown: \"\\u21bd\",\n  xrightleftharpoons: \"\\u21cc\",\n  xleftrightharpoons: \"\\u21cb\",\n  xtwoheadleftarrow: \"\\u219e\",\n  xtwoheadrightarrow: \"\\u21a0\",\n  xlongequal: \"=\",\n  xtofrom: \"\\u21c4\",\n  xrightleftarrows: \"\\u21c4\",\n  xrightequilibrium: \"\\u21cc\",\n  // Not a perfect match.\n  xleftequilibrium: \"\\u21cb\",\n  // None better available.\n  \"\\\\cdrightarrow\": \"\\u2192\",\n  \"\\\\cdleftarrow\": \"\\u2190\",\n  \"\\\\cdlongequal\": \"=\"\n};\n\nvar mathMLnode = function mathMLnode(label) {\n  var node = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\\\/, '')])]);\n  node.setAttribute(\"stretchy\", \"true\");\n  return node;\n}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.\n// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)\n// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)\n// Licensed under the SIL Open Font License, Version 1.1.\n// See \\nhttp://scripts.sil.org/OFL\n// Very Long SVGs\n//    Many of the KaTeX stretchy wide elements use a long SVG image and an\n//    overflow: hidden tactic to achieve a stretchy image while avoiding\n//    distortion of arrowheads or brace corners.\n//    The SVG typically contains a very long (400 em) arrow.\n//    The SVG is in a container span that has overflow: hidden, so the span\n//    acts like a window that exposes only part of the  SVG.\n//    The SVG always has a longer, thinner aspect ratio than the container span.\n//    After the SVG fills 100% of the height of the container span,\n//    there is a long arrow shaft left over. That left-over shaft is not shown.\n//    Instead, it is sliced off because the span's CSS has overflow: hidden.\n//    Thus, the reader sees an arrow that matches the subject matter width\n//    without distortion.\n//    Some functions, such as \\cancel, need to vary their aspect ratio. These\n//    functions do not get the overflow SVG treatment.\n// Second Brush Stroke\n//    Low resolution monitors struggle to display images in fine detail.\n//    So browsers apply anti-aliasing. A long straight arrow shaft therefore\n//    will sometimes appear as if it has a blurred edge.\n//    To mitigate this, these SVG files contain a second \"brush-stroke\" on the\n//    arrow shafts. That is, a second long thin rectangular SVG path has been\n//    written directly on top of each arrow shaft. This reinforcement causes\n//    some of the screen pixels to display as black instead of the anti-aliased\n//    gray pixel that a  single path would generate. So we get arrow shafts\n//    whose edges appear to be sharper.\n// In the katexImagesData object just below, the dimensions all\n// correspond to path geometry inside the relevant SVG.\n// For example, \\overrightarrow uses the same arrowhead as glyph U+2192\n// from the KaTeX Main font. The scaling factor is 1000.\n// That is, inside the font, that arrowhead is 522 units tall, which\n// corresponds to 0.522 em inside the document.\n\n\nvar katexImagesData = {\n  //   path(s), minWidth, height, align\n  overrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  overleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  underrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  underleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  xrightarrow: [[\"rightarrow\"], 1.469, 522, \"xMaxYMin\"],\n  \"\\\\cdrightarrow\": [[\"rightarrow\"], 3.0, 522, \"xMaxYMin\"],\n  // CD minwwidth2.5pc\n  xleftarrow: [[\"leftarrow\"], 1.469, 522, \"xMinYMin\"],\n  \"\\\\cdleftarrow\": [[\"leftarrow\"], 3.0, 522, \"xMinYMin\"],\n  Overrightarrow: [[\"doublerightarrow\"], 0.888, 560, \"xMaxYMin\"],\n  xRightarrow: [[\"doublerightarrow\"], 1.526, 560, \"xMaxYMin\"],\n  xLeftarrow: [[\"doubleleftarrow\"], 1.526, 560, \"xMinYMin\"],\n  overleftharpoon: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoonup: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoondown: [[\"leftharpoondown\"], 0.888, 522, \"xMinYMin\"],\n  overrightharpoon: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoonup: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoondown: [[\"rightharpoondown\"], 0.888, 522, \"xMaxYMin\"],\n  xlongequal: [[\"longequal\"], 0.888, 334, \"xMinYMin\"],\n  \"\\\\cdlongequal\": [[\"longequal\"], 3.0, 334, \"xMinYMin\"],\n  xtwoheadleftarrow: [[\"twoheadleftarrow\"], 0.888, 334, \"xMinYMin\"],\n  xtwoheadrightarrow: [[\"twoheadrightarrow\"], 0.888, 334, \"xMaxYMin\"],\n  overleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  overbrace: [[\"leftbrace\", \"midbrace\", \"rightbrace\"], 1.6, 548],\n  underbrace: [[\"leftbraceunder\", \"midbraceunder\", \"rightbraceunder\"], 1.6, 548],\n  underleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  xleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 1.75, 522],\n  xLeftrightarrow: [[\"doubleleftarrow\", \"doublerightarrow\"], 1.75, 560],\n  xrightleftharpoons: [[\"leftharpoondownplus\", \"rightharpoonplus\"], 1.75, 716],\n  xleftrightharpoons: [[\"leftharpoonplus\", \"rightharpoondownplus\"], 1.75, 716],\n  xhookleftarrow: [[\"leftarrow\", \"righthook\"], 1.08, 522],\n  xhookrightarrow: [[\"lefthook\", \"rightarrow\"], 1.08, 522],\n  overlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  underlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  overgroup: [[\"leftgroup\", \"rightgroup\"], 0.888, 342],\n  undergroup: [[\"leftgroupunder\", \"rightgroupunder\"], 0.888, 342],\n  xmapsto: [[\"leftmapsto\", \"rightarrow\"], 1.5, 522],\n  xtofrom: [[\"leftToFrom\", \"rightToFrom\"], 1.75, 528],\n  // The next three arrows are from the mhchem package.\n  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the\n  // document as \\xrightarrow or \\xrightleftharpoons. Those have\n  // min-length = 1.75em, so we set min-length on these next three to match.\n  xrightleftarrows: [[\"baraboveleftarrow\", \"rightarrowabovebar\"], 1.75, 901],\n  xrightequilibrium: [[\"baraboveshortleftharpoon\", \"rightharpoonaboveshortbar\"], 1.75, 716],\n  xleftequilibrium: [[\"shortbaraboveleftharpoon\", \"shortrightharpoonabovebar\"], 1.75, 716]\n};\n\nvar groupLength = function groupLength(arg) {\n  if (arg.type === \"ordgroup\") {\n    return arg.body.length;\n  } else {\n    return 1;\n  }\n};\n\nvar svgSpan = function svgSpan(group, options) {\n  // Create a span with inline SVG for the element.\n  function buildSvgSpan_() {\n    var viewBoxWidth = 400000; // default\n\n    var label = group.label.slice(1);\n\n    if (utils.contains([\"widehat\", \"widecheck\", \"widetilde\", \"utilde\"], label)) {\n      // Each type in the `if` statement corresponds to one of the ParseNode\n      // types below. This narrowing is required to access `grp.base`.\n      // $FlowFixMe\n      var grp = group; // There are four SVG images available for each function.\n      // Choose a taller image when there are more characters.\n\n      var numChars = groupLength(grp.base);\n      var viewBoxHeight;\n      var pathName;\n\n      var _height;\n\n      if (numChars > 5) {\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxHeight = 420;\n          viewBoxWidth = 2364;\n          _height = 0.42;\n          pathName = label + \"4\";\n        } else {\n          viewBoxHeight = 312;\n          viewBoxWidth = 2340;\n          _height = 0.34;\n          pathName = \"tilde4\";\n        }\n      } else {\n        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];\n\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];\n          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];\n          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];\n          pathName = label + imgIndex;\n        } else {\n          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];\n          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];\n          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];\n          pathName = \"tilde\" + imgIndex;\n        }\n      }\n\n      var path = new PathNode(pathName);\n      var svgNode = new SvgNode([path], {\n        \"width\": \"100%\",\n        \"height\": makeEm(_height),\n        \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight,\n        \"preserveAspectRatio\": \"none\"\n      });\n      return {\n        span: buildCommon.makeSvgSpan([], [svgNode], options),\n        minWidth: 0,\n        height: _height\n      };\n    } else {\n      var spans = [];\n      var data = katexImagesData[label];\n      var [paths, _minWidth, _viewBoxHeight] = data;\n\n      var _height2 = _viewBoxHeight / 1000;\n\n      var numSvgChildren = paths.length;\n      var widthClasses;\n      var aligns;\n\n      if (numSvgChildren === 1) {\n        // $FlowFixMe: All these cases must be of the 4-tuple type.\n        var align1 = data[3];\n        widthClasses = [\"hide-tail\"];\n        aligns = [align1];\n      } else if (numSvgChildren === 2) {\n        widthClasses = [\"halfarrow-left\", \"halfarrow-right\"];\n        aligns = [\"xMinYMin\", \"xMaxYMin\"];\n      } else if (numSvgChildren === 3) {\n        widthClasses = [\"brace-left\", \"brace-center\", \"brace-right\"];\n        aligns = [\"xMinYMin\", \"xMidYMin\", \"xMaxYMin\"];\n      } else {\n        throw new Error(\"Correct katexImagesData or update code here to support\\n                    \" + numSvgChildren + \" children.\");\n      }\n\n      for (var i = 0; i < numSvgChildren; i++) {\n        var _path = new PathNode(paths[i]);\n\n        var _svgNode = new SvgNode([_path], {\n          \"width\": \"400em\",\n          \"height\": makeEm(_height2),\n          \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + _viewBoxHeight,\n          \"preserveAspectRatio\": aligns[i] + \" slice\"\n        });\n\n        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);\n\n        if (numSvgChildren === 1) {\n          return {\n            span: _span,\n            minWidth: _minWidth,\n            height: _height2\n          };\n        } else {\n          _span.style.height = makeEm(_height2);\n          spans.push(_span);\n        }\n      }\n\n      return {\n        span: buildCommon.makeSpan([\"stretchy\"], spans, options),\n        minWidth: _minWidth,\n        height: _height2\n      };\n    }\n  } // buildSvgSpan_()\n\n\n  var {\n    span,\n    minWidth,\n    height\n  } = buildSvgSpan_(); // Note that we are returning span.depth = 0.\n  // Any adjustments relative to the baseline must be done in buildHTML.\n\n  span.height = height;\n  span.style.height = makeEm(height);\n\n  if (minWidth > 0) {\n    span.style.minWidth = makeEm(minWidth);\n  }\n\n  return span;\n};\n\nvar encloseSpan = function encloseSpan(inner, label, topPad, bottomPad, options) {\n  // Return an image span for \\cancel, \\bcancel, \\xcancel, \\fbox, or \\angl\n  var img;\n  var totalHeight = inner.height + inner.depth + topPad + bottomPad;\n\n  if (/fbox|color|angl/.test(label)) {\n    img = buildCommon.makeSpan([\"stretchy\", label], [], options);\n\n    if (label === \"fbox\") {\n      var color = options.color && options.getColor();\n\n      if (color) {\n        img.style.borderColor = color;\n      }\n    }\n  } else {\n    // \\cancel, \\bcancel, or \\xcancel\n    // Since \\cancel's SVG is inline and it omits the viewBox attribute,\n    // its stroke-width will not vary with span area.\n    var lines = [];\n\n    if (/^[bx]cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"0\",\n        \"x2\": \"100%\",\n        \"y2\": \"100%\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    if (/^x?cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"100%\",\n        \"x2\": \"100%\",\n        \"y2\": \"0\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    var svgNode = new SvgNode(lines, {\n      \"width\": \"100%\",\n      \"height\": makeEm(totalHeight)\n    });\n    img = buildCommon.makeSvgSpan([], [svgNode], options);\n  }\n\n  img.height = totalHeight;\n  img.style.height = makeEm(totalHeight);\n  return img;\n};\n\nvar stretchy = {\n  encloseSpan,\n  mathMLnode,\n  svgSpan\n};\n\n/**\n * Asserts that the node is of the given type and returns it with stricter\n * typing. Throws if the node's type does not match.\n */\nfunction assertNodeType(node, type) {\n  if (!node || node.type !== type) {\n    throw new Error(\"Expected node of type \" + type + \", but got \" + (node ? \"node of type \" + node.type : String(node)));\n  } // $FlowFixMe, >=0.125\n\n\n  return node;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction assertSymbolNodeType(node) {\n  var typedNode = checkSymbolNodeType(node);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of symbol group type, but got \" + (node ? \"node of type \" + node.type : String(node)));\n  }\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkSymbolNodeType(node) {\n  if (node && (node.type === \"atom\" || NON_ATOMS.hasOwnProperty(node.type))) {\n    // $FlowFixMe\n    return node;\n  }\n\n  return null;\n}\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"accent\", but\n// also \"supsub\" since an accent can affect super/subscripting.\nvar htmlBuilder$a = (grp, options) => {\n  // Accents are handled in the TeXbook pg. 443, rule 12.\n  var base;\n  var group;\n  var supSubGroup;\n\n  if (grp && grp.type === \"supsub\") {\n    // If our base is a character box, and we have superscripts and\n    // subscripts, the supsub will defer to us. In particular, we want\n    // to attach the superscripts and subscripts to the inner body (so\n    // that the position of the superscripts and subscripts won't be\n    // affected by the height of the accent). We accomplish this by\n    // sticking the base of the accent into the base of the supsub, and\n    // rendering that, while keeping track of where the accent is.\n    // The real accent group is the base of the supsub group\n    group = assertNodeType(grp.base, \"accent\"); // The character box is the base of the accent group\n\n    base = group.base; // Stick the character box into the base of the supsub group\n\n    grp.base = base; // Rerender the supsub group with its new base, and store that\n    // result.\n\n    supSubGroup = assertSpan(buildGroup$1(grp, options)); // reset original base\n\n    grp.base = group;\n  } else {\n    group = assertNodeType(grp, \"accent\");\n    base = group.base;\n  } // Build the base group\n\n\n  var body = buildGroup$1(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?\n\n  var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line \"If the\n  // nucleus is not a single character, let s = 0; otherwise set s to the\n  // kern amount for the nucleus followed by the \\skewchar of its font.\"\n  // Note that our skew metrics are just the kern between each character\n  // and the skewchar.\n\n  var skew = 0;\n\n  if (mustShift) {\n    // If the base is a character box, then we want the skew of the\n    // innermost character. To do that, we find the innermost character:\n    var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it\n\n    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.\n\n    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we\n    // removed with getBaseElem might contain things like \\color which\n    // we can't get rid of.\n    // TODO(emily): Find a better way to get the skew\n  }\n\n  var accentBelow = group.label === \"\\\\c\"; // calculate the amount of space between the body and the accent\n\n  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent\n\n  var accentBody;\n\n  if (!group.isStretchy) {\n    var accent;\n    var width;\n\n    if (group.label === \"\\\\vec\") {\n      // Before version 0.9, \\vec used the combining font glyph U+20D7.\n      // But browsers, especially Safari, are not consistent in how they\n      // render combining characters when not preceded by a character.\n      // So now we use an SVG.\n      // If Safari reforms, we should consider reverting to the glyph.\n      accent = buildCommon.staticSvg(\"vec\", options);\n      width = buildCommon.svgData.vec[1];\n    } else {\n      accent = buildCommon.makeOrd({\n        mode: group.mode,\n        text: group.label\n      }, options, \"textord\");\n      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to\n      // shift the accent over to a place we don't want.\n\n      accent.italic = 0;\n      width = accent.width;\n\n      if (accentBelow) {\n        clearance += accent.depth;\n      }\n    }\n\n    accentBody = buildCommon.makeSpan([\"accent-body\"], [accent]); // \"Full\" accents expand the width of the resulting symbol to be\n    // at least the width of the accent, and overlap directly onto the\n    // character without any vertical offset.\n\n    var accentFull = group.label === \"\\\\textcircled\";\n\n    if (accentFull) {\n      accentBody.classes.push('accent-full');\n      clearance = body.height;\n    } // Shift the accent over by the skew.\n\n\n    var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`\n    // so that the accent doesn't contribute to the bounding box.\n    // We need to shift the character by its width (effectively half\n    // its width) to compensate.\n\n    if (!accentFull) {\n      left -= width / 2;\n    }\n\n    accentBody.style.left = makeEm(left); // \\textcircled uses the \\bigcirc glyph, so it needs some\n    // vertical adjustment to match LaTeX.\n\n    if (group.label === \"\\\\textcircled\") {\n      accentBody.style.top = \".2em\";\n    }\n\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: -clearance\n      }, {\n        type: \"elem\",\n        elem: accentBody\n      }]\n    }, options);\n  } else {\n    accentBody = stretchy.svgSpan(group, options);\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"],\n        wrapperStyle: skew > 0 ? {\n          width: \"calc(100% - \" + makeEm(2 * skew) + \")\",\n          marginLeft: makeEm(2 * skew)\n        } : undefined\n      }]\n    }, options);\n  }\n\n  var accentWrap = buildCommon.makeSpan([\"mord\", \"accent\"], [accentBody], options);\n\n  if (supSubGroup) {\n    // Here, we replace the \"base\" child of the supsub with our newly\n    // generated accent.\n    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the\n    // accent, we manually recalculate height.\n\n    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.\n\n    supSubGroup.classes[0] = \"mord\";\n    return supSubGroup;\n  } else {\n    return accentWrap;\n  }\n};\n\nvar mathmlBuilder$9 = (group, options) => {\n  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode(\"mo\", [makeText(group.label, group.mode)]);\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\nvar NON_STRETCHY_ACCENT_REGEX = new RegExp([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\"].map(accent => \"\\\\\" + accent).join(\"|\")); // Accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\", \"\\\\widecheck\", \"\\\\widehat\", \"\\\\widetilde\", \"\\\\overrightarrow\", \"\\\\overleftarrow\", \"\\\\Overrightarrow\", \"\\\\overleftrightarrow\", \"\\\\overgroup\", \"\\\\overlinesegment\", \"\\\\overleftharpoon\", \"\\\\overrightharpoon\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (context, args) => {\n    var base = normalizeArgument(args[0]);\n    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);\n    var isShifty = !isStretchy || context.funcName === \"\\\\widehat\" || context.funcName === \"\\\\widetilde\" || context.funcName === \"\\\\widecheck\";\n    return {\n      type: \"accent\",\n      mode: context.parser.mode,\n      label: context.funcName,\n      isStretchy: isStretchy,\n      isShifty: isShifty,\n      base: base\n    };\n  },\n  htmlBuilder: htmlBuilder$a,\n  mathmlBuilder: mathmlBuilder$9\n}); // Text-mode accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\'\", \"\\\\`\", \"\\\\^\", \"\\\\~\", \"\\\\=\", \"\\\\u\", \"\\\\.\", '\\\\\"', \"\\\\c\", \"\\\\r\", \"\\\\H\", \"\\\\v\", \"\\\\textcircled\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    allowedInMath: true,\n    // unless in strict mode\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    var base = args[0];\n    var mode = context.parser.mode;\n\n    if (mode === \"math\") {\n      context.parser.settings.reportNonstrict(\"mathVsTextAccents\", \"LaTeX's accent \" + context.funcName + \" works only in text mode\");\n      mode = \"text\";\n    }\n\n    return {\n      type: \"accent\",\n      mode: mode,\n      label: context.funcName,\n      isStretchy: false,\n      isShifty: true,\n      base: base\n    };\n  },\n  htmlBuilder: htmlBuilder$a,\n  mathmlBuilder: mathmlBuilder$9\n});\n\n// Horizontal overlap functions\ndefineFunction({\n  type: \"accentUnder\",\n  names: [\"\\\\underleftarrow\", \"\\\\underrightarrow\", \"\\\\underleftrightarrow\", \"\\\\undergroup\", \"\\\\underlinesegment\", \"\\\\utilde\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var base = args[0];\n    return {\n      type: \"accentUnder\",\n      mode: parser.mode,\n      label: funcName,\n      base: base\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // Treat under accents much like underlines.\n    var innerGroup = buildGroup$1(group.base, options);\n    var accentBody = stretchy.svgSpan(group, options);\n    var kern = group.label === \"\\\\utilde\" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns\n\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: kern\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"accentunder\"], [vlist], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var accentNode = stretchy.mathMLnode(group.label);\n    var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.base, options), accentNode]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n});\n\n// Helper function\nvar paddedNode = group => {\n  var node = new mathMLTree.MathNode(\"mpadded\", group ? [group] : []);\n  node.setAttribute(\"width\", \"+0.6em\");\n  node.setAttribute(\"lspace\", \"0.3em\");\n  return node;\n}; // Stretchy arrows with an optional argument\n\n\ndefineFunction({\n  type: \"xArrow\",\n  names: [\"\\\\xleftarrow\", \"\\\\xrightarrow\", \"\\\\xLeftarrow\", \"\\\\xRightarrow\", \"\\\\xleftrightarrow\", \"\\\\xLeftrightarrow\", \"\\\\xhookleftarrow\", \"\\\\xhookrightarrow\", \"\\\\xmapsto\", \"\\\\xrightharpoondown\", \"\\\\xrightharpoonup\", \"\\\\xleftharpoondown\", \"\\\\xleftharpoonup\", \"\\\\xrightleftharpoons\", \"\\\\xleftrightharpoons\", \"\\\\xlongequal\", \"\\\\xtwoheadrightarrow\", \"\\\\xtwoheadleftarrow\", \"\\\\xtofrom\", // The next 3 functions are here to support the mhchem extension.\n  // Direct use of these functions is discouraged and may break someday.\n  \"\\\\xrightleftarrows\", \"\\\\xrightequilibrium\", \"\\\\xleftequilibrium\", // The next 3 functions are here only to support the {CD} environment.\n  \"\\\\\\\\cdrightarrow\", \"\\\\\\\\cdleftarrow\", \"\\\\\\\\cdlongequal\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"xArrow\",\n      mode: parser.mode,\n      label: funcName,\n      body: args[0],\n      below: optArgs[0]\n    };\n  },\n\n  // Flow is unable to correctly infer the type of `group`, even though it's\n  // unambiguously determined from the passed-in `type` above.\n  htmlBuilder(group, options) {\n    var style = options.style; // Build the argument groups in the appropriate style.\n    // Ref: amsmath.dtx:   \\hbox{$\\scriptstyle\\mkern#3mu{#6}\\mkern#4mu$}%\n    // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n    var newOptions = options.havingStyle(style.sup());\n    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);\n    var arrowPrefix = group.label.slice(0, 2) === \"\\\\x\" ? \"x\" : \"cd\";\n    upperGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    var lowerGroup;\n\n    if (group.below) {\n      // Build the lower group\n      newOptions = options.havingStyle(style.sub());\n      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);\n      lowerGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    }\n\n    var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.\n    // The point we want on the math axis is at 0.5 * arrowBody.height.\n\n    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\\if0#2\\else\\mkern#2mu\\fi\n\n    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu\n\n    if (upperGroup.depth > 0.25 || group.label === \"\\\\xleftequilibrium\") {\n      upperShift -= upperGroup.depth; // shift up if depth encroaches\n    } // Generate the vlist\n\n\n    var vlist;\n\n    if (lowerGroup) {\n      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }, {\n          type: \"elem\",\n          elem: lowerGroup,\n          shift: lowerShift\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }]\n      }, options);\n    } // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n    return buildCommon.makeSpan([\"mrel\", \"x-arrow\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var arrowNode = stretchy.mathMLnode(group.label);\n    arrowNode.setAttribute(\"minsize\", group.label.charAt(0) === \"x\" ? \"1.75em\" : \"3.0em\");\n    var node;\n\n    if (group.body) {\n      var upperNode = paddedNode(buildGroup(group.body, options));\n\n      if (group.below) {\n        var lowerNode = paddedNode(buildGroup(group.below, options));\n        node = new mathMLTree.MathNode(\"munderover\", [arrowNode, lowerNode, upperNode]);\n      } else {\n        node = new mathMLTree.MathNode(\"mover\", [arrowNode, upperNode]);\n      }\n    } else if (group.below) {\n      var _lowerNode = paddedNode(buildGroup(group.below, options));\n\n      node = new mathMLTree.MathNode(\"munder\", [arrowNode, _lowerNode]);\n    } else {\n      // This should never happen.\n      // Parser.js throws an error if there is no argument.\n      node = paddedNode();\n      node = new mathMLTree.MathNode(\"mover\", [arrowNode, node]);\n    }\n\n    return node;\n  }\n\n});\n\nvar makeSpan = buildCommon.makeSpan;\n\nfunction htmlBuilder$9(group, options) {\n  var elements = buildExpression$1(group.body, options, true);\n  return makeSpan([group.mclass], elements, options);\n}\n\nfunction mathmlBuilder$8(group, options) {\n  var node;\n  var inner = buildExpression(group.body, options);\n\n  if (group.mclass === \"minner\") {\n    node = new mathMLTree.MathNode(\"mpadded\", inner);\n  } else if (group.mclass === \"mord\") {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mi\";\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", inner);\n    }\n  } else {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mo\";\n    } else {\n      node = new mathMLTree.MathNode(\"mo\", inner);\n    } // Set spacing based on what is the most likely adjacent atom type.\n    // See TeXbook p170.\n\n\n    if (group.mclass === \"mbin\") {\n      node.attributes.lspace = \"0.22em\"; // medium space\n\n      node.attributes.rspace = \"0.22em\";\n    } else if (group.mclass === \"mpunct\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0.17em\"; // thinspace\n    } else if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0em\";\n    } else if (group.mclass === \"minner\") {\n      node.attributes.lspace = \"0.0556em\"; // 1 mu is the most likely option\n\n      node.attributes.width = \"+0.1111em\";\n    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo\n\n  }\n\n  return node;\n} // Math class commands except \\mathop\n\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\", \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: \"m\" + funcName.slice(5),\n      // TODO(kevinb): don't prefix with 'm'\n      body: ordargument(body),\n      isCharacterBox: utils.isCharacterBox(body)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$9,\n  mathmlBuilder: mathmlBuilder$8\n});\nvar binrelClass = arg => {\n  // \\binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.\n  // (by rendering separately and with {}s before and after, and measuring\n  // the change in spacing).  We'll do roughly the same by detecting the\n  // atom type directly.\n  var atom = arg.type === \"ordgroup\" && arg.body.length ? arg.body[0] : arg;\n\n  if (atom.type === \"atom\" && (atom.family === \"bin\" || atom.family === \"rel\")) {\n    return \"m\" + atom.family;\n  } else {\n    return \"mord\";\n  }\n}; // \\@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.\n// This is equivalent to \\binrel@{x}\\binrel@@{y} in AMSTeX.\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\@binrel\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser\n    } = _ref2;\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[1]),\n      isCharacterBox: utils.isCharacterBox(args[1])\n    };\n  }\n\n}); // Build a relation or stacked op by placing one symbol on top of another\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\stackrel\", \"\\\\overset\", \"\\\\underset\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref3, args) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    var baseArg = args[1];\n    var shiftedArg = args[0];\n    var mclass;\n\n    if (funcName !== \"\\\\stackrel\") {\n      // LaTeX applies \\binrel spacing to \\overset and \\underset.\n      mclass = binrelClass(baseArg);\n    } else {\n      mclass = \"mrel\"; // for \\stackrel\n    }\n\n    var baseOp = {\n      type: \"op\",\n      mode: baseArg.mode,\n      limits: true,\n      alwaysHandleSupSub: true,\n      parentIsSupSub: false,\n      symbol: false,\n      suppressBaseShift: funcName !== \"\\\\stackrel\",\n      body: ordargument(baseArg)\n    };\n    var supsub = {\n      type: \"supsub\",\n      mode: shiftedArg.mode,\n      base: baseOp,\n      sup: funcName === \"\\\\underset\" ? null : shiftedArg,\n      sub: funcName === \"\\\\underset\" ? shiftedArg : null\n    };\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass,\n      body: [supsub],\n      isCharacterBox: utils.isCharacterBox(supsub)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$9,\n  mathmlBuilder: mathmlBuilder$8\n});\n\n// \\pmb is a simulation of bold font.\n// The version of \\pmb in ambsy.sty works by typesetting three copies\n// with small offsets. We use CSS text-shadow.\n// It's a hack. Not as good as a real bold font. Better than nothing.\ndefineFunction({\n  type: \"pmb\",\n  names: [\"\\\\pmb\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"pmb\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var elements = buildExpression$1(group.body, options, true);\n    var node = buildCommon.makeSpan([group.mclass], elements, options);\n    node.style.textShadow = \"0.02em 0.01em 0.04px\";\n    return node;\n  },\n\n  mathmlBuilder(group, style) {\n    var inner = buildExpression(group.body, style); // Wrap with an <mstyle> element.\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n    node.setAttribute(\"style\", \"text-shadow: 0.02em 0.01em 0.04px\");\n    return node;\n  }\n\n});\n\nvar cdArrowFunctionName = {\n  \">\": \"\\\\\\\\cdrightarrow\",\n  \"<\": \"\\\\\\\\cdleftarrow\",\n  \"=\": \"\\\\\\\\cdlongequal\",\n  \"A\": \"\\\\uparrow\",\n  \"V\": \"\\\\downarrow\",\n  \"|\": \"\\\\Vert\",\n  \".\": \"no arrow\"\n};\n\nvar newCell = () => {\n  // Create an empty cell, to be filled below with parse nodes.\n  // The parseTree from this module must be constructed like the\n  // one created by parseArray(), so an empty CD cell must\n  // be a ParseNode<\"styling\">. And CD is always displaystyle.\n  // So these values are fixed and flow can do implicit typing.\n  return {\n    type: \"styling\",\n    body: [],\n    mode: \"math\",\n    style: \"display\"\n  };\n};\n\nvar isStartOfArrow = node => {\n  return node.type === \"textord\" && node.text === \"@\";\n};\n\nvar isLabelEnd = (node, endChar) => {\n  return (node.type === \"mathord\" || node.type === \"atom\") && node.text === endChar;\n};\n\nfunction cdArrow(arrowChar, labels, parser) {\n  // Return a parse tree of an arrow and its labels.\n  // This acts in a way similar to a macro expansion.\n  var funcName = cdArrowFunctionName[arrowChar];\n\n  switch (funcName) {\n    case \"\\\\\\\\cdrightarrow\":\n    case \"\\\\\\\\cdleftarrow\":\n      return parser.callFunction(funcName, [labels[0]], [labels[1]]);\n\n    case \"\\\\uparrow\":\n    case \"\\\\downarrow\":\n      {\n        var leftLabel = parser.callFunction(\"\\\\\\\\cdleft\", [labels[0]], []);\n        var bareArrow = {\n          type: \"atom\",\n          text: funcName,\n          mode: \"math\",\n          family: \"rel\"\n        };\n        var sizedArrow = parser.callFunction(\"\\\\Big\", [bareArrow], []);\n        var rightLabel = parser.callFunction(\"\\\\\\\\cdright\", [labels[1]], []);\n        var arrowGroup = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: [leftLabel, sizedArrow, rightLabel]\n        };\n        return parser.callFunction(\"\\\\\\\\cdparent\", [arrowGroup], []);\n      }\n\n    case \"\\\\\\\\cdlongequal\":\n      return parser.callFunction(\"\\\\\\\\cdlongequal\", [], []);\n\n    case \"\\\\Vert\":\n      {\n        var arrow = {\n          type: \"textord\",\n          text: \"\\\\Vert\",\n          mode: \"math\"\n        };\n        return parser.callFunction(\"\\\\Big\", [arrow], []);\n      }\n\n    default:\n      return {\n        type: \"textord\",\n        text: \" \",\n        mode: \"math\"\n      };\n  }\n}\n\nfunction parseCD(parser) {\n  // Get the array's parse nodes with \\\\ temporarily mapped to \\cr.\n  var parsedRows = [];\n  parser.gullet.beginGroup();\n  parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  parser.gullet.beginGroup();\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Get the parse nodes for the next row.\n    parsedRows.push(parser.parseExpression(false, \"\\\\\\\\\"));\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    var next = parser.fetch().text;\n\n    if (next === \"&\" || next === \"\\\\\\\\\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      if (parsedRows[parsedRows.length - 1].length === 0) {\n        parsedRows.pop(); // final row ended in \\\\\n      }\n\n      break;\n    } else {\n      throw new ParseError(\"Expected \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  }\n\n  var row = [];\n  var body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.\n\n  for (var i = 0; i < parsedRows.length; i++) {\n    // Start a new row.\n    var rowNodes = parsedRows[i]; // Create the first cell.\n\n    var cell = newCell();\n\n    for (var j = 0; j < rowNodes.length; j++) {\n      if (!isStartOfArrow(rowNodes[j])) {\n        // If a parseNode is not an arrow, it goes into a cell.\n        cell.body.push(rowNodes[j]);\n      } else {\n        // Parse node j is an \"@\", the start of an arrow.\n        // Before starting on the arrow, push the cell into `row`.\n        row.push(cell); // Now collect parseNodes into an arrow.\n        // The character after \"@\" defines the arrow type.\n\n        j += 1;\n        var arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.\n\n        var labels = new Array(2);\n        labels[0] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        };\n        labels[1] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        }; // Process the arrow.\n\n        if (\"=|.\".indexOf(arrowChar) > -1) ; else if (\"<>AV\".indexOf(arrowChar) > -1) {\n          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take\n          // two optional labels. E.g. the right-point arrow syntax is\n          // really:  @>{optional label}>{optional label}>\n          // Collect parseNodes into labels.\n          for (var labelNum = 0; labelNum < 2; labelNum++) {\n            var inLabel = true;\n\n            for (var k = j + 1; k < rowNodes.length; k++) {\n              if (isLabelEnd(rowNodes[k], arrowChar)) {\n                inLabel = false;\n                j = k;\n                break;\n              }\n\n              if (isStartOfArrow(rowNodes[k])) {\n                throw new ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[k]);\n              }\n\n              labels[labelNum].body.push(rowNodes[k]);\n            }\n\n            if (inLabel) {\n              // isLabelEnd never returned a true.\n              throw new ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[j]);\n            }\n          }\n        } else {\n          throw new ParseError(\"Expected one of \\\"<>AV=|.\\\" after @\", rowNodes[j]);\n        } // Now join the arrow to its labels.\n\n\n        var arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<\"styling\">.\n        // This is done to match parseArray() behavior.\n\n        var wrappedArrow = {\n          type: \"styling\",\n          body: [arrow],\n          mode: \"math\",\n          style: \"display\" // CD is always displaystyle.\n\n        };\n        row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that\n        // is not an arrow gets collected into a cell. So create an empty\n        // cell now. It will collect upcoming parseNodes.\n\n        cell = newCell();\n      }\n    }\n\n    if (i % 2 === 0) {\n      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell\n      // The last cell is not yet pushed into `row`, so:\n      row.push(cell);\n    } else {\n      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow\n      // Remove the empty cell that was placed at the beginning of `row`.\n      row.shift();\n    }\n\n    row = [];\n    body.push(row);\n  } // End row group\n\n\n  parser.gullet.endGroup(); // End array group defining \\\\\n\n  parser.gullet.endGroup(); // define column separation.\n\n  var cols = new Array(body[0].length).fill({\n    type: \"align\",\n    align: \"c\",\n    pregap: 0.25,\n    // CD package sets \\enskip between columns.\n    postgap: 0.25 // So pre and post each get half an \\enskip, i.e. 0.25em.\n\n  });\n  return {\n    type: \"array\",\n    mode: \"math\",\n    body,\n    arraystretch: 1,\n    addJot: true,\n    rowGaps: [null],\n    cols,\n    colSeparationType: \"CD\",\n    hLinesBeforeRow: new Array(body.length + 1).fill([])\n  };\n} // The functions below are not available for general use.\n// They are here only for internal use by the {CD} environment in placing labels\n// next to vertical arrows.\n// We don't need any such functions for horizontal arrows because we can reuse\n// the functionality that already exists for extensible arrows.\n\ndefineFunction({\n  type: \"cdlabel\",\n  names: [\"\\\\\\\\cdleft\", \"\\\\\\\\cdright\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"cdlabel\",\n      mode: parser.mode,\n      side: funcName.slice(4),\n      label: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var newOptions = options.havingStyle(options.style.sup());\n    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);\n    label.classes.push(\"cd-label-\" + group.side);\n    label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set\n    // by the arrow height, not by the label.\n\n    label.height = 0;\n    label.depth = 0;\n    return label;\n  },\n\n  mathmlBuilder(group, options) {\n    var label = new mathMLTree.MathNode(\"mrow\", [buildGroup(group.label, options)]);\n    label = new mathMLTree.MathNode(\"mpadded\", [label]);\n    label.setAttribute(\"width\", \"0\");\n\n    if (group.side === \"left\") {\n      label.setAttribute(\"lspace\", \"-1width\");\n    } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,\n    // But we don't know the height or depth of the label.\n\n\n    label.setAttribute(\"voffset\", \"0.7em\");\n    label = new mathMLTree.MathNode(\"mstyle\", [label]);\n    label.setAttribute(\"displaystyle\", \"false\");\n    label.setAttribute(\"scriptlevel\", \"1\");\n    return label;\n  }\n\n});\ndefineFunction({\n  type: \"cdlabelparent\",\n  names: [\"\\\\\\\\cdparent\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser\n    } = _ref2;\n    return {\n      type: \"cdlabelparent\",\n      mode: parser.mode,\n      fragment: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Wrap the vertical arrow and its labels.\n    // The parent gets position: relative. The child gets position: absolute.\n    // So CSS can locate the label correctly.\n    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);\n    parent.classes.push(\"cd-vert-arrow\");\n    return parent;\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", [buildGroup(group.fragment, options)]);\n  }\n\n});\n\n// {123} and converts into symbol with code 123.  It is used by the *macro*\n// \\char defined in macros.js.\n\ndefineFunction({\n  type: \"textord\",\n  names: [\"\\\\@char\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var arg = assertNodeType(args[0], \"ordgroup\");\n    var group = arg.body;\n    var number = \"\";\n\n    for (var i = 0; i < group.length; i++) {\n      var node = assertNodeType(group[i], \"textord\");\n      number += node.text;\n    }\n\n    var code = parseInt(number);\n    var text;\n\n    if (isNaN(code)) {\n      throw new ParseError(\"\\\\@char has non-numeric argument \" + number); // If we drop IE support, the following code could be replaced with\n      // text = String.fromCodePoint(code)\n    } else if (code < 0 || code >= 0x10ffff) {\n      throw new ParseError(\"\\\\@char with invalid code point \" + number);\n    } else if (code <= 0xffff) {\n      text = String.fromCharCode(code);\n    } else {\n      // Astral code point; split into surrogate halves\n      code -= 0x10000;\n      text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);\n    }\n\n    return {\n      type: \"textord\",\n      mode: parser.mode,\n      text: text\n    };\n  }\n\n});\n\nvar htmlBuilder$8 = (group, options) => {\n  var elements = buildExpression$1(group.body, options.withColor(group.color), false); // \\color isn't supposed to affect the type of the elements it contains.\n  // To accomplish this, we wrap the results in a fragment, so the inner\n  // elements will be able to directly interact with their neighbors. For\n  // example, `\\color{red}{2 +} 3` has the same spacing as `2 + 3`\n\n  return buildCommon.makeFragment(elements);\n};\n\nvar mathmlBuilder$7 = (group, options) => {\n  var inner = buildExpression(group.body, options.withColor(group.color));\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.color);\n  return node;\n};\n\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\textcolor\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"original\"]\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body: ordargument(body)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\color\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    argTypes: [\"color\"]\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser,\n      breakOnTokenText\n    } = _ref2;\n    var color = assertNodeType(args[0], \"color-token\").color; // Set macro \\current@color in current namespace to store the current\n    // color, mimicking the behavior of color.sty.\n    // This is currently used just to correctly color a \\right\n    // that follows a \\color command.\n\n    parser.gullet.macros.set(\"\\\\current@color\", color); // Parse out the implicit body that should be colored.\n\n    var body = parser.parseExpression(true, breakOnTokenText);\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\n\n// Row breaks within tabular environments, and line breaks at top level\n\ndefineFunction({\n  type: \"cr\",\n  names: [\"\\\\\\\\\"],\n  props: {\n    numArgs: 0,\n    numOptionalArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var size = parser.gullet.future().text === \"[\" ? parser.parseSizeGroup(true) : null;\n    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior(\"newLineInDisplayMode\", \"In LaTeX, \\\\\\\\ or \\\\newline \" + \"does nothing in display mode\");\n    return {\n      type: \"cr\",\n      mode: parser.mode,\n      newLine,\n      size: size && assertNodeType(size, \"size\").value\n    };\n  },\n\n  // The following builders are called only at the top level,\n  // not within tabular/array environments.\n  htmlBuilder(group, options) {\n    var span = buildCommon.makeSpan([\"mspace\"], [], options);\n\n    if (group.newLine) {\n      span.classes.push(\"newline\");\n\n      if (group.size) {\n        span.style.marginTop = makeEm(calculateSize(group.size, options));\n      }\n    }\n\n    return span;\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mspace\");\n\n    if (group.newLine) {\n      node.setAttribute(\"linebreak\", \"newline\");\n\n      if (group.size) {\n        node.setAttribute(\"height\", makeEm(calculateSize(group.size, options)));\n      }\n    }\n\n    return node;\n  }\n\n});\n\nvar globalMap = {\n  \"\\\\global\": \"\\\\global\",\n  \"\\\\long\": \"\\\\\\\\globallong\",\n  \"\\\\\\\\globallong\": \"\\\\\\\\globallong\",\n  \"\\\\def\": \"\\\\gdef\",\n  \"\\\\gdef\": \"\\\\gdef\",\n  \"\\\\edef\": \"\\\\xdef\",\n  \"\\\\xdef\": \"\\\\xdef\",\n  \"\\\\let\": \"\\\\\\\\globallet\",\n  \"\\\\futurelet\": \"\\\\\\\\globalfuture\"\n};\n\nvar checkControlSequence = tok => {\n  var name = tok.text;\n\n  if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n    throw new ParseError(\"Expected a control sequence\", tok);\n  }\n\n  return name;\n};\n\nvar getRHS = parser => {\n  var tok = parser.gullet.popToken();\n\n  if (tok.text === \"=\") {\n    // consume optional equals\n    tok = parser.gullet.popToken();\n\n    if (tok.text === \" \") {\n      // consume one optional space\n      tok = parser.gullet.popToken();\n    }\n  }\n\n  return tok;\n};\n\nvar letCommand = (parser, name, tok, global) => {\n  var macro = parser.gullet.macros.get(tok.text);\n\n  if (macro == null) {\n    // don't expand it later even if a macro with the same name is defined\n    // e.g., \\let\\foo=\\frac \\def\\frac{\\relax} \\frac12\n    tok.noexpand = true;\n    macro = {\n      tokens: [tok],\n      numArgs: 0,\n      // reproduce the same behavior in expansion\n      unexpandable: !parser.gullet.isExpandable(tok.text)\n    };\n  }\n\n  parser.gullet.macros.set(name, macro, global);\n}; // <assignment> -> <non-macro assignment>|<macro assignment>\n// <non-macro assignment> -> <simple assignment>|\\global<non-macro assignment>\n// <macro assignment> -> <definition>|<prefix><macro assignment>\n// <prefix> -> \\global|\\long|\\outer\n\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\global\", \"\\\\long\", \"\\\\\\\\globallong\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    parser.consumeSpaces();\n    var token = parser.fetch();\n\n    if (globalMap[token.text]) {\n      // KaTeX doesn't have \\par, so ignore \\long\n      if (funcName === \"\\\\global\" || funcName === \"\\\\\\\\globallong\") {\n        token.text = globalMap[token.text];\n      }\n\n      return assertNodeType(parser.parseFunction(), \"internal\");\n    }\n\n    throw new ParseError(\"Invalid token after macro prefix\", token);\n  }\n\n}); // Basic support for macro definitions: \\def, \\gdef, \\edef, \\xdef\n// <definition> -> <def><control sequence><definition text>\n// <def> -> \\def|\\gdef|\\edef|\\xdef\n// <definition text> -> <parameter text><left brace><balanced text><right brace>\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\def\", \"\\\\gdef\", \"\\\\edef\", \"\\\\xdef\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref2) {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var tok = parser.gullet.popToken();\n    var name = tok.text;\n\n    if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n      throw new ParseError(\"Expected a control sequence\", tok);\n    }\n\n    var numArgs = 0;\n    var insert;\n    var delimiters = [[]]; // <parameter text> contains no braces\n\n    while (parser.gullet.future().text !== \"{\") {\n      tok = parser.gullet.popToken();\n\n      if (tok.text === \"#\") {\n        // If the very last character of the <parameter text> is #, so that\n        // this # is immediately followed by {, TeX will behave as if the {\n        // had been inserted at the right end of both the parameter text\n        // and the replacement text.\n        if (parser.gullet.future().text === \"{\") {\n          insert = parser.gullet.future();\n          delimiters[numArgs].push(\"{\");\n          break;\n        } // A parameter, the first appearance of # must be followed by 1,\n        // the next by 2, and so on; up to nine #s are allowed\n\n\n        tok = parser.gullet.popToken();\n\n        if (!/^[1-9]$/.test(tok.text)) {\n          throw new ParseError(\"Invalid argument number \\\"\" + tok.text + \"\\\"\");\n        }\n\n        if (parseInt(tok.text) !== numArgs + 1) {\n          throw new ParseError(\"Argument number \\\"\" + tok.text + \"\\\" out of order\");\n        }\n\n        numArgs++;\n        delimiters.push([]);\n      } else if (tok.text === \"EOF\") {\n        throw new ParseError(\"Expected a macro definition\");\n      } else {\n        delimiters[numArgs].push(tok.text);\n      }\n    } // replacement text, enclosed in '{' and '}' and properly nested\n\n\n    var {\n      tokens\n    } = parser.gullet.consumeArg();\n\n    if (insert) {\n      tokens.unshift(insert);\n    }\n\n    if (funcName === \"\\\\edef\" || funcName === \"\\\\xdef\") {\n      tokens = parser.gullet.expandTokens(tokens);\n      tokens.reverse(); // to fit in with stack order\n    } // Final arg is the expansion of the macro\n\n\n    parser.gullet.macros.set(name, {\n      tokens,\n      numArgs,\n      delimiters\n    }, funcName === globalMap[funcName]);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // <simple assignment> -> <let assignment>\n// <let assignment> -> \\futurelet<control sequence><token><token>\n//     | \\let<control sequence><equals><one optional space><token>\n// <equals> -> <optional spaces>|<optional spaces>=\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\let\", \"\\\\\\\\globallet\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    var name = checkControlSequence(parser.gullet.popToken());\n    parser.gullet.consumeSpaces();\n    var tok = getRHS(parser);\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globallet\");\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\futurelet\", \"\\\\\\\\globalfuture\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref4) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    var name = checkControlSequence(parser.gullet.popToken());\n    var middle = parser.gullet.popToken();\n    var tok = parser.gullet.popToken();\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globalfuture\");\n    parser.gullet.pushToken(tok);\n    parser.gullet.pushToken(middle);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n\n/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar getMetrics = function getMetrics(symbol, font, mode) {\n  var replace = symbols.math[symbol] && symbols.math[symbol].replace;\n  var metrics = getCharacterMetrics(replace || symbol, font, mode);\n\n  if (!metrics) {\n    throw new Error(\"Unsupported symbol \" + symbol + \" and font size \" + font + \".\");\n  }\n\n  return metrics;\n};\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\n\n\nvar styleWrap = function styleWrap(delim, toStyle, options, classes) {\n  var newOptions = options.havingBaseStyle(toStyle);\n  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);\n  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;\n  span.height *= delimSizeMultiplier;\n  span.depth *= delimSizeMultiplier;\n  span.maxFontSize = newOptions.sizeMultiplier;\n  return span;\n};\n\nvar centerSpan = function centerSpan(span, options, style) {\n  var newOptions = options.havingBaseStyle(style);\n  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;\n  span.classes.push(\"delimcenter\");\n  span.style.top = makeEm(shift);\n  span.height -= shift;\n  span.depth += shift;\n};\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\n\n\nvar makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {\n  var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n  var span = styleWrap(text, style, options, classes);\n\n  if (center) {\n    centerSpan(span, options, style);\n  }\n\n  return span;\n};\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\n\n\nvar mathrmSize = function mathrmSize(value, size, mode, options) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode, options);\n};\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\n\n\nvar makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {\n  var inner = mathrmSize(delim, size, mode, options);\n  var span = styleWrap(buildCommon.makeSpan([\"delimsizing\", \"size\" + size], [inner], options), Style$1.TEXT, options, classes);\n\n  if (center) {\n    centerSpan(span, options, Style$1.TEXT);\n  }\n\n  return span;\n};\n/**\n * Make a span from a font glyph with the given offset and in the given font.\n * This is used in makeStackedDelim to make the stacking pieces for the delimiter.\n */\n\n\nvar makeGlyphSpan = function makeGlyphSpan(symbol, font, mode) {\n  var sizeClass; // Apply the correct CSS class to choose the right font.\n\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else\n    /* if (font === \"Size4-Regular\") */\n    {\n      sizeClass = \"delim-size4\";\n    }\n\n  var corner = buildCommon.makeSpan([\"delimsizinginner\", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n\n  return {\n    type: \"elem\",\n    elem: corner\n  };\n};\n\nvar makeInner = function makeInner(ch, height, options) {\n  // Create a span with inline SVG for the inner part of a tall stacked delimiter.\n  var width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];\n  var path = new PathNode(\"inner\", innerPath(ch, Math.round(1000 * height)));\n  var svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + Math.round(1000 * height),\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = buildCommon.makeSvgSpan([], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return {\n    type: \"elem\",\n    elem: span\n  };\n}; // Helpers for makeStackedDelim\n\n\nvar lapInEms = 0.008;\nvar lap = {\n  type: \"kern\",\n  size: -1 * lapInEms\n};\nvar verts = [\"|\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\vert\"];\nvar doubleVerts = [\"\\\\|\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\Vert\"];\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\n\nvar makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  var top;\n  var middle;\n  var repeat;\n  var bottom;\n  var svgLabel = \"\";\n  var viewBoxWidth = 0;\n  top = repeat = bottom = delim;\n  middle = null; // Also keep track of what font the delimiters are in\n\n  var font = \"Size1-Regular\"; // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23d0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23d0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23d0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (utils.contains(verts, delim)) {\n    repeat = \"\\u2223\";\n    svgLabel = \"vert\";\n    viewBoxWidth = 333;\n  } else if (utils.contains(doubleVerts, delim)) {\n    repeat = \"\\u2225\";\n    svgLabel = \"doublevert\";\n    viewBoxWidth = 556;\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23a1\";\n    repeat = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lbrack\";\n    viewBoxWidth = 667;\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23a4\";\n    repeat = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rbrack\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\lfloor\" || delim === \"\\u230a\") {\n    repeat = top = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lfloor\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\lceil\" || delim === \"\\u2308\") {\n    top = \"\\u23a1\";\n    repeat = bottom = \"\\u23a2\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lceil\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\rfloor\" || delim === \"\\u230b\") {\n    repeat = top = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rfloor\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\rceil\" || delim === \"\\u2309\") {\n    top = \"\\u23a4\";\n    repeat = bottom = \"\\u23a5\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rceil\";\n    viewBoxWidth = 667;\n  } else if (delim === \"(\" || delim === \"\\\\lparen\") {\n    top = \"\\u239b\";\n    repeat = \"\\u239c\";\n    bottom = \"\\u239d\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lparen\";\n    viewBoxWidth = 875;\n  } else if (delim === \")\" || delim === \"\\\\rparen\") {\n    top = \"\\u239e\";\n    repeat = \"\\u239f\";\n    bottom = \"\\u23a0\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rparen\";\n    viewBoxWidth = 875;\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23a7\";\n    middle = \"\\u23a8\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23ab\";\n    middle = \"\\u23ac\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\" || delim === \"\\u27ee\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\" || delim === \"\\u27ef\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\" || delim === \"\\u23b0\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\" || delim === \"\\u23b1\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } // Get the metrics of the four sections\n\n\n  var topMetrics = getMetrics(top, font, mode);\n  var topHeightTotal = topMetrics.height + topMetrics.depth;\n  var repeatMetrics = getMetrics(repeat, font, mode);\n  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  var bottomMetrics = getMetrics(bottom, font, mode);\n  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  var middleHeightTotal = 0;\n  var middleFactor = 1;\n\n  if (middle !== null) {\n    var middleMetrics = getMetrics(middle, font, mode);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  } // Calculate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n\n\n  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need\n\n  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols\n\n  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n\n  var axisHeight = options.fontMetrics().axisHeight;\n\n  if (center) {\n    axisHeight *= options.sizeMultiplier;\n  } // Calculate the depth\n\n\n  var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist\n  // Keep a list of the pieces of the stacked delimiter\n\n  var stack = [];\n\n  if (svgLabel.length > 0) {\n    // Instead of stacking glyphs, create a single SVG.\n    // This evades browser problems with imprecise positioning of spans.\n    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;\n    var viewBoxHeight = Math.round(realHeightTotal * 1000);\n    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));\n    var path = new PathNode(svgLabel, pathStr);\n    var width = (viewBoxWidth / 1000).toFixed(3) + \"em\";\n    var height = (viewBoxHeight / 1000).toFixed(3) + \"em\";\n    var svg = new SvgNode([path], {\n      \"width\": width,\n      \"height\": height,\n      \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight\n    });\n    var wrapper = buildCommon.makeSvgSpan([], [svg], options);\n    wrapper.height = viewBoxHeight / 1000;\n    wrapper.style.width = width;\n    wrapper.style.height = height;\n    stack.push({\n      type: \"elem\",\n      elem: wrapper\n    });\n  } else {\n    // Stack glyphs\n    // Start by adding the bottom symbol\n    stack.push(makeGlyphSpan(bottom, font, mode));\n    stack.push(lap); // overlap\n\n    if (middle === null) {\n      // The middle section will be an SVG. Make it an extra 0.016em tall.\n      // We'll overlap by 0.008em at top and bottom.\n      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;\n      stack.push(makeInner(repeat, innerHeight, options));\n    } else {\n      // When there is a middle bit, we need the middle part and two repeated\n      // sections\n      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;\n\n      stack.push(makeInner(repeat, _innerHeight, options)); // Now insert the middle of the brace.\n\n      stack.push(lap);\n      stack.push(makeGlyphSpan(middle, font, mode));\n      stack.push(lap);\n      stack.push(makeInner(repeat, _innerHeight, options));\n    } // Add the top symbol\n\n\n    stack.push(lap);\n    stack.push(makeGlyphSpan(top, font, mode));\n  } // Finally, build the vlist\n\n\n  var newOptions = options.havingBaseStyle(Style$1.TEXT);\n  var inner = buildCommon.makeVList({\n    positionType: \"bottom\",\n    positionData: depth,\n    children: stack\n  }, newOptions);\n  return styleWrap(buildCommon.makeSpan([\"delimsizing\", \"mult\"], [inner], newOptions), Style$1.TEXT, options, classes);\n}; // All surds have 0.08em padding above the vinculum inside the SVG.\n// That keeps browser span height rounding error from pinching the line.\n\n\nvar vbPad = 80; // padding above the surd, measured inside the viewBox.\n\nvar emPad = 0.08; // padding, in ems, measured in the document.\n\nvar sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraVinculum, options) {\n  var path = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);\n  var pathNode = new PathNode(sqrtName, path);\n  var svg = new SvgNode([pathNode], {\n    // Note: 1000:1 ratio of viewBox to document em width.\n    \"width\": \"400em\",\n    \"height\": makeEm(height),\n    \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n    \"preserveAspectRatio\": \"xMinYMin slice\"\n  });\n  return buildCommon.makeSvgSpan([\"hide-tail\"], [svg], options);\n};\n/**\n * Make a sqrt image of the given height,\n */\n\n\nvar makeSqrtImage = function makeSqrtImage(height, options) {\n  // Define a newOptions that removes the effect of size changes such as \\Huge.\n  // We don't pick different a height surd for \\Huge. For it, we scale up.\n  var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.\n\n  var delim = traverseSequence(\"\\\\surd\", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);\n  var sizeMultiplier = newOptions.sizeMultiplier; // default\n  // The standard sqrt SVGs each have a 0.04em thick vinculum.\n  // If Settings.minRuleThickness is larger than that, we add extraVinculum.\n\n  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.\n\n  var span;\n  var spanHeight = 0;\n  var texHeight = 0;\n  var viewBoxHeight = 0;\n  var advanceWidth; // We create viewBoxes with 80 units of \"padding\" above each surd.\n  // Then browser rounding error on the parent span height will not\n  // encroach on the ink of the vinculum. But that padding is not\n  // included in the TeX-like `height` used for calculation of\n  // vertical alignment. So texHeight = span.height < span.style.height.\n\n  if (delim.type === \"small\") {\n    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.\n    // 1000 unit normal glyph height.\n    viewBoxHeight = 1000 + 1000 * extraVinculum + vbPad;\n\n    if (height < 1.0) {\n      sizeMultiplier = 1.0; // mimic a \\textfont radical\n    } else if (height < 1.4) {\n      sizeMultiplier = 0.7; // mimic a \\scriptfont radical\n    }\n\n    spanHeight = (1.0 + extraVinculum + emPad) / sizeMultiplier;\n    texHeight = (1.00 + extraVinculum) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtMain\", spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"0.853em\";\n    advanceWidth = 0.833 / sizeMultiplier; // from the font.\n  } else if (delim.type === \"large\") {\n    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.\n    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];\n    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;\n    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtSize\" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"1.02em\";\n    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.\n  } else {\n    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.\n    // We'll use a single SVG to accomplish the same thing.\n    spanHeight = height + extraVinculum + emPad;\n    texHeight = height + extraVinculum;\n    viewBoxHeight = Math.floor(1000 * height + extraVinculum) + vbPad;\n    span = sqrtSvg(\"sqrtTall\", spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"0.742em\";\n    advanceWidth = 1.056;\n  }\n\n  span.height = texHeight;\n  span.style.height = makeEm(spanHeight);\n  return {\n    span,\n    advanceWidth,\n    // Calculate the actual line width.\n    // This actually should depend on the chosen font -- e.g. \\boldmath\n    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and\n    // have thicker rules.\n    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier\n  };\n}; // There are three kinds of delimiters, delimiters that stack when they become\n// too large\n\n\nvar stackLargeDelimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"\\\\surd\"]; // delimiters that always stack\n\nvar stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\"]; // and delimiters that never stack\n\nvar stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"]; // Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\n\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\n\nvar makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Sized delimiters are never centered.\n\n\n  if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {\n    return makeLargeDelim(delim, size, false, options, mode, classes);\n  } else if (utils.contains(stackAlwaysDelimiters, delim)) {\n    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);\n  } else {\n    throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}]; // Delimiters that always stack try the small delimiters first, then stack\n\nvar stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"stack\"\n}]; // Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\n\nvar stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n * TODO(#963) Use more specific font family return type once that is introduced.\n */\n\nvar delimTypeToFont = function delimTypeToFont(type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  } else {\n    throw new Error(\"Add support for delim type '\" + type.type + \"' here.\");\n  }\n};\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\n\n\nvar traverseSequence = function traverseSequence(delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  var start = Math.min(2, 3 - options.style.size);\n\n  for (var i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n\n    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), \"math\");\n    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      var newOptions = options.havingBaseStyle(sequence[i].style);\n      heightDepth *= newOptions.sizeMultiplier;\n    } // Check if the delimiter at this size works for the given height.\n\n\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  } // If we reached the end of the sequence, return the last sequence element.\n\n\n  return sequence[sequence.length - 1];\n};\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\n\n\nvar makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Decide what sequence to use\n\n\n  var sequence;\n\n  if (utils.contains(stackNeverDelimiters, delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (utils.contains(stackLargeDelimiters, delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  } // Look through the sequence\n\n\n  var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.\n  // Depending on the sequence element we decided on, call the\n  // appropriate function.\n\n  if (delimType.type === \"small\") {\n    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);\n  } else if (delimType.type === \"large\") {\n    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);\n  } else\n    /* if (delimType.type === \"stack\") */\n    {\n      return makeStackedDelim(delim, height, center, options, mode, classes);\n    }\n};\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\n\n\nvar makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right\n\n  var delimiterFactor = 901;\n  var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;\n  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n\n  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);\n};\n\nvar delimiter = {\n  sqrtImage: makeSqrtImage,\n  sizedDelim: makeSizedDelim,\n  sizeToMaxHeight: sizeToMaxHeight,\n  customSizedDelim: makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n};\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n  \"\\\\bigl\": {\n    mclass: \"mopen\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    mclass: \"mopen\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    mclass: \"mopen\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    mclass: \"mopen\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    mclass: \"mclose\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    mclass: \"mclose\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    mclass: \"mclose\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    mclass: \"mclose\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    mclass: \"mrel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    mclass: \"mrel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    mclass: \"mrel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    mclass: \"mrel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    mclass: \"mord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    mclass: \"mord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    mclass: \"mord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    mclass: \"mord\",\n    size: 4\n  }\n};\nvar delimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"<\", \">\", \"\\\\langle\", \"\\u27e8\", \"\\\\rangle\", \"\\u27e9\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\n\n// Delimiter functions\nfunction checkDelimiter(delim, context) {\n  var symDelim = checkSymbolNodeType(delim);\n\n  if (symDelim && utils.contains(delimiters, symDelim.text)) {\n    return symDelim;\n  } else if (symDelim) {\n    throw new ParseError(\"Invalid delimiter '\" + symDelim.text + \"' after '\" + context.funcName + \"'\", delim);\n  } else {\n    throw new ParseError(\"Invalid delimiter type '\" + delim.type + \"'\", delim);\n  }\n}\n\ndefineFunction({\n  type: \"delimsizing\",\n  names: [\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n    return {\n      type: \"delimsizing\",\n      mode: context.parser.mode,\n      size: delimiterSizes[context.funcName].size,\n      mclass: delimiterSizes[context.funcName].mclass,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    if (group.delim === \".\") {\n      // Empty delimiters still count as elements, even though they don't\n      // show anything.\n      return buildCommon.makeSpan([group.mclass]);\n    } // Use delimiter.sizedDelim to generate the delimiter.\n\n\n    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);\n  },\n  mathmlBuilder: group => {\n    var children = [];\n\n    if (group.delim !== \".\") {\n      children.push(makeText(group.delim, group.mode));\n    }\n\n    var node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      // Only some of the delimsizing functions act as fences, and they\n      // return \"mopen\" or \"mclose\" mclass.\n      node.setAttribute(\"fence\", \"true\");\n    } else {\n      // Explicitly disable fencing if it's not a fence, to override the\n      // defaults.\n      node.setAttribute(\"fence\", \"false\");\n    }\n\n    node.setAttribute(\"stretchy\", \"true\");\n    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);\n    node.setAttribute(\"minsize\", size);\n    node.setAttribute(\"maxsize\", size);\n    return node;\n  }\n});\n\nfunction assertParsed(group) {\n  if (!group.body) {\n    throw new Error(\"Bug: The leftright ParseNode wasn't fully parsed.\");\n  }\n}\n\ndefineFunction({\n  type: \"leftright-right\",\n  names: [\"\\\\right\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    // \\left case below triggers parsing of \\right in\n    //   `const right = parser.parseFunction();`\n    // uses this return value.\n    var color = context.parser.gullet.macros.get(\"\\\\current@color\");\n\n    if (color && typeof color !== \"string\") {\n      throw new ParseError(\"\\\\current@color set to non-string in \\\\right\");\n    }\n\n    return {\n      type: \"leftright-right\",\n      mode: context.parser.mode,\n      delim: checkDelimiter(args[0], context).text,\n      color // undefined if not set via \\color\n\n    };\n  }\n});\ndefineFunction({\n  type: \"leftright\",\n  names: [\"\\\\left\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n    var parser = context.parser; // Parse out the implicit body\n\n    ++parser.leftrightDepth; // parseExpression stops before '\\\\right'\n\n    var body = parser.parseExpression(false);\n    --parser.leftrightDepth; // Check the next token\n\n    parser.expect(\"\\\\right\", false);\n    var right = assertNodeType(parser.parseFunction(), \"leftright-right\");\n    return {\n      type: \"leftright\",\n      mode: parser.mode,\n      body,\n      left: delim.text,\n      right: right.delim,\n      rightColor: right.color\n    };\n  },\n  htmlBuilder: (group, options) => {\n    assertParsed(group); // Build the inner expression\n\n    var inner = buildExpression$1(group.body, options, true, [\"mopen\", \"mclose\"]);\n    var innerHeight = 0;\n    var innerDepth = 0;\n    var hadMiddle = false; // Calculate its height and depth\n\n    for (var i = 0; i < inner.length; i++) {\n      // Property `isMiddle` not defined on `span`. See comment in\n      // \"middle\"'s htmlBuilder.\n      // $FlowFixMe\n      if (inner[i].isMiddle) {\n        hadMiddle = true;\n      } else {\n        innerHeight = Math.max(inner[i].height, innerHeight);\n        innerDepth = Math.max(inner[i].depth, innerDepth);\n      }\n    } // The size of delimiters is the same, regardless of what style we are\n    // in. Thus, to correctly calculate the size of delimiter we need around\n    // a group, we scale down the inner size based on the size.\n\n\n    innerHeight *= options.sizeMultiplier;\n    innerDepth *= options.sizeMultiplier;\n    var leftDelim;\n\n    if (group.left === \".\") {\n      // Empty delimiters in \\left and \\right make null delimiter spaces.\n      leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n    } else {\n      // Otherwise, use leftRightDelim to generate the correct sized\n      // delimiter.\n      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, [\"mopen\"]);\n    } // Add it to the beginning of the expression\n\n\n    inner.unshift(leftDelim); // Handle middle delimiters\n\n    if (hadMiddle) {\n      for (var _i = 1; _i < inner.length; _i++) {\n        var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in\n        // \"middle\"'s htmlBuilder.\n        // $FlowFixMe\n\n        var isMiddle = middleDelim.isMiddle;\n\n        if (isMiddle) {\n          // Apply the options that were active when \\middle was called\n          inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);\n        }\n      }\n    }\n\n    var rightDelim; // Same for the right delimiter, but using color specified by \\color\n\n    if (group.right === \".\") {\n      rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n    } else {\n      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;\n      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, [\"mclose\"]);\n    } // Add it to the end of the expression.\n\n\n    inner.push(rightDelim);\n    return buildCommon.makeSpan([\"minner\"], inner, options);\n  },\n  mathmlBuilder: (group, options) => {\n    assertParsed(group);\n    var inner = buildExpression(group.body, options);\n\n    if (group.left !== \".\") {\n      var leftNode = new mathMLTree.MathNode(\"mo\", [makeText(group.left, group.mode)]);\n      leftNode.setAttribute(\"fence\", \"true\");\n      inner.unshift(leftNode);\n    }\n\n    if (group.right !== \".\") {\n      var rightNode = new mathMLTree.MathNode(\"mo\", [makeText(group.right, group.mode)]);\n      rightNode.setAttribute(\"fence\", \"true\");\n\n      if (group.rightColor) {\n        rightNode.setAttribute(\"mathcolor\", group.rightColor);\n      }\n\n      inner.push(rightNode);\n    }\n\n    return makeRow(inner);\n  }\n});\ndefineFunction({\n  type: \"middle\",\n  names: [\"\\\\middle\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n\n    if (!context.parser.leftrightDepth) {\n      throw new ParseError(\"\\\\middle without preceding \\\\left\", delim);\n    }\n\n    return {\n      type: \"middle\",\n      mode: context.parser.mode,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var middleDelim;\n\n    if (group.delim === \".\") {\n      middleDelim = makeNullDelimiter(options, []);\n    } else {\n      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);\n      var isMiddle = {\n        delim: group.delim,\n        options\n      }; // Property `isMiddle` not defined on `span`. It is only used in\n      // this file above.\n      // TODO: Fix this violation of the `span` type and possibly rename\n      // things since `isMiddle` sounds like a boolean, but is a struct.\n      // $FlowFixMe\n\n      middleDelim.isMiddle = isMiddle;\n    }\n\n    return middleDelim;\n  },\n  mathmlBuilder: (group, options) => {\n    // A Firefox \\middle will stretch a character vertically only if it\n    // is in the fence part of the operator dictionary at:\n    // https://www.w3.org/TR/MathML3/appendixc.html.\n    // So we need to avoid U+2223 and use plain \"|\" instead.\n    var textNode = group.delim === \"\\\\vert\" || group.delim === \"|\" ? makeText(\"|\", \"text\") : makeText(group.delim, group.mode);\n    var middleNode = new mathMLTree.MathNode(\"mo\", [textNode]);\n    middleNode.setAttribute(\"fence\", \"true\"); // MathML gives 5/18em spacing to each <mo> element.\n    // \\middle should get delimiter spacing instead.\n\n    middleNode.setAttribute(\"lspace\", \"0.05em\");\n    middleNode.setAttribute(\"rspace\", \"0.05em\");\n    return middleNode;\n  }\n});\n\nvar htmlBuilder$7 = (group, options) => {\n  // \\cancel, \\bcancel, \\xcancel, \\sout, \\fbox, \\colorbox, \\fcolorbox, \\phase\n  // Some groups can return document fragments.  Handle those by wrapping\n  // them in a span.\n  var inner = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);\n  var label = group.label.slice(1);\n  var scale = options.sizeMultiplier;\n  var img;\n  var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different\n  // depending on whether the subject is wider than it is tall, or vice versa.\n  // We don't know the width of a group, so as a proxy, we test if\n  // the subject is a single character. This captures most of the\n  // subjects that should get the \"tall\" treatment.\n\n  var isSingleChar = utils.isCharacterBox(group.body);\n\n  if (label === \"sout\") {\n    img = buildCommon.makeSpan([\"stretchy\", \"sout\"]);\n    img.height = options.fontMetrics().defaultRuleThickness / scale;\n    imgShift = -0.5 * options.fontMetrics().xHeight;\n  } else if (label === \"phase\") {\n    // Set a couple of dimensions from the steinmetz package.\n    var lineWeight = calculateSize({\n      number: 0.6,\n      unit: \"pt\"\n    }, options);\n    var clearance = calculateSize({\n      number: 0.35,\n      unit: \"ex\"\n    }, options); // Prevent size changes like \\Huge from affecting line thickness\n\n    var newOptions = options.havingBaseSizing();\n    scale = scale / newOptions.sizeMultiplier;\n    var angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.\n\n    inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG\n\n    var viewBoxHeight = Math.floor(1000 * angleHeight * scale);\n    var path = phasePath(viewBoxHeight);\n    var svgNode = new SvgNode([new PathNode(\"phase\", path)], {\n      \"width\": \"400em\",\n      \"height\": makeEm(viewBoxHeight / 1000),\n      \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n      \"preserveAspectRatio\": \"xMinYMin slice\"\n    }); // Wrap it in a span with overflow: hidden.\n\n    img = buildCommon.makeSvgSpan([\"hide-tail\"], [svgNode], options);\n    img.style.height = makeEm(angleHeight);\n    imgShift = inner.depth + lineWeight + clearance;\n  } else {\n    // Add horizontal padding\n    if (/cancel/.test(label)) {\n      if (!isSingleChar) {\n        inner.classes.push(\"cancel-pad\");\n      }\n    } else if (label === \"angl\") {\n      inner.classes.push(\"anglpad\");\n    } else {\n      inner.classes.push(\"boxpad\");\n    } // Add vertical padding\n\n\n    var topPad = 0;\n    var bottomPad = 0;\n    var ruleThickness = 0; // ref: cancel package: \\advance\\totalheight2\\p@ % \"+2\"\n\n    if (/box/.test(label)) {\n      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default\n      options.minRuleThickness // User override.\n      );\n      topPad = options.fontMetrics().fboxsep + (label === \"colorbox\" ? 0 : ruleThickness);\n      bottomPad = topPad;\n    } else if (label === \"angl\") {\n      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n      topPad = 4 * ruleThickness; // gap = 3  line, plus the line itself.\n\n      bottomPad = Math.max(0, 0.25 - inner.depth);\n    } else {\n      topPad = isSingleChar ? 0.2 : 0;\n      bottomPad = topPad;\n    }\n\n    img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);\n\n    if (/fbox|boxed|fcolorbox/.test(label)) {\n      img.style.borderStyle = \"solid\";\n      img.style.borderWidth = makeEm(ruleThickness);\n    } else if (label === \"angl\" && ruleThickness !== 0.049) {\n      img.style.borderTopWidth = makeEm(ruleThickness);\n      img.style.borderRightWidth = makeEm(ruleThickness);\n    }\n\n    imgShift = inner.depth + bottomPad;\n\n    if (group.backgroundColor) {\n      img.style.backgroundColor = group.backgroundColor;\n\n      if (group.borderColor) {\n        img.style.borderColor = group.borderColor;\n      }\n    }\n  }\n\n  var vlist;\n\n  if (group.backgroundColor) {\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Put the color background behind inner;\n      {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift\n      }, {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }]\n    }, options);\n  } else {\n    var classes = /cancel|phase/.test(label) ? [\"svg-align\"] : [];\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Write the \\cancel stroke on top of inner.\n      {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }, {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift,\n        wrapperClasses: classes\n      }]\n    }, options);\n  }\n\n  if (/cancel/.test(label)) {\n    // The cancel package documentation says that cancel lines add their height\n    // to the expression, but tests show that isn't how it actually works.\n    vlist.height = inner.height;\n    vlist.depth = inner.depth;\n  }\n\n  if (/cancel/.test(label) && !isSingleChar) {\n    // cancel does not create horiz space for its line extension.\n    return buildCommon.makeSpan([\"mord\", \"cancel-lap\"], [vlist], options);\n  } else {\n    return buildCommon.makeSpan([\"mord\"], [vlist], options);\n  }\n};\n\nvar mathmlBuilder$6 = (group, options) => {\n  var fboxsep = 0;\n  var node = new mathMLTree.MathNode(group.label.indexOf(\"colorbox\") > -1 ? \"mpadded\" : \"menclose\", [buildGroup(group.body, options)]);\n\n  switch (group.label) {\n    case \"\\\\cancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike\");\n      break;\n\n    case \"\\\\bcancel\":\n      node.setAttribute(\"notation\", \"downdiagonalstrike\");\n      break;\n\n    case \"\\\\phase\":\n      node.setAttribute(\"notation\", \"phasorangle\");\n      break;\n\n    case \"\\\\sout\":\n      node.setAttribute(\"notation\", \"horizontalstrike\");\n      break;\n\n    case \"\\\\fbox\":\n      node.setAttribute(\"notation\", \"box\");\n      break;\n\n    case \"\\\\angl\":\n      node.setAttribute(\"notation\", \"actuarial\");\n      break;\n\n    case \"\\\\fcolorbox\":\n    case \"\\\\colorbox\":\n      // <menclose> doesn't have a good notation option. So use <mpadded>\n      // instead. Set some attributes that come included with <menclose>.\n      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;\n      node.setAttribute(\"width\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"height\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"lspace\", fboxsep + \"pt\"); //\n\n      node.setAttribute(\"voffset\", fboxsep + \"pt\");\n\n      if (group.label === \"\\\\fcolorbox\") {\n        var thk = Math.max(options.fontMetrics().fboxrule, // default\n        options.minRuleThickness // user override\n        );\n        node.setAttribute(\"style\", \"border: \" + thk + \"em solid \" + String(group.borderColor));\n      }\n\n      break;\n\n    case \"\\\\xcancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike downdiagonalstrike\");\n      break;\n  }\n\n  if (group.backgroundColor) {\n    node.setAttribute(\"mathbackground\", group.backgroundColor);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\colorbox\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"text\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor: color,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fcolorbox\"],\n  props: {\n    numArgs: 3,\n    allowedInText: true,\n    argTypes: [\"color\", \"color\", \"text\"]\n  },\n\n  handler(_ref2, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var borderColor = assertNodeType(args[0], \"color-token\").color;\n    var backgroundColor = assertNodeType(args[1], \"color-token\").color;\n    var body = args[2];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor,\n      borderColor,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref3, args) {\n    var {\n      parser\n    } = _ref3;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\fbox\",\n      body: args[0]\n    };\n  }\n\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\cancel\", \"\\\\bcancel\", \"\\\\xcancel\", \"\\\\sout\", \"\\\\phase\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref4, args) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    var body = args[0];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\angl\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: false\n  },\n\n  handler(_ref5, args) {\n    var {\n      parser\n    } = _ref5;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\angl\",\n      body: args[0]\n    };\n  }\n\n});\n\n/**\n * All registered environments.\n * `environments.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `environments.js`.\n */\nvar _environments = {};\nfunction defineEnvironment(_ref) {\n  var {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of environments.\n  var data = {\n    type,\n    numArgs: props.numArgs || 0,\n    allowedInText: false,\n    numOptionalArgs: 0,\n    handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    // TODO: The value type of _environments should be a type union of all\n    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is\n    // an existential type.\n    _environments[names[i]] = data;\n  }\n\n  if (htmlBuilder) {\n    _htmlGroupBuilders[type] = htmlBuilder;\n  }\n\n  if (mathmlBuilder) {\n    _mathmlGroupBuilders[type] = mathmlBuilder;\n  }\n}\n\n/**\n * All registered global/built-in macros.\n * `macros.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `macros.js`.\n */\nvar _macros = {}; // This function might one day accept an additional argument and do more things.\n\nfunction defineMacro(name, body) {\n  _macros[name] = body;\n}\n\n// Helper functions\nfunction getHLines(parser) {\n  // Return an array. The array length = number of hlines.\n  // Each element in the array tells if the line is dashed.\n  var hlineInfo = [];\n  parser.consumeSpaces();\n  var nxt = parser.fetch().text;\n\n  if (nxt === \"\\\\relax\") {\n    // \\relax is an artifact of the \\cr macro below\n    parser.consume();\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  while (nxt === \"\\\\hline\" || nxt === \"\\\\hdashline\") {\n    parser.consume();\n    hlineInfo.push(nxt === \"\\\\hdashline\");\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  return hlineInfo;\n}\n\nvar validateAmsEnvironmentContext = context => {\n  var settings = context.parser.settings;\n\n  if (!settings.displayMode) {\n    throw new ParseError(\"{\" + context.envName + \"} can be used only in\" + \" display mode.\");\n  }\n}; // autoTag (an argument to parseArray) can be one of three values:\n// * undefined: Regular (not-top-level) array; no tags on each row\n// * true: Automatic equation numbering, overridable by \\tag\n// * false: Tags allowed on each row, but no automatic numbering\n// This function *doesn't* work with the \"split\" environment name.\n\n\nfunction getAutoTag(name) {\n  if (name.indexOf(\"ed\") === -1) {\n    return name.indexOf(\"*\") === -1;\n  } // return undefined;\n\n}\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.  If given an optional argument style\n * (\"text\", \"display\", etc.), then each cell is cast into that style.\n */\n\n\nfunction parseArray(parser, _ref, style) {\n  var {\n    hskipBeforeAndAfter,\n    addJot,\n    cols,\n    arraystretch,\n    colSeparationType,\n    autoTag,\n    singleRow,\n    emptySingleRow,\n    maxNumCols,\n    leqno\n  } = _ref;\n  parser.gullet.beginGroup();\n\n  if (!singleRow) {\n    // \\cr is equivalent to \\\\ without the optional size argument (see below)\n    // TODO: provide helpful error when \\cr is used outside array environment\n    parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  } // Get current arraystretch if it's not set by the environment\n\n\n  if (!arraystretch) {\n    var stretch = parser.gullet.expandMacroAsText(\"\\\\arraystretch\");\n\n    if (stretch == null) {\n      // Default \\arraystretch from lttab.dtx\n      arraystretch = 1;\n    } else {\n      arraystretch = parseFloat(stretch);\n\n      if (!arraystretch || arraystretch < 0) {\n        throw new ParseError(\"Invalid \\\\arraystretch: \" + stretch);\n      }\n    }\n  } // Start group for first cell\n\n\n  parser.gullet.beginGroup();\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n  var hLinesBeforeRow = [];\n  var tags = autoTag != null ? [] : undefined; // amsmath uses \\global\\@eqnswtrue and \\global\\@eqnswfalse to represent\n  // whether this row should have an equation number.  Simulate this with\n  // a \\@eqnsw macro set to 1 or 0.\n\n  function beginRow() {\n    if (autoTag) {\n      parser.gullet.macros.set(\"\\\\@eqnsw\", \"1\", true);\n    }\n  }\n\n  function endRow() {\n    if (tags) {\n      if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n        tags.push(parser.subparse([new Token(\"\\\\df@tag\")]));\n        parser.gullet.macros.set(\"\\\\df@tag\", undefined, true);\n      } else {\n        tags.push(Boolean(autoTag) && parser.gullet.macros.get(\"\\\\@eqnsw\") === \"1\");\n      }\n    }\n  }\n\n  beginRow(); // Test for \\hline at the top of the array.\n\n  hLinesBeforeRow.push(getHLines(parser));\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Parse each cell in its own group (namespace)\n    var cell = parser.parseExpression(false, singleRow ? \"\\\\end\" : \"\\\\\\\\\");\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    cell = {\n      type: \"ordgroup\",\n      mode: parser.mode,\n      body: cell\n    };\n\n    if (style) {\n      cell = {\n        type: \"styling\",\n        mode: parser.mode,\n        style,\n        body: [cell]\n      };\n    }\n\n    row.push(cell);\n    var next = parser.fetch().text;\n\n    if (next === \"&\") {\n      if (maxNumCols && row.length === maxNumCols) {\n        if (singleRow || colSeparationType) {\n          // {equation} or {split}\n          throw new ParseError(\"Too many tab characters: &\", parser.nextToken);\n        } else {\n          // {array} environment\n          parser.settings.reportNonstrict(\"textEnv\", \"Too few columns \" + \"specified in the {array} column argument.\");\n        }\n      }\n\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      endRow(); // Arrays terminate newlines with `\\crcr` which consumes a `\\cr` if\n      // the last line is empty.  However, AMS environments keep the\n      // empty row if it's the only one.\n      // NOTE: Currently, `cell` is the last item added into `row`.\n\n      if (row.length === 1 && cell.type === \"styling\" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {\n        body.pop();\n      }\n\n      if (hLinesBeforeRow.length < body.length + 1) {\n        hLinesBeforeRow.push([]);\n      }\n\n      break;\n    } else if (next === \"\\\\\\\\\") {\n      parser.consume();\n      var size = void 0; // \\def\\Let@{\\let\\\\\\math@cr}\n      // \\def\\math@cr{...\\math@cr@}\n      // \\def\\math@cr@{\\new@ifnextchar[\\math@cr@@{\\math@cr@@[\\z@]}}\n      // \\def\\math@cr@@[#1]{...\\math@cr@@@...}\n      // \\def\\math@cr@@@{\\cr}\n\n      if (parser.gullet.future().text !== \" \") {\n        size = parser.parseSizeGroup(true);\n      }\n\n      rowGaps.push(size ? size.value : null);\n      endRow(); // check for \\hline(s) following the row separator\n\n      hLinesBeforeRow.push(getHLines(parser));\n      row = [];\n      body.push(row);\n      beginRow();\n    } else {\n      throw new ParseError(\"Expected & or \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  } // End cell group\n\n\n  parser.gullet.endGroup(); // End array group defining \\cr\n\n  parser.gullet.endGroup();\n  return {\n    type: \"array\",\n    mode: parser.mode,\n    addJot,\n    arraystretch,\n    body,\n    cols,\n    rowGaps,\n    hskipBeforeAndAfter,\n    hLinesBeforeRow,\n    colSeparationType,\n    tags,\n    leqno\n  };\n} // Decides on a style for cells in an array according to whether the given\n// environment name starts with the letter 'd'.\n\n\nfunction dCellStyle(envName) {\n  if (envName.slice(0, 1) === \"d\") {\n    return \"display\";\n  } else {\n    return \"text\";\n  }\n}\n\nvar htmlBuilder$6 = function htmlBuilder(group, options) {\n  var r;\n  var c;\n  var nr = group.body.length;\n  var hLinesBeforeRow = group.hLinesBeforeRow;\n  var nc = 0;\n  var body = new Array(nr);\n  var hlines = [];\n  var ruleThickness = Math.max( // From LaTeX \\showthe\\arrayrulewidth. Equals 0.04 em.\n  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.\n  ); // Horizontal spacing\n\n  var pt = 1 / options.fontMetrics().ptPerEm;\n  var arraycolsep = 5 * pt; // default value, i.e. \\arraycolsep in article.cls\n\n  if (group.colSeparationType && group.colSeparationType === \"small\") {\n    // We're in a {smallmatrix}. Default column space is \\thickspace,\n    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.\n    // But that needs adjustment because LaTeX applies \\scriptstyle to the\n    // entire array, including the colspace, but this function applies\n    // \\scriptstyle only inside each element.\n    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;\n    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);\n  } // Vertical spacing\n\n\n  var baselineskip = group.colSeparationType === \"CD\" ? calculateSize({\n    number: 3,\n    unit: \"ex\"\n  }, options) : 12 * pt; // see size10.clo\n  // Default \\jot from ltmath.dtx\n  // TODO(edemaine): allow overriding \\jot via \\setlength (#687)\n\n  var jot = 3 * pt;\n  var arrayskip = group.arraystretch * baselineskip;\n  var arstrutHeight = 0.7 * arrayskip; // \\strutbox in ltfsstrc.dtx and\n\n  var arstrutDepth = 0.3 * arrayskip; // \\@arstrutbox in lttab.dtx\n\n  var totalHeight = 0; // Set a position for \\hline(s) at the top of the array, if any.\n\n  function setHLinePos(hlinesInGap) {\n    for (var i = 0; i < hlinesInGap.length; ++i) {\n      if (i > 0) {\n        totalHeight += 0.25;\n      }\n\n      hlines.push({\n        pos: totalHeight,\n        isDashed: hlinesInGap[i]\n      });\n    }\n  }\n\n  setHLinePos(hLinesBeforeRow[0]);\n\n  for (r = 0; r < group.body.length; ++r) {\n    var inrow = group.body[r];\n    var height = arstrutHeight; // \\@array adds an \\@arstrut\n\n    var depth = arstrutDepth; // to each tow (via the template)\n\n    if (nc < inrow.length) {\n      nc = inrow.length;\n    }\n\n    var outrow = new Array(inrow.length);\n\n    for (c = 0; c < inrow.length; ++c) {\n      var elt = buildGroup$1(inrow[c], options);\n\n      if (depth < elt.depth) {\n        depth = elt.depth;\n      }\n\n      if (height < elt.height) {\n        height = elt.height;\n      }\n\n      outrow[c] = elt;\n    }\n\n    var rowGap = group.rowGaps[r];\n    var gap = 0;\n\n    if (rowGap) {\n      gap = calculateSize(rowGap, options);\n\n      if (gap > 0) {\n        // \\@argarraycr\n        gap += arstrutDepth;\n\n        if (depth < gap) {\n          depth = gap; // \\@xargarraycr\n        }\n\n        gap = 0;\n      }\n    } // In AMS multiline environments such as aligned and gathered, rows\n    // correspond to lines that have additional \\jot added to the\n    // \\baselineskip via \\openup.\n\n\n    if (group.addJot) {\n      depth += jot;\n    }\n\n    outrow.height = height;\n    outrow.depth = depth;\n    totalHeight += height;\n    outrow.pos = totalHeight;\n    totalHeight += depth + gap; // \\@yargarraycr\n\n    body[r] = outrow; // Set a position for \\hline(s), if any.\n\n    setHLinePos(hLinesBeforeRow[r + 1]);\n  }\n\n  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;\n  var colDescriptions = group.cols || [];\n  var cols = [];\n  var colSep;\n  var colDescrNum;\n  var tagSpans = [];\n\n  if (group.tags && group.tags.some(tag => tag)) {\n    // An environment with manual tags and/or automatic equation numbers.\n    // Create node(s), the latter of which trigger CSS counter increment.\n    for (r = 0; r < nr; ++r) {\n      var rw = body[r];\n      var shift = rw.pos - offset;\n      var tag = group.tags[r];\n      var tagSpan = void 0;\n\n      if (tag === true) {\n        // automatic numbering\n        tagSpan = buildCommon.makeSpan([\"eqn-num\"], [], options);\n      } else if (tag === false) {\n        // \\nonumber/\\notag or starred environment\n        tagSpan = buildCommon.makeSpan([], [], options);\n      } else {\n        // manual \\tag\n        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);\n      }\n\n      tagSpan.depth = rw.depth;\n      tagSpan.height = rw.height;\n      tagSpans.push({\n        type: \"elem\",\n        elem: tagSpan,\n        shift\n      });\n    }\n  }\n\n  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column\n  // descriptions, so trailing separators don't get lost.\n  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {\n    var colDescr = colDescriptions[colDescrNum] || {};\n    var firstSeparator = true;\n\n    while (colDescr.type === \"separator\") {\n      // If there is more than one separator in a row, add a space\n      // between them.\n      if (!firstSeparator) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);\n        cols.push(colSep);\n      }\n\n      if (colDescr.separator === \"|\" || colDescr.separator === \":\") {\n        var lineType = colDescr.separator === \"|\" ? \"solid\" : \"dashed\";\n        var separator = buildCommon.makeSpan([\"vertical-separator\"], [], options);\n        separator.style.height = makeEm(totalHeight);\n        separator.style.borderRightWidth = makeEm(ruleThickness);\n        separator.style.borderRightStyle = lineType;\n        separator.style.margin = \"0 \" + makeEm(-ruleThickness / 2);\n\n        var _shift = totalHeight - offset;\n\n        if (_shift) {\n          separator.style.verticalAlign = makeEm(-_shift);\n        }\n\n        cols.push(separator);\n      } else {\n        throw new ParseError(\"Invalid separator type: \" + colDescr.separator);\n      }\n\n      colDescrNum++;\n      colDescr = colDescriptions[colDescrNum] || {};\n      firstSeparator = false;\n    }\n\n    if (c >= nc) {\n      continue;\n    }\n\n    var sepwidth = void 0;\n\n    if (c > 0 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n\n    var col = [];\n\n    for (r = 0; r < nr; ++r) {\n      var row = body[r];\n      var elem = row[c];\n\n      if (!elem) {\n        continue;\n      }\n\n      var _shift2 = row.pos - offset;\n\n      elem.depth = row.depth;\n      elem.height = row.height;\n      col.push({\n        type: \"elem\",\n        elem: elem,\n        shift: _shift2\n      });\n    }\n\n    col = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: col\n    }, options);\n    col = buildCommon.makeSpan([\"col-align-\" + (colDescr.align || \"c\")], [col]);\n    cols.push(col);\n\n    if (c < nc - 1 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n  }\n\n  body = buildCommon.makeSpan([\"mtable\"], cols); // Add \\hline(s), if any.\n\n  if (hlines.length > 0) {\n    var line = buildCommon.makeLineSpan(\"hline\", options, ruleThickness);\n    var dashes = buildCommon.makeLineSpan(\"hdashline\", options, ruleThickness);\n    var vListElems = [{\n      type: \"elem\",\n      elem: body,\n      shift: 0\n    }];\n\n    while (hlines.length > 0) {\n      var hline = hlines.pop();\n      var lineShift = hline.pos - offset;\n\n      if (hline.isDashed) {\n        vListElems.push({\n          type: \"elem\",\n          elem: dashes,\n          shift: lineShift\n        });\n      } else {\n        vListElems.push({\n          type: \"elem\",\n          elem: line,\n          shift: lineShift\n        });\n      }\n    }\n\n    body = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: vListElems\n    }, options);\n  }\n\n  if (tagSpans.length === 0) {\n    return buildCommon.makeSpan([\"mord\"], [body], options);\n  } else {\n    var eqnNumCol = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: tagSpans\n    }, options);\n    eqnNumCol = buildCommon.makeSpan([\"tag\"], [eqnNumCol], options);\n    return buildCommon.makeFragment([body, eqnNumCol]);\n  }\n};\n\nvar alignMap = {\n  c: \"center \",\n  l: \"left \",\n  r: \"right \"\n};\n\nvar mathmlBuilder$5 = function mathmlBuilder(group, options) {\n  var tbl = [];\n  var glue = new mathMLTree.MathNode(\"mtd\", [], [\"mtr-glue\"]);\n  var tag = new mathMLTree.MathNode(\"mtd\", [], [\"mml-eqn-num\"]);\n\n  for (var i = 0; i < group.body.length; i++) {\n    var rw = group.body[i];\n    var row = [];\n\n    for (var j = 0; j < rw.length; j++) {\n      row.push(new mathMLTree.MathNode(\"mtd\", [buildGroup(rw[j], options)]));\n    }\n\n    if (group.tags && group.tags[i]) {\n      row.unshift(glue);\n      row.push(glue);\n\n      if (group.leqno) {\n        row.unshift(tag);\n      } else {\n        row.push(tag);\n      }\n    }\n\n    tbl.push(new mathMLTree.MathNode(\"mtr\", row));\n  }\n\n  var table = new mathMLTree.MathNode(\"mtable\", tbl); // Set column alignment, row spacing, column spacing, and\n  // array lines by setting attributes on the table element.\n  // Set the row spacing. In MathML, we specify a gap distance.\n  // We do not use rowGap[] because MathML automatically increases\n  // cell height with the height/depth of the element content.\n  // LaTeX \\arraystretch multiplies the row baseline-to-baseline distance.\n  // We simulate this by adding (arraystretch - 1)em to the gap. This\n  // does a reasonable job of adjusting arrays containing 1 em tall content.\n  // The 0.16 and 0.09 values are found empirically. They produce an array\n  // similar to LaTeX and in which content does not interfere with \\hlines.\n\n  var gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}\n  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);\n  table.setAttribute(\"rowspacing\", makeEm(gap)); // MathML table lines go only between cells.\n  // To place a line on an edge we'll use <menclose>, if necessary.\n\n  var menclose = \"\";\n  var align = \"\";\n\n  if (group.cols && group.cols.length > 0) {\n    // Find column alignment, column spacing, and  vertical lines.\n    var cols = group.cols;\n    var columnLines = \"\";\n    var prevTypeWasAlign = false;\n    var iStart = 0;\n    var iEnd = cols.length;\n\n    if (cols[0].type === \"separator\") {\n      menclose += \"top \";\n      iStart = 1;\n    }\n\n    if (cols[cols.length - 1].type === \"separator\") {\n      menclose += \"bottom \";\n      iEnd -= 1;\n    }\n\n    for (var _i = iStart; _i < iEnd; _i++) {\n      if (cols[_i].type === \"align\") {\n        align += alignMap[cols[_i].align];\n\n        if (prevTypeWasAlign) {\n          columnLines += \"none \";\n        }\n\n        prevTypeWasAlign = true;\n      } else if (cols[_i].type === \"separator\") {\n        // MathML accepts only single lines between cells.\n        // So we read only the first of consecutive separators.\n        if (prevTypeWasAlign) {\n          columnLines += cols[_i].separator === \"|\" ? \"solid \" : \"dashed \";\n          prevTypeWasAlign = false;\n        }\n      }\n    }\n\n    table.setAttribute(\"columnalign\", align.trim());\n\n    if (/[sd]/.test(columnLines)) {\n      table.setAttribute(\"columnlines\", columnLines.trim());\n    }\n  } // Set column spacing.\n\n\n  if (group.colSeparationType === \"align\") {\n    var _cols = group.cols || [];\n\n    var spacing = \"\";\n\n    for (var _i2 = 1; _i2 < _cols.length; _i2++) {\n      spacing += _i2 % 2 ? \"0em \" : \"1em \";\n    }\n\n    table.setAttribute(\"columnspacing\", spacing.trim());\n  } else if (group.colSeparationType === \"alignat\" || group.colSeparationType === \"gather\") {\n    table.setAttribute(\"columnspacing\", \"0em\");\n  } else if (group.colSeparationType === \"small\") {\n    table.setAttribute(\"columnspacing\", \"0.2778em\");\n  } else if (group.colSeparationType === \"CD\") {\n    table.setAttribute(\"columnspacing\", \"0.5em\");\n  } else {\n    table.setAttribute(\"columnspacing\", \"1em\");\n  } // Address \\hline and \\hdashline\n\n\n  var rowLines = \"\";\n  var hlines = group.hLinesBeforeRow;\n  menclose += hlines[0].length > 0 ? \"left \" : \"\";\n  menclose += hlines[hlines.length - 1].length > 0 ? \"right \" : \"\";\n\n  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {\n    rowLines += hlines[_i3].length === 0 ? \"none \" // MathML accepts only a single line between rows. Read one element.\n    : hlines[_i3][0] ? \"dashed \" : \"solid \";\n  }\n\n  if (/[sd]/.test(rowLines)) {\n    table.setAttribute(\"rowlines\", rowLines.trim());\n  }\n\n  if (menclose !== \"\") {\n    table = new mathMLTree.MathNode(\"menclose\", [table]);\n    table.setAttribute(\"notation\", menclose.trim());\n  }\n\n  if (group.arraystretch && group.arraystretch < 1) {\n    // A small array. Wrap in scriptstyle so row gap is not too large.\n    table = new mathMLTree.MathNode(\"mstyle\", [table]);\n    table.setAttribute(\"scriptlevel\", \"1\");\n  }\n\n  return table;\n}; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.\n\n\nvar alignedHandler = function alignedHandler(context, args) {\n  if (context.envName.indexOf(\"ed\") === -1) {\n    validateAmsEnvironmentContext(context);\n  }\n\n  var cols = [];\n  var separationType = context.envName.indexOf(\"at\") > -1 ? \"alignat\" : \"align\";\n  var isSplit = context.envName === \"split\";\n  var res = parseArray(context.parser, {\n    cols,\n    addJot: true,\n    autoTag: isSplit ? undefined : getAutoTag(context.envName),\n    emptySingleRow: true,\n    colSeparationType: separationType,\n    maxNumCols: isSplit ? 2 : undefined,\n    leqno: context.parser.settings.leqno\n  }, \"display\"); // Determining number of columns.\n  // 1. If the first argument is given, we use it as a number of columns,\n  //    and makes sure that each row doesn't exceed that number.\n  // 2. Otherwise, just count number of columns = maximum number\n  //    of cells in each row (\"aligned\" mode -- isAligned will be true).\n  //\n  // At the same time, prepend empty group {} at beginning of every second\n  // cell in each row (starting with second cell) so that operators become\n  // binary.  This behavior is implemented in amsmath's \\start@aligned.\n\n  var numMaths;\n  var numCols = 0;\n  var emptyGroup = {\n    type: \"ordgroup\",\n    mode: context.mode,\n    body: []\n  };\n\n  if (args[0] && args[0].type === \"ordgroup\") {\n    var arg0 = \"\";\n\n    for (var i = 0; i < args[0].body.length; i++) {\n      var textord = assertNodeType(args[0].body[i], \"textord\");\n      arg0 += textord.text;\n    }\n\n    numMaths = Number(arg0);\n    numCols = numMaths * 2;\n  }\n\n  var isAligned = !numCols;\n  res.body.forEach(function (row) {\n    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {\n      // Modify ordgroup node within styling node\n      var styling = assertNodeType(row[_i4], \"styling\");\n      var ordgroup = assertNodeType(styling.body[0], \"ordgroup\");\n      ordgroup.body.unshift(emptyGroup);\n    }\n\n    if (!isAligned) {\n      // Case 1\n      var curMaths = row.length / 2;\n\n      if (numMaths < curMaths) {\n        throw new ParseError(\"Too many math in a row: \" + (\"expected \" + numMaths + \", but got \" + curMaths), row[0]);\n      }\n    } else if (numCols < row.length) {\n      // Case 2\n      numCols = row.length;\n    }\n  }); // Adjusting alignment.\n  // In aligned mode, we add one \\qquad between columns;\n  // otherwise we add nothing.\n\n  for (var _i5 = 0; _i5 < numCols; ++_i5) {\n    var align = \"r\";\n    var pregap = 0;\n\n    if (_i5 % 2 === 1) {\n      align = \"l\";\n    } else if (_i5 > 0 && isAligned) {\n      // \"aligned\" mode.\n      pregap = 1; // add one \\quad\n    }\n\n    cols[_i5] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n\n  res.colSeparationType = isAligned ? \"align\" : \"alignat\";\n  return res;\n}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\n// {darray} is an {array} environment where cells are set in \\displaystyle,\n// as defined in nccmath.sty.\n\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"array\", \"darray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Since no types are specified above, the two possibilities are\n    // - The argument is wrapped in {} or [], in which case Parser's\n    //   parseGroup() returns an \"ordgroup\" wrapping some symbol node.\n    // - The argument is a bare symbol node.\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text;\n\n      if (\"lcr\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      } else if (ca === \"|\") {\n        return {\n          type: \"separator\",\n          separator: \"|\"\n        };\n      } else if (ca === \":\") {\n        return {\n          type: \"separator\",\n          separator: \":\"\n        };\n      }\n\n      throw new ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n    var res = {\n      cols,\n      hskipBeforeAndAfter: true,\n      // \\@preamble in lttab.dtx\n      maxNumCols: cols.length\n    };\n    return parseArray(context.parser, res, dCellStyle(context.envName));\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\n// The mathtools package adds starred versions of the same environments.\n// These have an optional argument to choose left|center|right justification.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\", \"matrix*\", \"pmatrix*\", \"bmatrix*\", \"Bmatrix*\", \"vmatrix*\", \"Vmatrix*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var delimiters = {\n      \"matrix\": null,\n      \"pmatrix\": [\"(\", \")\"],\n      \"bmatrix\": [\"[\", \"]\"],\n      \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n      \"vmatrix\": [\"|\", \"|\"],\n      \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n    }[context.envName.replace(\"*\", \"\")]; // \\hskip -\\arraycolsep in amsmath\n\n    var colAlign = \"c\";\n    var payload = {\n      hskipBeforeAndAfter: false,\n      cols: [{\n        type: \"align\",\n        align: colAlign\n      }]\n    };\n\n    if (context.envName.charAt(context.envName.length - 1) === \"*\") {\n      // It's one of the mathtools starred functions.\n      // Parse the optional alignment argument.\n      var parser = context.parser;\n      parser.consumeSpaces();\n\n      if (parser.fetch().text === \"[\") {\n        parser.consume();\n        parser.consumeSpaces();\n        colAlign = parser.fetch().text;\n\n        if (\"lcr\".indexOf(colAlign) === -1) {\n          throw new ParseError(\"Expected l or c or r\", parser.nextToken);\n        }\n\n        parser.consume();\n        parser.consumeSpaces();\n        parser.expect(\"]\");\n        parser.consume();\n        payload.cols = [{\n          type: \"align\",\n          align: colAlign\n        }];\n      }\n    }\n\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.\n\n    var numCols = Math.max(0, ...res.body.map(row => row.length));\n    res.cols = new Array(numCols).fill({\n      type: \"align\",\n      align: colAlign\n    });\n    return delimiters ? {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1],\n      rightColor: undefined // \\right uninfluenced by \\color in array\n\n    } : res;\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"smallmatrix\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var payload = {\n      arraystretch: 0.5\n    };\n    var res = parseArray(context.parser, payload, \"script\");\n    res.colSeparationType = \"small\";\n    return res;\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"subarray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Parsing of {subarray} is similar to {array}\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text; // {subarray} only recognizes \"l\" & \"c\"\n\n      if (\"lc\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      }\n\n      throw new ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n\n    if (cols.length > 1) {\n      throw new ParseError(\"{subarray} can contain only one column\");\n    }\n\n    var res = {\n      cols,\n      hskipBeforeAndAfter: false,\n      arraystretch: 0.5\n    };\n    res = parseArray(context.parser, res, \"script\");\n\n    if (res.body.length > 0 && res.body[0].length > 1) {\n      throw new ParseError(\"{subarray} can contain only one column\");\n    }\n\n    return res;\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}}  \\end{array}\\right.\n// {dcases} is a {cases} environment where cells are set in \\displaystyle,\n// as defined in mathtools.sty.\n// {rcases} is another mathtools environment. It's brace is on the right side.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"cases\", \"dcases\", \"rcases\", \"drcases\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var payload = {\n      arraystretch: 1.2,\n      cols: [{\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        // TODO(kevinb) get the current style.\n        // For now we use the metrics for TEXT style which is what we were\n        // doing before.  Before attempting to get the current style we\n        // should look at TeX's behavior especially for \\over and matrices.\n        postgap: 1.0\n        /* 1em quad */\n\n      }, {\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        postgap: 0\n      }]\n    };\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName));\n    return {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: context.envName.indexOf(\"r\") > -1 ? \".\" : \"\\\\{\",\n      right: context.envName.indexOf(\"r\") > -1 ? \"\\\\}\" : \".\",\n      rightColor: undefined\n    };\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // In the align environment, one uses ampersands, &, to specify number of\n// columns in each row, and to locate spacing between each column.\n// align gets automatic numbering. align* and aligned do not.\n// The alignedat environment can be used in math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"align\", \"align*\", \"aligned\", \"split\"],\n  props: {\n    numArgs: 0\n  },\n  handler: alignedHandler,\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // A gathered environment is like an array environment with one centered\n// column, but where rows are considered lines so get \\jot line spacing\n// and contents are set in \\displaystyle.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"gathered\", \"gather\", \"gather*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    if (utils.contains([\"gather\", \"gather*\"], context.envName)) {\n      validateAmsEnvironmentContext(context);\n    }\n\n    var res = {\n      cols: [{\n        type: \"align\",\n        align: \"c\"\n      }],\n      addJot: true,\n      colSeparationType: \"gather\",\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // alignat environment is like an align environment, but one must explicitly\n// specify maximum number of columns in each row, and can adjust spacing between\n// each columns.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"alignat\", \"alignat*\", \"alignedat\"],\n  props: {\n    numArgs: 1\n  },\n  handler: alignedHandler,\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"equation\", \"equation*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    var res = {\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      singleRow: true,\n      maxNumCols: 1,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"CD\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    return parseCD(context.parser);\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineMacro(\"\\\\nonumber\", \"\\\\gdef\\\\@eqnsw{0}\");\ndefineMacro(\"\\\\notag\", \"\\\\nonumber\"); // Catch \\hline outside array environment\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\hline\", \"\\\\hdashline\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: true\n  },\n\n  handler(context, args) {\n    throw new ParseError(context.funcName + \" valid only within array environment\");\n  }\n\n});\n\nvar environments = _environments;\n\n// defineEnvironment definitions.\n\ndefineFunction({\n  type: \"environment\",\n  names: [\"\\\\begin\", \"\\\\end\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"]\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var nameGroup = args[0];\n\n    if (nameGroup.type !== \"ordgroup\") {\n      throw new ParseError(\"Invalid environment name\", nameGroup);\n    }\n\n    var envName = \"\";\n\n    for (var i = 0; i < nameGroup.body.length; ++i) {\n      envName += assertNodeType(nameGroup.body[i], \"textord\").text;\n    }\n\n    if (funcName === \"\\\\begin\") {\n      // begin...end is similar to left...right\n      if (!environments.hasOwnProperty(envName)) {\n        throw new ParseError(\"No such environment: \" + envName, nameGroup);\n      } // Build the environment object. Arguments and other information will\n      // be made available to the begin and end methods using properties.\n\n\n      var env = environments[envName];\n      var {\n        args: _args,\n        optArgs\n      } = parser.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n      var context = {\n        mode: parser.mode,\n        envName,\n        parser\n      };\n      var result = env.handler(context, _args, optArgs);\n      parser.expect(\"\\\\end\", false);\n      var endNameToken = parser.nextToken;\n      var end = assertNodeType(parser.parseFunction(), \"environment\");\n\n      if (end.name !== envName) {\n        throw new ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched by \\\\end{\" + end.name + \"}\", endNameToken);\n      } // $FlowFixMe, \"environment\" handler returns an environment ParseNode\n\n\n      return result;\n    }\n\n    return {\n      type: \"environment\",\n      mode: parser.mode,\n      name: envName,\n      nameGroup\n    };\n  }\n\n});\n\n// TODO(kevinb): implement \\\\sl and \\\\sc\n\nvar htmlBuilder$5 = (group, options) => {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildGroup$1(group.body, newOptions);\n};\n\nvar mathmlBuilder$4 = (group, options) => {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildGroup(group.body, newOptions);\n};\n\nvar fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\",\n  \"\\\\bm\": \"\\\\boldsymbol\"\n};\ndefineFunction({\n  type: \"font\",\n  names: [// styles, except \\boldsymbol defined below\n  \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\", \"\\\\mathnormal\", // families\n  \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\", // aliases, except \\bm defined below\n  \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"],\n  props: {\n    numArgs: 1,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = normalizeArgument(args[0]);\n    var func = funcName;\n\n    if (func in fontAliases) {\n      func = fontAliases[func];\n    }\n\n    return {\n      type: \"font\",\n      mode: parser.mode,\n      font: func.slice(1),\n      body\n    };\n  },\n  htmlBuilder: htmlBuilder$5,\n  mathmlBuilder: mathmlBuilder$4\n});\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\boldsymbol\", \"\\\\bm\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    var isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \\boldsymbol uses \\binrel spacing to inherit the\n    // argument's bin|rel|ord status\n\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(body),\n      body: [{\n        type: \"font\",\n        mode: parser.mode,\n        font: \"boldsymbol\",\n        body\n      }],\n      isCharacterBox: isCharacterBox\n    };\n  }\n}); // Old font changing functions\n\ndefineFunction({\n  type: \"font\",\n  names: [\"\\\\rm\", \"\\\\sf\", \"\\\\tt\", \"\\\\bf\", \"\\\\it\", \"\\\\cal\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    var {\n      parser,\n      funcName,\n      breakOnTokenText\n    } = _ref3;\n    var {\n      mode\n    } = parser;\n    var body = parser.parseExpression(true, breakOnTokenText);\n    var style = \"math\" + funcName.slice(1);\n    return {\n      type: \"font\",\n      mode: mode,\n      font: style,\n      body: {\n        type: \"ordgroup\",\n        mode: parser.mode,\n        body\n      }\n    };\n  },\n  htmlBuilder: htmlBuilder$5,\n  mathmlBuilder: mathmlBuilder$4\n});\n\nvar adjustStyle = (size, originalStyle) => {\n  // Figure out what style this fraction should be in based on the\n  // function used\n  var style = originalStyle;\n\n  if (size === \"display\") {\n    // Get display style as a default.\n    // If incoming style is sub/sup, use style.text() to get correct size.\n    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;\n  } else if (size === \"text\" && style.size === Style$1.DISPLAY.size) {\n    // We're in a \\tfrac but incoming style is displaystyle, so:\n    style = Style$1.TEXT;\n  } else if (size === \"script\") {\n    style = Style$1.SCRIPT;\n  } else if (size === \"scriptscript\") {\n    style = Style$1.SCRIPTSCRIPT;\n  }\n\n  return style;\n};\n\nvar htmlBuilder$4 = (group, options) => {\n  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).\n  var style = adjustStyle(group.size, options.style);\n  var nstyle = style.fracNum();\n  var dstyle = style.fracDen();\n  var newOptions;\n  newOptions = options.havingStyle(nstyle);\n  var numerm = buildGroup$1(group.numer, newOptions, options);\n\n  if (group.continued) {\n    // \\cfrac inserts a \\strut into the numerator.\n    // Get \\strut dimensions from TeXbook page 353.\n    var hStrut = 8.5 / options.fontMetrics().ptPerEm;\n    var dStrut = 3.5 / options.fontMetrics().ptPerEm;\n    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;\n    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;\n  }\n\n  newOptions = options.havingStyle(dstyle);\n  var denomm = buildGroup$1(group.denom, newOptions, options);\n  var rule;\n  var ruleWidth;\n  var ruleSpacing;\n\n  if (group.hasBarLine) {\n    if (group.barSize) {\n      ruleWidth = calculateSize(group.barSize, options);\n      rule = buildCommon.makeLineSpan(\"frac-line\", options, ruleWidth);\n    } else {\n      rule = buildCommon.makeLineSpan(\"frac-line\", options);\n    }\n\n    ruleWidth = rule.height;\n    ruleSpacing = rule.height;\n  } else {\n    rule = null;\n    ruleWidth = 0;\n    ruleSpacing = options.fontMetrics().defaultRuleThickness;\n  } // Rule 15b\n\n\n  var numShift;\n  var clearance;\n  var denomShift;\n\n  if (style.size === Style$1.DISPLAY.size || group.size === \"display\") {\n    numShift = options.fontMetrics().num1;\n\n    if (ruleWidth > 0) {\n      clearance = 3 * ruleSpacing;\n    } else {\n      clearance = 7 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom1;\n  } else {\n    if (ruleWidth > 0) {\n      numShift = options.fontMetrics().num2;\n      clearance = ruleSpacing;\n    } else {\n      numShift = options.fontMetrics().num3;\n      clearance = 3 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom2;\n  }\n\n  var frac;\n\n  if (!rule) {\n    // Rule 15c\n    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);\n\n    if (candidateClearance < clearance) {\n      numShift += 0.5 * (clearance - candidateClearance);\n      denomShift += 0.5 * (clearance - candidateClearance);\n    }\n\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } else {\n    // Rule 15d\n    var axisHeight = options.fontMetrics().axisHeight;\n\n    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {\n      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));\n    }\n\n    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {\n      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));\n    }\n\n    var midShift = -(axisHeight - 0.5 * ruleWidth);\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: rule,\n        shift: midShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } // Since we manually change the style sometimes (with \\dfrac or \\tfrac),\n  // account for the possible size change here.\n\n\n  newOptions = options.havingStyle(style);\n  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;\n  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e\n\n  var delimSize;\n\n  if (style.size === Style$1.DISPLAY.size) {\n    delimSize = options.fontMetrics().delim1;\n  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {\n    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;\n  } else {\n    delimSize = options.fontMetrics().delim2;\n  }\n\n  var leftDelim;\n  var rightDelim;\n\n  if (group.leftDelim == null) {\n    leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n  } else {\n    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mopen\"]);\n  }\n\n  if (group.continued) {\n    rightDelim = buildCommon.makeSpan([]); // zero width for \\cfrac\n  } else if (group.rightDelim == null) {\n    rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n  } else {\n    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mclose\"]);\n  }\n\n  return buildCommon.makeSpan([\"mord\"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan([\"mfrac\"], [frac]), rightDelim], options);\n};\n\nvar mathmlBuilder$3 = (group, options) => {\n  var node = new mathMLTree.MathNode(\"mfrac\", [buildGroup(group.numer, options), buildGroup(group.denom, options)]);\n\n  if (!group.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  } else if (group.barSize) {\n    var ruleWidth = calculateSize(group.barSize, options);\n    node.setAttribute(\"linethickness\", makeEm(ruleWidth));\n  }\n\n  var style = adjustStyle(group.size, options.style);\n\n  if (style.size !== options.style.size) {\n    node = new mathMLTree.MathNode(\"mstyle\", [node]);\n    var isDisplay = style.size === Style$1.DISPLAY.size ? \"true\" : \"false\";\n    node.setAttribute(\"displaystyle\", isDisplay);\n    node.setAttribute(\"scriptlevel\", \"0\");\n  }\n\n  if (group.leftDelim != null || group.rightDelim != null) {\n    var withDelims = [];\n\n    if (group.leftDelim != null) {\n      var leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.leftDelim.replace(\"\\\\\", \"\"))]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n\n    withDelims.push(node);\n\n    if (group.rightDelim != null) {\n      var rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.rightDelim.replace(\"\\\\\", \"\"))]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n\n    return makeRow(withDelims);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\", \"\\\\\\\\atopfrac\", // cant be entered directly\n  \"\\\\\\\\bracefrac\", \"\\\\\\\\brackfrac\" // ditto\n  ],\n  props: {\n    numArgs: 2,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var numer = args[0];\n    var denom = args[1];\n    var hasBarLine;\n    var leftDelim = null;\n    var rightDelim = null;\n    var size = \"auto\";\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\frac\":\n      case \"\\\\tfrac\":\n        hasBarLine = true;\n        break;\n\n      case \"\\\\\\\\atopfrac\":\n        hasBarLine = false;\n        break;\n\n      case \"\\\\dbinom\":\n      case \"\\\\binom\":\n      case \"\\\\tbinom\":\n        hasBarLine = false;\n        leftDelim = \"(\";\n        rightDelim = \")\";\n        break;\n\n      case \"\\\\\\\\bracefrac\":\n        hasBarLine = false;\n        leftDelim = \"\\\\{\";\n        rightDelim = \"\\\\}\";\n        break;\n\n      case \"\\\\\\\\brackfrac\":\n        hasBarLine = false;\n        leftDelim = \"[\";\n        rightDelim = \"]\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\dbinom\":\n        size = \"display\";\n        break;\n\n      case \"\\\\tfrac\":\n      case \"\\\\tbinom\":\n        size = \"text\";\n        break;\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: false,\n      numer,\n      denom,\n      hasBarLine,\n      leftDelim,\n      rightDelim,\n      size,\n      barSize: null\n    };\n  },\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\cfrac\"],\n  props: {\n    numArgs: 2\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var numer = args[0];\n    var denom = args[1];\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: true,\n      numer,\n      denom,\n      hasBarLine: true,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"display\",\n      barSize: null\n    };\n  }\n}); // Infix generalized fractions -- these are not rendered directly, but replaced\n// immediately by one of the variants above.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\over\", \"\\\\choose\", \"\\\\atop\", \"\\\\brace\", \"\\\\brack\"],\n  props: {\n    numArgs: 0,\n    infix: true\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref3;\n    var replaceWith;\n\n    switch (funcName) {\n      case \"\\\\over\":\n        replaceWith = \"\\\\frac\";\n        break;\n\n      case \"\\\\choose\":\n        replaceWith = \"\\\\binom\";\n        break;\n\n      case \"\\\\atop\":\n        replaceWith = \"\\\\\\\\atopfrac\";\n        break;\n\n      case \"\\\\brace\":\n        replaceWith = \"\\\\\\\\bracefrac\";\n        break;\n\n      case \"\\\\brack\":\n        replaceWith = \"\\\\\\\\brackfrac\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized infix genfrac command\");\n    }\n\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith,\n      token\n    };\n  }\n\n});\nvar stylArray = [\"display\", \"text\", \"script\", \"scriptscript\"];\n\nvar delimFromValue = function delimFromValue(delimString) {\n  var delim = null;\n\n  if (delimString.length > 0) {\n    delim = delimString;\n    delim = delim === \".\" ? null : delim;\n  }\n\n  return delim;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\genfrac\"],\n  props: {\n    numArgs: 6,\n    allowedInArgument: true,\n    argTypes: [\"math\", \"math\", \"size\", \"text\", \"math\", \"math\"]\n  },\n\n  handler(_ref4, args) {\n    var {\n      parser\n    } = _ref4;\n    var numer = args[4];\n    var denom = args[5]; // Look into the parse nodes to get the desired delimiters.\n\n    var leftNode = normalizeArgument(args[0]);\n    var leftDelim = leftNode.type === \"atom\" && leftNode.family === \"open\" ? delimFromValue(leftNode.text) : null;\n    var rightNode = normalizeArgument(args[1]);\n    var rightDelim = rightNode.type === \"atom\" && rightNode.family === \"close\" ? delimFromValue(rightNode.text) : null;\n    var barNode = assertNodeType(args[2], \"size\");\n    var hasBarLine;\n    var barSize = null;\n\n    if (barNode.isBlank) {\n      // \\genfrac acts differently than \\above.\n      // \\genfrac treats an empty size group as a signal to use a\n      // standard bar size. \\above would see size = 0 and omit the bar.\n      hasBarLine = true;\n    } else {\n      barSize = barNode.value;\n      hasBarLine = barSize.number > 0;\n    } // Find out if we want displaystyle, textstyle, etc.\n\n\n    var size = \"auto\";\n    var styl = args[3];\n\n    if (styl.type === \"ordgroup\") {\n      if (styl.body.length > 0) {\n        var textOrd = assertNodeType(styl.body[0], \"textord\");\n        size = stylArray[Number(textOrd.text)];\n      }\n    } else {\n      styl = assertNodeType(styl, \"textord\");\n      size = stylArray[Number(styl.text)];\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim,\n      rightDelim,\n      size\n    };\n  },\n\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n}); // \\above is an infix fraction that also defines a fraction bar size.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\above\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    infix: true\n  },\n\n  handler(_ref5, args) {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref5;\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith: \"\\\\\\\\abovefrac\",\n      size: assertNodeType(args[0], \"size\").value,\n      token\n    };\n  }\n\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\\\\\abovefrac\"],\n  props: {\n    numArgs: 3,\n    argTypes: [\"math\", \"size\", \"math\"]\n  },\n  handler: (_ref6, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref6;\n    var numer = args[0];\n    var barSize = assert(assertNodeType(args[1], \"infix\").size);\n    var denom = args[2];\n    var hasBarLine = barSize.number > 0;\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"auto\"\n    };\n  },\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n});\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"horizBrace\", but\n// also \"supsub\" since an over/underbrace can affect super/subscripting.\nvar htmlBuilder$3 = (grp, options) => {\n  var style = options.style; // Pull out the `ParseNode<\"horizBrace\">` if `grp` is a \"supsub\" node.\n\n  var supSubGroup;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // Ref: LaTeX source2e: }}}}\\limits}\n    // i.e. LaTeX treats the brace similar to an op and passes it\n    // with \\limits, so we need to assign supsub style.\n    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);\n    group = assertNodeType(grp.base, \"horizBrace\");\n  } else {\n    group = assertNodeType(grp, \"horizBrace\");\n  } // Build the base group\n\n\n  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element\n\n  var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        \n  // This first vlist contains the content and the brace:   equation\n\n  var vlist;\n\n  if (group.isOver) {\n    vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: braceBody\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n  } else {\n    vlist = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: body.depth + 0.1 + braceBody.height,\n      children: [{\n        type: \"elem\",\n        elem: braceBody\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: body\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[0].classes.push(\"svg-align\");\n  }\n\n  if (supSubGroup) {\n    // To write the supsub, wrap the first vlist in another vlist:\n    // They can't all go in the same vlist, because the note might be\n    // wider than the equation. We want the equation to control the\n    // brace width.\n    //      note          long note           long note\n    //      or         not    \n    //    equation           eqn                 eqn\n    var vSpan = buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n\n    if (group.isOver) {\n      vlist = buildCommon.makeVList({\n        positionType: \"firstBaseline\",\n        children: [{\n          type: \"elem\",\n          elem: vSpan\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: supSubGroup\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"bottom\",\n        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,\n        children: [{\n          type: \"elem\",\n          elem: supSubGroup\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: vSpan\n        }]\n      }, options);\n    }\n  }\n\n  return buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n};\n\nvar mathmlBuilder$2 = (group, options) => {\n  var accentNode = stretchy.mathMLnode(group.label);\n  return new mathMLTree.MathNode(group.isOver ? \"mover\" : \"munder\", [buildGroup(group.base, options), accentNode]);\n}; // Horizontal stretchy braces\n\n\ndefineFunction({\n  type: \"horizBrace\",\n  names: [\"\\\\overbrace\", \"\\\\underbrace\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"horizBrace\",\n      mode: parser.mode,\n      label: funcName,\n      isOver: /^\\\\over/.test(funcName),\n      base: args[0]\n    };\n  },\n\n  htmlBuilder: htmlBuilder$3,\n  mathmlBuilder: mathmlBuilder$2\n});\n\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\href\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"url\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    var body = args[1];\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\href\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\href\");\n    }\n\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options, false);\n    return buildCommon.makeAnchor(group.href, [], elements, options);\n  },\n  mathmlBuilder: (group, options) => {\n    var math = buildExpressionRow(group.body, options);\n\n    if (!(math instanceof MathNode)) {\n      math = new MathNode(\"mrow\", [math]);\n    }\n\n    math.setAttribute(\"href\", group.href);\n    return math;\n  }\n});\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\url\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"url\"],\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\url\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\url\");\n    }\n\n    var chars = [];\n\n    for (var i = 0; i < href.length; i++) {\n      var c = href[i];\n\n      if (c === \"~\") {\n        c = \"\\\\textasciitilde\";\n      }\n\n      chars.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: c\n      });\n    }\n\n    var body = {\n      type: \"text\",\n      mode: parser.mode,\n      font: \"\\\\texttt\",\n      body: chars\n    };\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  }\n});\n\n// In LaTeX, \\vcenter can act only on a box, as in\n// \\vcenter{\\hbox{$\\frac{a+b}{\\dfrac{c}{d}}$}}\n// This function by itself doesn't do anything but prevent a soft line break.\n\ndefineFunction({\n  type: \"hbox\",\n  names: [\"\\\\hbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"hbox\",\n      mode: parser.mode,\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var elements = buildExpression$1(group.body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", buildExpression(group.body, options));\n  }\n\n});\n\ndefineFunction({\n  type: \"html\",\n  names: [\"\\\\htmlClass\", \"\\\\htmlId\", \"\\\\htmlStyle\", \"\\\\htmlData\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"raw\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref;\n    var value = assertNodeType(args[0], \"raw\").string;\n    var body = args[1];\n\n    if (parser.settings.strict) {\n      parser.settings.reportNonstrict(\"htmlExtension\", \"HTML extension is disabled on strict mode\");\n    }\n\n    var trustContext;\n    var attributes = {};\n\n    switch (funcName) {\n      case \"\\\\htmlClass\":\n        attributes.class = value;\n        trustContext = {\n          command: \"\\\\htmlClass\",\n          class: value\n        };\n        break;\n\n      case \"\\\\htmlId\":\n        attributes.id = value;\n        trustContext = {\n          command: \"\\\\htmlId\",\n          id: value\n        };\n        break;\n\n      case \"\\\\htmlStyle\":\n        attributes.style = value;\n        trustContext = {\n          command: \"\\\\htmlStyle\",\n          style: value\n        };\n        break;\n\n      case \"\\\\htmlData\":\n        {\n          var data = value.split(\",\");\n\n          for (var i = 0; i < data.length; i++) {\n            var keyVal = data[i].split(\"=\");\n\n            if (keyVal.length !== 2) {\n              throw new ParseError(\"Error parsing key-value for \\\\htmlData\");\n            }\n\n            attributes[\"data-\" + keyVal[0].trim()] = keyVal[1].trim();\n          }\n\n          trustContext = {\n            command: \"\\\\htmlData\",\n            attributes\n          };\n          break;\n        }\n\n      default:\n        throw new Error(\"Unrecognized html command\");\n    }\n\n    if (!parser.settings.isTrusted(trustContext)) {\n      return parser.formatUnsupportedCmd(funcName);\n    }\n\n    return {\n      type: \"html\",\n      mode: parser.mode,\n      attributes,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options, false);\n    var classes = [\"enclosing\"];\n\n    if (group.attributes.class) {\n      classes.push(...group.attributes.class.trim().split(/\\s+/));\n    }\n\n    var span = buildCommon.makeSpan(classes, elements, options);\n\n    for (var attr in group.attributes) {\n      if (attr !== \"class\" && group.attributes.hasOwnProperty(attr)) {\n        span.setAttribute(attr, group.attributes[attr]);\n      }\n    }\n\n    return span;\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.body, options);\n  }\n});\n\ndefineFunction({\n  type: \"htmlmathml\",\n  names: [\"\\\\html@mathml\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"htmlmathml\",\n      mode: parser.mode,\n      html: ordargument(args[0]),\n      mathml: ordargument(args[1])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.html, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.mathml, options);\n  }\n});\n\nvar sizeData = function sizeData(str) {\n  if (/^[-+]? *(\\d+(\\.\\d*)?|\\.\\d+)$/.test(str)) {\n    // str is a number with no unit specified.\n    // default unit is bp, per graphix package.\n    return {\n      number: +str,\n      unit: \"bp\"\n    };\n  } else {\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(str);\n\n    if (!match) {\n      throw new ParseError(\"Invalid size: '\" + str + \"' in \\\\includegraphics\");\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new ParseError(\"Invalid unit: '\" + data.unit + \"' in \\\\includegraphics.\");\n    }\n\n    return data;\n  }\n};\n\ndefineFunction({\n  type: \"includegraphics\",\n  names: [\"\\\\includegraphics\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    argTypes: [\"raw\", \"url\"],\n    allowedInText: false\n  },\n  handler: (_ref, args, optArgs) => {\n    var {\n      parser\n    } = _ref;\n    var width = {\n      number: 0,\n      unit: \"em\"\n    };\n    var height = {\n      number: 0.9,\n      unit: \"em\"\n    }; // sorta character sized.\n\n    var totalheight = {\n      number: 0,\n      unit: \"em\"\n    };\n    var alt = \"\";\n\n    if (optArgs[0]) {\n      var attributeStr = assertNodeType(optArgs[0], \"raw\").string; // Parser.js does not parse key/value pairs. We get a string.\n\n      var attributes = attributeStr.split(\",\");\n\n      for (var i = 0; i < attributes.length; i++) {\n        var keyVal = attributes[i].split(\"=\");\n\n        if (keyVal.length === 2) {\n          var str = keyVal[1].trim();\n\n          switch (keyVal[0].trim()) {\n            case \"alt\":\n              alt = str;\n              break;\n\n            case \"width\":\n              width = sizeData(str);\n              break;\n\n            case \"height\":\n              height = sizeData(str);\n              break;\n\n            case \"totalheight\":\n              totalheight = sizeData(str);\n              break;\n\n            default:\n              throw new ParseError(\"Invalid key: '\" + keyVal[0] + \"' in \\\\includegraphics.\");\n          }\n        }\n      }\n    }\n\n    var src = assertNodeType(args[0], \"url\").url;\n\n    if (alt === \"\") {\n      // No alt given. Use the file name. Strip away the path.\n      alt = src;\n      alt = alt.replace(/^.*[\\\\/]/, '');\n      alt = alt.substring(0, alt.lastIndexOf('.'));\n    }\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\includegraphics\",\n      url: src\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\includegraphics\");\n    }\n\n    return {\n      type: \"includegraphics\",\n      mode: parser.mode,\n      alt: alt,\n      width: width,\n      height: height,\n      totalheight: totalheight,\n      src: src\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var height = calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n    }\n\n    var width = 0;\n\n    if (group.width.number > 0) {\n      width = calculateSize(group.width, options);\n    }\n\n    var style = {\n      height: makeEm(height + depth)\n    };\n\n    if (width > 0) {\n      style.width = makeEm(width);\n    }\n\n    if (depth > 0) {\n      style.verticalAlign = makeEm(-depth);\n    }\n\n    var node = new Img(group.src, group.alt, style);\n    node.height = height;\n    node.depth = depth;\n    return node;\n  },\n  mathmlBuilder: (group, options) => {\n    var node = new mathMLTree.MathNode(\"mglyph\", []);\n    node.setAttribute(\"alt\", group.alt);\n    var height = calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n      node.setAttribute(\"valign\", makeEm(-depth));\n    }\n\n    node.setAttribute(\"height\", makeEm(height + depth));\n\n    if (group.width.number > 0) {\n      var width = calculateSize(group.width, options);\n      node.setAttribute(\"width\", makeEm(width));\n    }\n\n    node.setAttribute(\"src\", group.src);\n    return node;\n  }\n});\n\n// Horizontal spacing commands\n\ndefineFunction({\n  type: \"kern\",\n  names: [\"\\\\kern\", \"\\\\mkern\", \"\\\\hskip\", \"\\\\mskip\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    primitive: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var size = assertNodeType(args[0], \"size\");\n\n    if (parser.settings.strict) {\n      var mathFunction = funcName[1] === 'm'; // \\mkern, \\mskip\n\n      var muUnit = size.value.unit === 'mu';\n\n      if (mathFunction) {\n        if (!muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" supports only mu units, \" + (\"not \" + size.value.unit + \" units\"));\n        }\n\n        if (parser.mode !== \"math\") {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" works only in math mode\");\n        }\n      } else {\n        // !mathFunction\n        if (muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" doesn't support mu units\");\n        }\n      }\n    }\n\n    return {\n      type: \"kern\",\n      mode: parser.mode,\n      dimension: size.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeGlue(group.dimension, options);\n  },\n\n  mathmlBuilder(group, options) {\n    var dimension = calculateSize(group.dimension, options);\n    return new mathMLTree.SpaceNode(dimension);\n  }\n\n});\n\n// Horizontal overlap functions\ndefineFunction({\n  type: \"lap\",\n  names: [\"\\\\mathllap\", \"\\\\mathrlap\", \"\\\\mathclap\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"lap\",\n      mode: parser.mode,\n      alignment: funcName.slice(5),\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    var inner;\n\n    if (group.alignment === \"clap\") {\n      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/\n      inner = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span\n\n      inner = buildCommon.makeSpan([\"inner\"], [inner], options);\n    } else {\n      inner = buildCommon.makeSpan([\"inner\"], [buildGroup$1(group.body, options)]);\n    }\n\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the\n    // two items involved in the lap.\n    // Next, use a strut to set the height of the HTML bounding box.\n    // Otherwise, a tall argument may be misplaced.\n    // This code resolved issue #1153\n\n    var strut = buildCommon.makeSpan([\"strut\"]);\n    strut.style.height = makeEm(node.height + node.depth);\n\n    if (node.depth) {\n      strut.style.verticalAlign = makeEm(-node.depth);\n    }\n\n    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.\n    // This code resolves issue #1234\n\n    node = buildCommon.makeSpan([\"thinbox\"], [node], options);\n    return buildCommon.makeSpan([\"mord\", \"vbox\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n\n    if (group.alignment !== \"rlap\") {\n      var offset = group.alignment === \"llap\" ? \"-1\" : \"-0.5\";\n      node.setAttribute(\"lspace\", offset + \"width\");\n    }\n\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\(\", \"$\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(_ref, args) {\n    var {\n      funcName,\n      parser\n    } = _ref;\n    var outerMode = parser.mode;\n    parser.switchMode(\"math\");\n    var close = funcName === \"\\\\(\" ? \"\\\\)\" : \"$\";\n    var body = parser.parseExpression(false, close);\n    parser.expect(close);\n    parser.switchMode(outerMode);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      style: \"text\",\n      body\n    };\n  }\n\n}); // Check for extra closing math delimiters\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\)\", \"\\\\]\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(context, args) {\n    throw new ParseError(\"Mismatched \" + context.funcName);\n  }\n\n});\n\nvar chooseMathStyle = (group, options) => {\n  switch (options.style.size) {\n    case Style$1.DISPLAY.size:\n      return group.display;\n\n    case Style$1.TEXT.size:\n      return group.text;\n\n    case Style$1.SCRIPT.size:\n      return group.script;\n\n    case Style$1.SCRIPTSCRIPT.size:\n      return group.scriptscript;\n\n    default:\n      return group.text;\n  }\n};\n\ndefineFunction({\n  type: \"mathchoice\",\n  names: [\"\\\\mathchoice\"],\n  props: {\n    numArgs: 4,\n    primitive: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"mathchoice\",\n      mode: parser.mode,\n      display: ordargument(args[0]),\n      text: ordargument(args[1]),\n      script: ordargument(args[2]),\n      scriptscript: ordargument(args[3])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var body = chooseMathStyle(group, options);\n    var elements = buildExpression$1(body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    var body = chooseMathStyle(group, options);\n    return buildExpressionRow(body, options);\n  }\n});\n\nvar assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {\n  base = buildCommon.makeSpan([], [base]);\n  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);\n  var sub;\n  var sup; // We manually have to handle the superscripts and subscripts. This,\n  // aside from the kern calculations, is copied from supsub.\n\n  if (supGroup) {\n    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);\n    sup = {\n      elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)\n    };\n  }\n\n  if (subGroup) {\n    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);\n\n    sub = {\n      elem: _elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)\n    };\n  } // Build the final group as a vlist of the possible subscript, base,\n  // and possible superscript.\n\n\n  var finalGroup;\n\n  if (sup && sub) {\n    var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: bottom,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else if (sub) {\n    var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note\n    // that we are supposed to shift the limits by 1/2 of the slant,\n    // but since we are centering the limits adding a full slant of\n    // margin will shift by 1/2 that.\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: top,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }]\n    }, options);\n  } else if (sup) {\n    var _bottom = base.depth + baseShift;\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: _bottom,\n      children: [{\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else {\n    // This case probably shouldn't occur (this would mean the\n    // supsub was sending us a group with no superscript or\n    // subscript) but be safe.\n    return base;\n  }\n\n  var parts = [finalGroup];\n\n  if (sub && slant !== 0 && !subIsSingleCharacter) {\n    // A negative margin-left was applied to the lower limit.\n    // Avoid an overlap by placing a spacer on the left on the group.\n    var spacer = buildCommon.makeSpan([\"mspace\"], [], options);\n    spacer.style.marginRight = makeEm(slant);\n    parts.unshift(spacer);\n  }\n\n  return buildCommon.makeSpan([\"mop\", \"op-limits\"], parts, options);\n};\n\n// Limits, symbols\n// Most operators have a large successor symbol, but these don't.\nvar noSuccessor = [\"\\\\smallint\"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only \"op\", but also\n// \"supsub\" since some of them (like \\int) can affect super/subscripting.\n\nvar htmlBuilder$2 = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"op\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"op\");\n  }\n\n  var style = options.style;\n  var large = false;\n\n  if (style.size === Style$1.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {\n    // Most symbol operators get larger in displaystyle (rule 13)\n    large = true;\n  }\n\n  var base;\n\n  if (group.symbol) {\n    // If this is a symbol, create the symbol.\n    var fontName = large ? \"Size2-Regular\" : \"Size1-Regular\";\n    var stash = \"\";\n\n    if (group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") {\n      // No font glyphs yet, so use a glyph w/o the oval.\n      // TODO: When font glyphs are available, delete this code.\n      stash = group.name.slice(1);\n      group.name = stash === \"oiint\" ? \"\\\\iint\" : \"\\\\iiint\";\n    }\n\n    base = buildCommon.makeSymbol(group.name, fontName, \"math\", options, [\"mop\", \"op-symbol\", large ? \"large-op\" : \"small-op\"]);\n\n    if (stash.length > 0) {\n      // We're in \\oiint or \\oiiint. Overlay the oval.\n      // TODO: When font glyphs are available, delete this code.\n      var italic = base.italic;\n      var oval = buildCommon.staticSvg(stash + \"Size\" + (large ? \"2\" : \"1\"), options);\n      base = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: base,\n          shift: 0\n        }, {\n          type: \"elem\",\n          elem: oval,\n          shift: large ? 0.08 : 0\n        }]\n      }, options);\n      group.name = \"\\\\\" + stash;\n      base.classes.unshift(\"mop\"); // $FlowFixMe\n\n      base.italic = italic;\n    }\n  } else if (group.body) {\n    // If this is a list, compose that list.\n    var inner = buildExpression$1(group.body, options, true);\n\n    if (inner.length === 1 && inner[0] instanceof SymbolNode) {\n      base = inner[0];\n      base.classes[0] = \"mop\"; // replace old mclass\n    } else {\n      base = buildCommon.makeSpan([\"mop\"], inner, options);\n    }\n  } else {\n    // Otherwise, this is a text operator. Build the text from the\n    // operator's name.\n    var output = [];\n\n    for (var i = 1; i < group.name.length; i++) {\n      output.push(buildCommon.mathsym(group.name[i], group.mode, options));\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], output, options);\n  } // If content of op is a single symbol, shift it vertically.\n\n\n  var baseShift = 0;\n  var slant = 0;\n\n  if ((base instanceof SymbolNode || group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") && !group.suppressBaseShift) {\n    // We suppress the shift of the base of \\overset and \\underset. Otherwise,\n    // shift the symbol so its center lies on the axis (rule 13). It\n    // appears that our fonts have the centers of the symbols already\n    // almost on the axis, so these numbers are very small. Note we\n    // don't actually apply this here, but instead it is used either in\n    // the vlist creation or separately when there are no limits.\n    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.\n    // $FlowFixMe\n\n    slant = base.italic;\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);\n  } else {\n    if (baseShift) {\n      base.style.position = \"relative\";\n      base.style.top = makeEm(baseShift);\n    }\n\n    return base;\n  }\n};\n\nvar mathmlBuilder$1 = (group, options) => {\n  var node;\n\n  if (group.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new MathNode(\"mo\", [makeText(group.name, group.mode)]);\n\n    if (utils.contains(noSuccessor, group.name)) {\n      node.setAttribute(\"largeop\", \"false\");\n    }\n  } else if (group.body) {\n    // This is an operator with children. Add them.\n    node = new MathNode(\"mo\", buildExpression(group.body, options));\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    node = new MathNode(\"mi\", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.\n    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4\n\n    var operator = new MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n    if (group.parentIsSupSub) {\n      node = new MathNode(\"mrow\", [node, operator]);\n    } else {\n      node = newDocumentFragment([node, operator]);\n    }\n  }\n\n  return node;\n};\n\nvar singleCharBigOps = {\n  \"\\u220F\": \"\\\\prod\",\n  \"\\u2210\": \"\\\\coprod\",\n  \"\\u2211\": \"\\\\sum\",\n  \"\\u22c0\": \"\\\\bigwedge\",\n  \"\\u22c1\": \"\\\\bigvee\",\n  \"\\u22c2\": \"\\\\bigcap\",\n  \"\\u22c3\": \"\\\\bigcup\",\n  \"\\u2a00\": \"\\\\bigodot\",\n  \"\\u2a01\": \"\\\\bigoplus\",\n  \"\\u2a02\": \"\\\\bigotimes\",\n  \"\\u2a04\": \"\\\\biguplus\",\n  \"\\u2a06\": \"\\\\bigsqcup\"\n};\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\", \"\\u220F\", \"\\u2210\", \"\\u2211\", \"\\u22c0\", \"\\u22c1\", \"\\u22c2\", \"\\u22c3\", \"\\u2a00\", \"\\u2a01\", \"\\u2a02\", \"\\u2a04\", \"\\u2a06\"],\n  props: {\n    numArgs: 0\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharBigOps[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // Note: calling defineFunction with a type that's already been defined only\n// works because the same htmlBuilder and mathmlBuilder are being used.\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\mathop\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\nvar singleCharIntegrals = {\n  \"\\u222b\": \"\\\\int\",\n  \"\\u222c\": \"\\\\iint\",\n  \"\\u222d\": \"\\\\iiint\",\n  \"\\u222e\": \"\\\\oint\",\n  \"\\u222f\": \"\\\\oiint\",\n  \"\\u2230\": \"\\\\oiiint\"\n}; // No limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arctg\", \"\\\\arcctg\", \"\\\\arg\", \"\\\\ch\", \"\\\\cos\", \"\\\\cosec\", \"\\\\cosh\", \"\\\\cot\", \"\\\\cotg\", \"\\\\coth\", \"\\\\csc\", \"\\\\ctg\", \"\\\\cth\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\sh\", \"\\\\tan\", \"\\\\tanh\", \"\\\\tg\", \"\\\\th\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // Limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref4) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // No limits, symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\", \"\\\\oiint\", \"\\\\oiiint\", \"\\u222b\", \"\\u222c\", \"\\u222d\", \"\\u222e\", \"\\u222f\", \"\\u2230\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref5) {\n    var {\n      parser,\n      funcName\n    } = _ref5;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharIntegrals[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n});\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only\n// \"operatorname\", but also  \"supsub\" since \\operatorname* can\n// affect super/subscripting.\nvar htmlBuilder$1 = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"operatorname\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"operatorname\");\n  }\n\n  var base;\n\n  if (group.body.length > 0) {\n    var body = group.body.map(child => {\n      // $FlowFixMe: Check if the node has a string `text` property.\n      var childText = child.text;\n\n      if (typeof childText === \"string\") {\n        return {\n          type: \"textord\",\n          mode: child.mode,\n          text: childText\n        };\n      } else {\n        return child;\n      }\n    }); // Consolidate function names into symbol characters.\n\n    var expression = buildExpression$1(body, options.withFont(\"mathrm\"), true);\n\n    for (var i = 0; i < expression.length; i++) {\n      var child = expression[i];\n\n      if (child instanceof SymbolNode) {\n        // Per amsopn package,\n        // change minus to hyphen and \\ast to asterisk\n        child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n      }\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], expression, options);\n  } else {\n    base = buildCommon.makeSpan([\"mop\"], [], options);\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);\n  } else {\n    return base;\n  }\n};\n\nvar mathmlBuilder = (group, options) => {\n  // The steps taken here are similar to the html version.\n  var expression = buildExpression(group.body, options.withFont(\"mathrm\")); // Is expression a string or has it something like a fraction?\n\n  var isAllString = true; // default\n\n  for (var i = 0; i < expression.length; i++) {\n    var node = expression[i];\n\n    if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {\n      switch (node.type) {\n        case \"mi\":\n        case \"mn\":\n        case \"ms\":\n        case \"mspace\":\n        case \"mtext\":\n          break;\n        // Do nothing yet.\n\n        case \"mo\":\n          {\n            var child = node.children[0];\n\n            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {\n              child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n            } else {\n              isAllString = false;\n            }\n\n            break;\n          }\n\n        default:\n          isAllString = false;\n      }\n    } else {\n      isAllString = false;\n    }\n  }\n\n  if (isAllString) {\n    // Write a single TextNode instead of multiple nested tags.\n    var word = expression.map(node => node.toText()).join(\"\");\n    expression = [new mathMLTree.TextNode(word)];\n  }\n\n  var identifier = new mathMLTree.MathNode(\"mi\", expression);\n  identifier.setAttribute(\"mathvariant\", \"normal\"); // \\u2061 is the same as &ApplyFunction;\n  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp\n\n  var operator = new mathMLTree.MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n  if (group.parentIsSupSub) {\n    return new mathMLTree.MathNode(\"mrow\", [identifier, operator]);\n  } else {\n    return mathMLTree.newDocumentFragment([identifier, operator]);\n  }\n}; // \\operatorname\n// amsopn.dtx: \\mathop{#1\\kern\\z@\\operator@font#3}\\newmcodes@\n\n\ndefineFunction({\n  type: \"operatorname\",\n  names: [\"\\\\operatorname@\", \"\\\\operatornamewithlimits\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"operatorname\",\n      mode: parser.mode,\n      body: ordargument(body),\n      alwaysHandleSupSub: funcName === \"\\\\operatornamewithlimits\",\n      limits: false,\n      parentIsSupSub: false\n    };\n  },\n  htmlBuilder: htmlBuilder$1,\n  mathmlBuilder\n});\ndefineMacro(\"\\\\operatorname\", \"\\\\@ifstar\\\\operatornamewithlimits\\\\operatorname@\");\n\ndefineFunctionBuilders({\n  type: \"ordgroup\",\n\n  htmlBuilder(group, options) {\n    if (group.semisimple) {\n      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));\n    }\n\n    return buildCommon.makeSpan([\"mord\"], buildExpression$1(group.body, options, true), options);\n  },\n\n  mathmlBuilder(group, options) {\n    return buildExpressionRow(group.body, options, true);\n  }\n\n});\n\ndefineFunction({\n  type: \"overline\",\n  names: [\"\\\\overline\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"overline\",\n      mode: parser.mode,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Overlines are handled in the TeXbook pg 443, Rule 9.\n    // Build the inner group in the cramped style.\n    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle()); // Create the line above the body\n\n    var line = buildCommon.makeLineSpan(\"overline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: innerGroup\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: defaultRuleThickness\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"overline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accent\", \"true\");\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"phantom\",\n  names: [\"\\\\phantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"phantom\",\n      mode: parser.mode,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options.withPhantom(), false); // \\phantom isn't supposed to affect the elements it contains.\n    // See \"color\" for more details.\n\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(group.body, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n  }\n});\ndefineFunction({\n  type: \"hphantom\",\n  names: [\"\\\\hphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    return {\n      type: \"hphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);\n    node.height = 0;\n    node.depth = 0;\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        node.children[i].height = 0;\n        node.children[i].depth = 0;\n      }\n    } // See smash for comment re: use of makeVList\n\n\n    node = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\smash as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"height\", \"0px\");\n    node.setAttribute(\"depth\", \"0px\");\n    return node;\n  }\n});\ndefineFunction({\n  type: \"vphantom\",\n  names: [\"\\\\vphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    var {\n      parser\n    } = _ref3;\n    var body = args[0];\n    return {\n      type: \"vphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var inner = buildCommon.makeSpan([\"inner\"], [buildGroup$1(group.body, options.withPhantom())]);\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    return buildCommon.makeSpan([\"mord\", \"rlap\"], [inner, fix], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"raisebox\",\n  names: [\"\\\\raisebox\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"size\", \"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var amount = assertNodeType(args[0], \"size\").value;\n    var body = args[1];\n    return {\n      type: \"raisebox\",\n      mode: parser.mode,\n      dy: amount,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var body = buildGroup$1(group.body, options);\n    var dy = calculateSize(group.dy, options);\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: -dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n    var dy = group.dy.number + group.dy.unit;\n    node.setAttribute(\"voffset\", dy);\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\relax\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n\ndefineFunction({\n  type: \"rule\",\n  names: [\"\\\\rule\"],\n  props: {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    argTypes: [\"size\", \"size\", \"size\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var shift = optArgs[0];\n    var width = assertNodeType(args[0], \"size\");\n    var height = assertNodeType(args[1], \"size\");\n    return {\n      type: \"rule\",\n      mode: parser.mode,\n      shift: shift && assertNodeType(shift, \"size\").value,\n      width: width.value,\n      height: height.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Make an empty span for the rule\n    var rule = buildCommon.makeSpan([\"mord\", \"rule\"], [], options); // Calculate the shift, width, and height of the rule, and account for units\n\n    var width = calculateSize(group.width, options);\n    var height = calculateSize(group.height, options);\n    var shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size\n\n    rule.style.borderRightWidth = makeEm(width);\n    rule.style.borderTopWidth = makeEm(height);\n    rule.style.bottom = makeEm(shift); // Record the height and width\n\n    rule.width = width;\n    rule.height = height + shift;\n    rule.depth = -shift; // Font size is the number large enough that the browser will\n    // reserve at least `absHeight` space above the baseline.\n    // The 1.125 factor was empirically determined\n\n    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;\n    return rule;\n  },\n\n  mathmlBuilder(group, options) {\n    var width = calculateSize(group.width, options);\n    var height = calculateSize(group.height, options);\n    var shift = group.shift ? calculateSize(group.shift, options) : 0;\n    var color = options.color && options.getColor() || \"black\";\n    var rule = new mathMLTree.MathNode(\"mspace\");\n    rule.setAttribute(\"mathbackground\", color);\n    rule.setAttribute(\"width\", makeEm(width));\n    rule.setAttribute(\"height\", makeEm(height));\n    var wrapper = new mathMLTree.MathNode(\"mpadded\", [rule]);\n\n    if (shift >= 0) {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n    } else {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n      wrapper.setAttribute(\"depth\", makeEm(-shift));\n    }\n\n    wrapper.setAttribute(\"voffset\", makeEm(shift));\n    return wrapper;\n  }\n\n});\n\nfunction sizingGroup(value, options, baseOptions) {\n  var inner = buildExpression$1(value, options, false);\n  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize\n  // manually. Handle nested size changes.\n\n  for (var i = 0; i < inner.length; i++) {\n    var pos = inner[i].classes.indexOf(\"sizing\");\n\n    if (pos < 0) {\n      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));\n    } else if (inner[i].classes[pos + 1] === \"reset-size\" + options.size) {\n      // This is a nested size change: e.g., inner[i] is the \"b\" in\n      // `\\Huge a \\small b`. Override the old size (the `reset-` class)\n      // but not the new size.\n      inner[i].classes[pos + 1] = \"reset-size\" + baseOptions.size;\n    }\n\n    inner[i].height *= multiplier;\n    inner[i].depth *= multiplier;\n  }\n\n  return buildCommon.makeFragment(inner);\n}\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\sixptsize\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\nvar htmlBuilder = (group, options) => {\n  // Handle sizing operators like \\Huge. Real TeX doesn't actually allow\n  // these functions inside of math expressions, so we do some special\n  // handling.\n  var newOptions = options.havingSize(group.size);\n  return sizingGroup(group.body, newOptions, options);\n};\ndefineFunction({\n  type: \"sizing\",\n  names: sizeFuncs,\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    var body = parser.parseExpression(false, breakOnTokenText);\n    return {\n      type: \"sizing\",\n      mode: parser.mode,\n      // Figure out what size to use based on the list of functions above\n      size: sizeFuncs.indexOf(funcName) + 1,\n      body\n    };\n  },\n  htmlBuilder,\n  mathmlBuilder: (group, options) => {\n    var newOptions = options.havingSize(group.size);\n    var inner = buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner); // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n\n    node.setAttribute(\"mathsize\", makeEm(newOptions.sizeMultiplier));\n    return node;\n  }\n});\n\n// smash, with optional [tb], as in AMS\ndefineFunction({\n  type: \"smash\",\n  names: [\"\\\\smash\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args, optArgs) => {\n    var {\n      parser\n    } = _ref;\n    var smashHeight = false;\n    var smashDepth = false;\n    var tbArg = optArgs[0] && assertNodeType(optArgs[0], \"ordgroup\");\n\n    if (tbArg) {\n      // Optional [tb] argument is engaged.\n      // ref: amsmath: \\renewcommand{\\smash}[1][tb]{%\n      //               def\\mb@t{\\ht}\\def\\mb@b{\\dp}\\def\\mb@tb{\\ht\\z@\\z@\\dp}%\n      var letter = \"\";\n\n      for (var i = 0; i < tbArg.body.length; ++i) {\n        var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n        letter = node.text;\n\n        if (letter === \"t\") {\n          smashHeight = true;\n        } else if (letter === \"b\") {\n          smashDepth = true;\n        } else {\n          smashHeight = false;\n          smashDepth = false;\n          break;\n        }\n      }\n    } else {\n      smashHeight = true;\n      smashDepth = true;\n    }\n\n    var body = args[0];\n    return {\n      type: \"smash\",\n      mode: parser.mode,\n      body,\n      smashHeight,\n      smashDepth\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);\n\n    if (!group.smashHeight && !group.smashDepth) {\n      return node;\n    }\n\n    if (group.smashHeight) {\n      node.height = 0; // In order to influence makeVList, we have to reset the children.\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          node.children[i].height = 0;\n        }\n      }\n    }\n\n    if (group.smashDepth) {\n      node.depth = 0;\n\n      if (node.children) {\n        for (var _i = 0; _i < node.children.length; _i++) {\n          node.children[_i].depth = 0;\n        }\n      }\n    } // At this point, we've reset the TeX-like height and depth values.\n    // But the span still has an HTML line height.\n    // makeVList applies \"display: table-cell\", which prevents the browser\n    // from acting on that line height. So we'll call makeVList now.\n\n\n    var smashedNode = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\hphantom as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [smashedNode], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n\n    if (group.smashHeight) {\n      node.setAttribute(\"height\", \"0px\");\n    }\n\n    if (group.smashDepth) {\n      node.setAttribute(\"depth\", \"0px\");\n    }\n\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"sqrt\",\n  names: [\"\\\\sqrt\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var index = optArgs[0];\n    var body = args[0];\n    return {\n      type: \"sqrt\",\n      mode: parser.mode,\n      body,\n      index\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Square roots are handled in the TeXbook pg. 443, Rule 11.\n    // First, we do the same steps as in overline to build the inner group\n    // and line\n    var inner = buildGroup$1(group.body, options.havingCrampedStyle());\n\n    if (inner.height === 0) {\n      // Render a small surd.\n      inner.height = options.fontMetrics().xHeight;\n    } // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n\n    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \\surd delimiter\n\n    var metrics = options.fontMetrics();\n    var theta = metrics.defaultRuleThickness;\n    var phi = theta;\n\n    if (options.style.id < Style$1.TEXT.id) {\n      phi = options.fontMetrics().xHeight;\n    } // Calculate the clearance between the body and line\n\n\n    var lineClearance = theta + phi / 4;\n    var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size\n\n    var {\n      span: img,\n      ruleWidth,\n      advanceWidth\n    } = delimiter.sqrtImage(minDelimiterHeight, options);\n    var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size\n\n    if (delimDepth > inner.height + inner.depth + lineClearance) {\n      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;\n    } // Shift the sqrt image\n\n\n    var imgShift = img.height - inner.height - lineClearance - ruleWidth;\n    inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.\n\n    var body = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: inner,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: -(inner.height + imgShift)\n      }, {\n        type: \"elem\",\n        elem: img\n      }, {\n        type: \"kern\",\n        size: ruleWidth\n      }]\n    }, options);\n\n    if (!group.index) {\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [body], options);\n    } else {\n      // Handle the optional root index\n      // The index is always in scriptscript style\n      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);\n      var rootm = buildGroup$1(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX\n      // source, in the definition of `\\r@@t`.\n\n      var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly\n\n      var rootVList = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -toShift,\n        children: [{\n          type: \"elem\",\n          elem: rootm\n        }]\n      }, options); // Add a class surrounding it so we can add on the appropriate\n      // kerning\n\n      var rootVListWrap = buildCommon.makeSpan([\"root\"], [rootVList]);\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [rootVListWrap, body], options);\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    var {\n      body,\n      index\n    } = group;\n    return index ? new mathMLTree.MathNode(\"mroot\", [buildGroup(body, options), buildGroup(index, options)]) : new mathMLTree.MathNode(\"msqrt\", [buildGroup(body, options)]);\n  }\n\n});\n\nvar styleMap = {\n  \"display\": Style$1.DISPLAY,\n  \"text\": Style$1.TEXT,\n  \"script\": Style$1.SCRIPT,\n  \"scriptscript\": Style$1.SCRIPTSCRIPT\n};\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    // parse out the implicit body\n    var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.\n    // here and in buildHTML and de-dupe the enumeration of all the styles).\n    // $FlowFixMe: The names above exactly match the styles.\n\n    var style = funcName.slice(1, funcName.length - 5);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Style changes are handled in the TeXbook on pg. 442, Rule 3.\n    var newStyle = styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle).withFont('');\n    return sizingGroup(group.body, newOptions, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Figure out what style we're changing to.\n    var newStyle = styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle);\n    var inner = buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n    var styleAttributes = {\n      \"display\": [\"0\", \"true\"],\n      \"text\": [\"0\", \"false\"],\n      \"script\": [\"1\", \"false\"],\n      \"scriptscript\": [\"2\", \"false\"]\n    };\n    var attr = styleAttributes[group.style];\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n    return node;\n  }\n\n});\n\n/**\n * Sometimes, groups perform special rules when they have superscripts or\n * subscripts attached to them. This function lets the `supsub` group know that\n * Sometimes, groups perform special rules when they have superscripts or\n * its inner element should handle the superscripts and subscripts instead of\n * handling them itself.\n */\nvar htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {\n  var base = group.base;\n\n  if (!base) {\n    return null;\n  } else if (base.type === \"op\") {\n    // Operators handle supsubs differently when they have limits\n    // (e.g. `\\displaystyle\\sum_2^3`)\n    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);\n    return delegate ? htmlBuilder$2 : null;\n  } else if (base.type === \"operatorname\") {\n    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);\n\n    return _delegate ? htmlBuilder$1 : null;\n  } else if (base.type === \"accent\") {\n    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;\n  } else if (base.type === \"horizBrace\") {\n    var isSup = !group.sub;\n    return isSup === base.isOver ? htmlBuilder$3 : null;\n  } else {\n    return null;\n  }\n}; // Super scripts and subscripts, whose precise placement can depend on other\n// functions that precede them.\n\n\ndefineFunctionBuilders({\n  type: \"supsub\",\n\n  htmlBuilder(group, options) {\n    // Superscript and subscripts are handled in the TeXbook on page\n    // 445-446, rules 18(a-f).\n    // Here is where we defer to the inner group if it should handle\n    // superscripts and subscripts itself.\n    var builderDelegate = htmlBuilderDelegate(group, options);\n\n    if (builderDelegate) {\n      return builderDelegate(group, options);\n    }\n\n    var {\n      base: valueBase,\n      sup: valueSup,\n      sub: valueSub\n    } = group;\n    var base = buildGroup$1(valueBase, options);\n    var supm;\n    var subm;\n    var metrics = options.fontMetrics(); // Rule 18a\n\n    var supShift = 0;\n    var subShift = 0;\n    var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);\n\n    if (valueSup) {\n      var newOptions = options.havingStyle(options.style.sup());\n      supm = buildGroup$1(valueSup, newOptions, options);\n\n      if (!isCharacterBox) {\n        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    }\n\n    if (valueSub) {\n      var _newOptions = options.havingStyle(options.style.sub());\n\n      subm = buildGroup$1(valueSub, _newOptions, options);\n\n      if (!isCharacterBox) {\n        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    } // Rule 18c\n\n\n    var minSupShift;\n\n    if (options.style === Style$1.DISPLAY) {\n      minSupShift = metrics.sup1;\n    } else if (options.style.cramped) {\n      minSupShift = metrics.sup3;\n    } else {\n      minSupShift = metrics.sup2;\n    } // scriptspace is a font-size-independent size, so scale it\n    // appropriately for use as the marginRight.\n\n\n    var multiplier = options.sizeMultiplier;\n    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);\n    var marginLeft = null;\n\n    if (subm) {\n      // Subscripts shouldn't be shifted by the base's italic correction.\n      // Account for that by shifting the subscript back the appropriate\n      // amount. Note we only do this when the base is a single symbol.\n      var isOiint = group.base && group.base.type === \"op\" && group.base.name && (group.base.name === \"\\\\oiint\" || group.base.name === \"\\\\oiiint\");\n\n      if (base instanceof SymbolNode || isOiint) {\n        // $FlowFixMe\n        marginLeft = makeEm(-base.italic);\n      }\n    }\n\n    var supsub;\n\n    if (supm && subm) {\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      subShift = Math.max(subShift, metrics.sub2);\n      var ruleWidth = metrics.defaultRuleThickness; // Rule 18e\n\n      var maxWidth = 4 * ruleWidth;\n\n      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {\n        subShift = maxWidth - (supShift - supm.depth) + subm.height;\n        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);\n\n        if (psi > 0) {\n          supShift += psi;\n          subShift -= psi;\n        }\n      }\n\n      var vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        shift: subShift,\n        marginRight,\n        marginLeft\n      }, {\n        type: \"elem\",\n        elem: supm,\n        shift: -supShift,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: vlistElem\n      }, options);\n    } else if (subm) {\n      // Rule 18b\n      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);\n      var _vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        marginLeft,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: subShift,\n        children: _vlistElem\n      }, options);\n    } else if (supm) {\n      // Rule 18c, d\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -supShift,\n        children: [{\n          type: \"elem\",\n          elem: supm,\n          marginRight\n        }]\n      }, options);\n    } else {\n      throw new Error(\"supsub must have either sup or sub.\");\n    } // Wrap the supsub vlist in a span.msupsub to reset text-align.\n\n\n    var mclass = getTypeOfDomTree(base, \"right\") || \"mord\";\n    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan([\"msupsub\"], [supsub])], options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Is the inner group a relevant horizonal brace?\n    var isBrace = false;\n    var isOver;\n    var isSup;\n\n    if (group.base && group.base.type === \"horizBrace\") {\n      isSup = !!group.sup;\n\n      if (isSup === group.base.isOver) {\n        isBrace = true;\n        isOver = group.base.isOver;\n      }\n    }\n\n    if (group.base && (group.base.type === \"op\" || group.base.type === \"operatorname\")) {\n      group.base.parentIsSupSub = true;\n    }\n\n    var children = [buildGroup(group.base, options)];\n\n    if (group.sub) {\n      children.push(buildGroup(group.sub, options));\n    }\n\n    if (group.sup) {\n      children.push(buildGroup(group.sup, options));\n    }\n\n    var nodeType;\n\n    if (isBrace) {\n      nodeType = isOver ? \"mover\" : \"munder\";\n    } else if (!group.sub) {\n      var base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {\n        nodeType = \"mover\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {\n        nodeType = \"mover\";\n      } else {\n        nodeType = \"msup\";\n      }\n    } else if (!group.sup) {\n      var _base = group.base;\n\n      if (_base && _base.type === \"op\" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {\n        nodeType = \"munder\";\n      } else if (_base && _base.type === \"operatorname\" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {\n        nodeType = \"munder\";\n      } else {\n        nodeType = \"msub\";\n      }\n    } else {\n      var _base2 = group.base;\n\n      if (_base2 && _base2.type === \"op\" && _base2.limits && options.style === Style$1.DISPLAY) {\n        nodeType = \"munderover\";\n      } else if (_base2 && _base2.type === \"operatorname\" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {\n        nodeType = \"munderover\";\n      } else {\n        nodeType = \"msubsup\";\n      }\n    }\n\n    return new mathMLTree.MathNode(nodeType, children);\n  }\n\n});\n\ndefineFunctionBuilders({\n  type: \"atom\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.mathsym(group.text, group.mode, options, [\"m\" + group.family]);\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mo\", [makeText(group.text, group.mode)]);\n\n    if (group.family === \"bin\") {\n      var variant = getVariant(group, options);\n\n      if (variant === \"bold-italic\") {\n        node.setAttribute(\"mathvariant\", variant);\n      }\n    } else if (group.family === \"punct\") {\n      node.setAttribute(\"separator\", \"true\");\n    } else if (group.family === \"open\" || group.family === \"close\") {\n      // Delims built here should not stretch vertically.\n      // See delimsizing.js for stretchy delims.\n      node.setAttribute(\"stretchy\", \"false\");\n    }\n\n    return node;\n  }\n\n});\n\n// \"mathord\" and \"textord\" ParseNodes created in Parser.js from symbol Groups in\n// src/symbols.js.\nvar defaultVariant = {\n  \"mi\": \"italic\",\n  \"mn\": \"normal\",\n  \"mtext\": \"normal\"\n};\ndefineFunctionBuilders({\n  type: \"mathord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"mathord\");\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mi\", [makeText(group.text, group.mode, options)]);\n    var variant = getVariant(group, options) || \"italic\";\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\ndefineFunctionBuilders({\n  type: \"textord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"textord\");\n  },\n\n  mathmlBuilder(group, options) {\n    var text = makeText(group.text, group.mode, options);\n    var variant = getVariant(group, options) || \"normal\";\n    var node;\n\n    if (group.mode === 'text') {\n      node = new mathMLTree.MathNode(\"mtext\", [text]);\n    } else if (/[0-9]/.test(group.text)) {\n      node = new mathMLTree.MathNode(\"mn\", [text]);\n    } else if (group.text === \"\\\\prime\") {\n      node = new mathMLTree.MathNode(\"mo\", [text]);\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", [text]);\n    }\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\n\nvar cssSpace = {\n  \"\\\\nobreak\": \"nobreak\",\n  \"\\\\allowbreak\": \"allowbreak\"\n}; // A lookup table to determine whether a spacing function/symbol should be\n// treated like a regular space character.  If a symbol or command is a key\n// in this table, then it should be a regular space character.  Furthermore,\n// the associated value may have a `className` specifying an extra CSS class\n// to add to the created `span`.\n\nvar regularSpace = {\n  \" \": {},\n  \"\\\\ \": {},\n  \"~\": {\n    className: \"nobreak\"\n  },\n  \"\\\\space\": {},\n  \"\\\\nobreakspace\": {\n    className: \"nobreak\"\n  }\n}; // ParseNode<\"spacing\"> created in Parser.js from the \"spacing\" symbol Groups in\n// src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"spacing\",\n\n  htmlBuilder(group, options) {\n    if (regularSpace.hasOwnProperty(group.text)) {\n      var className = regularSpace[group.text].className || \"\"; // Spaces are generated by adding an actual space. Each of these\n      // things has an entry in the symbols table, so these will be turned\n      // into appropriate outputs.\n\n      if (group.mode === \"text\") {\n        var ord = buildCommon.makeOrd(group, options, \"textord\");\n        ord.classes.push(className);\n        return ord;\n      } else {\n        return buildCommon.makeSpan([\"mspace\", className], [buildCommon.mathsym(group.text, group.mode, options)], options);\n      }\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // Spaces based on just a CSS class.\n      return buildCommon.makeSpan([\"mspace\", cssSpace[group.text]], [], options);\n    } else {\n      throw new ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    var node;\n\n    if (regularSpace.hasOwnProperty(group.text)) {\n      node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // CSS-based MathML spaces (\\nobreak, \\allowbreak) are ignored\n      return new mathMLTree.MathNode(\"mspace\");\n    } else {\n      throw new ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n\n    return node;\n  }\n\n});\n\nvar pad = () => {\n  var padNode = new mathMLTree.MathNode(\"mtd\", []);\n  padNode.setAttribute(\"width\", \"50%\");\n  return padNode;\n};\n\ndefineFunctionBuilders({\n  type: \"tag\",\n\n  mathmlBuilder(group, options) {\n    var table = new mathMLTree.MathNode(\"mtable\", [new mathMLTree.MathNode(\"mtr\", [pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.tag, options)])])]);\n    table.setAttribute(\"width\", \"100%\");\n    return table; // TODO: Left-aligned tags.\n    // Currently, the group and options passed here do not contain\n    // enough info to set tag alignment. `leqno` is in Settings but it is\n    // not passed to Options. On the HTML side, leqno is\n    // set by a CSS class applied in buildTree.js. That would have worked\n    // in MathML if browsers supported <mlabeledtr>. Since they don't, we\n    // need to rewrite the way this function is called.\n  }\n\n});\n\nvar textFontFamilies = {\n  \"\\\\text\": undefined,\n  \"\\\\textrm\": \"textrm\",\n  \"\\\\textsf\": \"textsf\",\n  \"\\\\texttt\": \"texttt\",\n  \"\\\\textnormal\": \"textrm\"\n};\nvar textFontWeights = {\n  \"\\\\textbf\": \"textbf\",\n  \"\\\\textmd\": \"textmd\"\n};\nvar textFontShapes = {\n  \"\\\\textit\": \"textit\",\n  \"\\\\textup\": \"textup\"\n};\n\nvar optionsWithFont = (group, options) => {\n  var font = group.font; // Checks if the argument is a font family or a font style.\n\n  if (!font) {\n    return options;\n  } else if (textFontFamilies[font]) {\n    return options.withTextFontFamily(textFontFamilies[font]);\n  } else if (textFontWeights[font]) {\n    return options.withTextFontWeight(textFontWeights[font]);\n  } else if (font === \"\\\\emph\") {\n    return options.fontShape === \"textit\" ? options.withTextFontShape(\"textup\") : options.withTextFontShape(\"textit\");\n  }\n\n  return options.withTextFontShape(textFontShapes[font]);\n};\n\ndefineFunction({\n  type: \"text\",\n  names: [// Font families\n  \"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\", // Font weights\n  \"\\\\textbf\", \"\\\\textmd\", // Font Shapes\n  \"\\\\textit\", \"\\\\textup\", \"\\\\emph\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInArgument: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"text\",\n      mode: parser.mode,\n      body: ordargument(body),\n      font: funcName\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    var inner = buildExpression$1(group.body, newOptions, true);\n    return buildCommon.makeSpan([\"mord\", \"text\"], inner, newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    return buildExpressionRow(group.body, newOptions);\n  }\n\n});\n\ndefineFunction({\n  type: \"underline\",\n  names: [\"\\\\underline\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"underline\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Underlines are handled in the TeXbook pg 443, Rule 10.\n    // Build the inner group.\n    var innerGroup = buildGroup$1(group.body, options); // Create the line to go below the body\n\n    var line = buildCommon.makeLineSpan(\"underline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"kern\",\n        size: defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"underline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"vcenter\",\n  names: [\"\\\\vcenter\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"original\"],\n    // In LaTeX, \\vcenter can act only on a box.\n    allowedInText: false\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"vcenter\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var body = buildGroup$1(group.body, options);\n    var axisHeight = options.fontMetrics().axisHeight;\n    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // There is no way to do this in MathML.\n    // Write a class as a breadcrumb in case some post-processor wants\n    // to perform a vcenter adjustment.\n    return new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)], [\"vcenter\"]);\n  }\n\n});\n\ndefineFunction({\n  type: \"verb\",\n  names: [\"\\\\verb\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(context, args, optArgs) {\n    // \\verb and \\verb* are dealt with directly in Parser.js.\n    // If we end up here, it's because of a failure to match the two delimiters\n    // in the regex in Lexer.js.  LaTeX raises the following error when \\verb is\n    // terminated by end of line (or file).\n    throw new ParseError(\"\\\\verb ended by end of line instead of matching delimiter\");\n  },\n\n  htmlBuilder(group, options) {\n    var text = makeVerb(group);\n    var body = []; // \\verb enters text mode and therefore is sized like \\textstyle\n\n    var newOptions = options.havingStyle(options.style.text());\n\n    for (var i = 0; i < text.length; i++) {\n      var c = text[i];\n\n      if (c === '~') {\n        c = '\\\\textasciitilde';\n      }\n\n      body.push(buildCommon.makeSymbol(c, \"Typewriter-Regular\", group.mode, newOptions, [\"mord\", \"texttt\"]));\n    }\n\n    return buildCommon.makeSpan([\"mord\", \"text\"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    var text = new mathMLTree.TextNode(makeVerb(group));\n    var node = new mathMLTree.MathNode(\"mtext\", [text]);\n    node.setAttribute(\"mathvariant\", \"monospace\");\n    return node;\n  }\n\n});\n/**\n * Converts verb group into body string.\n *\n * \\verb* replaces each space with an open box \\u2423\n * \\verb replaces each space with a no-break space \\xA0\n */\n\nvar makeVerb = group => group.body.replace(/ /g, group.star ? '\\u2423' : '\\xA0');\n\n/** Include this to ensure that all functions are defined. */\nvar functions = _functions;\n\n/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more whitespace characters\n * - matches a backslash followed by one or more letters then whitespace\n * - matches a backslash followed by any BMP character\n * Capturing groups:\n *   [1] regular whitespace\n *   [2] backslash followed by whitespace\n *   [3] anything else, which may include:\n *     [4] left character of \\verb*\n *     [5] left character of \\verb\n *     [6] backslash followed by word, excluding any trailing whitespace\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar spaceRegexString = \"[ \\r\\n\\t]\";\nvar controlWordRegexString = \"\\\\\\\\[a-zA-Z@]+\";\nvar controlSymbolRegexString = \"\\\\\\\\[^\\uD800-\\uDFFF]\";\nvar controlWordWhitespaceRegexString = \"(\" + controlWordRegexString + \")\" + spaceRegexString + \"*\";\nvar controlSpaceRegexString = \"\\\\\\\\(\\n|[ \\r\\t]+\\n?)[ \\r\\t]*\";\nvar combiningDiacriticalMarkString = \"[\\u0300-\\u036f]\";\nvar combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + \"+$\");\nvar tokenRegexString = \"(\" + spaceRegexString + \"+)|\" + ( // whitespace\ncontrolSpaceRegexString + \"|\") + // \\whitespace\n\"([!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" + ( // single codepoint\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" + ( // surrogate pair\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|\\\\\\\\verb\\\\*([^]).*?\\\\4\" + // \\verb*\n\"|\\\\\\\\verb([^*a-zA-Z]).*?\\\\5\" + ( // \\verb unstarred\n\"|\" + controlWordWhitespaceRegexString) + ( // \\macroName + spaces\n\"|\" + controlSymbolRegexString + \")\"); // \\\\, \\', etc.\n\n/** Main Lexer class */\n\nclass Lexer {\n  // Category codes. The lexer only supports comment characters (14) for now.\n  // MacroExpander additionally distinguishes active (13).\n  constructor(input, settings) {\n    this.input = void 0;\n    this.settings = void 0;\n    this.tokenRegex = void 0;\n    this.catcodes = void 0;\n    // Separate accents from characters\n    this.input = input;\n    this.settings = settings;\n    this.tokenRegex = new RegExp(tokenRegexString, 'g');\n    this.catcodes = {\n      \"%\": 14,\n      // comment character\n      \"~\": 13 // active character\n\n    };\n  }\n\n  setCatcode(char, code) {\n    this.catcodes[char] = code;\n  }\n  /**\n   * This function lexes a single token.\n   */\n\n\n  lex() {\n    var input = this.input;\n    var pos = this.tokenRegex.lastIndex;\n\n    if (pos === input.length) {\n      return new Token(\"EOF\", new SourceLocation(this, pos, pos));\n    }\n\n    var match = this.tokenRegex.exec(input);\n\n    if (match === null || match.index !== pos) {\n      throw new ParseError(\"Unexpected character: '\" + input[pos] + \"'\", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));\n    }\n\n    var text = match[6] || match[3] || (match[2] ? \"\\\\ \" : \" \");\n\n    if (this.catcodes[text] === 14) {\n      // comment character\n      var nlIndex = input.indexOf('\\n', this.tokenRegex.lastIndex);\n\n      if (nlIndex === -1) {\n        this.tokenRegex.lastIndex = input.length; // EOF\n\n        this.settings.reportNonstrict(\"commentAtEnd\", \"% comment has no terminating newline; LaTeX would \" + \"fail because of commenting the end of math mode (e.g. $)\");\n      } else {\n        this.tokenRegex.lastIndex = nlIndex + 1;\n      }\n\n      return this.lex();\n    }\n\n    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));\n  }\n\n}\n\n/**\n * A `Namespace` refers to a space of nameable things like macros or lengths,\n * which can be `set` either globally or local to a nested group, using an\n * undo stack similar to how TeX implements this functionality.\n * Performance-wise, `get` and local `set` take constant time, while global\n * `set` takes time proportional to the depth of group nesting.\n */\nclass Namespace {\n  /**\n   * Both arguments are optional.  The first argument is an object of\n   * built-in mappings which never change.  The second argument is an object\n   * of initial (global-level) mappings, which will constantly change\n   * according to any global/top-level `set`s done.\n   */\n  constructor(builtins, globalMacros) {\n    if (builtins === void 0) {\n      builtins = {};\n    }\n\n    if (globalMacros === void 0) {\n      globalMacros = {};\n    }\n\n    this.current = void 0;\n    this.builtins = void 0;\n    this.undefStack = void 0;\n    this.current = globalMacros;\n    this.builtins = builtins;\n    this.undefStack = [];\n  }\n  /**\n   * Start a new nested group, affecting future local `set`s.\n   */\n\n\n  beginGroup() {\n    this.undefStack.push({});\n  }\n  /**\n   * End current nested group, restoring values before the group began.\n   */\n\n\n  endGroup() {\n    if (this.undefStack.length === 0) {\n      throw new ParseError(\"Unbalanced namespace destruction: attempt \" + \"to pop global namespace; please report this as a bug\");\n    }\n\n    var undefs = this.undefStack.pop();\n\n    for (var undef in undefs) {\n      if (undefs.hasOwnProperty(undef)) {\n        if (undefs[undef] == null) {\n          delete this.current[undef];\n        } else {\n          this.current[undef] = undefs[undef];\n        }\n      }\n    }\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    while (this.undefStack.length > 0) {\n      this.endGroup();\n    }\n  }\n  /**\n   * Detect whether `name` has a definition.  Equivalent to\n   * `get(name) != null`.\n   */\n\n\n  has(name) {\n    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);\n  }\n  /**\n   * Get the current value of a name, or `undefined` if there is no value.\n   *\n   * Note: Do not use `if (namespace.get(...))` to detect whether a macro\n   * is defined, as the definition may be the empty string which evaluates\n   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or\n   * `if (namespace.has(...))`.\n   */\n\n\n  get(name) {\n    if (this.current.hasOwnProperty(name)) {\n      return this.current[name];\n    } else {\n      return this.builtins[name];\n    }\n  }\n  /**\n   * Set the current value of a name, and optionally set it globally too.\n   * Local set() sets the current value and (when appropriate) adds an undo\n   * operation to the undo stack.  Global set() may change the undo\n   * operation at every level, so takes time linear in their number.\n   * A value of undefined means to delete existing definitions.\n   */\n\n\n  set(name, value, global) {\n    if (global === void 0) {\n      global = false;\n    }\n\n    if (global) {\n      // Global set is equivalent to setting in all groups.  Simulate this\n      // by destroying any undos currently scheduled for this name,\n      // and adding an undo with the *new* value (in case it later gets\n      // locally reset within this environment).\n      for (var i = 0; i < this.undefStack.length; i++) {\n        delete this.undefStack[i][name];\n      }\n\n      if (this.undefStack.length > 0) {\n        this.undefStack[this.undefStack.length - 1][name] = value;\n      }\n    } else {\n      // Undo this set at end of this group (possibly to `undefined`),\n      // unless an undo is already in place, in which case that older\n      // value is the correct one.\n      var top = this.undefStack[this.undefStack.length - 1];\n\n      if (top && !top.hasOwnProperty(name)) {\n        top[name] = this.current[name];\n      }\n    }\n\n    if (value == null) {\n      delete this.current[name];\n    } else {\n      this.current[name] = value;\n    }\n  }\n\n}\n\n/**\n * Predefined macros for KaTeX.\n * This can be used to define some commands in terms of others.\n */\nvar macros = _macros;\n// macro tools\n\ndefineMacro(\"\\\\noexpand\", function (context) {\n  // The expansion is the token itself; but that token is interpreted\n  // as if its meaning were \\relax if it is a control sequence that\n  // would ordinarily be expanded by TeXs expansion rules.\n  var t = context.popToken();\n\n  if (context.isExpandable(t.text)) {\n    t.noexpand = true;\n    t.treatAsRelax = true;\n  }\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n});\ndefineMacro(\"\\\\expandafter\", function (context) {\n  // TeX first reads the token that comes immediately after \\expandafter,\n  // without expanding it; lets call this token t. Then TeX reads the\n  // token that comes after t (and possibly more tokens, if that token\n  // has an argument), replacing it by its expansion. Finally TeX puts\n  // t back in front of that expansion.\n  var t = context.popToken();\n  context.expandOnce(true); // expand only an expandable token\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n}); // LaTeX's \\@firstoftwo{#1}{#2} expands to #1, skipping #2\n// TeX source: \\long\\def\\@firstoftwo#1#2{#1}\n\ndefineMacro(\"\\\\@firstoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[0],\n    numArgs: 0\n  };\n}); // LaTeX's \\@secondoftwo{#1}{#2} expands to #2, skipping #1\n// TeX source: \\long\\def\\@secondoftwo#1#2{#2}\n\ndefineMacro(\"\\\\@secondoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[1],\n    numArgs: 0\n  };\n}); // LaTeX's \\@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)\n// symbol that isn't a space, consuming any spaces but not consuming the\n// first nonspace character.  If that nonspace character matches #1, then\n// the macro expands to #2; otherwise, it expands to #3.\n\ndefineMacro(\"\\\\@ifnextchar\", function (context) {\n  var args = context.consumeArgs(3); // symbol, if, else\n\n  context.consumeSpaces();\n  var nextToken = context.future();\n\n  if (args[0].length === 1 && args[0][0].text === nextToken.text) {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[2],\n      numArgs: 0\n    };\n  }\n}); // LaTeX's \\@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.\n// If it is `*`, then it consumes the symbol, and the macro expands to #1;\n// otherwise, the macro expands to #2 (without consuming the symbol).\n// TeX source: \\def\\@ifstar#1{\\@ifnextchar *{\\@firstoftwo{#1}}}\n\ndefineMacro(\"\\\\@ifstar\", \"\\\\@ifnextchar *{\\\\@firstoftwo{#1}}\"); // LaTeX's \\TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode\n\ndefineMacro(\"\\\\TextOrMath\", function (context) {\n  var args = context.consumeArgs(2);\n\n  if (context.mode === 'text') {\n    return {\n      tokens: args[0],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  }\n}); // Lookup table for parsing numbers in base 8 through 16\n\nvar digitToNumber = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"a\": 10,\n  \"A\": 10,\n  \"b\": 11,\n  \"B\": 11,\n  \"c\": 12,\n  \"C\": 12,\n  \"d\": 13,\n  \"D\": 13,\n  \"e\": 14,\n  \"E\": 14,\n  \"f\": 15,\n  \"F\": 15\n}; // TeX \\char makes a literal character (catcode 12) using the following forms:\n// (see The TeXBook, p. 43)\n//   \\char123  -- decimal\n//   \\char'123 -- octal\n//   \\char\"123 -- hex\n//   \\char`x   -- character that can be written (i.e. isn't active)\n//   \\char`\\x  -- character that cannot be written (e.g. %)\n// These all refer to characters from the font, so we turn them into special\n// calls to a function \\@char dealt with in the Parser.\n\ndefineMacro(\"\\\\char\", function (context) {\n  var token = context.popToken();\n  var base;\n  var number = '';\n\n  if (token.text === \"'\") {\n    base = 8;\n    token = context.popToken();\n  } else if (token.text === '\"') {\n    base = 16;\n    token = context.popToken();\n  } else if (token.text === \"`\") {\n    token = context.popToken();\n\n    if (token.text[0] === \"\\\\\") {\n      number = token.text.charCodeAt(1);\n    } else if (token.text === \"EOF\") {\n      throw new ParseError(\"\\\\char` missing argument\");\n    } else {\n      number = token.text.charCodeAt(0);\n    }\n  } else {\n    base = 10;\n  }\n\n  if (base) {\n    // Parse a number in the given base, starting with first `token`.\n    number = digitToNumber[token.text];\n\n    if (number == null || number >= base) {\n      throw new ParseError(\"Invalid base-\" + base + \" digit \" + token.text);\n    }\n\n    var digit;\n\n    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {\n      number *= base;\n      number += digit;\n      context.popToken();\n    }\n  }\n\n  return \"\\\\@char{\" + number + \"}\";\n}); // \\newcommand{\\macro}[args]{definition}\n// \\renewcommand{\\macro}[args]{definition}\n// TODO: Optional arguments: \\newcommand{\\macro}[args][default]{definition}\n\nvar newcommand = (context, existsOK, nonexistsOK) => {\n  var arg = context.consumeArg().tokens;\n\n  if (arg.length !== 1) {\n    throw new ParseError(\"\\\\newcommand's first argument must be a macro name\");\n  }\n\n  var name = arg[0].text;\n  var exists = context.isDefined(name);\n\n  if (exists && !existsOK) {\n    throw new ParseError(\"\\\\newcommand{\" + name + \"} attempting to redefine \" + (name + \"; use \\\\renewcommand\"));\n  }\n\n  if (!exists && !nonexistsOK) {\n    throw new ParseError(\"\\\\renewcommand{\" + name + \"} when command \" + name + \" \" + \"does not yet exist; use \\\\newcommand\");\n  }\n\n  var numArgs = 0;\n  arg = context.consumeArg().tokens;\n\n  if (arg.length === 1 && arg[0].text === \"[\") {\n    var argText = '';\n    var token = context.expandNextToken();\n\n    while (token.text !== \"]\" && token.text !== \"EOF\") {\n      // TODO: Should properly expand arg, e.g., ignore {}s\n      argText += token.text;\n      token = context.expandNextToken();\n    }\n\n    if (!argText.match(/^\\s*[0-9]+\\s*$/)) {\n      throw new ParseError(\"Invalid number of arguments: \" + argText);\n    }\n\n    numArgs = parseInt(argText);\n    arg = context.consumeArg().tokens;\n  } // Final arg is the expansion of the macro\n\n\n  context.macros.set(name, {\n    tokens: arg,\n    numArgs\n  });\n  return '';\n};\n\ndefineMacro(\"\\\\newcommand\", context => newcommand(context, false, true));\ndefineMacro(\"\\\\renewcommand\", context => newcommand(context, true, false));\ndefineMacro(\"\\\\providecommand\", context => newcommand(context, true, true)); // terminal (console) tools\n\ndefineMacro(\"\\\\message\", context => {\n  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.log(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\errmessage\", context => {\n  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.error(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\show\", context => {\n  var tok = context.popToken();\n  var name = tok.text; // eslint-disable-next-line no-console\n\n  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);\n  return '';\n}); //////////////////////////////////////////////////////////////////////\n// Grouping\n// \\let\\bgroup={ \\let\\egroup=}\n\ndefineMacro(\"\\\\bgroup\", \"{\");\ndefineMacro(\"\\\\egroup\", \"}\"); // Symbols from latex.ltx:\n// \\def~{\\nobreakspace{}}\n// \\def\\lq{`}\n// \\def\\rq{'}\n// \\def \\aa {\\r a}\n// \\def \\AA {\\r A}\n\ndefineMacro(\"~\", \"\\\\nobreakspace\");\ndefineMacro(\"\\\\lq\", \"`\");\ndefineMacro(\"\\\\rq\", \"'\");\ndefineMacro(\"\\\\aa\", \"\\\\r a\");\ndefineMacro(\"\\\\AA\", \"\\\\r A\"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.\n// \\DeclareTextCommandDefault{\\textcopyright}{\\textcircled{c}}\n// \\DeclareTextCommandDefault{\\textregistered}{\\textcircled{%\n//      \\check@mathfonts\\fontsize\\sf@size\\z@\\math@fontsfalse\\selectfont R}}\n// \\DeclareRobustCommand{\\copyright}{%\n//    \\ifmmode{\\nfss@text{\\textcopyright}}\\else\\textcopyright\\fi}\n\ndefineMacro(\"\\\\textcopyright\", \"\\\\html@mathml{\\\\textcircled{c}}{\\\\char`}\");\ndefineMacro(\"\\\\copyright\", \"\\\\TextOrMath{\\\\textcopyright}{\\\\text{\\\\textcopyright}}\");\ndefineMacro(\"\\\\textregistered\", \"\\\\html@mathml{\\\\textcircled{\\\\scriptsize R}}{\\\\char`}\"); // Characters omitted from Unicode range 1D4001D7FF\n\ndefineMacro(\"\\u212C\", \"\\\\mathscr{B}\"); // script\n\ndefineMacro(\"\\u2130\", \"\\\\mathscr{E}\");\ndefineMacro(\"\\u2131\", \"\\\\mathscr{F}\");\ndefineMacro(\"\\u210B\", \"\\\\mathscr{H}\");\ndefineMacro(\"\\u2110\", \"\\\\mathscr{I}\");\ndefineMacro(\"\\u2112\", \"\\\\mathscr{L}\");\ndefineMacro(\"\\u2133\", \"\\\\mathscr{M}\");\ndefineMacro(\"\\u211B\", \"\\\\mathscr{R}\");\ndefineMacro(\"\\u212D\", \"\\\\mathfrak{C}\"); // Fraktur\n\ndefineMacro(\"\\u210C\", \"\\\\mathfrak{H}\");\ndefineMacro(\"\\u2128\", \"\\\\mathfrak{Z}\"); // Define \\Bbbk with a macro that works in both HTML and MathML.\n\ndefineMacro(\"\\\\Bbbk\", \"\\\\Bbb{k}\"); // Unicode middle dot\n// The KaTeX fonts do not contain U+00B7. Instead, \\cdotp displays\n// the dot at U+22C5 and gives it punct spacing.\n\ndefineMacro(\"\\u00b7\", \"\\\\cdotp\"); // \\llap and \\rlap render their contents in text mode\n\ndefineMacro(\"\\\\llap\", \"\\\\mathllap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\rlap\", \"\\\\mathrlap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\clap\", \"\\\\mathclap{\\\\textrm{#1}}\"); // \\mathstrut from the TeXbook, p 360\n\ndefineMacro(\"\\\\mathstrut\", \"\\\\vphantom{(}\"); // \\underbar from TeXbook p 353\n\ndefineMacro(\"\\\\underbar\", \"\\\\underline{\\\\text{#1}}\"); // \\not is defined by base/fontmath.ltx via\n// \\DeclareMathSymbol{\\not}{\\mathrel}{symbols}{\"36}\n// It's thus treated like a \\mathrel, but defined by a symbol that has zero\n// width but extends to the right.  We use \\rlap to get that spacing.\n// For MathML we write U+0338 here. buildMathML.js will then do the overlay.\n\ndefineMacro(\"\\\\not\", '\\\\html@mathml{\\\\mathrel{\\\\mathrlap\\\\@not}}{\\\\char\"338}'); // Negated symbols from base/fontmath.ltx:\n// \\def\\neq{\\not=} \\let\\ne=\\neq\n// \\DeclareRobustCommand\n//   \\notin{\\mathrel{\\m@th\\mathpalette\\c@ncel\\in}}\n// \\def\\c@ncel#1#2{\\m@th\\ooalign{$\\hfil#1\\mkern1mu/\\hfil$\\crcr$#1#2$}}\n\ndefineMacro(\"\\\\neq\", \"\\\\html@mathml{\\\\mathrel{\\\\not=}}{\\\\mathrel{\\\\char`}}\");\ndefineMacro(\"\\\\ne\", \"\\\\neq\");\ndefineMacro(\"\\u2260\", \"\\\\neq\");\ndefineMacro(\"\\\\notin\", \"\\\\html@mathml{\\\\mathrel{{\\\\in}\\\\mathllap{/\\\\mskip1mu}}}\" + \"{\\\\mathrel{\\\\char`}}\");\ndefineMacro(\"\\u2209\", \"\\\\notin\"); // Unicode stacked relations\n\ndefineMacro(\"\\u2258\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\kern{-1em}\\\\raisebox{0.4em}{$\\\\scriptsize\\\\frown$}}\" + \"}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u2259\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\wedge}{=}}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u225A\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\vee}{=}}{\\\\mathrel{\\\\char`\\u225A}}\");\ndefineMacro(\"\\u225B\", \"\\\\html@mathml{\\\\stackrel{\\\\scriptsize\\\\star}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225B}}\");\ndefineMacro(\"\\u225D\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{def}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225D}}\");\ndefineMacro(\"\\u225E\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{m}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225E}}\");\ndefineMacro(\"\\u225F\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny?}{=}}{\\\\mathrel{\\\\char`\\u225F}}\"); // Misc Unicode\n\ndefineMacro(\"\\u27C2\", \"\\\\perp\");\ndefineMacro(\"\\u203C\", \"\\\\mathclose{!\\\\mkern-0.8mu!}\");\ndefineMacro(\"\\u220C\", \"\\\\notni\");\ndefineMacro(\"\\u231C\", \"\\\\ulcorner\");\ndefineMacro(\"\\u231D\", \"\\\\urcorner\");\ndefineMacro(\"\\u231E\", \"\\\\llcorner\");\ndefineMacro(\"\\u231F\", \"\\\\lrcorner\");\ndefineMacro(\"\\u00A9\", \"\\\\copyright\");\ndefineMacro(\"\\u00AE\", \"\\\\textregistered\");\ndefineMacro(\"\\uFE0F\", \"\\\\textregistered\"); // The KaTeX fonts have corners at codepoints that don't match Unicode.\n// For MathML purposes, use the Unicode code point.\n\ndefineMacro(\"\\\\ulcorner\", \"\\\\html@mathml{\\\\@ulcorner}{\\\\mathop{\\\\char\\\"231c}}\");\ndefineMacro(\"\\\\urcorner\", \"\\\\html@mathml{\\\\@urcorner}{\\\\mathop{\\\\char\\\"231d}}\");\ndefineMacro(\"\\\\llcorner\", \"\\\\html@mathml{\\\\@llcorner}{\\\\mathop{\\\\char\\\"231e}}\");\ndefineMacro(\"\\\\lrcorner\", \"\\\\html@mathml{\\\\@lrcorner}{\\\\mathop{\\\\char\\\"231f}}\"); //////////////////////////////////////////////////////////////////////\n// LaTeX_2\n// \\vdots{\\vbox{\\baselineskip4\\p@  \\lineskiplimit\\z@\n// \\kern6\\p@\\hbox{.}\\hbox{.}\\hbox{.}}}\n// We'll call \\varvdots, which gets a glyph from symbols.js.\n// The zero-width rule gets us an equivalent to the vertical 6pt kern.\n\ndefineMacro(\"\\\\vdots\", \"\\\\mathord{\\\\varvdots\\\\rule{0pt}{15pt}}\");\ndefineMacro(\"\\u22ee\", \"\\\\vdots\"); //////////////////////////////////////////////////////////////////////\n// amsmath.sty\n// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf\n// Italic Greek capital letters.  AMS defines these with \\DeclareMathSymbol,\n// but they are equivalent to \\mathit{\\Letter}.\n\ndefineMacro(\"\\\\varGamma\", \"\\\\mathit{\\\\Gamma}\");\ndefineMacro(\"\\\\varDelta\", \"\\\\mathit{\\\\Delta}\");\ndefineMacro(\"\\\\varTheta\", \"\\\\mathit{\\\\Theta}\");\ndefineMacro(\"\\\\varLambda\", \"\\\\mathit{\\\\Lambda}\");\ndefineMacro(\"\\\\varXi\", \"\\\\mathit{\\\\Xi}\");\ndefineMacro(\"\\\\varPi\", \"\\\\mathit{\\\\Pi}\");\ndefineMacro(\"\\\\varSigma\", \"\\\\mathit{\\\\Sigma}\");\ndefineMacro(\"\\\\varUpsilon\", \"\\\\mathit{\\\\Upsilon}\");\ndefineMacro(\"\\\\varPhi\", \"\\\\mathit{\\\\Phi}\");\ndefineMacro(\"\\\\varPsi\", \"\\\\mathit{\\\\Psi}\");\ndefineMacro(\"\\\\varOmega\", \"\\\\mathit{\\\\Omega}\"); //\\newcommand{\\substack}[1]{\\subarray{c}#1\\endsubarray}\n\ndefineMacro(\"\\\\substack\", \"\\\\begin{subarray}{c}#1\\\\end{subarray}\"); // \\renewcommand{\\colon}{\\nobreak\\mskip2mu\\mathpunct{}\\nonscript\n// \\mkern-\\thinmuskip{:}\\mskip6muplus1mu\\relax}\n\ndefineMacro(\"\\\\colon\", \"\\\\nobreak\\\\mskip2mu\\\\mathpunct{}\" + \"\\\\mathchoice{\\\\mkern-3mu}{\\\\mkern-3mu}{}{}{:}\\\\mskip6mu\\\\relax\"); // \\newcommand{\\boxed}[1]{\\fbox{\\m@th$\\displaystyle#1$}}\n\ndefineMacro(\"\\\\boxed\", \"\\\\fbox{$\\\\displaystyle{#1}$}\"); // \\def\\iff{\\DOTSB\\;\\Longleftrightarrow\\;}\n// \\def\\implies{\\DOTSB\\;\\Longrightarrow\\;}\n// \\def\\impliedby{\\DOTSB\\;\\Longleftarrow\\;}\n\ndefineMacro(\"\\\\iff\", \"\\\\DOTSB\\\\;\\\\Longleftrightarrow\\\\;\");\ndefineMacro(\"\\\\implies\", \"\\\\DOTSB\\\\;\\\\Longrightarrow\\\\;\");\ndefineMacro(\"\\\\impliedby\", \"\\\\DOTSB\\\\;\\\\Longleftarrow\\\\;\"); // AMSMath's automatic \\dots, based on \\mdots@@ macro.\n\nvar dotsByToken = {\n  ',': '\\\\dotsc',\n  '\\\\not': '\\\\dotsb',\n  // \\keybin@ checks for the following:\n  '+': '\\\\dotsb',\n  '=': '\\\\dotsb',\n  '<': '\\\\dotsb',\n  '>': '\\\\dotsb',\n  '-': '\\\\dotsb',\n  '*': '\\\\dotsb',\n  ':': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSB:\n  '\\\\DOTSB': '\\\\dotsb',\n  '\\\\coprod': '\\\\dotsb',\n  '\\\\bigvee': '\\\\dotsb',\n  '\\\\bigwedge': '\\\\dotsb',\n  '\\\\biguplus': '\\\\dotsb',\n  '\\\\bigcap': '\\\\dotsb',\n  '\\\\bigcup': '\\\\dotsb',\n  '\\\\prod': '\\\\dotsb',\n  '\\\\sum': '\\\\dotsb',\n  '\\\\bigotimes': '\\\\dotsb',\n  '\\\\bigoplus': '\\\\dotsb',\n  '\\\\bigodot': '\\\\dotsb',\n  '\\\\bigsqcup': '\\\\dotsb',\n  '\\\\And': '\\\\dotsb',\n  '\\\\longrightarrow': '\\\\dotsb',\n  '\\\\Longrightarrow': '\\\\dotsb',\n  '\\\\longleftarrow': '\\\\dotsb',\n  '\\\\Longleftarrow': '\\\\dotsb',\n  '\\\\longleftrightarrow': '\\\\dotsb',\n  '\\\\Longleftrightarrow': '\\\\dotsb',\n  '\\\\mapsto': '\\\\dotsb',\n  '\\\\longmapsto': '\\\\dotsb',\n  '\\\\hookrightarrow': '\\\\dotsb',\n  '\\\\doteq': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathbin:\n  '\\\\mathbin': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathrel:\n  '\\\\mathrel': '\\\\dotsb',\n  '\\\\relbar': '\\\\dotsb',\n  '\\\\Relbar': '\\\\dotsb',\n  '\\\\xrightarrow': '\\\\dotsb',\n  '\\\\xleftarrow': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSI:\n  '\\\\DOTSI': '\\\\dotsi',\n  '\\\\int': '\\\\dotsi',\n  '\\\\oint': '\\\\dotsi',\n  '\\\\iint': '\\\\dotsi',\n  '\\\\iiint': '\\\\dotsi',\n  '\\\\iiiint': '\\\\dotsi',\n  '\\\\idotsint': '\\\\dotsi',\n  // Symbols whose definition starts with \\DOTSX:\n  '\\\\DOTSX': '\\\\dotsx'\n};\ndefineMacro(\"\\\\dots\", function (context) {\n  // TODO: If used in text mode, should expand to \\textellipsis.\n  // However, in KaTeX, \\textellipsis and \\ldots behave the same\n  // (in text mode), and it's unlikely we'd see any of the math commands\n  // that affect the behavior of \\dots when in text mode.  So fine for now\n  // (until we support \\ifmmode ... \\else ... \\fi).\n  var thedots = '\\\\dotso';\n  var next = context.expandAfterFuture().text;\n\n  if (next in dotsByToken) {\n    thedots = dotsByToken[next];\n  } else if (next.slice(0, 4) === '\\\\not') {\n    thedots = '\\\\dotsb';\n  } else if (next in symbols.math) {\n    if (utils.contains(['bin', 'rel'], symbols.math[next].group)) {\n      thedots = '\\\\dotsb';\n    }\n  }\n\n  return thedots;\n});\nvar spaceAfterDots = {\n  // \\rightdelim@ checks for the following:\n  ')': true,\n  ']': true,\n  '\\\\rbrack': true,\n  '\\\\}': true,\n  '\\\\rbrace': true,\n  '\\\\rangle': true,\n  '\\\\rceil': true,\n  '\\\\rfloor': true,\n  '\\\\rgroup': true,\n  '\\\\rmoustache': true,\n  '\\\\right': true,\n  '\\\\bigr': true,\n  '\\\\biggr': true,\n  '\\\\Bigr': true,\n  '\\\\Biggr': true,\n  // \\extra@ also tests for the following:\n  '$': true,\n  // \\extrap@ checks for the following:\n  ';': true,\n  '.': true,\n  ',': true\n};\ndefineMacro(\"\\\\dotso\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\dotsc\", function (context) {\n  var next = context.future().text; // \\dotsc uses \\extra@ but not \\extrap@, instead specially checking for\n  // ';' and '.', but doesn't check for ','.\n\n  if (next in spaceAfterDots && next !== ',') {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\cdots\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\@cdots\\\\,\";\n  } else {\n    return \"\\\\@cdots\";\n  }\n});\ndefineMacro(\"\\\\dotsb\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsm\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsi\", \"\\\\!\\\\cdots\"); // amsmath doesn't actually define \\dotsx, but \\dots followed by a macro\n// starting with \\DOTSX implies \\dotso, and then \\extra@ detects this case\n// and forces the added `\\,`.\n\ndefineMacro(\"\\\\dotsx\", \"\\\\ldots\\\\,\"); // \\let\\DOTSI\\relax\n// \\let\\DOTSB\\relax\n// \\let\\DOTSX\\relax\n\ndefineMacro(\"\\\\DOTSI\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSB\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSX\", \"\\\\relax\"); // Spacing, based on amsmath.sty's override of LaTeX defaults\n// \\DeclareRobustCommand{\\tmspace}[3]{%\n//   \\ifmmode\\mskip#1#2\\else\\kern#1#3\\fi\\relax}\n\ndefineMacro(\"\\\\tmspace\", \"\\\\TextOrMath{\\\\kern#1#3}{\\\\mskip#1#2}\\\\relax\"); // \\renewcommand{\\,}{\\tmspace+\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\,\", \"\\\\tmspace+{3mu}{.1667em}\"); // \\let\\thinspace\\,\n\ndefineMacro(\"\\\\thinspace\", \"\\\\,\"); // \\def\\>{\\mskip\\medmuskip}\n// \\renewcommand{\\:}{\\tmspace+\\medmuskip{.2222em}}\n// TODO: \\> and math mode of \\: should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\>\", \"\\\\mskip{4mu}\");\ndefineMacro(\"\\\\:\", \"\\\\tmspace+{4mu}{.2222em}\"); // \\let\\medspace\\:\n\ndefineMacro(\"\\\\medspace\", \"\\\\:\"); // \\renewcommand{\\;}{\\tmspace+\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip = 5mu plus 5mu\n\ndefineMacro(\"\\\\;\", \"\\\\tmspace+{5mu}{.2777em}\"); // \\let\\thickspace\\;\n\ndefineMacro(\"\\\\thickspace\", \"\\\\;\"); // \\renewcommand{\\!}{\\tmspace-\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\!\", \"\\\\tmspace-{3mu}{.1667em}\"); // \\let\\negthinspace\\!\n\ndefineMacro(\"\\\\negthinspace\", \"\\\\!\"); // \\newcommand{\\negmedspace}{\\tmspace-\\medmuskip{.2222em}}\n// TODO: math mode should use \\medmuskip\n\ndefineMacro(\"\\\\negmedspace\", \"\\\\tmspace-{4mu}{.2222em}\"); // \\newcommand{\\negthickspace}{\\tmspace-\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip\n\ndefineMacro(\"\\\\negthickspace\", \"\\\\tmspace-{5mu}{.277em}\"); // \\def\\enspace{\\kern.5em }\n\ndefineMacro(\"\\\\enspace\", \"\\\\kern.5em \"); // \\def\\enskip{\\hskip.5em\\relax}\n\ndefineMacro(\"\\\\enskip\", \"\\\\hskip.5em\\\\relax\"); // \\def\\quad{\\hskip1em\\relax}\n\ndefineMacro(\"\\\\quad\", \"\\\\hskip1em\\\\relax\"); // \\def\\qquad{\\hskip2em\\relax}\n\ndefineMacro(\"\\\\qquad\", \"\\\\hskip2em\\\\relax\"); // \\tag@in@display form of \\tag\n\ndefineMacro(\"\\\\tag\", \"\\\\@ifstar\\\\tag@literal\\\\tag@paren\");\ndefineMacro(\"\\\\tag@paren\", \"\\\\tag@literal{({#1})}\");\ndefineMacro(\"\\\\tag@literal\", context => {\n  if (context.macros.get(\"\\\\df@tag\")) {\n    throw new ParseError(\"Multiple \\\\tag\");\n  }\n\n  return \"\\\\gdef\\\\df@tag{\\\\text{#1}}\";\n}); // \\renewcommand{\\bmod}{\\nonscript\\mskip-\\medmuskip\\mkern5mu\\mathbin\n//   {\\operator@font mod}\\penalty900\n//   \\mkern5mu\\nonscript\\mskip-\\medmuskip}\n// \\newcommand{\\pod}[1]{\\allowbreak\n//   \\if@display\\mkern18mu\\else\\mkern8mu\\fi(#1)}\n// \\renewcommand{\\pmod}[1]{\\pod{{\\operator@font mod}\\mkern6mu#1}}\n// \\newcommand{\\mod}[1]{\\allowbreak\\if@display\\mkern18mu\n//   \\else\\mkern12mu\\fi{\\operator@font mod}\\,\\,#1}\n// TODO: math mode should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\bmod\", \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\" + \"\\\\mathbin{\\\\rm mod}\" + \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\");\ndefineMacro(\"\\\\pod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern8mu}{\\\\mkern8mu}{\\\\mkern8mu}(#1)\");\ndefineMacro(\"\\\\pmod\", \"\\\\pod{{\\\\rm mod}\\\\mkern6mu#1}\");\ndefineMacro(\"\\\\mod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern12mu}{\\\\mkern12mu}{\\\\mkern12mu}\" + \"{\\\\rm mod}\\\\,\\\\,#1\"); //////////////////////////////////////////////////////////////////////\n// LaTeX source2e\n// \\expandafter\\let\\expandafter\\@normalcr\n//     \\csname\\expandafter\\@gobble\\string\\\\ \\endcsname\n// \\DeclareRobustCommand\\newline{\\@normalcr\\relax}\n\ndefineMacro(\"\\\\newline\", \"\\\\\\\\\\\\relax\"); // \\def\\TeX{T\\kern-.1667em\\lower.5ex\\hbox{E}\\kern-.125emX\\@}\n// TODO: Doesn't normally work in math mode because \\@ fails.  KaTeX doesn't\n// support \\@ yet, so that's omitted, and we add \\text so that the result\n// doesn't look funny in math mode.\n\ndefineMacro(\"\\\\TeX\", \"\\\\textrm{\\\\html@mathml{\" + \"T\\\\kern-.1667em\\\\raisebox{-.5ex}{E}\\\\kern-.125emX\" + \"}{TeX}}\"); // \\DeclareRobustCommand{\\LaTeX}{L\\kern-.36em%\n//         {\\sbox\\z@ T%\n//          \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts\n//                               \\fontsize\\sf@size\\z@\n//                               \\math@fontsfalse\\selectfont\n//                               A}%\n//                         \\vss}%\n//         }%\n//         \\kern-.15em%\n//         \\TeX}\n// This code aligns the top of the A with the T (from the perspective of TeX's\n// boxes, though visually the A appears to extend above slightly).\n// We compute the corresponding \\raisebox when A is rendered in \\normalsize\n// \\scriptstyle, which has a scale factor of 0.7 (see Options.js).\n\nvar latexRaiseA = makeEm(fontMetricsData['Main-Regular'][\"T\".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular'][\"A\".charCodeAt(0)][1]);\ndefineMacro(\"\\\\LaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"L\\\\kern-.36em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{LaTeX}}\"); // New KaTeX logo based on tweaking LaTeX logo\n\ndefineMacro(\"\\\\KaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"K\\\\kern-.17em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{KaTeX}}\"); // \\DeclareRobustCommand\\hspace{\\@ifstar\\@hspacer\\@hspace}\n// \\def\\@hspace#1{\\hskip  #1\\relax}\n// \\def\\@hspacer#1{\\vrule \\@width\\z@\\nobreak\n//                 \\hskip #1\\hskip \\z@skip}\n\ndefineMacro(\"\\\\hspace\", \"\\\\@ifstar\\\\@hspacer\\\\@hspace\");\ndefineMacro(\"\\\\@hspace\", \"\\\\hskip #1\\\\relax\");\ndefineMacro(\"\\\\@hspacer\", \"\\\\rule{0pt}{0pt}\\\\hskip #1\\\\relax\"); //////////////////////////////////////////////////////////////////////\n// mathtools.sty\n//\\providecommand\\ordinarycolon{:}\n\ndefineMacro(\"\\\\ordinarycolon\", \":\"); //\\def\\vcentcolon{\\mathrel{\\mathop\\ordinarycolon}}\n//TODO(edemaine): Not yet centered. Fix via \\raisebox or #726\n\ndefineMacro(\"\\\\vcentcolon\", \"\\\\mathrel{\\\\mathop\\\\ordinarycolon}\"); // \\providecommand*\\dblcolon{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}\n\ndefineMacro(\"\\\\dblcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-.9mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2237}}\"); // \\providecommand*\\coloneqq{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2254}}\"); // \n// \\providecommand*\\Coloneqq{\\dblcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\Coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"3d}}\"); // \\providecommand*\\coloneq{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2212}}\"); // \\providecommand*\\Coloneq{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\Coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2212}}\"); // \\providecommand*\\eqqcolon{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2255}}\"); // \n// \\providecommand*\\Eqqcolon{=\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"3d\\\\char\\\"2237}}\"); // \\providecommand*\\eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2239}}\"); // \\providecommand*\\Eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"2212\\\\char\\\"2237}}\"); // \\providecommand*\\colonapprox{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2248}}\"); // \\providecommand*\\Colonapprox{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\Colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2248}}\"); // \\providecommand*\\colonsim{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"223c}}\"); // \\providecommand*\\Colonsim{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\Colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"223c}}\"); // Some Unicode characters are implemented with macros to mathtools functions.\n\ndefineMacro(\"\\u2237\", \"\\\\dblcolon\"); // ::\n\ndefineMacro(\"\\u2239\", \"\\\\eqcolon\"); // -:\n\ndefineMacro(\"\\u2254\", \"\\\\coloneqq\"); // :=\n\ndefineMacro(\"\\u2255\", \"\\\\eqqcolon\"); // =:\n\ndefineMacro(\"\\u2A74\", \"\\\\Coloneqq\"); // ::=\n//////////////////////////////////////////////////////////////////////\n// colonequals.sty\n// Alternate names for mathtools's macros:\n\ndefineMacro(\"\\\\ratio\", \"\\\\vcentcolon\");\ndefineMacro(\"\\\\coloncolon\", \"\\\\dblcolon\");\ndefineMacro(\"\\\\colonequals\", \"\\\\coloneqq\");\ndefineMacro(\"\\\\coloncolonequals\", \"\\\\Coloneqq\");\ndefineMacro(\"\\\\equalscolon\", \"\\\\eqqcolon\");\ndefineMacro(\"\\\\equalscoloncolon\", \"\\\\Eqqcolon\");\ndefineMacro(\"\\\\colonminus\", \"\\\\coloneq\");\ndefineMacro(\"\\\\coloncolonminus\", \"\\\\Coloneq\");\ndefineMacro(\"\\\\minuscolon\", \"\\\\eqcolon\");\ndefineMacro(\"\\\\minuscoloncolon\", \"\\\\Eqcolon\"); // \\colonapprox name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonapprox\", \"\\\\Colonapprox\"); // \\colonsim name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonsim\", \"\\\\Colonsim\"); // Additional macros, implemented by analogy with mathtools definitions:\n\ndefineMacro(\"\\\\simcolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\simcoloncolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\");\ndefineMacro(\"\\\\approxcolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\approxcoloncolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\"); // Present in newtxmath, pxfonts and txfonts\n\ndefineMacro(\"\\\\notni\", \"\\\\html@mathml{\\\\not\\\\ni}{\\\\mathrel{\\\\char`\\u220C}}\");\ndefineMacro(\"\\\\limsup\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,sup}\");\ndefineMacro(\"\\\\liminf\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,inf}\"); //////////////////////////////////////////////////////////////////////\n// From amsopn.sty\n\ndefineMacro(\"\\\\injlim\", \"\\\\DOTSB\\\\operatorname*{inj\\\\,lim}\");\ndefineMacro(\"\\\\projlim\", \"\\\\DOTSB\\\\operatorname*{proj\\\\,lim}\");\ndefineMacro(\"\\\\varlimsup\", \"\\\\DOTSB\\\\operatorname*{\\\\overline{lim}}\");\ndefineMacro(\"\\\\varliminf\", \"\\\\DOTSB\\\\operatorname*{\\\\underline{lim}}\");\ndefineMacro(\"\\\\varinjlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underrightarrow{lim}}\");\ndefineMacro(\"\\\\varprojlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underleftarrow{lim}}\"); //////////////////////////////////////////////////////////////////////\n// MathML alternates for KaTeX glyphs in the Unicode private area\n\ndefineMacro(\"\\\\gvertneqq\", \"\\\\html@mathml{\\\\@gvertneqq}{\\u2269}\");\ndefineMacro(\"\\\\lvertneqq\", \"\\\\html@mathml{\\\\@lvertneqq}{\\u2268}\");\ndefineMacro(\"\\\\ngeqq\", \"\\\\html@mathml{\\\\@ngeqq}{\\u2271}\");\ndefineMacro(\"\\\\ngeqslant\", \"\\\\html@mathml{\\\\@ngeqslant}{\\u2271}\");\ndefineMacro(\"\\\\nleqq\", \"\\\\html@mathml{\\\\@nleqq}{\\u2270}\");\ndefineMacro(\"\\\\nleqslant\", \"\\\\html@mathml{\\\\@nleqslant}{\\u2270}\");\ndefineMacro(\"\\\\nshortmid\", \"\\\\html@mathml{\\\\@nshortmid}{}\");\ndefineMacro(\"\\\\nshortparallel\", \"\\\\html@mathml{\\\\@nshortparallel}{}\");\ndefineMacro(\"\\\\nsubseteqq\", \"\\\\html@mathml{\\\\@nsubseteqq}{\\u2288}\");\ndefineMacro(\"\\\\nsupseteqq\", \"\\\\html@mathml{\\\\@nsupseteqq}{\\u2289}\");\ndefineMacro(\"\\\\varsubsetneq\", \"\\\\html@mathml{\\\\@varsubsetneq}{}\");\ndefineMacro(\"\\\\varsubsetneqq\", \"\\\\html@mathml{\\\\@varsubsetneqq}{}\");\ndefineMacro(\"\\\\varsupsetneq\", \"\\\\html@mathml{\\\\@varsupsetneq}{}\");\ndefineMacro(\"\\\\varsupsetneqq\", \"\\\\html@mathml{\\\\@varsupsetneqq}{}\");\ndefineMacro(\"\\\\imath\", \"\\\\html@mathml{\\\\@imath}{\\u0131}\");\ndefineMacro(\"\\\\jmath\", \"\\\\html@mathml{\\\\@jmath}{\\u0237}\"); //////////////////////////////////////////////////////////////////////\n// stmaryrd and semantic\n// The stmaryrd and semantic packages render the next four items by calling a\n// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.\n\ndefineMacro(\"\\\\llbracket\", \"\\\\html@mathml{\" + \"\\\\mathopen{[\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u27e6}}\");\ndefineMacro(\"\\\\rrbracket\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu]}}\" + \"{\\\\mathclose{\\\\char`\\u27e7}}\");\ndefineMacro(\"\\u27e6\", \"\\\\llbracket\"); // blackboard bold [\n\ndefineMacro(\"\\u27e7\", \"\\\\rrbracket\"); // blackboard bold ]\n\ndefineMacro(\"\\\\lBrace\", \"\\\\html@mathml{\" + \"\\\\mathopen{\\\\{\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u2983}}\");\ndefineMacro(\"\\\\rBrace\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu\\\\}}}\" + \"{\\\\mathclose{\\\\char`\\u2984}}\");\ndefineMacro(\"\\u2983\", \"\\\\lBrace\"); // blackboard bold {\n\ndefineMacro(\"\\u2984\", \"\\\\rBrace\"); // blackboard bold }\n// TODO: Create variable sized versions of the last two items. I believe that\n// will require new font glyphs.\n// The stmaryrd function `\\minuso` provides a \"Plimsoll\" symbol that\n// superimposes the characters \\circ and \\mathminus. Used in chemistry.\n\ndefineMacro(\"\\\\minuso\", \"\\\\mathbin{\\\\html@mathml{\" + \"{\\\\mathrlap{\\\\mathchoice{\\\\kern{0.145em}}{\\\\kern{0.145em}}\" + \"{\\\\kern{0.1015em}}{\\\\kern{0.0725em}}\\\\circ}{-}}}\" + \"{\\\\char`}}\");\ndefineMacro(\"\", \"\\\\minuso\"); //////////////////////////////////////////////////////////////////////\n// texvc.sty\n// The texvc package contains macros available in mediawiki pages.\n// We omit the functions deprecated at\n// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax\n// We also omit texvc's \\O, which conflicts with \\text{\\O}\n\ndefineMacro(\"\\\\darr\", \"\\\\downarrow\");\ndefineMacro(\"\\\\dArr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\Darr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\lang\", \"\\\\langle\");\ndefineMacro(\"\\\\rang\", \"\\\\rangle\");\ndefineMacro(\"\\\\uarr\", \"\\\\uparrow\");\ndefineMacro(\"\\\\uArr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\Uarr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\N\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\R\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Z\", \"\\\\mathbb{Z}\");\ndefineMacro(\"\\\\alef\", \"\\\\aleph\");\ndefineMacro(\"\\\\alefsym\", \"\\\\aleph\");\ndefineMacro(\"\\\\Alpha\", \"\\\\mathrm{A}\");\ndefineMacro(\"\\\\Beta\", \"\\\\mathrm{B}\");\ndefineMacro(\"\\\\bull\", \"\\\\bullet\");\ndefineMacro(\"\\\\Chi\", \"\\\\mathrm{X}\");\ndefineMacro(\"\\\\clubs\", \"\\\\clubsuit\");\ndefineMacro(\"\\\\cnums\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Complex\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Dagger\", \"\\\\ddagger\");\ndefineMacro(\"\\\\diamonds\", \"\\\\diamondsuit\");\ndefineMacro(\"\\\\empty\", \"\\\\emptyset\");\ndefineMacro(\"\\\\Epsilon\", \"\\\\mathrm{E}\");\ndefineMacro(\"\\\\Eta\", \"\\\\mathrm{H}\");\ndefineMacro(\"\\\\exist\", \"\\\\exists\");\ndefineMacro(\"\\\\harr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\hArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Harr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\hearts\", \"\\\\heartsuit\");\ndefineMacro(\"\\\\image\", \"\\\\Im\");\ndefineMacro(\"\\\\infin\", \"\\\\infty\");\ndefineMacro(\"\\\\Iota\", \"\\\\mathrm{I}\");\ndefineMacro(\"\\\\isin\", \"\\\\in\");\ndefineMacro(\"\\\\Kappa\", \"\\\\mathrm{K}\");\ndefineMacro(\"\\\\larr\", \"\\\\leftarrow\");\ndefineMacro(\"\\\\lArr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\Larr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\lrarr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\lrArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Lrarr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Mu\", \"\\\\mathrm{M}\");\ndefineMacro(\"\\\\natnums\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\Nu\", \"\\\\mathrm{N}\");\ndefineMacro(\"\\\\Omicron\", \"\\\\mathrm{O}\");\ndefineMacro(\"\\\\plusmn\", \"\\\\pm\");\ndefineMacro(\"\\\\rarr\", \"\\\\rightarrow\");\ndefineMacro(\"\\\\rArr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\Rarr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\real\", \"\\\\Re\");\ndefineMacro(\"\\\\reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Rho\", \"\\\\mathrm{P}\");\ndefineMacro(\"\\\\sdot\", \"\\\\cdot\");\ndefineMacro(\"\\\\sect\", \"\\\\S\");\ndefineMacro(\"\\\\spades\", \"\\\\spadesuit\");\ndefineMacro(\"\\\\sub\", \"\\\\subset\");\ndefineMacro(\"\\\\sube\", \"\\\\subseteq\");\ndefineMacro(\"\\\\supe\", \"\\\\supseteq\");\ndefineMacro(\"\\\\Tau\", \"\\\\mathrm{T}\");\ndefineMacro(\"\\\\thetasym\", \"\\\\vartheta\"); // TODO: defineMacro(\"\\\\varcoppa\", \"\\\\\\mbox{\\\\coppa}\");\n\ndefineMacro(\"\\\\weierp\", \"\\\\wp\");\ndefineMacro(\"\\\\Zeta\", \"\\\\mathrm{Z}\"); //////////////////////////////////////////////////////////////////////\n// statmath.sty\n// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf\n\ndefineMacro(\"\\\\argmin\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,min}\");\ndefineMacro(\"\\\\argmax\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,max}\");\ndefineMacro(\"\\\\plim\", \"\\\\DOTSB\\\\mathop{\\\\operatorname{plim}}\\\\limits\"); //////////////////////////////////////////////////////////////////////\n// braket.sty\n// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf\n\ndefineMacro(\"\\\\bra\", \"\\\\mathinner{\\\\langle{#1}|}\");\ndefineMacro(\"\\\\ket\", \"\\\\mathinner{|{#1}\\\\rangle}\");\ndefineMacro(\"\\\\braket\", \"\\\\mathinner{\\\\langle{#1}\\\\rangle}\");\ndefineMacro(\"\\\\Bra\", \"\\\\left\\\\langle#1\\\\right|\");\ndefineMacro(\"\\\\Ket\", \"\\\\left|#1\\\\right\\\\rangle\");\n\nvar braketHelper = one => context => {\n  var left = context.consumeArg().tokens;\n  var middle = context.consumeArg().tokens;\n  var middleDouble = context.consumeArg().tokens;\n  var right = context.consumeArg().tokens;\n  var oldMiddle = context.macros.get(\"|\");\n  var oldMiddleDouble = context.macros.get(\"\\\\|\");\n  context.macros.beginGroup();\n\n  var midMacro = double => context => {\n    if (one) {\n      // Only modify the first instance of | or \\|\n      context.macros.set(\"|\", oldMiddle);\n\n      if (middleDouble.length) {\n        context.macros.set(\"\\\\|\", oldMiddleDouble);\n      }\n    }\n\n    var doubled = double;\n\n    if (!double && middleDouble.length) {\n      // Mimic \\@ifnextchar\n      var nextToken = context.future();\n\n      if (nextToken.text === \"|\") {\n        context.popToken();\n        doubled = true;\n      }\n    }\n\n    return {\n      tokens: doubled ? middleDouble : middle,\n      numArgs: 0\n    };\n  };\n\n  context.macros.set(\"|\", midMacro(false));\n\n  if (middleDouble.length) {\n    context.macros.set(\"\\\\|\", midMacro(true));\n  }\n\n  var arg = context.consumeArg().tokens;\n  var expanded = context.expandTokens([...right, ...arg, ...left // reversed\n  ]);\n  context.macros.endGroup();\n  return {\n    tokens: expanded.reverse(),\n    numArgs: 0\n  };\n};\n\ndefineMacro(\"\\\\bra@ket\", braketHelper(false));\ndefineMacro(\"\\\\bra@set\", braketHelper(true));\ndefineMacro(\"\\\\Braket\", \"\\\\bra@ket{\\\\left\\\\langle}\" + \"{\\\\,\\\\middle\\\\vert\\\\,}{\\\\,\\\\middle\\\\vert\\\\,}{\\\\right\\\\rangle}\");\ndefineMacro(\"\\\\Set\", \"\\\\bra@set{\\\\left\\\\{\\\\:}\" + \"{\\\\;\\\\middle\\\\vert\\\\;}{\\\\;\\\\middle\\\\Vert\\\\;}{\\\\:\\\\right\\\\}}\");\ndefineMacro(\"\\\\set\", \"\\\\bra@set{\\\\{\\\\,}{\\\\mid}{}{\\\\,\\\\}}\"); // has no support for special || or \\|\n//////////////////////////////////////////////////////////////////////\n// actuarialangle.dtx\n\ndefineMacro(\"\\\\angln\", \"{\\\\angl n}\"); // Custom Khan Academy colors, should be moved to an optional package\n\ndefineMacro(\"\\\\blue\", \"\\\\textcolor{##6495ed}{#1}\");\ndefineMacro(\"\\\\orange\", \"\\\\textcolor{##ffa500}{#1}\");\ndefineMacro(\"\\\\pink\", \"\\\\textcolor{##ff00af}{#1}\");\ndefineMacro(\"\\\\red\", \"\\\\textcolor{##df0030}{#1}\");\ndefineMacro(\"\\\\green\", \"\\\\textcolor{##28ae7b}{#1}\");\ndefineMacro(\"\\\\gray\", \"\\\\textcolor{gray}{#1}\");\ndefineMacro(\"\\\\purple\", \"\\\\textcolor{##9d38bd}{#1}\");\ndefineMacro(\"\\\\blueA\", \"\\\\textcolor{##ccfaff}{#1}\");\ndefineMacro(\"\\\\blueB\", \"\\\\textcolor{##80f6ff}{#1}\");\ndefineMacro(\"\\\\blueC\", \"\\\\textcolor{##63d9ea}{#1}\");\ndefineMacro(\"\\\\blueD\", \"\\\\textcolor{##11accd}{#1}\");\ndefineMacro(\"\\\\blueE\", \"\\\\textcolor{##0c7f99}{#1}\");\ndefineMacro(\"\\\\tealA\", \"\\\\textcolor{##94fff5}{#1}\");\ndefineMacro(\"\\\\tealB\", \"\\\\textcolor{##26edd5}{#1}\");\ndefineMacro(\"\\\\tealC\", \"\\\\textcolor{##01d1c1}{#1}\");\ndefineMacro(\"\\\\tealD\", \"\\\\textcolor{##01a995}{#1}\");\ndefineMacro(\"\\\\tealE\", \"\\\\textcolor{##208170}{#1}\");\ndefineMacro(\"\\\\greenA\", \"\\\\textcolor{##b6ffb0}{#1}\");\ndefineMacro(\"\\\\greenB\", \"\\\\textcolor{##8af281}{#1}\");\ndefineMacro(\"\\\\greenC\", \"\\\\textcolor{##74cf70}{#1}\");\ndefineMacro(\"\\\\greenD\", \"\\\\textcolor{##1fab54}{#1}\");\ndefineMacro(\"\\\\greenE\", \"\\\\textcolor{##0d923f}{#1}\");\ndefineMacro(\"\\\\goldA\", \"\\\\textcolor{##ffd0a9}{#1}\");\ndefineMacro(\"\\\\goldB\", \"\\\\textcolor{##ffbb71}{#1}\");\ndefineMacro(\"\\\\goldC\", \"\\\\textcolor{##ff9c39}{#1}\");\ndefineMacro(\"\\\\goldD\", \"\\\\textcolor{##e07d10}{#1}\");\ndefineMacro(\"\\\\goldE\", \"\\\\textcolor{##a75a05}{#1}\");\ndefineMacro(\"\\\\redA\", \"\\\\textcolor{##fca9a9}{#1}\");\ndefineMacro(\"\\\\redB\", \"\\\\textcolor{##ff8482}{#1}\");\ndefineMacro(\"\\\\redC\", \"\\\\textcolor{##f9685d}{#1}\");\ndefineMacro(\"\\\\redD\", \"\\\\textcolor{##e84d39}{#1}\");\ndefineMacro(\"\\\\redE\", \"\\\\textcolor{##bc2612}{#1}\");\ndefineMacro(\"\\\\maroonA\", \"\\\\textcolor{##ffbde0}{#1}\");\ndefineMacro(\"\\\\maroonB\", \"\\\\textcolor{##ff92c6}{#1}\");\ndefineMacro(\"\\\\maroonC\", \"\\\\textcolor{##ed5fa6}{#1}\");\ndefineMacro(\"\\\\maroonD\", \"\\\\textcolor{##ca337c}{#1}\");\ndefineMacro(\"\\\\maroonE\", \"\\\\textcolor{##9e034e}{#1}\");\ndefineMacro(\"\\\\purpleA\", \"\\\\textcolor{##ddd7ff}{#1}\");\ndefineMacro(\"\\\\purpleB\", \"\\\\textcolor{##c6b9fc}{#1}\");\ndefineMacro(\"\\\\purpleC\", \"\\\\textcolor{##aa87ff}{#1}\");\ndefineMacro(\"\\\\purpleD\", \"\\\\textcolor{##7854ab}{#1}\");\ndefineMacro(\"\\\\purpleE\", \"\\\\textcolor{##543b78}{#1}\");\ndefineMacro(\"\\\\mintA\", \"\\\\textcolor{##f5f9e8}{#1}\");\ndefineMacro(\"\\\\mintB\", \"\\\\textcolor{##edf2df}{#1}\");\ndefineMacro(\"\\\\mintC\", \"\\\\textcolor{##e0e5cc}{#1}\");\ndefineMacro(\"\\\\grayA\", \"\\\\textcolor{##f6f7f7}{#1}\");\ndefineMacro(\"\\\\grayB\", \"\\\\textcolor{##f0f1f2}{#1}\");\ndefineMacro(\"\\\\grayC\", \"\\\\textcolor{##e3e5e6}{#1}\");\ndefineMacro(\"\\\\grayD\", \"\\\\textcolor{##d6d8da}{#1}\");\ndefineMacro(\"\\\\grayE\", \"\\\\textcolor{##babec2}{#1}\");\ndefineMacro(\"\\\\grayF\", \"\\\\textcolor{##888d93}{#1}\");\ndefineMacro(\"\\\\grayG\", \"\\\\textcolor{##626569}{#1}\");\ndefineMacro(\"\\\\grayH\", \"\\\\textcolor{##3b3e40}{#1}\");\ndefineMacro(\"\\\\grayI\", \"\\\\textcolor{##21242c}{#1}\");\ndefineMacro(\"\\\\kaBlue\", \"\\\\textcolor{##314453}{#1}\");\ndefineMacro(\"\\\\kaGreen\", \"\\\\textcolor{##71B307}{#1}\");\n\n/**\n * This file contains the gullet where macros are expanded\n * until only non-macro tokens remain.\n */\n// List of commands that act like macros but aren't defined as a macro,\n// function, or symbol.  Used in `isDefined`.\nvar implicitCommands = {\n  \"^\": true,\n  // Parser.js\n  \"_\": true,\n  // Parser.js\n  \"\\\\limits\": true,\n  // Parser.js\n  \"\\\\nolimits\": true // Parser.js\n\n};\nclass MacroExpander {\n  constructor(input, settings, mode) {\n    this.settings = void 0;\n    this.expansionCount = void 0;\n    this.lexer = void 0;\n    this.macros = void 0;\n    this.stack = void 0;\n    this.mode = void 0;\n    this.settings = settings;\n    this.expansionCount = 0;\n    this.feed(input); // Make new global namespace\n\n    this.macros = new Namespace(macros, settings.macros);\n    this.mode = mode;\n    this.stack = []; // contains tokens in REVERSE order\n  }\n  /**\n   * Feed a new input string to the same MacroExpander\n   * (with existing macros etc.).\n   */\n\n\n  feed(input) {\n    this.lexer = new Lexer(input, this.settings);\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n  }\n  /**\n   * Start a new group nesting within all namespaces.\n   */\n\n\n  beginGroup() {\n    this.macros.beginGroup();\n  }\n  /**\n   * End current group nesting within all namespaces.\n   */\n\n\n  endGroup() {\n    this.macros.endGroup();\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    this.macros.endGroups();\n  }\n  /**\n   * Returns the topmost token on the stack, without expanding it.\n   * Similar in behavior to TeX's `\\futurelet`.\n   */\n\n\n  future() {\n    if (this.stack.length === 0) {\n      this.pushToken(this.lexer.lex());\n    }\n\n    return this.stack[this.stack.length - 1];\n  }\n  /**\n   * Remove and return the next unexpanded token.\n   */\n\n\n  popToken() {\n    this.future(); // ensure non-empty stack\n\n    return this.stack.pop();\n  }\n  /**\n   * Add a given token to the token stack.  In particular, this get be used\n   * to put back a token returned from one of the other methods.\n   */\n\n\n  pushToken(token) {\n    this.stack.push(token);\n  }\n  /**\n   * Append an array of tokens to the token stack.\n   */\n\n\n  pushTokens(tokens) {\n    this.stack.push(...tokens);\n  }\n  /**\n   * Find an macro argument without expanding tokens and append the array of\n   * tokens to the token stack. Uses Token as a container for the result.\n   */\n\n\n  scanArgument(isOptional) {\n    var start;\n    var end;\n    var tokens;\n\n    if (isOptional) {\n      this.consumeSpaces(); // \\@ifnextchar gobbles any space following it\n\n      if (this.future().text !== \"[\") {\n        return null;\n      }\n\n      start = this.popToken(); // don't include [ in tokens\n\n      ({\n        tokens,\n        end\n      } = this.consumeArg([\"]\"]));\n    } else {\n      ({\n        tokens,\n        start,\n        end\n      } = this.consumeArg());\n    } // indicate the end of an argument\n\n\n    this.pushToken(new Token(\"EOF\", end.loc));\n    this.pushTokens(tokens);\n    return start.range(end, \"\");\n  }\n  /**\n   * Consume all following space tokens, without expansion.\n   */\n\n\n  consumeSpaces() {\n    for (;;) {\n      var token = this.future();\n\n      if (token.text === \" \") {\n        this.stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Consume an argument from the token stream, and return the resulting array\n   * of tokens and start/end token.\n   */\n\n\n  consumeArg(delims) {\n    // The argument for a delimited parameter is the shortest (possibly\n    // empty) sequence of tokens with properly nested {...} groups that is\n    // followed ... by this particular list of non-parameter tokens.\n    // The argument for an undelimited parameter is the next nonblank\n    // token, unless that token is {, when the argument will be the\n    // entire {...} group that follows.\n    var tokens = [];\n    var isDelimited = delims && delims.length > 0;\n\n    if (!isDelimited) {\n      // Ignore spaces between arguments.  As the TeXbook says:\n      // \"After you have said \\def\\row#1#2{...}, you are allowed to\n      //  put spaces between the arguments (e.g., \\row x n), because\n      //  TeX doesnt use single spaces as undelimited arguments.\"\n      this.consumeSpaces();\n    }\n\n    var start = this.future();\n    var tok;\n    var depth = 0;\n    var match = 0;\n\n    do {\n      tok = this.popToken();\n      tokens.push(tok);\n\n      if (tok.text === \"{\") {\n        ++depth;\n      } else if (tok.text === \"}\") {\n        --depth;\n\n        if (depth === -1) {\n          throw new ParseError(\"Extra }\", tok);\n        }\n      } else if (tok.text === \"EOF\") {\n        throw new ParseError(\"Unexpected end of input in a macro argument\" + \", expected '\" + (delims && isDelimited ? delims[match] : \"}\") + \"'\", tok);\n      }\n\n      if (delims && isDelimited) {\n        if ((depth === 0 || depth === 1 && delims[match] === \"{\") && tok.text === delims[match]) {\n          ++match;\n\n          if (match === delims.length) {\n            // don't include delims in tokens\n            tokens.splice(-match, match);\n            break;\n          }\n        } else {\n          match = 0;\n        }\n      }\n    } while (depth !== 0 || isDelimited); // If the argument found ... has the form {<nested tokens>},\n    // ... the outermost braces enclosing the argument are removed\n\n\n    if (start.text === \"{\" && tokens[tokens.length - 1].text === \"}\") {\n      tokens.pop();\n      tokens.shift();\n    }\n\n    tokens.reverse(); // to fit in with stack order\n\n    return {\n      tokens,\n      start,\n      end: tok\n    };\n  }\n  /**\n   * Consume the specified number of (delimited) arguments from the token\n   * stream and return the resulting array of arguments.\n   */\n\n\n  consumeArgs(numArgs, delimiters) {\n    if (delimiters) {\n      if (delimiters.length !== numArgs + 1) {\n        throw new ParseError(\"The length of delimiters doesn't match the number of args!\");\n      }\n\n      var delims = delimiters[0];\n\n      for (var i = 0; i < delims.length; i++) {\n        var tok = this.popToken();\n\n        if (delims[i] !== tok.text) {\n          throw new ParseError(\"Use of the macro doesn't match its definition\", tok);\n        }\n      }\n    }\n\n    var args = [];\n\n    for (var _i = 0; _i < numArgs; _i++) {\n      args.push(this.consumeArg(delimiters && delimiters[_i + 1]).tokens);\n    }\n\n    return args;\n  }\n  /**\n   * Increment `expansionCount` by the specified amount.\n   * Throw an error if it exceeds `maxExpand`.\n   */\n\n\n  countExpansion(amount) {\n    this.expansionCount += amount;\n\n    if (this.expansionCount > this.settings.maxExpand) {\n      throw new ParseError(\"Too many expansions: infinite loop or \" + \"need to increase maxExpand setting\");\n    }\n  }\n  /**\n   * Expand the next token only once if possible.\n   *\n   * If the token is expanded, the resulting tokens will be pushed onto\n   * the stack in reverse order, and the number of such tokens will be\n   * returned.  This number might be zero or positive.\n   *\n   * If not, the return value is `false`, and the next token remains at the\n   * top of the stack.\n   *\n   * In either case, the next token will be on the top of the stack,\n   * or the stack will be empty (in case of empty expansion\n   * and no other tokens).\n   *\n   * Used to implement `expandAfterFuture` and `expandNextToken`.\n   *\n   * If expandableOnly, only expandable tokens are expanded and\n   * an undefined control sequence results in an error.\n   */\n\n\n  expandOnce(expandableOnly) {\n    var topToken = this.popToken();\n    var name = topToken.text;\n    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;\n\n    if (expansion == null || expandableOnly && expansion.unexpandable) {\n      if (expandableOnly && expansion == null && name[0] === \"\\\\\" && !this.isDefined(name)) {\n        throw new ParseError(\"Undefined control sequence: \" + name);\n      }\n\n      this.pushToken(topToken);\n      return false;\n    }\n\n    this.countExpansion(1);\n    var tokens = expansion.tokens;\n    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);\n\n    if (expansion.numArgs) {\n      // paste arguments in place of the placeholders\n      tokens = tokens.slice(); // make a shallow copy\n\n      for (var i = tokens.length - 1; i >= 0; --i) {\n        var tok = tokens[i];\n\n        if (tok.text === \"#\") {\n          if (i === 0) {\n            throw new ParseError(\"Incomplete placeholder at end of macro body\", tok);\n          }\n\n          tok = tokens[--i]; // next token on stack\n\n          if (tok.text === \"#\") {\n            // ##  #\n            tokens.splice(i + 1, 1); // drop first #\n          } else if (/^[1-9]$/.test(tok.text)) {\n            // replace the placeholder with the indicated argument\n            tokens.splice(i, 2, ...args[+tok.text - 1]);\n          } else {\n            throw new ParseError(\"Not a valid argument number\", tok);\n          }\n        }\n      }\n    } // Concatenate expansion onto top of stack.\n\n\n    this.pushTokens(tokens);\n    return tokens.length;\n  }\n  /**\n   * Expand the next token only once (if possible), and return the resulting\n   * top token on the stack (without removing anything from the stack).\n   * Similar in behavior to TeX's `\\expandafter\\futurelet`.\n   * Equivalent to expandOnce() followed by future().\n   */\n\n\n  expandAfterFuture() {\n    this.expandOnce();\n    return this.future();\n  }\n  /**\n   * Recursively expand first token, then return first non-expandable token.\n   */\n\n\n  expandNextToken() {\n    for (;;) {\n      if (this.expandOnce() === false) {\n        // fully expanded\n        var token = this.stack.pop(); // the token after \\noexpand is interpreted as if its meaning\n        // were \\relax\n\n        if (token.treatAsRelax) {\n          token.text = \"\\\\relax\";\n        }\n\n        return token;\n      }\n    } // Flow unable to figure out that this pathway is impossible.\n    // https://github.com/facebook/flow/issues/4808\n\n\n    throw new Error(); // eslint-disable-line no-unreachable\n  }\n  /**\n   * Fully expand the given macro name and return the resulting list of\n   * tokens, or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacro(name) {\n    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;\n  }\n  /**\n   * Fully expand the given token stream and return the resulting list of\n   * tokens.  Note that the input tokens are in reverse order, but the\n   * output tokens are in forward order.\n   */\n\n\n  expandTokens(tokens) {\n    var output = [];\n    var oldStackLength = this.stack.length;\n    this.pushTokens(tokens);\n\n    while (this.stack.length > oldStackLength) {\n      // Expand only expandable tokens\n      if (this.expandOnce(true) === false) {\n        // fully expanded\n        var token = this.stack.pop();\n\n        if (token.treatAsRelax) {\n          // the expansion of \\noexpand is the token itself\n          token.noexpand = false;\n          token.treatAsRelax = false;\n        }\n\n        output.push(token);\n      }\n    } // Count all of these tokens as additional expansions, to prevent\n    // exponential blowup from linearly many \\edef's.\n\n\n    this.countExpansion(output.length);\n    return output;\n  }\n  /**\n   * Fully expand the given macro name and return the result as a string,\n   * or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacroAsText(name) {\n    var tokens = this.expandMacro(name);\n\n    if (tokens) {\n      return tokens.map(token => token.text).join(\"\");\n    } else {\n      return tokens;\n    }\n  }\n  /**\n   * Returns the expanded macro as a reversed array of tokens and a macro\n   * argument count.  Or returns `null` if no such macro.\n   */\n\n\n  _getExpansion(name) {\n    var definition = this.macros.get(name);\n\n    if (definition == null) {\n      // mainly checking for undefined here\n      return definition;\n    } // If a single character has an associated catcode other than 13\n    // (active character), then don't expand it.\n\n\n    if (name.length === 1) {\n      var catcode = this.lexer.catcodes[name];\n\n      if (catcode != null && catcode !== 13) {\n        return;\n      }\n    }\n\n    var expansion = typeof definition === \"function\" ? definition(this) : definition;\n\n    if (typeof expansion === \"string\") {\n      var numArgs = 0;\n\n      if (expansion.indexOf(\"#\") !== -1) {\n        var stripped = expansion.replace(/##/g, \"\");\n\n        while (stripped.indexOf(\"#\" + (numArgs + 1)) !== -1) {\n          ++numArgs;\n        }\n      }\n\n      var bodyLexer = new Lexer(expansion, this.settings);\n      var tokens = [];\n      var tok = bodyLexer.lex();\n\n      while (tok.text !== \"EOF\") {\n        tokens.push(tok);\n        tok = bodyLexer.lex();\n      }\n\n      tokens.reverse(); // to fit in with stack using push and pop\n\n      var expanded = {\n        tokens,\n        numArgs\n      };\n      return expanded;\n    }\n\n    return expansion;\n  }\n  /**\n   * Determine whether a command is currently \"defined\" (has some\n   * functionality), meaning that it's a macro (in the current group),\n   * a function, a symbol, or one of the special commands listed in\n   * `implicitCommands`.\n   */\n\n\n  isDefined(name) {\n    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);\n  }\n  /**\n   * Determine whether a command is expandable.\n   */\n\n\n  isExpandable(name) {\n    var macro = this.macros.get(name);\n    return macro != null ? typeof macro === \"string\" || typeof macro === \"function\" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;\n  }\n\n}\n\n// Helpers for Parser.js handling of Unicode (sub|super)script characters.\nvar unicodeSubRegEx = /^[]/;\nvar uSubsAndSups = Object.freeze({\n  '': '+',\n  '': '-',\n  '': '=',\n  '': '(',\n  '': ')',\n  '': '0',\n  '': '1',\n  '': '2',\n  '': '3',\n  '': '4',\n  '': '5',\n  '': '6',\n  '': '7',\n  '': '8',\n  '': '9',\n  '\\u2090': 'a',\n  '\\u2091': 'e',\n  '\\u2095': 'h',\n  '\\u1D62': 'i',\n  '\\u2C7C': 'j',\n  '\\u2096': 'k',\n  '\\u2097': 'l',\n  '\\u2098': 'm',\n  '\\u2099': 'n',\n  '\\u2092': 'o',\n  '\\u209A': 'p',\n  '\\u1D63': 'r',\n  '\\u209B': 's',\n  '\\u209C': 't',\n  '\\u1D64': 'u',\n  '\\u1D65': 'v',\n  '\\u2093': 'x',\n  '\\u1D66': '',\n  '\\u1D67': '',\n  '\\u1D68': '',\n  '\\u1D69': '\\u03d5',\n  '\\u1D6A': '',\n  '': '+',\n  '': '-',\n  '': '=',\n  '': '(',\n  '': ')',\n  '': '0',\n  '': '1',\n  '': '2',\n  '': '3',\n  '': '4',\n  '': '5',\n  '': '6',\n  '': '7',\n  '': '8',\n  '': '9',\n  '\\u1D2C': 'A',\n  '\\u1D2E': 'B',\n  '\\u1D30': 'D',\n  '\\u1D31': 'E',\n  '\\u1D33': 'G',\n  '\\u1D34': 'H',\n  '\\u1D35': 'I',\n  '\\u1D36': 'J',\n  '\\u1D37': 'K',\n  '\\u1D38': 'L',\n  '\\u1D39': 'M',\n  '\\u1D3A': 'N',\n  '\\u1D3C': 'O',\n  '\\u1D3E': 'P',\n  '\\u1D3F': 'R',\n  '\\u1D40': 'T',\n  '\\u1D41': 'U',\n  '\\u2C7D': 'V',\n  '\\u1D42': 'W',\n  '\\u1D43': 'a',\n  '\\u1D47': 'b',\n  '\\u1D9C': 'c',\n  '\\u1D48': 'd',\n  '\\u1D49': 'e',\n  '\\u1DA0': 'f',\n  '\\u1D4D': 'g',\n  '\\u02B0': 'h',\n  '\\u2071': 'i',\n  '\\u02B2': 'j',\n  '\\u1D4F': 'k',\n  '\\u02E1': 'l',\n  '\\u1D50': 'm',\n  '\\u207F': 'n',\n  '\\u1D52': 'o',\n  '\\u1D56': 'p',\n  '\\u02B3': 'r',\n  '\\u02E2': 's',\n  '\\u1D57': 't',\n  '\\u1D58': 'u',\n  '\\u1D5B': 'v',\n  '\\u02B7': 'w',\n  '\\u02E3': 'x',\n  '\\u02B8': 'y',\n  '\\u1DBB': 'z',\n  '\\u1D5D': '',\n  '\\u1D5E': '',\n  '\\u1D5F': '',\n  '\\u1D60': '\\u03d5',\n  '\\u1D61': '',\n  '\\u1DBF': ''\n});\n\n/* eslint no-constant-condition:0 */\n\nvar unicodeAccents = {\n  \"\": {\n    \"text\": \"\\\\'\",\n    \"math\": \"\\\\acute\"\n  },\n  \"\": {\n    \"text\": \"\\\\`\",\n    \"math\": \"\\\\grave\"\n  },\n  \"\": {\n    \"text\": \"\\\\\\\"\",\n    \"math\": \"\\\\ddot\"\n  },\n  \"\": {\n    \"text\": \"\\\\~\",\n    \"math\": \"\\\\tilde\"\n  },\n  \"\": {\n    \"text\": \"\\\\=\",\n    \"math\": \"\\\\bar\"\n  },\n  \"\": {\n    \"text\": \"\\\\u\",\n    \"math\": \"\\\\breve\"\n  },\n  \"\": {\n    \"text\": \"\\\\v\",\n    \"math\": \"\\\\check\"\n  },\n  \"\": {\n    \"text\": \"\\\\^\",\n    \"math\": \"\\\\hat\"\n  },\n  \"\": {\n    \"text\": \"\\\\.\",\n    \"math\": \"\\\\dot\"\n  },\n  \"\": {\n    \"text\": \"\\\\r\",\n    \"math\": \"\\\\mathring\"\n  },\n  \"\": {\n    \"text\": \"\\\\H\"\n  },\n  \"\": {\n    \"text\": \"\\\\c\"\n  }\n};\nvar unicodeSymbols = {\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"b\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"d\",\n  \"\": \"d\",\n  \"\": \"d\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"f\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"j\",\n  \"\": \"j\",\n  \"\": \"k\",\n  \"\": \"k\",\n  \"\": \"k\",\n  \"\": \"l\",\n  \"\": \"l\",\n  \"\": \"l\",\n  \"\": \"m\",\n  \"\": \"m\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"p\",\n  \"\": \"p\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"v\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"x\",\n  \"\": \"x\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"B\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"D\",\n  \"\": \"D\",\n  \"\": \"D\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"F\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"J\",\n  \"\": \"K\",\n  \"\": \"K\",\n  \"\": \"K\",\n  \"\": \"L\",\n  \"\": \"L\",\n  \"\": \"L\",\n  \"\": \"M\",\n  \"\": \"M\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"P\",\n  \"\": \"P\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"T\",\n  \"\": \"T\",\n  \"\": \"T\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"V\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"X\",\n  \"\": \"X\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\"\n};\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The functions return ParseNodes.\n */\nclass Parser {\n  constructor(input, settings) {\n    this.mode = void 0;\n    this.gullet = void 0;\n    this.settings = void 0;\n    this.leftrightDepth = void 0;\n    this.nextToken = void 0;\n    // Start in math mode\n    this.mode = \"math\"; // Create a new macro expander (gullet) and (indirectly via that) also a\n    // new lexer (mouth) for this parser (stomach, in the language of TeX)\n\n    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing\n\n    this.settings = settings; // Count leftright depth (for \\middle errors)\n\n    this.leftrightDepth = 0;\n  }\n  /**\n   * Checks a result to make sure it has the right type, and throws an\n   * appropriate error otherwise.\n   */\n\n\n  expect(text, consume) {\n    if (consume === void 0) {\n      consume = true;\n    }\n\n    if (this.fetch().text !== text) {\n      throw new ParseError(\"Expected '\" + text + \"', got '\" + this.fetch().text + \"'\", this.fetch());\n    }\n\n    if (consume) {\n      this.consume();\n    }\n  }\n  /**\n   * Discards the current lookahead token, considering it consumed.\n   */\n\n\n  consume() {\n    this.nextToken = null;\n  }\n  /**\n   * Return the current lookahead token, or if there isn't one (at the\n   * beginning, or if the previous lookahead token was consume()d),\n   * fetch the next token as the new lookahead token and return it.\n   */\n\n\n  fetch() {\n    if (this.nextToken == null) {\n      this.nextToken = this.gullet.expandNextToken();\n    }\n\n    return this.nextToken;\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n    this.gullet.switchMode(newMode);\n  }\n  /**\n   * Main parsing function, which parses an entire input.\n   */\n\n\n  parse() {\n    if (!this.settings.globalGroup) {\n      // Create a group namespace for the math expression.\n      // (LaTeX creates a new group for every $...$, $$...$$, \\[...\\].)\n      this.gullet.beginGroup();\n    } // Use old \\color behavior (same as LaTeX's \\textcolor) if requested.\n    // We do this within the group for the math expression, so it doesn't\n    // pollute settings.macros.\n\n\n    if (this.settings.colorIsTextColor) {\n      this.gullet.macros.set(\"\\\\color\", \"\\\\textcolor\");\n    }\n\n    try {\n      // Try to parse the input\n      var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end\n\n      this.expect(\"EOF\"); // End the group namespace for the expression\n\n      if (!this.settings.globalGroup) {\n        this.gullet.endGroup();\n      }\n\n      return parse; // Close any leftover groups in case of a parse error.\n    } finally {\n      this.gullet.endGroups();\n    }\n  }\n  /**\n   * Fully parse a separate sequence of tokens as a separate job.\n   * Tokens should be specified in reverse order, as in a MacroDefinition.\n   */\n\n\n  subparse(tokens) {\n    // Save the next token from the current job.\n    var oldToken = this.nextToken;\n    this.consume(); // Run the new job, terminating it with an excess '}'\n\n    this.gullet.pushToken(new Token(\"}\"));\n    this.gullet.pushTokens(tokens);\n    var parse = this.parseExpression(false);\n    this.expect(\"}\"); // Restore the next token from the current job.\n\n    this.nextToken = oldToken;\n    return parse;\n  }\n\n  /**\n   * Parses an \"expression\", which is a list of atoms.\n   *\n   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This\n   *                 happens when functions have higher precedence han infix\n   *                 nodes in implicit parses.\n   *\n   * `breakOnTokenText`: The text of the token that the expression should end\n   *                     with, or `null` if something else should end the\n   *                     expression.\n   */\n  parseExpression(breakOnInfix, breakOnTokenText) {\n    var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n\n    while (true) {\n      // Ignore spaces in math mode\n      if (this.mode === \"math\") {\n        this.consumeSpaces();\n      }\n\n      var lex = this.fetch();\n\n      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {\n        break;\n      }\n\n      if (breakOnTokenText && lex.text === breakOnTokenText) {\n        break;\n      }\n\n      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {\n        break;\n      }\n\n      var atom = this.parseAtom(breakOnTokenText);\n\n      if (!atom) {\n        break;\n      } else if (atom.type === \"internal\") {\n        continue;\n      }\n\n      body.push(atom);\n    }\n\n    if (this.mode === \"text\") {\n      this.formLigatures(body);\n    }\n\n    return this.handleInfixNodes(body);\n  }\n  /**\n   * Rewrites infix operators such as \\over with corresponding commands such\n   * as \\frac.\n   *\n   * There can only be one infix operator per group.  If there's more than one\n   * then the expression is ambiguous.  This can be resolved by adding {}.\n   */\n\n\n  handleInfixNodes(body) {\n    var overIndex = -1;\n    var funcName;\n\n    for (var i = 0; i < body.length; i++) {\n      if (body[i].type === \"infix\") {\n        if (overIndex !== -1) {\n          throw new ParseError(\"only one infix operator per group\", body[i].token);\n        }\n\n        overIndex = i;\n        funcName = body[i].replaceWith;\n      }\n    }\n\n    if (overIndex !== -1 && funcName) {\n      var numerNode;\n      var denomNode;\n      var numerBody = body.slice(0, overIndex);\n      var denomBody = body.slice(overIndex + 1);\n\n      if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n        numerNode = numerBody[0];\n      } else {\n        numerNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: numerBody\n        };\n      }\n\n      if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n        denomNode = denomBody[0];\n      } else {\n        denomNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: denomBody\n        };\n      }\n\n      var node;\n\n      if (funcName === \"\\\\\\\\abovefrac\") {\n        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);\n      } else {\n        node = this.callFunction(funcName, [numerNode, denomNode], []);\n      }\n\n      return [node];\n    } else {\n      return body;\n    }\n  }\n  /**\n   * Handle a subscript or superscript with nice errors.\n   */\n\n\n  handleSupSubscript(name // For error reporting.\n  ) {\n    var symbolToken = this.fetch();\n    var symbol = symbolToken.text;\n    this.consume();\n    this.consumeSpaces(); // ignore spaces before sup/subscript argument\n\n    var group = this.parseGroup(name);\n\n    if (!group) {\n      throw new ParseError(\"Expected group after '\" + symbol + \"'\", symbolToken);\n    }\n\n    return group;\n  }\n  /**\n   * Converts the textual input of an unsupported command into a text node\n   * contained within a color node whose color is determined by errorColor\n   */\n\n\n  formatUnsupportedCmd(text) {\n    var textordArray = [];\n\n    for (var i = 0; i < text.length; i++) {\n      textordArray.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: text[i]\n      });\n    }\n\n    var textNode = {\n      type: \"text\",\n      mode: this.mode,\n      body: textordArray\n    };\n    var colorNode = {\n      type: \"color\",\n      mode: this.mode,\n      color: this.settings.errorColor,\n      body: [textNode]\n    };\n    return colorNode;\n  }\n  /**\n   * Parses a group with optional super/subscripts.\n   */\n\n\n  parseAtom(breakOnTokenText) {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    var base = this.parseGroup(\"atom\", breakOnTokenText); // In text mode, we don't have superscripts or subscripts\n\n    if (this.mode === \"text\") {\n      return base;\n    } // Note that base may be empty (i.e. null) at this point.\n\n\n    var superscript;\n    var subscript;\n\n    while (true) {\n      // Guaranteed in math mode, so eat any spaces first.\n      this.consumeSpaces(); // Lex the first token\n\n      var lex = this.fetch();\n\n      if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n        // We got a limit control\n        if (base && base.type === \"op\") {\n          var limits = lex.text === \"\\\\limits\";\n          base.limits = limits;\n          base.alwaysHandleSupSub = true;\n        } else if (base && base.type === \"operatorname\") {\n          if (base.alwaysHandleSupSub) {\n            base.limits = lex.text === \"\\\\limits\";\n          }\n        } else {\n          throw new ParseError(\"Limit controls must follow a math operator\", lex);\n        }\n\n        this.consume();\n      } else if (lex.text === \"^\") {\n        // We got a superscript start\n        if (superscript) {\n          throw new ParseError(\"Double superscript\", lex);\n        }\n\n        superscript = this.handleSupSubscript(\"superscript\");\n      } else if (lex.text === \"_\") {\n        // We got a subscript start\n        if (subscript) {\n          throw new ParseError(\"Double subscript\", lex);\n        }\n\n        subscript = this.handleSupSubscript(\"subscript\");\n      } else if (lex.text === \"'\") {\n        // We got a prime\n        if (superscript) {\n          throw new ParseError(\"Double superscript\", lex);\n        }\n\n        var prime = {\n          type: \"textord\",\n          mode: this.mode,\n          text: \"\\\\prime\"\n        }; // Many primes can be grouped together, so we handle this here\n\n        var primes = [prime];\n        this.consume(); // Keep lexing tokens until we get something that's not a prime\n\n        while (this.fetch().text === \"'\") {\n          // For each one, add another prime to the list\n          primes.push(prime);\n          this.consume();\n        } // If there's a superscript following the primes, combine that\n        // superscript in with the primes.\n\n\n        if (this.fetch().text === \"^\") {\n          primes.push(this.handleSupSubscript(\"superscript\"));\n        } // Put everything into an ordgroup as the superscript\n\n\n        superscript = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: primes\n        };\n      } else if (uSubsAndSups[lex.text]) {\n        // A Unicode subscript or superscript character.\n        // We treat these similarly to the unicode-math package.\n        // So we render a string of Unicode (sub|super)scripts the\n        // same as a (sub|super)script of regular characters.\n        var isSub = unicodeSubRegEx.test(lex.text);\n        var subsupTokens = [];\n        subsupTokens.push(new Token(uSubsAndSups[lex.text]));\n        this.consume(); // Continue fetching tokens to fill out the string.\n\n        while (true) {\n          var token = this.fetch().text;\n\n          if (!uSubsAndSups[token]) {\n            break;\n          }\n\n          if (unicodeSubRegEx.test(token) !== isSub) {\n            break;\n          }\n\n          subsupTokens.unshift(new Token(uSubsAndSups[token]));\n          this.consume();\n        } // Now create a (sub|super)script.\n\n\n        var body = this.subparse(subsupTokens);\n\n        if (isSub) {\n          subscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        } else {\n          superscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        }\n      } else {\n        // If it wasn't ^, _, or ', stop parsing super/subscripts\n        break;\n      }\n    } // Base must be set if superscript or subscript are set per logic above,\n    // but need to check here for type check to pass.\n\n\n    if (superscript || subscript) {\n      // If we got either a superscript or subscript, create a supsub\n      return {\n        type: \"supsub\",\n        mode: this.mode,\n        base: base,\n        sup: superscript,\n        sub: subscript\n      };\n    } else {\n      // Otherwise return the original body\n      return base;\n    }\n  }\n  /**\n   * Parses an entire function, including its base and all of its arguments.\n   */\n\n\n  parseFunction(breakOnTokenText, name // For determining its context\n  ) {\n    var token = this.fetch();\n    var func = token.text;\n    var funcData = functions[func];\n\n    if (!funcData) {\n      return null;\n    }\n\n    this.consume(); // consume command token\n\n    if (name && name !== \"atom\" && !funcData.allowedInArgument) {\n      throw new ParseError(\"Got function '\" + func + \"' with no arguments\" + (name ? \" as \" + name : \"\"), token);\n    } else if (this.mode === \"text\" && !funcData.allowedInText) {\n      throw new ParseError(\"Can't use function '\" + func + \"' in text mode\", token);\n    } else if (this.mode === \"math\" && funcData.allowedInMath === false) {\n      throw new ParseError(\"Can't use function '\" + func + \"' in math mode\", token);\n    }\n\n    var {\n      args,\n      optArgs\n    } = this.parseArguments(func, funcData);\n    return this.callFunction(func, args, optArgs, token, breakOnTokenText);\n  }\n  /**\n   * Call a function handler with a suitable context and arguments.\n   */\n\n\n  callFunction(name, args, optArgs, token, breakOnTokenText) {\n    var context = {\n      funcName: name,\n      parser: this,\n      token,\n      breakOnTokenText\n    };\n    var func = functions[name];\n\n    if (func && func.handler) {\n      return func.handler(context, args, optArgs);\n    } else {\n      throw new ParseError(\"No function handler for \" + name);\n    }\n  }\n  /**\n   * Parses the arguments of a function or environment\n   */\n\n\n  parseArguments(func, // Should look like \"\\name\" or \"\\begin{name}\".\n  funcData) {\n    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n\n    if (totalArgs === 0) {\n      return {\n        args: [],\n        optArgs: []\n      };\n    }\n\n    var args = [];\n    var optArgs = [];\n\n    for (var i = 0; i < totalArgs; i++) {\n      var argType = funcData.argTypes && funcData.argTypes[i];\n      var isOptional = i < funcData.numOptionalArgs;\n\n      if (funcData.primitive && argType == null || // \\sqrt expands into primitive if optional argument doesn't exist\n      funcData.type === \"sqrt\" && i === 1 && optArgs[0] == null) {\n        argType = \"primitive\";\n      }\n\n      var arg = this.parseGroupOfType(\"argument to '\" + func + \"'\", argType, isOptional);\n\n      if (isOptional) {\n        optArgs.push(arg);\n      } else if (arg != null) {\n        args.push(arg);\n      } else {\n        // should be unreachable\n        throw new ParseError(\"Null argument, please report this as a bug\");\n      }\n    }\n\n    return {\n      args,\n      optArgs\n    };\n  }\n  /**\n   * Parses a group when the mode is changing.\n   */\n\n\n  parseGroupOfType(name, type, optional) {\n    switch (type) {\n      case \"color\":\n        return this.parseColorGroup(optional);\n\n      case \"size\":\n        return this.parseSizeGroup(optional);\n\n      case \"url\":\n        return this.parseUrlGroup(optional);\n\n      case \"math\":\n      case \"text\":\n        return this.parseArgumentGroup(optional, type);\n\n      case \"hbox\":\n        {\n          // hbox argument type wraps the argument in the equivalent of\n          // \\hbox, which is like \\text but switching to \\textstyle size.\n          var group = this.parseArgumentGroup(optional, \"text\");\n          return group != null ? {\n            type: \"styling\",\n            mode: group.mode,\n            body: [group],\n            style: \"text\" // simulate \\textstyle\n\n          } : null;\n        }\n\n      case \"raw\":\n        {\n          var token = this.parseStringGroup(\"raw\", optional);\n          return token != null ? {\n            type: \"raw\",\n            mode: \"text\",\n            string: token.text\n          } : null;\n        }\n\n      case \"primitive\":\n        {\n          if (optional) {\n            throw new ParseError(\"A primitive argument cannot be optional\");\n          }\n\n          var _group = this.parseGroup(name);\n\n          if (_group == null) {\n            throw new ParseError(\"Expected group as \" + name, this.fetch());\n          }\n\n          return _group;\n        }\n\n      case \"original\":\n      case null:\n      case undefined:\n        return this.parseArgumentGroup(optional);\n\n      default:\n        throw new ParseError(\"Unknown group type as \" + name, this.fetch());\n    }\n  }\n  /**\n   * Discard any space tokens, fetching the next non-space token.\n   */\n\n\n  consumeSpaces() {\n    while (this.fetch().text === \" \") {\n      this.consume();\n    }\n  }\n  /**\n   * Parses a group, essentially returning the string formed by the\n   * brace-enclosed tokens plus some position information.\n   */\n\n\n  parseStringGroup(modeName, // Used to describe the mode in error messages.\n  optional) {\n    var argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\") {\n      str += nextToken.text;\n      this.consume();\n    }\n\n    this.consume(); // consume the end of the argument\n\n    argToken.text = str;\n    return argToken;\n  }\n  /**\n   * Parses a regex-delimited group: the largest sequence of tokens\n   * whose concatenated strings match `regex`. Returns the string\n   * formed by the tokens plus some position information.\n   */\n\n\n  parseRegexGroup(regex, modeName // Used to describe the mode in error messages.\n  ) {\n    var firstToken = this.fetch();\n    var lastToken = firstToken;\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\" && regex.test(str + nextToken.text)) {\n      lastToken = nextToken;\n      str += lastToken.text;\n      this.consume();\n    }\n\n    if (str === \"\") {\n      throw new ParseError(\"Invalid \" + modeName + \": '\" + firstToken.text + \"'\", firstToken);\n    }\n\n    return firstToken.range(lastToken, str);\n  }\n  /**\n   * Parses a color description.\n   */\n\n\n  parseColorGroup(optional) {\n    var res = this.parseStringGroup(\"color\", optional);\n\n    if (res == null) {\n      return null;\n    }\n\n    var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);\n\n    if (!match) {\n      throw new ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n    }\n\n    var color = match[0];\n\n    if (/^[0-9a-f]{6}$/i.test(color)) {\n      // We allow a 6-digit HTML color spec without a leading \"#\".\n      // This follows the xcolor package's HTML color model.\n      // Predefined color names are all missed by this RegEx pattern.\n      color = \"#\" + color;\n    }\n\n    return {\n      type: \"color-token\",\n      mode: this.mode,\n      color\n    };\n  }\n  /**\n   * Parses a size specification, consisting of magnitude and unit.\n   */\n\n\n  parseSizeGroup(optional) {\n    var res;\n    var isBlank = false; // don't expand before parseStringGroup\n\n    this.gullet.consumeSpaces();\n\n    if (!optional && this.gullet.future().text !== \"{\") {\n      res = this.parseRegexGroup(/^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2} *$/, \"size\");\n    } else {\n      res = this.parseStringGroup(\"size\", optional);\n    }\n\n    if (!res) {\n      return null;\n    }\n\n    if (!optional && res.text.length === 0) {\n      // Because we've tested for what is !optional, this block won't\n      // affect \\kern, \\hspace, etc. It will capture the mandatory arguments\n      // to \\genfrac and \\above.\n      res.text = \"0pt\"; // Enable \\above{}\n\n      isBlank = true; // This is here specifically for \\genfrac\n    }\n\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(res.text);\n\n    if (!match) {\n      throw new ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n    }\n\n    return {\n      type: \"size\",\n      mode: this.mode,\n      value: data,\n      isBlank\n    };\n  }\n  /**\n   * Parses an URL, checking escaped letters and allowed protocols,\n   * and setting the catcode of % as an active character (as in \\hyperref).\n   */\n\n\n  parseUrlGroup(optional) {\n    this.gullet.lexer.setCatcode(\"%\", 13); // active character\n\n    this.gullet.lexer.setCatcode(\"~\", 12); // other character\n\n    var res = this.parseStringGroup(\"url\", optional);\n    this.gullet.lexer.setCatcode(\"%\", 14); // comment character\n\n    this.gullet.lexer.setCatcode(\"~\", 13); // active character\n\n    if (res == null) {\n      return null;\n    } // hyperref package allows backslashes alone in href, but doesn't\n    // generate valid links in such cases; we interpret this as\n    // \"undefined\" behaviour, and keep them as-is. Some browser will\n    // replace backslashes with forward slashes.\n\n\n    var url = res.text.replace(/\\\\([#$%&~_^{}])/g, '$1');\n    return {\n      type: \"url\",\n      mode: this.mode,\n      url\n    };\n  }\n  /**\n   * Parses an argument with the mode specified.\n   */\n\n\n  parseArgumentGroup(optional, mode) {\n    var argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    var outerMode = this.mode;\n\n    if (mode) {\n      // Switch to specified mode\n      this.switchMode(mode);\n    }\n\n    this.gullet.beginGroup();\n    var expression = this.parseExpression(false, \"EOF\"); // TODO: find an alternative way to denote the end\n\n    this.expect(\"EOF\"); // expect the end of the argument\n\n    this.gullet.endGroup();\n    var result = {\n      type: \"ordgroup\",\n      mode: this.mode,\n      loc: argToken.loc,\n      body: expression\n    };\n\n    if (mode) {\n      // Switch mode back\n      this.switchMode(outerMode);\n    }\n\n    return result;\n  }\n  /**\n   * Parses an ordinary group, which is either a single nucleus (like \"x\")\n   * or an expression in braces (like \"{x+y}\") or an implicit group, a group\n   * that starts at the current position, and ends right before a higher explicit\n   * group ends, or at EOF.\n   */\n\n\n  parseGroup(name, // For error reporting.\n  breakOnTokenText) {\n    var firstToken = this.fetch();\n    var text = firstToken.text;\n    var result; // Try to parse an open brace or \\begingroup\n\n    if (text === \"{\" || text === \"\\\\begingroup\") {\n      this.consume();\n      var groupEnd = text === \"{\" ? \"}\" : \"\\\\endgroup\";\n      this.gullet.beginGroup(); // If we get a brace, parse an expression\n\n      var expression = this.parseExpression(false, groupEnd);\n      var lastToken = this.fetch();\n      this.expect(groupEnd); // Check that we got a matching closing brace\n\n      this.gullet.endGroup();\n      result = {\n        type: \"ordgroup\",\n        mode: this.mode,\n        loc: SourceLocation.range(firstToken, lastToken),\n        body: expression,\n        // A group formed by \\begingroup...\\endgroup is a semi-simple group\n        // which doesn't affect spacing in math mode, i.e., is transparent.\n        // https://tex.stackexchange.com/questions/1930/when-should-one-\n        // use-begingroup-instead-of-bgroup\n        semisimple: text === \"\\\\begingroup\" || undefined\n      };\n    } else {\n      // If there exists a function with this name, parse the function.\n      // Otherwise, just return a nucleus\n      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();\n\n      if (result == null && text[0] === \"\\\\\" && !implicitCommands.hasOwnProperty(text)) {\n        if (this.settings.throwOnError) {\n          throw new ParseError(\"Undefined control sequence: \" + text, firstToken);\n        }\n\n        result = this.formatUnsupportedCmd(text);\n        this.consume();\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Form ligature-like combinations of characters for text mode.\n   * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n   * The result will simply replace multiple textord nodes with a single\n   * character in each value by a single textord node having multiple\n   * characters in its value.  The representation is still ASCII source.\n   * The group will be modified in place.\n   */\n\n\n  formLigatures(group) {\n    var n = group.length - 1;\n\n    for (var i = 0; i < n; ++i) {\n      var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n      var v = a.text;\n\n      if (v === \"-\" && group[i + 1].text === \"-\") {\n        if (i + 1 < n && group[i + 2].text === \"-\") {\n          group.splice(i, 3, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 2]),\n            text: \"---\"\n          });\n          n -= 2;\n        } else {\n          group.splice(i, 2, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 1]),\n            text: \"--\"\n          });\n          n -= 1;\n        }\n      }\n\n      if ((v === \"'\" || v === \"`\") && group[i + 1].text === v) {\n        group.splice(i, 2, {\n          type: \"textord\",\n          mode: \"text\",\n          loc: SourceLocation.range(a, group[i + 1]),\n          text: v + v\n        });\n        n -= 1;\n      }\n    }\n  }\n  /**\n   * Parse a single symbol out of the string. Here, we handle single character\n   * symbols and special functions like \\verb.\n   */\n\n\n  parseSymbol() {\n    var nucleus = this.fetch();\n    var text = nucleus.text;\n\n    if (/^\\\\verb[^a-zA-Z]/.test(text)) {\n      this.consume();\n      var arg = text.slice(5);\n      var star = arg.charAt(0) === \"*\";\n\n      if (star) {\n        arg = arg.slice(1);\n      } // Lexer's tokenRegex is constructed to always have matching\n      // first/last characters.\n\n\n      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {\n        throw new ParseError(\"\\\\verb assertion failed --\\n                    please report what input caused this bug\");\n      }\n\n      arg = arg.slice(1, -1); // remove first and last char\n\n      return {\n        type: \"verb\",\n        mode: \"text\",\n        body: arg,\n        star\n      };\n    } // At this point, we should have a symbol, possibly with accents.\n    // First expand any accented base symbol according to unicodeSymbols.\n\n\n    if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {\n      // This behavior is not strict (XeTeX-compatible) in math mode.\n      if (this.settings.strict && this.mode === \"math\") {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Accented Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      text = unicodeSymbols[text[0]] + text.slice(1);\n    } // Strip off any combining characters\n\n\n    var match = combiningDiacriticalMarksEndRegex.exec(text);\n\n    if (match) {\n      text = text.substring(0, match.index);\n\n      if (text === 'i') {\n        text = '\\u0131'; // dotless i, in math and text mode\n      } else if (text === 'j') {\n        text = '\\u0237'; // dotless j, in math and text mode\n      }\n    } // Recognize base symbol\n\n\n    var symbol;\n\n    if (symbols[this.mode][text]) {\n      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Latin-1/Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      var group = symbols[this.mode][text].group;\n      var loc = SourceLocation.range(nucleus);\n      var s;\n\n      if (ATOMS.hasOwnProperty(group)) {\n        // $FlowFixMe\n        var family = group;\n        s = {\n          type: \"atom\",\n          mode: this.mode,\n          family,\n          loc,\n          text\n        };\n      } else {\n        // $FlowFixMe\n        s = {\n          type: group,\n          mode: this.mode,\n          loc,\n          text\n        };\n      } // $FlowFixMe\n\n\n      symbol = s;\n    } else if (text.charCodeAt(0) >= 0x80) {\n      // no symbol for e.g. ^\n      if (this.settings.strict) {\n        if (!supportedCodepoint(text.charCodeAt(0))) {\n          this.settings.reportNonstrict(\"unknownSymbol\", \"Unrecognized Unicode character \\\"\" + text[0] + \"\\\"\" + (\" (\" + text.charCodeAt(0) + \")\"), nucleus);\n        } else if (this.mode === \"math\") {\n          this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Unicode text character \\\"\" + text[0] + \"\\\" used in math mode\", nucleus);\n        }\n      } // All nonmathematical Unicode characters are rendered as if they\n      // are in text mode (wrapped in \\text) because that's what it\n      // takes to render them in LaTeX.  Setting `mode: this.mode` is\n      // another natural choice (the user requested math mode), but\n      // this makes it more difficult for getCharacterMetrics() to\n      // distinguish Unicode characters without metrics and those for\n      // which we want to simulate the letter M.\n\n\n      symbol = {\n        type: \"textord\",\n        mode: \"text\",\n        loc: SourceLocation.range(nucleus),\n        text\n      };\n    } else {\n      return null; // EOF, ^, _, {, }, etc.\n    }\n\n    this.consume(); // Transform combining characters into accents\n\n    if (match) {\n      for (var i = 0; i < match[0].length; i++) {\n        var accent = match[0][i];\n\n        if (!unicodeAccents[accent]) {\n          throw new ParseError(\"Unknown accent ' \" + accent + \"'\", nucleus);\n        }\n\n        var command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;\n\n        if (!command) {\n          throw new ParseError(\"Accent \" + accent + \" unsupported in \" + this.mode + \" mode\", nucleus);\n        }\n\n        symbol = {\n          type: \"accent\",\n          mode: this.mode,\n          loc: SourceLocation.range(nucleus),\n          label: command,\n          isStretchy: false,\n          isShifty: true,\n          // $FlowFixMe\n          base: symbol\n        };\n      }\n    } // $FlowFixMe\n\n\n    return symbol;\n  }\n\n}\nParser.endOfExpression = [\"}\", \"\\\\endgroup\", \"\\\\end\", \"\\\\right\", \"&\"];\n\n/**\n * Provides a single function for parsing an expression using a Parser\n * TODO(emily): Remove this\n */\n\n/**\n * Parses an expression using a Parser, then returns the parsed result.\n */\nvar parseTree = function parseTree(toParse, settings) {\n  if (!(typeof toParse === 'string' || toParse instanceof String)) {\n    throw new TypeError('KaTeX can only parse string typed expression');\n  }\n\n  var parser = new Parser(toParse, settings); // Blank out any \\df@tag to avoid spurious \"Duplicate \\tag\" errors\n\n  delete parser.gullet.macros.current[\"\\\\df@tag\"];\n  var tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().\n\n  delete parser.gullet.macros.current[\"\\\\current@color\"];\n  delete parser.gullet.macros.current[\"\\\\color\"]; // If the input used \\tag, it will set the \\df@tag macro to the tag.\n  // In this case, we separately parse the tag and wrap the tree.\n\n  if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n    if (!settings.displayMode) {\n      throw new ParseError(\"\\\\tag works only in display equations\");\n    }\n\n    tree = [{\n      type: \"tag\",\n      mode: \"text\",\n      body: tree,\n      tag: parser.subparse([new Token(\"\\\\df@tag\")])\n    }];\n  }\n\n  return tree;\n};\n\n/* eslint no-console:0 */\n\n/**\n * Parse and build an expression, and place that expression in the DOM node\n * given.\n */\nvar render = function render(expression, baseNode, options) {\n  baseNode.textContent = \"\";\n  var node = renderToDomTree(expression, options).toNode();\n  baseNode.appendChild(node);\n}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and\n// disable rendering.\n\n\nif (typeof document !== \"undefined\") {\n  if (document.compatMode !== \"CSS1Compat\") {\n    typeof console !== \"undefined\" && console.warn(\"Warning: KaTeX doesn't work in quirks mode. Make sure your \" + \"website has a suitable doctype.\");\n\n    render = function render() {\n      throw new ParseError(\"KaTeX doesn't work in quirks mode.\");\n    };\n  }\n}\n/**\n * Parse and build an expression, and return the markup for that.\n */\n\n\nvar renderToString = function renderToString(expression, options) {\n  var markup = renderToDomTree(expression, options).toMarkup();\n  return markup;\n};\n/**\n * Parse an expression and return the parse tree.\n */\n\n\nvar generateParseTree = function generateParseTree(expression, options) {\n  var settings = new Settings(options);\n  return parseTree(expression, settings);\n};\n/**\n * If the given error is a KaTeX ParseError and options.throwOnError is false,\n * renders the invalid LaTeX as a span with hover title giving the KaTeX\n * error message.  Otherwise, simply throws the error.\n */\n\n\nvar renderError = function renderError(error, expression, options) {\n  if (options.throwOnError || !(error instanceof ParseError)) {\n    throw error;\n  }\n\n  var node = buildCommon.makeSpan([\"katex-error\"], [new SymbolNode(expression)]);\n  node.setAttribute(\"title\", error.toString());\n  node.setAttribute(\"style\", \"color:\" + options.errorColor);\n  return node;\n};\n/**\n * Generates and returns the katex build tree. This is used for advanced\n * use cases (like rendering to custom output).\n */\n\n\nvar renderToDomTree = function renderToDomTree(expression, options) {\n  var settings = new Settings(options);\n\n  try {\n    var tree = parseTree(expression, settings);\n    return buildTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n/**\n * Generates and returns the katex build tree, with just HTML (no MathML).\n * This is used for advanced use cases (like rendering to custom output).\n */\n\n\nvar renderToHTMLTree = function renderToHTMLTree(expression, options) {\n  var settings = new Settings(options);\n\n  try {\n    var tree = parseTree(expression, settings);\n    return buildHTMLTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n\nvar katex = {\n  /**\n   * Current KaTeX version\n   */\n  version: \"0.16.11\",\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination, and adds\n   * it as a child to the specified DOM node.\n   */\n  render,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination string,\n   * for sending to the client.\n   */\n  renderToString,\n\n  /**\n   * KaTeX error, usually during parsing.\n   */\n  ParseError,\n\n  /**\n   * The shema of Settings\n   */\n  SETTINGS_SCHEMA,\n\n  /**\n   * Parses the given LaTeX into KaTeX's internal parse tree structure,\n   * without rendering to HTML or MathML.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __parse: generateParseTree,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML internal DOM tree\n   * representation, without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToDomTree: renderToDomTree,\n\n  /**\n   * Renders the given LaTeX into an HTML internal DOM tree representation,\n   * without MathML and without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToHTMLTree: renderToHTMLTree,\n\n  /**\n   * extends internal font metrics object with a new object\n   * each key in the new object represents a font name\n  */\n  __setFontMetrics: setFontMetrics,\n\n  /**\n   * adds a new symbol to builtin symbols table\n   */\n  __defineSymbol: defineSymbol,\n\n  /**\n   * adds a new function to builtin function list,\n   * which directly produce parse tree elements\n   * and have their own html/mathml builders\n   */\n  __defineFunction: defineFunction,\n\n  /**\n   * adds a new macro to builtin macro list\n   */\n  __defineMacro: defineMacro,\n\n  /**\n   * Expose the dom tree node types, which can be useful for type checking nodes.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __domTree: {\n    Span,\n    Anchor,\n    SymbolNode,\n    SvgNode,\n    PathNode,\n    LineNode\n  }\n};\n\nexport { katex as default };\n","'use client'\n\nimport { AIMessage, BaseMessage, HumanMessage, SystemMessage } from '@langchain/core/messages'\nimport { useChat as useBaseChat } from 'ai/react'\n\nexport const useChat = ({\n  copilotStream,\n}: {\n  copilotStream?: (\n    message: string | BaseMessage[],\n    onMessageUpdate: (chunk: string) => void,\n  ) => void\n}) => {\n  return useBaseChat({\n    fetch: async (_, init) => {\n      const data = (init?.body ? JSON.parse(init.body as string) : {}) as {\n        messages: { role: string; content: string }[]\n        system?: string\n      }\n      const messages = data.messages.map((message) => {\n        if (message.role === 'user') {\n          return new HumanMessage(message.content)\n        }\n        return new AIMessage(message.content)\n      })\n      if (data.system) {\n        messages.unshift(new SystemMessage(data.system))\n      }\n\n      const stream = createStreamResponse({\n        messages,\n        copilotStream,\n      })\n      return new Response(stream, {\n        headers: {\n          Connection: 'keep-alive',\n          'Content-Type': 'text/plain',\n        },\n      })\n    },\n  })\n}\n\nconst createStreamResponse = ({\n  messages,\n  copilotStream,\n  streamProtocol = 'data',\n}: {\n  messages: BaseMessage[]\n  copilotStream?: (\n    message: string | BaseMessage[],\n    onMessageUpdate: (chunk: string) => void,\n  ) => void\n  chunkCount?: number\n  streamProtocol?: 'data' | 'text'\n}) => {\n  const encoder = new TextEncoder()\n\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        let count = 0\n        let lastChunk = ''\n        await copilotStream?.(messages, (chunk) => {\n          count += 1\n          const chunkData = chunk.replace(lastChunk, '')\n          lastChunk = chunk\n          if (streamProtocol === 'text') {\n            controller.enqueue(encoder.encode(chunkData))\n          } else {\n            controller.enqueue(encoder.encode(`0:${JSON.stringify(chunkData)}\\n`))\n          }\n        })\n\n        if (streamProtocol === 'data') {\n          controller.enqueue(\n            `d:{\"finishReason\":\"stop\",\"usage\":{\"promptTokens\":0,\"completionTokens\":${count}}}\\n`,\n          )\n        }\n      } finally {\n        controller.close()\n      }\n    },\n  })\n}\n","'use client'\n\nimport React, { memo } from 'react'\n\nimport { AIChatPlugin, useLastAssistantMessage } from '@udecode/plate-ai/react'\nimport { type PlateEditor, Plate, useEditorPlugin } from '@udecode/plate-common/react'\nimport { deserializeMd } from '@udecode/plate-markdown'\n\nimport { Editor } from './editor'\n\nexport const AIChatEditor = memo(\n  ({ aiEditorRef }: { aiEditorRef: React.MutableRefObject<PlateEditor | null> }) => {\n    const { getOptions } = useEditorPlugin(AIChatPlugin)\n    const lastAssistantMessage = useLastAssistantMessage()\n    const content = lastAssistantMessage?.content ?? ''\n\n    const aiEditor = React.useMemo(() => {\n      const editor = getOptions().createAIEditor()\n\n      const fragment = deserializeMd(editor, content)\n      editor.children = fragment.length > 0 ? fragment : editor.api.create.value()\n\n      return editor\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [])\n\n    React.useEffect(() => {\n      if (aiEditor && content) {\n        aiEditorRef.current = aiEditor\n\n        setTimeout(() => {\n          aiEditor.tf.setValue(deserializeMd(aiEditor, content))\n        }, 0)\n      }\n    }, [aiEditor, aiEditorRef, content])\n\n    if (!content) return null\n\n    return (\n      <Plate editor={aiEditor}>\n        <Editor variant=\"aiChat\" readOnly />\n      </Plate>\n    )\n  },\n)\n","'use client'\n\nimport { useEffect, useMemo } from 'react'\n\nimport { AIChatPlugin, AIPlugin } from '@udecode/plate-ai/react'\nimport { getAncestorNode, getEndPoint, getNodeString } from '@udecode/plate-common'\nimport { type PlateEditor, focusEditor, useEditorPlugin } from '@udecode/plate-common/react'\nimport { useIsSelecting } from '@udecode/plate-selection/react'\nimport LazyIcon from 'src/components/atoms/LazyIcon'\n\nimport { CommandGroup, CommandItem } from './command'\n\nexport type EditorChatState =\n  | 'cursorCommand'\n  | 'cursorSuggestion'\n  | 'selectionCommand'\n  | 'selectionSuggestion'\n\nexport const aiChatItems = {\n  accept: {\n    icon: <LazyIcon name=\"check\" />,\n    label: 'Accept',\n    value: 'accept',\n    onSelect: ({ editor }) => {\n      editor.getTransforms(AIChatPlugin).aiChat.accept()\n      focusEditor(editor, getEndPoint(editor, editor.selection!))\n    },\n  },\n  continueWrite: {\n    icon: <LazyIcon name=\"pen-line\" />,\n    label: 'Continue writing',\n    value: 'continueWrite',\n    onSelect: ({ editor }) => {\n      const ancestorNode = getAncestorNode(editor)\n\n      if (!ancestorNode) return\n\n      const isEmpty = getNodeString(ancestorNode[0]).trim().length === 0\n\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        mode: 'insert',\n        prompt: isEmpty\n          ? `<Document>\n{editor}\n</Document>\nStart writing a new paragraph AFTER <Document> ONLY ONE SENTENCE`\n          : 'Continue writing AFTER <Block> ONLY ONE SENTENCE. DONT REPEAT THE TEXT.',\n      })\n    },\n  },\n  discard: {\n    icon: <LazyIcon name=\"x\" />,\n    label: 'Discard',\n    shortcut: 'Escape',\n    value: 'discard',\n    onSelect: ({ editor }) => {\n      editor.getTransforms(AIPlugin).ai.undo()\n      editor.getApi(AIChatPlugin).aiChat.hide()\n    },\n  },\n  explain: {\n    icon: <LazyIcon name=\"badge-help\" />,\n    label: 'Explain',\n    value: 'explain',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        prompt: {\n          default: 'Explain {editor}',\n          selecting: 'Explain',\n        },\n      })\n    },\n  },\n  fixSpelling: {\n    icon: <LazyIcon name=\"check\" />,\n    label: 'Fix spelling & grammar',\n    value: 'fixSpelling',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        prompt: 'Fix spelling and grammar',\n      })\n    },\n  },\n  improveWriting: {\n    icon: <LazyIcon name=\"wand\" />,\n    label: 'Improve writing',\n    value: 'improveWriting',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        prompt: 'Improve the writing',\n      })\n    },\n  },\n  insertBelow: {\n    icon: <LazyIcon name=\"list-end\" />,\n    label: 'Insert below',\n    value: 'insertBelow',\n    onSelect: ({ aiEditor, editor }) => {\n      void editor.getTransforms(AIChatPlugin).aiChat.insertBelow(aiEditor)\n    },\n  },\n  makeLonger: {\n    icon: <LazyIcon name=\"list-plus\" />,\n    label: 'Make longer',\n    value: 'makeLonger',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        prompt: 'Make longer',\n      })\n    },\n  },\n  makeShorter: {\n    icon: <LazyIcon name=\"list-minus\" />,\n    label: 'Make shorter',\n    value: 'makeShorter',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        prompt: 'Make shorter',\n      })\n    },\n  },\n  replace: {\n    icon: <LazyIcon name=\"check\" />,\n    label: 'Replace selection',\n    value: 'replace',\n    onSelect: ({ aiEditor, editor }) => {\n      void editor.getTransforms(AIChatPlugin).aiChat.replaceSelection(aiEditor)\n    },\n  },\n  simplifyLanguage: {\n    icon: <LazyIcon name=\"feather\" />,\n    label: 'Simplify language',\n    value: 'simplifyLanguage',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        prompt: 'Simplify the language',\n      })\n    },\n  },\n  summarize: {\n    icon: <LazyIcon name=\"album\" />,\n    label: 'Add a summary',\n    value: 'summarize',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.submit({\n        mode: 'insert',\n        prompt: {\n          default: 'Summarize {editor}',\n          selecting: 'Summarize',\n        },\n      })\n    },\n  },\n  tryAgain: {\n    icon: <LazyIcon name=\"corner-up-left\" />,\n    label: 'Try again',\n    value: 'tryAgain',\n    onSelect: ({ editor }) => {\n      void editor.getApi(AIChatPlugin).aiChat.reload()\n    },\n  },\n} satisfies Record<\n  string,\n  {\n    icon: React.ReactNode\n    label: string\n    value: string\n    component?: React.ComponentType<{ menuState: EditorChatState }>\n    filterItems?: boolean\n    items?: { label: string; value: string }[]\n    shortcut?: string\n    onSelect?: ({ aiEditor, editor }: { aiEditor: PlateEditor; editor: PlateEditor }) => void\n  }\n>\n\nconst menuStateItems: Record<\n  EditorChatState,\n  {\n    items: (typeof aiChatItems)[keyof typeof aiChatItems][]\n    heading?: string\n  }[]\n> = {\n  cursorCommand: [\n    {\n      items: [aiChatItems.continueWrite, aiChatItems.summarize, aiChatItems.explain],\n    },\n  ],\n  cursorSuggestion: [\n    {\n      items: [aiChatItems.accept, aiChatItems.discard, aiChatItems.tryAgain],\n    },\n  ],\n  selectionCommand: [\n    {\n      items: [\n        aiChatItems.improveWriting,\n        aiChatItems.makeLonger,\n        aiChatItems.makeShorter,\n        aiChatItems.fixSpelling,\n        aiChatItems.simplifyLanguage,\n      ],\n    },\n  ],\n  selectionSuggestion: [\n    {\n      items: [\n        aiChatItems.replace,\n        aiChatItems.insertBelow,\n        aiChatItems.discard,\n        aiChatItems.tryAgain,\n      ],\n    },\n  ],\n}\n\nexport const AIMenuItems = ({\n  aiEditorRef,\n  setValue,\n}: {\n  aiEditorRef: React.MutableRefObject<PlateEditor | null>\n  setValue: (value: string) => void\n}) => {\n  const { editor, useOption } = useEditorPlugin(AIChatPlugin)\n  const { messages } = useOption('chat')\n  const isSelecting = useIsSelecting()\n\n  const menuState = useMemo(() => {\n    if (messages && messages.length > 0) {\n      return isSelecting ? 'selectionSuggestion' : 'cursorSuggestion'\n    }\n\n    return isSelecting ? 'selectionCommand' : 'cursorCommand'\n  }, [isSelecting, messages])\n\n  const menuGroups = useMemo(() => {\n    const items = menuStateItems[menuState]\n\n    return items\n  }, [menuState])\n\n  useEffect(() => {\n    if (menuGroups.length > 0 && menuGroups[0].items.length > 0) {\n      setValue(menuGroups[0].items[0].value)\n    }\n  }, [menuGroups, setValue])\n\n  return (\n    <>\n      {menuGroups.map((group, index) => (\n        <CommandGroup key={index} heading={group.heading}>\n          {group.items.map((menuItem) => (\n            <CommandItem\n              key={menuItem.value}\n              className=\"[&_svg]:text-muted-foreground\"\n              value={menuItem.value}\n              onSelect={() => {\n                menuItem.onSelect?.({\n                  aiEditor: aiEditorRef.current!,\n                  editor: editor,\n                })\n              }}\n            >\n              {menuItem.icon}\n              <span>{menuItem.label}</span>\n            </CommandItem>\n          ))}\n        </CommandGroup>\n      ))}\n    </>\n  )\n}\n","'use client'\n\nimport { BaseMessage } from '@langchain/core/messages'\nimport { withProps } from '@udecode/cn'\nimport { AIChatPlugin, AIPlugin } from '@udecode/plate-ai/react'\nimport {\n  BoldPlugin,\n  CodePlugin,\n  ItalicPlugin,\n  StrikethroughPlugin,\n  UnderlinePlugin,\n} from '@udecode/plate-basic-marks/react'\nimport { BlockquotePlugin } from '@udecode/plate-block-quote/react'\nimport { CodeBlockPlugin, CodeLinePlugin, CodeSyntaxPlugin } from '@udecode/plate-code-block/react'\nimport { ParagraphPlugin, PlateLeaf, createPlateEditor } from '@udecode/plate-common/react'\nimport { HEADING_KEYS } from '@udecode/plate-heading'\nimport { HorizontalRulePlugin } from '@udecode/plate-horizontal-rule/react'\nimport { LinkPlugin } from '@udecode/plate-link/react'\nimport { MarkdownPlugin } from '@udecode/plate-markdown'\n\nimport { AIMenu } from 'src/lib/plate-ui/ui/ai-menu'\nimport { BlockquoteElement } from 'src/lib/plate-ui/ui/blockquote-element'\nimport { CodeBlockElement } from 'src/lib/plate-ui/ui/code-block-element'\nimport { CodeLeaf } from 'src/lib/plate-ui/ui/code-leaf'\nimport { CodeLineElement } from 'src/lib/plate-ui/ui/code-line-element'\nimport { CodeSyntaxLeaf } from 'src/lib/plate-ui/ui/code-syntax-leaf'\nimport { HeadingElement } from 'src/lib/plate-ui/ui/heading-element'\nimport { HrElement } from 'src/lib/plate-ui/ui/hr-element'\nimport { LinkElement } from 'src/lib/plate-ui/ui/link-element'\nimport { ParagraphElement } from 'src/lib/plate-ui/ui/paragraph-element'\n\nimport { basicNodesPlugins } from './basic-nodes-plugins'\nimport { blockSelectionReadOnlyPlugin } from './block-selection-plugins'\nimport { indentListPlugins } from './indent-list-plugins'\nimport { linkPlugin } from './link-plugin'\nimport { cursorOverlayPlugin } from './cursor-overlay-plugin'\n\nconst createAIEditor = () => {\n  const editor = createPlateEditor({\n    id: 'ai',\n    override: {\n      components: {\n        [BlockquotePlugin.key]: BlockquoteElement,\n        [BoldPlugin.key]: withProps(PlateLeaf, { as: 'strong' }),\n        [CodeBlockPlugin.key]: CodeBlockElement,\n        [CodeLinePlugin.key]: CodeLineElement,\n        [CodePlugin.key]: CodeLeaf,\n        [CodeSyntaxPlugin.key]: CodeSyntaxLeaf,\n        [HEADING_KEYS.h1]: withProps(HeadingElement, { variant: 'h1' }),\n        [HEADING_KEYS.h2]: withProps(HeadingElement, { variant: 'h2' }),\n        [HEADING_KEYS.h3]: withProps(HeadingElement, { variant: 'h3' }),\n        [HorizontalRulePlugin.key]: HrElement,\n        [ItalicPlugin.key]: withProps(PlateLeaf, { as: 'em' }),\n        [LinkPlugin.key]: LinkElement,\n        [ParagraphPlugin.key]: ParagraphElement,\n        [StrikethroughPlugin.key]: withProps(PlateLeaf, { as: 's' }),\n        [UnderlinePlugin.key]: withProps(PlateLeaf, { as: 'u' }),\n      },\n    },\n    plugins: [\n      ...basicNodesPlugins,\n      ...indentListPlugins,\n      HorizontalRulePlugin,\n      linkPlugin,\n      MarkdownPlugin.configure({ options: { indentList: true } }),\n      blockSelectionReadOnlyPlugin,\n    ],\n  })\n\n  return editor\n}\n\nconst systemCommon = `\\\nYou are an advanced AI-powered note-taking assistant, designed to enhance productivity and creativity in note management.\nRespond directly to user prompts with clear, concise, and relevant content. Maintain a neutral, helpful tone.\n\nRules:\n- <Document> is the entire note the user is working on.\n- <Reminder> is a reminder of how you should reply to INSTRUCTIONS. It does not apply to questions.\n- Anything else is the user prompt.\n- Your response should be tailored to the user's prompt, providing precise assistance to optimize note management.\n- For INSTRUCTIONS: Follow the <Reminder> exactly. Provide ONLY the content to be inserted or replaced. No explanations or comments.\n- For QUESTIONS: Provide a helpful and concise answer. You may include brief explanations if necessary.\n- CRITICAL: Distinguish between INSTRUCTIONS and QUESTIONS. Instructions typically ask you to modify or add content. Questions ask for information or clarification.\n`\n\nconst systemDefault = `\\\n${systemCommon}\n- <Block> is the current block of text the user is working on.\n- Ensure your output can seamlessly fit into the existing <Block> structure.\n- CRITICAL: Provide only a single block of text. DO NOT create multiple paragraphs or separate blocks.\n<Block>\n{block}\n</Block>\n`\n\nconst systemSelecting = `\\\n${systemCommon}\n- <Block> is the block of text containing the user's selection, providing context.\n- Ensure your output can seamlessly fit into the existing <Block> structure.\n- <Selection> is the specific text the user has selected in the block and wants to modify or ask about.\n- Consider the context provided by <Block>, but only modify <Selection>. Your response should be a direct replacement for <Selection>.\n<Block>\n{block}\n</Block>\n<Selection>\n{selection}\n</Selection>\n`\n\nconst systemBlockSelecting = `\\\n${systemCommon}\n- <Selection> represents the full blocks of text the user has selected and wants to modify or ask about.\n- Your response should be a direct replacement for the entire <Selection>.\n- Maintain the overall structure and formatting of the selected blocks, unless explicitly instructed otherwise.\n- CRITICAL: Provide only the content to replace <Selection>. Do not add additional blocks or change the block structure unless specifically requested.\n<Selection>\n{block}\n</Selection>\n`\n\nconst userDefault = `<Reminder>\nCRITICAL: DO NOT use block formatting. You can only use inline formatting.\nCRITICAL: DO NOT start new lines or paragraphs.\nNEVER write <Block>.\n</Reminder>\n{prompt}`\n\nconst userSelecting = `<Reminder>\nIf this is a question, provide a helpful and concise answer about <Selection>.\nIf this is an instruction, provide ONLY the text to replace <Selection>. No explanations.\nEnsure it fits seamlessly within <Block>. If <Block> is empty, write ONE random sentence.\nNEVER write <Block> or <Selection>.\n</Reminder>\n{prompt} about <Selection>`\n\nconst userBlockSelecting = `<Reminder>\nIf this is a question, provide a helpful and concise answer about <Selection>.\nIf this is an instruction, provide ONLY the content to replace the entire <Selection>. No explanations.\nMaintain the overall structure unless instructed otherwise.\nNEVER write <Block> or <Selection>.\n</Reminder>\n{prompt} about <Selection>`\n\nexport const PROMPT_TEMPLATES = {\n  systemBlockSelecting,\n  systemDefault,\n  systemSelecting,\n  userBlockSelecting,\n  userDefault,\n  userSelecting,\n}\n\nexport const buildAIPlugins = ({\n  copilotStream,\n}: {\n  copilotStream?: (\n    message: string | BaseMessage[],\n    onMessageUpdate: (chunk: string) => void,\n  ) => void\n}) => {\n  return [\n    cursorOverlayPlugin,\n    MarkdownPlugin.configure({ options: { indentList: true } }),\n    AIPlugin,\n    AIChatPlugin.configure({\n      options: {\n        createAIEditor,\n        promptTemplate: ({ isBlockSelecting, isSelecting }) => {\n          return isBlockSelecting\n            ? PROMPT_TEMPLATES.userBlockSelecting\n            : isSelecting\n              ? PROMPT_TEMPLATES.userSelecting\n              : PROMPT_TEMPLATES.userDefault\n        },\n        systemTemplate: ({ isBlockSelecting, isSelecting }) => {\n          return isBlockSelecting\n            ? PROMPT_TEMPLATES.systemBlockSelecting\n            : isSelecting\n              ? PROMPT_TEMPLATES.systemSelecting\n              : PROMPT_TEMPLATES.systemDefault\n        },\n      },\n      render: { afterEditable: () => <AIMenu copilotStream={copilotStream} /> },\n    }),\n  ] as const\n}\n","'use client'\n\nimport type { TElement } from '@udecode/plate-common'\n\nimport { CopilotPlugin } from '@udecode/plate-ai/react'\nimport { getAncestorNode } from '@udecode/plate-common'\nimport { serializeMdNodes, stripMarkdown } from '@udecode/plate-markdown'\n\nimport { GhostText } from 'src/lib/plate-ui/ui/ghost-text'\n\nexport const copilotPlugins = [\n  CopilotPlugin.configure(({ api }) => ({\n    options: {\n      completeOptions: {\n        api: '/api/ai/copilot',\n        body: {\n          system: `You are an advanced AI writing assistant, similar to VSCode Copilot but for general text. Your task is to predict and generate the next part of the text based on the given context.\n  \n  Rules:\n  - Continue the text naturally up to the next punctuation mark (., ,, ;, :, ?, or !).\n  - Maintain style and tone. Don't repeat given text.\n  - For unclear context, provide the most likely continuation.\n  - Handle code snippets, lists, or structured text if needed.\n  - Don't include \"\"\" in your response.\n  - CRITICAL: Always end with a punctuation mark.\n  - CRITICAL: Avoid starting a new block. Do not use block formatting like >, #, 1., 2., -, etc. The suggestion should continue in the same block as the context.\n  - If no context is provided or you can't generate a continuation, return \"0\" without explanation.`,\n        },\n        onError: () => {\n          api.copilot.setBlockSuggestion({\n            text: stripMarkdown(''),\n          })\n        },\n        onFinish: (_, completion) => {\n          if (completion === '0') return\n\n          api.copilot.setBlockSuggestion({\n            text: stripMarkdown(completion),\n          })\n        },\n      },\n      debounceDelay: 500,\n      getPrompt: ({ editor }) => {\n        const contextEntry = getAncestorNode(editor)\n\n        if (!contextEntry) return ''\n\n        const prompt = serializeMdNodes([contextEntry[0] as TElement])\n\n        return `Continue the text up to the next punctuation mark:\n  \"\"\"\n  ${prompt}\n  \"\"\"`\n      },\n      renderGhostText: GhostText,\n    },\n  })),\n] as const\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = assertString;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction assertString(input) {\n  var isString = typeof input === 'string' || input instanceof String;\n  if (!isString) {\n    var invalidType = _typeof(input);\n    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;\n    throw new TypeError(\"Expected a string but received a \".concat(invalidType));\n  }\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toDate;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction toDate(date) {\n  (0, _assertString.default)(date);\n  date = Date.parse(date);\n  return !isNaN(date) ? new Date(date) : null;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.farsiLocales = exports.englishLocales = exports.dotDecimal = exports.decimal = exports.commaDecimal = exports.bengaliLocales = exports.arabicLocales = exports.alphanumeric = exports.alpha = void 0;\nvar alpha = exports.alpha = {\n  'en-US': /^[A-Z]+$/i,\n  'az-AZ': /^[A-VXYZ]+$/i,\n  'bg-BG': /^[-]+$/i,\n  'cs-CZ': /^[A-Z]+$/i,\n  'da-DK': /^[A-Z]+$/i,\n  'de-DE': /^[A-Z]+$/i,\n  'el-GR': /^[-]+$/i,\n  'es-ES': /^[A-Z]+$/i,\n  'fa-IR': /^[]+$/i,\n  'fi-FI': /^[A-Z]+$/i,\n  'fr-FR': /^[A-Z]+$/i,\n  'it-IT': /^[A-Z]+$/i,\n  'ja-JP': /^[----]+$/i,\n  'nb-NO': /^[A-Z]+$/i,\n  'nl-NL': /^[A-Z]+$/i,\n  'nn-NO': /^[A-Z]+$/i,\n  'hu-HU': /^[A-Z]+$/i,\n  'pl-PL': /^[A-Z]+$/i,\n  'pt-PT': /^[A-Z]+$/i,\n  'ru-RU': /^[-]+$/i,\n  'kk-KZ': /^[-\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA]+$/i,\n  'sl-SI': /^[A-Z]+$/i,\n  'sk-SK': /^[A-Z]+$/i,\n  'sr-RS@latin': /^[A-Z]+$/i,\n  'sr-RS': /^[-]+$/i,\n  'sv-SE': /^[A-Z]+$/i,\n  'th-TH': /^[-\\s]+$/i,\n  'tr-TR': /^[A-Z]+$/i,\n  'uk-UA': /^[-I]+$/i,\n  'vi-VN': /^[A-Z]+$/i,\n  'ko-KR': /^[---]*$/,\n  'ku-IQ': /^[]+$/i,\n  ar: /^[]+$/,\n  he: /^[-]+$/,\n  fa: /^['']+$/i,\n  bn: /^['']+$/,\n  eo: /^[ABCD-GHIJK-PRSTUVZ]+$/i,\n  'hi-IN': /^[\\u0900-\\u0961]+[\\u0972-\\u097F]*$/i,\n  'si-LK': /^[\\u0D80-\\u0DFF]+$/\n};\nvar alphanumeric = exports.alphanumeric = {\n  'en-US': /^[0-9A-Z]+$/i,\n  'az-AZ': /^[0-9A-VXYZ]+$/i,\n  'bg-BG': /^[0-9-]+$/i,\n  'cs-CZ': /^[0-9A-Z]+$/i,\n  'da-DK': /^[0-9A-Z]+$/i,\n  'de-DE': /^[0-9A-Z]+$/i,\n  'el-GR': /^[0-9-]+$/i,\n  'es-ES': /^[0-9A-Z]+$/i,\n  'fi-FI': /^[0-9A-Z]+$/i,\n  'fr-FR': /^[0-9A-Z]+$/i,\n  'it-IT': /^[0-9A-Z]+$/i,\n  'ja-JP': /^[0-9-----]+$/i,\n  'hu-HU': /^[0-9A-Z]+$/i,\n  'nb-NO': /^[0-9A-Z]+$/i,\n  'nl-NL': /^[0-9A-Z]+$/i,\n  'nn-NO': /^[0-9A-Z]+$/i,\n  'pl-PL': /^[0-9A-Z]+$/i,\n  'pt-PT': /^[0-9A-Z]+$/i,\n  'ru-RU': /^[0-9-]+$/i,\n  'kk-KZ': /^[0-9-\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA]+$/i,\n  'sl-SI': /^[0-9A-Z]+$/i,\n  'sk-SK': /^[0-9A-Z]+$/i,\n  'sr-RS@latin': /^[0-9A-Z]+$/i,\n  'sr-RS': /^[0-9-]+$/i,\n  'sv-SE': /^[0-9A-Z]+$/i,\n  'th-TH': /^[-\\s]+$/i,\n  'tr-TR': /^[0-9A-Z]+$/i,\n  'uk-UA': /^[0-9-I]+$/i,\n  'ko-KR': /^[0-9---]*$/,\n  'ku-IQ': /^[0-9]+$/i,\n  'vi-VN': /^[0-9A-Z]+$/i,\n  ar: /^[0-9]+$/,\n  he: /^[0-9-]+$/,\n  fa: /^['0-9']+$/i,\n  bn: /^['']+$/,\n  eo: /^[0-9ABCD-GHIJK-PRSTUVZ]+$/i,\n  'hi-IN': /^[\\u0900-\\u0963]+[\\u0966-\\u097F]*$/i,\n  'si-LK': /^[0-9\\u0D80-\\u0DFF]+$/\n};\nvar decimal = exports.decimal = {\n  'en-US': '.',\n  ar: ''\n};\nvar englishLocales = exports.englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];\nfor (var locale, i = 0; i < englishLocales.length; i++) {\n  locale = \"en-\".concat(englishLocales[i]);\n  alpha[locale] = alpha['en-US'];\n  alphanumeric[locale] = alphanumeric['en-US'];\n  decimal[locale] = decimal['en-US'];\n}\n\n// Source: http://www.localeplanet.com/java/\nvar arabicLocales = exports.arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];\nfor (var _locale, _i = 0; _i < arabicLocales.length; _i++) {\n  _locale = \"ar-\".concat(arabicLocales[_i]);\n  alpha[_locale] = alpha.ar;\n  alphanumeric[_locale] = alphanumeric.ar;\n  decimal[_locale] = decimal.ar;\n}\nvar farsiLocales = exports.farsiLocales = ['IR', 'AF'];\nfor (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {\n  _locale2 = \"fa-\".concat(farsiLocales[_i2]);\n  alphanumeric[_locale2] = alphanumeric.fa;\n  decimal[_locale2] = decimal.ar;\n}\nvar bengaliLocales = exports.bengaliLocales = ['BD', 'IN'];\nfor (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {\n  _locale3 = \"bn-\".concat(bengaliLocales[_i3]);\n  alpha[_locale3] = alpha.bn;\n  alphanumeric[_locale3] = alphanumeric.bn;\n  decimal[_locale3] = decimal['en-US'];\n}\n\n// Source: https://en.wikipedia.org/wiki/Decimal_mark\nvar dotDecimal = exports.dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];\nvar commaDecimal = exports.commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'id-ID', 'it-IT', 'ku-IQ', 'hi-IN', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'kk-KZ', 'si-LK', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN'];\nfor (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {\n  decimal[dotDecimal[_i4]] = decimal['en-US'];\n}\nfor (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {\n  decimal[commaDecimal[_i5]] = ',';\n}\nalpha['fr-CA'] = alpha['fr-FR'];\nalphanumeric['fr-CA'] = alphanumeric['fr-FR'];\nalpha['pt-BR'] = alpha['pt-PT'];\nalphanumeric['pt-BR'] = alphanumeric['pt-PT'];\ndecimal['pt-BR'] = decimal['pt-PT'];\n\n// see #862\nalpha['pl-Pl'] = alpha['pl-PL'];\nalphanumeric['pl-Pl'] = alphanumeric['pl-PL'];\ndecimal['pl-Pl'] = decimal['pl-PL'];\n\n// see #1455\nalpha['fa-AF'] = alpha.fa;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isFloat;\nexports.locales = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _alpha = require(\"./alpha\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isFloat(str, options) {\n  (0, _assertString.default)(str);\n  options = options || {};\n  var float = new RegExp(\"^(?:[-+])?(?:[0-9]+)?(?:\\\\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', \"[0-9]*)?(?:[eE][\\\\+\\\\-]?(?:[0-9]+))?$\"));\n  if (str === '' || str === '.' || str === ',' || str === '-' || str === '+') {\n    return false;\n  }\n  var value = parseFloat(str.replace(',', '.'));\n  return float.test(str) && (!options.hasOwnProperty('min') || value >= options.min) && (!options.hasOwnProperty('max') || value <= options.max) && (!options.hasOwnProperty('lt') || value < options.lt) && (!options.hasOwnProperty('gt') || value > options.gt);\n}\nvar locales = exports.locales = Object.keys(_alpha.decimal);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toFloat;\nvar _isFloat = _interopRequireDefault(require(\"./isFloat\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction toFloat(str) {\n  if (!(0, _isFloat.default)(str)) return NaN;\n  return parseFloat(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toInt;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction toInt(str, radix) {\n  (0, _assertString.default)(str);\n  return parseInt(str, radix || 10);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toBoolean;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction toBoolean(str, strict) {\n  (0, _assertString.default)(str);\n  if (strict) {\n    return str === '1' || /^true$/i.test(str);\n  }\n  return str !== '0' && !/^false$/i.test(str) && str !== '';\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = equals;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction equals(str, comparison) {\n  (0, _assertString.default)(str);\n  return str === comparison;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toString;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction toString(input) {\n  if (_typeof(input) === 'object' && input !== null) {\n    if (typeof input.toString === 'function') {\n      input = input.toString();\n    } else {\n      input = '[object Object]';\n    }\n  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {\n    input = '';\n  }\n  return String(input);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = merge;\nfunction merge() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaults = arguments.length > 1 ? arguments[1] : undefined;\n  for (var key in defaults) {\n    if (typeof obj[key] === 'undefined') {\n      obj[key] = defaults[key];\n    }\n  }\n  return obj;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = contains;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _toString = _interopRequireDefault(require(\"./util/toString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar defaulContainsOptions = {\n  ignoreCase: false,\n  minOccurrences: 1\n};\nfunction contains(str, elem, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, defaulContainsOptions);\n  if (options.ignoreCase) {\n    return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;\n  }\n  return str.split((0, _toString.default)(elem)).length > options.minOccurrences;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = matches;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction matches(str, pattern, modifiers) {\n  (0, _assertString.default)(str);\n  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {\n    pattern = new RegExp(pattern, modifiers);\n  }\n  return !!str.match(pattern);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isByteLength;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/* eslint-disable prefer-rest-params */\nfunction isByteLength(str, options) {\n  (0, _assertString.default)(str);\n  var min;\n  var max;\n  if (_typeof(options) === 'object') {\n    min = options.min || 0;\n    max = options.max;\n  } else {\n    // backwards compatibility: isByteLength(str, min [, max])\n    min = arguments[1];\n    max = arguments[2];\n  }\n  var len = encodeURI(str).split(/%..|./).length - 1;\n  return len >= min && (typeof max === 'undefined' || len <= max);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isFQDN;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar default_fqdn_options = {\n  require_tld: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_numeric_tld: false,\n  allow_wildcard: false,\n  ignore_max_length: false\n};\nfunction isFQDN(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_fqdn_options);\n\n  /* Remove the optional trailing dot before checking validity */\n  if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n    str = str.substring(0, str.length - 1);\n  }\n\n  /* Remove the optional wildcard before checking validity */\n  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {\n    str = str.substring(2);\n  }\n  var parts = str.split('.');\n  var tld = parts[parts.length - 1];\n  if (options.require_tld) {\n    // disallow fqdns without tld\n    if (parts.length < 2) {\n      return false;\n    }\n    if (!options.allow_numeric_tld && !/^([a-z\\u00A1-\\u00A8\\u00AA-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n      return false;\n    }\n\n    // disallow spaces\n    if (/\\s/.test(tld)) {\n      return false;\n    }\n  }\n\n  // reject numeric TLDs\n  if (!options.allow_numeric_tld && /^\\d+$/.test(tld)) {\n    return false;\n  }\n  return parts.every(function (part) {\n    if (part.length > 63 && !options.ignore_max_length) {\n      return false;\n    }\n    if (!/^[a-z_\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n      return false;\n    }\n\n    // disallow full-width chars\n    if (/[\\uff01-\\uff5e]/.test(part)) {\n      return false;\n    }\n\n    // disallow parts starting or ending with hyphen\n    if (/^-|-$/.test(part)) {\n      return false;\n    }\n    if (!options.allow_underscores && /_/.test(part)) {\n      return false;\n    }\n    return true;\n  });\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIP;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n11.3.  Examples\n\n   The following addresses\n\n             fe80::1234 (on the 1st link of the node)\n             ff02::5678 (on the 5th link of the node)\n             ff08::9abc (on the 10th organization of the node)\n\n   would be represented as follows:\n\n             fe80::1234%1\n             ff02::5678%5\n             ff08::9abc%10\n\n   (Here we assume a natural translation from a zone index to the\n   <zone_id> part, where the Nth zone of any scope is translated into\n   \"N\".)\n\n   If we use interface names as <zone_id>, those addresses could also be\n   represented as follows:\n\n            fe80::1234%ne0\n            ff02::5678%pvc1.3\n            ff08::9abc%interface10\n\n   where the interface \"ne0\" belongs to the 1st link, \"pvc1.3\" belongs\n   to the 5th link, and \"interface10\" belongs to the 10th organization.\n * * */\nvar IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nvar IPv4AddressFormat = \"(\".concat(IPv4SegmentFormat, \"[.]){3}\").concat(IPv4SegmentFormat);\nvar IPv4AddressRegExp = new RegExp(\"^\".concat(IPv4AddressFormat, \"$\"));\nvar IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';\nvar IPv6AddressRegExp = new RegExp('^(' + \"(?:\".concat(IPv6SegmentFormat, \":){7}(?:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){6}(?:\").concat(IPv4AddressFormat, \"|:\").concat(IPv6SegmentFormat, \"|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){5}(?::\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,2}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){4}(?:(:\").concat(IPv6SegmentFormat, \"){0,1}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,3}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){3}(?:(:\").concat(IPv6SegmentFormat, \"){0,2}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,4}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){2}(?:(:\").concat(IPv6SegmentFormat, \"){0,3}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,5}|:)|\") + \"(?:\".concat(IPv6SegmentFormat, \":){1}(?:(:\").concat(IPv6SegmentFormat, \"){0,4}:\").concat(IPv4AddressFormat, \"|(:\").concat(IPv6SegmentFormat, \"){1,6}|:)|\") + \"(?::((?::\".concat(IPv6SegmentFormat, \"){0,5}:\").concat(IPv4AddressFormat, \"|(?::\").concat(IPv6SegmentFormat, \"){1,7}|:))\") + ')(%[0-9a-zA-Z-.:]{1,})?$');\nfunction isIP(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  (0, _assertString.default)(str);\n  version = String(version);\n  if (!version) {\n    return isIP(str, 4) || isIP(str, 6);\n  }\n  if (version === '4') {\n    return IPv4AddressRegExp.test(str);\n  }\n  if (version === '6') {\n    return IPv6AddressRegExp.test(str);\n  }\n  return false;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isEmail;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _isByteLength = _interopRequireDefault(require(\"./isByteLength\"));\nvar _isFQDN = _interopRequireDefault(require(\"./isFQDN\"));\nvar _isIP = _interopRequireDefault(require(\"./isIP\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar default_email_options = {\n  allow_display_name: false,\n  allow_underscores: false,\n  require_display_name: false,\n  allow_utf8_local_part: true,\n  require_tld: true,\n  blacklisted_chars: '',\n  ignore_max_length: false,\n  host_blacklist: [],\n  host_whitelist: []\n};\n\n/* eslint-disable max-len */\n/* eslint-disable no-control-regex */\nvar splitNameAddress = /^([^\\x00-\\x1F\\x7F-\\x9F\\cX]+)</i;\nvar emailUserPart = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]+$/i;\nvar gmailUserPart = /^[a-z\\d]+$/;\nvar quotedEmailUser = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]))*$/i;\nvar emailUserUtf8Part = /^[a-z\\d!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\u00A1-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+$/i;\nvar quotedEmailUserUtf8 = /^([\\s\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f\\x21\\x23-\\x5b\\x5d-\\x7e\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))*$/i;\nvar defaultMaxEmailLength = 254;\n/* eslint-enable max-len */\n/* eslint-enable no-control-regex */\n\n/**\n * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2\n * @param {String} display_name\n */\nfunction validateDisplayName(display_name) {\n  var display_name_without_quotes = display_name.replace(/^\"(.+)\"$/, '$1');\n  // display name with only spaces is not valid\n  if (!display_name_without_quotes.trim()) {\n    return false;\n  }\n\n  // check whether display name contains illegal character\n  var contains_illegal = /[\\.\";<>]/.test(display_name_without_quotes);\n  if (contains_illegal) {\n    // if contains illegal characters,\n    // must to be enclosed in double-quotes, otherwise it's not a valid display name\n    if (display_name_without_quotes === display_name) {\n      return false;\n    }\n\n    // the quotes in display name must start with character symbol \\\n    var all_start_with_back_slash = display_name_without_quotes.split('\"').length === display_name_without_quotes.split('\\\\\"').length;\n    if (!all_start_with_back_slash) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isEmail(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_email_options);\n  if (options.require_display_name || options.allow_display_name) {\n    var display_email = str.match(splitNameAddress);\n    if (display_email) {\n      var display_name = display_email[1];\n\n      // Remove display name and angle brackets to get email address\n      // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)\n      str = str.replace(display_name, '').replace(/(^<|>$)/g, '');\n\n      // sometimes need to trim the last space to get the display name\n      // because there may be a space between display name and email address\n      // eg. myname <address@gmail.com>\n      // the display name is `myname` instead of `myname `, so need to trim the last space\n      if (display_name.endsWith(' ')) {\n        display_name = display_name.slice(0, -1);\n      }\n      if (!validateDisplayName(display_name)) {\n        return false;\n      }\n    } else if (options.require_display_name) {\n      return false;\n    }\n  }\n  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {\n    return false;\n  }\n  var parts = str.split('@');\n  var domain = parts.pop();\n  var lower_domain = domain.toLowerCase();\n  if (options.host_blacklist.includes(lower_domain)) {\n    return false;\n  }\n  if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {\n    return false;\n  }\n  var user = parts.join('@');\n  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {\n    /*\n      Previously we removed dots for gmail addresses before validating.\n      This was removed because it allows `multiple..dots@gmail.com`\n      to be reported as valid, but it is not.\n      Gmail only normalizes single dots, removing them from here is pointless,\n      should be done in normalizeEmail\n    */\n    user = user.toLowerCase();\n\n    // Removing sub-address from username before gmail validation\n    var username = user.split('+')[0];\n\n    // Dots are not included in gmail length restriction\n    if (!(0, _isByteLength.default)(username.replace(/\\./g, ''), {\n      min: 6,\n      max: 30\n    })) {\n      return false;\n    }\n    var _user_parts = username.split('.');\n    for (var i = 0; i < _user_parts.length; i++) {\n      if (!gmailUserPart.test(_user_parts[i])) {\n        return false;\n      }\n    }\n  }\n  if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {\n    max: 64\n  }) || !(0, _isByteLength.default)(domain, {\n    max: 254\n  }))) {\n    return false;\n  }\n  if (!(0, _isFQDN.default)(domain, {\n    require_tld: options.require_tld,\n    ignore_max_length: options.ignore_max_length,\n    allow_underscores: options.allow_underscores\n  })) {\n    if (!options.allow_ip_domain) {\n      return false;\n    }\n    if (!(0, _isIP.default)(domain)) {\n      if (!domain.startsWith('[') || !domain.endsWith(']')) {\n        return false;\n      }\n      var noBracketdomain = domain.slice(1, -1);\n      if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {\n        return false;\n      }\n    }\n  }\n  if (user[0] === '\"') {\n    user = user.slice(1, user.length - 1);\n    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);\n  }\n  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;\n  var user_parts = user.split('.');\n  for (var _i = 0; _i < user_parts.length; _i++) {\n    if (!pattern.test(user_parts[_i])) {\n      return false;\n    }\n  }\n  if (options.blacklisted_chars) {\n    if (user.search(new RegExp(\"[\".concat(options.blacklisted_chars, \"]+\"), 'g')) !== -1) return false;\n  }\n  return true;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isURL;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _isFQDN = _interopRequireDefault(require(\"./isFQDN\"));\nvar _isIP = _interopRequireDefault(require(\"./isIP\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n/*\noptions for isURL method\n\nrequire_protocol - if set as true isURL will return false if protocol is not present in the URL\nrequire_valid_protocol - isURL will check if the URL's protocol is present in the protocols option\nprotocols - valid protocols can be modified with this option\nrequire_host - if set as false isURL will not check if host is present in the URL\nrequire_port - if set as true isURL will check if port is present in the URL\nallow_protocol_relative_urls - if set as true protocol relative URLs will be allowed\nvalidate_length - if set as false isURL will skip string length validation (IE maximum is 2083)\n\n*/\n\nvar default_url_options = {\n  protocols: ['http', 'https', 'ftp'],\n  require_tld: true,\n  require_protocol: false,\n  require_host: true,\n  require_port: false,\n  require_valid_protocol: true,\n  allow_underscores: false,\n  allow_trailing_dot: false,\n  allow_protocol_relative_urls: false,\n  allow_fragments: true,\n  allow_query_components: true,\n  validate_length: true\n};\nvar wrapped_ipv6 = /^\\[([^\\]]+)\\](?::([0-9]+))?$/;\nfunction isRegExp(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n}\nfunction checkHost(host, matches) {\n  for (var i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    if (host === match || isRegExp(match) && match.test(host)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isURL(url, options) {\n  (0, _assertString.default)(url);\n  if (!url || /[\\s<>]/.test(url)) {\n    return false;\n  }\n  if (url.indexOf('mailto:') === 0) {\n    return false;\n  }\n  options = (0, _merge.default)(options, default_url_options);\n  if (options.validate_length && url.length >= 2083) {\n    return false;\n  }\n  if (!options.allow_fragments && url.includes('#')) {\n    return false;\n  }\n  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {\n    return false;\n  }\n  var protocol, auth, host, hostname, port, port_str, split, ipv6;\n  split = url.split('#');\n  url = split.shift();\n  split = url.split('?');\n  url = split.shift();\n  split = url.split('://');\n  if (split.length > 1) {\n    protocol = split.shift().toLowerCase();\n    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n      return false;\n    }\n  } else if (options.require_protocol) {\n    return false;\n  } else if (url.slice(0, 2) === '//') {\n    if (!options.allow_protocol_relative_urls) {\n      return false;\n    }\n    split[0] = url.slice(2);\n  }\n  url = split.join('://');\n  if (url === '') {\n    return false;\n  }\n  split = url.split('/');\n  url = split.shift();\n  if (url === '' && !options.require_host) {\n    return true;\n  }\n  split = url.split('@');\n  if (split.length > 1) {\n    if (options.disallow_auth) {\n      return false;\n    }\n    if (split[0] === '') {\n      return false;\n    }\n    auth = split.shift();\n    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n      return false;\n    }\n    var _auth$split = auth.split(':'),\n      _auth$split2 = _slicedToArray(_auth$split, 2),\n      user = _auth$split2[0],\n      password = _auth$split2[1];\n    if (user === '' && password === '') {\n      return false;\n    }\n  }\n  hostname = split.join('@');\n  port_str = null;\n  ipv6 = null;\n  var ipv6_match = hostname.match(wrapped_ipv6);\n  if (ipv6_match) {\n    host = '';\n    ipv6 = ipv6_match[1];\n    port_str = ipv6_match[2] || null;\n  } else {\n    split = hostname.split(':');\n    host = split.shift();\n    if (split.length) {\n      port_str = split.join(':');\n    }\n  }\n  if (port_str !== null && port_str.length > 0) {\n    port = parseInt(port_str, 10);\n    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n      return false;\n    }\n  } else if (options.require_port) {\n    return false;\n  }\n  if (options.host_whitelist) {\n    return checkHost(host, options.host_whitelist);\n  }\n  if (host === '' && !options.require_host) {\n    return true;\n  }\n  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {\n    return false;\n  }\n  host = host || ipv6;\n  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {\n    return false;\n  }\n  return true;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMACAddress;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\\s]))([0-9a-fA-F]{2}\\1){4}([0-9a-fA-F]{2})$/;\nvar macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;\nvar macAddress48WithDots = /^([0-9a-fA-F]{4}\\.){2}([0-9a-fA-F]{4})$/;\nvar macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\\s]))([0-9a-fA-F]{2}\\1){6}([0-9a-fA-F]{2})$/;\nvar macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;\nvar macAddress64WithDots = /^([0-9a-fA-F]{4}\\.){3}([0-9a-fA-F]{4})$/;\nfunction isMACAddress(str, options) {\n  (0, _assertString.default)(str);\n  if (options !== null && options !== void 0 && options.eui) {\n    options.eui = String(options.eui);\n  }\n  /**\n   * @deprecated `no_colons` TODO: remove it in the next major\n  */\n  if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {\n    if (options.eui === '48') {\n      return macAddress48NoSeparators.test(str);\n    }\n    if (options.eui === '64') {\n      return macAddress64NoSeparators.test(str);\n    }\n    return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);\n  }\n  if ((options === null || options === void 0 ? void 0 : options.eui) === '48') {\n    return macAddress48.test(str) || macAddress48WithDots.test(str);\n  }\n  if ((options === null || options === void 0 ? void 0 : options.eui) === '64') {\n    return macAddress64.test(str) || macAddress64WithDots.test(str);\n  }\n  return isMACAddress(str, {\n    eui: '48'\n  }) || isMACAddress(str, {\n    eui: '64'\n  });\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIPRange;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _isIP = _interopRequireDefault(require(\"./isIP\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar subnetMaybe = /^\\d{1,3}$/;\nvar v4Subnet = 32;\nvar v6Subnet = 128;\nfunction isIPRange(str) {\n  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  (0, _assertString.default)(str);\n  var parts = str.split('/');\n\n  // parts[0] -> ip, parts[1] -> subnet\n  if (parts.length !== 2) {\n    return false;\n  }\n  if (!subnetMaybe.test(parts[1])) {\n    return false;\n  }\n\n  // Disallow preceding 0 i.e. 01, 02, ...\n  if (parts[1].length > 1 && parts[1].startsWith('0')) {\n    return false;\n  }\n  var isValidIP = (0, _isIP.default)(parts[0], version);\n  if (!isValidIP) {\n    return false;\n  }\n\n  // Define valid subnet according to IP's version\n  var expectedSubnet = null;\n  switch (String(version)) {\n    case '4':\n      expectedSubnet = v4Subnet;\n      break;\n    case '6':\n      expectedSubnet = v6Subnet;\n      break;\n    default:\n      expectedSubnet = (0, _isIP.default)(parts[0], '6') ? v6Subnet : v4Subnet;\n  }\n  return parts[1] <= expectedSubnet && parts[1] >= 0;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isDate;\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar default_date_options = {\n  format: 'YYYY/MM/DD',\n  delimiters: ['/', '-'],\n  strictMode: false\n};\nfunction isValidFormat(format) {\n  return /(^(y{4}|y{2})[.\\/-](m{1,2})[.\\/-](d{1,2})$)|(^(m{1,2})[.\\/-](d{1,2})[.\\/-]((y{4}|y{2})$))|(^(d{1,2})[.\\/-](m{1,2})[.\\/-]((y{4}|y{2})$))/gi.test(format);\n}\nfunction zip(date, format) {\n  var zippedArr = [],\n    len = Math.min(date.length, format.length);\n  for (var i = 0; i < len; i++) {\n    zippedArr.push([date[i], format[i]]);\n  }\n  return zippedArr;\n}\nfunction isDate(input, options) {\n  if (typeof options === 'string') {\n    // Allow backward compatibility for old format isDate(input [, format])\n    options = (0, _merge.default)({\n      format: options\n    }, default_date_options);\n  } else {\n    options = (0, _merge.default)(options, default_date_options);\n  }\n  if (typeof input === 'string' && isValidFormat(options.format)) {\n    var formatDelimiter = options.delimiters.find(function (delimiter) {\n      return options.format.indexOf(delimiter) !== -1;\n    });\n    var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function (delimiter) {\n      return input.indexOf(delimiter) !== -1;\n    });\n    var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));\n    var dateObj = {};\n    var _iterator = _createForOfIteratorHelper(dateAndFormat),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          dateWord = _step$value[0],\n          formatWord = _step$value[1];\n        if (dateWord.length !== formatWord.length) {\n          return false;\n        }\n        dateObj[formatWord.charAt(0)] = dateWord;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var fullYear = dateObj.y;\n\n    // Check if the year starts with a hyphen\n    if (fullYear.startsWith('-')) {\n      return false; // Hyphen before year is not allowed\n    }\n    if (dateObj.y.length === 2) {\n      var parsedYear = parseInt(dateObj.y, 10);\n      if (isNaN(parsedYear)) {\n        return false;\n      }\n      var currentYearLastTwoDigits = new Date().getFullYear() % 100;\n      if (parsedYear < currentYearLastTwoDigits) {\n        fullYear = \"20\".concat(dateObj.y);\n      } else {\n        fullYear = \"19\".concat(dateObj.y);\n      }\n    }\n    var month = dateObj.m;\n    if (dateObj.m.length === 1) {\n      month = \"0\".concat(dateObj.m);\n    }\n    var day = dateObj.d;\n    if (dateObj.d.length === 1) {\n      day = \"0\".concat(dateObj.d);\n    }\n    return new Date(\"\".concat(fullYear, \"-\").concat(month, \"-\").concat(day, \"T00:00:00.000Z\")).getUTCDate() === +dateObj.d;\n  }\n  if (!options.strictMode) {\n    return Object.prototype.toString.call(input) === '[object Date]' && isFinite(input);\n  }\n  return false;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isTime;\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar default_time_options = {\n  hourFormat: 'hour24',\n  mode: 'default'\n};\nvar formats = {\n  hour24: {\n    default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,\n    withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/\n  },\n  hour12: {\n    default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,\n    withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/\n  }\n};\nfunction isTime(input, options) {\n  options = (0, _merge.default)(options, default_time_options);\n  if (typeof input !== 'string') return false;\n  return formats[options.hourFormat][options.mode].test(input);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBoolean;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar defaultOptions = {\n  loose: false\n};\nvar strictBooleans = ['true', 'false', '1', '0'];\nvar looseBooleans = [].concat(strictBooleans, ['yes', 'no']);\nfunction isBoolean(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  (0, _assertString.default)(str);\n  if (options.loose) {\n    return looseBooleans.includes(str.toLowerCase());\n  }\n  return strictBooleans.includes(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLocale;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*\n  = 3ALPHA              ; selected ISO 639 codes\n    *2(\"-\" 3ALPHA)      ; permanently reserved\n */\nvar extlang = '([A-Za-z]{3}(-[A-Za-z]{3}){0,2})';\n\n/*\n  = 2*3ALPHA            ; shortest ISO 639 code\n    [\"-\" extlang]       ; sometimes followed by\n                        ; extended language subtags\n  / 4ALPHA              ; or reserved for future use\n  / 5*8ALPHA            ; or registered language subtag\n */\nvar language = \"(([a-zA-Z]{2,3}(-\".concat(extlang, \")?)|([a-zA-Z]{5,8}))\");\n\n/*\n  = 4ALPHA              ; ISO 15924 code\n */\nvar script = '([A-Za-z]{4})';\n\n/*\n  = 2ALPHA              ; ISO 3166-1 code\n  / 3DIGIT              ; UN M.49 code\n */\nvar region = '([A-Za-z]{2}|\\\\d{3})';\n\n/*\n  = 5*8alphanum         ; registered variants\n  / (DIGIT 3alphanum)\n */\nvar variant = '([A-Za-z0-9]{5,8}|(\\\\d[A-Z-a-z0-9]{3}))';\n\n/*\n  = DIGIT               ; 0 - 9\n  / %x41-57             ; A - W\n  / %x59-5A             ; Y - Z\n  / %x61-77             ; a - w\n  / %x79-7A             ; y - z\n */\nvar singleton = '(\\\\d|[A-W]|[Y-Z]|[a-w]|[y-z])';\n\n/*\n  = singleton 1*(\"-\" (2*8alphanum))\n                        ; Single alphanumerics\n                        ; \"x\" reserved for private use\n */\nvar extension = \"(\".concat(singleton, \"(-[A-Za-z0-9]{2,8})+)\");\n\n/*\n  = \"x\" 1*(\"-\" (1*8alphanum))\n */\nvar privateuse = '(x(-[A-Za-z0-9]{1,8})+)';\n\n// irregular tags do not match the 'langtag' production and would not\n// otherwise be considered 'well-formed'. These tags are all valid, but\n// most are deprecated in favor of more modern subtags or subtag combination\n\nvar irregular = '((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|' + '(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|' + '(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))';\n\n// regular tags match the 'langtag' production, but their subtags are not\n// extended language or variant subtags: their meaning is defined by\n// their registration and all of these are deprecated in favor of a more\n// modern subtag or sequence of subtags\n\nvar regular = '((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|' + '(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))';\n\n/*\n  = irregular           ; non-redundant tags registered\n  / regular             ; during the RFC 3066 era\n\n */\nvar grandfathered = \"(\".concat(irregular, \"|\").concat(regular, \")\");\n\n/*\n  RFC 5646 defines delimitation of subtags via a hyphen:\n\n      \"Subtag\" refers to a specific section of a tag, delimited by a\n      hyphen, such as the subtags 'zh', 'Hant', and 'CN' in the tag \"zh-\n      Hant-CN\".  Examples of subtags in this document are enclosed in\n      single quotes ('Hant')\n\n  However, we need to add \"_\" to maintain the existing behaviour.\n */\nvar delimiter = '(-|_)';\n\n/*\n  = language\n    [\"-\" script]\n    [\"-\" region]\n    *(\"-\" variant)\n    *(\"-\" extension)\n    [\"-\" privateuse]\n */\nvar langtag = \"\".concat(language, \"(\").concat(delimiter).concat(script, \")?(\").concat(delimiter).concat(region, \")?(\").concat(delimiter).concat(variant, \")*(\").concat(delimiter).concat(extension, \")*(\").concat(delimiter).concat(privateuse, \")?\");\n\n/*\n  Regex implementation based on BCP RFC 5646\n  Tags for Identifying Languages\n  https://www.rfc-editor.org/rfc/rfc5646.html\n */\nvar languageTagRegex = new RegExp(\"(^\".concat(privateuse, \"$)|(^\").concat(grandfathered, \"$)|(^\").concat(langtag, \"$)\"));\nfunction isLocale(str) {\n  (0, _assertString.default)(str);\n  return languageTagRegex.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isAbaRouting;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// http://www.brainjar.com/js/validation/\n// https://www.aba.com/news-research/research-analysis/routing-number-policy-procedures\n// series reserved for future use are excluded\nvar isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;\nfunction isAbaRouting(str) {\n  (0, _assertString.default)(str);\n  if (!isRoutingReg.test(str)) return false;\n  var checkSumVal = 0;\n  for (var i = 0; i < str.length; i++) {\n    if (i % 3 === 0) checkSumVal += str[i] * 3;else if (i % 3 === 1) checkSumVal += str[i] * 7;else checkSumVal += str[i] * 1;\n  }\n  return checkSumVal % 10 === 0;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isAlpha;\nexports.locales = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _alpha = require(\"./alpha\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isAlpha(_str) {\n  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0, _assertString.default)(_str);\n  var str = _str;\n  var ignore = options.ignore;\n  if (ignore) {\n    if (ignore instanceof RegExp) {\n      str = str.replace(ignore, '');\n    } else if (typeof ignore === 'string') {\n      str = str.replace(new RegExp(\"[\".concat(ignore.replace(/[-[\\]{}()*+?.,\\\\^$|#\\\\s]/g, '\\\\$&'), \"]\"), 'g'), ''); // escape regex for ignore\n    } else {\n      throw new Error('ignore should be instance of a String or RegExp');\n    }\n  }\n  if (locale in _alpha.alpha) {\n    return _alpha.alpha[locale].test(str);\n  }\n  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n}\nvar locales = exports.locales = Object.keys(_alpha.alpha);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isAlphanumeric;\nexports.locales = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _alpha = require(\"./alpha\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isAlphanumeric(_str) {\n  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  (0, _assertString.default)(_str);\n  var str = _str;\n  var ignore = options.ignore;\n  if (ignore) {\n    if (ignore instanceof RegExp) {\n      str = str.replace(ignore, '');\n    } else if (typeof ignore === 'string') {\n      str = str.replace(new RegExp(\"[\".concat(ignore.replace(/[-[\\]{}()*+?.,\\\\^$|#\\\\s]/g, '\\\\$&'), \"]\"), 'g'), ''); // escape regex for ignore\n    } else {\n      throw new Error('ignore should be instance of a String or RegExp');\n    }\n  }\n  if (locale in _alpha.alphanumeric) {\n    return _alpha.alphanumeric[locale].test(str);\n  }\n  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n}\nvar locales = exports.locales = Object.keys(_alpha.alphanumeric);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isNumeric;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _alpha = require(\"./alpha\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar numericNoSymbols = /^[0-9]+$/;\nfunction isNumeric(str, options) {\n  (0, _assertString.default)(str);\n  if (options && options.no_symbols) {\n    return numericNoSymbols.test(str);\n  }\n  return new RegExp(\"^[+-]?([0-9]*[\".concat((options || {}).locale ? _alpha.decimal[options.locale] : '.', \"])?[0-9]+$\")).test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isPassportNumber;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Reference:\n * https://en.wikipedia.org/ -- Wikipedia\n * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number\n * https://countrycode.org/ -- Country Codes\n */\nvar passportRegexByCountryCode = {\n  AM: /^[A-Z]{2}\\d{7}$/,\n  // ARMENIA\n  AR: /^[A-Z]{3}\\d{6}$/,\n  // ARGENTINA\n  AT: /^[A-Z]\\d{7}$/,\n  // AUSTRIA\n  AU: /^[A-Z]\\d{7}$/,\n  // AUSTRALIA\n  AZ: /^[A-Z]{1}\\d{8}$/,\n  // AZERBAIJAN\n  BE: /^[A-Z]{2}\\d{6}$/,\n  // BELGIUM\n  BG: /^\\d{9}$/,\n  // BULGARIA\n  BR: /^[A-Z]{2}\\d{6}$/,\n  // BRAZIL\n  BY: /^[A-Z]{2}\\d{7}$/,\n  // BELARUS\n  CA: /^[A-Z]{2}\\d{6}$/,\n  // CANADA\n  CH: /^[A-Z]\\d{7}$/,\n  // SWITZERLAND\n  CN: /^G\\d{8}$|^E(?![IO])[A-Z0-9]\\d{7}$/,\n  // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits\n  CY: /^[A-Z](\\d{6}|\\d{8})$/,\n  // CYPRUS\n  CZ: /^\\d{8}$/,\n  // CZECH REPUBLIC\n  DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,\n  // GERMANY\n  DK: /^\\d{9}$/,\n  // DENMARK\n  DZ: /^\\d{9}$/,\n  // ALGERIA\n  EE: /^([A-Z]\\d{7}|[A-Z]{2}\\d{7})$/,\n  // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits\n  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\\d{6}$/,\n  // SPAIN\n  FI: /^[A-Z]{2}\\d{7}$/,\n  // FINLAND\n  FR: /^\\d{2}[A-Z]{2}\\d{5}$/,\n  // FRANCE\n  GB: /^\\d{9}$/,\n  // UNITED KINGDOM\n  GR: /^[A-Z]{2}\\d{7}$/,\n  // GREECE\n  HR: /^\\d{9}$/,\n  // CROATIA\n  HU: /^[A-Z]{2}(\\d{6}|\\d{7})$/,\n  // HUNGARY\n  IE: /^[A-Z0-9]{2}\\d{7}$/,\n  // IRELAND\n  IN: /^[A-Z]{1}-?\\d{7}$/,\n  // INDIA\n  ID: /^[A-C]\\d{7}$/,\n  // INDONESIA\n  IR: /^[A-Z]\\d{8}$/,\n  // IRAN\n  IS: /^(A)\\d{7}$/,\n  // ICELAND\n  IT: /^[A-Z0-9]{2}\\d{7}$/,\n  // ITALY\n  JM: /^[Aa]\\d{7}$/,\n  // JAMAICA\n  JP: /^[A-Z]{2}\\d{7}$/,\n  // JAPAN\n  KR: /^[MS]\\d{8}$/,\n  // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]\n  KZ: /^[a-zA-Z]\\d{7}$/,\n  // KAZAKHSTAN\n  LI: /^[a-zA-Z]\\d{5}$/,\n  // LIECHTENSTEIN\n  LT: /^[A-Z0-9]{8}$/,\n  // LITHUANIA\n  LU: /^[A-Z0-9]{8}$/,\n  // LUXEMBURG\n  LV: /^[A-Z0-9]{2}\\d{7}$/,\n  // LATVIA\n  LY: /^[A-Z0-9]{8}$/,\n  // LIBYA\n  MT: /^\\d{7}$/,\n  // MALTA\n  MZ: /^([A-Z]{2}\\d{7})|(\\d{2}[A-Z]{2}\\d{5})$/,\n  // MOZAMBIQUE\n  MY: /^[AHK]\\d{8}$/,\n  // MALAYSIA\n  MX: /^\\d{10,11}$/,\n  // MEXICO\n  NL: /^[A-Z]{2}[A-Z0-9]{6}\\d$/,\n  // NETHERLANDS\n  NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\\d{6}$/,\n  // NEW ZEALAND\n  PH: /^([A-Z](\\d{6}|\\d{7}[A-Z]))|([A-Z]{2}(\\d{6}|\\d{7}))$/,\n  // PHILIPPINES\n  PK: /^[A-Z]{2}\\d{7}$/,\n  // PAKISTAN\n  PL: /^[A-Z]{2}\\d{7}$/,\n  // POLAND\n  PT: /^[A-Z]\\d{6}$/,\n  // PORTUGAL\n  RO: /^\\d{8,9}$/,\n  // ROMANIA\n  RU: /^\\d{9}$/,\n  // RUSSIAN FEDERATION\n  SE: /^\\d{8}$/,\n  // SWEDEN\n  SL: /^(P)[A-Z]\\d{7}$/,\n  // SLOVENIA\n  SK: /^[0-9A-Z]\\d{7}$/,\n  // SLOVAKIA\n  TH: /^[A-Z]{1,2}\\d{6,7}$/,\n  // THAILAND\n  TR: /^[A-Z]\\d{8}$/,\n  // TURKEY\n  UA: /^[A-Z]{2}\\d{6}$/,\n  // UKRAINE\n  US: /^\\d{9}$/,\n  // UNITED STATES\n  ZA: /^[TAMD]\\d{8}$/ // SOUTH AFRICA\n};\n\n/**\n * Check if str is a valid passport number\n * relative to provided ISO Country Code.\n *\n * @param {string} str\n * @param {string} countryCode\n * @return {boolean}\n */\nfunction isPassportNumber(str, countryCode) {\n  (0, _assertString.default)(str);\n  /** Remove All Whitespaces, Convert to UPPERCASE */\n  var normalizedStr = str.replace(/\\s/g, '').toUpperCase();\n  return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isInt;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;\nvar intLeadingZeroes = /^[-+]?[0-9]+$/;\nfunction isInt(str, options) {\n  (0, _assertString.default)(str);\n  options = options || {};\n\n  // Get the regex to use for testing, based on whether\n  // leading zeroes are allowed or not.\n  var regex = options.allow_leading_zeroes === false ? int : intLeadingZeroes;\n\n  // Check min/max/lt/gt\n  var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;\n  var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;\n  var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;\n  var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;\n  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isPort;\nvar _isInt = _interopRequireDefault(require(\"./isInt\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isPort(str) {\n  return (0, _isInt.default)(str, {\n    allow_leading_zeroes: false,\n    min: 0,\n    max: 65535\n  });\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLowercase;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isLowercase(str) {\n  (0, _assertString.default)(str);\n  return str === str.toLowerCase();\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isUppercase;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isUppercase(str) {\n  (0, _assertString.default)(str);\n  return str === str.toUpperCase();\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIMEI;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar imeiRegexWithoutHypens = /^[0-9]{15}$/;\nvar imeiRegexWithHypens = /^\\d{2}-\\d{6}-\\d{6}-\\d{1}$/;\nfunction isIMEI(str, options) {\n  (0, _assertString.default)(str);\n  options = options || {};\n\n  // default regex for checking imei is the one without hyphens\n\n  var imeiRegex = imeiRegexWithoutHypens;\n  if (options.allow_hyphens) {\n    imeiRegex = imeiRegexWithHypens;\n  }\n  if (!imeiRegex.test(str)) {\n    return false;\n  }\n  str = str.replace(/-/g, '');\n  var sum = 0,\n    mul = 2,\n    l = 14;\n  for (var i = 0; i < l; i++) {\n    var digit = str.substring(l - i - 1, l - i);\n    var tp = parseInt(digit, 10) * mul;\n    if (tp >= 10) {\n      sum += tp % 10 + 1;\n    } else {\n      sum += tp;\n    }\n    if (mul === 1) {\n      mul += 1;\n    } else {\n      mul -= 1;\n    }\n  }\n  var chk = (10 - sum % 10) % 10;\n  if (chk !== parseInt(str.substring(14, 15), 10)) {\n    return false;\n  }\n  return true;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isAscii;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* eslint-disable no-control-regex */\nvar ascii = /^[\\x00-\\x7F]+$/;\n/* eslint-enable no-control-regex */\n\nfunction isAscii(str) {\n  (0, _assertString.default)(str);\n  return ascii.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isFullWidth;\nexports.fullWidth = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar fullWidth = exports.fullWidth = /[^\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\nfunction isFullWidth(str) {\n  (0, _assertString.default)(str);\n  return fullWidth.test(str);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isHalfWidth;\nexports.halfWidth = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar halfWidth = exports.halfWidth = /[\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\nfunction isHalfWidth(str) {\n  (0, _assertString.default)(str);\n  return halfWidth.test(str);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isVariableWidth;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _isFullWidth = require(\"./isFullWidth\");\nvar _isHalfWidth = require(\"./isHalfWidth\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isVariableWidth(str) {\n  (0, _assertString.default)(str);\n  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMultibyte;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* eslint-disable no-control-regex */\nvar multibyte = /[^\\x00-\\x7F]/;\n/* eslint-enable no-control-regex */\n\nfunction isMultibyte(str) {\n  (0, _assertString.default)(str);\n  return multibyte.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = multilineRegexp;\n/**\n * Build RegExp object from an array\n * of multiple/multi-line regexp parts\n *\n * @param {string[]} parts\n * @param {string} flags\n * @return {object} - RegExp object\n */\nfunction multilineRegexp(parts, flags) {\n  var regexpAsStringLiteral = parts.join('');\n  return new RegExp(regexpAsStringLiteral, flags);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isSemVer;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _multilineRegex = _interopRequireDefault(require(\"./util/multilineRegex\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * Regular Expression to match\n * semantic versioning (SemVer)\n * built from multi-line, multi-parts regexp\n * Reference: https://semver.org/\n */\nvar semanticVersioningRegex = (0, _multilineRegex.default)(['^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)', '(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-z-][0-9a-z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-z-][0-9a-z-]*))*))', '?(?:\\\\+([0-9a-z-]+(?:\\\\.[0-9a-z-]+)*))?$'], 'i');\nfunction isSemVer(str) {\n  (0, _assertString.default)(str);\n  return semanticVersioningRegex.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isSurrogatePair;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\nfunction isSurrogatePair(str) {\n  (0, _assertString.default)(str);\n  return surrogatePair.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar includes = function includes(arr, val) {\n  return arr.some(function (arrVal) {\n    return val === arrVal;\n  });\n};\nvar _default = exports.default = includes;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isDecimal;\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _includes = _interopRequireDefault(require(\"./util/includes\"));\nvar _alpha = require(\"./alpha\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction decimalRegExp(options) {\n  var regExp = new RegExp(\"^[-+]?([0-9]+)?(\\\\\".concat(_alpha.decimal[options.locale], \"[0-9]{\").concat(options.decimal_digits, \"})\").concat(options.force_decimal ? '' : '?', \"$\"));\n  return regExp;\n}\nvar default_decimal_options = {\n  force_decimal: false,\n  decimal_digits: '1,',\n  locale: 'en-US'\n};\nvar blacklist = ['', '-', '+'];\nfunction isDecimal(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_decimal_options);\n  if (options.locale in _alpha.decimal) {\n    return !(0, _includes.default)(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);\n  }\n  throw new Error(\"Invalid locale '\".concat(options.locale, \"'\"));\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isHexadecimal;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;\nfunction isHexadecimal(str) {\n  (0, _assertString.default)(str);\n  return hexadecimal.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isOctal;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar octal = /^(0o)?[0-7]+$/i;\nfunction isOctal(str) {\n  (0, _assertString.default)(str);\n  return octal.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isDivisibleBy;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _toFloat = _interopRequireDefault(require(\"./toFloat\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isDivisibleBy(str, num) {\n  (0, _assertString.default)(str);\n  return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isHexColor;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;\nfunction isHexColor(str) {\n  (0, _assertString.default)(str);\n  return hexcolor.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isRgbColor;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar rgbColor = /^rgb\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\)$/;\nvar rgbaColor = /^rgba\\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\\.\\d|1(\\.0)?|0(\\.0)?)\\)$/;\nvar rgbColorPercent = /^rgb\\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\\)$/;\nvar rgbaColorPercent = /^rgba\\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\\.\\d|1(\\.0)?|0(\\.0)?)\\)$/;\nfunction isRgbColor(str) {\n  var includePercentValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  (0, _assertString.default)(str);\n  if (!includePercentValues) {\n    return rgbColor.test(str) || rgbaColor.test(str);\n  }\n  return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isHSL;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar hslComma = /^hsla?\\(((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%){2}(,((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%?))?\\)$/i;\nvar hslSpace = /^hsla?\\(((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?))(deg|grad|rad|turn)?(\\s(\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%){2}\\s?(\\/\\s((\\+|\\-)?([0-9]+(\\.[0-9]+)?(e(\\+|\\-)?[0-9]+)?|\\.[0-9]+(e(\\+|\\-)?[0-9]+)?)%?)\\s?)?\\)$/i;\nfunction isHSL(str) {\n  (0, _assertString.default)(str);\n\n  // Strip duplicate spaces before calling the validation regex (See  #1598 for more info)\n  var strippedStr = str.replace(/\\s+/g, ' ').replace(/\\s?(hsla?\\(|\\)|,)\\s?/ig, '$1');\n  if (strippedStr.indexOf(',') !== -1) {\n    return hslComma.test(strippedStr);\n  }\n  return hslSpace.test(strippedStr);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isISRC;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// see http://isrc.ifpi.org/en/isrc-standard/code-syntax\nvar isrc = /^[A-Z]{2}[0-9A-Z]{3}\\d{2}\\d{5}$/;\nfunction isISRC(str) {\n  (0, _assertString.default)(str);\n  return isrc.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isIBAN;\nexports.locales = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/**\n * List of country codes with\n * corresponding IBAN regular expression\n * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n */\nvar ibanRegexThroughCountryCode = {\n  AD: /^(AD[0-9]{2})\\d{8}[A-Z0-9]{12}$/,\n  AE: /^(AE[0-9]{2})\\d{3}\\d{16}$/,\n  AL: /^(AL[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  AT: /^(AT[0-9]{2})\\d{16}$/,\n  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  BA: /^(BA[0-9]{2})\\d{16}$/,\n  BE: /^(BE[0-9]{2})\\d{12}$/,\n  BG: /^(BG[0-9]{2})[A-Z]{4}\\d{6}[A-Z0-9]{8}$/,\n  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,\n  BR: /^(BR[0-9]{2})\\d{23}[A-Z]{1}[A-Z0-9]{1}$/,\n  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  CH: /^(CH[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  CR: /^(CR[0-9]{2})\\d{18}$/,\n  CY: /^(CY[0-9]{2})\\d{8}[A-Z0-9]{16}$/,\n  CZ: /^(CZ[0-9]{2})\\d{20}$/,\n  DE: /^(DE[0-9]{2})\\d{18}$/,\n  DK: /^(DK[0-9]{2})\\d{14}$/,\n  DO: /^(DO[0-9]{2})[A-Z]{4}\\d{20}$/,\n  DZ: /^(DZ\\d{24})$/,\n  EE: /^(EE[0-9]{2})\\d{16}$/,\n  EG: /^(EG[0-9]{2})\\d{25}$/,\n  ES: /^(ES[0-9]{2})\\d{20}$/,\n  FI: /^(FI[0-9]{2})\\d{14}$/,\n  FO: /^(FO[0-9]{2})\\d{14}$/,\n  FR: /^(FR[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  GB: /^(GB[0-9]{2})[A-Z]{4}\\d{14}$/,\n  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\\d{16}$/,\n  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,\n  GL: /^(GL[0-9]{2})\\d{14}$/,\n  GR: /^(GR[0-9]{2})\\d{7}[A-Z0-9]{16}$/,\n  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,\n  HR: /^(HR[0-9]{2})\\d{17}$/,\n  HU: /^(HU[0-9]{2})\\d{24}$/,\n  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\\d{14}$/,\n  IL: /^(IL[0-9]{2})\\d{19}$/,\n  IQ: /^(IQ[0-9]{2})[A-Z]{4}\\d{15}$/,\n  IR: /^(IR[0-9]{2})0\\d{2}0\\d{18}$/,\n  IS: /^(IS[0-9]{2})\\d{22}$/,\n  IT: /^(IT[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  JO: /^(JO[0-9]{2})[A-Z]{4}\\d{22}$/,\n  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,\n  KZ: /^(KZ[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  LB: /^(LB[0-9]{2})\\d{4}[A-Z0-9]{20}$/,\n  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,\n  LI: /^(LI[0-9]{2})\\d{5}[A-Z0-9]{12}$/,\n  LT: /^(LT[0-9]{2})\\d{16}$/,\n  LU: /^(LU[0-9]{2})\\d{3}[A-Z0-9]{13}$/,\n  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,\n  MA: /^(MA[0-9]{26})$/,\n  MC: /^(MC[0-9]{2})\\d{10}[A-Z0-9]{11}\\d{2}$/,\n  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,\n  ME: /^(ME[0-9]{2})\\d{18}$/,\n  MK: /^(MK[0-9]{2})\\d{3}[A-Z0-9]{10}\\d{2}$/,\n  MR: /^(MR[0-9]{2})\\d{23}$/,\n  MT: /^(MT[0-9]{2})[A-Z]{4}\\d{5}[A-Z0-9]{18}$/,\n  MU: /^(MU[0-9]{2})[A-Z]{4}\\d{19}[A-Z]{3}$/,\n  MZ: /^(MZ[0-9]{2})\\d{21}$/,\n  NL: /^(NL[0-9]{2})[A-Z]{4}\\d{10}$/,\n  NO: /^(NO[0-9]{2})\\d{11}$/,\n  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  PL: /^(PL[0-9]{2})\\d{24}$/,\n  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\\d{21}$/,\n  PT: /^(PT[0-9]{2})\\d{21}$/,\n  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,\n  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,\n  RS: /^(RS[0-9]{2})\\d{18}$/,\n  SA: /^(SA[0-9]{2})\\d{2}[A-Z0-9]{18}$/,\n  SC: /^(SC[0-9]{2})[A-Z]{4}\\d{20}[A-Z]{3}$/,\n  SE: /^(SE[0-9]{2})\\d{20}$/,\n  SI: /^(SI[0-9]{2})\\d{15}$/,\n  SK: /^(SK[0-9]{2})\\d{20}$/,\n  SM: /^(SM[0-9]{2})[A-Z]{1}\\d{10}[A-Z0-9]{12}$/,\n  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\\d{20}$/,\n  TL: /^(TL[0-9]{2})\\d{19}$/,\n  TN: /^(TN[0-9]{2})\\d{20}$/,\n  TR: /^(TR[0-9]{2})\\d{5}[A-Z0-9]{17}$/,\n  UA: /^(UA[0-9]{2})\\d{6}[A-Z0-9]{19}$/,\n  VA: /^(VA[0-9]{2})\\d{18}$/,\n  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\\d{16}$/,\n  XK: /^(XK[0-9]{2})\\d{16}$/\n};\n\n/**\n * Check if the country codes passed are valid using the\n * ibanRegexThroughCountryCode as a reference\n *\n * @param {array} countryCodeArray\n * @return {boolean}\n */\n\nfunction hasOnlyValidCountryCodes(countryCodeArray) {\n  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function (countryCode) {\n    return !(countryCode in ibanRegexThroughCountryCode);\n  });\n  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Check whether string has correct universal IBAN format\n * The IBAN consists of up to 34 alphanumeric characters, as follows:\n * Country Code using ISO 3166-1 alpha-2, two letters\n * check digits, two digits and\n * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.\n * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]\n *\n * @param {string} str - string under validation\n * @param {object} options - object to pass the countries to be either whitelisted or blacklisted\n * @return {boolean}\n */\nfunction hasValidIbanFormat(str, options) {\n  // Strip white spaces and hyphens\n  var strippedStr = str.replace(/[\\s\\-]+/gi, '').toUpperCase();\n  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();\n  var isoCountryCodeInIbanRegexCodeObject = (isoCountryCode in ibanRegexThroughCountryCode);\n  if (options.whitelist) {\n    if (!hasOnlyValidCountryCodes(options.whitelist)) {\n      return false;\n    }\n    var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);\n    if (!isoCountryCodeInWhiteList) {\n      return false;\n    }\n  }\n  if (options.blacklist) {\n    var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);\n    if (isoCountryCodeInBlackList) {\n      return false;\n    }\n  }\n  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);\n}\n\n/**\n   * Check whether string has valid IBAN Checksum\n   * by performing basic mod-97 operation and\n   * the remainder should equal 1\n   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string\n   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35\n   * -- Interpret the string as a decimal integer and\n   * -- compute the remainder on division by 97 (mod 97)\n   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n   *\n   * @param {string} str\n   * @return {boolean}\n   */\nfunction hasValidIbanChecksum(str) {\n  var strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic\n  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);\n  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function (char) {\n    return char.charCodeAt(0) - 55;\n  });\n  var remainder = alphaCapsReplacedWithDigits.match(/\\d{1,7}/g).reduce(function (acc, value) {\n    return Number(acc + value) % 97;\n  }, '');\n  return remainder === 1;\n}\nfunction isIBAN(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _assertString.default)(str);\n  return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);\n}\nvar locales = exports.locales = Object.keys(ibanRegexThroughCountryCode);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CountryCodes = void 0;\nexports.default = isISO31661Alpha2;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2\nvar validISO31661Alpha2CountriesCodes = new Set(['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW']);\nfunction isISO31661Alpha2(str) {\n  (0, _assertString.default)(str);\n  return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());\n}\nvar CountryCodes = exports.CountryCodes = validISO31661Alpha2CountriesCodes;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBIC;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _isISO31661Alpha = require(\"./isISO31661Alpha2\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// https://en.wikipedia.org/wiki/ISO_9362\nvar isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;\nfunction isBIC(str) {\n  (0, _assertString.default)(str);\n\n  // toUpperCase() should be removed when a new major version goes out that changes\n  // the regex to [A-Z] (per the spec).\n  var countryCode = str.slice(4, 6).toUpperCase();\n  if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== 'XK') {\n    return false;\n  }\n  return isBICReg.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMD5;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar md5 = /^[a-f0-9]{32}$/;\nfunction isMD5(str) {\n  (0, _assertString.default)(str);\n  return md5.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isHash;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar lengths = {\n  md5: 32,\n  md4: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8\n};\nfunction isHash(str, algorithm) {\n  (0, _assertString.default)(str);\n  var hash = new RegExp(\"^[a-fA-F0-9]{\".concat(lengths[algorithm], \"}$\"));\n  return hash.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBase64;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar notBase64 = /[^A-Z0-9+\\/=]/i;\nvar urlSafeBase64 = /^[A-Z0-9_\\-]*$/i;\nvar defaultBase64Options = {\n  urlSafe: false\n};\nfunction isBase64(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, defaultBase64Options);\n  var len = str.length;\n  if (options.urlSafe) {\n    return urlSafeBase64.test(str);\n  }\n  if (len % 4 !== 0 || notBase64.test(str)) {\n    return false;\n  }\n  var firstPaddingChar = str.indexOf('=');\n  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isJWT;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _isBase = _interopRequireDefault(require(\"./isBase64\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction isJWT(str) {\n  (0, _assertString.default)(str);\n  var dotSplit = str.split('.');\n  var len = dotSplit.length;\n  if (len !== 3) {\n    return false;\n  }\n  return dotSplit.reduce(function (acc, currElem) {\n    return acc && (0, _isBase.default)(currElem, {\n      urlSafe: true\n    });\n  }, true);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isJSON;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar default_json_options = {\n  allow_primitives: false\n};\nfunction isJSON(str, options) {\n  (0, _assertString.default)(str);\n  try {\n    options = (0, _merge.default)(options, default_json_options);\n    var primitives = [];\n    if (options.allow_primitives) {\n      primitives = [null, false, true];\n    }\n    var obj = JSON.parse(str);\n    return primitives.includes(obj) || !!obj && _typeof(obj) === 'object';\n  } catch (e) {/* ignore */}\n  return false;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isEmpty;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar default_is_empty_options = {\n  ignore_whitespace: false\n};\nfunction isEmpty(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_is_empty_options);\n  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLength;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/* eslint-disable prefer-rest-params */\nfunction isLength(str, options) {\n  (0, _assertString.default)(str);\n  var min;\n  var max;\n  if (_typeof(options) === 'object') {\n    min = options.min || 0;\n    max = options.max;\n  } else {\n    // backwards compatibility: isLength(str, min [, max])\n    min = arguments[1] || 0;\n    max = arguments[2];\n  }\n  var presentationSequences = str.match(/(\\uFE0F|\\uFE0E)/g) || [];\n  var surrogatePairs = str.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g) || [];\n  var len = str.length - presentationSequences.length - surrogatePairs.length;\n  return len >= min && (typeof max === 'undefined' || len <= max);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isTaxID;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar algorithms = _interopRequireWildcard(require(\"./util/algorithms\"));\nvar _isDate = _interopRequireDefault(require(\"./isDate\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * TIN Validation\n * Validates Tax Identification Numbers (TINs) from the US, EU member states and the United Kingdom.\n *\n * EU-UK:\n * National TIN validity is calculated using public algorithms as made available by DG TAXUD.\n *\n * See `https://ec.europa.eu/taxation_customs/tin/specs/FS-TIN%20Algorithms-Public.docx` for more information.\n *\n * US:\n * An Employer Identification Number (EIN), also known as a Federal Tax Identification Number,\n *  is used to identify a business entity.\n *\n * NOTES:\n *  - Prefix 47 is being reserved for future use\n *  - Prefixes 26, 27, 45, 46 and 47 were previously assigned by the Philadelphia campus.\n *\n * See `http://www.irs.gov/Businesses/Small-Businesses-&-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes`\n * for more information.\n */\n\n// Locale functions\n\n/*\n * bg-BG validation function\n * (Edinen gradanski nomer (EGN/), persons only)\n * Checks if birth date (first six digits) is valid and calculates check (last) digit\n */\nfunction bgBgCheck(tin) {\n  // Extract full year, normalize month and check birth date validity\n  var century_year = tin.slice(0, 2);\n  var month = parseInt(tin.slice(2, 4), 10);\n  if (month > 40) {\n    month -= 40;\n    century_year = \"20\".concat(century_year);\n  } else if (month > 20) {\n    month -= 20;\n    century_year = \"18\".concat(century_year);\n  } else {\n    century_year = \"19\".concat(century_year);\n  }\n  if (month < 10) {\n    month = \"0\".concat(month);\n  }\n  var date = \"\".concat(century_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // split digits into an array for further processing\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n\n  // Calculate checksum by multiplying digits with fixed values\n  var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];\n  var checksum = 0;\n  for (var i = 0; i < multip_lookup.length; i++) {\n    checksum += digits[i] * multip_lookup[i];\n  }\n  checksum = checksum % 11 === 10 ? 0 : checksum % 11;\n  return checksum === digits[9];\n}\n\n/**\n * Check if an input is a valid Canadian SIN (Social Insurance Number)\n *\n * The Social Insurance Number (SIN) is a 9 digit number that\n * you need to work in Canada or to have access to government programs and benefits.\n *\n * https://en.wikipedia.org/wiki/Social_Insurance_Number\n * https://www.canada.ca/en/employment-social-development/services/sin.html\n * https://www.codercrunch.com/challenge/819302488/sin-validator\n *\n * @param {string} input\n * @return {boolean}\n */\nfunction isCanadianSIN(input) {\n  var digitsArray = input.split('');\n  var even = digitsArray.filter(function (_, idx) {\n    return idx % 2;\n  }).map(function (i) {\n    return Number(i) * 2;\n  }).join('').split('');\n  var total = digitsArray.filter(function (_, idx) {\n    return !(idx % 2);\n  }).concat(even).map(function (i) {\n    return Number(i);\n  }).reduce(function (acc, cur) {\n    return acc + cur;\n  });\n  return total % 10 === 0;\n}\n\n/*\n * cs-CZ validation function\n * (Rodn slo (R), persons only)\n * Checks if birth date (first six digits) is valid and divisibility by 11\n * Material not in DG TAXUD document sourced from:\n * -`https://lorenc.info/3MA381/overeni-spravnosti-rodneho-cisla.htm`\n * -`https://www.mvcr.cz/clanek/rady-a-sluzby-dokumenty-rodne-cislo.aspx`\n */\nfunction csCzCheck(tin) {\n  tin = tin.replace(/\\W/, '');\n\n  // Extract full year from TIN length\n  var full_year = parseInt(tin.slice(0, 2), 10);\n  if (tin.length === 10) {\n    if (full_year < 54) {\n      full_year = \"20\".concat(full_year);\n    } else {\n      full_year = \"19\".concat(full_year);\n    }\n  } else {\n    if (tin.slice(6) === '000') {\n      return false;\n    } // Three-zero serial not assigned before 1954\n    if (full_year < 54) {\n      full_year = \"19\".concat(full_year);\n    } else {\n      return false; // No 18XX years seen in any of the resources\n    }\n  }\n  // Add missing zero if needed\n  if (full_year.length === 3) {\n    full_year = [full_year.slice(0, 2), '0', full_year.slice(2)].join('');\n  }\n\n  // Extract month from TIN and normalize\n  var month = parseInt(tin.slice(2, 4), 10);\n  if (month > 50) {\n    month -= 50;\n  }\n  if (month > 20) {\n    // Month-plus-twenty was only introduced in 2004\n    if (parseInt(full_year, 10) < 2004) {\n      return false;\n    }\n    month -= 20;\n  }\n  if (month < 10) {\n    month = \"0\".concat(month);\n  }\n\n  // Check date validity\n  var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // Verify divisibility by 11\n  if (tin.length === 10) {\n    if (parseInt(tin, 10) % 11 !== 0) {\n      // Some numbers up to and including 1985 are still valid if\n      // check (last) digit equals 0 and modulo of first 9 digits equals 10\n      var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;\n      if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {\n        if (parseInt(tin.slice(9), 10) !== 0) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/*\n * de-AT validation function\n * (Abgabenkontonummer, persons/entities)\n * Verify TIN validity by calling luhnCheck()\n */\nfunction deAtCheck(tin) {\n  return algorithms.luhnCheck(tin);\n}\n\n/*\n * de-DE validation function\n * (Steueridentifikationsnummer (Steuer-IdNr.), persons only)\n * Tests for single duplicate/triplicate value, then calculates ISO 7064 check (last) digit\n * Partial implementation of spec (same result with both algorithms always)\n */\nfunction deDeCheck(tin) {\n  // Split digits into an array for further processing\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n\n  // Fill array with strings of number positions\n  var occurences = [];\n  for (var i = 0; i < digits.length - 1; i++) {\n    occurences.push('');\n    for (var j = 0; j < digits.length - 1; j++) {\n      if (digits[i] === digits[j]) {\n        occurences[i] += j;\n      }\n    }\n  }\n\n  // Remove digits with one occurence and test for only one duplicate/triplicate\n  occurences = occurences.filter(function (a) {\n    return a.length > 1;\n  });\n  if (occurences.length !== 2 && occurences.length !== 3) {\n    return false;\n  }\n\n  // In case of triplicate value only two digits are allowed next to each other\n  if (occurences[0].length === 3) {\n    var trip_locations = occurences[0].split('').map(function (a) {\n      return parseInt(a, 10);\n    });\n    var recurrent = 0; // Amount of neighbour occurences\n    for (var _i = 0; _i < trip_locations.length - 1; _i++) {\n      if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {\n        recurrent += 1;\n      }\n    }\n    if (recurrent === 2) {\n      return false;\n    }\n  }\n  return algorithms.iso7064Check(tin);\n}\n\n/*\n * dk-DK validation function\n * (CPR-nummer (personnummer), persons only)\n * Checks if birth date (first six digits) is valid and assigned to century (seventh) digit,\n * and calculates check (last) digit\n */\nfunction dkDkCheck(tin) {\n  tin = tin.replace(/\\W/, '');\n\n  // Extract year, check if valid for given century digit and add century\n  var year = parseInt(tin.slice(4, 6), 10);\n  var century_digit = tin.slice(6, 7);\n  switch (century_digit) {\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n      year = \"19\".concat(year);\n      break;\n    case '4':\n    case '9':\n      if (year < 37) {\n        year = \"20\".concat(year);\n      } else {\n        year = \"19\".concat(year);\n      }\n      break;\n    default:\n      if (year < 37) {\n        year = \"20\".concat(year);\n      } else if (year > 58) {\n        year = \"18\".concat(year);\n      } else {\n        return false;\n      }\n      break;\n  }\n  // Add missing zero if needed\n  if (year.length === 3) {\n    year = [year.slice(0, 2), '0', year.slice(2)].join('');\n  }\n  // Check date validity\n  var date = \"\".concat(year, \"/\").concat(tin.slice(2, 4), \"/\").concat(tin.slice(0, 2));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // Split digits into an array for further processing\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n  var checksum = 0;\n  var weight = 4;\n  // Multiply by weight and add to checksum\n  for (var i = 0; i < 9; i++) {\n    checksum += digits[i] * weight;\n    weight -= 1;\n    if (weight === 1) {\n      weight = 7;\n    }\n  }\n  checksum %= 11;\n  if (checksum === 1) {\n    return false;\n  }\n  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;\n}\n\n/*\n * el-CY validation function\n * (Arithmos Forologikou Mitroou (AFM/), persons only)\n * Verify TIN validity by calculating ASCII value of check (last) character\n */\nfunction elCyCheck(tin) {\n  // split digits into an array for further processing\n  var digits = tin.slice(0, 8).split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n  var checksum = 0;\n  // add digits in even places\n  for (var i = 1; i < digits.length; i += 2) {\n    checksum += digits[i];\n  }\n\n  // add digits in odd places\n  for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {\n    if (digits[_i2] < 2) {\n      checksum += 1 - digits[_i2];\n    } else {\n      checksum += 2 * (digits[_i2] - 2) + 5;\n      if (digits[_i2] > 4) {\n        checksum += 2;\n      }\n    }\n  }\n  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);\n}\n\n/*\n * el-GR validation function\n * (Arithmos Forologikou Mitroou (AFM/), persons/entities)\n * Verify TIN validity by calculating check (last) digit\n * Algorithm not in DG TAXUD document- sourced from:\n * - `http://epixeirisi.gr/%CE%9A%CE%A1%CE%99%CE%A3%CE%99%CE%9C%CE%91-%CE%98%CE%95%CE%9C%CE%91%CE%A4%CE%91-%CE%A6%CE%9F%CE%A1%CE%9F%CE%9B%CE%9F%CE%93%CE%99%CE%91%CE%A3-%CE%9A%CE%91%CE%99-%CE%9B%CE%9F%CE%93%CE%99%CE%A3%CE%A4%CE%99%CE%9A%CE%97%CE%A3/23791/%CE%91%CF%81%CE%B9%CE%B8%CE%BC%CF%8C%CF%82-%CE%A6%CE%BF%CF%81%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CE%BA%CE%BF%CF%8D-%CE%9C%CE%B7%CF%84%CF%81%CF%8E%CE%BF%CF%85`\n */\nfunction elGrCheck(tin) {\n  // split digits into an array for further processing\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n  var checksum = 0;\n  for (var i = 0; i < 8; i++) {\n    checksum += digits[i] * Math.pow(2, 8 - i);\n  }\n  return checksum % 11 % 10 === digits[8];\n}\n\n/*\n * en-GB validation function (should go here if needed)\n * (National Insurance Number (NINO) or Unique Taxpayer Reference (UTR),\n * persons/entities respectively)\n */\n\n/*\n * en-IE validation function\n * (Personal Public Service Number (PPS No), persons only)\n * Verify TIN validity by calculating check (second to last) character\n */\nfunction enIeCheck(tin) {\n  var checksum = algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {\n    return parseInt(a, 10);\n  }), 8);\n  if (tin.length === 9 && tin[8] !== 'W') {\n    checksum += (tin[8].charCodeAt(0) - 64) * 9;\n  }\n  checksum %= 23;\n  if (checksum === 0) {\n    return tin[7].toUpperCase() === 'W';\n  }\n  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);\n}\n\n// Valid US IRS campus prefixes\nvar enUsCampusPrefix = {\n  andover: ['10', '12'],\n  atlanta: ['60', '67'],\n  austin: ['50', '53'],\n  brookhaven: ['01', '02', '03', '04', '05', '06', '11', '13', '14', '16', '21', '22', '23', '25', '34', '51', '52', '54', '55', '56', '57', '58', '59', '65'],\n  cincinnati: ['30', '32', '35', '36', '37', '38', '61'],\n  fresno: ['15', '24'],\n  internet: ['20', '26', '27', '45', '46', '47'],\n  kansas: ['40', '44'],\n  memphis: ['94', '95'],\n  ogden: ['80', '90'],\n  philadelphia: ['33', '39', '41', '42', '43', '46', '48', '62', '63', '64', '66', '68', '71', '72', '73', '74', '75', '76', '77', '81', '82', '83', '84', '85', '86', '87', '88', '91', '92', '93', '98', '99'],\n  sba: ['31']\n};\n\n// Return an array of all US IRS campus prefixes\nfunction enUsGetPrefixes() {\n  var prefixes = [];\n  for (var location in enUsCampusPrefix) {\n    // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n    // istanbul ignore else\n    if (enUsCampusPrefix.hasOwnProperty(location)) {\n      prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));\n    }\n  }\n  return prefixes;\n}\n\n/*\n * en-US validation function\n * Verify that the TIN starts with a valid IRS campus prefix\n */\nfunction enUsCheck(tin) {\n  return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;\n}\n\n/*\n * es-AR validation function\n * Clave nica de Identificacin Tributaria (CUIT/CUIL)\n * Sourced from:\n * - https://servicioscf.afip.gob.ar/publico/abc/ABCpaso2.aspx?id_nivel1=3036&id_nivel2=3040&p=Conceptos%20b%C3%A1sicos\n * - https://es.wikipedia.org/wiki/Clave_%C3%9Anica_de_Identificaci%C3%B3n_Tributaria\n */\n\nfunction esArCheck(tin) {\n  var accum = 0;\n  var digits = tin.split('');\n  var digit = parseInt(digits.pop(), 10);\n  for (var i = 0; i < digits.length; i++) {\n    accum += digits[9 - i] * (2 + i % 6);\n  }\n  var verif = 11 - accum % 11;\n  if (verif === 11) {\n    verif = 0;\n  } else if (verif === 10) {\n    verif = 9;\n  }\n  return digit === verif;\n}\n\n/*\n * es-ES validation function\n * (Documento Nacional de Identidad (DNI)\n * or Nmero de Identificacin de Extranjero (NIE), persons only)\n * Verify TIN validity by calculating check (last) character\n */\nfunction esEsCheck(tin) {\n  // Split characters into an array for further processing\n  var chars = tin.toUpperCase().split('');\n\n  // Replace initial letter if needed\n  if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {\n    var lead_replace = 0;\n    switch (chars[0]) {\n      case 'Y':\n        lead_replace = 1;\n        break;\n      case 'Z':\n        lead_replace = 2;\n        break;\n      default:\n    }\n    chars.splice(0, 1, lead_replace);\n    // Fill with zeros if smaller than proper\n  } else {\n    while (chars.length < 9) {\n      chars.unshift(0);\n    }\n  }\n\n  // Calculate checksum and check according to lookup\n  var lookup = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];\n  chars = chars.join('');\n  var checksum = parseInt(chars.slice(0, 8), 10) % 23;\n  return chars[8] === lookup[checksum];\n}\n\n/*\n * et-EE validation function\n * (Isikukood (IK), persons only)\n * Checks if birth date (century digit and six following) is valid and calculates check (last) digit\n * Material not in DG TAXUD document sourced from:\n * - `https://www.oecd.org/tax/automatic-exchange/crs-implementation-and-assistance/tax-identification-numbers/Estonia-TIN.pdf`\n */\nfunction etEeCheck(tin) {\n  // Extract year and add century\n  var full_year = tin.slice(1, 3);\n  var century_digit = tin.slice(0, 1);\n  switch (century_digit) {\n    case '1':\n    case '2':\n      full_year = \"18\".concat(full_year);\n      break;\n    case '3':\n    case '4':\n      full_year = \"19\".concat(full_year);\n      break;\n    default:\n      full_year = \"20\".concat(full_year);\n      break;\n  }\n  // Check date validity\n  var date = \"\".concat(full_year, \"/\").concat(tin.slice(3, 5), \"/\").concat(tin.slice(5, 7));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // Split digits into an array for further processing\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n  var checksum = 0;\n  var weight = 1;\n  // Multiply by weight and add to checksum\n  for (var i = 0; i < 10; i++) {\n    checksum += digits[i] * weight;\n    weight += 1;\n    if (weight === 10) {\n      weight = 1;\n    }\n  }\n  // Do again if modulo 11 of checksum is 10\n  if (checksum % 11 === 10) {\n    checksum = 0;\n    weight = 3;\n    for (var _i3 = 0; _i3 < 10; _i3++) {\n      checksum += digits[_i3] * weight;\n      weight += 1;\n      if (weight === 10) {\n        weight = 1;\n      }\n    }\n    if (checksum % 11 === 10) {\n      return digits[10] === 0;\n    }\n  }\n  return checksum % 11 === digits[10];\n}\n\n/*\n * fi-FI validation function\n * (Henkiltunnus (HETU), persons only)\n * Checks if birth date (first six digits plus century symbol) is valid\n * and calculates check (last) digit\n */\nfunction fiFiCheck(tin) {\n  // Extract year and add century\n  var full_year = tin.slice(4, 6);\n  var century_symbol = tin.slice(6, 7);\n  switch (century_symbol) {\n    case '+':\n      full_year = \"18\".concat(full_year);\n      break;\n    case '-':\n      full_year = \"19\".concat(full_year);\n      break;\n    default:\n      full_year = \"20\".concat(full_year);\n      break;\n  }\n  // Check date validity\n  var date = \"\".concat(full_year, \"/\").concat(tin.slice(2, 4), \"/\").concat(tin.slice(0, 2));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // Calculate check character\n  var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;\n  if (checksum < 10) {\n    return checksum === parseInt(tin.slice(10), 10);\n  }\n  checksum -= 10;\n  var letters_lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];\n  return letters_lookup[checksum] === tin.slice(10);\n}\n\n/*\n * fr/nl-BE validation function\n * (Numro national (N.N.), persons only)\n * Checks if birth date (first six digits) is valid and calculates check (last two) digits\n */\nfunction frBeCheck(tin) {\n  // Zero month/day value is acceptable\n  if (tin.slice(2, 4) !== '00' || tin.slice(4, 6) !== '00') {\n    // Extract date from first six digits of TIN\n    var date = \"\".concat(tin.slice(0, 2), \"/\").concat(tin.slice(2, 4), \"/\").concat(tin.slice(4, 6));\n    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n      return false;\n    }\n  }\n  var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;\n  var checkdigits = parseInt(tin.slice(9, 11), 10);\n  if (checksum !== checkdigits) {\n    checksum = 97 - parseInt(\"2\".concat(tin.slice(0, 9)), 10) % 97;\n    if (checksum !== checkdigits) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n * fr-FR validation function\n * (Numro fiscal de rfrence (numro SPI), persons only)\n * Verify TIN validity by calculating check (last three) digits\n */\nfunction frFrCheck(tin) {\n  tin = tin.replace(/\\s/g, '');\n  var checksum = parseInt(tin.slice(0, 10), 10) % 511;\n  var checkdigits = parseInt(tin.slice(10, 13), 10);\n  return checksum === checkdigits;\n}\n\n/*\n * fr/lb-LU validation function\n * (numro didentification personnelle, persons only)\n * Verify birth date validity and run Luhn and Verhoeff checks\n */\nfunction frLuCheck(tin) {\n  // Extract date and check validity\n  var date = \"\".concat(tin.slice(0, 4), \"/\").concat(tin.slice(4, 6), \"/\").concat(tin.slice(6, 8));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // Run Luhn check\n  if (!algorithms.luhnCheck(tin.slice(0, 12))) {\n    return false;\n  }\n  // Remove Luhn check digit and run Verhoeff check\n  return algorithms.verhoeffCheck(\"\".concat(tin.slice(0, 11)).concat(tin[12]));\n}\n\n/*\n * hr-HR validation function\n * (Osobni identifikacijski broj (OIB), persons/entities)\n * Verify TIN validity by calling iso7064Check(digits)\n */\nfunction hrHrCheck(tin) {\n  return algorithms.iso7064Check(tin);\n}\n\n/*\n * hu-HU validation function\n * (Adazonost jel, persons only)\n * Verify TIN validity by calculating check (last) digit\n */\nfunction huHuCheck(tin) {\n  // split digits into an array for further processing\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n  var checksum = 8;\n  for (var i = 1; i < 9; i++) {\n    checksum += digits[i] * (i + 1);\n  }\n  return checksum % 11 === digits[9];\n}\n\n/*\n * lt-LT validation function (should go here if needed)\n * (Asmens kodas, persons/entities respectively)\n * Current validation check is alias of etEeCheck- same format applies\n */\n\n/*\n * it-IT first/last name validity check\n * Accepts it-IT TIN-encoded names as a three-element character array and checks their validity\n * Due to lack of clarity between resources (\"Are only Italian consonants used?\n * What happens if a person has X in their name?\" etc.) only two test conditions\n * have been implemented:\n * Vowels may only be followed by other vowels or an X character\n * and X characters after vowels may only be followed by other X characters.\n */\nfunction itItNameCheck(name) {\n  // true at the first occurence of a vowel\n  var vowelflag = false;\n\n  // true at the first occurence of an X AFTER vowel\n  // (to properly handle last names with X as consonant)\n  var xflag = false;\n  for (var i = 0; i < 3; i++) {\n    if (!vowelflag && /[AEIOU]/.test(name[i])) {\n      vowelflag = true;\n    } else if (!xflag && vowelflag && name[i] === 'X') {\n      xflag = true;\n    } else if (i > 0) {\n      if (vowelflag && !xflag) {\n        if (!/[AEIOU]/.test(name[i])) {\n          return false;\n        }\n      }\n      if (xflag) {\n        if (!/X/.test(name[i])) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/*\n * it-IT validation function\n * (Codice fiscale (TIN-IT), persons only)\n * Verify name, birth date and codice catastale validity\n * and calculate check character.\n * Material not in DG-TAXUD document sourced from:\n * `https://en.wikipedia.org/wiki/Italian_fiscal_code`\n */\nfunction itItCheck(tin) {\n  // Capitalize and split characters into an array for further processing\n  var chars = tin.toUpperCase().split('');\n\n  // Check first and last name validity calling itItNameCheck()\n  if (!itItNameCheck(chars.slice(0, 3))) {\n    return false;\n  }\n  if (!itItNameCheck(chars.slice(3, 6))) {\n    return false;\n  }\n\n  // Convert letters in number spaces back to numbers if any\n  var number_locations = [6, 7, 9, 10, 12, 13, 14];\n  var number_replace = {\n    L: '0',\n    M: '1',\n    N: '2',\n    P: '3',\n    Q: '4',\n    R: '5',\n    S: '6',\n    T: '7',\n    U: '8',\n    V: '9'\n  };\n  for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {\n    var i = _number_locations[_i4];\n    if (chars[i] in number_replace) {\n      chars.splice(i, 1, number_replace[chars[i]]);\n    }\n  }\n\n  // Extract month and day, and check date validity\n  var month_replace = {\n    A: '01',\n    B: '02',\n    C: '03',\n    D: '04',\n    E: '05',\n    H: '06',\n    L: '07',\n    M: '08',\n    P: '09',\n    R: '10',\n    S: '11',\n    T: '12'\n  };\n  var month = month_replace[chars[8]];\n  var day = parseInt(chars[9] + chars[10], 10);\n  if (day > 40) {\n    day -= 40;\n  }\n  if (day < 10) {\n    day = \"0\".concat(day);\n  }\n  var date = \"\".concat(chars[6]).concat(chars[7], \"/\").concat(month, \"/\").concat(day);\n  if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n    return false;\n  }\n\n  // Calculate check character by adding up even and odd characters as numbers\n  var checksum = 0;\n  for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {\n    var char_to_int = parseInt(chars[_i5], 10);\n    if (isNaN(char_to_int)) {\n      char_to_int = chars[_i5].charCodeAt(0) - 65;\n    }\n    checksum += char_to_int;\n  }\n  var odd_convert = {\n    // Maps of characters at odd places\n    A: 1,\n    B: 0,\n    C: 5,\n    D: 7,\n    E: 9,\n    F: 13,\n    G: 15,\n    H: 17,\n    I: 19,\n    J: 21,\n    K: 2,\n    L: 4,\n    M: 18,\n    N: 20,\n    O: 11,\n    P: 3,\n    Q: 6,\n    R: 8,\n    S: 12,\n    T: 14,\n    U: 16,\n    V: 10,\n    W: 22,\n    X: 25,\n    Y: 24,\n    Z: 23,\n    0: 1,\n    1: 0\n  };\n  for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {\n    var _char_to_int = 0;\n    if (chars[_i6] in odd_convert) {\n      _char_to_int = odd_convert[chars[_i6]];\n    } else {\n      var multiplier = parseInt(chars[_i6], 10);\n      _char_to_int = 2 * multiplier + 1;\n      if (multiplier > 4) {\n        _char_to_int += 2;\n      }\n    }\n    checksum += _char_to_int;\n  }\n  if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {\n    return false;\n  }\n  return true;\n}\n\n/*\n * lv-LV validation function\n * (Personas kods (PK), persons only)\n * Check validity of birth date and calculate check (last) digit\n * Support only for old format numbers (not starting with '32', issued before 2017/07/01)\n * Material not in DG TAXUD document sourced from:\n * `https://boot.ritakafija.lv/forums/index.php?/topic/88314-personas-koda-algoritms-%C4%8Deksumma/`\n */\nfunction lvLvCheck(tin) {\n  tin = tin.replace(/\\W/, '');\n  // Extract date from TIN\n  var day = tin.slice(0, 2);\n  if (day !== '32') {\n    // No date/checksum check if new format\n    var month = tin.slice(2, 4);\n    if (month !== '00') {\n      // No date check if unknown month\n      var full_year = tin.slice(4, 6);\n      switch (tin[6]) {\n        case '0':\n          full_year = \"18\".concat(full_year);\n          break;\n        case '1':\n          full_year = \"19\".concat(full_year);\n          break;\n        default:\n          full_year = \"20\".concat(full_year);\n          break;\n      }\n      // Check date validity\n      var date = \"\".concat(full_year, \"/\").concat(tin.slice(2, 4), \"/\").concat(day);\n      if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n        return false;\n      }\n    }\n\n    // Calculate check digit\n    var checksum = 1101;\n    var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\n    for (var i = 0; i < tin.length - 1; i++) {\n      checksum -= parseInt(tin[i], 10) * multip_lookup[i];\n    }\n    return parseInt(tin[10], 10) === checksum % 11;\n  }\n  return true;\n}\n\n/*\n * mt-MT validation function\n * (Identity Card Number or Unique Taxpayer Reference, persons/entities)\n * Verify Identity Card Number structure (no other tests found)\n */\nfunction mtMtCheck(tin) {\n  if (tin.length !== 9) {\n    // No tests for UTR\n    var chars = tin.toUpperCase().split('');\n    // Fill with zeros if smaller than proper\n    while (chars.length < 8) {\n      chars.unshift(0);\n    }\n    // Validate format according to last character\n    switch (tin[7]) {\n      case 'A':\n      case 'P':\n        if (parseInt(chars[6], 10) === 0) {\n          return false;\n        }\n        break;\n      default:\n        {\n          var first_part = parseInt(chars.join('').slice(0, 5), 10);\n          if (first_part > 32000) {\n            return false;\n          }\n          var second_part = parseInt(chars.join('').slice(5, 7), 10);\n          if (first_part === second_part) {\n            return false;\n          }\n        }\n    }\n  }\n  return true;\n}\n\n/*\n * nl-NL validation function\n * (Burgerservicenummer (BSN) or Rechtspersonen Samenwerkingsverbanden Informatie Nummer (RSIN),\n * persons/entities respectively)\n * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n */\nfunction nlNlCheck(tin) {\n  return algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {\n    return parseInt(a, 10);\n  }), 9) % 11 === parseInt(tin[8], 10);\n}\n\n/*\n * pl-PL validation function\n * (Powszechny Elektroniczny System Ewidencji Ludnoci (PESEL)\n * or Numer identyfikacji podatkowej (NIP), persons/entities)\n * Verify TIN validity by validating birth date (PESEL) and calculating check (last) digit\n */\nfunction plPlCheck(tin) {\n  // NIP\n  if (tin.length === 10) {\n    // Calculate last digit by multiplying with lookup\n    var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];\n    var _checksum = 0;\n    for (var i = 0; i < lookup.length; i++) {\n      _checksum += parseInt(tin[i], 10) * lookup[i];\n    }\n    _checksum %= 11;\n    if (_checksum === 10) {\n      return false;\n    }\n    return _checksum === parseInt(tin[9], 10);\n  }\n\n  // PESEL\n  // Extract full year using month\n  var full_year = tin.slice(0, 2);\n  var month = parseInt(tin.slice(2, 4), 10);\n  if (month > 80) {\n    full_year = \"18\".concat(full_year);\n    month -= 80;\n  } else if (month > 60) {\n    full_year = \"22\".concat(full_year);\n    month -= 60;\n  } else if (month > 40) {\n    full_year = \"21\".concat(full_year);\n    month -= 40;\n  } else if (month > 20) {\n    full_year = \"20\".concat(full_year);\n    month -= 20;\n  } else {\n    full_year = \"19\".concat(full_year);\n  }\n  // Add leading zero to month if needed\n  if (month < 10) {\n    month = \"0\".concat(month);\n  }\n  // Check date validity\n  var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n  if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n\n  // Calculate last digit by mulitplying with odd one-digit numbers except 5\n  var checksum = 0;\n  var multiplier = 1;\n  for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {\n    checksum += parseInt(tin[_i7], 10) * multiplier % 10;\n    multiplier += 2;\n    if (multiplier > 10) {\n      multiplier = 1;\n    } else if (multiplier === 5) {\n      multiplier += 2;\n    }\n  }\n  checksum = 10 - checksum % 10;\n  return checksum === parseInt(tin[10], 10);\n}\n\n/*\n* pt-BR validation function\n* (Cadastro de Pessoas Fsicas (CPF, persons)\n* Cadastro Nacional de Pessoas Jurdicas (CNPJ, entities)\n* Both inputs will be validated\n*/\n\nfunction ptBrCheck(tin) {\n  if (tin.length === 11) {\n    var _sum;\n    var remainder;\n    _sum = 0;\n    if (\n    // Reject known invalid CPFs\n    tin === '11111111111' || tin === '22222222222' || tin === '33333333333' || tin === '44444444444' || tin === '55555555555' || tin === '66666666666' || tin === '77777777777' || tin === '88888888888' || tin === '99999999999' || tin === '00000000000') return false;\n    for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);\n    remainder = _sum * 10 % 11;\n    if (remainder === 10) remainder = 0;\n    if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;\n    _sum = 0;\n    for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);\n    remainder = _sum * 10 % 11;\n    if (remainder === 10) remainder = 0;\n    if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;\n    return true;\n  }\n  if (\n  // Reject know invalid CNPJs\n  tin === '00000000000000' || tin === '11111111111111' || tin === '22222222222222' || tin === '33333333333333' || tin === '44444444444444' || tin === '55555555555555' || tin === '66666666666666' || tin === '77777777777777' || tin === '88888888888888' || tin === '99999999999999') {\n    return false;\n  }\n  var length = tin.length - 2;\n  var identifiers = tin.substring(0, length);\n  var verificators = tin.substring(length);\n  var sum = 0;\n  var pos = length - 7;\n  for (var _i9 = length; _i9 >= 1; _i9--) {\n    sum += identifiers.charAt(length - _i9) * pos;\n    pos -= 1;\n    if (pos < 2) {\n      pos = 9;\n    }\n  }\n  var result = sum % 11 < 2 ? 0 : 11 - sum % 11;\n  if (result !== parseInt(verificators.charAt(0), 10)) {\n    return false;\n  }\n  length += 1;\n  identifiers = tin.substring(0, length);\n  sum = 0;\n  pos = length - 7;\n  for (var _i10 = length; _i10 >= 1; _i10--) {\n    sum += identifiers.charAt(length - _i10) * pos;\n    pos -= 1;\n    if (pos < 2) {\n      pos = 9;\n    }\n  }\n  result = sum % 11 < 2 ? 0 : 11 - sum % 11;\n  if (result !== parseInt(verificators.charAt(1), 10)) {\n    return false;\n  }\n  return true;\n}\n\n/*\n * pt-PT validation function\n * (Nmero de identificao fiscal (NIF), persons/entities)\n * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n */\nfunction ptPtCheck(tin) {\n  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {\n    return parseInt(a, 10);\n  }), 9) % 11;\n  if (checksum > 9) {\n    return parseInt(tin[8], 10) === 0;\n  }\n  return checksum === parseInt(tin[8], 10);\n}\n\n/*\n * ro-RO validation function\n * (Cod Numeric Personal (CNP) or Cod de nregistrare fiscal (CIF),\n * persons only)\n * Verify CNP validity by calculating check (last) digit (test not found for CIF)\n * Material not in DG TAXUD document sourced from:\n * `https://en.wikipedia.org/wiki/National_identification_number#Romania`\n */\nfunction roRoCheck(tin) {\n  if (tin.slice(0, 4) !== '9000') {\n    // No test found for this format\n    // Extract full year using century digit if possible\n    var full_year = tin.slice(1, 3);\n    switch (tin[0]) {\n      case '1':\n      case '2':\n        full_year = \"19\".concat(full_year);\n        break;\n      case '3':\n      case '4':\n        full_year = \"18\".concat(full_year);\n        break;\n      case '5':\n      case '6':\n        full_year = \"20\".concat(full_year);\n        break;\n      default:\n    }\n\n    // Check date validity\n    var date = \"\".concat(full_year, \"/\").concat(tin.slice(3, 5), \"/\").concat(tin.slice(5, 7));\n    if (date.length === 8) {\n      if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n        return false;\n      }\n    } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n      return false;\n    }\n\n    // Calculate check digit\n    var digits = tin.split('').map(function (a) {\n      return parseInt(a, 10);\n    });\n    var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];\n    var checksum = 0;\n    for (var i = 0; i < multipliers.length; i++) {\n      checksum += digits[i] * multipliers[i];\n    }\n    if (checksum % 11 === 10) {\n      return digits[12] === 1;\n    }\n    return digits[12] === checksum % 11;\n  }\n  return true;\n}\n\n/*\n * sk-SK validation function\n * (Rodn slo (R) or bezvznamov identifikan slo (BI), persons only)\n * Checks validity of pre-1954 birth numbers (rodn slo) only\n * Due to the introduction of the pseudo-random BI it is not possible to test\n * post-1954 birth numbers without knowing whether they are BI or R beforehand\n */\nfunction skSkCheck(tin) {\n  if (tin.length === 9) {\n    tin = tin.replace(/\\W/, '');\n    if (tin.slice(6) === '000') {\n      return false;\n    } // Three-zero serial not assigned before 1954\n\n    // Extract full year from TIN length\n    var full_year = parseInt(tin.slice(0, 2), 10);\n    if (full_year > 53) {\n      return false;\n    }\n    if (full_year < 10) {\n      full_year = \"190\".concat(full_year);\n    } else {\n      full_year = \"19\".concat(full_year);\n    }\n\n    // Extract month from TIN and normalize\n    var month = parseInt(tin.slice(2, 4), 10);\n    if (month > 50) {\n      month -= 50;\n    }\n    if (month < 10) {\n      month = \"0\".concat(month);\n    }\n\n    // Check date validity\n    var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(tin.slice(4, 6));\n    if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n * sl-SI validation function\n * (Davna tevilka, persons/entities)\n * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n */\nfunction slSiCheck(tin) {\n  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {\n    return parseInt(a, 10);\n  }), 8) % 11;\n  if (checksum === 10) {\n    return parseInt(tin[7], 10) === 0;\n  }\n  return checksum === parseInt(tin[7], 10);\n}\n\n/*\n * sv-SE validation function\n * (Personnummer or samordningsnummer, persons only)\n * Checks validity of birth date and calls luhnCheck() to validate check (last) digit\n */\nfunction svSeCheck(tin) {\n  // Make copy of TIN and normalize to two-digit year form\n  var tin_copy = tin.slice(0);\n  if (tin.length > 11) {\n    tin_copy = tin_copy.slice(2);\n  }\n\n  // Extract date of birth\n  var full_year = '';\n  var month = tin_copy.slice(2, 4);\n  var day = parseInt(tin_copy.slice(4, 6), 10);\n  if (tin.length > 11) {\n    full_year = tin.slice(0, 4);\n  } else {\n    full_year = tin.slice(0, 2);\n    if (tin.length === 11 && day < 60) {\n      // Extract full year from centenarian symbol\n      // Should work just fine until year 10000 or so\n      var current_year = new Date().getFullYear().toString();\n      var current_century = parseInt(current_year.slice(0, 2), 10);\n      current_year = parseInt(current_year, 10);\n      if (tin[6] === '-') {\n        if (parseInt(\"\".concat(current_century).concat(full_year), 10) > current_year) {\n          full_year = \"\".concat(current_century - 1).concat(full_year);\n        } else {\n          full_year = \"\".concat(current_century).concat(full_year);\n        }\n      } else {\n        full_year = \"\".concat(current_century - 1).concat(full_year);\n        if (current_year - parseInt(full_year, 10) < 100) {\n          return false;\n        }\n      }\n    }\n  }\n\n  // Normalize day and check date validity\n  if (day > 60) {\n    day -= 60;\n  }\n  if (day < 10) {\n    day = \"0\".concat(day);\n  }\n  var date = \"\".concat(full_year, \"/\").concat(month, \"/\").concat(day);\n  if (date.length === 8) {\n    if (!(0, _isDate.default)(date, 'YY/MM/DD')) {\n      return false;\n    }\n  } else if (!(0, _isDate.default)(date, 'YYYY/MM/DD')) {\n    return false;\n  }\n  return algorithms.luhnCheck(tin.replace(/\\W/, ''));\n}\n\n/**\n * uk-UA validation function\n * Verify TIN validity by calculating check (last) digit (variant of MOD 11)\n */\nfunction ukUaCheck(tin) {\n  // Calculate check digit\n  var digits = tin.split('').map(function (a) {\n    return parseInt(a, 10);\n  });\n  var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];\n  var checksum = 0;\n  for (var i = 0; i < multipliers.length; i++) {\n    checksum += digits[i] * multipliers[i];\n  }\n  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;\n}\n\n// Locale lookup objects\n\n/*\n * Tax id regex formats for various locales\n *\n * Where not explicitly specified in DG-TAXUD document both\n * uppercase and lowercase letters are acceptable.\n */\nvar taxIdFormat = {\n  'bg-BG': /^\\d{10}$/,\n  'cs-CZ': /^\\d{6}\\/{0,1}\\d{3,4}$/,\n  'de-AT': /^\\d{9}$/,\n  'de-DE': /^[1-9]\\d{10}$/,\n  'dk-DK': /^\\d{6}-{0,1}\\d{4}$/,\n  'el-CY': /^[09]\\d{7}[A-Z]$/,\n  'el-GR': /^([0-4]|[7-9])\\d{8}$/,\n  'en-CA': /^\\d{9}$/,\n  'en-GB': /^\\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\\d{6}[ABCD ]$/i,\n  'en-IE': /^\\d{7}[A-W][A-IW]{0,1}$/i,\n  'en-US': /^\\d{2}[- ]{0,1}\\d{7}$/,\n  'es-AR': /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,\n  'es-ES': /^(\\d{0,8}|[XYZKLM]\\d{7})[A-HJ-NP-TV-Z]$/i,\n  'et-EE': /^[1-6]\\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\\d$/,\n  'fi-FI': /^\\d{6}[-+A]\\d{3}[0-9A-FHJ-NPR-Y]$/i,\n  'fr-BE': /^\\d{11}$/,\n  'fr-FR': /^[0-3]\\d{12}$|^[0-3]\\d\\s\\d{2}(\\s\\d{3}){3}$/,\n  // Conforms both to official spec and provided example\n  'fr-LU': /^\\d{13}$/,\n  'hr-HR': /^\\d{11}$/,\n  'hu-HU': /^8\\d{9}$/,\n  'it-IT': /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,\n  'lv-LV': /^\\d{6}-{0,1}\\d{5}$/,\n  // Conforms both to DG TAXUD spec and original research\n  'mt-MT': /^\\d{3,7}[APMGLHBZ]$|^([1-8])\\1\\d{7}$/i,\n  'nl-NL': /^\\d{9}$/,\n  'pl-PL': /^\\d{10,11}$/,\n  'pt-BR': /(?:^\\d{11}$)|(?:^\\d{14}$)/,\n  'pt-PT': /^\\d{9}$/,\n  'ro-RO': /^\\d{13}$/,\n  'sk-SK': /^\\d{6}\\/{0,1}\\d{3,4}$/,\n  'sl-SI': /^[1-9]\\d{7}$/,\n  'sv-SE': /^(\\d{6}[-+]{0,1}\\d{4}|(18|19|20)\\d{6}[-+]{0,1}\\d{4})$/,\n  'uk-UA': /^\\d{10}$/\n};\n// taxIdFormat locale aliases\ntaxIdFormat['lb-LU'] = taxIdFormat['fr-LU'];\ntaxIdFormat['lt-LT'] = taxIdFormat['et-EE'];\ntaxIdFormat['nl-BE'] = taxIdFormat['fr-BE'];\ntaxIdFormat['fr-CA'] = taxIdFormat['en-CA'];\n\n// Algorithmic tax id check functions for various locales\nvar taxIdCheck = {\n  'bg-BG': bgBgCheck,\n  'cs-CZ': csCzCheck,\n  'de-AT': deAtCheck,\n  'de-DE': deDeCheck,\n  'dk-DK': dkDkCheck,\n  'el-CY': elCyCheck,\n  'el-GR': elGrCheck,\n  'en-CA': isCanadianSIN,\n  'en-IE': enIeCheck,\n  'en-US': enUsCheck,\n  'es-AR': esArCheck,\n  'es-ES': esEsCheck,\n  'et-EE': etEeCheck,\n  'fi-FI': fiFiCheck,\n  'fr-BE': frBeCheck,\n  'fr-FR': frFrCheck,\n  'fr-LU': frLuCheck,\n  'hr-HR': hrHrCheck,\n  'hu-HU': huHuCheck,\n  'it-IT': itItCheck,\n  'lv-LV': lvLvCheck,\n  'mt-MT': mtMtCheck,\n  'nl-NL': nlNlCheck,\n  'pl-PL': plPlCheck,\n  'pt-BR': ptBrCheck,\n  'pt-PT': ptPtCheck,\n  'ro-RO': roRoCheck,\n  'sk-SK': skSkCheck,\n  'sl-SI': slSiCheck,\n  'sv-SE': svSeCheck,\n  'uk-UA': ukUaCheck\n};\n// taxIdCheck locale aliases\ntaxIdCheck['lb-LU'] = taxIdCheck['fr-LU'];\ntaxIdCheck['lt-LT'] = taxIdCheck['et-EE'];\ntaxIdCheck['nl-BE'] = taxIdCheck['fr-BE'];\ntaxIdCheck['fr-CA'] = taxIdCheck['en-CA'];\n\n// Regexes for locales where characters should be omitted before checking format\nvar allsymbols = /[-\\\\\\/!@#$%\\^&\\*\\(\\)\\+\\=\\[\\]]+/g;\nvar sanitizeRegexes = {\n  'de-AT': allsymbols,\n  'de-DE': /[\\/\\\\]/g,\n  'fr-BE': allsymbols\n};\n// sanitizeRegexes locale aliases\nsanitizeRegexes['nl-BE'] = sanitizeRegexes['fr-BE'];\n\n/*\n * Validator function\n * Return true if the passed string is a valid tax identification number\n * for the specified locale.\n * Throw an error exception if the locale is not supported.\n */\nfunction isTaxID(str) {\n  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n  (0, _assertString.default)(str);\n  // Copy TIN to avoid replacement if sanitized\n  var strcopy = str.slice(0);\n  if (locale in taxIdFormat) {\n    if (locale in sanitizeRegexes) {\n      strcopy = strcopy.replace(sanitizeRegexes[locale], '');\n    }\n    if (!taxIdFormat[locale].test(strcopy)) {\n      return false;\n    }\n    if (locale in taxIdCheck) {\n      return taxIdCheck[locale](strcopy);\n    }\n    // Fallthrough; not all locales have algorithmic checks\n    return true;\n  }\n  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMobilePhone;\nexports.locales = void 0;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* eslint-disable max-len */\nvar phones = {\n  'am-AM': /^(\\+?374|0)(33|4[134]|55|77|88|9[13-689])\\d{6}$/,\n  'ar-AE': /^((\\+?971)|0)?5[024568]\\d{7}$/,\n  'ar-BH': /^(\\+?973)?(3|6)\\d{7}$/,\n  'ar-DZ': /^(\\+?213|0)(5|6|7)\\d{8}$/,\n  'ar-LB': /^(\\+?961)?((3|81)\\d{6}|7\\d{7})$/,\n  'ar-EG': /^((\\+?20)|0)?1[0125]\\d{8}$/,\n  'ar-IQ': /^(\\+?964|0)?7[0-9]\\d{8}$/,\n  'ar-JO': /^(\\+?962|0)?7[789]\\d{7}$/,\n  'ar-KW': /^(\\+?965)([569]\\d{7}|41\\d{6})$/,\n  'ar-LY': /^((\\+?218)|0)?(9[1-6]\\d{7}|[1-8]\\d{7,9})$/,\n  'ar-MA': /^(?:(?:\\+|00)212|0)[5-7]\\d{8}$/,\n  'ar-OM': /^((\\+|00)968)?(9[1-9])\\d{6}$/,\n  'ar-PS': /^(\\+?970|0)5[6|9](\\d{7})$/,\n  'ar-SA': /^(!?(\\+?966)|0)?5\\d{8}$/,\n  'ar-SD': /^((\\+?249)|0)?(9[012369]|1[012])\\d{7}$/,\n  'ar-SY': /^(!?(\\+?963)|0)?9\\d{8}$/,\n  'ar-TN': /^(\\+?216)?[2459]\\d{7}$/,\n  'az-AZ': /^(\\+994|0)(10|5[015]|7[07]|99)\\d{7}$/,\n  'bs-BA': /^((((\\+|00)3876)|06))((([0-3]|[5-6])\\d{6})|(4\\d{7}))$/,\n  'be-BY': /^(\\+?375)?(24|25|29|33|44)\\d{7}$/,\n  'bg-BG': /^(\\+?359|0)?8[789]\\d{7}$/,\n  'bn-BD': /^(\\+?880|0)1[13456789][0-9]{8}$/,\n  'ca-AD': /^(\\+376)?[346]\\d{5}$/,\n  'cs-CZ': /^(\\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\n  'da-DK': /^(\\+?45)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  'de-DE': /^((\\+49|0)1)(5[0-25-9]\\d|6([23]|0\\d?)|7([0-57-9]|6\\d))\\d{7,9}$/,\n  'de-AT': /^(\\+43|0)\\d{1,4}\\d{3,12}$/,\n  'de-CH': /^(\\+41|0)([1-9])\\d{1,9}$/,\n  'de-LU': /^(\\+352)?((6\\d1)\\d{6})$/,\n  'dv-MV': /^(\\+?960)?(7[2-9]|9[1-9])\\d{5}$/,\n  'el-GR': /^(\\+?30|0)?6(8[5-9]|9(?![26])[0-9])\\d{7}$/,\n  'el-CY': /^(\\+?357?)?(9(9|6)\\d{6})$/,\n  'en-AI': /^(\\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\\d{4}$/,\n  'en-AU': /^(\\+?61|0)4\\d{8}$/,\n  'en-AG': /^(?:\\+1|1)268(?:464|7(?:1[3-9]|[28]\\d|3[0246]|64|7[0-689]))\\d{4}$/,\n  'en-BM': /^(\\+?1)?441(((3|7)\\d{6}$)|(5[0-3][0-9]\\d{4}$)|(59\\d{5}$))/,\n  'en-BS': /^(\\+?1[-\\s]?|0)?\\(?242\\)?[-\\s]?\\d{3}[-\\s]?\\d{4}$/,\n  'en-GB': /^(\\+?44|0)7\\d{9}$/,\n  'en-GG': /^(\\+?44|0)1481\\d{6}$/,\n  'en-GH': /^(\\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\\d{7}$/,\n  'en-GY': /^(\\+592|0)6\\d{6}$/,\n  'en-HK': /^(\\+?852[-\\s]?)?[456789]\\d{3}[-\\s]?\\d{4}$/,\n  'en-MO': /^(\\+?853[-\\s]?)?[6]\\d{3}[-\\s]?\\d{4}$/,\n  'en-IE': /^(\\+?353|0)8[356789]\\d{7}$/,\n  'en-IN': /^(\\+?91|0)?[6789]\\d{9}$/,\n  'en-JM': /^(\\+?876)?\\d{7}$/,\n  'en-KE': /^(\\+?254|0)(7|1)\\d{8}$/,\n  'fr-CF': /^(\\+?236| ?)(70|75|77|72|21|22)\\d{6}$/,\n  'en-SS': /^(\\+?211|0)(9[1257])\\d{7}$/,\n  'en-KI': /^((\\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,\n  'en-KN': /^(?:\\+1|1)869(?:46\\d|48[89]|55[6-8]|66\\d|76[02-7])\\d{4}$/,\n  'en-LS': /^(\\+?266)(22|28|57|58|59|27|52)\\d{6}$/,\n  'en-MT': /^(\\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,\n  'en-MU': /^(\\+?230|0)?\\d{8}$/,\n  'en-MW': /^(\\+?265|0)(((77|88|31|99|98|21)\\d{7})|(((111)|1)\\d{6})|(32000\\d{4}))$/,\n  'en-NA': /^(\\+?264|0)(6|8)\\d{7}$/,\n  'en-NG': /^(\\+?234|0)?[789]\\d{9}$/,\n  'en-NZ': /^(\\+?64|0)[28]\\d{7,9}$/,\n  'en-PG': /^(\\+?675|0)?(7\\d|8[18])\\d{6}$/,\n  'en-PK': /^((00|\\+)?92|0)3[0-6]\\d{8}$/,\n  'en-PH': /^(09|\\+639)\\d{9}$/,\n  'en-RW': /^(\\+?250|0)?[7]\\d{8}$/,\n  'en-SG': /^(\\+65)?[3689]\\d{7}$/,\n  'en-SL': /^(\\+?232|0)\\d{8}$/,\n  'en-TZ': /^(\\+?255|0)?[67]\\d{8}$/,\n  'en-UG': /^(\\+?256|0)?[7]\\d{8}$/,\n  'en-US': /^((\\+1|1)?( |-)?)?(\\([2-9][0-9]{2}\\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,\n  'en-ZA': /^(\\+?27|0)\\d{9}$/,\n  'en-ZM': /^(\\+?26)?09[567]\\d{7}$/,\n  'en-ZW': /^(\\+263)[0-9]{9}$/,\n  'en-BW': /^(\\+?267)?(7[1-8]{1})\\d{6}$/,\n  'es-AR': /^\\+?549(11|[2368]\\d)\\d{8}$/,\n  'es-BO': /^(\\+?591)?(6|7)\\d{7}$/,\n  'es-CO': /^(\\+?57)?3(0(0|1|2|4|5)|1\\d|2[0-4]|5(0|1))\\d{7}$/,\n  'es-CL': /^(\\+?56|0)[2-9]\\d{1}\\d{7}$/,\n  'es-CR': /^(\\+506)?[2-8]\\d{7}$/,\n  'es-CU': /^(\\+53|0053)?5\\d{7}$/,\n  'es-DO': /^(\\+?1)?8[024]9\\d{7}$/,\n  'es-HN': /^(\\+?504)?[9|8|3|2]\\d{7}$/,\n  'es-EC': /^(\\+?593|0)([2-7]|9[2-9])\\d{7}$/,\n  'es-ES': /^(\\+?34)?[6|7]\\d{8}$/,\n  'es-PE': /^(\\+?51)?9\\d{8}$/,\n  'es-MX': /^(\\+?52)?(1|01)?\\d{10,11}$/,\n  'es-NI': /^(\\+?505)\\d{7,8}$/,\n  'es-PA': /^(\\+?507)\\d{7,8}$/,\n  'es-PY': /^(\\+?595|0)9[9876]\\d{7}$/,\n  'es-SV': /^(\\+?503)?[67]\\d{7}$/,\n  'es-UY': /^(\\+598|0)9[1-9][\\d]{6}$/,\n  'es-VE': /^(\\+?58)?(2|4)\\d{9}$/,\n  'et-EE': /^(\\+?372)?\\s?(5|8[1-4])\\s?([0-9]\\s?){6,7}$/,\n  'fa-IR': /^(\\+?98[\\-\\s]?|0)9[0-39]\\d[\\-\\s]?\\d{3}[\\-\\s]?\\d{4}$/,\n  'fi-FI': /^(\\+?358|0)\\s?(4[0-6]|50)\\s?(\\d\\s?){4,8}$/,\n  'fj-FJ': /^(\\+?679)?\\s?\\d{3}\\s?\\d{4}$/,\n  'fo-FO': /^(\\+?298)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  'fr-BF': /^(\\+226|0)[67]\\d{7}$/,\n  'fr-BJ': /^(\\+229)\\d{8}$/,\n  'fr-CD': /^(\\+?243|0)?(8|9)\\d{8}$/,\n  'fr-CM': /^(\\+?237)6[0-9]{8}$/,\n  'fr-FR': /^(\\+?33|0)[67]\\d{8}$/,\n  'fr-GF': /^(\\+?594|0|00594)[67]\\d{8}$/,\n  'fr-GP': /^(\\+?590|0|00590)[67]\\d{8}$/,\n  'fr-MQ': /^(\\+?596|0|00596)[67]\\d{8}$/,\n  'fr-PF': /^(\\+?689)?8[789]\\d{6}$/,\n  'fr-RE': /^(\\+?262|0|00262)[67]\\d{8}$/,\n  'fr-WF': /^(\\+681)?\\d{6}$/,\n  'he-IL': /^(\\+972|0)([23489]|5[012345689]|77)[1-9]\\d{6}$/,\n  'hu-HU': /^(\\+?36|06)(20|30|31|50|70)\\d{7}$/,\n  'id-ID': /^(\\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\\s?|\\d]{5,11})$/,\n  'ir-IR': /^(\\+98|0)?9\\d{9}$/,\n  'it-IT': /^(\\+?39)?\\s?3\\d{2} ?\\d{6,7}$/,\n  'it-SM': /^((\\+378)|(0549)|(\\+390549)|(\\+3780549))?6\\d{5,9}$/,\n  'ja-JP': /^(\\+81[ \\-]?(\\(0\\))?|0)[6789]0[ \\-]?\\d{4}[ \\-]?\\d{4}$/,\n  'ka-GE': /^(\\+?995)?(79\\d{7}|5\\d{8})$/,\n  'kk-KZ': /^(\\+?7|8)?7\\d{9}$/,\n  'kl-GL': /^(\\+?299)?\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}$/,\n  'ko-KR': /^((\\+?82)[ \\-]?)?0?1([0|1|6|7|8|9]{1})[ \\-]?\\d{3,4}[ \\-]?\\d{4}$/,\n  'ky-KG': /^(\\+?7\\s?\\+?7|0)\\s?\\d{2}\\s?\\d{3}\\s?\\d{4}$/,\n  'lt-LT': /^(\\+370|8)\\d{8}$/,\n  'lv-LV': /^(\\+?371)2\\d{7}$/,\n  'mg-MG': /^((\\+?261|0)(2|3)\\d)?\\d{7}$/,\n  'mn-MN': /^(\\+|00|011)?976(77|81|88|91|94|95|96|99)\\d{6}$/,\n  'my-MM': /^(\\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,\n  'ms-MY': /^(\\+?60|0)1(([0145](-|\\s)?\\d{7,8})|([236-9](-|\\s)?\\d{7}))$/,\n  'mz-MZ': /^(\\+?258)?8[234567]\\d{7}$/,\n  'nb-NO': /^(\\+?47)?[49]\\d{7}$/,\n  'ne-NP': /^(\\+?977)?9[78]\\d{8}$/,\n  'nl-BE': /^(\\+?32|0)4\\d{8}$/,\n  'nl-NL': /^(((\\+|00)?31\\(0\\))|((\\+|00)?31)|0)6{1}\\d{8}$/,\n  'nl-AW': /^(\\+)?297(56|59|64|73|74|99)\\d{5}$/,\n  'nn-NO': /^(\\+?47)?[49]\\d{7}$/,\n  'pl-PL': /^(\\+?48)? ?([5-8]\\d|45) ?\\d{3} ?\\d{2} ?\\d{2}$/,\n  'pt-BR': /^((\\+?55\\ ?[1-9]{2}\\ ?)|(\\+?55\\ ?\\([1-9]{2}\\)\\ ?)|(0[1-9]{2}\\ ?)|(\\([1-9]{2}\\)\\ ?)|([1-9]{2}\\ ?))((\\d{4}\\-?\\d{4})|(9[1-9]{1}\\d{3}\\-?\\d{4}))$/,\n  'pt-PT': /^(\\+?351)?9[1236]\\d{7}$/,\n  'pt-AO': /^(\\+244)\\d{9}$/,\n  'ro-MD': /^(\\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\\d{6}$/,\n  'ro-RO': /^(\\+?40|0)\\s?7\\d{2}(\\/|\\s|\\.|-)?\\d{3}(\\s|\\.|-)?\\d{3}$/,\n  'ru-RU': /^(\\+?7|8)?9\\d{9}$/,\n  'si-LK': /^(?:0|94|\\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\\d{7}$/,\n  'sl-SI': /^(\\+386\\s?|0)(\\d{1}\\s?\\d{3}\\s?\\d{2}\\s?\\d{2}|\\d{2}\\s?\\d{3}\\s?\\d{3})$/,\n  'sk-SK': /^(\\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,\n  'so-SO': /^(\\+?252|0)((6[0-9])\\d{7}|(7[1-9])\\d{7})$/,\n  'sq-AL': /^(\\+355|0)6[789]\\d{6}$/,\n  'sr-RS': /^(\\+3816|06)[- \\d]{5,9}$/,\n  'sv-SE': /^(\\+?46|0)[\\s\\-]?7[\\s\\-]?[02369]([\\s\\-]?\\d){7}$/,\n  'tg-TJ': /^(\\+?992)?[5][5]\\d{7}$/,\n  'th-TH': /^(\\+66|66|0)\\d{9}$/,\n  'tr-TR': /^(\\+?90|0)?5\\d{9}$/,\n  'tk-TM': /^(\\+993|993|8)\\d{8}$/,\n  'uk-UA': /^(\\+?38|8)?0\\d{9}$/,\n  'uz-UZ': /^(\\+?998)?(6[125-79]|7[1-69]|88|9\\d)\\d{7}$/,\n  'vi-VN': /^((\\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,\n  'zh-CN': /^((\\+|00)86)?(1[3-9]|9[28])\\d{9}$/,\n  'zh-TW': /^(\\+?886\\-?|0)?9\\d{8}$/,\n  'dz-BT': /^(\\+?975|0)?(17|16|77|02)\\d{6}$/,\n  'ar-YE': /^(((\\+|00)9677|0?7)[0137]\\d{7}|((\\+|00)967|0)[1-7]\\d{6})$/,\n  'ar-EH': /^(\\+?212|0)[\\s\\-]?(5288|5289)[\\s\\-]?\\d{5}$/,\n  'fa-AF': /^(\\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\\d{7})$/\n};\n/* eslint-enable max-len */\n\n// aliases\nphones['en-CA'] = phones['en-US'];\nphones['fr-CA'] = phones['en-CA'];\nphones['fr-BE'] = phones['nl-BE'];\nphones['zh-HK'] = phones['en-HK'];\nphones['zh-MO'] = phones['en-MO'];\nphones['ga-IE'] = phones['en-IE'];\nphones['fr-CH'] = phones['de-CH'];\nphones['it-CH'] = phones['fr-CH'];\nfunction isMobilePhone(str, locale, options) {\n  (0, _assertString.default)(str);\n  if (options && options.strictMode && !str.startsWith('+')) {\n    return false;\n  }\n  if (Array.isArray(locale)) {\n    return locale.some(function (key) {\n      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes\n      // istanbul ignore else\n      if (phones.hasOwnProperty(key)) {\n        var phone = phones[key];\n        if (phone.test(str)) {\n          return true;\n        }\n      }\n      return false;\n    });\n  } else if (locale in phones) {\n    return phones[locale].test(str);\n    // alias falsey locale as 'any'\n  } else if (!locale || locale === 'any') {\n    for (var key in phones) {\n      // istanbul ignore else\n      if (phones.hasOwnProperty(key)) {\n        var phone = phones[key];\n        if (phone.test(str)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  throw new Error(\"Invalid locale '\".concat(locale, \"'\"));\n}\nvar locales = exports.locales = Object.keys(phones);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isEthereumAddress;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar eth = /^(0x)[0-9a-f]{40}$/i;\nfunction isEthereumAddress(str) {\n  (0, _assertString.default)(str);\n  return eth.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isCurrency;\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction currencyRegex(options) {\n  var decimal_digits = \"\\\\d{\".concat(options.digits_after_decimal[0], \"}\");\n  options.digits_after_decimal.forEach(function (digit, index) {\n    if (index !== 0) decimal_digits = \"\".concat(decimal_digits, \"|\\\\d{\").concat(digit, \"}\");\n  });\n  var symbol = \"(\".concat(options.symbol.replace(/\\W/, function (m) {\n      return \"\\\\\".concat(m);\n    }), \")\").concat(options.require_symbol ? '' : '?'),\n    negative = '-?',\n    whole_dollar_amount_without_sep = '[1-9]\\\\d*',\n    whole_dollar_amount_with_sep = \"[1-9]\\\\d{0,2}(\\\\\".concat(options.thousands_separator, \"\\\\d{3})*\"),\n    valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],\n    whole_dollar_amount = \"(\".concat(valid_whole_dollar_amounts.join('|'), \")?\"),\n    decimal_amount = \"(\\\\\".concat(options.decimal_separator, \"(\").concat(decimal_digits, \"))\").concat(options.require_decimal ? '' : '?');\n  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');\n\n  // default is negative sign before symbol, but there are two other options (besides parens)\n  if (options.allow_negatives && !options.parens_for_negatives) {\n    if (options.negative_sign_after_digits) {\n      pattern += negative;\n    } else if (options.negative_sign_before_digits) {\n      pattern = negative + pattern;\n    }\n  }\n\n  // South African Rand, for example, uses R 123 (space) and R-123 (no space)\n  if (options.allow_negative_sign_placeholder) {\n    pattern = \"( (?!\\\\-))?\".concat(pattern);\n  } else if (options.allow_space_after_symbol) {\n    pattern = \" ?\".concat(pattern);\n  } else if (options.allow_space_after_digits) {\n    pattern += '( (?!$))?';\n  }\n  if (options.symbol_after_digits) {\n    pattern += symbol;\n  } else {\n    pattern = symbol + pattern;\n  }\n  if (options.allow_negatives) {\n    if (options.parens_for_negatives) {\n      pattern = \"(\\\\(\".concat(pattern, \"\\\\)|\").concat(pattern, \")\");\n    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {\n      pattern = negative + pattern;\n    }\n  }\n\n  // ensure there's a dollar and/or decimal amount, and that\n  // it doesn't start with a space or a negative sign followed by a space\n  return new RegExp(\"^(?!-? )(?=.*\\\\d)\".concat(pattern, \"$\"));\n}\nvar default_currency_options = {\n  symbol: '$',\n  require_symbol: false,\n  allow_space_after_symbol: false,\n  symbol_after_digits: false,\n  allow_negatives: true,\n  parens_for_negatives: false,\n  negative_sign_before_digits: false,\n  negative_sign_after_digits: false,\n  allow_negative_sign_placeholder: false,\n  thousands_separator: ',',\n  decimal_separator: '.',\n  allow_decimal: true,\n  require_decimal: false,\n  digits_after_decimal: [2],\n  allow_space_after_digits: false\n};\nfunction isCurrency(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, default_currency_options);\n  return currencyRegex(options).test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBtcAddress;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar bech32 = /^(bc1)[a-z0-9]{25,39}$/;\nvar base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;\nfunction isBtcAddress(str) {\n  (0, _assertString.default)(str);\n  return bech32.test(str) || base58.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFreightContainerID = void 0;\nexports.isISO6346 = isISO6346;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// https://en.wikipedia.org/wiki/ISO_6346\n// according to ISO6346 standard, checksum digit is mandatory for freight container but recommended\n// for other container types (J and Z)\nvar isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;\nvar isDigit = /^[0-9]$/;\nfunction isISO6346(str) {\n  (0, _assertString.default)(str);\n  str = str.toUpperCase();\n  if (!isISO6346Str.test(str)) return false;\n  if (str.length === 11) {\n    var sum = 0;\n    for (var i = 0; i < str.length - 1; i++) {\n      if (!isDigit.test(str[i])) {\n        var convertedCode = void 0;\n        var letterCode = str.charCodeAt(i) - 55;\n        if (letterCode < 11) convertedCode = letterCode;else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;else convertedCode = 34 + letterCode % 31;\n        sum += convertedCode * Math.pow(2, i);\n      } else sum += str[i] * Math.pow(2, i);\n    }\n    var checkSumDigit = sum % 11;\n    return Number(str[str.length - 1]) === checkSumDigit;\n  }\n  return true;\n}\nvar isFreightContainerID = exports.isFreightContainerID = isISO6346;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isISO6391;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar isISO6391Set = new Set(['aa', 'ab', 'ae', 'af', 'ak', 'am', 'an', 'ar', 'as', 'av', 'ay', 'az', 'az', 'ba', 'be', 'bg', 'bh', 'bi', 'bm', 'bn', 'bo', 'br', 'bs', 'ca', 'ce', 'ch', 'co', 'cr', 'cs', 'cu', 'cv', 'cy', 'da', 'de', 'dv', 'dz', 'ee', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'ff', 'fi', 'fj', 'fo', 'fr', 'fy', 'ga', 'gd', 'gl', 'gn', 'gu', 'gv', 'ha', 'he', 'hi', 'ho', 'hr', 'ht', 'hu', 'hy', 'hz', 'ia', 'id', 'ie', 'ig', 'ii', 'ik', 'io', 'is', 'it', 'iu', 'ja', 'jv', 'ka', 'kg', 'ki', 'kj', 'kk', 'kl', 'km', 'kn', 'ko', 'kr', 'ks', 'ku', 'kv', 'kw', 'ky', 'la', 'lb', 'lg', 'li', 'ln', 'lo', 'lt', 'lu', 'lv', 'mg', 'mh', 'mi', 'mk', 'ml', 'mn', 'mr', 'ms', 'mt', 'my', 'na', 'nb', 'nd', 'ne', 'ng', 'nl', 'nn', 'no', 'nr', 'nv', 'ny', 'oc', 'oj', 'om', 'or', 'os', 'pa', 'pi', 'pl', 'ps', 'pt', 'qu', 'rm', 'rn', 'ro', 'ru', 'rw', 'sa', 'sc', 'sd', 'se', 'sg', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'ss', 'st', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'ti', 'tk', 'tl', 'tn', 'to', 'tr', 'ts', 'tt', 'tw', 'ty', 'ug', 'uk', 'ur', 'uz', 've', 'vi', 'vo', 'wa', 'wo', 'xh', 'yi', 'yo', 'za', 'zh', 'zu']);\nfunction isISO6391(str) {\n  (0, _assertString.default)(str);\n  return isISO6391Set.has(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isISO8601;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* eslint-disable max-len */\n// from http://goo.gl/0ejHHW\nvar iso8601 = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T\\s]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n// same as above, except with a strict 'T' separator between date and time\nvar iso8601StrictSeparator = /^([\\+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([\\.,]\\d+(?!:))?)?(\\17[0-5]\\d([\\.,]\\d+)?)?([zZ]|([\\+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\n/* eslint-enable max-len */\nvar isValidDate = function isValidDate(str) {\n  // str must have passed the ISO8601 check\n  // this check is meant to catch invalid dates\n  // like 2009-02-31\n  // first check for ordinal dates\n  var ordinalMatch = str.match(/^(\\d{4})-?(\\d{3})([ T]{1}\\.*|$)/);\n  if (ordinalMatch) {\n    var oYear = Number(ordinalMatch[1]);\n    var oDay = Number(ordinalMatch[2]);\n    // if is leap year\n    if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;\n    return oDay <= 365;\n  }\n  var match = str.match(/(\\d{4})-?(\\d{0,2})-?(\\d*)/).map(Number);\n  var year = match[1];\n  var month = match[2];\n  var day = match[3];\n  var monthString = month ? \"0\".concat(month).slice(-2) : month;\n  var dayString = day ? \"0\".concat(day).slice(-2) : day;\n\n  // create a date object and compare\n  var d = new Date(\"\".concat(year, \"-\").concat(monthString || '01', \"-\").concat(dayString || '01'));\n  if (month && day) {\n    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;\n  }\n  return true;\n};\nfunction isISO8601(str) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  (0, _assertString.default)(str);\n  var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);\n  if (check && options.strict) return isValidDate(str);\n  return check;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isRFC3339;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */\n\nvar dateFullYear = /[0-9]{4}/;\nvar dateMonth = /(0[1-9]|1[0-2])/;\nvar dateMDay = /([12]\\d|0[1-9]|3[01])/;\nvar timeHour = /([01][0-9]|2[0-3])/;\nvar timeMinute = /[0-5][0-9]/;\nvar timeSecond = /([0-5][0-9]|60)/;\nvar timeSecFrac = /(\\.[0-9]+)?/;\nvar timeNumOffset = new RegExp(\"[-+]\".concat(timeHour.source, \":\").concat(timeMinute.source));\nvar timeOffset = new RegExp(\"([zZ]|\".concat(timeNumOffset.source, \")\"));\nvar partialTime = new RegExp(\"\".concat(timeHour.source, \":\").concat(timeMinute.source, \":\").concat(timeSecond.source).concat(timeSecFrac.source));\nvar fullDate = new RegExp(\"\".concat(dateFullYear.source, \"-\").concat(dateMonth.source, \"-\").concat(dateMDay.source));\nvar fullTime = new RegExp(\"\".concat(partialTime.source).concat(timeOffset.source));\nvar rfc3339 = new RegExp(\"^\".concat(fullDate.source, \"[ tT]\").concat(fullTime.source, \"$\"));\nfunction isRFC3339(str) {\n  (0, _assertString.default)(str);\n  return rfc3339.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isISO31661Alpha3;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3\nvar validISO31661Alpha3CountriesCodes = new Set(['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE']);\nfunction isISO31661Alpha3(str) {\n  (0, _assertString.default)(str);\n  return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CurrencyCodes = void 0;\nexports.default = isISO4217;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// from https://en.wikipedia.org/wiki/ISO_4217\nvar validISO4217CurrencyCodes = new Set(['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYN', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLE', 'SLL', 'SOS', 'SRD', 'SSP', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'UYI', 'UYU', 'UYW', 'UZS', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XAG', 'XAU', 'XBA', 'XBB', 'XBC', 'XBD', 'XCD', 'XDR', 'XOF', 'XPD', 'XPF', 'XPT', 'XSU', 'XTS', 'XUA', 'XXX', 'YER', 'ZAR', 'ZMW', 'ZWL']);\nfunction isISO4217(str) {\n  (0, _assertString.default)(str);\n  return validISO4217CurrencyCodes.has(str.toUpperCase());\n}\nvar CurrencyCodes = exports.CurrencyCodes = validISO4217CurrencyCodes;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBase32;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar base32 = /^[A-Z2-7]+=*$/;\nvar crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;\nvar defaultBase32Options = {\n  crockford: false\n};\nfunction isBase32(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, defaultBase32Options);\n  if (options.crockford) {\n    return crockfordBase32.test(str);\n  }\n  var len = str.length;\n  if (len % 8 === 0 && base32.test(str)) {\n    return true;\n  }\n  return false;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isBase58;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n// Accepted chars - 123456789ABCDEFGH JKLMN PQRSTUVWXYZabcdefghijk mnopqrstuvwxyz\nvar base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;\nfunction isBase58(str) {\n  (0, _assertString.default)(str);\n  if (base58Reg.test(str)) {\n    return true;\n  }\n  return false;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isDataURI;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar validMediaType = /^[a-z]+\\/[a-z0-9\\-\\+\\._]+$/i;\nvar validAttribute = /^[a-z\\-]+=[a-z0-9\\-]+$/i;\nvar validData = /^[a-z0-9!\\$&'\\(\\)\\*\\+,;=\\-\\._~:@\\/\\?%\\s]*$/i;\nfunction isDataURI(str) {\n  (0, _assertString.default)(str);\n  var data = str.split(',');\n  if (data.length < 2) {\n    return false;\n  }\n  var attributes = data.shift().trim().split(';');\n  var schemeAndMediaType = attributes.shift();\n  if (schemeAndMediaType.slice(0, 5) !== 'data:') {\n    return false;\n  }\n  var mediaType = schemeAndMediaType.slice(5);\n  if (mediaType !== '' && !validMediaType.test(mediaType)) {\n    return false;\n  }\n  for (var i = 0; i < attributes.length; i++) {\n    if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') && !validAttribute.test(attributes[i])) {\n      return false;\n    }\n  }\n  for (var _i = 0; _i < data.length; _i++) {\n    if (!validData.test(data[_i])) {\n      return false;\n    }\n  }\n  return true;\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMagnetURI;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar magnetURIComponent = /(?:^magnet:\\?|[^?&]&)xt(?:\\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;\nfunction isMagnetURI(url) {\n  (0, _assertString.default)(url);\n  if (url.indexOf('magnet:?') !== 0) {\n    return false;\n  }\n  return magnetURIComponent.test(url);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rtrim;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction rtrim(str, chars) {\n  (0, _assertString.default)(str);\n  if (chars) {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n    var pattern = new RegExp(\"[\".concat(chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), \"]+$\"), 'g');\n    return str.replace(pattern, '');\n  }\n  // Use a faster and more safe than regex trim method https://blog.stevenlevithan.com/archives/faster-trim-javascript\n  var strIndex = str.length - 1;\n  while (/\\s/.test(str.charAt(strIndex))) {\n    strIndex -= 1;\n  }\n  return str.slice(0, strIndex + 1);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ltrim;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction ltrim(str, chars) {\n  (0, _assertString.default)(str);\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n  var pattern = chars ? new RegExp(\"^[\".concat(chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), \"]+\"), 'g') : /^\\s+/g;\n  return str.replace(pattern, '');\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = trim;\nvar _rtrim = _interopRequireDefault(require(\"./rtrim\"));\nvar _ltrim = _interopRequireDefault(require(\"./ltrim\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction trim(str, chars) {\n  return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMailtoURI;\nvar _trim = _interopRequireDefault(require(\"./trim\"));\nvar _isEmail = _interopRequireDefault(require(\"./isEmail\"));\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction parseMailtoQueryString(queryString) {\n  var allowedParams = new Set(['subject', 'body', 'cc', 'bcc']),\n    query = {\n      cc: '',\n      bcc: ''\n    };\n  var isParseFailed = false;\n  var queryParams = queryString.split('&');\n  if (queryParams.length > 4) {\n    return false;\n  }\n  var _iterator = _createForOfIteratorHelper(queryParams),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var q = _step.value;\n      var _q$split = q.split('='),\n        _q$split2 = _slicedToArray(_q$split, 2),\n        key = _q$split2[0],\n        value = _q$split2[1];\n\n      // checked for invalid and duplicated query params\n      if (key && !allowedParams.has(key)) {\n        isParseFailed = true;\n        break;\n      }\n      if (value && (key === 'cc' || key === 'bcc')) {\n        query[key] = value;\n      }\n      if (key) {\n        allowedParams.delete(key);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return isParseFailed ? false : query;\n}\nfunction isMailtoURI(url, options) {\n  (0, _assertString.default)(url);\n  if (url.indexOf('mailto:') !== 0) {\n    return false;\n  }\n  var _url$replace$split = url.replace('mailto:', '').split('?'),\n    _url$replace$split2 = _slicedToArray(_url$replace$split, 2),\n    to = _url$replace$split2[0],\n    _url$replace$split2$ = _url$replace$split2[1],\n    queryString = _url$replace$split2$ === void 0 ? '' : _url$replace$split2$;\n  if (!to && !queryString) {\n    return true;\n  }\n  var query = parseMailtoQueryString(queryString);\n  if (!query) {\n    return false;\n  }\n  return \"\".concat(to, \",\").concat(query.cc, \",\").concat(query.bcc).split(',').every(function (email) {\n    email = (0, _trim.default)(email, ' ');\n    if (email) {\n      return (0, _isEmail.default)(email, options);\n    }\n    return true;\n  });\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isMimeType;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n/*\n  Checks if the provided string matches to a correct Media type format (MIME type)\n\n  This function only checks is the string format follows the\n  etablished rules by the according RFC specifications.\n  This function supports 'charset' in textual media types\n  (https://tools.ietf.org/html/rfc6657).\n\n  This function does not check against all the media types listed\n  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)\n  because of lightness purposes : it would require to include\n  all these MIME types in this librairy, which would weigh it\n  significantly. This kind of effort maybe is not worth for the use that\n  this function has in this entire librairy.\n\n  More informations in the RFC specifications :\n  - https://tools.ietf.org/html/rfc2045\n  - https://tools.ietf.org/html/rfc2046\n  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1\n  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n*/\n\n// Match simple MIME types\n// NB :\n//   Subtype length must not exceed 100 characters.\n//   This rule does not comply to the RFC specs (what is the max length ?).\nvar mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\\/[a-zA-Z0-9\\.\\-\\+_]{1,100}$/i; // eslint-disable-line max-len\n\n// Handle \"charset\" in \"text/*\"\nvar mimeTypeText = /^text\\/[a-zA-Z0-9\\.\\-\\+]{1,100};\\s?charset=(\"[a-zA-Z0-9\\.\\-\\+\\s]{0,70}\"|[a-zA-Z0-9\\.\\-\\+]{0,70})(\\s?\\([a-zA-Z0-9\\.\\-\\+\\s]{1,20}\\))?$/i; // eslint-disable-line max-len\n\n// Handle \"boundary\" in \"multipart/*\"\nvar mimeTypeMultipart = /^multipart\\/[a-zA-Z0-9\\.\\-\\+]{1,100}(;\\s?(boundary|charset)=(\"[a-zA-Z0-9\\.\\-\\+\\s]{0,70}\"|[a-zA-Z0-9\\.\\-\\+]{0,70})(\\s?\\([a-zA-Z0-9\\.\\-\\+\\s]{1,20}\\))?){0,2}$/i; // eslint-disable-line max-len\n\nfunction isMimeType(str) {\n  (0, _assertString.default)(str);\n  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isLatLong;\nvar _assertString = _interopRequireDefault(require(\"./util/assertString\"));\nvar _merge = _interopRequireDefault(require(\"./util/merge\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nvar lat = /^\\(?[+-]?(90(\\.0+)?|[1-8]?\\d(\\.\\d+)?)$/;\nvar long = /^\\s?[+-]?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|\\d{1,2}(\\.\\d+)?)\\)?$/;\nvar latDMS = /^(([1-8]?\\d)\\D+([1-5]?\\d|60)\\D+([1-5]?\\d|60)(\\.\\d+)?|90\\D+0\\D+0)\\D+[NSns]?$/i;\nvar longDMS = /^\\s*([1-7]?\\d{1,2}\\D+([1-5]?\\d|60)\\D+([1-5]?\\d|60)(\\.\\d+)?|180\\D+0\\D+0)\\D+[EWew]?$/i;\nvar defaultLatLongOptions = {\n  checkDMS: false\n};\nfunction isLatLong(str, options) {\n  (0, _assertString.default)(str);\n  options = (0, _merge.default)(options, defaultLatLongOptions);\n  if (!str.includes(',')) return false;\n  var pair = str.split(',');\n  if (pair[0].startsWith('(') && !pair[1].endsWith(')') || pair[1].endsWith(')') && !pair[0].startsWith('(')) return false;\n  if (options.checkDMS) {\n    return latDMS.test(pair[0]) && longDMS.test(pair[1]);\n  }\n  return lat.test(pair[0]) && long.test(pair[1]);\n}\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;\nvar domhandler_1 = require(\"domhandler\");\nvar dom_serializer_1 = __importDefault(require(\"dom-serializer\"));\nvar domelementtype_1 = require(\"domelementtype\");\n/**\n * @param node Node to get the outer HTML of.\n * @param options Options for serialization.\n * @deprecated Use the `dom-serializer` module directly.\n * @returns `node`'s outer HTML.\n */\nfunction getOuterHTML(node, options) {\n    return (0, dom_serializer_1.default)(node, options);\n}\nexports.getOuterHTML = getOuterHTML;\n/**\n * @param node Node to get the inner HTML of.\n * @param options Options for serialization.\n * @deprecated Use the `dom-serializer` module directly.\n * @returns `node`'s inner HTML.\n */\nfunction getInnerHTML(node, options) {\n    return (0, domhandler_1.hasChildren)(node)\n        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join(\"\")\n        : \"\";\n}\nexports.getInnerHTML = getInnerHTML;\n/**\n * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.\n *\n * @deprecated Use `textContent` instead.\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n */\nfunction getText(node) {\n    if (Array.isArray(node))\n        return node.map(getText).join(\"\");\n    if ((0, domhandler_1.isTag)(node))\n        return node.name === \"br\" ? \"\\n\" : getText(node.children);\n    if ((0, domhandler_1.isCDATA)(node))\n        return getText(node.children);\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.getText = getText;\n/**\n * Get a node's text content.\n *\n * @param node Node to get the text content of.\n * @returns `node`'s text content.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}\n */\nfunction textContent(node) {\n    if (Array.isArray(node))\n        return node.map(textContent).join(\"\");\n    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {\n        return textContent(node.children);\n    }\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.textContent = textContent;\n/**\n * Get a node's inner text.\n *\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}\n */\nfunction innerText(node) {\n    if (Array.isArray(node))\n        return node.map(innerText).join(\"\");\n    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {\n        return innerText(node.children);\n    }\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.innerText = innerText;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.aliases = void 0;\n/**\n * Aliases are pseudos that are expressed as selectors.\n */\nexports.aliases = {\n    // Links\n    \"any-link\": \":is(a, area, link)[href]\",\n    link: \":any-link:not(:visited)\",\n    // Forms\n    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements\n    disabled: \":is(\\n        :is(button, input, select, textarea, optgroup, option)[disabled],\\n        optgroup[disabled] > option,\\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\\n    )\",\n    enabled: \":not(:disabled)\",\n    checked: \":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)\",\n    required: \":is(input, select, textarea)[required]\",\n    optional: \":is(input, select, textarea):not([required])\",\n    // JQuery extensions\n    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness\n    selected: \"option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)\",\n    checkbox: \"[type=checkbox]\",\n    file: \"[type=file]\",\n    password: \"[type=password]\",\n    radio: \"[type=radio]\",\n    reset: \"[type=reset]\",\n    image: \"[type=image]\",\n    submit: \"[type=submit]\",\n    parent: \":not(:empty)\",\n    header: \":is(h1, h2, h3, h4, h5, h6)\",\n    button: \":is(button, input[type=button])\",\n    input: \":is(input, textarea, select, button)\",\n    text: \"input:is(:not([type!='']), [type=text])\",\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar decode_codepoint_1 = __importDefault(require(\"entities/lib/decode_codepoint\"));\nvar entities_json_1 = __importDefault(require(\"entities/lib/maps/entities.json\"));\nvar legacy_json_1 = __importDefault(require(\"entities/lib/maps/legacy.json\"));\nvar xml_json_1 = __importDefault(require(\"entities/lib/maps/xml.json\"));\nfunction whitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\t\" || c === \"\\f\" || c === \"\\r\";\n}\nfunction isASCIIAlpha(c) {\n    return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n}\nfunction ifElseState(upper, SUCCESS, FAILURE) {\n    var lower = upper.toLowerCase();\n    if (upper === lower) {\n        return function (t, c) {\n            if (c === lower) {\n                t._state = SUCCESS;\n            }\n            else {\n                t._state = FAILURE;\n                t._index--;\n            }\n        };\n    }\n    return function (t, c) {\n        if (c === lower || c === upper) {\n            t._state = SUCCESS;\n        }\n        else {\n            t._state = FAILURE;\n            t._index--;\n        }\n    };\n}\nfunction consumeSpecialNameChar(upper, NEXT_STATE) {\n    var lower = upper.toLowerCase();\n    return function (t, c) {\n        if (c === lower || c === upper) {\n            t._state = NEXT_STATE;\n        }\n        else {\n            t._state = 3 /* InTagName */;\n            t._index--; // Consume the token again\n        }\n    };\n}\nvar stateBeforeCdata1 = ifElseState(\"C\", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);\nvar stateBeforeCdata2 = ifElseState(\"D\", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);\nvar stateBeforeCdata3 = ifElseState(\"A\", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);\nvar stateBeforeCdata4 = ifElseState(\"T\", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);\nvar stateBeforeCdata5 = ifElseState(\"A\", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);\nvar stateBeforeScript1 = consumeSpecialNameChar(\"R\", 35 /* BeforeScript2 */);\nvar stateBeforeScript2 = consumeSpecialNameChar(\"I\", 36 /* BeforeScript3 */);\nvar stateBeforeScript3 = consumeSpecialNameChar(\"P\", 37 /* BeforeScript4 */);\nvar stateBeforeScript4 = consumeSpecialNameChar(\"T\", 38 /* BeforeScript5 */);\nvar stateAfterScript1 = ifElseState(\"R\", 40 /* AfterScript2 */, 1 /* Text */);\nvar stateAfterScript2 = ifElseState(\"I\", 41 /* AfterScript3 */, 1 /* Text */);\nvar stateAfterScript3 = ifElseState(\"P\", 42 /* AfterScript4 */, 1 /* Text */);\nvar stateAfterScript4 = ifElseState(\"T\", 43 /* AfterScript5 */, 1 /* Text */);\nvar stateBeforeStyle1 = consumeSpecialNameChar(\"Y\", 45 /* BeforeStyle2 */);\nvar stateBeforeStyle2 = consumeSpecialNameChar(\"L\", 46 /* BeforeStyle3 */);\nvar stateBeforeStyle3 = consumeSpecialNameChar(\"E\", 47 /* BeforeStyle4 */);\nvar stateAfterStyle1 = ifElseState(\"Y\", 49 /* AfterStyle2 */, 1 /* Text */);\nvar stateAfterStyle2 = ifElseState(\"L\", 50 /* AfterStyle3 */, 1 /* Text */);\nvar stateAfterStyle3 = ifElseState(\"E\", 51 /* AfterStyle4 */, 1 /* Text */);\nvar stateBeforeSpecialT = consumeSpecialNameChar(\"I\", 54 /* BeforeTitle1 */);\nvar stateBeforeTitle1 = consumeSpecialNameChar(\"T\", 55 /* BeforeTitle2 */);\nvar stateBeforeTitle2 = consumeSpecialNameChar(\"L\", 56 /* BeforeTitle3 */);\nvar stateBeforeTitle3 = consumeSpecialNameChar(\"E\", 57 /* BeforeTitle4 */);\nvar stateAfterSpecialTEnd = ifElseState(\"I\", 58 /* AfterTitle1 */, 1 /* Text */);\nvar stateAfterTitle1 = ifElseState(\"T\", 59 /* AfterTitle2 */, 1 /* Text */);\nvar stateAfterTitle2 = ifElseState(\"L\", 60 /* AfterTitle3 */, 1 /* Text */);\nvar stateAfterTitle3 = ifElseState(\"E\", 61 /* AfterTitle4 */, 1 /* Text */);\nvar stateBeforeEntity = ifElseState(\"#\", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);\nvar stateBeforeNumericEntity = ifElseState(\"X\", 66 /* InHexEntity */, 65 /* InNumericEntity */);\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(options, cbs) {\n        var _a;\n        /** The current state the tokenizer is in. */\n        this._state = 1 /* Text */;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this._index = 0;\n        /**\n         * Data that has already been processed will be removed from the buffer occasionally.\n         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.\n         */\n        this.bufferOffset = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = 1 /* Text */;\n        /** For special parsing behavior inside of script and style tags. */\n        this.special = 1 /* None */;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** Indicates whether the tokenizer has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs;\n        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);\n        this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;\n    }\n    Tokenizer.prototype.reset = function () {\n        this._state = 1 /* Text */;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this._index = 0;\n        this.bufferOffset = 0;\n        this.baseState = 1 /* Text */;\n        this.special = 1 /* None */;\n        this.running = true;\n        this.ended = false;\n    };\n    Tokenizer.prototype.write = function (chunk) {\n        if (this.ended)\n            this.cbs.onerror(Error(\".write() after done!\"));\n        this.buffer += chunk;\n        this.parse();\n    };\n    Tokenizer.prototype.end = function (chunk) {\n        if (this.ended)\n            this.cbs.onerror(Error(\".end() after done!\"));\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        if (this.running)\n            this.finish();\n    };\n    Tokenizer.prototype.pause = function () {\n        this.running = false;\n    };\n    Tokenizer.prototype.resume = function () {\n        this.running = true;\n        if (this._index < this.buffer.length) {\n            this.parse();\n        }\n        if (this.ended) {\n            this.finish();\n        }\n    };\n    /**\n     * The current index within all of the written data.\n     */\n    Tokenizer.prototype.getAbsoluteIndex = function () {\n        return this.bufferOffset + this._index;\n    };\n    Tokenizer.prototype.stateText = function (c) {\n        if (c === \"<\") {\n            if (this._index > this.sectionStart) {\n                this.cbs.ontext(this.getSection());\n            }\n            this._state = 2 /* BeforeTagName */;\n            this.sectionStart = this._index;\n        }\n        else if (this.decodeEntities &&\n            c === \"&\" &&\n            (this.special === 1 /* None */ || this.special === 4 /* Title */)) {\n            if (this._index > this.sectionStart) {\n                this.cbs.ontext(this.getSection());\n            }\n            this.baseState = 1 /* Text */;\n            this._state = 62 /* BeforeEntity */;\n            this.sectionStart = this._index;\n        }\n    };\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    Tokenizer.prototype.isTagStartChar = function (c) {\n        return (isASCIIAlpha(c) ||\n            (this.xmlMode && !whitespace(c) && c !== \"/\" && c !== \">\"));\n    };\n    Tokenizer.prototype.stateBeforeTagName = function (c) {\n        if (c === \"/\") {\n            this._state = 5 /* BeforeClosingTagName */;\n        }\n        else if (c === \"<\") {\n            this.cbs.ontext(this.getSection());\n            this.sectionStart = this._index;\n        }\n        else if (c === \">\" ||\n            this.special !== 1 /* None */ ||\n            whitespace(c)) {\n            this._state = 1 /* Text */;\n        }\n        else if (c === \"!\") {\n            this._state = 15 /* BeforeDeclaration */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === \"?\") {\n            this._state = 17 /* InProcessingInstruction */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (!this.isTagStartChar(c)) {\n            this._state = 1 /* Text */;\n        }\n        else {\n            this._state =\n                !this.xmlMode && (c === \"s\" || c === \"S\")\n                    ? 32 /* BeforeSpecialS */\n                    : !this.xmlMode && (c === \"t\" || c === \"T\")\n                        ? 52 /* BeforeSpecialT */\n                        : 3 /* InTagName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInTagName = function (c) {\n        if (c === \"/\" || c === \">\" || whitespace(c)) {\n            this.emitToken(\"onopentagname\");\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {\n        if (whitespace(c)) {\n            // Ignore\n        }\n        else if (c === \">\") {\n            this._state = 1 /* Text */;\n        }\n        else if (this.special !== 1 /* None */) {\n            if (this.special !== 4 /* Title */ && (c === \"s\" || c === \"S\")) {\n                this._state = 33 /* BeforeSpecialSEnd */;\n            }\n            else if (this.special === 4 /* Title */ &&\n                (c === \"t\" || c === \"T\")) {\n                this._state = 53 /* BeforeSpecialTEnd */;\n            }\n            else {\n                this._state = 1 /* Text */;\n                this._index--;\n            }\n        }\n        else if (!this.isTagStartChar(c)) {\n            this._state = 20 /* InSpecialComment */;\n            this.sectionStart = this._index;\n        }\n        else {\n            this._state = 6 /* InClosingTagName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInClosingTagName = function (c) {\n        if (c === \">\" || whitespace(c)) {\n            this.emitToken(\"onclosetag\");\n            this._state = 7 /* AfterClosingTagName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateAfterClosingTagName = function (c) {\n        // Skip everything until \">\"\n        if (c === \">\") {\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeName = function (c) {\n        if (c === \">\") {\n            this.cbs.onopentagend();\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === \"/\") {\n            this._state = 4 /* InSelfClosingTag */;\n        }\n        else if (!whitespace(c)) {\n            this._state = 9 /* InAttributeName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInSelfClosingTag = function (c) {\n        if (c === \">\") {\n            this.cbs.onselfclosingtag();\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n            this.special = 1 /* None */; // Reset special state, in case of self-closing special tags\n        }\n        else if (!whitespace(c)) {\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateInAttributeName = function (c) {\n        if (c === \"=\" || c === \"/\" || c === \">\" || whitespace(c)) {\n            this.cbs.onattribname(this.getSection());\n            this.sectionStart = -1;\n            this._state = 10 /* AfterAttributeName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateAfterAttributeName = function (c) {\n        if (c === \"=\") {\n            this._state = 11 /* BeforeAttributeValue */;\n        }\n        else if (c === \"/\" || c === \">\") {\n            this.cbs.onattribend(undefined);\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n        else if (!whitespace(c)) {\n            this.cbs.onattribend(undefined);\n            this._state = 9 /* InAttributeName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {\n        if (c === '\"') {\n            this._state = 12 /* InAttributeValueDq */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === \"'\") {\n            this._state = 13 /* InAttributeValueSq */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (!whitespace(c)) {\n            this._state = 14 /* InAttributeValueNq */;\n            this.sectionStart = this._index;\n            this._index--; // Reconsume token\n        }\n    };\n    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {\n        if (c === quote) {\n            this.emitToken(\"onattribdata\");\n            this.cbs.onattribend(quote);\n            this._state = 8 /* BeforeAttributeName */;\n        }\n        else if (this.decodeEntities && c === \"&\") {\n            this.emitToken(\"onattribdata\");\n            this.baseState = this._state;\n            this._state = 62 /* BeforeEntity */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {\n        this.handleInAttributeValue(c, '\"');\n    };\n    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {\n        this.handleInAttributeValue(c, \"'\");\n    };\n    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {\n        if (whitespace(c) || c === \">\") {\n            this.emitToken(\"onattribdata\");\n            this.cbs.onattribend(null);\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n        else if (this.decodeEntities && c === \"&\") {\n            this.emitToken(\"onattribdata\");\n            this.baseState = this._state;\n            this._state = 62 /* BeforeEntity */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateBeforeDeclaration = function (c) {\n        this._state =\n            c === \"[\"\n                ? 23 /* BeforeCdata1 */\n                : c === \"-\"\n                    ? 18 /* BeforeComment */\n                    : 16 /* InDeclaration */;\n    };\n    Tokenizer.prototype.stateInDeclaration = function (c) {\n        if (c === \">\") {\n            this.cbs.ondeclaration(this.getSection());\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateInProcessingInstruction = function (c) {\n        if (c === \">\") {\n            this.cbs.onprocessinginstruction(this.getSection());\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeComment = function (c) {\n        if (c === \"-\") {\n            this._state = 19 /* InComment */;\n            this.sectionStart = this._index + 1;\n        }\n        else {\n            this._state = 16 /* InDeclaration */;\n        }\n    };\n    Tokenizer.prototype.stateInComment = function (c) {\n        if (c === \"-\")\n            this._state = 21 /* AfterComment1 */;\n    };\n    Tokenizer.prototype.stateInSpecialComment = function (c) {\n        if (c === \">\") {\n            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateAfterComment1 = function (c) {\n        if (c === \"-\") {\n            this._state = 22 /* AfterComment2 */;\n        }\n        else {\n            this._state = 19 /* InComment */;\n        }\n    };\n    Tokenizer.prototype.stateAfterComment2 = function (c) {\n        if (c === \">\") {\n            // Remove 2 trailing chars\n            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c !== \"-\") {\n            this._state = 19 /* InComment */;\n        }\n        // Else: stay in AFTER_COMMENT_2 (`--->`)\n    };\n    Tokenizer.prototype.stateBeforeCdata6 = function (c) {\n        if (c === \"[\") {\n            this._state = 29 /* InCdata */;\n            this.sectionStart = this._index + 1;\n        }\n        else {\n            this._state = 16 /* InDeclaration */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateInCdata = function (c) {\n        if (c === \"]\")\n            this._state = 30 /* AfterCdata1 */;\n    };\n    Tokenizer.prototype.stateAfterCdata1 = function (c) {\n        if (c === \"]\")\n            this._state = 31 /* AfterCdata2 */;\n        else\n            this._state = 29 /* InCdata */;\n    };\n    Tokenizer.prototype.stateAfterCdata2 = function (c) {\n        if (c === \">\") {\n            // Remove 2 trailing chars\n            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c !== \"]\") {\n            this._state = 29 /* InCdata */;\n        }\n        // Else: stay in AFTER_CDATA_2 (`]]]>`)\n    };\n    Tokenizer.prototype.stateBeforeSpecialS = function (c) {\n        if (c === \"c\" || c === \"C\") {\n            this._state = 34 /* BeforeScript1 */;\n        }\n        else if (c === \"t\" || c === \"T\") {\n            this._state = 44 /* BeforeStyle1 */;\n        }\n        else {\n            this._state = 3 /* InTagName */;\n            this._index--; // Consume the token again\n        }\n    };\n    Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {\n        if (this.special === 2 /* Script */ && (c === \"c\" || c === \"C\")) {\n            this._state = 39 /* AfterScript1 */;\n        }\n        else if (this.special === 3 /* Style */ && (c === \"t\" || c === \"T\")) {\n            this._state = 48 /* AfterStyle1 */;\n        }\n        else\n            this._state = 1 /* Text */;\n    };\n    Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {\n        if (c === \"/\" || c === \">\" || whitespace(c)) {\n            this.special = special;\n        }\n        this._state = 3 /* InTagName */;\n        this._index--; // Consume the token again\n    };\n    Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {\n        if (c === \">\" || whitespace(c)) {\n            this.special = 1 /* None */;\n            this._state = 6 /* InClosingTagName */;\n            this.sectionStart = this._index - sectionStartOffset;\n            this._index--; // Reconsume the token\n        }\n        else\n            this._state = 1 /* Text */;\n    };\n    // For entities terminated with a semicolon\n    Tokenizer.prototype.parseFixedEntity = function (map) {\n        if (map === void 0) { map = this.xmlMode ? xml_json_1.default : entities_json_1.default; }\n        // Offset = 1\n        if (this.sectionStart + 1 < this._index) {\n            var entity = this.buffer.substring(this.sectionStart + 1, this._index);\n            if (Object.prototype.hasOwnProperty.call(map, entity)) {\n                this.emitPartial(map[entity]);\n                this.sectionStart = this._index + 1;\n            }\n        }\n    };\n    // Parses legacy entities (without trailing semicolon)\n    Tokenizer.prototype.parseLegacyEntity = function () {\n        var start = this.sectionStart + 1;\n        // The max length of legacy entities is 6\n        var limit = Math.min(this._index - start, 6);\n        while (limit >= 2) {\n            // The min length of legacy entities is 2\n            var entity = this.buffer.substr(start, limit);\n            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {\n                this.emitPartial(legacy_json_1.default[entity]);\n                this.sectionStart += limit + 1;\n                return;\n            }\n            limit--;\n        }\n    };\n    Tokenizer.prototype.stateInNamedEntity = function (c) {\n        if (c === \";\") {\n            this.parseFixedEntity();\n            // Retry as legacy entity if entity wasn't parsed\n            if (this.baseState === 1 /* Text */ &&\n                this.sectionStart + 1 < this._index &&\n                !this.xmlMode) {\n                this.parseLegacyEntity();\n            }\n            this._state = this.baseState;\n        }\n        else if ((c < \"0\" || c > \"9\") && !isASCIIAlpha(c)) {\n            if (this.xmlMode || this.sectionStart + 1 === this._index) {\n                // Ignore\n            }\n            else if (this.baseState !== 1 /* Text */) {\n                if (c !== \"=\") {\n                    // Parse as legacy entity, without allowing additional characters.\n                    this.parseFixedEntity(legacy_json_1.default);\n                }\n            }\n            else {\n                this.parseLegacyEntity();\n            }\n            this._state = this.baseState;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {\n        var sectionStart = this.sectionStart + offset;\n        if (sectionStart !== this._index) {\n            // Parse entity\n            var entity = this.buffer.substring(sectionStart, this._index);\n            var parsed = parseInt(entity, base);\n            this.emitPartial(decode_codepoint_1.default(parsed));\n            this.sectionStart = strict ? this._index + 1 : this._index;\n        }\n        this._state = this.baseState;\n    };\n    Tokenizer.prototype.stateInNumericEntity = function (c) {\n        if (c === \";\") {\n            this.decodeNumericEntity(2, 10, true);\n        }\n        else if (c < \"0\" || c > \"9\") {\n            if (!this.xmlMode) {\n                this.decodeNumericEntity(2, 10, false);\n            }\n            else {\n                this._state = this.baseState;\n            }\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateInHexEntity = function (c) {\n        if (c === \";\") {\n            this.decodeNumericEntity(3, 16, true);\n        }\n        else if ((c < \"a\" || c > \"f\") &&\n            (c < \"A\" || c > \"F\") &&\n            (c < \"0\" || c > \"9\")) {\n            if (!this.xmlMode) {\n                this.decodeNumericEntity(3, 16, false);\n            }\n            else {\n                this._state = this.baseState;\n            }\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.cleanup = function () {\n        if (this.sectionStart < 0) {\n            this.buffer = \"\";\n            this.bufferOffset += this._index;\n            this._index = 0;\n        }\n        else if (this.running) {\n            if (this._state === 1 /* Text */) {\n                if (this.sectionStart !== this._index) {\n                    this.cbs.ontext(this.buffer.substr(this.sectionStart));\n                }\n                this.buffer = \"\";\n                this.bufferOffset += this._index;\n                this._index = 0;\n            }\n            else if (this.sectionStart === this._index) {\n                // The section just started\n                this.buffer = \"\";\n                this.bufferOffset += this._index;\n                this._index = 0;\n            }\n            else {\n                // Remove everything unnecessary\n                this.buffer = this.buffer.substr(this.sectionStart);\n                this._index -= this.sectionStart;\n                this.bufferOffset += this.sectionStart;\n            }\n            this.sectionStart = 0;\n        }\n    };\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    Tokenizer.prototype.parse = function () {\n        while (this._index < this.buffer.length && this.running) {\n            var c = this.buffer.charAt(this._index);\n            if (this._state === 1 /* Text */) {\n                this.stateText(c);\n            }\n            else if (this._state === 12 /* InAttributeValueDq */) {\n                this.stateInAttributeValueDoubleQuotes(c);\n            }\n            else if (this._state === 9 /* InAttributeName */) {\n                this.stateInAttributeName(c);\n            }\n            else if (this._state === 19 /* InComment */) {\n                this.stateInComment(c);\n            }\n            else if (this._state === 20 /* InSpecialComment */) {\n                this.stateInSpecialComment(c);\n            }\n            else if (this._state === 8 /* BeforeAttributeName */) {\n                this.stateBeforeAttributeName(c);\n            }\n            else if (this._state === 3 /* InTagName */) {\n                this.stateInTagName(c);\n            }\n            else if (this._state === 6 /* InClosingTagName */) {\n                this.stateInClosingTagName(c);\n            }\n            else if (this._state === 2 /* BeforeTagName */) {\n                this.stateBeforeTagName(c);\n            }\n            else if (this._state === 10 /* AfterAttributeName */) {\n                this.stateAfterAttributeName(c);\n            }\n            else if (this._state === 13 /* InAttributeValueSq */) {\n                this.stateInAttributeValueSingleQuotes(c);\n            }\n            else if (this._state === 11 /* BeforeAttributeValue */) {\n                this.stateBeforeAttributeValue(c);\n            }\n            else if (this._state === 5 /* BeforeClosingTagName */) {\n                this.stateBeforeClosingTagName(c);\n            }\n            else if (this._state === 7 /* AfterClosingTagName */) {\n                this.stateAfterClosingTagName(c);\n            }\n            else if (this._state === 32 /* BeforeSpecialS */) {\n                this.stateBeforeSpecialS(c);\n            }\n            else if (this._state === 21 /* AfterComment1 */) {\n                this.stateAfterComment1(c);\n            }\n            else if (this._state === 14 /* InAttributeValueNq */) {\n                this.stateInAttributeValueNoQuotes(c);\n            }\n            else if (this._state === 4 /* InSelfClosingTag */) {\n                this.stateInSelfClosingTag(c);\n            }\n            else if (this._state === 16 /* InDeclaration */) {\n                this.stateInDeclaration(c);\n            }\n            else if (this._state === 15 /* BeforeDeclaration */) {\n                this.stateBeforeDeclaration(c);\n            }\n            else if (this._state === 22 /* AfterComment2 */) {\n                this.stateAfterComment2(c);\n            }\n            else if (this._state === 18 /* BeforeComment */) {\n                this.stateBeforeComment(c);\n            }\n            else if (this._state === 33 /* BeforeSpecialSEnd */) {\n                this.stateBeforeSpecialSEnd(c);\n            }\n            else if (this._state === 53 /* BeforeSpecialTEnd */) {\n                stateAfterSpecialTEnd(this, c);\n            }\n            else if (this._state === 39 /* AfterScript1 */) {\n                stateAfterScript1(this, c);\n            }\n            else if (this._state === 40 /* AfterScript2 */) {\n                stateAfterScript2(this, c);\n            }\n            else if (this._state === 41 /* AfterScript3 */) {\n                stateAfterScript3(this, c);\n            }\n            else if (this._state === 34 /* BeforeScript1 */) {\n                stateBeforeScript1(this, c);\n            }\n            else if (this._state === 35 /* BeforeScript2 */) {\n                stateBeforeScript2(this, c);\n            }\n            else if (this._state === 36 /* BeforeScript3 */) {\n                stateBeforeScript3(this, c);\n            }\n            else if (this._state === 37 /* BeforeScript4 */) {\n                stateBeforeScript4(this, c);\n            }\n            else if (this._state === 38 /* BeforeScript5 */) {\n                this.stateBeforeSpecialLast(c, 2 /* Script */);\n            }\n            else if (this._state === 42 /* AfterScript4 */) {\n                stateAfterScript4(this, c);\n            }\n            else if (this._state === 43 /* AfterScript5 */) {\n                this.stateAfterSpecialLast(c, 6);\n            }\n            else if (this._state === 44 /* BeforeStyle1 */) {\n                stateBeforeStyle1(this, c);\n            }\n            else if (this._state === 29 /* InCdata */) {\n                this.stateInCdata(c);\n            }\n            else if (this._state === 45 /* BeforeStyle2 */) {\n                stateBeforeStyle2(this, c);\n            }\n            else if (this._state === 46 /* BeforeStyle3 */) {\n                stateBeforeStyle3(this, c);\n            }\n            else if (this._state === 47 /* BeforeStyle4 */) {\n                this.stateBeforeSpecialLast(c, 3 /* Style */);\n            }\n            else if (this._state === 48 /* AfterStyle1 */) {\n                stateAfterStyle1(this, c);\n            }\n            else if (this._state === 49 /* AfterStyle2 */) {\n                stateAfterStyle2(this, c);\n            }\n            else if (this._state === 50 /* AfterStyle3 */) {\n                stateAfterStyle3(this, c);\n            }\n            else if (this._state === 51 /* AfterStyle4 */) {\n                this.stateAfterSpecialLast(c, 5);\n            }\n            else if (this._state === 52 /* BeforeSpecialT */) {\n                stateBeforeSpecialT(this, c);\n            }\n            else if (this._state === 54 /* BeforeTitle1 */) {\n                stateBeforeTitle1(this, c);\n            }\n            else if (this._state === 55 /* BeforeTitle2 */) {\n                stateBeforeTitle2(this, c);\n            }\n            else if (this._state === 56 /* BeforeTitle3 */) {\n                stateBeforeTitle3(this, c);\n            }\n            else if (this._state === 57 /* BeforeTitle4 */) {\n                this.stateBeforeSpecialLast(c, 4 /* Title */);\n            }\n            else if (this._state === 58 /* AfterTitle1 */) {\n                stateAfterTitle1(this, c);\n            }\n            else if (this._state === 59 /* AfterTitle2 */) {\n                stateAfterTitle2(this, c);\n            }\n            else if (this._state === 60 /* AfterTitle3 */) {\n                stateAfterTitle3(this, c);\n            }\n            else if (this._state === 61 /* AfterTitle4 */) {\n                this.stateAfterSpecialLast(c, 5);\n            }\n            else if (this._state === 17 /* InProcessingInstruction */) {\n                this.stateInProcessingInstruction(c);\n            }\n            else if (this._state === 64 /* InNamedEntity */) {\n                this.stateInNamedEntity(c);\n            }\n            else if (this._state === 23 /* BeforeCdata1 */) {\n                stateBeforeCdata1(this, c);\n            }\n            else if (this._state === 62 /* BeforeEntity */) {\n                stateBeforeEntity(this, c);\n            }\n            else if (this._state === 24 /* BeforeCdata2 */) {\n                stateBeforeCdata2(this, c);\n            }\n            else if (this._state === 25 /* BeforeCdata3 */) {\n                stateBeforeCdata3(this, c);\n            }\n            else if (this._state === 30 /* AfterCdata1 */) {\n                this.stateAfterCdata1(c);\n            }\n            else if (this._state === 31 /* AfterCdata2 */) {\n                this.stateAfterCdata2(c);\n            }\n            else if (this._state === 26 /* BeforeCdata4 */) {\n                stateBeforeCdata4(this, c);\n            }\n            else if (this._state === 27 /* BeforeCdata5 */) {\n                stateBeforeCdata5(this, c);\n            }\n            else if (this._state === 28 /* BeforeCdata6 */) {\n                this.stateBeforeCdata6(c);\n            }\n            else if (this._state === 66 /* InHexEntity */) {\n                this.stateInHexEntity(c);\n            }\n            else if (this._state === 65 /* InNumericEntity */) {\n                this.stateInNumericEntity(c);\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            }\n            else if (this._state === 63 /* BeforeNumericEntity */) {\n                stateBeforeNumericEntity(this, c);\n            }\n            else {\n                this.cbs.onerror(Error(\"unknown _state\"), this._state);\n            }\n            this._index++;\n        }\n        this.cleanup();\n    };\n    Tokenizer.prototype.finish = function () {\n        // If there is remaining data, emit it in a reasonable way\n        if (this.sectionStart < this._index) {\n            this.handleTrailingData();\n        }\n        this.cbs.onend();\n    };\n    Tokenizer.prototype.handleTrailingData = function () {\n        var data = this.buffer.substr(this.sectionStart);\n        if (this._state === 29 /* InCdata */ ||\n            this._state === 30 /* AfterCdata1 */ ||\n            this._state === 31 /* AfterCdata2 */) {\n            this.cbs.oncdata(data);\n        }\n        else if (this._state === 19 /* InComment */ ||\n            this._state === 21 /* AfterComment1 */ ||\n            this._state === 22 /* AfterComment2 */) {\n            this.cbs.oncomment(data);\n        }\n        else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {\n            this.parseLegacyEntity();\n            if (this.sectionStart < this._index) {\n                this._state = this.baseState;\n                this.handleTrailingData();\n            }\n        }\n        else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {\n            this.decodeNumericEntity(2, 10, false);\n            if (this.sectionStart < this._index) {\n                this._state = this.baseState;\n                this.handleTrailingData();\n            }\n        }\n        else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {\n            this.decodeNumericEntity(3, 16, false);\n            if (this.sectionStart < this._index) {\n                this._state = this.baseState;\n                this.handleTrailingData();\n            }\n        }\n        else if (this._state !== 3 /* InTagName */ &&\n            this._state !== 8 /* BeforeAttributeName */ &&\n            this._state !== 11 /* BeforeAttributeValue */ &&\n            this._state !== 10 /* AfterAttributeName */ &&\n            this._state !== 9 /* InAttributeName */ &&\n            this._state !== 13 /* InAttributeValueSq */ &&\n            this._state !== 12 /* InAttributeValueDq */ &&\n            this._state !== 14 /* InAttributeValueNq */ &&\n            this._state !== 6 /* InClosingTagName */) {\n            this.cbs.ontext(data);\n        }\n        /*\n         * Else, ignore remaining data\n         * TODO add a way to remove current tag\n         */\n    };\n    Tokenizer.prototype.getSection = function () {\n        return this.buffer.substring(this.sectionStart, this._index);\n    };\n    Tokenizer.prototype.emitToken = function (name) {\n        this.cbs[name](this.getSection());\n        this.sectionStart = -1;\n    };\n    Tokenizer.prototype.emitPartial = function (value) {\n        if (this.baseState !== 1 /* Text */) {\n            this.cbs.onattribdata(value); // TODO implement the new event\n        }\n        else {\n            this.cbs.ontext(value);\n        }\n    };\n    return Tokenizer;\n}());\nexports.default = Tokenizer;\n","'use strict';\n\nconst Mixin = require('../../utils/mixin');\n\nclass PositionTrackingPreprocessorMixin extends Mixin {\n    constructor(preprocessor) {\n        super(preprocessor);\n\n        this.preprocessor = preprocessor;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n\n        this.offset = 0;\n        this.col = 0;\n        this.line = 1;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            advance() {\n                const pos = this.pos + 1;\n                const ch = this.html[pos];\n\n                //NOTE: LF should be in the last column of the line\n                if (mxn.isEol) {\n                    mxn.isEol = false;\n                    mxn.line++;\n                    mxn.lineStartPos = pos;\n                }\n\n                if (ch === '\\n' || (ch === '\\r' && this.html[pos + 1] !== '\\n')) {\n                    mxn.isEol = true;\n                }\n\n                mxn.col = pos - mxn.lineStartPos + 1;\n                mxn.offset = mxn.droppedBufferSize + pos;\n\n                return orig.advance.call(this);\n            },\n\n            retreat() {\n                orig.retreat.call(this);\n\n                mxn.isEol = false;\n                mxn.col = this.pos - mxn.lineStartPos + 1;\n            },\n\n            dropParsedChunk() {\n                const prevPos = this.pos;\n\n                orig.dropParsedChunk.call(this);\n\n                const reduction = prevPos - this.pos;\n\n                mxn.lineStartPos -= reduction;\n                mxn.droppedBufferSize += reduction;\n                mxn.offset = mxn.droppedBufferSize + this.pos;\n            }\n        };\n    }\n}\n\nmodule.exports = PositionTrackingPreprocessorMixin;\n","'use strict';\n\nconst Tokenizer = require('../tokenizer');\nconst OpenElementStack = require('./open-element-stack');\nconst FormattingElementList = require('./formatting-element-list');\nconst LocationInfoParserMixin = require('../extensions/location-info/parser-mixin');\nconst ErrorReportingParserMixin = require('../extensions/error-reporting/parser-mixin');\nconst Mixin = require('../utils/mixin');\nconst defaultTreeAdapter = require('../tree-adapters/default');\nconst mergeOptions = require('../utils/merge-options');\nconst doctype = require('../common/doctype');\nconst foreignContent = require('../common/foreign-content');\nconst ERR = require('../common/error-codes');\nconst unicode = require('../common/unicode');\nconst HTML = require('../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\nconst ATTRS = HTML.ATTRS;\n\nconst DEFAULT_OPTIONS = {\n    scriptingEnabled: true,\n    sourceCodeLocationInfo: false,\n    onParseError: null,\n    treeAdapter: defaultTreeAdapter\n};\n\n//Misc constants\nconst HIDDEN_INPUT_TYPE = 'hidden';\n\n//Adoption agency loops iteration count\nconst AA_OUTER_LOOP_ITER = 8;\nconst AA_INNER_LOOP_ITER = 3;\n\n//Insertion modes\nconst INITIAL_MODE = 'INITIAL_MODE';\nconst BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';\nconst BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';\nconst IN_HEAD_MODE = 'IN_HEAD_MODE';\nconst IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';\nconst AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';\nconst IN_BODY_MODE = 'IN_BODY_MODE';\nconst TEXT_MODE = 'TEXT_MODE';\nconst IN_TABLE_MODE = 'IN_TABLE_MODE';\nconst IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';\nconst IN_CAPTION_MODE = 'IN_CAPTION_MODE';\nconst IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';\nconst IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';\nconst IN_ROW_MODE = 'IN_ROW_MODE';\nconst IN_CELL_MODE = 'IN_CELL_MODE';\nconst IN_SELECT_MODE = 'IN_SELECT_MODE';\nconst IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';\nconst IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';\nconst AFTER_BODY_MODE = 'AFTER_BODY_MODE';\nconst IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';\nconst AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';\nconst AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';\nconst AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';\n\n//Insertion mode reset map\nconst INSERTION_MODE_RESET_MAP = {\n    [$.TR]: IN_ROW_MODE,\n    [$.TBODY]: IN_TABLE_BODY_MODE,\n    [$.THEAD]: IN_TABLE_BODY_MODE,\n    [$.TFOOT]: IN_TABLE_BODY_MODE,\n    [$.CAPTION]: IN_CAPTION_MODE,\n    [$.COLGROUP]: IN_COLUMN_GROUP_MODE,\n    [$.TABLE]: IN_TABLE_MODE,\n    [$.BODY]: IN_BODY_MODE,\n    [$.FRAMESET]: IN_FRAMESET_MODE\n};\n\n//Template insertion mode switch map\nconst TEMPLATE_INSERTION_MODE_SWITCH_MAP = {\n    [$.CAPTION]: IN_TABLE_MODE,\n    [$.COLGROUP]: IN_TABLE_MODE,\n    [$.TBODY]: IN_TABLE_MODE,\n    [$.TFOOT]: IN_TABLE_MODE,\n    [$.THEAD]: IN_TABLE_MODE,\n    [$.COL]: IN_COLUMN_GROUP_MODE,\n    [$.TR]: IN_TABLE_BODY_MODE,\n    [$.TD]: IN_ROW_MODE,\n    [$.TH]: IN_ROW_MODE\n};\n\n//Token handlers map for insertion modes\nconst TOKEN_HANDLERS = {\n    [INITIAL_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,\n        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,\n        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,\n        [Tokenizer.EOF_TOKEN]: tokenInInitialMode\n    },\n    [BEFORE_HTML_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,\n        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,\n        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml\n    },\n    [BEFORE_HEAD_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,\n        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,\n        [Tokenizer.EOF_TOKEN]: tokenBeforeHead\n    },\n    [IN_HEAD_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagInHead,\n        [Tokenizer.END_TAG_TOKEN]: endTagInHead,\n        [Tokenizer.EOF_TOKEN]: tokenInHead\n    },\n    [IN_HEAD_NO_SCRIPT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,\n        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,\n        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript\n    },\n    [AFTER_HEAD_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,\n        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,\n        [Tokenizer.EOF_TOKEN]: tokenAfterHead\n    },\n    [IN_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInBody,\n        [Tokenizer.END_TAG_TOKEN]: endTagInBody,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [TEXT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: ignoreToken,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: ignoreToken,\n        [Tokenizer.END_TAG_TOKEN]: endTagInText,\n        [Tokenizer.EOF_TOKEN]: eofInText\n    },\n    [IN_TABLE_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInTable,\n        [Tokenizer.END_TAG_TOKEN]: endTagInTable,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_TABLE_TEXT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,\n        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,\n        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,\n        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,\n        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,\n        [Tokenizer.EOF_TOKEN]: tokenInTableText\n    },\n    [IN_CAPTION_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,\n        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_COLUMN_GROUP_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,\n        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_TABLE_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,\n        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_ROW_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInRow,\n        [Tokenizer.END_TAG_TOKEN]: endTagInRow,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_CELL_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInCell,\n        [Tokenizer.END_TAG_TOKEN]: endTagInCell,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_SELECT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,\n        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_SELECT_IN_TABLE_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,\n        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_TEMPLATE_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,\n        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,\n        [Tokenizer.EOF_TOKEN]: eofInTemplate\n    },\n    [AFTER_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,\n        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [IN_FRAMESET_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,\n        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [AFTER_FRAMESET_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,\n        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [AFTER_AFTER_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,\n        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [AFTER_AFTER_FRAMESET_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,\n        [Tokenizer.END_TAG_TOKEN]: ignoreToken,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    }\n};\n\n//Parser\nclass Parser {\n    constructor(options) {\n        this.options = mergeOptions(DEFAULT_OPTIONS, options);\n\n        this.treeAdapter = this.options.treeAdapter;\n        this.pendingScript = null;\n\n        if (this.options.sourceCodeLocationInfo) {\n            Mixin.install(this, LocationInfoParserMixin);\n        }\n\n        if (this.options.onParseError) {\n            Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });\n        }\n    }\n\n    // API\n    parse(html) {\n        const document = this.treeAdapter.createDocument();\n\n        this._bootstrap(document, null);\n        this.tokenizer.write(html, true);\n        this._runParsingLoop(null);\n\n        return document;\n    }\n\n    parseFragment(html, fragmentContext) {\n        //NOTE: use <template> element as a fragment context if context element was not provided,\n        //so we will parse in \"forgiving\" manner\n        if (!fragmentContext) {\n            fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);\n        }\n\n        //NOTE: create fake element which will be used as 'document' for fragment parsing.\n        //This is important for jsdom there 'document' can't be recreated, therefore\n        //fragment parsing causes messing of the main `document`.\n        const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);\n\n        this._bootstrap(documentMock, fragmentContext);\n\n        if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {\n            this._pushTmplInsertionMode(IN_TEMPLATE_MODE);\n        }\n\n        this._initTokenizerForFragmentParsing();\n        this._insertFakeRootElement();\n        this._resetInsertionMode();\n        this._findFormInFragmentContext();\n        this.tokenizer.write(html, true);\n        this._runParsingLoop(null);\n\n        const rootElement = this.treeAdapter.getFirstChild(documentMock);\n        const fragment = this.treeAdapter.createDocumentFragment();\n\n        this._adoptNodes(rootElement, fragment);\n\n        return fragment;\n    }\n\n    //Bootstrap parser\n    _bootstrap(document, fragmentContext) {\n        this.tokenizer = new Tokenizer(this.options);\n\n        this.stopped = false;\n\n        this.insertionMode = INITIAL_MODE;\n        this.originalInsertionMode = '';\n\n        this.document = document;\n        this.fragmentContext = fragmentContext;\n\n        this.headElement = null;\n        this.formElement = null;\n\n        this.openElements = new OpenElementStack(this.document, this.treeAdapter);\n        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);\n\n        this.tmplInsertionModeStack = [];\n        this.tmplInsertionModeStackTop = -1;\n        this.currentTmplInsertionMode = null;\n\n        this.pendingCharacterTokens = [];\n        this.hasNonWhitespacePendingCharacterToken = false;\n\n        this.framesetOk = true;\n        this.skipNextNewLine = false;\n        this.fosterParentingEnabled = false;\n    }\n\n    //Errors\n    _err() {\n        // NOTE: err reporting is noop by default. Enabled by mixin.\n    }\n\n    //Parsing loop\n    _runParsingLoop(scriptHandler) {\n        while (!this.stopped) {\n            this._setupTokenizerCDATAMode();\n\n            const token = this.tokenizer.getNextToken();\n\n            if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n                break;\n            }\n\n            if (this.skipNextNewLine) {\n                this.skipNextNewLine = false;\n\n                if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\\n') {\n                    if (token.chars.length === 1) {\n                        continue;\n                    }\n\n                    token.chars = token.chars.substr(1);\n                }\n            }\n\n            this._processInputToken(token);\n\n            if (scriptHandler && this.pendingScript) {\n                break;\n            }\n        }\n    }\n\n    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {\n        this._runParsingLoop(scriptHandler);\n\n        if (scriptHandler && this.pendingScript) {\n            const script = this.pendingScript;\n\n            this.pendingScript = null;\n\n            scriptHandler(script);\n\n            return;\n        }\n\n        if (writeCallback) {\n            writeCallback();\n        }\n    }\n\n    //Text parsing\n    _setupTokenizerCDATAMode() {\n        const current = this._getAdjustedCurrentElement();\n\n        this.tokenizer.allowCDATA =\n            current &&\n            current !== this.document &&\n            this.treeAdapter.getNamespaceURI(current) !== NS.HTML &&\n            !this._isIntegrationPoint(current);\n    }\n\n    _switchToTextParsing(currentToken, nextTokenizerState) {\n        this._insertElement(currentToken, NS.HTML);\n        this.tokenizer.state = nextTokenizerState;\n        this.originalInsertionMode = this.insertionMode;\n        this.insertionMode = TEXT_MODE;\n    }\n\n    switchToPlaintextParsing() {\n        this.insertionMode = TEXT_MODE;\n        this.originalInsertionMode = IN_BODY_MODE;\n        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n    }\n\n    //Fragment parsing\n    _getAdjustedCurrentElement() {\n        return this.openElements.stackTop === 0 && this.fragmentContext\n            ? this.fragmentContext\n            : this.openElements.current;\n    }\n\n    _findFormInFragmentContext() {\n        let node = this.fragmentContext;\n\n        do {\n            if (this.treeAdapter.getTagName(node) === $.FORM) {\n                this.formElement = node;\n                break;\n            }\n\n            node = this.treeAdapter.getParentNode(node);\n        } while (node);\n    }\n\n    _initTokenizerForFragmentParsing() {\n        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {\n            const tn = this.treeAdapter.getTagName(this.fragmentContext);\n\n            if (tn === $.TITLE || tn === $.TEXTAREA) {\n                this.tokenizer.state = Tokenizer.MODE.RCDATA;\n            } else if (\n                tn === $.STYLE ||\n                tn === $.XMP ||\n                tn === $.IFRAME ||\n                tn === $.NOEMBED ||\n                tn === $.NOFRAMES ||\n                tn === $.NOSCRIPT\n            ) {\n                this.tokenizer.state = Tokenizer.MODE.RAWTEXT;\n            } else if (tn === $.SCRIPT) {\n                this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;\n            } else if (tn === $.PLAINTEXT) {\n                this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n            }\n        }\n    }\n\n    //Tree mutation\n    _setDocumentType(token) {\n        const name = token.name || '';\n        const publicId = token.publicId || '';\n        const systemId = token.systemId || '';\n\n        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);\n    }\n\n    _attachElementToTree(element) {\n        if (this._shouldFosterParentOnInsertion()) {\n            this._fosterParentElement(element);\n        } else {\n            const parent = this.openElements.currentTmplContent || this.openElements.current;\n\n            this.treeAdapter.appendChild(parent, element);\n        }\n    }\n\n    _appendElement(token, namespaceURI) {\n        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);\n\n        this._attachElementToTree(element);\n    }\n\n    _insertElement(token, namespaceURI) {\n        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);\n\n        this._attachElementToTree(element);\n        this.openElements.push(element);\n    }\n\n    _insertFakeElement(tagName) {\n        const element = this.treeAdapter.createElement(tagName, NS.HTML, []);\n\n        this._attachElementToTree(element);\n        this.openElements.push(element);\n    }\n\n    _insertTemplate(token) {\n        const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);\n        const content = this.treeAdapter.createDocumentFragment();\n\n        this.treeAdapter.setTemplateContent(tmpl, content);\n        this._attachElementToTree(tmpl);\n        this.openElements.push(tmpl);\n    }\n\n    _insertFakeRootElement() {\n        const element = this.treeAdapter.createElement($.HTML, NS.HTML, []);\n\n        this.treeAdapter.appendChild(this.openElements.current, element);\n        this.openElements.push(element);\n    }\n\n    _appendCommentNode(token, parent) {\n        const commentNode = this.treeAdapter.createCommentNode(token.data);\n\n        this.treeAdapter.appendChild(parent, commentNode);\n    }\n\n    _insertCharacters(token) {\n        if (this._shouldFosterParentOnInsertion()) {\n            this._fosterParentText(token.chars);\n        } else {\n            const parent = this.openElements.currentTmplContent || this.openElements.current;\n\n            this.treeAdapter.insertText(parent, token.chars);\n        }\n    }\n\n    _adoptNodes(donor, recipient) {\n        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {\n            this.treeAdapter.detachNode(child);\n            this.treeAdapter.appendChild(recipient, child);\n        }\n    }\n\n    //Token processing\n    _shouldProcessTokenInForeignContent(token) {\n        const current = this._getAdjustedCurrentElement();\n\n        if (!current || current === this.document) {\n            return false;\n        }\n\n        const ns = this.treeAdapter.getNamespaceURI(current);\n\n        if (ns === NS.HTML) {\n            return false;\n        }\n\n        if (\n            this.treeAdapter.getTagName(current) === $.ANNOTATION_XML &&\n            ns === NS.MATHML &&\n            token.type === Tokenizer.START_TAG_TOKEN &&\n            token.tagName === $.SVG\n        ) {\n            return false;\n        }\n\n        const isCharacterToken =\n            token.type === Tokenizer.CHARACTER_TOKEN ||\n            token.type === Tokenizer.NULL_CHARACTER_TOKEN ||\n            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;\n\n        const isMathMLTextStartTag =\n            token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;\n\n        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {\n            return false;\n        }\n\n        if (\n            (token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&\n            this._isIntegrationPoint(current, NS.HTML)\n        ) {\n            return false;\n        }\n\n        return token.type !== Tokenizer.EOF_TOKEN;\n    }\n\n    _processToken(token) {\n        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);\n    }\n\n    _processTokenInBodyMode(token) {\n        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);\n    }\n\n    _processTokenInForeignContent(token) {\n        if (token.type === Tokenizer.CHARACTER_TOKEN) {\n            characterInForeignContent(this, token);\n        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n            nullCharacterInForeignContent(this, token);\n        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {\n            insertCharacters(this, token);\n        } else if (token.type === Tokenizer.COMMENT_TOKEN) {\n            appendComment(this, token);\n        } else if (token.type === Tokenizer.START_TAG_TOKEN) {\n            startTagInForeignContent(this, token);\n        } else if (token.type === Tokenizer.END_TAG_TOKEN) {\n            endTagInForeignContent(this, token);\n        }\n    }\n\n    _processInputToken(token) {\n        if (this._shouldProcessTokenInForeignContent(token)) {\n            this._processTokenInForeignContent(token);\n        } else {\n            this._processToken(token);\n        }\n\n        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {\n            this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);\n        }\n    }\n\n    //Integration points\n    _isIntegrationPoint(element, foreignNS) {\n        const tn = this.treeAdapter.getTagName(element);\n        const ns = this.treeAdapter.getNamespaceURI(element);\n        const attrs = this.treeAdapter.getAttrList(element);\n\n        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);\n    }\n\n    //Active formatting elements reconstruction\n    _reconstructActiveFormattingElements() {\n        const listLength = this.activeFormattingElements.length;\n\n        if (listLength) {\n            let unopenIdx = listLength;\n            let entry = null;\n\n            do {\n                unopenIdx--;\n                entry = this.activeFormattingElements.entries[unopenIdx];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {\n                    unopenIdx++;\n                    break;\n                }\n            } while (unopenIdx > 0);\n\n            for (let i = unopenIdx; i < listLength; i++) {\n                entry = this.activeFormattingElements.entries[i];\n                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));\n                entry.element = this.openElements.current;\n            }\n        }\n    }\n\n    //Close elements\n    _closeTableCell() {\n        this.openElements.generateImpliedEndTags();\n        this.openElements.popUntilTableCellPopped();\n        this.activeFormattingElements.clearToLastMarker();\n        this.insertionMode = IN_ROW_MODE;\n    }\n\n    _closePElement() {\n        this.openElements.generateImpliedEndTagsWithExclusion($.P);\n        this.openElements.popUntilTagNamePopped($.P);\n    }\n\n    //Insertion modes\n    _resetInsertionMode() {\n        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {\n            let element = this.openElements.items[i];\n\n            if (i === 0) {\n                last = true;\n\n                if (this.fragmentContext) {\n                    element = this.fragmentContext;\n                }\n            }\n\n            const tn = this.treeAdapter.getTagName(element);\n            const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];\n\n            if (newInsertionMode) {\n                this.insertionMode = newInsertionMode;\n                break;\n            } else if (!last && (tn === $.TD || tn === $.TH)) {\n                this.insertionMode = IN_CELL_MODE;\n                break;\n            } else if (!last && tn === $.HEAD) {\n                this.insertionMode = IN_HEAD_MODE;\n                break;\n            } else if (tn === $.SELECT) {\n                this._resetInsertionModeForSelect(i);\n                break;\n            } else if (tn === $.TEMPLATE) {\n                this.insertionMode = this.currentTmplInsertionMode;\n                break;\n            } else if (tn === $.HTML) {\n                this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;\n                break;\n            } else if (last) {\n                this.insertionMode = IN_BODY_MODE;\n                break;\n            }\n        }\n    }\n\n    _resetInsertionModeForSelect(selectIdx) {\n        if (selectIdx > 0) {\n            for (let i = selectIdx - 1; i > 0; i--) {\n                const ancestor = this.openElements.items[i];\n                const tn = this.treeAdapter.getTagName(ancestor);\n\n                if (tn === $.TEMPLATE) {\n                    break;\n                } else if (tn === $.TABLE) {\n                    this.insertionMode = IN_SELECT_IN_TABLE_MODE;\n                    return;\n                }\n            }\n        }\n\n        this.insertionMode = IN_SELECT_MODE;\n    }\n\n    _pushTmplInsertionMode(mode) {\n        this.tmplInsertionModeStack.push(mode);\n        this.tmplInsertionModeStackTop++;\n        this.currentTmplInsertionMode = mode;\n    }\n\n    _popTmplInsertionMode() {\n        this.tmplInsertionModeStack.pop();\n        this.tmplInsertionModeStackTop--;\n        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];\n    }\n\n    //Foster parenting\n    _isElementCausesFosterParenting(element) {\n        const tn = this.treeAdapter.getTagName(element);\n\n        return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;\n    }\n\n    _shouldFosterParentOnInsertion() {\n        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);\n    }\n\n    _findFosterParentingLocation() {\n        const location = {\n            parent: null,\n            beforeElement: null\n        };\n\n        for (let i = this.openElements.stackTop; i >= 0; i--) {\n            const openElement = this.openElements.items[i];\n            const tn = this.treeAdapter.getTagName(openElement);\n            const ns = this.treeAdapter.getNamespaceURI(openElement);\n\n            if (tn === $.TEMPLATE && ns === NS.HTML) {\n                location.parent = this.treeAdapter.getTemplateContent(openElement);\n                break;\n            } else if (tn === $.TABLE) {\n                location.parent = this.treeAdapter.getParentNode(openElement);\n\n                if (location.parent) {\n                    location.beforeElement = openElement;\n                } else {\n                    location.parent = this.openElements.items[i - 1];\n                }\n\n                break;\n            }\n        }\n\n        if (!location.parent) {\n            location.parent = this.openElements.items[0];\n        }\n\n        return location;\n    }\n\n    _fosterParentElement(element) {\n        const location = this._findFosterParentingLocation();\n\n        if (location.beforeElement) {\n            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);\n        } else {\n            this.treeAdapter.appendChild(location.parent, element);\n        }\n    }\n\n    _fosterParentText(chars) {\n        const location = this._findFosterParentingLocation();\n\n        if (location.beforeElement) {\n            this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);\n        } else {\n            this.treeAdapter.insertText(location.parent, chars);\n        }\n    }\n\n    //Special elements\n    _isSpecialElement(element) {\n        const tn = this.treeAdapter.getTagName(element);\n        const ns = this.treeAdapter.getNamespaceURI(element);\n\n        return HTML.SPECIAL_ELEMENTS[ns][tn];\n    }\n}\n\nmodule.exports = Parser;\n\n//Adoption agency algorithm\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)\n//------------------------------------------------------------------\n\n//Steps 5-8 of the algorithm\nfunction aaObtainFormattingElementEntry(p, token) {\n    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);\n\n    if (formattingElementEntry) {\n        if (!p.openElements.contains(formattingElementEntry.element)) {\n            p.activeFormattingElements.removeEntry(formattingElementEntry);\n            formattingElementEntry = null;\n        } else if (!p.openElements.hasInScope(token.tagName)) {\n            formattingElementEntry = null;\n        }\n    } else {\n        genericEndTagInBody(p, token);\n    }\n\n    return formattingElementEntry;\n}\n\n//Steps 9 and 10 of the algorithm\nfunction aaObtainFurthestBlock(p, formattingElementEntry) {\n    let furthestBlock = null;\n\n    for (let i = p.openElements.stackTop; i >= 0; i--) {\n        const element = p.openElements.items[i];\n\n        if (element === formattingElementEntry.element) {\n            break;\n        }\n\n        if (p._isSpecialElement(element)) {\n            furthestBlock = element;\n        }\n    }\n\n    if (!furthestBlock) {\n        p.openElements.popUntilElementPopped(formattingElementEntry.element);\n        p.activeFormattingElements.removeEntry(formattingElementEntry);\n    }\n\n    return furthestBlock;\n}\n\n//Step 13 of the algorithm\nfunction aaInnerLoop(p, furthestBlock, formattingElement) {\n    let lastElement = furthestBlock;\n    let nextElement = p.openElements.getCommonAncestor(furthestBlock);\n\n    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {\n        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)\n        nextElement = p.openElements.getCommonAncestor(element);\n\n        const elementEntry = p.activeFormattingElements.getElementEntry(element);\n        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;\n        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;\n\n        if (shouldRemoveFromOpenElements) {\n            if (counterOverflow) {\n                p.activeFormattingElements.removeEntry(elementEntry);\n            }\n\n            p.openElements.remove(element);\n        } else {\n            element = aaRecreateElementFromEntry(p, elementEntry);\n\n            if (lastElement === furthestBlock) {\n                p.activeFormattingElements.bookmark = elementEntry;\n            }\n\n            p.treeAdapter.detachNode(lastElement);\n            p.treeAdapter.appendChild(element, lastElement);\n            lastElement = element;\n        }\n    }\n\n    return lastElement;\n}\n\n//Step 13.7 of the algorithm\nfunction aaRecreateElementFromEntry(p, elementEntry) {\n    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);\n    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);\n\n    p.openElements.replace(elementEntry.element, newElement);\n    elementEntry.element = newElement;\n\n    return newElement;\n}\n\n//Step 14 of the algorithm\nfunction aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {\n    if (p._isElementCausesFosterParenting(commonAncestor)) {\n        p._fosterParentElement(lastElement);\n    } else {\n        const tn = p.treeAdapter.getTagName(commonAncestor);\n        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);\n\n        if (tn === $.TEMPLATE && ns === NS.HTML) {\n            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);\n        }\n\n        p.treeAdapter.appendChild(commonAncestor, lastElement);\n    }\n}\n\n//Steps 15-19 of the algorithm\nfunction aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {\n    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);\n    const token = formattingElementEntry.token;\n    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);\n\n    p._adoptNodes(furthestBlock, newElement);\n    p.treeAdapter.appendChild(furthestBlock, newElement);\n\n    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);\n    p.activeFormattingElements.removeEntry(formattingElementEntry);\n\n    p.openElements.remove(formattingElementEntry.element);\n    p.openElements.insertAfter(furthestBlock, newElement);\n}\n\n//Algorithm entry point\nfunction callAdoptionAgency(p, token) {\n    let formattingElementEntry;\n\n    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {\n        formattingElementEntry = aaObtainFormattingElementEntry(p, token, formattingElementEntry);\n\n        if (!formattingElementEntry) {\n            break;\n        }\n\n        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);\n\n        if (!furthestBlock) {\n            break;\n        }\n\n        p.activeFormattingElements.bookmark = formattingElementEntry;\n\n        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);\n        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);\n\n        p.treeAdapter.detachNode(lastElement);\n        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);\n        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);\n    }\n}\n\n//Generic token handlers\n//------------------------------------------------------------------\nfunction ignoreToken() {\n    //NOTE: do nothing =)\n}\n\nfunction misplacedDoctype(p) {\n    p._err(ERR.misplacedDoctype);\n}\n\nfunction appendComment(p, token) {\n    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);\n}\n\nfunction appendCommentToRootHtmlElement(p, token) {\n    p._appendCommentNode(token, p.openElements.items[0]);\n}\n\nfunction appendCommentToDocument(p, token) {\n    p._appendCommentNode(token, p.document);\n}\n\nfunction insertCharacters(p, token) {\n    p._insertCharacters(token);\n}\n\nfunction stopParsing(p) {\n    p.stopped = true;\n}\n\n// The \"initial\" insertion mode\n//------------------------------------------------------------------\nfunction doctypeInInitialMode(p, token) {\n    p._setDocumentType(token);\n\n    const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);\n\n    if (!doctype.isConforming(token)) {\n        p._err(ERR.nonConformingDoctype);\n    }\n\n    p.treeAdapter.setDocumentMode(p.document, mode);\n\n    p.insertionMode = BEFORE_HTML_MODE;\n}\n\nfunction tokenInInitialMode(p, token) {\n    p._err(ERR.missingDoctype, { beforeToken: true });\n    p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);\n    p.insertionMode = BEFORE_HTML_MODE;\n    p._processToken(token);\n}\n\n// The \"before html\" insertion mode\n//------------------------------------------------------------------\nfunction startTagBeforeHtml(p, token) {\n    if (token.tagName === $.HTML) {\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = BEFORE_HEAD_MODE;\n    } else {\n        tokenBeforeHtml(p, token);\n    }\n}\n\nfunction endTagBeforeHtml(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {\n        tokenBeforeHtml(p, token);\n    }\n}\n\nfunction tokenBeforeHtml(p, token) {\n    p._insertFakeRootElement();\n    p.insertionMode = BEFORE_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"before head\" insertion mode\n//------------------------------------------------------------------\nfunction startTagBeforeHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.HEAD) {\n        p._insertElement(token, NS.HTML);\n        p.headElement = p.openElements.current;\n        p.insertionMode = IN_HEAD_MODE;\n    } else {\n        tokenBeforeHead(p, token);\n    }\n}\n\nfunction endTagBeforeHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {\n        tokenBeforeHead(p, token);\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenBeforeHead(p, token) {\n    p._insertFakeElement($.HEAD);\n    p.headElement = p.openElements.current;\n    p.insertionMode = IN_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"in head\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {\n        p._appendElement(token, NS.HTML);\n        token.ackSelfClosing = true;\n    } else if (tn === $.TITLE) {\n        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);\n    } else if (tn === $.NOSCRIPT) {\n        if (p.options.scriptingEnabled) {\n            p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n        } else {\n            p._insertElement(token, NS.HTML);\n            p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;\n        }\n    } else if (tn === $.NOFRAMES || tn === $.STYLE) {\n        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n    } else if (tn === $.SCRIPT) {\n        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);\n    } else if (tn === $.TEMPLATE) {\n        p._insertTemplate(token, NS.HTML);\n        p.activeFormattingElements.insertMarker();\n        p.framesetOk = false;\n        p.insertionMode = IN_TEMPLATE_MODE;\n        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);\n    } else if (tn === $.HEAD) {\n        p._err(ERR.misplacedStartTagForHeadElement);\n    } else {\n        tokenInHead(p, token);\n    }\n}\n\nfunction endTagInHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HEAD) {\n        p.openElements.pop();\n        p.insertionMode = AFTER_HEAD_MODE;\n    } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {\n        tokenInHead(p, token);\n    } else if (tn === $.TEMPLATE) {\n        if (p.openElements.tmplCount > 0) {\n            p.openElements.generateImpliedEndTagsThoroughly();\n\n            if (p.openElements.currentTagName !== $.TEMPLATE) {\n                p._err(ERR.closingOfElementWithOpenChildElements);\n            }\n\n            p.openElements.popUntilTagNamePopped($.TEMPLATE);\n            p.activeFormattingElements.clearToLastMarker();\n            p._popTmplInsertionMode();\n            p._resetInsertionMode();\n        } else {\n            p._err(ERR.endTagWithoutMatchingOpenElement);\n        }\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenInHead(p, token) {\n    p.openElements.pop();\n    p.insertionMode = AFTER_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"in head no script\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInHeadNoScript(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (\n        tn === $.BASEFONT ||\n        tn === $.BGSOUND ||\n        tn === $.HEAD ||\n        tn === $.LINK ||\n        tn === $.META ||\n        tn === $.NOFRAMES ||\n        tn === $.STYLE\n    ) {\n        startTagInHead(p, token);\n    } else if (tn === $.NOSCRIPT) {\n        p._err(ERR.nestedNoscriptInHead);\n    } else {\n        tokenInHeadNoScript(p, token);\n    }\n}\n\nfunction endTagInHeadNoScript(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.NOSCRIPT) {\n        p.openElements.pop();\n        p.insertionMode = IN_HEAD_MODE;\n    } else if (tn === $.BR) {\n        tokenInHeadNoScript(p, token);\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenInHeadNoScript(p, token) {\n    const errCode =\n        token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;\n\n    p._err(errCode);\n    p.openElements.pop();\n    p.insertionMode = IN_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"after head\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.BODY) {\n        p._insertElement(token, NS.HTML);\n        p.framesetOk = false;\n        p.insertionMode = IN_BODY_MODE;\n    } else if (tn === $.FRAMESET) {\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_FRAMESET_MODE;\n    } else if (\n        tn === $.BASE ||\n        tn === $.BASEFONT ||\n        tn === $.BGSOUND ||\n        tn === $.LINK ||\n        tn === $.META ||\n        tn === $.NOFRAMES ||\n        tn === $.SCRIPT ||\n        tn === $.STYLE ||\n        tn === $.TEMPLATE ||\n        tn === $.TITLE\n    ) {\n        p._err(ERR.abandonedHeadElementChild);\n        p.openElements.push(p.headElement);\n        startTagInHead(p, token);\n        p.openElements.remove(p.headElement);\n    } else if (tn === $.HEAD) {\n        p._err(ERR.misplacedStartTagForHeadElement);\n    } else {\n        tokenAfterHead(p, token);\n    }\n}\n\nfunction endTagAfterHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.BODY || tn === $.HTML || tn === $.BR) {\n        tokenAfterHead(p, token);\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenAfterHead(p, token) {\n    p._insertFakeElement($.BODY);\n    p.insertionMode = IN_BODY_MODE;\n    p._processToken(token);\n}\n\n// The \"in body\" insertion mode\n//------------------------------------------------------------------\nfunction whitespaceCharacterInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertCharacters(token);\n}\n\nfunction characterInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertCharacters(token);\n    p.framesetOk = false;\n}\n\nfunction htmlStartTagInBody(p, token) {\n    if (p.openElements.tmplCount === 0) {\n        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);\n    }\n}\n\nfunction bodyStartTagInBody(p, token) {\n    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();\n\n    if (bodyElement && p.openElements.tmplCount === 0) {\n        p.framesetOk = false;\n        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);\n    }\n}\n\nfunction framesetStartTagInBody(p, token) {\n    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();\n\n    if (p.framesetOk && bodyElement) {\n        p.treeAdapter.detachNode(bodyElement);\n        p.openElements.popAllUpToHtmlElement();\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_FRAMESET_MODE;\n    }\n}\n\nfunction addressStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction numberedHeaderStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    const tn = p.openElements.currentTagName;\n\n    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n        p.openElements.pop();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction preStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move\n    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)\n    p.skipNextNewLine = true;\n    p.framesetOk = false;\n}\n\nfunction formStartTagInBody(p, token) {\n    const inTemplate = p.openElements.tmplCount > 0;\n\n    if (!p.formElement || inTemplate) {\n        if (p.openElements.hasInButtonScope($.P)) {\n            p._closePElement();\n        }\n\n        p._insertElement(token, NS.HTML);\n\n        if (!inTemplate) {\n            p.formElement = p.openElements.current;\n        }\n    }\n}\n\nfunction listItemStartTagInBody(p, token) {\n    p.framesetOk = false;\n\n    const tn = token.tagName;\n\n    for (let i = p.openElements.stackTop; i >= 0; i--) {\n        const element = p.openElements.items[i];\n        const elementTn = p.treeAdapter.getTagName(element);\n        let closeTn = null;\n\n        if (tn === $.LI && elementTn === $.LI) {\n            closeTn = $.LI;\n        } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {\n            closeTn = elementTn;\n        }\n\n        if (closeTn) {\n            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);\n            p.openElements.popUntilTagNamePopped(closeTn);\n            break;\n        }\n\n        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element)) {\n            break;\n        }\n    }\n\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction plaintextStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n}\n\nfunction buttonStartTagInBody(p, token) {\n    if (p.openElements.hasInScope($.BUTTON)) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilTagNamePopped($.BUTTON);\n    }\n\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.framesetOk = false;\n}\n\nfunction aStartTagInBody(p, token) {\n    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);\n\n    if (activeElementEntry) {\n        callAdoptionAgency(p, token);\n        p.openElements.remove(activeElementEntry.element);\n        p.activeFormattingElements.removeEntry(activeElementEntry);\n    }\n\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction bStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction nobrStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n\n    if (p.openElements.hasInScope($.NOBR)) {\n        callAdoptionAgency(p, token);\n        p._reconstructActiveFormattingElements();\n    }\n\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction appletStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.insertMarker();\n    p.framesetOk = false;\n}\n\nfunction tableStartTagInBody(p, token) {\n    if (\n        p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS &&\n        p.openElements.hasInButtonScope($.P)\n    ) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n    p.framesetOk = false;\n    p.insertionMode = IN_TABLE_MODE;\n}\n\nfunction areaStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._appendElement(token, NS.HTML);\n    p.framesetOk = false;\n    token.ackSelfClosing = true;\n}\n\nfunction inputStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._appendElement(token, NS.HTML);\n\n    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);\n\n    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {\n        p.framesetOk = false;\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction paramStartTagInBody(p, token) {\n    p._appendElement(token, NS.HTML);\n    token.ackSelfClosing = true;\n}\n\nfunction hrStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._appendElement(token, NS.HTML);\n    p.framesetOk = false;\n    token.ackSelfClosing = true;\n}\n\nfunction imageStartTagInBody(p, token) {\n    token.tagName = $.IMG;\n    areaStartTagInBody(p, token);\n}\n\nfunction textareaStartTagInBody(p, token) {\n    p._insertElement(token, NS.HTML);\n    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move\n    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n    p.skipNextNewLine = true;\n    p.tokenizer.state = Tokenizer.MODE.RCDATA;\n    p.originalInsertionMode = p.insertionMode;\n    p.framesetOk = false;\n    p.insertionMode = TEXT_MODE;\n}\n\nfunction xmpStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._reconstructActiveFormattingElements();\n    p.framesetOk = false;\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\nfunction iframeStartTagInBody(p, token) {\n    p.framesetOk = false;\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\n//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse\n//<noembed> as a rawtext.\nfunction noembedStartTagInBody(p, token) {\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\nfunction selectStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.framesetOk = false;\n\n    if (\n        p.insertionMode === IN_TABLE_MODE ||\n        p.insertionMode === IN_CAPTION_MODE ||\n        p.insertionMode === IN_TABLE_BODY_MODE ||\n        p.insertionMode === IN_ROW_MODE ||\n        p.insertionMode === IN_CELL_MODE\n    ) {\n        p.insertionMode = IN_SELECT_IN_TABLE_MODE;\n    } else {\n        p.insertionMode = IN_SELECT_MODE;\n    }\n}\n\nfunction optgroupStartTagInBody(p, token) {\n    if (p.openElements.currentTagName === $.OPTION) {\n        p.openElements.pop();\n    }\n\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n}\n\nfunction rbStartTagInBody(p, token) {\n    if (p.openElements.hasInScope($.RUBY)) {\n        p.openElements.generateImpliedEndTags();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction rtStartTagInBody(p, token) {\n    if (p.openElements.hasInScope($.RUBY)) {\n        p.openElements.generateImpliedEndTagsWithExclusion($.RTC);\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction menuStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction mathStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n\n    foreignContent.adjustTokenMathMLAttrs(token);\n    foreignContent.adjustTokenXMLAttrs(token);\n\n    if (token.selfClosing) {\n        p._appendElement(token, NS.MATHML);\n    } else {\n        p._insertElement(token, NS.MATHML);\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction svgStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n\n    foreignContent.adjustTokenSVGAttrs(token);\n    foreignContent.adjustTokenXMLAttrs(token);\n\n    if (token.selfClosing) {\n        p._appendElement(token, NS.SVG);\n    } else {\n        p._insertElement(token, NS.SVG);\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction genericStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n}\n\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\nfunction startTagInBody(p, token) {\n    const tn = token.tagName;\n\n    switch (tn.length) {\n        case 1:\n            if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.P) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.A) {\n                aStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 2:\n            if (tn === $.DL || tn === $.OL || tn === $.UL) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n                numberedHeaderStartTagInBody(p, token);\n            } else if (tn === $.LI || tn === $.DD || tn === $.DT) {\n                listItemStartTagInBody(p, token);\n            } else if (tn === $.EM || tn === $.TT) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.BR) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.HR) {\n                hrStartTagInBody(p, token);\n            } else if (tn === $.RB) {\n                rbStartTagInBody(p, token);\n            } else if (tn === $.RT || tn === $.RP) {\n                rtStartTagInBody(p, token);\n            } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 3:\n            if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.PRE) {\n                preStartTagInBody(p, token);\n            } else if (tn === $.BIG) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.IMG || tn === $.WBR) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.XMP) {\n                xmpStartTagInBody(p, token);\n            } else if (tn === $.SVG) {\n                svgStartTagInBody(p, token);\n            } else if (tn === $.RTC) {\n                rbStartTagInBody(p, token);\n            } else if (tn !== $.COL) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.HTML) {\n                htmlStartTagInBody(p, token);\n            } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {\n                startTagInHead(p, token);\n            } else if (tn === $.BODY) {\n                bodyStartTagInBody(p, token);\n            } else if (tn === $.MAIN || tn === $.MENU) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.FORM) {\n                formStartTagInBody(p, token);\n            } else if (tn === $.CODE || tn === $.FONT) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.NOBR) {\n                nobrStartTagInBody(p, token);\n            } else if (tn === $.AREA) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.MATH) {\n                mathStartTagInBody(p, token);\n            } else if (tn === $.MENU) {\n                menuStartTagInBody(p, token);\n            } else if (tn !== $.HEAD) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.STYLE || tn === $.TITLE) {\n                startTagInHead(p, token);\n            } else if (tn === $.ASIDE) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.SMALL) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.TABLE) {\n                tableStartTagInBody(p, token);\n            } else if (tn === $.EMBED) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.INPUT) {\n                inputStartTagInBody(p, token);\n            } else if (tn === $.PARAM || tn === $.TRACK) {\n                paramStartTagInBody(p, token);\n            } else if (tn === $.IMAGE) {\n                imageStartTagInBody(p, token);\n            } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 6:\n            if (tn === $.SCRIPT) {\n                startTagInHead(p, token);\n            } else if (\n                tn === $.CENTER ||\n                tn === $.FIGURE ||\n                tn === $.FOOTER ||\n                tn === $.HEADER ||\n                tn === $.HGROUP ||\n                tn === $.DIALOG\n            ) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.BUTTON) {\n                buttonStartTagInBody(p, token);\n            } else if (tn === $.STRIKE || tn === $.STRONG) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.APPLET || tn === $.OBJECT) {\n                appletStartTagInBody(p, token);\n            } else if (tn === $.KEYGEN) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.SOURCE) {\n                paramStartTagInBody(p, token);\n            } else if (tn === $.IFRAME) {\n                iframeStartTagInBody(p, token);\n            } else if (tn === $.SELECT) {\n                selectStartTagInBody(p, token);\n            } else if (tn === $.OPTION) {\n                optgroupStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 7:\n            if (tn === $.BGSOUND) {\n                startTagInHead(p, token);\n            } else if (\n                tn === $.DETAILS ||\n                tn === $.ADDRESS ||\n                tn === $.ARTICLE ||\n                tn === $.SECTION ||\n                tn === $.SUMMARY\n            ) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.LISTING) {\n                preStartTagInBody(p, token);\n            } else if (tn === $.MARQUEE) {\n                appletStartTagInBody(p, token);\n            } else if (tn === $.NOEMBED) {\n                noembedStartTagInBody(p, token);\n            } else if (tn !== $.CAPTION) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 8:\n            if (tn === $.BASEFONT) {\n                startTagInHead(p, token);\n            } else if (tn === $.FRAMESET) {\n                framesetStartTagInBody(p, token);\n            } else if (tn === $.FIELDSET) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.TEXTAREA) {\n                textareaStartTagInBody(p, token);\n            } else if (tn === $.TEMPLATE) {\n                startTagInHead(p, token);\n            } else if (tn === $.NOSCRIPT) {\n                if (p.options.scriptingEnabled) {\n                    noembedStartTagInBody(p, token);\n                } else {\n                    genericStartTagInBody(p, token);\n                }\n            } else if (tn === $.OPTGROUP) {\n                optgroupStartTagInBody(p, token);\n            } else if (tn !== $.COLGROUP) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 9:\n            if (tn === $.PLAINTEXT) {\n                plaintextStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 10:\n            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {\n                addressStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        default:\n            genericStartTagInBody(p, token);\n    }\n}\n\nfunction bodyEndTagInBody(p) {\n    if (p.openElements.hasInScope($.BODY)) {\n        p.insertionMode = AFTER_BODY_MODE;\n    }\n}\n\nfunction htmlEndTagInBody(p, token) {\n    if (p.openElements.hasInScope($.BODY)) {\n        p.insertionMode = AFTER_BODY_MODE;\n        p._processToken(token);\n    }\n}\n\nfunction addressEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    if (p.openElements.hasInScope(tn)) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilTagNamePopped(tn);\n    }\n}\n\nfunction formEndTagInBody(p) {\n    const inTemplate = p.openElements.tmplCount > 0;\n    const formElement = p.formElement;\n\n    if (!inTemplate) {\n        p.formElement = null;\n    }\n\n    if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {\n        p.openElements.generateImpliedEndTags();\n\n        if (inTemplate) {\n            p.openElements.popUntilTagNamePopped($.FORM);\n        } else {\n            p.openElements.remove(formElement);\n        }\n    }\n}\n\nfunction pEndTagInBody(p) {\n    if (!p.openElements.hasInButtonScope($.P)) {\n        p._insertFakeElement($.P);\n    }\n\n    p._closePElement();\n}\n\nfunction liEndTagInBody(p) {\n    if (p.openElements.hasInListItemScope($.LI)) {\n        p.openElements.generateImpliedEndTagsWithExclusion($.LI);\n        p.openElements.popUntilTagNamePopped($.LI);\n    }\n}\n\nfunction ddEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    if (p.openElements.hasInScope(tn)) {\n        p.openElements.generateImpliedEndTagsWithExclusion(tn);\n        p.openElements.popUntilTagNamePopped(tn);\n    }\n}\n\nfunction numberedHeaderEndTagInBody(p) {\n    if (p.openElements.hasNumberedHeaderInScope()) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilNumberedHeaderPopped();\n    }\n}\n\nfunction appletEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    if (p.openElements.hasInScope(tn)) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilTagNamePopped(tn);\n        p.activeFormattingElements.clearToLastMarker();\n    }\n}\n\nfunction brEndTagInBody(p) {\n    p._reconstructActiveFormattingElements();\n    p._insertFakeElement($.BR);\n    p.openElements.pop();\n    p.framesetOk = false;\n}\n\nfunction genericEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    for (let i = p.openElements.stackTop; i > 0; i--) {\n        const element = p.openElements.items[i];\n\n        if (p.treeAdapter.getTagName(element) === tn) {\n            p.openElements.generateImpliedEndTagsWithExclusion(tn);\n            p.openElements.popUntilElementPopped(element);\n            break;\n        }\n\n        if (p._isSpecialElement(element)) {\n            break;\n        }\n    }\n}\n\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\nfunction endTagInBody(p, token) {\n    const tn = token.tagName;\n\n    switch (tn.length) {\n        case 1:\n            if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {\n                callAdoptionAgency(p, token);\n            } else if (tn === $.P) {\n                pEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 2:\n            if (tn === $.DL || tn === $.UL || tn === $.OL) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.LI) {\n                liEndTagInBody(p, token);\n            } else if (tn === $.DD || tn === $.DT) {\n                ddEndTagInBody(p, token);\n            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n                numberedHeaderEndTagInBody(p, token);\n            } else if (tn === $.BR) {\n                brEndTagInBody(p, token);\n            } else if (tn === $.EM || tn === $.TT) {\n                callAdoptionAgency(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 3:\n            if (tn === $.BIG) {\n                callAdoptionAgency(p, token);\n            } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {\n                addressEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.BODY) {\n                bodyEndTagInBody(p, token);\n            } else if (tn === $.HTML) {\n                htmlEndTagInBody(p, token);\n            } else if (tn === $.FORM) {\n                formEndTagInBody(p, token);\n            } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {\n                callAdoptionAgency(p, token);\n            } else if (tn === $.MAIN || tn === $.MENU) {\n                addressEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.ASIDE) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.SMALL) {\n                callAdoptionAgency(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 6:\n            if (\n                tn === $.CENTER ||\n                tn === $.FIGURE ||\n                tn === $.FOOTER ||\n                tn === $.HEADER ||\n                tn === $.HGROUP ||\n                tn === $.DIALOG\n            ) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.APPLET || tn === $.OBJECT) {\n                appletEndTagInBody(p, token);\n            } else if (tn === $.STRIKE || tn === $.STRONG) {\n                callAdoptionAgency(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 7:\n            if (\n                tn === $.ADDRESS ||\n                tn === $.ARTICLE ||\n                tn === $.DETAILS ||\n                tn === $.SECTION ||\n                tn === $.SUMMARY ||\n                tn === $.LISTING\n            ) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.MARQUEE) {\n                appletEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 8:\n            if (tn === $.FIELDSET) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.TEMPLATE) {\n                endTagInHead(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 10:\n            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {\n                addressEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        default:\n            genericEndTagInBody(p, token);\n    }\n}\n\nfunction eofInBody(p, token) {\n    if (p.tmplInsertionModeStackTop > -1) {\n        eofInTemplate(p, token);\n    } else {\n        p.stopped = true;\n    }\n}\n\n// The \"text\" insertion mode\n//------------------------------------------------------------------\nfunction endTagInText(p, token) {\n    if (token.tagName === $.SCRIPT) {\n        p.pendingScript = p.openElements.current;\n    }\n\n    p.openElements.pop();\n    p.insertionMode = p.originalInsertionMode;\n}\n\nfunction eofInText(p, token) {\n    p._err(ERR.eofInElementThatCanContainOnlyText);\n    p.openElements.pop();\n    p.insertionMode = p.originalInsertionMode;\n    p._processToken(token);\n}\n\n// The \"in table\" insertion mode\n//------------------------------------------------------------------\nfunction characterInTable(p, token) {\n    const curTn = p.openElements.currentTagName;\n\n    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {\n        p.pendingCharacterTokens = [];\n        p.hasNonWhitespacePendingCharacterToken = false;\n        p.originalInsertionMode = p.insertionMode;\n        p.insertionMode = IN_TABLE_TEXT_MODE;\n        p._processToken(token);\n    } else {\n        tokenInTable(p, token);\n    }\n}\n\nfunction captionStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p.activeFormattingElements.insertMarker();\n    p._insertElement(token, NS.HTML);\n    p.insertionMode = IN_CAPTION_MODE;\n}\n\nfunction colgroupStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertElement(token, NS.HTML);\n    p.insertionMode = IN_COLUMN_GROUP_MODE;\n}\n\nfunction colStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertFakeElement($.COLGROUP);\n    p.insertionMode = IN_COLUMN_GROUP_MODE;\n    p._processToken(token);\n}\n\nfunction tbodyStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertElement(token, NS.HTML);\n    p.insertionMode = IN_TABLE_BODY_MODE;\n}\n\nfunction tdStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertFakeElement($.TBODY);\n    p.insertionMode = IN_TABLE_BODY_MODE;\n    p._processToken(token);\n}\n\nfunction tableStartTagInTable(p, token) {\n    if (p.openElements.hasInTableScope($.TABLE)) {\n        p.openElements.popUntilTagNamePopped($.TABLE);\n        p._resetInsertionMode();\n        p._processToken(token);\n    }\n}\n\nfunction inputStartTagInTable(p, token) {\n    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);\n\n    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {\n        p._appendElement(token, NS.HTML);\n    } else {\n        tokenInTable(p, token);\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction formStartTagInTable(p, token) {\n    if (!p.formElement && p.openElements.tmplCount === 0) {\n        p._insertElement(token, NS.HTML);\n        p.formElement = p.openElements.current;\n        p.openElements.pop();\n    }\n}\n\nfunction startTagInTable(p, token) {\n    const tn = token.tagName;\n\n    switch (tn.length) {\n        case 2:\n            if (tn === $.TD || tn === $.TH || tn === $.TR) {\n                tdStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 3:\n            if (tn === $.COL) {\n                colStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.FORM) {\n                formStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.TABLE) {\n                tableStartTagInTable(p, token);\n            } else if (tn === $.STYLE) {\n                startTagInHead(p, token);\n            } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n                tbodyStartTagInTable(p, token);\n            } else if (tn === $.INPUT) {\n                inputStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 6:\n            if (tn === $.SCRIPT) {\n                startTagInHead(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 7:\n            if (tn === $.CAPTION) {\n                captionStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 8:\n            if (tn === $.COLGROUP) {\n                colgroupStartTagInTable(p, token);\n            } else if (tn === $.TEMPLATE) {\n                startTagInHead(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        default:\n            tokenInTable(p, token);\n    }\n}\n\nfunction endTagInTable(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TABLE) {\n        if (p.openElements.hasInTableScope($.TABLE)) {\n            p.openElements.popUntilTagNamePopped($.TABLE);\n            p._resetInsertionMode();\n        }\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    } else if (\n        tn !== $.BODY &&\n        tn !== $.CAPTION &&\n        tn !== $.COL &&\n        tn !== $.COLGROUP &&\n        tn !== $.HTML &&\n        tn !== $.TBODY &&\n        tn !== $.TD &&\n        tn !== $.TFOOT &&\n        tn !== $.TH &&\n        tn !== $.THEAD &&\n        tn !== $.TR\n    ) {\n        tokenInTable(p, token);\n    }\n}\n\nfunction tokenInTable(p, token) {\n    const savedFosterParentingState = p.fosterParentingEnabled;\n\n    p.fosterParentingEnabled = true;\n    p._processTokenInBodyMode(token);\n    p.fosterParentingEnabled = savedFosterParentingState;\n}\n\n// The \"in table text\" insertion mode\n//------------------------------------------------------------------\nfunction whitespaceCharacterInTableText(p, token) {\n    p.pendingCharacterTokens.push(token);\n}\n\nfunction characterInTableText(p, token) {\n    p.pendingCharacterTokens.push(token);\n    p.hasNonWhitespacePendingCharacterToken = true;\n}\n\nfunction tokenInTableText(p, token) {\n    let i = 0;\n\n    if (p.hasNonWhitespacePendingCharacterToken) {\n        for (; i < p.pendingCharacterTokens.length; i++) {\n            tokenInTable(p, p.pendingCharacterTokens[i]);\n        }\n    } else {\n        for (; i < p.pendingCharacterTokens.length; i++) {\n            p._insertCharacters(p.pendingCharacterTokens[i]);\n        }\n    }\n\n    p.insertionMode = p.originalInsertionMode;\n    p._processToken(token);\n}\n\n// The \"in caption\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInCaption(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TD ||\n        tn === $.TFOOT ||\n        tn === $.TH ||\n        tn === $.THEAD ||\n        tn === $.TR\n    ) {\n        if (p.openElements.hasInTableScope($.CAPTION)) {\n            p.openElements.generateImpliedEndTags();\n            p.openElements.popUntilTagNamePopped($.CAPTION);\n            p.activeFormattingElements.clearToLastMarker();\n            p.insertionMode = IN_TABLE_MODE;\n            p._processToken(token);\n        }\n    } else {\n        startTagInBody(p, token);\n    }\n}\n\nfunction endTagInCaption(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.CAPTION || tn === $.TABLE) {\n        if (p.openElements.hasInTableScope($.CAPTION)) {\n            p.openElements.generateImpliedEndTags();\n            p.openElements.popUntilTagNamePopped($.CAPTION);\n            p.activeFormattingElements.clearToLastMarker();\n            p.insertionMode = IN_TABLE_MODE;\n\n            if (tn === $.TABLE) {\n                p._processToken(token);\n            }\n        }\n    } else if (\n        tn !== $.BODY &&\n        tn !== $.COL &&\n        tn !== $.COLGROUP &&\n        tn !== $.HTML &&\n        tn !== $.TBODY &&\n        tn !== $.TD &&\n        tn !== $.TFOOT &&\n        tn !== $.TH &&\n        tn !== $.THEAD &&\n        tn !== $.TR\n    ) {\n        endTagInBody(p, token);\n    }\n}\n\n// The \"in column group\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInColumnGroup(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.COL) {\n        p._appendElement(token, NS.HTML);\n        token.ackSelfClosing = true;\n    } else if (tn === $.TEMPLATE) {\n        startTagInHead(p, token);\n    } else {\n        tokenInColumnGroup(p, token);\n    }\n}\n\nfunction endTagInColumnGroup(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.COLGROUP) {\n        if (p.openElements.currentTagName === $.COLGROUP) {\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n        }\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    } else if (tn !== $.COL) {\n        tokenInColumnGroup(p, token);\n    }\n}\n\nfunction tokenInColumnGroup(p, token) {\n    if (p.openElements.currentTagName === $.COLGROUP) {\n        p.openElements.pop();\n        p.insertionMode = IN_TABLE_MODE;\n        p._processToken(token);\n    }\n}\n\n// The \"in table body\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInTableBody(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TR) {\n        p.openElements.clearBackToTableBodyContext();\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_ROW_MODE;\n    } else if (tn === $.TH || tn === $.TD) {\n        p.openElements.clearBackToTableBodyContext();\n        p._insertFakeElement($.TR);\n        p.insertionMode = IN_ROW_MODE;\n        p._processToken(token);\n    } else if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD\n    ) {\n        if (p.openElements.hasTableBodyContextInTableScope()) {\n            p.openElements.clearBackToTableBodyContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n            p._processToken(token);\n        }\n    } else {\n        startTagInTable(p, token);\n    }\n}\n\nfunction endTagInTableBody(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p.openElements.clearBackToTableBodyContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n        }\n    } else if (tn === $.TABLE) {\n        if (p.openElements.hasTableBodyContextInTableScope()) {\n            p.openElements.clearBackToTableBodyContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n            p._processToken(token);\n        }\n    } else if (\n        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||\n        (tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR)\n    ) {\n        endTagInTable(p, token);\n    }\n}\n\n// The \"in row\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInRow(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TH || tn === $.TD) {\n        p.openElements.clearBackToTableRowContext();\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_CELL_MODE;\n        p.activeFormattingElements.insertMarker();\n    } else if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD ||\n        tn === $.TR\n    ) {\n        if (p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n            p._processToken(token);\n        }\n    } else {\n        startTagInTable(p, token);\n    }\n}\n\nfunction endTagInRow(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TR) {\n        if (p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n        }\n    } else if (tn === $.TABLE) {\n        if (p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n            p._processToken(token);\n        }\n    } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n            p._processToken(token);\n        }\n    } else if (\n        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||\n        (tn !== $.HTML && tn !== $.TD && tn !== $.TH)\n    ) {\n        endTagInTable(p, token);\n    }\n}\n\n// The \"in cell\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInCell(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TD ||\n        tn === $.TFOOT ||\n        tn === $.TH ||\n        tn === $.THEAD ||\n        tn === $.TR\n    ) {\n        if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {\n            p._closeTableCell();\n            p._processToken(token);\n        }\n    } else {\n        startTagInBody(p, token);\n    }\n}\n\nfunction endTagInCell(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TD || tn === $.TH) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p.openElements.generateImpliedEndTags();\n            p.openElements.popUntilTagNamePopped(tn);\n            p.activeFormattingElements.clearToLastMarker();\n            p.insertionMode = IN_ROW_MODE;\n        }\n    } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p._closeTableCell();\n            p._processToken(token);\n        }\n    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {\n        endTagInBody(p, token);\n    }\n}\n\n// The \"in select\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInSelect(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.OPTION) {\n        if (p.openElements.currentTagName === $.OPTION) {\n            p.openElements.pop();\n        }\n\n        p._insertElement(token, NS.HTML);\n    } else if (tn === $.OPTGROUP) {\n        if (p.openElements.currentTagName === $.OPTION) {\n            p.openElements.pop();\n        }\n\n        if (p.openElements.currentTagName === $.OPTGROUP) {\n            p.openElements.pop();\n        }\n\n        p._insertElement(token, NS.HTML);\n    } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {\n        if (p.openElements.hasInSelectScope($.SELECT)) {\n            p.openElements.popUntilTagNamePopped($.SELECT);\n            p._resetInsertionMode();\n\n            if (tn !== $.SELECT) {\n                p._processToken(token);\n            }\n        }\n    } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {\n        startTagInHead(p, token);\n    }\n}\n\nfunction endTagInSelect(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.OPTGROUP) {\n        const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];\n        const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);\n\n        if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {\n            p.openElements.pop();\n        }\n\n        if (p.openElements.currentTagName === $.OPTGROUP) {\n            p.openElements.pop();\n        }\n    } else if (tn === $.OPTION) {\n        if (p.openElements.currentTagName === $.OPTION) {\n            p.openElements.pop();\n        }\n    } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {\n        p.openElements.popUntilTagNamePopped($.SELECT);\n        p._resetInsertionMode();\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    }\n}\n\n//12.2.5.4.17 The \"in select in table\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInSelectInTable(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.TABLE ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD ||\n        tn === $.TR ||\n        tn === $.TD ||\n        tn === $.TH\n    ) {\n        p.openElements.popUntilTagNamePopped($.SELECT);\n        p._resetInsertionMode();\n        p._processToken(token);\n    } else {\n        startTagInSelect(p, token);\n    }\n}\n\nfunction endTagInSelectInTable(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.TABLE ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD ||\n        tn === $.TR ||\n        tn === $.TD ||\n        tn === $.TH\n    ) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p.openElements.popUntilTagNamePopped($.SELECT);\n            p._resetInsertionMode();\n            p._processToken(token);\n        }\n    } else {\n        endTagInSelect(p, token);\n    }\n}\n\n// The \"in template\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInTemplate(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.BASE ||\n        tn === $.BASEFONT ||\n        tn === $.BGSOUND ||\n        tn === $.LINK ||\n        tn === $.META ||\n        tn === $.NOFRAMES ||\n        tn === $.SCRIPT ||\n        tn === $.STYLE ||\n        tn === $.TEMPLATE ||\n        tn === $.TITLE\n    ) {\n        startTagInHead(p, token);\n    } else {\n        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;\n\n        p._popTmplInsertionMode();\n        p._pushTmplInsertionMode(newInsertionMode);\n        p.insertionMode = newInsertionMode;\n        p._processToken(token);\n    }\n}\n\nfunction endTagInTemplate(p, token) {\n    if (token.tagName === $.TEMPLATE) {\n        endTagInHead(p, token);\n    }\n}\n\nfunction eofInTemplate(p, token) {\n    if (p.openElements.tmplCount > 0) {\n        p.openElements.popUntilTagNamePopped($.TEMPLATE);\n        p.activeFormattingElements.clearToLastMarker();\n        p._popTmplInsertionMode();\n        p._resetInsertionMode();\n        p._processToken(token);\n    } else {\n        p.stopped = true;\n    }\n}\n\n// The \"after body\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterBody(p, token) {\n    if (token.tagName === $.HTML) {\n        startTagInBody(p, token);\n    } else {\n        tokenAfterBody(p, token);\n    }\n}\n\nfunction endTagAfterBody(p, token) {\n    if (token.tagName === $.HTML) {\n        if (!p.fragmentContext) {\n            p.insertionMode = AFTER_AFTER_BODY_MODE;\n        }\n    } else {\n        tokenAfterBody(p, token);\n    }\n}\n\nfunction tokenAfterBody(p, token) {\n    p.insertionMode = IN_BODY_MODE;\n    p._processToken(token);\n}\n\n// The \"in frameset\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInFrameset(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.FRAMESET) {\n        p._insertElement(token, NS.HTML);\n    } else if (tn === $.FRAME) {\n        p._appendElement(token, NS.HTML);\n        token.ackSelfClosing = true;\n    } else if (tn === $.NOFRAMES) {\n        startTagInHead(p, token);\n    }\n}\n\nfunction endTagInFrameset(p, token) {\n    if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {\n        p.openElements.pop();\n\n        if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {\n            p.insertionMode = AFTER_FRAMESET_MODE;\n        }\n    }\n}\n\n// The \"after frameset\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterFrameset(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.NOFRAMES) {\n        startTagInHead(p, token);\n    }\n}\n\nfunction endTagAfterFrameset(p, token) {\n    if (token.tagName === $.HTML) {\n        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;\n    }\n}\n\n// The \"after after body\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterAfterBody(p, token) {\n    if (token.tagName === $.HTML) {\n        startTagInBody(p, token);\n    } else {\n        tokenAfterAfterBody(p, token);\n    }\n}\n\nfunction tokenAfterAfterBody(p, token) {\n    p.insertionMode = IN_BODY_MODE;\n    p._processToken(token);\n}\n\n// The \"after after frameset\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterAfterFrameset(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.NOFRAMES) {\n        startTagInHead(p, token);\n    }\n}\n\n// The rules for parsing tokens in foreign content\n//------------------------------------------------------------------\nfunction nullCharacterInForeignContent(p, token) {\n    token.chars = unicode.REPLACEMENT_CHARACTER;\n    p._insertCharacters(token);\n}\n\nfunction characterInForeignContent(p, token) {\n    p._insertCharacters(token);\n    p.framesetOk = false;\n}\n\nfunction startTagInForeignContent(p, token) {\n    if (foreignContent.causesExit(token) && !p.fragmentContext) {\n        while (\n            p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&\n            !p._isIntegrationPoint(p.openElements.current)\n        ) {\n            p.openElements.pop();\n        }\n\n        p._processToken(token);\n    } else {\n        const current = p._getAdjustedCurrentElement();\n        const currentNs = p.treeAdapter.getNamespaceURI(current);\n\n        if (currentNs === NS.MATHML) {\n            foreignContent.adjustTokenMathMLAttrs(token);\n        } else if (currentNs === NS.SVG) {\n            foreignContent.adjustTokenSVGTagName(token);\n            foreignContent.adjustTokenSVGAttrs(token);\n        }\n\n        foreignContent.adjustTokenXMLAttrs(token);\n\n        if (token.selfClosing) {\n            p._appendElement(token, currentNs);\n        } else {\n            p._insertElement(token, currentNs);\n        }\n\n        token.ackSelfClosing = true;\n    }\n}\n\nfunction endTagInForeignContent(p, token) {\n    for (let i = p.openElements.stackTop; i > 0; i--) {\n        const element = p.openElements.items[i];\n\n        if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {\n            p._processToken(token);\n            break;\n        }\n\n        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {\n            p.openElements.popUntilElementPopped(element);\n            break;\n        }\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeArray = exports.serialize = void 0;\nvar utils_1 = require(\"../utils\");\n/*\n * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js\n * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js\n */\nvar submittableSelector = 'input,select,textarea,keygen';\nvar r20 = /%20/g;\nvar rCRLF = /\\r?\\n/g;\n/**\n * Encode a set of form elements as a string for submission.\n *\n * @category Forms\n * @returns The serialized form.\n * @see {@link https://api.jquery.com/serialize/}\n */\nfunction serialize() {\n    // Convert form elements into name/value objects\n    var arr = this.serializeArray();\n    // Serialize each element into a key/value string\n    var retArr = arr.map(function (data) {\n        return encodeURIComponent(data.name) + \"=\" + encodeURIComponent(data.value);\n    });\n    // Return the resulting serialization\n    return retArr.join('&').replace(r20, '+');\n}\nexports.serialize = serialize;\n/**\n * Encode a set of form elements as an array of names and values.\n *\n * @category Forms\n * @example\n *\n * ```js\n * $('<form><input name=\"foo\" value=\"bar\" /></form>').serializeArray();\n * //=> [ { name: 'foo', value: 'bar' } ]\n * ```\n *\n * @returns The serialized form.\n * @see {@link https://api.jquery.com/serializeArray/}\n */\nfunction serializeArray() {\n    var _this = this;\n    // Resolve all form elements from either forms or collections of form elements\n    return this.map(function (_, elem) {\n        var $elem = _this._make(elem);\n        if (utils_1.isTag(elem) && elem.name === 'form') {\n            return $elem.find(submittableSelector).toArray();\n        }\n        return $elem.filter(submittableSelector).toArray();\n    })\n        .filter(\n    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)\n    '[name!=\"\"]:enabled' +\n        // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)\n        ':not(:submit, :button, :image, :reset, :file)' +\n        // And are either checked/don't have a checkable state\n        ':matches([checked], :not(:checkbox, :radio))'\n    // Convert each of the elements to its value(s)\n    )\n        .map(function (_, elem) {\n        var _a;\n        var $elem = _this._make(elem);\n        var name = $elem.attr('name'); // We have filtered for elements with a name before.\n        // If there is no value set (e.g. `undefined`, `null`), then default value to empty\n        var value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : '';\n        // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs\n        if (Array.isArray(value)) {\n            return value.map(function (val) {\n                /*\n                 * We trim replace any line endings (e.g. `\\r` or `\\r\\n` with `\\r\\n`) to guarantee consistency across platforms\n                 * These can occur inside of `<textarea>'s`\n                 */\n                return ({ name: name, value: val.replace(rCRLF, '\\r\\n') });\n            });\n        }\n        // Otherwise (e.g. `<input type=\"text\">`, return only one key/value pair\n        return { name: name, value: value.replace(rCRLF, '\\r\\n') };\n    })\n        .toArray();\n}\nexports.serializeArray = serializeArray;\n","exports = module.exports = debug;\n\nfunction debug(label) {\n  return _debug.bind(null, label);\n}\n\nfunction _debug(label) {\n  var args = [].slice.call(arguments, 1);\n  args.unshift('[' + label + ']');\n  process.stderr.write(args.join(' ') + '\\n');\n}","var DEBUG = false; // `true` to print debugging info.\nvar TIMER = false; // `true` to time calls to `lex()` and print the results.\n\nvar debug = require('./debug')('lex');\n\nexports = module.exports = lex;\n\n/**\n * Convert a CSS string into an array of lexical tokens.\n *\n * @param {String} css CSS\n * @returns {Array} lexical tokens\n */\nfunction lex(css) {\n  var start; // Debug timer start.\n\n  var buffer = '';      // Character accumulator\n  var ch;               // Current character\n  var column = 0;       // Current source column number\n  var cursor = -1;      // Current source cursor position\n  var depth = 0;        // Current nesting depth\n  var line = 1;         // Current source line number\n  var state = 'before-selector'; // Current state\n  var stack = [state];  // State stack\n  var token = {};       // Current token\n  var tokens = [];      // Token accumulator\n\n  // Supported @-rules, in roughly descending order of usage probability.\n  var atRules = [\n    'media',\n    'keyframes',\n    { name: '-webkit-keyframes', type: 'keyframes', prefix: '-webkit-' },\n    { name: '-moz-keyframes', type: 'keyframes', prefix: '-moz-' },\n    { name: '-ms-keyframes', type: 'keyframes', prefix: '-ms-' },\n    { name: '-o-keyframes', type: 'keyframes', prefix: '-o-' },\n    'font-face',\n    { name: 'import', state: 'before-at-value' },\n    { name: 'charset', state: 'before-at-value' },\n    'supports',\n    'viewport',\n    { name: 'namespace', state: 'before-at-value' },\n    'document',\n    { name: '-moz-document', type: 'document', prefix: '-moz-' },\n    'page'\n  ];\n\n  // -- Functions ------------------------------------------------------------\n\n  /**\n   * Advance the character cursor and return the next character.\n   *\n   * @returns {String} The next character.\n   */\n  function getCh() {\n    skip();\n    return css[cursor];\n  }\n\n  /**\n   * Return the state at the given index in the stack.\n   * The stack is LIFO so indexing is from the right.\n   *\n   * @param {Number} [index=0] Index to return.\n   * @returns {String} state\n   */\n  function getState(index) {\n    return index ? stack[stack.length - 1 - index] : state;\n  }\n\n  /**\n   * Look ahead for a string beginning from the next position. The string\n   * being looked for must start at the next position.\n   *\n   * @param {String} str The string to look for.\n   * @returns {Boolean} Whether the string was found.\n   */\n  function isNextString(str) {\n    var start = cursor + 1;\n    return (str === css.slice(start, start + str.length));\n  }\n\n  /**\n   * Find the start position of a substring beginning from the next\n   * position. The string being looked for may begin anywhere.\n   *\n   * @param {String} str The substring to look for.\n   * @returns {Number|false} The position, or `false` if not found.\n   */\n  function find(str) {\n    var pos = css.slice(cursor).indexOf(str);\n\n    return pos > 0 ? pos : false;\n  }\n\n  /**\n   * Determine whether a character is next.\n   *\n   * @param {String} ch Character.\n   * @returns {Boolean} Whether the character is next.\n   */\n  function isNextChar(ch) {\n    return ch === peek(1);\n  }\n\n  /**\n   * Return the character at the given cursor offset. The offset is relative\n   * to the cursor, so negative values move backwards.\n   *\n   * @param {Number} [offset=1] Cursor offset.\n   * @returns {String} Character.\n   */\n  function peek(offset) {\n    return css[cursor + (offset || 1)];\n  }\n\n  /**\n   * Remove the current state from the stack and set the new current state.\n   *\n   * @returns {String} The removed state.\n   */\n  function popState() {\n    var removed = stack.pop();\n    state = stack[stack.length - 1];\n\n    return removed;\n  }\n\n  /**\n   * Set the current state and add it to the stack.\n   *\n   * @param {String} newState The new state.\n   * @returns {Number} The new stack length.\n   */\n  function pushState(newState) {\n    state = newState;\n    stack.push(state);\n\n    return stack.length;\n  }\n\n  /**\n   * Replace the current state with a new state.\n   *\n   * @param {String} newState The new state.\n   * @returns {String} The replaced state.\n   */\n  function replaceState(newState) {\n    var previousState = state;\n    stack[stack.length - 1] = state = newState;\n\n    return previousState;\n  }\n\n  /**\n   * Move the character cursor. Positive numbers move the cursor forward.\n   * Negative numbers are not supported!\n   *\n   * @param {Number} [n=1] Number of characters to skip.\n   */\n  function skip(n) {\n    if ((n || 1) == 1) {\n      if (css[cursor] == '\\n') {\n        line++;\n        column = 1;\n      } else {\n        column++;\n      }\n      cursor++;\n    } else {\n      var skipStr = css.slice(cursor, cursor + n).split('\\n');\n      if (skipStr.length > 1) {\n        line += skipStr.length - 1;\n        column = 1;\n      }\n      column += skipStr[skipStr.length - 1].length;\n      cursor = cursor + n;\n    }\n  }\n\n  /**\n   * Add the current token to the pile and reset the buffer.\n   */\n  function addToken() {\n    token.end = {\n      line: line,\n      col: column\n    };\n\n    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));\n\n    tokens.push(token);\n\n    buffer = '';\n    token = {};\n  }\n\n  /**\n   * Set the current token.\n   *\n   * @param {String} type Token type.\n   */\n  function initializeToken(type) {\n    token = {\n      type: type,\n      start: {\n        line: line,\n        col : column\n      }\n    };\n  }\n\n  // -- Main Loop ------------------------------------------------------------\n\n  /*\n  The main loop is a state machine that reads in one character at a time,\n  and determines what to do based on the current state and character.\n  This is implemented as a series of nested `switch` statements and the\n  case orders have been mildly optimized based on rough probabilities\n  calculated by processing a small sample of real-world CSS.\n\n  Further optimization (such as a dispatch table) shouldn't be necessary\n  since the total number of cases is very low.\n  */\n\n  TIMER && (start = Date.now());\n\n  while (ch = getCh()) {\n    DEBUG && debug(ch, getState());\n\n    // column += 1;\n\n    switch (ch) {\n    // Space\n    case ' ':\n      switch (getState()) {\n      case 'selector':\n      case 'value':\n      case 'value-paren':\n      case 'at-group':\n      case 'at-value':\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        buffer += ch;\n        break;\n      }\n      break;\n\n    // Newline or tab\n    case '\\n':\n    case '\\t':\n    case '\\r':\n    case '\\f':\n      switch (getState()) {\n      case 'value':\n      case 'value-paren':\n      case 'at-group':\n      case 'comment':\n      case 'single-string':\n      case 'double-string':\n      case 'selector':\n        buffer += ch;\n        break;\n\n      case 'at-value':\n        // Tokenize an @-rule if a semi-colon was omitted.\n        if ('\\n' === ch) {\n          token.value = buffer.trim();\n          addToken();\n          popState();\n        }\n        break;\n      }\n\n      // if ('\\n' === ch) {\n      //   column = 0;\n      //   line += 1;\n      // }\n      break;\n\n    case ':':\n      switch (getState()) {\n      case 'name':\n        token.name = buffer.trim();\n        buffer = '';\n\n        replaceState('before-value');\n        break;\n\n      case 'before-selector':\n        buffer += ch;\n\n        initializeToken('selector');\n        pushState('selector');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n\n      default:\n        buffer += ch;\n        break;\n      }\n      break;\n\n    case ';':\n      switch (getState()) {\n      case 'name':\n      case 'before-value':\n      case 'value':\n        // Tokenize a declaration\n        // if value is empty skip the declaration\n        if (buffer.trim().length > 0) {\n          token.value = buffer.trim(),\n          addToken();\n        }\n        replaceState('before-name');\n        break;\n\n      case 'value-paren':\n        // Insignificant semi-colon\n        buffer += ch;\n        break;\n\n      case 'at-value':\n        // Tokenize an @-rule\n        token.value = buffer.trim();\n        addToken();\n        popState();\n        break;\n\n      case 'before-name':\n        // Extraneous semi-colon\n        break;\n\n      default:\n        buffer += ch;\n        break;\n      }\n      break;\n\n    case '{':\n      switch (getState()) {\n      case 'selector':\n        // If the sequence is `\\{` then assume that the brace should be escaped.\n        if (peek(-1) === '\\\\') {\n            buffer += ch;\n            break;\n        }\n\n        // Tokenize a selector\n        token.text = buffer.trim();\n        addToken();\n        replaceState('before-name');\n        depth = depth + 1;\n        break;\n\n      case 'at-group':\n        // Tokenize an @-group\n        token.name = buffer.trim();\n\n        // XXX: @-rules are starting to get hairy\n        switch (token.type) {\n        case 'font-face':\n        case 'viewport' :\n        case 'page'     :\n          pushState('before-name');\n          break;\n\n        default:\n          pushState('before-selector');\n        }\n\n        addToken();\n        depth = depth + 1;\n        break;\n\n      case 'name':\n      case 'at-rule':\n        // Tokenize a declaration or an @-rule\n        token.name = buffer.trim();\n        addToken();\n        pushState('before-name');\n        depth = depth + 1;\n        break;\n\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        // Ignore braces in comments and strings\n        buffer += ch;\n        break;\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n      }\n\n      break;\n\n    case '}':\n      switch (getState()) {\n      case 'before-name':\n      case 'name':\n      case 'before-value':\n      case 'value':\n        // If the buffer contains anything, it is a value\n        if (buffer) {\n          token.value = buffer.trim();\n        }\n\n        // If the current token has a name and a value it should be tokenized.\n        if (token.name && token.value) {\n          addToken();\n        }\n\n        // Leave the block\n        initializeToken('end');\n        addToken();\n        popState();\n\n        // We might need to leave again.\n        // XXX: What about 3 levels deep?\n        if ('at-group' === getState()) {\n          initializeToken('at-group-end');\n          addToken();\n          popState();\n        }\n        \n        if (depth > 0) {\n          depth = depth - 1;\n        }\n\n        break;\n\n      case 'at-group':\n      case 'before-selector':\n      case 'selector':\n        // If the sequence is `\\}` then assume that the brace should be escaped.\n        if (peek(-1) === '\\\\') {\n            buffer += ch;\n            break;\n        }\n\n        if (depth > 0) {\n          // Leave block if in an at-group\n          if ('at-group' === getState(1)) {\n            initializeToken('at-group-end');\n            addToken();\n          }\n        }\n\n        if (depth > 1) {\n          popState();\n        }\n\n        if (depth > 0) {\n          depth = depth - 1;\n        }\n        break;\n\n      case 'double-string':\n      case 'single-string':\n      case 'comment':\n        // Ignore braces in comments and strings.\n        buffer += ch;\n        break;\n      }\n\n      break;\n\n    // Strings\n    case '\"':\n    case \"'\":\n      switch (getState()) {\n      case 'double-string':\n        if ('\"' === ch && '\\\\' !== peek(-1)) {\n          popState();\n        }\n        break;\n\n      case 'single-string':\n        if (\"'\" === ch && '\\\\' !== peek(-1)) {\n          popState();\n        }\n        break;\n\n      case 'before-at-value':\n        replaceState('at-value');\n        pushState('\"' === ch ? 'double-string' : 'single-string');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        pushState('\"' === ch ? 'double-string' : 'single-string');\n        break;\n\n      case 'comment':\n        // Ignore strings within comments.\n        break;\n\n      default:\n        if ('\\\\' !== peek(-1)) {\n          pushState('\"' === ch ? 'double-string' : 'single-string');\n        }\n      }\n\n      buffer += ch;\n      break;\n\n    // Comments\n    case '/':\n      switch (getState()) {\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        // Ignore\n        buffer += ch;\n        break;\n\n      case 'before-value':\n      case 'selector':\n      case 'name':\n      case 'value':\n        if (isNextChar('*')) {\n          // Ignore comments in selectors, properties and values. They are\n          // difficult to represent in the AST.\n          var pos = find('*/');\n\n          if (pos) {\n            skip(pos + 1);\n          }\n        } else {\n          if (getState() == 'before-value') replaceState('value');\n          buffer += ch;\n        }\n        break;\n\n      default:\n        if (isNextChar('*')) {\n          // Create a comment token\n          initializeToken('comment');\n          pushState('comment');\n          skip();\n        }\n        else {\n          buffer += ch;\n        }\n        break;\n      }\n      break;\n\n    // Comment end or universal selector\n    case '*':\n      switch (getState()) {\n      case 'comment':\n        if (isNextChar('/')) {\n          // Tokenize a comment\n          token.text = buffer; // Don't trim()!\n          skip();\n          addToken();\n          popState();\n        }\n        else {\n          buffer += ch;\n        }\n        break;\n\n      case 'before-selector':\n        buffer += ch;\n        initializeToken('selector');\n        pushState('selector');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n\n      default:\n        buffer += ch;\n      }\n      break;\n\n    // @-rules\n    case '@':\n      switch (getState()) {\n      case 'comment':\n      case 'double-string':\n      case 'single-string':\n        buffer += ch;\n        break;\n      case 'before-value':\n        replaceState('value');\n        buffer += ch;\n        break;\n\n      default:\n        // Iterate over the supported @-rules and attempt to tokenize one.\n        var tokenized = false;\n        var name;\n        var rule;\n\n        for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {\n          rule = atRules[j];\n          name = rule.name || rule;\n\n          if (!isNextString(name)) { continue; }\n\n          tokenized = true;\n\n          initializeToken(name);\n          pushState(rule.state || 'at-group');\n          skip(name.length);\n\n          if (rule.prefix) {\n            token.prefix = rule.prefix;\n          }\n\n          if (rule.type) {\n            token.type = rule.type;\n          }\n        }\n\n        if (!tokenized) {\n          // Keep on truckin' America!\n          buffer += ch;\n        }\n        break;\n      }\n      break;\n\n    // Parentheses are tracked to disambiguate semi-colons, such as within a\n    // data URI.\n    case '(':\n      switch (getState()) {\n      case 'value':\n        pushState('value-paren');\n        break;\n      case 'before-value':\n        replaceState('value');\n        break;\n      }\n\n      buffer += ch;\n      break;\n\n    case ')':\n      switch (getState()) {\n      case 'value-paren':\n        popState();\n        break;\n      case 'before-value':\n        replaceState('value');\n        break;\n      }\n\n      buffer += ch;\n      break;\n\n    default:\n      switch (getState()) {\n      case 'before-selector':\n        initializeToken('selector');\n        pushState('selector');\n        break;\n\n      case 'before-name':\n        initializeToken('property');\n        replaceState('name');\n        break;\n\n      case 'before-value':\n        replaceState('value');\n        break;\n\n      case 'before-at-value':\n        replaceState('at-value');\n        break;\n      }\n\n      buffer += ch;\n      break;\n    }\n  }\n\n  TIMER && debug('ran in', (Date.now() - start) + 'ms');\n\n  return tokens;\n}\n"],"file":"assets/PlateEditorOriginal-BsOvDUtH.js"}