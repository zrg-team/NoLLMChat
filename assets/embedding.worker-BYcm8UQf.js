function o_(oe){return oe&&oe.__esModule&&Object.prototype.hasOwnProperty.call(oe,"default")?oe.default:oe}var _m={exports:{}},an=_m.exports={},ci,pi;function Wp(){throw new Error("setTimeout has not been defined")}function Gp(){throw new Error("clearTimeout has not been defined")}(function(){try{typeof setTimeout=="function"?ci=setTimeout:ci=Wp}catch{ci=Wp}try{typeof clearTimeout=="function"?pi=clearTimeout:pi=Gp}catch{pi=Gp}})();function wm(oe){if(ci===setTimeout)return setTimeout(oe,0);if((ci===Wp||!ci)&&setTimeout)return ci=setTimeout,setTimeout(oe,0);try{return ci(oe,0)}catch{try{return ci.call(null,oe,0)}catch{return ci.call(this,oe,0)}}}function a_(oe){if(pi===clearTimeout)return clearTimeout(oe);if((pi===Gp||!pi)&&clearTimeout)return pi=clearTimeout,clearTimeout(oe);try{return pi(oe)}catch{try{return pi.call(null,oe)}catch{return pi.call(this,oe)}}}var $i=[],aa=!1,Cs,Lc=-1;function l_(){!aa||!Cs||(aa=!1,Cs.length?$i=Cs.concat($i):Lc=-1,$i.length&&ym())}function ym(){if(!aa){var oe=wm(l_);aa=!0;for(var R=$i.length;R;){for(Cs=$i,$i=[];++Lc<R;)Cs&&Cs[Lc].run();Lc=-1,R=$i.length}Cs=null,aa=!1,a_(oe)}}an.nextTick=function(oe){var R=new Array(arguments.length-1);if(arguments.length>1)for(var T=1;T<arguments.length;T++)R[T-1]=arguments[T];$i.push(new bm(oe,R)),$i.length===1&&!aa&&wm(ym)};function bm(oe,R){this.fun=oe,this.array=R}bm.prototype.run=function(){this.fun.apply(null,this.array)};an.title="browser";an.browser=!0;an.env={};an.argv=[];an.version="";an.versions={};function Si(){}an.on=Si;an.addListener=Si;an.once=Si;an.off=Si;an.removeListener=Si;an.removeAllListeners=Si;an.emit=Si;an.prependListener=Si;an.prependOnceListener=Si;an.listeners=function(oe){return[]};an.binding=function(oe){throw new Error("process.binding is not supported")};an.cwd=function(){return"/"};an.chdir=function(oe){throw new Error("process.chdir is not supported")};an.umask=function(){return 0};var u_=_m.exports;const Es=o_(u_);var Mm={},Vc={};Vc.byteLength=p_;Vc.toByteArray=f_;Vc.fromByteArray=__;var fi=[],Kn=[],d_=typeof Uint8Array<"u"?Uint8Array:Array,Rp="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var sa=0,c_=Rp.length;sa<c_;++sa)fi[sa]=Rp[sa],Kn[Rp.charCodeAt(sa)]=sa;Kn[45]=62;Kn[95]=63;function vm(oe){var R=oe.length;if(R%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var T=oe.indexOf("=");T===-1&&(T=R);var E=T===R?0:4-T%4;return[T,E]}function p_(oe){var R=vm(oe),T=R[0],E=R[1];return(T+E)*3/4-E}function h_(oe,R,T){return(R+T)*3/4-T}function f_(oe){var R,T=vm(oe),E=T[0],Z=T[1],re=new d_(h_(oe,E,Z)),fe=0,Ee=Z>0?E-4:E,j;for(j=0;j<Ee;j+=4)R=Kn[oe.charCodeAt(j)]<<18|Kn[oe.charCodeAt(j+1)]<<12|Kn[oe.charCodeAt(j+2)]<<6|Kn[oe.charCodeAt(j+3)],re[fe++]=R>>16&255,re[fe++]=R>>8&255,re[fe++]=R&255;return Z===2&&(R=Kn[oe.charCodeAt(j)]<<2|Kn[oe.charCodeAt(j+1)]>>4,re[fe++]=R&255),Z===1&&(R=Kn[oe.charCodeAt(j)]<<10|Kn[oe.charCodeAt(j+1)]<<4|Kn[oe.charCodeAt(j+2)]>>2,re[fe++]=R>>8&255,re[fe++]=R&255),re}function m_(oe){return fi[oe>>18&63]+fi[oe>>12&63]+fi[oe>>6&63]+fi[oe&63]}function g_(oe,R,T){for(var E,Z=[],re=R;re<T;re+=3)E=(oe[re]<<16&16711680)+(oe[re+1]<<8&65280)+(oe[re+2]&255),Z.push(m_(E));return Z.join("")}function __(oe){for(var R,T=oe.length,E=T%3,Z=[],re=16383,fe=0,Ee=T-E;fe<Ee;fe+=re)Z.push(g_(oe,fe,fe+re>Ee?Ee:fe+re));return E===1?(R=oe[T-1],Z.push(fi[R>>2]+fi[R<<4&63]+"==")):E===2&&(R=(oe[T-2]<<8)+oe[T-1],Z.push(fi[R>>10]+fi[R>>4&63]+fi[R<<2&63]+"=")),Z.join("")}var Xp={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */Xp.read=function(oe,R,T,E,Z){var re,fe,Ee=Z*8-E-1,j=(1<<Ee)-1,O=j>>1,M=-7,N=T?Z-1:0,K=T?-1:1,ae=oe[R+N];for(N+=K,re=ae&(1<<-M)-1,ae>>=-M,M+=Ee;M>0;re=re*256+oe[R+N],N+=K,M-=8);for(fe=re&(1<<-M)-1,re>>=-M,M+=E;M>0;fe=fe*256+oe[R+N],N+=K,M-=8);if(re===0)re=1-O;else{if(re===j)return fe?NaN:(ae?-1:1)*(1/0);fe=fe+Math.pow(2,E),re=re-O}return(ae?-1:1)*fe*Math.pow(2,re-E)};Xp.write=function(oe,R,T,E,Z,re){var fe,Ee,j,O=re*8-Z-1,M=(1<<O)-1,N=M>>1,K=Z===23?Math.pow(2,-24)-Math.pow(2,-77):0,ae=E?0:re-1,$e=E?1:-1,Te=R<0||R===0&&1/R<0?1:0;for(R=Math.abs(R),isNaN(R)||R===1/0?(Ee=isNaN(R)?1:0,fe=M):(fe=Math.floor(Math.log(R)/Math.LN2),R*(j=Math.pow(2,-fe))<1&&(fe--,j*=2),fe+N>=1?R+=K/j:R+=K*Math.pow(2,1-N),R*j>=2&&(fe++,j/=2),fe+N>=M?(Ee=0,fe=M):fe+N>=1?(Ee=(R*j-1)*Math.pow(2,Z),fe=fe+N):(Ee=R*Math.pow(2,N-1)*Math.pow(2,Z),fe=0));Z>=8;oe[T+ae]=Ee&255,ae+=$e,Ee/=256,Z-=8);for(fe=fe<<Z|Ee,O+=Z;O>0;oe[T+ae]=fe&255,ae+=$e,fe/=256,O-=8);oe[T+ae-$e]|=Te*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(oe){const R=Vc,T=Xp,E=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;oe.Buffer=M,oe.SlowBuffer=q,oe.INSPECT_MAX_BYTES=50;const Z=2147483647;oe.kMaxLength=Z;const{Uint8Array:re,ArrayBuffer:fe,SharedArrayBuffer:Ee}=globalThis;M.TYPED_ARRAY_SUPPORT=j(),!M.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function j(){try{const C=new re(1),c={foo:function(){return 42}};return Object.setPrototypeOf(c,re.prototype),Object.setPrototypeOf(C,c),C.foo()===42}catch{return!1}}Object.defineProperty(M.prototype,"parent",{enumerable:!0,get:function(){if(M.isBuffer(this))return this.buffer}}),Object.defineProperty(M.prototype,"offset",{enumerable:!0,get:function(){if(M.isBuffer(this))return this.byteOffset}});function O(C){if(C>Z)throw new RangeError('The value "'+C+'" is invalid for option "size"');const c=new re(C);return Object.setPrototypeOf(c,M.prototype),c}function M(C,c,m){if(typeof C=="number"){if(typeof c=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return $e(C)}return N(C,c,m)}M.poolSize=8192;function N(C,c,m){if(typeof C=="string")return Te(C,c);if(fe.isView(C))return ue(C);if(C==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof C);if(dt(C,fe)||C&&dt(C.buffer,fe)||typeof Ee<"u"&&(dt(C,Ee)||C&&dt(C.buffer,Ee)))return ke(C,c,m);if(typeof C=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const W=C.valueOf&&C.valueOf();if(W!=null&&W!==C)return M.from(W,c,m);const we=te(C);if(we)return we;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof C[Symbol.toPrimitive]=="function")return M.from(C[Symbol.toPrimitive]("string"),c,m);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof C)}M.from=function(C,c,m){return N(C,c,m)},Object.setPrototypeOf(M.prototype,re.prototype),Object.setPrototypeOf(M,re);function K(C){if(typeof C!="number")throw new TypeError('"size" argument must be of type number');if(C<0)throw new RangeError('The value "'+C+'" is invalid for option "size"')}function ae(C,c,m){return K(C),C<=0?O(C):c!==void 0?typeof m=="string"?O(C).fill(c,m):O(C).fill(c):O(C)}M.alloc=function(C,c,m){return ae(C,c,m)};function $e(C){return K(C),O(C<0?0:ee(C)|0)}M.allocUnsafe=function(C){return $e(C)},M.allocUnsafeSlow=function(C){return $e(C)};function Te(C,c){if((typeof c!="string"||c==="")&&(c="utf8"),!M.isEncoding(c))throw new TypeError("Unknown encoding: "+c);const m=B(C,c)|0;let W=O(m);const we=W.write(C,c);return we!==m&&(W=W.slice(0,we)),W}function U(C){const c=C.length<0?0:ee(C.length)|0,m=O(c);for(let W=0;W<c;W+=1)m[W]=C[W]&255;return m}function ue(C){if(dt(C,re)){const c=new re(C);return ke(c.buffer,c.byteOffset,c.byteLength)}return U(C)}function ke(C,c,m){if(c<0||C.byteLength<c)throw new RangeError('"offset" is outside of buffer bounds');if(C.byteLength<c+(m||0))throw new RangeError('"length" is outside of buffer bounds');let W;return c===void 0&&m===void 0?W=new re(C):m===void 0?W=new re(C,c):W=new re(C,c,m),Object.setPrototypeOf(W,M.prototype),W}function te(C){if(M.isBuffer(C)){const c=ee(C.length)|0,m=O(c);return m.length===0||C.copy(m,0,0,c),m}if(C.length!==void 0)return typeof C.length!="number"||at(C.length)?O(0):U(C);if(C.type==="Buffer"&&Array.isArray(C.data))return U(C.data)}function ee(C){if(C>=Z)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+Z.toString(16)+" bytes");return C|0}function q(C){return+C!=C&&(C=0),M.alloc(+C)}M.isBuffer=function(c){return c!=null&&c._isBuffer===!0&&c!==M.prototype},M.compare=function(c,m){if(dt(c,re)&&(c=M.from(c,c.offset,c.byteLength)),dt(m,re)&&(m=M.from(m,m.offset,m.byteLength)),!M.isBuffer(c)||!M.isBuffer(m))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(c===m)return 0;let W=c.length,we=m.length;for(let Fe=0,Xe=Math.min(W,we);Fe<Xe;++Fe)if(c[Fe]!==m[Fe]){W=c[Fe],we=m[Fe];break}return W<we?-1:we<W?1:0},M.isEncoding=function(c){switch(String(c).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},M.concat=function(c,m){if(!Array.isArray(c))throw new TypeError('"list" argument must be an Array of Buffers');if(c.length===0)return M.alloc(0);let W;if(m===void 0)for(m=0,W=0;W<c.length;++W)m+=c[W].length;const we=M.allocUnsafe(m);let Fe=0;for(W=0;W<c.length;++W){let Xe=c[W];if(dt(Xe,re))Fe+Xe.length>we.length?(M.isBuffer(Xe)||(Xe=M.from(Xe)),Xe.copy(we,Fe)):re.prototype.set.call(we,Xe,Fe);else if(M.isBuffer(Xe))Xe.copy(we,Fe);else throw new TypeError('"list" argument must be an Array of Buffers');Fe+=Xe.length}return we};function B(C,c){if(M.isBuffer(C))return C.length;if(fe.isView(C)||dt(C,fe))return C.byteLength;if(typeof C!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof C);const m=C.length,W=arguments.length>2&&arguments[2]===!0;if(!W&&m===0)return 0;let we=!1;for(;;)switch(c){case"ascii":case"latin1":case"binary":return m;case"utf8":case"utf-8":return $(C).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return m*2;case"hex":return m>>>1;case"base64":return pe(C).length;default:if(we)return W?-1:$(C).length;c=(""+c).toLowerCase(),we=!0}}M.byteLength=B;function H(C,c,m){let W=!1;if((c===void 0||c<0)&&(c=0),c>this.length||((m===void 0||m>this.length)&&(m=this.length),m<=0)||(m>>>=0,c>>>=0,m<=c))return"";for(C||(C="utf8");;)switch(C){case"hex":return nt(this,c,m);case"utf8":case"utf-8":return ie(this,c,m);case"ascii":return _e(this,c,m);case"latin1":case"binary":return Oe(this,c,m);case"base64":return Ae(this,c,m);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return de(this,c,m);default:if(W)throw new TypeError("Unknown encoding: "+C);C=(C+"").toLowerCase(),W=!0}}M.prototype._isBuffer=!0;function I(C,c,m){const W=C[c];C[c]=C[m],C[m]=W}M.prototype.swap16=function(){const c=this.length;if(c%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let m=0;m<c;m+=2)I(this,m,m+1);return this},M.prototype.swap32=function(){const c=this.length;if(c%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let m=0;m<c;m+=4)I(this,m,m+3),I(this,m+1,m+2);return this},M.prototype.swap64=function(){const c=this.length;if(c%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let m=0;m<c;m+=8)I(this,m,m+7),I(this,m+1,m+6),I(this,m+2,m+5),I(this,m+3,m+4);return this},M.prototype.toString=function(){const c=this.length;return c===0?"":arguments.length===0?ie(this,0,c):H.apply(this,arguments)},M.prototype.toLocaleString=M.prototype.toString,M.prototype.equals=function(c){if(!M.isBuffer(c))throw new TypeError("Argument must be a Buffer");return this===c?!0:M.compare(this,c)===0},M.prototype.inspect=function(){let c="";const m=oe.INSPECT_MAX_BYTES;return c=this.toString("hex",0,m).replace(/(.{2})/g,"$1 ").trim(),this.length>m&&(c+=" ... "),"<Buffer "+c+">"},E&&(M.prototype[E]=M.prototype.inspect),M.prototype.compare=function(c,m,W,we,Fe){if(dt(c,re)&&(c=M.from(c,c.offset,c.byteLength)),!M.isBuffer(c))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof c);if(m===void 0&&(m=0),W===void 0&&(W=c?c.length:0),we===void 0&&(we=0),Fe===void 0&&(Fe=this.length),m<0||W>c.length||we<0||Fe>this.length)throw new RangeError("out of range index");if(we>=Fe&&m>=W)return 0;if(we>=Fe)return-1;if(m>=W)return 1;if(m>>>=0,W>>>=0,we>>>=0,Fe>>>=0,this===c)return 0;let Xe=Fe-we,sr=W-m;const ot=Math.min(Xe,sr),V=this.slice(we,Fe),ve=c.slice(m,W);for(let Ie=0;Ie<ot;++Ie)if(V[Ie]!==ve[Ie]){Xe=V[Ie],sr=ve[Ie];break}return Xe<sr?-1:sr<Xe?1:0};function Me(C,c,m,W,we){if(C.length===0)return-1;if(typeof m=="string"?(W=m,m=0):m>2147483647?m=2147483647:m<-2147483648&&(m=-2147483648),m=+m,at(m)&&(m=we?0:C.length-1),m<0&&(m=C.length+m),m>=C.length){if(we)return-1;m=C.length-1}else if(m<0)if(we)m=0;else return-1;if(typeof c=="string"&&(c=M.from(c,W)),M.isBuffer(c))return c.length===0?-1:xe(C,c,m,W,we);if(typeof c=="number")return c=c&255,typeof re.prototype.indexOf=="function"?we?re.prototype.indexOf.call(C,c,m):re.prototype.lastIndexOf.call(C,c,m):xe(C,[c],m,W,we);throw new TypeError("val must be string, number or Buffer")}function xe(C,c,m,W,we){let Fe=1,Xe=C.length,sr=c.length;if(W!==void 0&&(W=String(W).toLowerCase(),W==="ucs2"||W==="ucs-2"||W==="utf16le"||W==="utf-16le")){if(C.length<2||c.length<2)return-1;Fe=2,Xe/=2,sr/=2,m/=2}function ot(ve,Ie){return Fe===1?ve[Ie]:ve.readUInt16BE(Ie*Fe)}let V;if(we){let ve=-1;for(V=m;V<Xe;V++)if(ot(C,V)===ot(c,ve===-1?0:V-ve)){if(ve===-1&&(ve=V),V-ve+1===sr)return ve*Fe}else ve!==-1&&(V-=V-ve),ve=-1}else for(m+sr>Xe&&(m=Xe-sr),V=m;V>=0;V--){let ve=!0;for(let Ie=0;Ie<sr;Ie++)if(ot(C,V+Ie)!==ot(c,Ie)){ve=!1;break}if(ve)return V}return-1}M.prototype.includes=function(c,m,W){return this.indexOf(c,m,W)!==-1},M.prototype.indexOf=function(c,m,W){return Me(this,c,m,W,!0)},M.prototype.lastIndexOf=function(c,m,W){return Me(this,c,m,W,!1)};function Ce(C,c,m,W){m=Number(m)||0;const we=C.length-m;W?(W=Number(W),W>we&&(W=we)):W=we;const Fe=c.length;W>Fe/2&&(W=Fe/2);let Xe;for(Xe=0;Xe<W;++Xe){const sr=parseInt(c.substr(Xe*2,2),16);if(at(sr))return Xe;C[m+Xe]=sr}return Xe}function Ve(C,c,m,W){return Se($(c,C.length-m),C,m,W)}function Ue(C,c,m,W){return Se(J(c),C,m,W)}function Ne(C,c,m,W){return Se(pe(c),C,m,W)}function Pe(C,c,m,W){return Se(z(c,C.length-m),C,m,W)}M.prototype.write=function(c,m,W,we){if(m===void 0)we="utf8",W=this.length,m=0;else if(W===void 0&&typeof m=="string")we=m,W=this.length,m=0;else if(isFinite(m))m=m>>>0,isFinite(W)?(W=W>>>0,we===void 0&&(we="utf8")):(we=W,W=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const Fe=this.length-m;if((W===void 0||W>Fe)&&(W=Fe),c.length>0&&(W<0||m<0)||m>this.length)throw new RangeError("Attempt to write outside buffer bounds");we||(we="utf8");let Xe=!1;for(;;)switch(we){case"hex":return Ce(this,c,m,W);case"utf8":case"utf-8":return Ve(this,c,m,W);case"ascii":case"latin1":case"binary":return Ue(this,c,m,W);case"base64":return Ne(this,c,m,W);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Pe(this,c,m,W);default:if(Xe)throw new TypeError("Unknown encoding: "+we);we=(""+we).toLowerCase(),Xe=!0}},M.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Ae(C,c,m){return c===0&&m===C.length?R.fromByteArray(C):R.fromByteArray(C.slice(c,m))}function ie(C,c,m){m=Math.min(C.length,m);const W=[];let we=c;for(;we<m;){const Fe=C[we];let Xe=null,sr=Fe>239?4:Fe>223?3:Fe>191?2:1;if(we+sr<=m){let ot,V,ve,Ie;switch(sr){case 1:Fe<128&&(Xe=Fe);break;case 2:ot=C[we+1],(ot&192)===128&&(Ie=(Fe&31)<<6|ot&63,Ie>127&&(Xe=Ie));break;case 3:ot=C[we+1],V=C[we+2],(ot&192)===128&&(V&192)===128&&(Ie=(Fe&15)<<12|(ot&63)<<6|V&63,Ie>2047&&(Ie<55296||Ie>57343)&&(Xe=Ie));break;case 4:ot=C[we+1],V=C[we+2],ve=C[we+3],(ot&192)===128&&(V&192)===128&&(ve&192)===128&&(Ie=(Fe&15)<<18|(ot&63)<<12|(V&63)<<6|ve&63,Ie>65535&&Ie<1114112&&(Xe=Ie))}}Xe===null?(Xe=65533,sr=1):Xe>65535&&(Xe-=65536,W.push(Xe>>>10&1023|55296),Xe=56320|Xe&1023),W.push(Xe),we+=sr}return se(W)}const F=4096;function se(C){const c=C.length;if(c<=F)return String.fromCharCode.apply(String,C);let m="",W=0;for(;W<c;)m+=String.fromCharCode.apply(String,C.slice(W,W+=F));return m}function _e(C,c,m){let W="";m=Math.min(C.length,m);for(let we=c;we<m;++we)W+=String.fromCharCode(C[we]&127);return W}function Oe(C,c,m){let W="";m=Math.min(C.length,m);for(let we=c;we<m;++we)W+=String.fromCharCode(C[we]);return W}function nt(C,c,m){const W=C.length;(!c||c<0)&&(c=0),(!m||m<0||m>W)&&(m=W);let we="";for(let Fe=c;Fe<m;++Fe)we+=At[C[Fe]];return we}function de(C,c,m){const W=C.slice(c,m);let we="";for(let Fe=0;Fe<W.length-1;Fe+=2)we+=String.fromCharCode(W[Fe]+W[Fe+1]*256);return we}M.prototype.slice=function(c,m){const W=this.length;c=~~c,m=m===void 0?W:~~m,c<0?(c+=W,c<0&&(c=0)):c>W&&(c=W),m<0?(m+=W,m<0&&(m=0)):m>W&&(m=W),m<c&&(m=c);const we=this.subarray(c,m);return Object.setPrototypeOf(we,M.prototype),we};function Re(C,c,m){if(C%1!==0||C<0)throw new RangeError("offset is not uint");if(C+c>m)throw new RangeError("Trying to access beyond buffer length")}M.prototype.readUintLE=M.prototype.readUIntLE=function(c,m,W){c=c>>>0,m=m>>>0,W||Re(c,m,this.length);let we=this[c],Fe=1,Xe=0;for(;++Xe<m&&(Fe*=256);)we+=this[c+Xe]*Fe;return we},M.prototype.readUintBE=M.prototype.readUIntBE=function(c,m,W){c=c>>>0,m=m>>>0,W||Re(c,m,this.length);let we=this[c+--m],Fe=1;for(;m>0&&(Fe*=256);)we+=this[c+--m]*Fe;return we},M.prototype.readUint8=M.prototype.readUInt8=function(c,m){return c=c>>>0,m||Re(c,1,this.length),this[c]},M.prototype.readUint16LE=M.prototype.readUInt16LE=function(c,m){return c=c>>>0,m||Re(c,2,this.length),this[c]|this[c+1]<<8},M.prototype.readUint16BE=M.prototype.readUInt16BE=function(c,m){return c=c>>>0,m||Re(c,2,this.length),this[c]<<8|this[c+1]},M.prototype.readUint32LE=M.prototype.readUInt32LE=function(c,m){return c=c>>>0,m||Re(c,4,this.length),(this[c]|this[c+1]<<8|this[c+2]<<16)+this[c+3]*16777216},M.prototype.readUint32BE=M.prototype.readUInt32BE=function(c,m){return c=c>>>0,m||Re(c,4,this.length),this[c]*16777216+(this[c+1]<<16|this[c+2]<<8|this[c+3])},M.prototype.readBigUInt64LE=pt(function(c){c=c>>>0,_t(c,"offset");const m=this[c],W=this[c+7];(m===void 0||W===void 0)&&yt(c,this.length-8);const we=m+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24,Fe=this[++c]+this[++c]*2**8+this[++c]*2**16+W*2**24;return BigInt(we)+(BigInt(Fe)<<BigInt(32))}),M.prototype.readBigUInt64BE=pt(function(c){c=c>>>0,_t(c,"offset");const m=this[c],W=this[c+7];(m===void 0||W===void 0)&&yt(c,this.length-8);const we=m*2**24+this[++c]*2**16+this[++c]*2**8+this[++c],Fe=this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+W;return(BigInt(we)<<BigInt(32))+BigInt(Fe)}),M.prototype.readIntLE=function(c,m,W){c=c>>>0,m=m>>>0,W||Re(c,m,this.length);let we=this[c],Fe=1,Xe=0;for(;++Xe<m&&(Fe*=256);)we+=this[c+Xe]*Fe;return Fe*=128,we>=Fe&&(we-=Math.pow(2,8*m)),we},M.prototype.readIntBE=function(c,m,W){c=c>>>0,m=m>>>0,W||Re(c,m,this.length);let we=m,Fe=1,Xe=this[c+--we];for(;we>0&&(Fe*=256);)Xe+=this[c+--we]*Fe;return Fe*=128,Xe>=Fe&&(Xe-=Math.pow(2,8*m)),Xe},M.prototype.readInt8=function(c,m){return c=c>>>0,m||Re(c,1,this.length),this[c]&128?(255-this[c]+1)*-1:this[c]},M.prototype.readInt16LE=function(c,m){c=c>>>0,m||Re(c,2,this.length);const W=this[c]|this[c+1]<<8;return W&32768?W|4294901760:W},M.prototype.readInt16BE=function(c,m){c=c>>>0,m||Re(c,2,this.length);const W=this[c+1]|this[c]<<8;return W&32768?W|4294901760:W},M.prototype.readInt32LE=function(c,m){return c=c>>>0,m||Re(c,4,this.length),this[c]|this[c+1]<<8|this[c+2]<<16|this[c+3]<<24},M.prototype.readInt32BE=function(c,m){return c=c>>>0,m||Re(c,4,this.length),this[c]<<24|this[c+1]<<16|this[c+2]<<8|this[c+3]},M.prototype.readBigInt64LE=pt(function(c){c=c>>>0,_t(c,"offset");const m=this[c],W=this[c+7];(m===void 0||W===void 0)&&yt(c,this.length-8);const we=this[c+4]+this[c+5]*2**8+this[c+6]*2**16+(W<<24);return(BigInt(we)<<BigInt(32))+BigInt(m+this[++c]*2**8+this[++c]*2**16+this[++c]*2**24)}),M.prototype.readBigInt64BE=pt(function(c){c=c>>>0,_t(c,"offset");const m=this[c],W=this[c+7];(m===void 0||W===void 0)&&yt(c,this.length-8);const we=(m<<24)+this[++c]*2**16+this[++c]*2**8+this[++c];return(BigInt(we)<<BigInt(32))+BigInt(this[++c]*2**24+this[++c]*2**16+this[++c]*2**8+W)}),M.prototype.readFloatLE=function(c,m){return c=c>>>0,m||Re(c,4,this.length),T.read(this,c,!0,23,4)},M.prototype.readFloatBE=function(c,m){return c=c>>>0,m||Re(c,4,this.length),T.read(this,c,!1,23,4)},M.prototype.readDoubleLE=function(c,m){return c=c>>>0,m||Re(c,8,this.length),T.read(this,c,!0,52,8)},M.prototype.readDoubleBE=function(c,m){return c=c>>>0,m||Re(c,8,this.length),T.read(this,c,!1,52,8)};function it(C,c,m,W,we,Fe){if(!M.isBuffer(C))throw new TypeError('"buffer" argument must be a Buffer instance');if(c>we||c<Fe)throw new RangeError('"value" argument is out of bounds');if(m+W>C.length)throw new RangeError("Index out of range")}M.prototype.writeUintLE=M.prototype.writeUIntLE=function(c,m,W,we){if(c=+c,m=m>>>0,W=W>>>0,!we){const sr=Math.pow(2,8*W)-1;it(this,c,m,W,sr,0)}let Fe=1,Xe=0;for(this[m]=c&255;++Xe<W&&(Fe*=256);)this[m+Xe]=c/Fe&255;return m+W},M.prototype.writeUintBE=M.prototype.writeUIntBE=function(c,m,W,we){if(c=+c,m=m>>>0,W=W>>>0,!we){const sr=Math.pow(2,8*W)-1;it(this,c,m,W,sr,0)}let Fe=W-1,Xe=1;for(this[m+Fe]=c&255;--Fe>=0&&(Xe*=256);)this[m+Fe]=c/Xe&255;return m+W},M.prototype.writeUint8=M.prototype.writeUInt8=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,1,255,0),this[m]=c&255,m+1},M.prototype.writeUint16LE=M.prototype.writeUInt16LE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,2,65535,0),this[m]=c&255,this[m+1]=c>>>8,m+2},M.prototype.writeUint16BE=M.prototype.writeUInt16BE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,2,65535,0),this[m]=c>>>8,this[m+1]=c&255,m+2},M.prototype.writeUint32LE=M.prototype.writeUInt32LE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,4,4294967295,0),this[m+3]=c>>>24,this[m+2]=c>>>16,this[m+1]=c>>>8,this[m]=c&255,m+4},M.prototype.writeUint32BE=M.prototype.writeUInt32BE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,4,4294967295,0),this[m]=c>>>24,this[m+1]=c>>>16,this[m+2]=c>>>8,this[m+3]=c&255,m+4};function He(C,c,m,W,we){Qe(c,W,we,C,m,7);let Fe=Number(c&BigInt(4294967295));C[m++]=Fe,Fe=Fe>>8,C[m++]=Fe,Fe=Fe>>8,C[m++]=Fe,Fe=Fe>>8,C[m++]=Fe;let Xe=Number(c>>BigInt(32)&BigInt(4294967295));return C[m++]=Xe,Xe=Xe>>8,C[m++]=Xe,Xe=Xe>>8,C[m++]=Xe,Xe=Xe>>8,C[m++]=Xe,m}function wt(C,c,m,W,we){Qe(c,W,we,C,m,7);let Fe=Number(c&BigInt(4294967295));C[m+7]=Fe,Fe=Fe>>8,C[m+6]=Fe,Fe=Fe>>8,C[m+5]=Fe,Fe=Fe>>8,C[m+4]=Fe;let Xe=Number(c>>BigInt(32)&BigInt(4294967295));return C[m+3]=Xe,Xe=Xe>>8,C[m+2]=Xe,Xe=Xe>>8,C[m+1]=Xe,Xe=Xe>>8,C[m]=Xe,m+8}M.prototype.writeBigUInt64LE=pt(function(c,m=0){return He(this,c,m,BigInt(0),BigInt("0xffffffffffffffff"))}),M.prototype.writeBigUInt64BE=pt(function(c,m=0){return wt(this,c,m,BigInt(0),BigInt("0xffffffffffffffff"))}),M.prototype.writeIntLE=function(c,m,W,we){if(c=+c,m=m>>>0,!we){const ot=Math.pow(2,8*W-1);it(this,c,m,W,ot-1,-ot)}let Fe=0,Xe=1,sr=0;for(this[m]=c&255;++Fe<W&&(Xe*=256);)c<0&&sr===0&&this[m+Fe-1]!==0&&(sr=1),this[m+Fe]=(c/Xe>>0)-sr&255;return m+W},M.prototype.writeIntBE=function(c,m,W,we){if(c=+c,m=m>>>0,!we){const ot=Math.pow(2,8*W-1);it(this,c,m,W,ot-1,-ot)}let Fe=W-1,Xe=1,sr=0;for(this[m+Fe]=c&255;--Fe>=0&&(Xe*=256);)c<0&&sr===0&&this[m+Fe+1]!==0&&(sr=1),this[m+Fe]=(c/Xe>>0)-sr&255;return m+W},M.prototype.writeInt8=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,1,127,-128),c<0&&(c=255+c+1),this[m]=c&255,m+1},M.prototype.writeInt16LE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,2,32767,-32768),this[m]=c&255,this[m+1]=c>>>8,m+2},M.prototype.writeInt16BE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,2,32767,-32768),this[m]=c>>>8,this[m+1]=c&255,m+2},M.prototype.writeInt32LE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,4,2147483647,-2147483648),this[m]=c&255,this[m+1]=c>>>8,this[m+2]=c>>>16,this[m+3]=c>>>24,m+4},M.prototype.writeInt32BE=function(c,m,W){return c=+c,m=m>>>0,W||it(this,c,m,4,2147483647,-2147483648),c<0&&(c=4294967295+c+1),this[m]=c>>>24,this[m+1]=c>>>16,this[m+2]=c>>>8,this[m+3]=c&255,m+4},M.prototype.writeBigInt64LE=pt(function(c,m=0){return He(this,c,m,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),M.prototype.writeBigInt64BE=pt(function(c,m=0){return wt(this,c,m,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function xt(C,c,m,W,we,Fe){if(m+W>C.length)throw new RangeError("Index out of range");if(m<0)throw new RangeError("Index out of range")}function et(C,c,m,W,we){return c=+c,m=m>>>0,we||xt(C,c,m,4),T.write(C,c,m,W,23,4),m+4}M.prototype.writeFloatLE=function(c,m,W){return et(this,c,m,!0,W)},M.prototype.writeFloatBE=function(c,m,W){return et(this,c,m,!1,W)};function X(C,c,m,W,we){return c=+c,m=m>>>0,we||xt(C,c,m,8),T.write(C,c,m,W,52,8),m+8}M.prototype.writeDoubleLE=function(c,m,W){return X(this,c,m,!0,W)},M.prototype.writeDoubleBE=function(c,m,W){return X(this,c,m,!1,W)},M.prototype.copy=function(c,m,W,we){if(!M.isBuffer(c))throw new TypeError("argument should be a Buffer");if(W||(W=0),!we&&we!==0&&(we=this.length),m>=c.length&&(m=c.length),m||(m=0),we>0&&we<W&&(we=W),we===W||c.length===0||this.length===0)return 0;if(m<0)throw new RangeError("targetStart out of bounds");if(W<0||W>=this.length)throw new RangeError("Index out of range");if(we<0)throw new RangeError("sourceEnd out of bounds");we>this.length&&(we=this.length),c.length-m<we-W&&(we=c.length-m+W);const Fe=we-W;return this===c&&typeof re.prototype.copyWithin=="function"?this.copyWithin(m,W,we):re.prototype.set.call(c,this.subarray(W,we),m),Fe},M.prototype.fill=function(c,m,W,we){if(typeof c=="string"){if(typeof m=="string"?(we=m,m=0,W=this.length):typeof W=="string"&&(we=W,W=this.length),we!==void 0&&typeof we!="string")throw new TypeError("encoding must be a string");if(typeof we=="string"&&!M.isEncoding(we))throw new TypeError("Unknown encoding: "+we);if(c.length===1){const Xe=c.charCodeAt(0);(we==="utf8"&&Xe<128||we==="latin1")&&(c=Xe)}}else typeof c=="number"?c=c&255:typeof c=="boolean"&&(c=Number(c));if(m<0||this.length<m||this.length<W)throw new RangeError("Out of range index");if(W<=m)return this;m=m>>>0,W=W===void 0?this.length:W>>>0,c||(c=0);let Fe;if(typeof c=="number")for(Fe=m;Fe<W;++Fe)this[Fe]=c;else{const Xe=M.isBuffer(c)?c:M.from(c,we),sr=Xe.length;if(sr===0)throw new TypeError('The value "'+c+'" is invalid for argument "value"');for(Fe=0;Fe<W-m;++Fe)this[Fe+m]=Xe[Fe%sr]}return this};const Be={};function st(C,c,m){Be[C]=class extends m{constructor(){super(),Object.defineProperty(this,"message",{value:c.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${C}]`,this.stack,delete this.name}get code(){return C}set code(we){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:we,writable:!0})}toString(){return`${this.name} [${C}]: ${this.message}`}}}st("ERR_BUFFER_OUT_OF_BOUNDS",function(C){return C?`${C} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),st("ERR_INVALID_ARG_TYPE",function(C,c){return`The "${C}" argument must be of type number. Received type ${typeof c}`},TypeError),st("ERR_OUT_OF_RANGE",function(C,c,m){let W=`The value of "${C}" is out of range.`,we=m;return Number.isInteger(m)&&Math.abs(m)>2**32?we=lt(String(m)):typeof m=="bigint"&&(we=String(m),(m>BigInt(2)**BigInt(32)||m<-(BigInt(2)**BigInt(32)))&&(we=lt(we)),we+="n"),W+=` It must be ${c}. Received ${we}`,W},RangeError);function lt(C){let c="",m=C.length;const W=C[0]==="-"?1:0;for(;m>=W+4;m-=3)c=`_${C.slice(m-3,m)}${c}`;return`${C.slice(0,m)}${c}`}function rt(C,c,m){_t(c,"offset"),(C[c]===void 0||C[c+m]===void 0)&&yt(c,C.length-(m+1))}function Qe(C,c,m,W,we,Fe){if(C>m||C<c){const Xe=typeof c=="bigint"?"n":"";let sr;throw c===0||c===BigInt(0)?sr=`>= 0${Xe} and < 2${Xe} ** ${(Fe+1)*8}${Xe}`:sr=`>= -(2${Xe} ** ${(Fe+1)*8-1}${Xe}) and < 2 ** ${(Fe+1)*8-1}${Xe}`,new Be.ERR_OUT_OF_RANGE("value",sr,C)}rt(W,we,Fe)}function _t(C,c){if(typeof C!="number")throw new Be.ERR_INVALID_ARG_TYPE(c,"number",C)}function yt(C,c,m){throw Math.floor(C)!==C?(_t(C,m),new Be.ERR_OUT_OF_RANGE("offset","an integer",C)):c<0?new Be.ERR_BUFFER_OUT_OF_BOUNDS:new Be.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${c}`,C)}const Lt=/[^+/0-9A-Za-z-_]/g;function kt(C){if(C=C.split("=")[0],C=C.trim().replace(Lt,""),C.length<2)return"";for(;C.length%4!==0;)C=C+"=";return C}function $(C,c){c=c||1/0;let m;const W=C.length;let we=null;const Fe=[];for(let Xe=0;Xe<W;++Xe){if(m=C.charCodeAt(Xe),m>55295&&m<57344){if(!we){if(m>56319){(c-=3)>-1&&Fe.push(239,191,189);continue}else if(Xe+1===W){(c-=3)>-1&&Fe.push(239,191,189);continue}we=m;continue}if(m<56320){(c-=3)>-1&&Fe.push(239,191,189),we=m;continue}m=(we-55296<<10|m-56320)+65536}else we&&(c-=3)>-1&&Fe.push(239,191,189);if(we=null,m<128){if((c-=1)<0)break;Fe.push(m)}else if(m<2048){if((c-=2)<0)break;Fe.push(m>>6|192,m&63|128)}else if(m<65536){if((c-=3)<0)break;Fe.push(m>>12|224,m>>6&63|128,m&63|128)}else if(m<1114112){if((c-=4)<0)break;Fe.push(m>>18|240,m>>12&63|128,m>>6&63|128,m&63|128)}else throw new Error("Invalid code point")}return Fe}function J(C){const c=[];for(let m=0;m<C.length;++m)c.push(C.charCodeAt(m)&255);return c}function z(C,c){let m,W,we;const Fe=[];for(let Xe=0;Xe<C.length&&!((c-=2)<0);++Xe)m=C.charCodeAt(Xe),W=m>>8,we=m%256,Fe.push(we),Fe.push(W);return Fe}function pe(C){return R.toByteArray(kt(C))}function Se(C,c,m,W){let we;for(we=0;we<W&&!(we+m>=c.length||we>=C.length);++we)c[we+m]=C[we];return we}function dt(C,c){return C instanceof c||C!=null&&C.constructor!=null&&C.constructor.name!=null&&C.constructor.name===c.name}function at(C){return C!==C}const At=function(){const C="0123456789abcdef",c=new Array(256);for(let m=0;m<16;++m){const W=m*16;for(let we=0;we<16;++we)c[W+we]=C[m]+C[we]}return c}();function pt(C){return typeof BigInt>"u"?bt:C}function bt(){throw new Error("BigInt not supported")}})(Mm);const w_=Mm.Buffer;var Np={},xm={"./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":(oe,R,T)=>{oe.exports=T.p+"ort-wasm-simd-threaded.jsep.wasm"},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(oe,R,T)=>{T.r(R),T.d(R,{Environment:()=>Qe,Interpreter:()=>_t,Template:()=>kt,parse:()=>_e,tokenize:()=>N});var E=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),Z=Object.freeze({set:E.Set,for:E.For,in:E.In,is:E.Is,if:E.If,else:E.Else,endif:E.EndIf,elif:E.ElseIf,endfor:E.EndFor,and:E.And,or:E.Or,not:E.Not,"not in":E.NotIn,macro:E.Macro,endmacro:E.EndMacro,true:E.BooleanLiteral,false:E.BooleanLiteral,True:E.BooleanLiteral,False:E.BooleanLiteral}),re=class{constructor($,J){this.value=$,this.type=J}};function fe($){return/\w/.test($)}function Ee($){return/[0-9]/.test($)}var j=[["{%",E.OpenStatement],["%}",E.CloseStatement],["{{",E.OpenExpression],["}}",E.CloseExpression],["(",E.OpenParen],[")",E.CloseParen],["{",E.OpenCurlyBracket],["}",E.CloseCurlyBracket],["[",E.OpenSquareBracket],["]",E.CloseSquareBracket],[",",E.Comma],[".",E.Dot],[":",E.Colon],["|",E.Pipe],["<=",E.ComparisonBinaryOperator],[">=",E.ComparisonBinaryOperator],["==",E.ComparisonBinaryOperator],["!=",E.ComparisonBinaryOperator],["<",E.ComparisonBinaryOperator],[">",E.ComparisonBinaryOperator],["+",E.AdditiveBinaryOperator],["-",E.AdditiveBinaryOperator],["*",E.MultiplicativeBinaryOperator],["/",E.MultiplicativeBinaryOperator],["%",E.MultiplicativeBinaryOperator],["=",E.Equals]],O=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function M($,J={}){return $.endsWith(`
`)&&($=$.slice(0,-1)),$=$.replace(/{#.*?#}/gs,"{##}"),J.lstrip_blocks&&($=$.replace(/^[ \t]*({[#%])/gm,"$1")),J.trim_blocks&&($=$.replace(/([#%]})\n/g,"$1")),$.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function N($,J={}){const z=[],pe=M($,J);let Se=0;const dt=at=>{let At="";for(;at(pe[Se]);){if(pe[Se]==="\\"){if(++Se,Se>=pe.length)throw new SyntaxError("Unexpected end of input");const pt=pe[Se++],bt=O.get(pt);if(bt===void 0)throw new SyntaxError(`Unexpected escaped character: ${pt}`);At+=bt;continue}if(At+=pe[Se++],Se>=pe.length)throw new SyntaxError("Unexpected end of input")}return At};e:for(;Se<pe.length;){const at=z.at(-1)?.type;if(at===void 0||at===E.CloseStatement||at===E.CloseExpression){let pt="";for(;Se<pe.length&&!(pe[Se]==="{"&&(pe[Se+1]==="%"||pe[Se+1]==="{"));)pt+=pe[Se++];if(pt.length>0){z.push(new re(pt,E.Text));continue}}dt(pt=>/\s/.test(pt));const At=pe[Se];if(At==="-"||At==="+"){const pt=z.at(-1)?.type;if(pt===E.Text||pt===void 0)throw new SyntaxError(`Unexpected character: ${At}`);switch(pt){case E.Identifier:case E.NumericLiteral:case E.BooleanLiteral:case E.StringLiteral:case E.CloseParen:case E.CloseSquareBracket:break;default:{++Se;const bt=dt(Ee);z.push(new re(`${At}${bt}`,bt.length>0?E.NumericLiteral:E.UnaryOperator));continue}}}for(const[pt,bt]of j)if(pe.slice(Se,Se+pt.length)===pt){z.push(new re(pt,bt)),Se+=pt.length;continue e}if(At==="'"||At==='"'){++Se;const pt=dt(bt=>bt!==At);z.push(new re(pt,E.StringLiteral)),++Se;continue}if(Ee(At)){const pt=dt(Ee);z.push(new re(pt,E.NumericLiteral));continue}if(fe(At)){const pt=dt(fe),bt=Object.hasOwn(Z,pt)?Z[pt]:E.Identifier;bt===E.In&&z.at(-1)?.type===E.Not?(z.pop(),z.push(new re("not in",E.NotIn))):z.push(new re(pt,bt));continue}throw new SyntaxError(`Unexpected character: ${At}`)}return z}var K=class{type="Statement"},ae=class extends K{constructor($){super(),this.body=$}type="Program"},$e=class extends K{constructor($,J,z){super(),this.test=$,this.body=J,this.alternate=z}type="If"},Te=class extends K{constructor($,J,z,pe){super(),this.loopvar=$,this.iterable=J,this.body=z,this.defaultBlock=pe}type="For"},U=class extends K{constructor($,J){super(),this.assignee=$,this.value=J}type="Set"},ue=class extends K{constructor($,J,z){super(),this.name=$,this.args=J,this.body=z}type="Macro"},ke=class extends K{type="Expression"},te=class extends ke{constructor($,J,z){super(),this.object=$,this.property=J,this.computed=z}type="MemberExpression"},ee=class extends ke{constructor($,J){super(),this.callee=$,this.args=J}type="CallExpression"},q=class extends ke{constructor($){super(),this.value=$}type="Identifier"},B=class extends ke{constructor($){super(),this.value=$}type="Literal"},H=class extends B{type="NumericLiteral"},I=class extends B{type="StringLiteral"},Me=class extends B{type="BooleanLiteral"},xe=class extends B{type="ArrayLiteral"},Ce=class extends B{type="TupleLiteral"},Ve=class extends B{type="ObjectLiteral"},Ue=class extends ke{constructor($,J,z){super(),this.operator=$,this.left=J,this.right=z}type="BinaryExpression"},Ne=class extends ke{constructor($,J){super(),this.operand=$,this.filter=J}type="FilterExpression"},Pe=class extends ke{constructor($,J){super(),this.iterable=$,this.test=J}type="SelectExpression"},Ae=class extends ke{constructor($,J,z){super(),this.operand=$,this.negate=J,this.test=z}type="TestExpression"},ie=class extends ke{constructor($,J){super(),this.operator=$,this.argument=J}type="UnaryExpression"},F=class extends ke{constructor($=void 0,J=void 0,z=void 0){super(),this.start=$,this.stop=J,this.step=z}type="SliceExpression"},se=class extends ke{constructor($,J){super(),this.key=$,this.value=J}type="KeywordArgumentExpression"};function _e($){const J=new ae([]);let z=0;function pe(We,Ge){const vt=$[z++];if(!vt||vt.type!==We)throw new Error(`Parser Error: ${Ge}. ${vt.type} !== ${We}.`);return vt}function Se(){switch($[z].type){case E.Text:return At();case E.OpenStatement:return pt();case E.OpenExpression:return bt();default:throw new SyntaxError(`Unexpected token type: ${$[z].type}`)}}function dt(...We){return z+We.length<=$.length&&We.some((Ge,vt)=>Ge!==$[z+vt].type)}function at(...We){return z+We.length<=$.length&&We.every((Ge,vt)=>Ge===$[z+vt].type)}function At(){return new I(pe(E.Text,"Expected text token").value)}function pt(){pe(E.OpenStatement,"Expected opening statement token");let We;switch($[z].type){case E.Set:++z,We=C(),pe(E.CloseStatement,"Expected closing statement token");break;case E.If:++z,We=c(),pe(E.OpenStatement,"Expected {% token"),pe(E.EndIf,"Expected endif token"),pe(E.CloseStatement,"Expected %} token");break;case E.Macro:++z,We=m(),pe(E.OpenStatement,"Expected {% token"),pe(E.EndMacro,"Expected endmacro token"),pe(E.CloseStatement,"Expected %} token");break;case E.For:++z,We=we(),pe(E.OpenStatement,"Expected {% token"),pe(E.EndFor,"Expected endfor token"),pe(E.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${$[z].type}`)}return We}function bt(){pe(E.OpenExpression,"Expected opening expression token");const We=Fe();return pe(E.CloseExpression,"Expected closing expression token"),We}function C(){const We=Fe();if(at(E.Equals)){++z;const Ge=C();return new U(We,Ge)}return We}function c(){const We=Fe();pe(E.CloseStatement,"Expected closing statement token");const Ge=[],vt=[];for(;!($[z]?.type===E.OpenStatement&&($[z+1]?.type===E.ElseIf||$[z+1]?.type===E.Else||$[z+1]?.type===E.EndIf));)Ge.push(Se());if($[z]?.type===E.OpenStatement&&$[z+1]?.type!==E.EndIf)if(++z,at(E.ElseIf))pe(E.ElseIf,"Expected elseif token"),vt.push(c());else for(pe(E.Else,"Expected else token"),pe(E.CloseStatement,"Expected closing statement token");!($[z]?.type===E.OpenStatement&&$[z+1]?.type===E.EndIf);)vt.push(Se());return new $e(We,Ge,vt)}function m(){const We=Nt();if(We.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const Ge=mt();pe(E.CloseStatement,"Expected closing statement token");const vt=[];for(;dt(E.OpenStatement,E.EndMacro);)vt.push(Se());return new ue(We,Ge,vt)}function W(We=!1){const Ge=We?Nt:Fe,vt=[Ge()],Ht=at(E.Comma);for(;Ht&&(++z,vt.push(Ge()),!!at(E.Comma)););return Ht?new Ce(vt):vt[0]}function we(){const We=W(!0);if(!(We instanceof q||We instanceof Ce))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${We.type} instead`);pe(E.In,"Expected `in` keyword following loop variable");const Ge=Fe();pe(E.CloseStatement,"Expected closing statement token");const vt=[];for(;dt(E.OpenStatement,E.EndFor)&&dt(E.OpenStatement,E.Else);)vt.push(Se());const Ht=[];if(at(E.OpenStatement,E.Else))for(++z,++z,pe(E.CloseStatement,"Expected closing statement token");dt(E.OpenStatement,E.EndFor);)Ht.push(Se());return new Te(We,Ge,vt,Ht)}function Fe(){return Xe()}function Xe(){const We=sr();if(at(E.If)){++z;const Ge=sr();if(at(E.Else)){++z;const vt=sr();return new $e(Ge,[We],[vt])}else return new Pe(We,Ge)}return We}function sr(){let We=ot();for(;at(E.Or);){const Ge=$[z];++z;const vt=ot();We=new Ue(Ge,We,vt)}return We}function ot(){let We=V();for(;at(E.And);){const Ge=$[z];++z;const vt=V();We=new Ue(Ge,We,vt)}return We}function V(){let We;for(;at(E.Not);){const Ge=$[z];++z;const vt=V();We=new ie(Ge,vt)}return We??ve()}function ve(){let We=Ie();for(;at(E.ComparisonBinaryOperator)||at(E.In)||at(E.NotIn);){const Ge=$[z];++z;const vt=Ie();We=new Ue(Ge,We,vt)}return We}function Ie(){let We=Tt();for(;at(E.AdditiveBinaryOperator);){const Ge=$[z];++z;const vt=Tt();We=new Ue(Ge,We,vt)}return We}function je(){const We=Ft();return at(E.OpenParen)?Ze(We):We}function Ze(We){let Ge=new ee(We,mt());return at(E.OpenParen)&&(Ge=Ze(Ge)),Ge}function mt(){pe(E.OpenParen,"Expected opening parenthesis for arguments list");const We=Ct();return pe(E.CloseParen,"Expected closing parenthesis for arguments list"),We}function Ct(){const We=[];for(;!at(E.CloseParen);){let Ge=Fe();if(at(E.Equals)){if(++z,!(Ge instanceof q))throw new SyntaxError("Expected identifier for keyword argument");const vt=Fe();Ge=new se(Ge,vt)}We.push(Ge),at(E.Comma)&&++z}return We}function Et(){const We=[];let Ge=!1;for(;!at(E.CloseSquareBracket);)at(E.Colon)?(We.push(void 0),++z,Ge=!0):(We.push(Fe()),at(E.Colon)&&(++z,Ge=!0));if(We.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(Ge){if(We.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new F(...We)}return We[0]}function Ft(){let We=Nt();for(;at(E.Dot)||at(E.OpenSquareBracket);){const Ge=$[z];++z;let vt;const Ht=Ge.type!==E.Dot;if(Ht)vt=Et(),pe(E.CloseSquareBracket,"Expected closing square bracket");else if(vt=Nt(),vt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");We=new te(We,vt,Ht)}return We}function Tt(){let We=Ut();for(;at(E.MultiplicativeBinaryOperator);){const Ge=$[z];++z;const vt=Ut();We=new Ue(Ge,We,vt)}return We}function Ut(){let We=Wt();for(;at(E.Is);){++z;const Ge=at(E.Not);Ge&&++z;let vt=Nt();if(vt instanceof Me&&(vt=new q(vt.value.toString())),!(vt instanceof q))throw new SyntaxError("Expected identifier for the test");We=new Ae(We,Ge,vt)}return We}function Wt(){let We=je();for(;at(E.Pipe);){++z;let Ge=Nt();if(!(Ge instanceof q))throw new SyntaxError("Expected identifier for the filter");at(E.OpenParen)&&(Ge=Ze(Ge)),We=new Ne(We,Ge)}return We}function Nt(){const We=$[z];switch(We.type){case E.NumericLiteral:return++z,new H(Number(We.value));case E.StringLiteral:return++z,new I(We.value);case E.BooleanLiteral:return++z,new Me(We.value.toLowerCase()==="true");case E.Identifier:return++z,new q(We.value);case E.OpenParen:{++z;const Ge=W();if($[z].type!==E.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${$[z].type} instead`);return++z,Ge}case E.OpenSquareBracket:{++z;const Ge=[];for(;!at(E.CloseSquareBracket);)Ge.push(Fe()),at(E.Comma)&&++z;return++z,new xe(Ge)}case E.OpenCurlyBracket:{++z;const Ge=new Map;for(;!at(E.CloseCurlyBracket);){const vt=Fe();pe(E.Colon,"Expected colon between key and value in object literal");const Ht=Fe();Ge.set(vt,Ht),at(E.Comma)&&++z}return++z,new Ve(Ge)}default:throw new SyntaxError(`Unexpected token: ${We.type}`)}}for(;z<$.length;)J.body.push(Se());return J}function Oe($,J,z=1){J===void 0&&(J=$,$=0);const pe=[];for(let Se=$;Se<J;Se+=z)pe.push(Se);return pe}function nt($,J,z,pe=1){const Se=Math.sign(pe);Se>=0?(J=(J??=0)<0?Math.max($.length+J,0):Math.min(J,$.length),z=(z??=$.length)<0?Math.max($.length+z,0):Math.min(z,$.length)):(J=(J??=$.length-1)<0?Math.max($.length+J,-1):Math.min(J,$.length-1),z=(z??=-1)<-1?Math.max($.length+z,-1):Math.min(z,$.length-1));const dt=[];for(let at=J;Se*at<Se*z;at+=pe)dt.push($[at]);return dt}function de($){return $.replace(/\b\w/g,J=>J.toUpperCase())}var Re=class{type="RuntimeValue";value;builtins=new Map;constructor($=void 0){this.value=$}__bool__(){return new wt(!!this.value)}},it=class extends Re{type="NumericValue"},He=class extends Re{type="StringValue";builtins=new Map([["upper",new st(()=>new He(this.value.toUpperCase()))],["lower",new st(()=>new He(this.value.toLowerCase()))],["strip",new st(()=>new He(this.value.trim()))],["title",new st(()=>new He(de(this.value)))],["length",new it(this.value.length)]])},wt=class extends Re{type="BooleanValue"},xt=class extends Re{type="ObjectValue";__bool__(){return new wt(this.value.size>0)}builtins=new Map([["get",new st(([$,J])=>{if(!($ instanceof He))throw new Error(`Object key must be a string: got ${$.type}`);return this.value.get($.value)??J??new lt})],["items",new st(()=>new X(Array.from(this.value.entries()).map(([$,J])=>new X([new He($),J]))))]])},et=class extends xt{type="KeywordArgumentsValue"},X=class extends Re{type="ArrayValue";builtins=new Map([["length",new it(this.value.length)]]);__bool__(){return new wt(this.value.length>0)}},Be=class extends X{type="TupleValue"},st=class extends Re{type="FunctionValue"},lt=class extends Re{type="NullValue"},rt=class extends Re{type="UndefinedValue"},Qe=class{constructor($){this.parent=$}variables=new Map([["namespace",new st($=>{if($.length===0)return new xt(new Map);if($.length!==1||!($[0]instanceof xt))throw new Error("`namespace` expects either zero arguments or a single object argument");return $[0]})]]);tests=new Map([["boolean",$=>$.type==="BooleanValue"],["callable",$=>$ instanceof st],["odd",$=>{if($.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${$.type}`);return $.value%2!==0}],["even",$=>{if($.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${$.type}`);return $.value%2===0}],["false",$=>$.type==="BooleanValue"&&!$.value],["true",$=>$.type==="BooleanValue"&&$.value],["string",$=>$.type==="StringValue"],["number",$=>$.type==="NumericValue"],["integer",$=>$.type==="NumericValue"&&Number.isInteger($.value)],["iterable",$=>$ instanceof X||$ instanceof He],["lower",$=>{const J=$.value;return $.type==="StringValue"&&J===J.toLowerCase()}],["upper",$=>{const J=$.value;return $.type==="StringValue"&&J===J.toUpperCase()}],["none",$=>$.type==="NullValue"],["defined",$=>$.type!=="UndefinedValue"],["undefined",$=>$.type==="UndefinedValue"],["equalto",($,J)=>$.value===J.value],["eq",($,J)=>$.value===J.value]]);set($,J){return this.declareVariable($,yt(J))}declareVariable($,J){if(this.variables.has($))throw new SyntaxError(`Variable already declared: ${$}`);return this.variables.set($,J),J}setVariable($,J){return this.variables.set($,J),J}resolve($){if(this.variables.has($))return this;if(this.parent)return this.parent.resolve($);throw new Error(`Unknown variable: ${$}`)}lookupVariable($){try{return this.resolve($).variables.get($)??new rt}catch{return new rt}}},_t=class{global;constructor($){this.global=$??new Qe}run($){return this.evaluate($,this.global)}evaluateBinaryExpression($,J){const z=this.evaluate($.left,J);switch($.operator.value){case"and":return z.__bool__().value?this.evaluate($.right,J):z;case"or":return z.__bool__().value?z:this.evaluate($.right,J)}const pe=this.evaluate($.right,J);switch($.operator.value){case"==":return new wt(z.value==pe.value);case"!=":return new wt(z.value!=pe.value)}if(z instanceof rt||pe instanceof rt)throw new Error("Cannot perform operation on undefined values");if(z instanceof lt||pe instanceof lt)throw new Error("Cannot perform operation on null values");if(z instanceof it&&pe instanceof it)switch($.operator.value){case"+":return new it(z.value+pe.value);case"-":return new it(z.value-pe.value);case"*":return new it(z.value*pe.value);case"/":return new it(z.value/pe.value);case"%":return new it(z.value%pe.value);case"<":return new wt(z.value<pe.value);case">":return new wt(z.value>pe.value);case">=":return new wt(z.value>=pe.value);case"<=":return new wt(z.value<=pe.value)}else if(z instanceof X&&pe instanceof X)switch($.operator.value){case"+":return new X(z.value.concat(pe.value))}else if(pe instanceof X){const Se=pe.value.find(dt=>dt.value===z.value)!==void 0;switch($.operator.value){case"in":return new wt(Se);case"not in":return new wt(!Se)}}if(z instanceof He||pe instanceof He)switch($.operator.value){case"+":return new He(z.value.toString()+pe.value.toString())}if(z instanceof He&&pe instanceof He)switch($.operator.value){case"in":return new wt(pe.value.includes(z.value));case"not in":return new wt(!pe.value.includes(z.value))}if(z instanceof He&&pe instanceof xt)switch($.operator.value){case"in":return new wt(pe.value.has(z.value));case"not in":return new wt(!pe.value.has(z.value))}throw new SyntaxError(`Unknown operator "${$.operator.value}" between ${z.type} and ${pe.type}`)}evaluateArguments($,J){const z=[],pe=new Map;for(const Se of $)if(Se.type==="KeywordArgumentExpression"){const dt=Se;pe.set(dt.key.value,this.evaluate(dt.value,J))}else{if(pe.size>0)throw new Error("Positional arguments must come before keyword arguments");z.push(this.evaluate(Se,J))}return[z,pe]}evaluateFilterExpression($,J){const z=this.evaluate($.operand,J);if($.filter.type==="Identifier"){const pe=$.filter;if(pe.value==="tojson")return new He(Lt(z));if(z instanceof X)switch(pe.value){case"list":return z;case"first":return z.value[0];case"last":return z.value[z.value.length-1];case"length":return new it(z.value.length);case"reverse":return new X(z.value.reverse());case"sort":return new X(z.value.sort((Se,dt)=>{if(Se.type!==dt.type)throw new Error(`Cannot compare different types: ${Se.type} and ${dt.type}`);switch(Se.type){case"NumericValue":return Se.value-dt.value;case"StringValue":return Se.value.localeCompare(dt.value);default:throw new Error(`Cannot compare type: ${Se.type}`)}}));default:throw new Error(`Unknown ArrayValue filter: ${pe.value}`)}else if(z instanceof He)switch(pe.value){case"length":return new it(z.value.length);case"upper":return new He(z.value.toUpperCase());case"lower":return new He(z.value.toLowerCase());case"title":return new He(de(z.value));case"capitalize":return new He(z.value.charAt(0).toUpperCase()+z.value.slice(1));case"trim":return new He(z.value.trim());case"indent":return new He(z.value.split(`
`).map((Se,dt)=>dt===0||Se.length===0?Se:"    "+Se).join(`
`));case"string":return z;default:throw new Error(`Unknown StringValue filter: ${pe.value}`)}else if(z instanceof it)switch(pe.value){case"abs":return new it(Math.abs(z.value));default:throw new Error(`Unknown NumericValue filter: ${pe.value}`)}else if(z instanceof xt)switch(pe.value){case"items":return new X(Array.from(z.value.entries()).map(([Se,dt])=>new X([new He(Se),dt])));case"length":return new it(z.value.size);default:throw new Error(`Unknown ObjectValue filter: ${pe.value}`)}throw new Error(`Cannot apply filter "${pe.value}" to type: ${z.type}`)}else if($.filter.type==="CallExpression"){const pe=$.filter;if(pe.callee.type!=="Identifier")throw new Error(`Unknown filter: ${pe.callee.type}`);const Se=pe.callee.value;if(Se==="tojson"){const[,dt]=this.evaluateArguments(pe.args,J),at=dt.get("indent")??new lt;if(!(at instanceof it||at instanceof lt))throw new Error("If set, indent must be a number");return new He(Lt(z,at.value))}if(z instanceof X){switch(Se){case"selectattr":{if(z.value.some(C=>!(C instanceof xt)))throw new Error("`selectattr` can only be applied to array of objects");if(pe.args.some(C=>C.type!=="StringLiteral"))throw new Error("arguments of `selectattr` must be strings");const[dt,at,At]=pe.args.map(C=>this.evaluate(C,J));let pt;if(at){const C=J.tests.get(at.value);if(!C)throw new Error(`Unknown test: ${at.value}`);pt=C}else pt=(...C)=>C[0].__bool__().value;const bt=z.value.filter(C=>{const c=C.value.get(dt.value);return c?pt(c,At):!1});return new X(bt)}case"map":{const[,dt]=this.evaluateArguments(pe.args,J);if(dt.has("attribute")){const at=dt.get("attribute");if(!(at instanceof He))throw new Error("attribute must be a string");const At=dt.get("default"),pt=z.value.map(bt=>{if(!(bt instanceof xt))throw new Error("items in map must be an object");return bt.value.get(at.value)??At??new rt});return new X(pt)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${Se}`)}else if(z instanceof He){switch(Se){case"indent":{const[dt,at]=this.evaluateArguments(pe.args,J),At=dt.at(0)??at.get("width")??new it(4);if(!(At instanceof it))throw new Error("width must be a number");const pt=dt.at(1)??at.get("first")??new wt(!1),bt=dt.at(2)??at.get("blank")??new wt(!1),C=z.value.split(`
`),c=" ".repeat(At.value),m=C.map((W,we)=>!pt.value&&we===0||!bt.value&&W.length===0?W:c+W);return new He(m.join(`
`))}}throw new Error(`Unknown StringValue filter: ${Se}`)}else throw new Error(`Cannot apply filter "${Se}" to type: ${z.type}`)}throw new Error(`Unknown filter: ${$.filter.type}`)}evaluateTestExpression($,J){const z=this.evaluate($.operand,J),pe=J.tests.get($.test.value);if(!pe)throw new Error(`Unknown test: ${$.test.value}`);const Se=pe(z);return new wt($.negate?!Se:Se)}evaluateUnaryExpression($,J){const z=this.evaluate($.argument,J);switch($.operator.value){case"not":return new wt(!z.value);default:throw new SyntaxError(`Unknown operator: ${$.operator.value}`)}}evalProgram($,J){return this.evaluateBlock($.body,J)}evaluateBlock($,J){let z="";for(const pe of $){const Se=this.evaluate(pe,J);Se.type!=="NullValue"&&Se.type!=="UndefinedValue"&&(z+=Se.value)}return new He(z)}evaluateIdentifier($,J){return J.lookupVariable($.value)}evaluateCallExpression($,J){const[z,pe]=this.evaluateArguments($.args,J);pe.size>0&&z.push(new et(pe));const Se=this.evaluate($.callee,J);if(Se.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Se.type}`);return Se.value(z,J)}evaluateSliceExpression($,J,z){if(!($ instanceof X||$ instanceof He))throw new Error("Slice object must be an array or string");const pe=this.evaluate(J.start,z),Se=this.evaluate(J.stop,z),dt=this.evaluate(J.step,z);if(!(pe instanceof it||pe instanceof rt))throw new Error("Slice start must be numeric or undefined");if(!(Se instanceof it||Se instanceof rt))throw new Error("Slice stop must be numeric or undefined");if(!(dt instanceof it||dt instanceof rt))throw new Error("Slice step must be numeric or undefined");return $ instanceof X?new X(nt($.value,pe.value,Se.value,dt.value)):new He(nt(Array.from($.value),pe.value,Se.value,dt.value).join(""))}evaluateMemberExpression($,J){const z=this.evaluate($.object,J);let pe;if($.computed){if($.property.type==="SliceExpression")return this.evaluateSliceExpression(z,$.property,J);pe=this.evaluate($.property,J)}else pe=new He($.property.value);let Se;if(z instanceof xt){if(!(pe instanceof He))throw new Error(`Cannot access property with non-string: got ${pe.type}`);Se=z.value.get(pe.value)??z.builtins.get(pe.value)}else if(z instanceof X||z instanceof He)if(pe instanceof it)Se=z.value.at(pe.value),z instanceof He&&(Se=new He(z.value.at(pe.value)));else if(pe instanceof He)Se=z.builtins.get(pe.value);else throw new Error(`Cannot access property with non-string/non-number: got ${pe.type}`);else{if(!(pe instanceof He))throw new Error(`Cannot access property with non-string: got ${pe.type}`);Se=z.builtins.get(pe.value)}return Se instanceof Re?Se:new rt}evaluateSet($,J){const z=this.evaluate($.value,J);if($.assignee.type==="Identifier"){const pe=$.assignee.value;J.setVariable(pe,z)}else if($.assignee.type==="MemberExpression"){const pe=$.assignee,Se=this.evaluate(pe.object,J);if(!(Se instanceof xt))throw new Error("Cannot assign to member of non-object");if(pe.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");Se.value.set(pe.property.value,z)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify($.assignee)}`);return new lt}evaluateIf($,J){const z=this.evaluate($.test,J);return this.evaluateBlock(z.__bool__().value?$.body:$.alternate,J)}evaluateFor($,J){const z=new Qe(J);let pe,Se;if($.iterable.type==="SelectExpression"){const bt=$.iterable;Se=this.evaluate(bt.iterable,z),pe=bt.test}else Se=this.evaluate($.iterable,z);if(!(Se instanceof X))throw new Error(`Expected iterable type in for loop: got ${Se.type}`);const dt=[],at=[];for(let bt=0;bt<Se.value.length;++bt){const C=new Qe(z),c=Se.value[bt];let m;if($.loopvar.type==="Identifier")m=W=>W.setVariable($.loopvar.value,c);else if($.loopvar.type==="TupleLiteral"){const W=$.loopvar;if(c.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${c.type}`);const we=c;if(W.value.length!==we.value.length)throw new Error(`Too ${W.value.length>we.value.length?"few":"many"} items to unpack`);m=Fe=>{for(let Xe=0;Xe<W.value.length;++Xe){if(W.value[Xe].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${W.value[Xe].type}`);Fe.setVariable(W.value[Xe].value,we.value[Xe])}}}else throw new Error(`Invalid loop variable(s): ${$.loopvar.type}`);pe&&(m(C),!this.evaluate(pe,C).__bool__().value)||(dt.push(c),at.push(m))}let At="",pt=!0;for(let bt=0;bt<dt.length;++bt){const C=new Map([["index",new it(bt+1)],["index0",new it(bt)],["revindex",new it(dt.length-bt)],["revindex0",new it(dt.length-bt-1)],["first",new wt(bt===0)],["last",new wt(bt===dt.length-1)],["length",new it(dt.length)],["previtem",bt>0?dt[bt-1]:new rt],["nextitem",bt<dt.length-1?dt[bt+1]:new rt]]);z.setVariable("loop",new xt(C)),at[bt](z);const c=this.evaluateBlock($.body,z);At+=c.value,pt=!1}if(pt){const bt=this.evaluateBlock($.defaultBlock,z);At+=bt.value}return new He(At)}evaluateMacro($,J){return J.setVariable($.name.value,new st((z,pe)=>{const Se=new Qe(pe);z=z.slice();let dt;z.at(-1)?.type==="KeywordArgumentsValue"&&(dt=z.pop());for(let at=0;at<$.args.length;++at){const At=$.args[at],pt=z[at];if(At.type==="Identifier"){const bt=At;if(!pt)throw new Error(`Missing positional argument: ${bt.value}`);Se.setVariable(bt.value,pt)}else if(At.type==="KeywordArgumentExpression"){const bt=At,C=pt??dt?.value.get(bt.key.value)??this.evaluate(bt.value,Se);Se.setVariable(bt.key.value,C)}else throw new Error(`Unknown argument type: ${At.type}`)}return this.evaluateBlock($.body,Se)})),new lt}evaluate($,J){if($===void 0)return new rt;switch($.type){case"Program":return this.evalProgram($,J);case"Set":return this.evaluateSet($,J);case"If":return this.evaluateIf($,J);case"For":return this.evaluateFor($,J);case"Macro":return this.evaluateMacro($,J);case"NumericLiteral":return new it(Number($.value));case"StringLiteral":return new He($.value);case"BooleanLiteral":return new wt($.value);case"ArrayLiteral":return new X($.value.map(z=>this.evaluate(z,J)));case"TupleLiteral":return new Be($.value.map(z=>this.evaluate(z,J)));case"ObjectLiteral":{const z=new Map;for(const[pe,Se]of $.value){const dt=this.evaluate(pe,J);if(!(dt instanceof He))throw new Error(`Object keys must be strings: got ${dt.type}`);z.set(dt.value,this.evaluate(Se,J))}return new xt(z)}case"Identifier":return this.evaluateIdentifier($,J);case"CallExpression":return this.evaluateCallExpression($,J);case"MemberExpression":return this.evaluateMemberExpression($,J);case"UnaryExpression":return this.evaluateUnaryExpression($,J);case"BinaryExpression":return this.evaluateBinaryExpression($,J);case"FilterExpression":return this.evaluateFilterExpression($,J);case"TestExpression":return this.evaluateTestExpression($,J);default:throw new SyntaxError(`Unknown node type: ${$.type}`)}}};function yt($){switch(typeof $){case"number":return new it($);case"string":return new He($);case"boolean":return new wt($);case"undefined":return new rt;case"object":return $===null?new lt:Array.isArray($)?new X($.map(yt)):new xt(new Map(Object.entries($).map(([J,z])=>[J,yt(z)])));case"function":return new st((J,z)=>{const pe=$(...J.map(Se=>Se.value))??null;return yt(pe)});default:throw new Error(`Cannot convert to runtime value: ${$}`)}}function Lt($,J,z){const pe=z??0;switch($.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify($.value);case"ArrayValue":case"ObjectValue":{const Se=J?" ".repeat(J):"",dt=`
`+Se.repeat(pe),at=dt+Se;if($.type==="ArrayValue"){const At=$.value.map(pt=>Lt(pt,J,pe+1));return J?`[${at}${At.join(`,${at}`)}${dt}]`:`[${At.join(", ")}]`}else{const At=Array.from($.value.entries()).map(([pt,bt])=>{const C=`"${pt}": ${Lt(bt,J,pe+1)}`;return J?`${at}${C}`:C});return J?`{${At.join(",")}${dt}}`:`{${At.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${$.type}`)}}var kt=class{parsed;constructor($){const J=N($,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=_e(J)}render($){const J=new Qe;J.set("false",!1),J.set("true",!0),J.set("raise_exception",Se=>{throw new Error(Se)}),J.set("range",Oe);for(const[Se,dt]of Object.entries($))J.set(Se,dt);return new _t(J).run(this.parsed).value}}},"./node_modules/onnxruntime-common/dist/esm/backend-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{registerBackend:()=>re,resolveBackendAndExecutionProviders:()=>Ee});const E=new Map,Z=[],re=(j,O,M)=>{if(O&&typeof O.init=="function"&&typeof O.createInferenceSessionHandler=="function"){const N=E.get(j);if(N===void 0)E.set(j,{backend:O,priority:M});else{if(N.priority>M)return;if(N.priority===M&&N.backend!==O)throw new Error(`cannot register backend "${j}" using priority ${M}`)}if(M>=0){const K=Z.indexOf(j);K!==-1&&Z.splice(K,1);for(let ae=0;ae<Z.length;ae++)if(E.get(Z[ae]).priority<=M){Z.splice(ae,0,j);return}Z.push(j)}return}throw new TypeError("not a valid backend")},fe=async j=>{const O=E.get(j);if(!O)return"backend not found.";if(O.initialized)return O.backend;if(O.aborted)return O.error;{const M=!!O.initPromise;try{return M||(O.initPromise=O.backend.init(j)),await O.initPromise,O.initialized=!0,O.backend}catch(N){return M||(O.error=`${N}`,O.aborted=!0),O.error}finally{delete O.initPromise}}},Ee=async j=>{const O=j.executionProviders||[],M=O.map(U=>typeof U=="string"?U:U.name),N=M.length===0?Z:M;let K;const ae=[],$e=new Set;for(const U of N){const ue=await fe(U);typeof ue=="string"?ae.push({name:U,err:ue}):(K||(K=ue),K===ue&&$e.add(U))}if(!K)throw new Error(`no available backend found. ERR: ${ae.map(U=>`[${U.name}] ${U.err}`).join(", ")}`);for(const{name:U,err:ue}of ae)M.includes(U)&&console.warn(`removing requested execution provider "${U}" from session options because it is not available: ${ue}`);const Te=O.filter(U=>$e.has(typeof U=="string"?U:U.name));return[K,new Proxy(j,{get:(U,ue)=>ue==="executionProviders"?Te:Reflect.get(U,ue)})]}},"./node_modules/onnxruntime-common/dist/esm/backend.js":(oe,R,T)=>{T.r(R),T.d(R,{registerBackend:()=>E.registerBackend});var E=T("./node_modules/onnxruntime-common/dist/esm/backend-impl.js")},"./node_modules/onnxruntime-common/dist/esm/env-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{env:()=>re});var E=T("./node_modules/onnxruntime-common/dist/esm/version.js");let Z="warning";const re={wasm:{},webgl:{},webgpu:{},versions:{common:E.version},set logLevel(fe){if(fe!==void 0){if(typeof fe!="string"||["verbose","info","warning","error","fatal"].indexOf(fe)===-1)throw new Error(`Unsupported logging level: ${fe}`);Z=fe}},get logLevel(){return Z}};Object.defineProperty(re,"logLevel",{enumerable:!0})},"./node_modules/onnxruntime-common/dist/esm/env.js":(oe,R,T)=>{T.r(R),T.d(R,{env:()=>Z});var E=T("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const Z=E.env},"./node_modules/onnxruntime-common/dist/esm/index.js":(oe,R,T)=>{T.r(R),T.d(R,{InferenceSession:()=>re.InferenceSession,TRACE:()=>Ee.TRACE,TRACE_FUNC_BEGIN:()=>Ee.TRACE_FUNC_BEGIN,TRACE_FUNC_END:()=>Ee.TRACE_FUNC_END,Tensor:()=>fe.Tensor,TrainingSession:()=>j.TrainingSession,env:()=>Z.env,registerBackend:()=>E.registerBackend});var E=T("./node_modules/onnxruntime-common/dist/esm/backend.js"),Z=T("./node_modules/onnxruntime-common/dist/esm/env.js"),re=T("./node_modules/onnxruntime-common/dist/esm/inference-session.js"),fe=T("./node_modules/onnxruntime-common/dist/esm/tensor.js");T("./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"),T("./node_modules/onnxruntime-common/dist/esm/tensor-factory.js");var Ee=T("./node_modules/onnxruntime-common/dist/esm/trace.js");T("./node_modules/onnxruntime-common/dist/esm/onnx-model.js"),T("./node_modules/onnxruntime-common/dist/esm/onnx-value.js");var j=T("./node_modules/onnxruntime-common/dist/esm/training-session.js")},"./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{InferenceSession:()=>fe});var E=T("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),Z=T("./node_modules/onnxruntime-common/dist/esm/tensor.js"),re=T("./node_modules/onnxruntime-common/dist/esm/trace.js");class fe{constructor(j){this.handler=j}async run(j,O,M){(0,re.TRACE_FUNC_BEGIN)();const N={};let K={};if(typeof j!="object"||j===null||j instanceof Z.Tensor||Array.isArray(j))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ae=!0;if(typeof O=="object"){if(O===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(O instanceof Z.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(O)){if(O.length===0)throw new TypeError("'fetches' cannot be an empty array.");ae=!1;for(const U of O){if(typeof U!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(U)===-1)throw new RangeError(`'fetches' contains invalid output name: ${U}.`);N[U]=null}if(typeof M=="object"&&M!==null)K=M;else if(typeof M<"u")throw new TypeError("'options' must be an object.")}else{let U=!1;const ue=Object.getOwnPropertyNames(O);for(const ke of this.outputNames)if(ue.indexOf(ke)!==-1){const te=O[ke];(te===null||te instanceof Z.Tensor)&&(U=!0,ae=!1,N[ke]=te)}if(U){if(typeof M=="object"&&M!==null)K=M;else if(typeof M<"u")throw new TypeError("'options' must be an object.")}else K=O}}else if(typeof O<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const U of this.inputNames)if(typeof j[U]>"u")throw new Error(`input '${U}' is missing in 'feeds'.`);if(ae)for(const U of this.outputNames)N[U]=null;const $e=await this.handler.run(j,N,K),Te={};for(const U in $e)if(Object.hasOwnProperty.call($e,U)){const ue=$e[U];ue instanceof Z.Tensor?Te[U]=ue:Te[U]=new Z.Tensor(ue.type,ue.data,ue.dims)}return(0,re.TRACE_FUNC_END)(),Te}async release(){return this.handler.dispose()}static async create(j,O,M,N){(0,re.TRACE_FUNC_BEGIN)();let K,ae={};if(typeof j=="string"){if(K=j,typeof O=="object"&&O!==null)ae=O;else if(typeof O<"u")throw new TypeError("'options' must be an object.")}else if(j instanceof Uint8Array){if(K=j,typeof O=="object"&&O!==null)ae=O;else if(typeof O<"u")throw new TypeError("'options' must be an object.")}else if(j instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&j instanceof SharedArrayBuffer){const ue=j;let ke=0,te=j.byteLength;if(typeof O=="object"&&O!==null)ae=O;else if(typeof O=="number"){if(ke=O,!Number.isSafeInteger(ke))throw new RangeError("'byteOffset' must be an integer.");if(ke<0||ke>=ue.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${ue.byteLength}).`);if(te=j.byteLength-ke,typeof M=="number"){if(te=M,!Number.isSafeInteger(te))throw new RangeError("'byteLength' must be an integer.");if(te<=0||ke+te>ue.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${ue.byteLength-ke}].`);if(typeof N=="object"&&N!==null)ae=N;else if(typeof N<"u")throw new TypeError("'options' must be an object.")}else if(typeof M<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof O<"u")throw new TypeError("'options' must be an object.");K=new Uint8Array(ue,ke,te)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[$e,Te]=await(0,E.resolveBackendAndExecutionProviders)(ae),U=await $e.createInferenceSessionHandler(K,Te);return(0,re.TRACE_FUNC_END)(),new fe(U)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./node_modules/onnxruntime-common/dist/esm/inference-session.js":(oe,R,T)=>{T.r(R),T.d(R,{InferenceSession:()=>Z});var E=T("./node_modules/onnxruntime-common/dist/esm/inference-session-impl.js");const Z=E.InferenceSession},"./node_modules/onnxruntime-common/dist/esm/onnx-model.js":(oe,R,T)=>{T.r(R)},"./node_modules/onnxruntime-common/dist/esm/onnx-value.js":(oe,R,T)=>{T.r(R)},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{tensorToDataURL:()=>E,tensorToImageData:()=>Z});const E=(re,fe)=>{const Ee=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);Ee.width=re.dims[3],Ee.height=re.dims[2];const j=Ee.getContext("2d");if(j!=null){let O,M;fe?.tensorLayout!==void 0&&fe.tensorLayout==="NHWC"?(O=re.dims[2],M=re.dims[3]):(O=re.dims[3],M=re.dims[2]);const N=fe?.format!==void 0?fe.format:"RGB",K=fe?.norm;let ae,$e;K===void 0||K.mean===void 0?ae=[255,255,255,255]:typeof K.mean=="number"?ae=[K.mean,K.mean,K.mean,K.mean]:(ae=[K.mean[0],K.mean[1],K.mean[2],0],K.mean[3]!==void 0&&(ae[3]=K.mean[3])),K===void 0||K.bias===void 0?$e=[0,0,0,0]:typeof K.bias=="number"?$e=[K.bias,K.bias,K.bias,K.bias]:($e=[K.bias[0],K.bias[1],K.bias[2],0],K.bias[3]!==void 0&&($e[3]=K.bias[3]));const Te=M*O;let U=0,ue=Te,ke=Te*2,te=-1;N==="RGBA"?(U=0,ue=Te,ke=Te*2,te=Te*3):N==="RGB"?(U=0,ue=Te,ke=Te*2):N==="RBG"&&(U=0,ke=Te,ue=Te*2);for(let ee=0;ee<M;ee++)for(let q=0;q<O;q++){const B=(re.data[U++]-$e[0])*ae[0],H=(re.data[ue++]-$e[1])*ae[1],I=(re.data[ke++]-$e[2])*ae[2],Me=te===-1?255:(re.data[te++]-$e[3])*ae[3];j.fillStyle="rgba("+B+","+H+","+I+","+Me+")",j.fillRect(q,ee,1,1)}if("toDataURL"in Ee)return Ee.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Z=(re,fe)=>{const Ee=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let j;if(Ee!=null){let O,M,N;fe?.tensorLayout!==void 0&&fe.tensorLayout==="NHWC"?(O=re.dims[2],M=re.dims[1],N=re.dims[3]):(O=re.dims[3],M=re.dims[2],N=re.dims[1]);const K=fe!==void 0&&fe.format!==void 0?fe.format:"RGB",ae=fe?.norm;let $e,Te;ae===void 0||ae.mean===void 0?$e=[255,255,255,255]:typeof ae.mean=="number"?$e=[ae.mean,ae.mean,ae.mean,ae.mean]:($e=[ae.mean[0],ae.mean[1],ae.mean[2],255],ae.mean[3]!==void 0&&($e[3]=ae.mean[3])),ae===void 0||ae.bias===void 0?Te=[0,0,0,0]:typeof ae.bias=="number"?Te=[ae.bias,ae.bias,ae.bias,ae.bias]:(Te=[ae.bias[0],ae.bias[1],ae.bias[2],0],ae.bias[3]!==void 0&&(Te[3]=ae.bias[3]));const U=M*O;if(fe!==void 0&&(fe.format!==void 0&&N===4&&fe.format!=="RGBA"||N===3&&fe.format!=="RGB"&&fe.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const ue=4;let ke=0,te=1,ee=2,q=3,B=0,H=U,I=U*2,Me=-1;K==="RGBA"?(B=0,H=U,I=U*2,Me=U*3):K==="RGB"?(B=0,H=U,I=U*2):K==="RBG"&&(B=0,I=U,H=U*2),j=Ee.createImageData(O,M);for(let xe=0;xe<M*O;ke+=ue,te+=ue,ee+=ue,q+=ue,xe++)j.data[ke]=(re.data[B++]-Te[0])*$e[0],j.data[te]=(re.data[H++]-Te[1])*$e[1],j.data[ee]=(re.data[I++]-Te[2])*$e[2],j.data[q]=Me===-1?255:(re.data[Me++]-Te[3])*$e[3]}else throw new Error("Can not access image data");return j}},"./node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":(oe,R,T)=>{T.r(R)},"./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{bufferToTensor:()=>Z,tensorFromGpuBuffer:()=>Ee,tensorFromImage:()=>re,tensorFromPinnedBuffer:()=>j,tensorFromTexture:()=>fe});var E=T("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const Z=(O,M)=>{if(O===void 0)throw new Error("Image buffer must be defined");if(M.height===void 0||M.width===void 0)throw new Error("Image height and width must be defined");if(M.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:N,width:K}=M,ae=M.norm??{mean:255,bias:0};let $e,Te;typeof ae.mean=="number"?$e=[ae.mean,ae.mean,ae.mean,ae.mean]:$e=[ae.mean[0],ae.mean[1],ae.mean[2],ae.mean[3]??255],typeof ae.bias=="number"?Te=[ae.bias,ae.bias,ae.bias,ae.bias]:Te=[ae.bias[0],ae.bias[1],ae.bias[2],ae.bias[3]??0];const U=M.format!==void 0?M.format:"RGBA",ue=M.tensorFormat!==void 0&&M.tensorFormat!==void 0?M.tensorFormat:"RGB",ke=N*K,te=ue==="RGBA"?new Float32Array(ke*4):new Float32Array(ke*3);let ee=4,q=0,B=1,H=2,I=3,Me=0,xe=ke,Ce=ke*2,Ve=-1;U==="RGB"&&(ee=3,q=0,B=1,H=2,I=-1),ue==="RGBA"?Ve=ke*3:ue==="RBG"?(Me=0,Ce=ke,xe=ke*2):ue==="BGR"&&(Ce=0,xe=ke,Me=ke*2);for(let Ne=0;Ne<ke;Ne++,q+=ee,H+=ee,B+=ee,I+=ee)te[Me++]=(O[q]+Te[0])/$e[0],te[xe++]=(O[B]+Te[1])/$e[1],te[Ce++]=(O[H]+Te[2])/$e[2],Ve!==-1&&I!==-1&&(te[Ve++]=(O[I]+Te[3])/$e[3]);return ue==="RGBA"?new E.Tensor("float32",te,[1,4,N,K]):new E.Tensor("float32",te,[1,3,N,K])},re=async(O,M)=>{const N=typeof HTMLImageElement<"u"&&O instanceof HTMLImageElement,K=typeof ImageData<"u"&&O instanceof ImageData,ae=typeof ImageBitmap<"u"&&O instanceof ImageBitmap,$e=typeof O=="string";let Te,U=M??{};const ue=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},ke=te=>te instanceof HTMLCanvasElement||te instanceof OffscreenCanvas?te.getContext("2d"):null;if(N){const te=ue();te.width=O.width,te.height=O.height;const ee=ke(te);if(ee!=null){let q=O.height,B=O.width;if(M!==void 0&&M.resizedHeight!==void 0&&M.resizedWidth!==void 0&&(q=M.resizedHeight,B=M.resizedWidth),M!==void 0){if(U=M,M.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");U.tensorFormat="RGBA",U.height=q,U.width=B}else U.tensorFormat="RGBA",U.height=q,U.width=B;ee.drawImage(O,0,0),Te=ee.getImageData(0,0,B,q).data}else throw new Error("Can not access image data")}else if(K){let te,ee;if(M!==void 0&&M.resizedWidth!==void 0&&M.resizedHeight!==void 0?(te=M.resizedHeight,ee=M.resizedWidth):(te=O.height,ee=O.width),M!==void 0&&(U=M),U.format="RGBA",U.height=te,U.width=ee,M!==void 0){const q=ue();q.width=ee,q.height=te;const B=ke(q);if(B!=null)B.putImageData(O,0,0),Te=B.getImageData(0,0,ee,te).data;else throw new Error("Can not access image data")}else Te=O.data}else if(ae){if(M===void 0)throw new Error("Please provide image config with format for Imagebitmap");const te=ue();te.width=O.width,te.height=O.height;const ee=ke(te);if(ee!=null){const q=O.height,B=O.width;return ee.drawImage(O,0,0,B,q),Te=ee.getImageData(0,0,B,q).data,U.height=q,U.width=B,Z(Te,U)}else throw new Error("Can not access image data")}else{if($e)return new Promise((te,ee)=>{const q=ue(),B=ke(q);if(!O||!B)return ee();const H=new Image;H.crossOrigin="Anonymous",H.src=O,H.onload=()=>{q.width=H.width,q.height=H.height,B.drawImage(H,0,0,q.width,q.height);const I=B.getImageData(0,0,q.width,q.height);U.height=q.height,U.width=q.width,te(Z(I.data,U))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(Te!==void 0)return Z(Te,U);throw new Error("Input data provided is not supported - aborted tensor creation")},fe=(O,M)=>{const{width:N,height:K,download:ae,dispose:$e}=M,Te=[1,K,N,4];return new E.Tensor({location:"texture",type:"float32",texture:O,dims:Te,download:ae,dispose:$e})},Ee=(O,M)=>{const{dataType:N,dims:K,download:ae,dispose:$e}=M;return new E.Tensor({location:"gpu-buffer",type:N??"float32",gpuBuffer:O,dims:K,download:ae,dispose:$e})},j=(O,M,N)=>new E.Tensor({location:"cpu-pinned",type:O,data:M,dims:N??[M.length]})},"./node_modules/onnxruntime-common/dist/esm/tensor-factory.js":(oe,R,T)=>{T.r(R)},"./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":(oe,R,T)=>{T.r(R),T.d(R,{NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP:()=>Z,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP:()=>E,checkTypedArray:()=>fe});const E=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Z=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let re=!1;const fe=()=>{if(!re){re=!0;const Ee=typeof BigInt64Array<"u"&&BigInt64Array.from,j=typeof BigUint64Array<"u"&&BigUint64Array.from,O=typeof Float16Array<"u"&&Float16Array.from;Ee&&(E.set("int64",BigInt64Array),Z.set(BigInt64Array,"int64")),j&&(E.set("uint64",BigUint64Array),Z.set(BigUint64Array,"uint64")),O?(E.set("float16",Float16Array),Z.set(Float16Array,"float16")):E.set("float16",Uint16Array)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{Tensor:()=>Ee});var E=T("./node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"),Z=T("./node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"),re=T("./node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"),fe=T("./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js");class Ee{constructor(O,M,N){(0,re.checkTypedArray)();let K,ae;if(typeof O=="object"&&"location"in O)switch(this.dataLocation=O.location,K=O.type,ae=O.dims,O.location){case"cpu-pinned":{const Te=re.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(K);if(!Te)throw new TypeError(`unsupported type "${K}" to create tensor from pinned buffer`);if(!(O.data instanceof Te))throw new TypeError(`buffer should be of type ${Te.name}`);this.cpuData=O.data;break}case"texture":{if(K!=="float32")throw new TypeError(`unsupported type "${K}" to create tensor from texture`);this.gpuTextureData=O.texture,this.downloader=O.download,this.disposer=O.dispose;break}case"gpu-buffer":{if(K!=="float32"&&K!=="float16"&&K!=="int32"&&K!=="int64"&&K!=="uint32"&&K!=="uint8"&&K!=="bool")throw new TypeError(`unsupported type "${K}" to create tensor from gpu buffer`);this.gpuBufferData=O.gpuBuffer,this.downloader=O.download,this.disposer=O.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let Te,U;if(typeof O=="string")if(K=O,U=N,O==="string"){if(!Array.isArray(M))throw new TypeError("A string tensor's data must be a string array.");Te=M}else{const ue=re.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(O);if(ue===void 0)throw new TypeError(`Unsupported tensor type: ${O}.`);if(Array.isArray(M)){if(O==="float16"&&ue===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");O==="uint64"||O==="int64"?Te=ue.from(M,BigInt):Te=ue.from(M)}else if(M instanceof ue)Te=M;else throw new TypeError(`A ${K} tensor's data must be type of ${ue}`)}else if(U=M,Array.isArray(O)){if(O.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const ue=typeof O[0];if(ue==="string")K="string",Te=O;else if(ue==="boolean")K="bool",Te=Uint8Array.from(O);else throw new TypeError(`Invalid element type of data array: ${ue}.`)}else{const ue=re.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(O.constructor);if(ue===void 0)throw new TypeError(`Unsupported type for tensor data: ${O.constructor}.`);K=ue,Te=O}if(U===void 0)U=[Te.length];else if(!Array.isArray(U))throw new TypeError("A tensor's dims must be a number array");ae=U,this.cpuData=Te,this.dataLocation="cpu"}const $e=(0,fe.calculateSize)(ae);if(this.cpuData&&$e!==this.cpuData.length)throw new Error(`Tensor's size(${$e}) does not match data length(${this.cpuData.length}).`);this.type=K,this.dims=ae,this.size=$e}static async fromImage(O,M){return(0,Z.tensorFromImage)(O,M)}static fromTexture(O,M){return(0,Z.tensorFromTexture)(O,M)}static fromGpuBuffer(O,M){return(0,Z.tensorFromGpuBuffer)(O,M)}static fromPinnedBuffer(O,M,N){return(0,Z.tensorFromPinnedBuffer)(O,M,N)}toDataURL(O){return(0,E.tensorToDataURL)(this,O)}toImageData(O){return(0,E.tensorToImageData)(this,O)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(O){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const M=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=M,O&&this.disposer&&(this.disposer(),this.disposer=void 0),M}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(O){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return(0,fe.tensorReshape)(this,O)}}},"./node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{calculateSize:()=>Z,tensorReshape:()=>re});var E=T("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const Z=fe=>{let Ee=1;for(let j=0;j<fe.length;j++){const O=fe[j];if(typeof O!="number"||!Number.isSafeInteger(O))throw new TypeError(`dims[${j}] must be an integer, got: ${O}`);if(O<0)throw new RangeError(`dims[${j}] must be a non-negative integer, got: ${O}`);Ee*=O}return Ee},re=(fe,Ee)=>{switch(fe.location){case"cpu":return new E.Tensor(fe.type,fe.data,Ee);case"cpu-pinned":return new E.Tensor({location:"cpu-pinned",data:fe.data,type:fe.type,dims:Ee});case"texture":return new E.Tensor({location:"texture",texture:fe.texture,type:fe.type,dims:Ee});case"gpu-buffer":return new E.Tensor({location:"gpu-buffer",gpuBuffer:fe.gpuBuffer,type:fe.type,dims:Ee});default:throw new Error(`tensorReshape: tensor location ${fe.location} is not supported`)}}},"./node_modules/onnxruntime-common/dist/esm/tensor.js":(oe,R,T)=>{T.r(R),T.d(R,{Tensor:()=>Z});var E=T("./node_modules/onnxruntime-common/dist/esm/tensor-impl.js");const Z=E.Tensor},"./node_modules/onnxruntime-common/dist/esm/trace.js":(oe,R,T)=>{T.r(R),T.d(R,{TRACE:()=>Z,TRACE_FUNC_BEGIN:()=>fe,TRACE_FUNC_END:()=>Ee});var E=T("./node_modules/onnxruntime-common/dist/esm/env-impl.js");const Z=(j,O)=>{(typeof E.env.trace>"u"?!E.env.wasm.trace:!E.env.trace)||console.timeStamp(`${j}::ORT::${O}`)},re=(j,O)=>{const M=new Error().stack?.split(/\r\n|\r|\n/g)||[];let N=!1;for(let K=0;K<M.length;K++){if(N&&!M[K].includes("TRACE_FUNC")){let ae=`FUNC_${j}::${M[K].trim().split(" ")[1]}`;O&&(ae+=`::${O}`),Z("CPU",ae);return}M[K].includes("TRACE_FUNC")&&(N=!0)}},fe=j=>{(typeof E.env.trace>"u"?!E.env.wasm.trace:!E.env.trace)||re("BEGIN",j)},Ee=j=>{(typeof E.env.trace>"u"?!E.env.wasm.trace:!E.env.trace)||re("END",j)}},"./node_modules/onnxruntime-common/dist/esm/training-session-impl.js":(oe,R,T)=>{T.r(R),T.d(R,{TrainingSession:()=>fe});var E=T("./node_modules/onnxruntime-common/dist/esm/backend-impl.js"),Z=T("./node_modules/onnxruntime-common/dist/esm/tensor.js");const re="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";class fe{constructor(j,O,M){this.handler=j,this.hasOptimizerModel=O,this.hasEvalModel=M}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(j,O){const M=j.evalModel||"",N=j.optimizerModel||"",K=O||{},[ae,$e]=await(0,E.resolveBackendAndExecutionProviders)(K);if(ae.createTrainingSessionHandler){const Te=await ae.createTrainingSessionHandler(j.checkpointState,j.trainModel,M,N,$e);return new fe(Te,!!j.optimizerModel,!!j.evalModel)}else throw new Error(re)}typeNarrowingForRunStep(j,O,M,N,K){const ae={};let $e={};if(typeof M!="object"||M===null||M instanceof Z.Tensor||Array.isArray(M))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let Te=!0;if(typeof N=="object"){if(N===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(N instanceof Z.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(N)){if(N.length===0)throw new TypeError("'fetches' cannot be an empty array.");Te=!1;for(const U of N){if(typeof U!="string")throw new TypeError("'fetches' must be a string array or an object.");if(O.indexOf(U)===-1)throw new RangeError(`'fetches' contains invalid output name: ${U}.`);ae[U]=null}if(typeof K=="object"&&K!==null)$e=K;else if(typeof K<"u")throw new TypeError("'options' must be an object.")}else{let U=!1;const ue=Object.getOwnPropertyNames(N);for(const ke of O)if(ue.indexOf(ke)!==-1){const te=N[ke];(te===null||te instanceof Z.Tensor)&&(U=!0,Te=!1,ae[ke]=te)}if(U){if(typeof K=="object"&&K!==null)$e=K;else if(typeof K<"u")throw new TypeError("'options' must be an object.")}else $e=N}}else if(typeof N<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const U of j)if(typeof M[U]>"u")throw new Error(`input '${U}' is missing in 'feeds'.`);if(Te)for(const U of O)ae[U]=null;return[ae,$e]}convertHandlerReturnTypeToMapOfTensors(j){const O={};for(const M in j)if(Object.hasOwnProperty.call(j,M)){const N=j[M];N instanceof Z.Tensor?O[M]=N:O[M]=new Z.Tensor(N.type,N.data,N.dims)}return O}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(j,O,M){const[N,K]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,j,O,M),ae=await this.handler.runTrainStep(j,N,K);return this.convertHandlerReturnTypeToMapOfTensors(ae)}async runOptimizerStep(j){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(j||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(j,O,M){if(this.hasEvalModel){const[N,K]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,j,O,M),ae=await this.handler.runEvalStep(j,N,K);return this.convertHandlerReturnTypeToMapOfTensors(ae)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(j=!0){return this.handler.getParametersSize(j)}async loadParametersBuffer(j,O=!0){const M=await this.getParametersSize(O);if(j.length!==4*M)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(j,O)}async getContiguousParameters(j=!0){return this.handler.getContiguousParameters(j)}async release(){return this.handler.dispose()}}},"./node_modules/onnxruntime-common/dist/esm/training-session.js":(oe,R,T)=>{T.r(R),T.d(R,{TrainingSession:()=>Z});var E=T("./node_modules/onnxruntime-common/dist/esm/training-session-impl.js");const Z=E.TrainingSession},"./node_modules/onnxruntime-common/dist/esm/version.js":(oe,R,T)=>{T.r(R),T.d(R,{version:()=>E});const E="1.19.2"},"./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs":(oe,R,T)=>{T.r(R),T.d(R,{InferenceSession:()=>kt,TRACE:()=>st,TRACE_FUNC_BEGIN:()=>rt,TRACE_FUNC_END:()=>Qe,Tensor:()=>X,TrainingSession:()=>pt,default:()=>Um,env:()=>I,registerBackend:()=>$e});/*!
 * ONNX Runtime Web v1.21.0-dev.20241024-d9ca84ef96
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var E=Object.defineProperty,Z=Object.getOwnPropertyDescriptor,re=Object.getOwnPropertyNames,fe=Object.prototype.hasOwnProperty,Ee=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),j=(e,t)=>()=>(e&&(t=e(e=0)),t),O=(e,t)=>{for(var r in t)E(e,r,{get:t[r],enumerable:!0})},M=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of re(t))!fe.call(e,i)&&i!==r&&E(e,i,{get:()=>t[i],enumerable:!(n=Z(t,i))||n.enumerable});return e},N=e=>M(E({},"__esModule",{value:!0}),e),K,ae,$e,Te,U,ue=j(()=>{K=new Map,ae=[],$e=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let n=K.get(e);if(n===void 0)K.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let i=ae.indexOf(e);i!==-1&&ae.splice(i,1);for(let s=0;s<ae.length;s++)if(K.get(ae[s]).priority<=r){ae.splice(s,0,e);return}ae.push(e)}return}throw new TypeError("not a valid backend")},Te=async e=>{let t=K.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(n){return r||(t.error=`${n}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},U=async e=>{let t=e.executionProviders||[],r=t.map(d=>typeof d=="string"?d:d.name),n=r.length===0?ae:r,i,s=[],o=new Set;for(let d of n){let h=await Te(d);typeof h=="string"?s.push({name:d,err:h}):(i||(i=h),i===h&&o.add(d))}if(!i)throw new Error(`no available backend found. ERR: ${s.map(d=>`[${d.name}] ${d.err}`).join(", ")}`);for(let{name:d,err:h}of s)r.includes(d)&&console.warn(`removing requested execution provider "${d}" from session options because it is not available: ${h}`);let u=t.filter(d=>o.has(typeof d=="string"?d:d.name));return[i,new Proxy(e,{get:(d,h)=>h==="executionProviders"?u:Reflect.get(d,h)})]}}),ke=j(()=>{ue()}),te,ee=j(()=>{te="1.20.0-dev.20241016-2b8fc5529b"}),q,B,H=j(()=>{ee(),q="warning",B={wasm:{},webgl:{},webgpu:{},versions:{common:te},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);q=e}},get logLevel(){return q}},Object.defineProperty(B,"logLevel",{enumerable:!0})}),I,Me=j(()=>{H(),I=B}),xe,Ce,Ve=j(()=>{xe=(e,t)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext("2d");if(n!=null){let i,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(i=e.dims[2],s=e.dims[3]):(i=e.dims[3],s=e.dims[2]);let o=t?.format!==void 0?t.format:"RGB",u=t?.norm,d,h;u===void 0||u.mean===void 0?d=[255,255,255,255]:typeof u.mean=="number"?d=[u.mean,u.mean,u.mean,u.mean]:(d=[u.mean[0],u.mean[1],u.mean[2],0],u.mean[3]!==void 0&&(d[3]=u.mean[3])),u===void 0||u.bias===void 0?h=[0,0,0,0]:typeof u.bias=="number"?h=[u.bias,u.bias,u.bias,u.bias]:(h=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(h[3]=u.bias[3]));let y=s*i,l=0,x=y,A=y*2,P=-1;o==="RGBA"?(l=0,x=y,A=y*2,P=y*3):o==="RGB"?(l=0,x=y,A=y*2):o==="RBG"&&(l=0,A=y,x=y*2);for(let S=0;S<s;S++)for(let Q=0;Q<i;Q++){let Y=(e.data[l++]-h[0])*d[0],D=(e.data[x++]-h[1])*d[1],ne=(e.data[A++]-h[2])*d[2],he=P===-1?255:(e.data[P++]-h[3])*d[3];n.fillStyle="rgba("+Y+","+D+","+ne+","+he+")",n.fillRect(Q,S,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Ce=(e,t)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),n;if(r!=null){let i,s,o;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(i=e.dims[2],s=e.dims[1],o=e.dims[3]):(i=e.dims[3],s=e.dims[2],o=e.dims[1]);let u=t!==void 0&&t.format!==void 0?t.format:"RGB",d=t?.norm,h,y;d===void 0||d.mean===void 0?h=[255,255,255,255]:typeof d.mean=="number"?h=[d.mean,d.mean,d.mean,d.mean]:(h=[d.mean[0],d.mean[1],d.mean[2],255],d.mean[3]!==void 0&&(h[3]=d.mean[3])),d===void 0||d.bias===void 0?y=[0,0,0,0]:typeof d.bias=="number"?y=[d.bias,d.bias,d.bias,d.bias]:(y=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(y[3]=d.bias[3]));let l=s*i;if(t!==void 0&&(t.format!==void 0&&o===4&&t.format!=="RGBA"||o===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let x=4,A=0,P=1,S=2,Q=3,Y=0,D=l,ne=l*2,he=-1;u==="RGBA"?(Y=0,D=l,ne=l*2,he=l*3):u==="RGB"?(Y=0,D=l,ne=l*2):u==="RBG"&&(Y=0,ne=l,D=l*2),n=r.createImageData(i,s);for(let be=0;be<s*i;A+=x,P+=x,S+=x,Q+=x,be++)n.data[A]=(e.data[Y++]-y[0])*h[0],n.data[P]=(e.data[D++]-y[1])*h[1],n.data[S]=(e.data[ne++]-y[2])*h[2],n.data[Q]=he===-1?255:(e.data[he++]-y[3])*h[3]}else throw new Error("Can not access image data");return n}}),Ue,Ne,Pe,Ae,ie,F,se=j(()=>{et(),Ue=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:n}=t,i=t.norm??{mean:255,bias:0},s,o;typeof i.mean=="number"?s=[i.mean,i.mean,i.mean,i.mean]:s=[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],typeof i.bias=="number"?o=[i.bias,i.bias,i.bias,i.bias]:o=[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let u=t.format!==void 0?t.format:"RGBA",d=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",h=r*n,y=d==="RGBA"?new Float32Array(h*4):new Float32Array(h*3),l=4,x=0,A=1,P=2,S=3,Q=0,Y=h,D=h*2,ne=-1;u==="RGB"&&(l=3,x=0,A=1,P=2,S=-1),d==="RGBA"?ne=h*3:d==="RBG"?(Q=0,D=h,Y=h*2):d==="BGR"&&(D=0,Y=h,Q=h*2);for(let he=0;he<h;he++,x+=l,P+=l,A+=l,S+=l)y[Q++]=(e[x]+o[0])/s[0],y[Y++]=(e[A]+o[1])/s[1],y[D++]=(e[P]+o[2])/s[2],ne!==-1&&S!==-1&&(y[ne++]=(e[S]+o[3])/s[3]);return d==="RGBA"?new xt("float32",y,[1,4,r,n]):new xt("float32",y,[1,3,r,n])},Ne=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,n=typeof ImageData<"u"&&e instanceof ImageData,i=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",o,u=t??{},d=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},h=y=>typeof HTMLCanvasElement<"u"&&y instanceof HTMLCanvasElement||y instanceof OffscreenCanvas?y.getContext("2d"):null;if(r){let y=d();y.width=e.width,y.height=e.height;let l=h(y);if(l!=null){let x=e.height,A=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(x=t.resizedHeight,A=t.resizedWidth),t!==void 0){if(u=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");u.tensorFormat="RGBA",u.height=x,u.width=A}else u.tensorFormat="RGBA",u.height=x,u.width=A;l.drawImage(e,0,0),o=l.getImageData(0,0,A,x).data}else throw new Error("Can not access image data")}else if(n){let y,l;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(y=t.resizedHeight,l=t.resizedWidth):(y=e.height,l=e.width),t!==void 0&&(u=t),u.format="RGBA",u.height=y,u.width=l,t!==void 0){let x=d();x.width=l,x.height=y;let A=h(x);if(A!=null)A.putImageData(e,0,0),o=A.getImageData(0,0,l,y).data;else throw new Error("Can not access image data")}else o=e.data}else if(i){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let y=d();y.width=e.width,y.height=e.height;let l=h(y);if(l!=null){let x=e.height,A=e.width;return l.drawImage(e,0,0,A,x),o=l.getImageData(0,0,A,x).data,u.height=x,u.width=A,Ue(o,u)}else throw new Error("Can not access image data")}else{if(s)return new Promise((y,l)=>{let x=d(),A=h(x);if(!e||!A)return l();let P=new Image;P.crossOrigin="Anonymous",P.src=e,P.onload=()=>{x.width=P.width,x.height=P.height,A.drawImage(P,0,0,x.width,x.height);let S=A.getImageData(0,0,x.width,x.height);u.height=x.height,u.width=x.width,y(Ue(S.data,u))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return Ue(o,u);throw new Error("Input data provided is not supported - aborted tensor creation")},Pe=(e,t)=>{let{width:r,height:n,download:i,dispose:s}=t,o=[1,n,r,4];return new xt({location:"texture",type:"float32",texture:e,dims:o,download:i,dispose:s})},Ae=(e,t)=>{let{dataType:r,dims:n,download:i,dispose:s}=t;return new xt({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:i,dispose:s})},ie=(e,t)=>{let{dataType:r,dims:n,download:i,dispose:s}=t;return new xt({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:n,download:i,dispose:s})},F=(e,t,r)=>new xt({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})}),_e,Oe,nt,de,Re=j(()=>{_e=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Oe=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),nt=!1,de=()=>{if(!nt){nt=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,r=typeof Float16Array<"u"&&Float16Array.from;e&&(_e.set("int64",BigInt64Array),Oe.set(BigInt64Array,"int64")),t&&(_e.set("uint64",BigUint64Array),Oe.set(BigUint64Array,"uint64")),r?(_e.set("float16",Float16Array),Oe.set(Float16Array,"float16")):_e.set("float16",Uint16Array)}}}),it,He,wt=j(()=>{et(),it=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if(typeof n!="number"||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},He=(e,t)=>{switch(e.location){case"cpu":return new xt(e.type,e.data,t);case"cpu-pinned":return new xt({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new xt({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new xt({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new xt({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),xt,et=j(()=>{Ve(),se(),Re(),wt(),xt=class{constructor(e,t,r){de();let n,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,n=e.type,i=e.dims,e.location){case"cpu-pinned":{let o=_e.get(n);if(!o)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=e.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint64"&&n!=="int8"&&n!=="uint8"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,u;if(typeof e=="string")if(n=e,u=r,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{let d=_e.get(e);if(d===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&d===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${d.name} as data.`);e==="uint64"||e==="int64"?o=d.from(t,BigInt):o=d.from(t)}else if(t instanceof d)o=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")o=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${n} tensor's data must be type of ${d}`)}else if(u=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let d=typeof e[0];if(d==="string")n="string",o=e;else if(d==="boolean")n="bool",o=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${d}.`)}else if(e instanceof Uint8ClampedArray)n="uint8",o=Uint8Array.from(e);else{let d=Oe.get(e.constructor);if(d===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=d,o=e}if(u===void 0)u=[o.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");i=u,this.cpuData=o,this.dataLocation="cpu"}let s=it(i);if(this.cpuData&&s!==this.cpuData.length&&!((n==="uint4"||n==="int4")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=i,this.size=s}static async fromImage(e,t){return Ne(e,t)}static fromTexture(e,t){return Pe(e,t)}static fromGpuBuffer(e,t){return Ae(e,t)}static fromMLTensor(e,t){return ie(e,t)}static fromPinnedBuffer(e,t,r){return F(e,t,r)}toDataURL(e){return xe(this,e)}toImageData(e){return Ce(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return He(this,e)}}}),X,Be=j(()=>{et(),X=xt}),st,lt,rt,Qe,_t=j(()=>{H(),st=(e,t)=>{(typeof B.trace>"u"?!B.wasm.trace:!B.trace)||console.timeStamp(`${e}::ORT::${t}`)},lt=(e,t)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],n=!1;for(let i=0;i<r.length;i++){if(n&&!r[i].includes("TRACE_FUNC")){let s=`FUNC_${e}::${r[i].trim().split(" ")[1]}`;t&&(s+=`::${t}`),st("CPU",s);return}r[i].includes("TRACE_FUNC")&&(n=!0)}},rt=e=>{(typeof B.trace>"u"?!B.wasm.trace:!B.trace)||lt("BEGIN",e)},Qe=e=>{(typeof B.trace>"u"?!B.wasm.trace:!B.trace)||lt("END",e)}}),yt,Lt=j(()=>{ue(),Be(),_t(),yt=class Tm{constructor(t){this.handler=t}async run(t,r,n){rt();let i={},s={};if(typeof t!="object"||t===null||t instanceof X||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof X)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let h of r){if(typeof h!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(h)===-1)throw new RangeError(`'fetches' contains invalid output name: ${h}.`);i[h]=null}if(typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let h=!1,y=Object.getOwnPropertyNames(r);for(let l of this.outputNames)if(y.indexOf(l)!==-1){let x=r[l];(x===null||x instanceof X)&&(h=!0,o=!1,i[l]=x)}if(h){if(typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let h of this.inputNames)if(typeof t[h]>"u")throw new Error(`input '${h}' is missing in 'feeds'.`);if(o)for(let h of this.outputNames)i[h]=null;let u=await this.handler.run(t,i,s),d={};for(let h in u)if(Object.hasOwnProperty.call(u,h)){let y=u[h];y instanceof X?d[h]=y:d[h]=new X(y.type,y.data,y.dims)}return Qe(),d}async release(){return this.handler.dispose()}static async create(t,r,n,i){rt();let s,o={};if(typeof t=="string"){if(s=t,typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let y=t,l=0,x=t.byteLength;if(typeof r=="object"&&r!==null)o=r;else if(typeof r=="number"){if(l=r,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=y.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${y.byteLength}).`);if(x=t.byteLength-l,typeof n=="number"){if(x=n,!Number.isSafeInteger(x))throw new RangeError("'byteLength' must be an integer.");if(x<=0||l+x>y.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${y.byteLength-l}].`);if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(typeof n<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(y,l,x)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[u,d]=await U(o),h=await u.createInferenceSessionHandler(s,d);return Qe(),new Tm(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),kt,$=j(()=>{Lt(),kt=yt}),J=j(()=>{}),z=j(()=>{}),pe=j(()=>{}),Se=j(()=>{}),dt,at,At=j(()=>{ue(),Be(),dt="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",at=class Em{constructor(t,r,n){this.handler=t,this.hasOptimizerModel=r,this.hasEvalModel=n}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(t,r){let n=t.evalModel||"",i=t.optimizerModel||"",s=r||{},[o,u]=await U(s);if(o.createTrainingSessionHandler){let d=await o.createTrainingSessionHandler(t.checkpointState,t.trainModel,n,i,u);return new Em(d,!!t.optimizerModel,!!t.evalModel)}else throw new Error(dt)}typeNarrowingForRunStep(t,r,n,i,s){let o={},u={};if(typeof n!="object"||n===null||n instanceof X||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let d=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof X)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");d=!1;for(let h of i){if(typeof h!="string")throw new TypeError("'fetches' must be a string array or an object.");if(r.indexOf(h)===-1)throw new RangeError(`'fetches' contains invalid output name: ${h}.`);o[h]=null}if(typeof s=="object"&&s!==null)u=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else{let h=!1,y=Object.getOwnPropertyNames(i);for(let l of r)if(y.indexOf(l)!==-1){let x=i[l];(x===null||x instanceof X)&&(h=!0,d=!1,o[l]=x)}if(h){if(typeof s=="object"&&s!==null)u=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else u=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let h of t)if(typeof n[h]>"u")throw new Error(`input '${h}' is missing in 'feeds'.`);if(d)for(let h of r)o[h]=null;return[o,u]}convertHandlerReturnTypeToMapOfTensors(t){let r={};for(let n in t)if(Object.hasOwnProperty.call(t,n)){let i=t[n];i instanceof X?r[n]=i:r[n]=new X(i.type,i.data,i.dims)}return r}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(t,r,n){let[i,s]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,t,r,n),o=await this.handler.runTrainStep(t,i,s);return this.convertHandlerReturnTypeToMapOfTensors(o)}async runOptimizerStep(t){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(t||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(t,r,n){if(this.hasEvalModel){let[i,s]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,t,r,n),o=await this.handler.runEvalStep(t,i,s);return this.convertHandlerReturnTypeToMapOfTensors(o)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(t=!0){return this.handler.getParametersSize(t)}async loadParametersBuffer(t,r=!0){let n=await this.getParametersSize(r);if(t.length!==4*n)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(t,r)}async getContiguousParameters(t=!0){return this.handler.getContiguousParameters(t)}async release(){return this.handler.dispose()}}}),pt,bt=j(()=>{At(),pt=at}),C={};O(C,{InferenceSession:()=>kt,TRACE:()=>st,TRACE_FUNC_BEGIN:()=>rt,TRACE_FUNC_END:()=>Qe,Tensor:()=>X,TrainingSession:()=>pt,env:()=>I,registerBackend:()=>$e});var c=j(()=>{ke(),Me(),$(),Be(),J(),z(),_t(),pe(),Se(),bt()}),m=j(()=>{}),W={};O(W,{default:()=>Xe});var we,Fe,Xe,sr=j(()=>{Sh(),zr(),Nt(),we="ort-wasm-proxy-worker",Fe=globalThis.self?.name===we,Fe&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":jr(r.wasm).then(()=>{ip(r).then(()=>{postMessage({type:t})},n=>{postMessage({type:t,err:n})})},n=>{postMessage({type:t,err:n})});break;case"init-ep":{let{epName:n,env:i}=r;sp(i,n).then(()=>{postMessage({type:t})},s=>{postMessage({type:t,err:s})});break}case"copy-from":{let{buffer:n}=r,i=vc(n);postMessage({type:t,out:i});break}case"create":{let{model:n,options:i}=r;op(n,i).then(s=>{postMessage({type:t,out:s})},s=>{postMessage({type:t,err:s})});break}case"release":ap(r),postMessage({type:t});break;case"run":{let{sessionId:n,inputIndices:i,inputs:s,outputIndices:o,options:u}=r;up(n,i,s,o,new Array(o.length).fill(null),u).then(d=>{d.some(h=>h[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:d},cp([...s,...d]))},d=>{postMessage({type:t,err:d})});break}case"end-profiling":dp(r),postMessage({type:t});break;default:}}catch(n){postMessage({type:t,err:n})}}),Xe=Fe?null:e=>new Worker(e??Ze,{type:"module",name:we})}),ot={};O(ot,{default:()=>Ie});var V,ve,Ie,je=j(()=>{ve=(V=import.meta.url,async function(e={}){function t(){return or.buffer!=xr.buffer&&vn(),xr}function r(){return or.buffer!=xr.buffer&&vn(),Xt}function n(){return or.buffer!=xr.buffer&&vn(),yr}function i(){return or.buffer!=xr.buffer&&vn(),ut}function s(){return or.buffer!=xr.buffer&&vn(),St}function o(){return or.buffer!=xr.buffer&&vn(),mr}function u(){return or.buffer!=xr.buffer&&vn(),Wr}function d(){return or.buffer!=xr.buffer&&vn(),Dn}var h,y,l=Object.assign({},e),x=new Promise((a,f)=>{h=a,y=f}),A=typeof window=="object",P=typeof importScripts=="function",S=P&&self.name=="em-pthread";l.mountExternalData=(a,f)=>{a.startsWith("./")&&(a=a.substring(2)),(l.Eb||(l.Eb=new Map)).set(a,f)},l.unmountExternalData=()=>{delete l.Eb};var Q=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let Y=()=>{let a=(b,k,L)=>(...ge)=>{let tt=ui,gt=k?.();ge=b(...ge);let Rt=k?.();return gt!==Rt&&(b=Rt,L(gt),k=L=null),ui!=tt?new Promise((Gt,nr)=>{Ap={resolve:Gt,reject:nr}}):ge},f=b=>async(...k)=>{try{if(l.Fb)throw Error("Session already started");let L=l.Fb={fc:k[0],errors:[]},ge=await b(...k);if(l.Fb!==L)throw Error("Session mismatch");l.Gb?.flush();let tt=L.errors;if(0<tt.length){let gt=await Promise.all(tt);if(gt=gt.filter(Rt=>Rt),0<gt.length)throw Error(gt.join(`
`))}return ge}finally{l.Fb=null}};l._OrtCreateSession=a(l._OrtCreateSession,()=>l._OrtCreateSession,b=>l._OrtCreateSession=b),l._OrtRun=f(a(l._OrtRun,()=>l._OrtRun,b=>l._OrtRun=b)),l._OrtRunWithBinding=f(a(l._OrtRunWithBinding,()=>l._OrtRunWithBinding,b=>l._OrtRunWithBinding=b)),l._OrtBindInput=a(l._OrtBindInput,()=>l._OrtBindInput,b=>l._OrtBindInput=b),Y=void 0};l.jsepInit=(a,f)=>{if(Y?.(),a==="webgpu"){[l.Gb,l.Ub,l.Yb,l.Nb,l.Xb,l.jb,l.Zb,l.bc,l.Vb,l.Wb,l.$b]=f;let b=l.Gb;l.jsepRegisterBuffer=(k,L,ge,tt)=>b.registerBuffer(k,L,ge,tt),l.jsepGetBuffer=k=>b.getBuffer(k),l.jsepCreateDownloader=(k,L,ge)=>b.createDownloader(k,L,ge),l.jsepOnCreateSession=k=>{b.onCreateSession(k)},l.jsepOnReleaseSession=k=>{b.onReleaseSession(k)},l.jsepOnRunStart=k=>b.onRunStart(k),l.cc=(k,L)=>{b.upload(k,L)}}else if(a==="webnn"){[l.Gb,l.ac,l.Ob,l.jsepEnsureTensor,l.dc,l.jsepDownloadTensor]=f,l.jsepReleaseTensorId=l.Ob;let b=l.Gb;l.jsepOnRunStart=k=>b.onRunStart(k),l.jsepRegisterMLContext=(k,L)=>{b.registerMLContext(k,L)},l.jsepOnReleaseSession=k=>{b.onReleaseSession(k)},l.jsepCreateMLTensorDownloader=(k,L)=>b.createMLTensorDownloader(k,L),l.jsepRegisterMLTensor=(k,L,ge)=>b.registerMLTensor(k,L,ge),l.qc=(k,L,ge,tt,gt)=>b.registerMLConstant(k,L,ge,tt,gt,l.Eb)}};var D,ne,he=Object.assign({},l),be="./this.program",Ye=(a,f)=>{throw f},ze="";(A||P)&&(P?ze=self.location.href:typeof document<"u"&&document.currentScript&&(ze=document.currentScript.src),V&&(ze=V),ze=ze.startsWith("blob:")?"":ze.substr(0,ze.replace(/[?#].*/,"").lastIndexOf("/")+1),P&&(ne=a=>{var f=new XMLHttpRequest;return f.open("GET",a,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),D=(a,f,b)=>{var k=new XMLHttpRequest;k.open("GET",a,!0),k.responseType="arraybuffer",k.onload=()=>{k.status==200||k.status==0&&k.response?f(k.response):b()},k.onerror=b,k.send(null)});var Mt,Vt=console.log.bind(console),jt=console.error.bind(console),lr=Vt,Zt=jt;if(Object.assign(l,he),he=null,S){let a=function(f){try{var b=f.data,k=b.cmd;if(k==="load"){let L=[];self.onmessage=ge=>L.push(ge),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let ge of L)a(ge);self.onmessage=a};for(let ge of b.handlers)l[ge]&&!l[ge].proxy||(l[ge]=(...tt)=>{postMessage({Mb:"callHandler",oc:ge,args:tt})},ge=="print"&&(lr=l[ge]),ge=="printErr"&&(Zt=l[ge]));or=b.wasmMemory,vn(),ur(b.wasmModule)}else if(k==="run"){Bp(b.pthread_ptr,0,0,1,0,0),Sp(b.pthread_ptr),Gm(),Zh(),Sr||(Yf(),Sr=!0);try{qm(b.start_routine,b.arg)}catch(L){if(L!="unwind")throw L}}else k==="cancel"?ia()&&Bc(-1):b.target!=="setimmediate"&&(k==="checkMailbox"?Sr&&Cc():k&&(Zt(`worker: received unknown command ${k}`),Zt(b)))}catch(L){throw Qf(),L}};var ur,Sr=!1;Zt=function(...f){f=f.join(" "),console.error(f)},self.alert=function(...f){postMessage({Mb:"alert",text:f.join(" "),rc:ia()})},l.instantiateWasm=(f,b)=>new Promise(k=>{ur=L=>{L=new WebAssembly.Instance(L,Hh()),b(L),k()}}),self.onunhandledrejection=f=>{throw f.reason||f},self.onmessage=a}l.wasmBinary&&(Mt=l.wasmBinary);var or,Yt,Tr,xr,Xt,yr,ut,St,mr,Wr,qr,Gn,Dn,Cn=!1;function vn(){var a=or.buffer;l.HEAP8=xr=new Int8Array(a),l.HEAP16=yr=new Int16Array(a),l.HEAPU8=Xt=new Uint8Array(a),l.HEAPU16=ut=new Uint16Array(a),l.HEAP32=St=new Int32Array(a),l.HEAPU32=mr=new Uint32Array(a),l.HEAPF32=Wr=new Float32Array(a),l.HEAPF64=Dn=new Float64Array(a),l.HEAP64=qr=new BigInt64Array(a),l.HEAPU64=Gn=new BigUint64Array(a)}if(!S){if(!((or=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof Q))throw Zt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");vn()}var mn=[],gn=[],Qi=[],Zi=0,Ms=null;function Uh(){if(--Zi==0&&Ms){var a=Ms;Ms=null,a()}}function ta(a){throw Zt(a="Aborted("+a+")"),Cn=!0,Tr=1,a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info."),y(a),a}var gp,Vh=a=>a.startsWith("data:application/octet-stream;base64,"),Wh=a=>a.startsWith("file://");function Gh(a){if(a==gp&&Mt)return new Uint8Array(Mt);if(ne)return ne(a);throw"both async and sync fetching of the wasm failed"}function qh(a,f,b){return function(k){if(!Mt&&(A||P)){if(typeof fetch=="function"&&!Wh(k))return fetch(k,{credentials:"same-origin"}).then(L=>{if(!L.ok)throw`failed to load wasm binary file at '${k}'`;return L.arrayBuffer()}).catch(()=>Gh(k));if(D)return new Promise((L,ge)=>{D(k,tt=>L(new Uint8Array(tt)),ge)})}return Promise.resolve().then(()=>Gh(k))}(a).then(k=>WebAssembly.instantiate(k,f)).then(b,k=>{Zt(`failed to asynchronously prepare wasm: ${k}`),ta(k)})}function Hh(){return{a:{O:Wm,Aa:Vm,b:Km,aa:rf,B:of,qa:af,Y:uf,_:df,ra:cf,oa:pf,ha:hf,na:ff,L:mf,Z:gf,W:_f,pa:wf,X:yf,wa:Xm,F:Ym,Q:Qm,P:Jm,E:tg,u:rg,q:ng,G:ig,A:cg,R:pg,ua:hg,ka:fg,U:mg,ba:gg,H:_g,ja:Sp,ta:wg,t:yg,x:vg,n:xg,l:Eg,c:Cp,o:Cg,j:kg,w:Pg,p:Ag,g:Ig,s:Fg,m:Og,e:Bg,k:Dg,i:zg,h:Lg,d:Rg,ea:Ng,fa:jg,ga:Ug,ca:Ff,da:Of,T:Vg,f:Wg,D:Gg,I:qg,M:Hg,y:Kg,sa:Xg,V:Yg,v:Df,z:Qg,N:Zg,S:Jg,za:e_,ya:t_,la:Rf,ma:Nf,$:Mp,C:jf,K:Uf,ia:Vf,J:Wf,a:or,xa:bp,va:Hf,r:i_}}}var _p={867364:(a,f,b,k,L)=>{if(l===void 0||!l.Eb)return 1;if((a=wn(a>>>0)).startsWith("./")&&(a=a.substring(2)),!(a=l.Eb.get(a)))return 2;if(k>>>=0,(f>>>=0)+(b>>>=0)>a.byteLength)return 3;try{let ge=a.subarray(f,f+b);switch(L){case 0:r().set(ge,k>>>0);break;case 1:l.cc(k,ge);break;default:return 4}return 0}catch{return 4}},868047:(a,f,b)=>{l.dc(a,r().subarray(f>>>0,f+b>>>0))},868110:()=>l.ac(),868151:a=>{l.Ob(a)},868187:()=>{l.Vb()},868218:()=>{l.Wb()},868247:()=>{l.$b()},868272:a=>l.Ub(a),868305:a=>l.Yb(a),868337:(a,f,b)=>{l.Nb(a,f,b,!0)},868376:(a,f,b)=>{l.Nb(a,f,b)},868409:()=>typeof wasmOffsetConverter<"u",868466:a=>{l.jb("Abs",a,void 0)},868517:a=>{l.jb("Neg",a,void 0)},868568:a=>{l.jb("Floor",a,void 0)},868621:a=>{l.jb("Ceil",a,void 0)},868673:a=>{l.jb("Reciprocal",a,void 0)},868731:a=>{l.jb("Sqrt",a,void 0)},868783:a=>{l.jb("Exp",a,void 0)},868834:a=>{l.jb("Erf",a,void 0)},868885:a=>{l.jb("Sigmoid",a,void 0)},868940:(a,f,b)=>{l.jb("HardSigmoid",a,{alpha:f,beta:b})},869019:a=>{l.jb("Log",a,void 0)},869070:a=>{l.jb("Sin",a,void 0)},869121:a=>{l.jb("Cos",a,void 0)},869172:a=>{l.jb("Tan",a,void 0)},869223:a=>{l.jb("Asin",a,void 0)},869275:a=>{l.jb("Acos",a,void 0)},869327:a=>{l.jb("Atan",a,void 0)},869379:a=>{l.jb("Sinh",a,void 0)},869431:a=>{l.jb("Cosh",a,void 0)},869483:a=>{l.jb("Asinh",a,void 0)},869536:a=>{l.jb("Acosh",a,void 0)},869589:a=>{l.jb("Atanh",a,void 0)},869642:a=>{l.jb("Tanh",a,void 0)},869694:a=>{l.jb("Not",a,void 0)},869745:(a,f,b)=>{l.jb("Clip",a,{min:f,max:b})},869814:a=>{l.jb("Clip",a,void 0)},869866:(a,f)=>{l.jb("Elu",a,{alpha:f})},869924:a=>{l.jb("Gelu",a,void 0)},869976:a=>{l.jb("Relu",a,void 0)},870028:(a,f)=>{l.jb("LeakyRelu",a,{alpha:f})},870092:(a,f)=>{l.jb("ThresholdedRelu",a,{alpha:f})},870162:(a,f)=>{l.jb("Cast",a,{to:f})},870220:a=>{l.jb("Add",a,void 0)},870271:a=>{l.jb("Sub",a,void 0)},870322:a=>{l.jb("Mul",a,void 0)},870373:a=>{l.jb("Div",a,void 0)},870424:a=>{l.jb("Pow",a,void 0)},870475:a=>{l.jb("Equal",a,void 0)},870528:a=>{l.jb("Greater",a,void 0)},870583:a=>{l.jb("GreaterOrEqual",a,void 0)},870645:a=>{l.jb("Less",a,void 0)},870697:a=>{l.jb("LessOrEqual",a,void 0)},870756:(a,f,b,k,L)=>{l.jb("ReduceMean",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},870915:(a,f,b,k,L)=>{l.jb("ReduceMax",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},871073:(a,f,b,k,L)=>{l.jb("ReduceMin",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},871231:(a,f,b,k,L)=>{l.jb("ReduceProd",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},871390:(a,f,b,k,L)=>{l.jb("ReduceSum",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},871548:(a,f,b,k,L)=>{l.jb("ReduceL1",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},871705:(a,f,b,k,L)=>{l.jb("ReduceL2",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},871862:(a,f,b,k,L)=>{l.jb("ReduceLogSum",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},872023:(a,f,b,k,L)=>{l.jb("ReduceSumSquare",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},872187:(a,f,b,k,L)=>{l.jb("ReduceLogSumExp",a,{keepDims:!!f,noopWithEmptyAxes:!!b,axes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},872351:a=>{l.jb("Where",a,void 0)},872404:(a,f,b)=>{l.jb("Transpose",a,{perm:f?Array.from(s().subarray(f>>>0,b>>>0)):[]})},872512:(a,f,b,k)=>{l.jb("DepthToSpace",a,{blocksize:f,mode:wn(b),format:k?"NHWC":"NCHW"})},872645:(a,f,b,k)=>{l.jb("DepthToSpace",a,{blocksize:f,mode:wn(b),format:k?"NHWC":"NCHW"})},872778:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke,Pr)=>{l.jb("ConvTranspose",a,{format:Rt?"NHWC":"NCHW",autoPad:f,dilations:[b],group:k,kernelShape:[L],pads:[ge,tt],strides:[gt],wIsConst:()=>!!t()[Gt>>>0],outputPadding:nr?Array.from(s().subarray(nr>>>0,Fr>>>0)):[],outputShape:Rr?Array.from(s().subarray(Rr>>>0,Ke>>>0)):[],activation:wn(Pr)})},873179:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke)=>{l.jb("ConvTranspose",a,{format:gt?"NHWC":"NCHW",autoPad:f,dilations:Array.from(s().subarray(b>>>0,2+(b>>>0)>>>0)),group:k,kernelShape:Array.from(s().subarray(L>>>0,2+(L>>>0)>>>0)),pads:Array.from(s().subarray(ge>>>0,4+(ge>>>0)>>>0)),strides:Array.from(s().subarray(tt>>>0,2+(tt>>>0)>>>0)),wIsConst:()=>!!t()[Rt>>>0],outputPadding:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],outputShape:Fr?Array.from(s().subarray(Fr>>>0,Rr>>>0)):[],activation:wn(Ke)})},873744:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke,Pr)=>{l.jb("ConvTranspose",a,{format:Rt?"NHWC":"NCHW",autoPad:f,dilations:[b],group:k,kernelShape:[L],pads:[ge,tt],strides:[gt],wIsConst:()=>!!t()[Gt>>>0],outputPadding:nr?Array.from(s().subarray(nr>>>0,Fr>>>0)):[],outputShape:Rr?Array.from(s().subarray(Rr>>>0,Ke>>>0)):[],activation:wn(Pr)})},874145:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke)=>{l.jb("ConvTranspose",a,{format:gt?"NHWC":"NCHW",autoPad:f,dilations:Array.from(s().subarray(b>>>0,2+(b>>>0)>>>0)),group:k,kernelShape:Array.from(s().subarray(L>>>0,2+(L>>>0)>>>0)),pads:Array.from(s().subarray(ge>>>0,4+(ge>>>0)>>>0)),strides:Array.from(s().subarray(tt>>>0,2+(tt>>>0)>>>0)),wIsConst:()=>!!t()[Rt>>>0],outputPadding:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],outputShape:Fr?Array.from(s().subarray(Fr>>>0,Rr>>>0)):[],activation:wn(Ke)})},874710:(a,f)=>{l.jb("GlobalAveragePool",a,{format:f?"NHWC":"NCHW"})},874801:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke)=>{l.jb("AveragePool",a,{format:Ke?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:k,storage_order:L,dilations:ge?Array.from(s().subarray(ge>>>0,tt>>>0)):[],kernel_shape:gt?Array.from(s().subarray(gt>>>0,Rt>>>0)):[],pads:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],strides:Fr?Array.from(s().subarray(Fr>>>0,Rr>>>0)):[]})},875216:(a,f)=>{l.jb("GlobalAveragePool",a,{format:f?"NHWC":"NCHW"})},875307:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke)=>{l.jb("AveragePool",a,{format:Ke?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:k,storage_order:L,dilations:ge?Array.from(s().subarray(ge>>>0,tt>>>0)):[],kernel_shape:gt?Array.from(s().subarray(gt>>>0,Rt>>>0)):[],pads:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],strides:Fr?Array.from(s().subarray(Fr>>>0,Rr>>>0)):[]})},875722:(a,f)=>{l.jb("GlobalMaxPool",a,{format:f?"NHWC":"NCHW"})},875809:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke)=>{l.jb("MaxPool",a,{format:Ke?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:k,storage_order:L,dilations:ge?Array.from(s().subarray(ge>>>0,tt>>>0)):[],kernel_shape:gt?Array.from(s().subarray(gt>>>0,Rt>>>0)):[],pads:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],strides:Fr?Array.from(s().subarray(Fr>>>0,Rr>>>0)):[]})},876220:(a,f)=>{l.jb("GlobalMaxPool",a,{format:f?"NHWC":"NCHW"})},876307:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke)=>{l.jb("MaxPool",a,{format:Ke?"NHWC":"NCHW",auto_pad:f,ceil_mode:b,count_include_pad:k,storage_order:L,dilations:ge?Array.from(s().subarray(ge>>>0,tt>>>0)):[],kernel_shape:gt?Array.from(s().subarray(gt>>>0,Rt>>>0)):[],pads:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],strides:Fr?Array.from(s().subarray(Fr>>>0,Rr>>>0)):[]})},876718:(a,f,b,k,L)=>{l.jb("Gemm",a,{alpha:f,beta:b,transA:k,transB:L})},876822:a=>{l.jb("MatMul",a,void 0)},876876:(a,f,b,k)=>{l.jb("ArgMax",a,{keepDims:!!f,selectLastIndex:!!b,axis:k})},876984:(a,f,b,k)=>{l.jb("ArgMin",a,{keepDims:!!f,selectLastIndex:!!b,axis:k})},877092:(a,f)=>{l.jb("Softmax",a,{axis:f})},877155:(a,f)=>{l.jb("Concat",a,{axis:f})},877215:(a,f,b,k,L)=>{l.jb("Split",a,{axis:f,numOutputs:b,splitSizes:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},877355:a=>{l.jb("Expand",a,void 0)},877409:(a,f)=>{l.jb("Gather",a,{axis:Number(f)})},877480:(a,f)=>{l.jb("GatherElements",a,{axis:Number(f)})},877559:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr)=>{l.jb("Resize",a,{antialias:f,axes:b?Array.from(s().subarray(b>>>0,k>>>0)):[],coordinateTransformMode:wn(L),cubicCoeffA:ge,excludeOutside:tt,extrapolationValue:gt,keepAspectRatioPolicy:wn(Rt),mode:wn(Gt),nearestMode:wn(nr)})},877905:(a,f,b,k,L,ge,tt)=>{l.jb("Slice",a,{starts:f?Array.from(s().subarray(f>>>0,b>>>0)):[],ends:k?Array.from(s().subarray(k>>>0,L>>>0)):[],axes:ge?Array.from(s().subarray(ge>>>0,tt>>>0)):[]})},878121:a=>{l.jb("Tile",a,void 0)},878173:(a,f,b)=>{l.jb("InstanceNormalization",a,{epsilon:f,format:b?"NHWC":"NCHW"})},878287:(a,f,b)=>{l.jb("InstanceNormalization",a,{epsilon:f,format:b?"NHWC":"NCHW"})},878401:a=>{l.jb("Range",a,void 0)},878454:(a,f)=>{l.jb("Einsum",a,{equation:wn(f)})},878535:(a,f,b,k,L)=>{l.jb("Pad",a,{mode:f,value:b,pads:k?Array.from(s().subarray(k>>>0,L>>>0)):[]})},878662:(a,f,b,k,L,ge)=>{l.jb("BatchNormalization",a,{epsilon:f,momentum:b,spatial:!!L,trainingMode:!!k,format:ge?"NHWC":"NCHW"})},878831:(a,f,b,k,L,ge)=>{l.jb("BatchNormalization",a,{epsilon:f,momentum:b,spatial:!!L,trainingMode:!!k,format:ge?"NHWC":"NCHW"})},879e3:(a,f,b)=>{l.jb("CumSum",a,{exclusive:Number(f),reverse:Number(b)})},879097:(a,f,b)=>{l.jb("DequantizeLinear",a,{axis:f,blockSize:b})},879187:(a,f,b,k,L,ge,tt,gt,Rt)=>{l.jb("Attention",a,{numHeads:f,isUnidirectional:b,maskFilterValue:k,scale:L,doRotary:ge,qkvHiddenSizes:tt?Array.from(s().subarray(Number(gt)>>>0,Number(gt)+tt>>>0)):[],pastPresentShareBuffer:!!Rt})},879459:a=>{l.jb("BiasAdd",a,void 0)},879514:a=>{l.jb("BiasSplitGelu",a,void 0)},879575:a=>{l.jb("FastGelu",a,void 0)},879631:(a,f,b,k,L,ge,tt,gt,Rt,Gt,nr,Fr,Rr,Ke,Pr,tn)=>{l.jb("Conv",a,{format:Fr?"NHWC":"NCHW",auto_pad:f,dilations:b?Array.from(s().subarray(b>>>0,k>>>0)):[],group:L,kernel_shape:ge?Array.from(s().subarray(ge>>>0,tt>>>0)):[],pads:gt?Array.from(s().subarray(gt>>>0,Rt>>>0)):[],strides:Gt?Array.from(s().subarray(Gt>>>0,nr>>>0)):[],w_is_const:()=>!!t()[Rr>>>0],activation:wn(Ke),activation_params:Pr?Array.from(u().subarray(Pr>>>0,tn>>>0)):[]})},880127:a=>{l.jb("Gelu",a,void 0)},880179:(a,f,b,k,L,ge,tt,gt,Rt)=>{l.jb("GroupQueryAttention",a,{numHeads:f,kvNumHeads:b,scale:k,softcap:L,doRotary:ge,rotaryInterleaved:tt,smoothSoftmax:gt,localWindowSize:Rt})},880396:(a,f,b,k)=>{l.jb("LayerNormalization",a,{axis:f,epsilon:b,simplified:!!k})},880507:(a,f,b,k)=>{l.jb("LayerNormalization",a,{axis:f,epsilon:b,simplified:!!k})},880618:(a,f,b,k,L,ge)=>{l.jb("MatMulNBits",a,{k:f,n:b,accuracyLevel:k,bits:L,blockSize:ge})},880745:(a,f,b,k,L,ge)=>{l.jb("MultiHeadAttention",a,{numHeads:f,isUnidirectional:b,maskFilterValue:k,scale:L,doRotary:ge})},880904:(a,f)=>{l.jb("QuickGelu",a,{alpha:f})},880968:(a,f,b,k,L)=>{l.jb("RotaryEmbedding",a,{interleaved:!!f,numHeads:b,rotaryEmbeddingDim:k,scale:L})},881107:(a,f,b)=>{l.jb("SkipLayerNormalization",a,{epsilon:f,simplified:!!b})},881209:(a,f,b)=>{l.jb("SkipLayerNormalization",a,{epsilon:f,simplified:!!b})},881311:(a,f,b,k)=>{l.jb("GatherBlockQuantized",a,{gatherAxis:f,quantizeAxis:b,blockSize:k})},881432:a=>{l.Zb(a)},881466:(a,f)=>l.bc(a,f,l.Fb.fc,l.Fb.errors)};function Vm(a,f,b){return Sf(async()=>{await l.Xb(a,f,b)})}function Wm(){return typeof wasmOffsetConverter<"u"}function wp(a){this.name="ExitStatus",this.message=`Program terminated with exit(${a})`,this.status=a}var yp=a=>{a.terminate(),a.onmessage=()=>{}},Kh=a=>{Ji.length==0&&(ef(),Jh(Ji[0]));var f=Ji.pop();if(!f)return 6;xs.push(f),ai[a.Ab]=f,f.Ab=a.Ab;var b={cmd:"run",start_routine:a.hc,arg:a.Qb,pthread_ptr:a.Ab};return f.postMessage(b,a.mc),0},vs=0,Qr=(a,f,...b)=>{for(var k=2*b.length,L=Lp(),ge=zp(8*k),tt=ge>>>3,gt=0;gt<b.length;gt++){var Rt=b[gt];typeof Rt=="bigint"?(qr[tt+2*gt]=1n,qr[tt+2*gt+1]=Rt):(qr[tt+2*gt]=0n,d()[tt+2*gt+1>>>0]=Rt)}return a=Zf(a,0,k,ge,f),Dc(L),a};function bp(a){if(S)return Qr(0,1,a);if(Tr=a,!(0<vs)){for(var f of xs)yp(f);for(f of Ji)yp(f);Ji=[],xs=[],ai=[],Cn=!0}Ye(a,new wp(a))}function Xh(a){if(S)return Qr(1,0,a);Mp(a)}var Mp=a=>{if(Tr=a,S)throw Xh(a),"unwind";bp(a)},Ji=[],xs=[],Yh=[],ai={},Qh=a=>{var f=a.Ab;delete ai[f],Ji.push(a),xs.splice(xs.indexOf(a),1),a.Ab=0,Dp(f)};function Zh(){Yh.forEach(a=>a())}var Jh=a=>new Promise(f=>{a.onmessage=L=>{var ge=(L=L.data).cmd;if(L.targetThread&&L.targetThread!=ia()){var tt=ai[L.targetThread];tt?tt.postMessage(L,L.transferList):Zt(`Internal error! Worker sent a message "${ge}" to target pthread ${L.targetThread}, but that thread no longer exists!`)}else ge==="checkMailbox"?Cc():ge==="spawnThread"?Kh(L):ge==="cleanupThread"?Qh(ai[L.thread]):ge==="killThread"?(L=L.thread,ge=ai[L],delete ai[L],yp(ge),Dp(L),xs.splice(xs.indexOf(ge),1),ge.Ab=0):ge==="cancelThread"?ai[L.thread].postMessage({cmd:"cancel"}):ge==="loaded"?(a.loaded=!0,f(a)):ge==="alert"?alert(`Thread ${L.threadId}: ${L.text}`):L.target==="setimmediate"?a.postMessage(L):ge==="callHandler"?l[L.handler](...L.args):ge&&Zt(`worker sent an unknown command ${ge}`)},a.onerror=L=>{throw Zt(`worker sent an error! ${L.filename}:${L.lineno}: ${L.message}`),L};var b,k=[];for(b of[])l.hasOwnProperty(b)&&k.push(b);a.postMessage({cmd:"load",handlers:k,wasmMemory:or,wasmModule:Yt})});function ef(){var a=new Worker(new URL(import.meta.url),{type:"module",workerData:"em-pthread",name:"em-pthread"});Ji.push(a)}var Ec=a=>{for(;0<a.length;)a.shift()(l)},Gm=()=>{var a=ia(),f=o()[a+52>>>2>>>0];a=o()[a+56>>>2>>>0],em(f,f-a),Dc(f)},qm=(a,f)=>{vs=0,a=tm(a,f),0<vs?Tr=a:Bc(a)};class Hm{constructor(f){this.Jb=f-24}}function Km(a,f,b){var k=new Hm(a>>>=0);throw f>>>=0,b>>>=0,o()[k.Jb+16>>>2>>>0]=0,o()[k.Jb+4>>>2>>>0]=f,o()[k.Jb+8>>>2>>>0]=b,a}function tf(a,f,b,k){return S?Qr(2,1,a,f,b,k):rf(a,f,b,k)}function rf(a,f,b,k){if(a>>>=0,f>>>=0,b>>>=0,k>>>=0,Q===void 0)return Zt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var L=[];return S&&L.length===0?tf(a,f,b,k):(a={hc:b,Ab:a,Qb:k,mc:L},S?(a.Mb="spawnThread",postMessage(a,L),0):Kh(a))}var nf=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,sf=(a,f,b)=>{var k=(f>>>=0)+b;for(b=f;a[b]&&!(b>=k);)++b;if(16<b-f&&a.buffer&&nf)return nf.decode(a.buffer instanceof Q?a.slice(f,b):a.subarray(f,b));for(k="";f<b;){var L=a[f++];if(128&L){var ge=63&a[f++];if((224&L)==192)k+=String.fromCharCode((31&L)<<6|ge);else{var tt=63&a[f++];65536>(L=(240&L)==224?(15&L)<<12|ge<<6|tt:(7&L)<<18|ge<<12|tt<<6|63&a[f++])?k+=String.fromCharCode(L):(L-=65536,k+=String.fromCharCode(55296|L>>10,56320|1023&L))}}else k+=String.fromCharCode(L)}return k},wn=(a,f)=>(a>>>=0)?sf(r(),a,f):"";function of(a,f,b){return S?Qr(3,1,a,f,b):0}function af(a,f){if(S)return Qr(4,1,a,f)}var vp=a=>{for(var f=0,b=0;b<a.length;++b){var k=a.charCodeAt(b);127>=k?f++:2047>=k?f+=2:55296<=k&&57343>=k?(f+=4,++b):f+=3}return f},lf=(a,f,b,k)=>{if(!(0<k))return 0;var L=b>>>=0;k=b+k-1;for(var ge=0;ge<a.length;++ge){var tt=a.charCodeAt(ge);if(55296<=tt&&57343>=tt&&(tt=65536+((1023&tt)<<10)|1023&a.charCodeAt(++ge)),127>=tt){if(b>=k)break;f[b++>>>0]=tt}else{if(2047>=tt){if(b+1>=k)break;f[b++>>>0]=192|tt>>6}else{if(65535>=tt){if(b+2>=k)break;f[b++>>>0]=224|tt>>12}else{if(b+3>=k)break;f[b++>>>0]=240|tt>>18,f[b++>>>0]=128|tt>>12&63}f[b++>>>0]=128|tt>>6&63}f[b++>>>0]=128|63&tt}}return f[b>>>0]=0,b-L},ra=(a,f,b)=>lf(a,r(),f,b);function uf(a,f){if(S)return Qr(5,1,a,f)}function df(a,f,b){if(S)return Qr(6,1,a,f,b)}function cf(a,f,b){return S?Qr(7,1,a,f,b):0}function pf(a,f){if(S)return Qr(8,1,a,f)}function hf(a,f,b){if(S)return Qr(9,1,a,f,b)}function ff(a,f,b,k){if(S)return Qr(10,1,a,f,b,k)}function mf(a,f,b,k){if(S)return Qr(11,1,a,f,b,k)}function gf(a,f,b,k){if(S)return Qr(12,1,a,f,b,k)}function _f(a){if(S)return Qr(13,1,a)}function wf(a,f){if(S)return Qr(14,1,a,f)}function yf(a,f,b){if(S)return Qr(15,1,a,f,b)}var bf,es,Xm=()=>{ta("")},li=a=>{for(var f="";r()[a>>>0];)f+=bf[r()[a++>>>0]];return f},xp={},Tp={};function Ei(a,f,b={}){if(!("argPackAdvance"in f))throw new TypeError("registerType registeredInstance requires argPackAdvance");return function(k,L,ge={}){var tt=L.name;if(!k)throw new es(`type "${tt}" must have a positive integer typeid pointer`);if(Tp.hasOwnProperty(k)){if(ge.Sb)return;throw new es(`Cannot register type '${tt}' twice`)}Tp[k]=L,xp.hasOwnProperty(k)&&(L=xp[k],delete xp[k],L.forEach(gt=>gt()))}(a,f,b)}var Mf=(a,f,b)=>{switch(f){case 1:return b?k=>t()[k>>>0]:k=>r()[k>>>0];case 2:return b?k=>n()[k>>>1>>>0]:k=>i()[k>>>1>>>0];case 4:return b?k=>s()[k>>>2>>>0]:k=>o()[k>>>2>>>0];case 8:return b?k=>qr[k>>>3]:k=>Gn[k>>>3];default:throw new TypeError(`invalid integer width (${f}): ${a}`)}};function Ym(a,f,b){b>>>=0,Ei(a>>>=0,{name:f=li(f>>>0),fromWireType:k=>k,toWireType:function(k,L){if(typeof L!="bigint"&&typeof L!="number")throw L=L===null?"null":(k=typeof L)=="object"||k==="array"||k==="function"?L.toString():""+L,new TypeError(`Cannot convert "${L}" to ${this.name}`);return typeof L=="number"&&(L=BigInt(L)),L},argPackAdvance:ts,readValueFromPointer:Mf(f,b,f.indexOf("u")==-1),Db:null})}var ts=8;function Qm(a,f,b,k){Ei(a>>>=0,{name:f=li(f>>>0),fromWireType:function(L){return!!L},toWireType:function(L,ge){return ge?b:k},argPackAdvance:ts,readValueFromPointer:function(L){return this.fromWireType(r()[L>>>0])},Db:null})}var Ep=[],Ci=[];function Cp(a){9<(a>>>=0)&&--Ci[a+1]==0&&(Ci[a]=void 0,Ep.push(a))}var qn=a=>{if(!a)throw new es("Cannot use deleted val. handle = "+a);return Ci[a]},Hn=a=>{switch(a){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let f=Ep.pop()||Ci.length;return Ci[f]=a,Ci[f+1]=1,f}};function $p(a){return this.fromWireType(o()[a>>>2>>>0])}var Zm={name:"emscripten::val",fromWireType:a=>{var f=qn(a);return Cp(a),f},toWireType:(a,f)=>Hn(f),argPackAdvance:ts,readValueFromPointer:$p,Db:null};function Jm(a){return Ei(a>>>0,Zm)}var eg=(a,f)=>{switch(f){case 4:return function(b){return this.fromWireType(u()[b>>>2>>>0])};case 8:return function(b){return this.fromWireType(d()[b>>>3>>>0])};default:throw new TypeError(`invalid float width (${f}): ${a}`)}};function tg(a,f,b){b>>>=0,Ei(a>>>=0,{name:f=li(f>>>0),fromWireType:k=>k,toWireType:(k,L)=>L,argPackAdvance:ts,readValueFromPointer:eg(f,b),Db:null})}function rg(a,f,b,k,L){if(a>>>=0,b>>>=0,f=li(f>>>0),L===-1&&(L=4294967295),L=gt=>gt,k===0){var ge=32-8*b;L=gt=>gt<<ge>>>ge}var tt=f.includes("unsigned")?function(gt,Rt){return Rt>>>0}:function(gt,Rt){return Rt};Ei(a,{name:f,fromWireType:L,toWireType:tt,argPackAdvance:ts,readValueFromPointer:Mf(f,b,k!==0),Db:null})}function ng(a,f,b){function k(ge){var tt=o()[ge>>>2>>>0];return ge=o()[ge+4>>>2>>>0],new L(t().buffer,ge,tt)}var L=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][f];Ei(a>>>=0,{name:b=li(b>>>0),fromWireType:k,argPackAdvance:ts,readValueFromPointer:k},{Sb:!0})}function ig(a,f){a>>>=0;var b=(f=li(f>>>0))==="std::string";Ei(a,{name:f,fromWireType:function(k){var L=o()[k>>>2>>>0],ge=k+4;if(b)for(var tt=ge,gt=0;gt<=L;++gt){var Rt=ge+gt;if(gt==L||r()[Rt>>>0]==0){if(tt=wn(tt,Rt-tt),Gt===void 0)var Gt=tt;else Gt+="\0",Gt+=tt;tt=Rt+1}}else{for(Gt=Array(L),gt=0;gt<L;++gt)Gt[gt]=String.fromCharCode(r()[ge+gt>>>0]);Gt=Gt.join("")}return di(k),Gt},toWireType:function(k,L){L instanceof ArrayBuffer&&(L=new Uint8Array(L));var ge=typeof L=="string";if(!(ge||L instanceof Uint8Array||L instanceof Uint8ClampedArray||L instanceof Int8Array))throw new es("Cannot pass non-string to std::string");var tt=b&&ge?vp(L):L.length,gt=Oc(4+tt+1),Rt=gt+4;if(o()[gt>>>2>>>0]=tt,b&&ge)ra(L,Rt,tt+1);else if(ge)for(ge=0;ge<tt;++ge){var Gt=L.charCodeAt(ge);if(255<Gt)throw di(Rt),new es("String has UTF-16 code units that do not fit in 8 bits");r()[Rt+ge>>>0]=Gt}else for(ge=0;ge<tt;++ge)r()[Rt+ge>>>0]=L[ge];return k!==null&&k.push(di,gt),gt},argPackAdvance:ts,readValueFromPointer:$p,Db(k){di(k)}})}var vf=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,sg=(a,f)=>{for(var b=a>>1,k=b+f/2;!(b>=k)&&i()[b>>>0];)++b;if(32<(b<<=1)-a&&vf)return vf.decode(r().slice(a,b));for(b="",k=0;!(k>=f/2);++k){var L=n()[a+2*k>>>1>>>0];if(L==0)break;b+=String.fromCharCode(L)}return b},og=(a,f,b)=>{if(b??=2147483647,2>b)return 0;var k=f;b=(b-=2)<2*a.length?b/2:a.length;for(var L=0;L<b;++L){var ge=a.charCodeAt(L);n()[f>>>1>>>0]=ge,f+=2}return n()[f>>>1>>>0]=0,f-k},ag=a=>2*a.length,lg=(a,f)=>{for(var b=0,k="";!(b>=f/4);){var L=s()[a+4*b>>>2>>>0];if(L==0)break;++b,65536<=L?(L-=65536,k+=String.fromCharCode(55296|L>>10,56320|1023&L)):k+=String.fromCharCode(L)}return k},ug=(a,f,b)=>{if(f>>>=0,b??=2147483647,4>b)return 0;var k=f;b=k+b-4;for(var L=0;L<a.length;++L){var ge=a.charCodeAt(L);if(55296<=ge&&57343>=ge&&(ge=65536+((1023&ge)<<10)|1023&a.charCodeAt(++L)),s()[f>>>2>>>0]=ge,(f+=4)+4>b)break}return s()[f>>>2>>>0]=0,f-k},dg=a=>{for(var f=0,b=0;b<a.length;++b){var k=a.charCodeAt(b);55296<=k&&57343>=k&&++b,f+=4}return f};function cg(a,f,b){if(a>>>=0,f>>>=0,b=li(b>>>=0),f===2)var k=sg,L=og,ge=ag,tt=gt=>i()[gt>>>1>>>0];else f===4&&(k=lg,L=ug,ge=dg,tt=gt=>o()[gt>>>2>>>0]);Ei(a,{name:b,fromWireType:gt=>{for(var Rt,Gt=o()[gt>>>2>>>0],nr=gt+4,Fr=0;Fr<=Gt;++Fr){var Rr=gt+4+Fr*f;Fr!=Gt&&tt(Rr)!=0||(nr=k(nr,Rr-nr),Rt===void 0?Rt=nr:(Rt+="\0",Rt+=nr),nr=Rr+f)}return di(gt),Rt},toWireType:(gt,Rt)=>{if(typeof Rt!="string")throw new es(`Cannot pass non-string to C++ string type ${b}`);var Gt=ge(Rt),nr=Oc(4+Gt+f);return o()[nr>>>2>>>0]=Gt/f,L(Rt,nr+4,Gt+f),gt!==null&&gt.push(di,nr),nr},argPackAdvance:ts,readValueFromPointer:$p,Db(gt){di(gt)}})}function pg(a,f){Ei(a>>>=0,{Tb:!0,name:f=li(f>>>0),argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}})}var hg=()=>1;function fg(a){Bp(a>>>0,!P,1,!A,131072,!1),Zh()}var xf=a=>{if(!Cn)try{if(a(),!(0<vs))try{S?Bc(Tr):Mp(Tr)}catch(f){f instanceof wp||f=="unwind"||Ye(1,f)}}catch(f){f instanceof wp||f=="unwind"||Ye(1,f)}};function Sp(a){a>>>=0,typeof Atomics.nc=="function"&&(Atomics.nc(s(),a>>>2,a).value.then(Cc),a+=128,Atomics.store(s(),a>>>2,1))}var Cc=()=>{var a=ia();a&&(Sp(a),xf(Jf))};function mg(a,f){(a>>>=0)==f>>>0?setTimeout(Cc):S?postMessage({targetThread:a,cmd:"checkMailbox"}):(a=ai[a])&&a.postMessage({cmd:"checkMailbox"})}var kp=[];function gg(a,f,b,k,L){for(f>>>=0,k/=2,kp.length=k,b=L>>>0>>>3,L=0;L<k;L++)kp[L]=qr[b+2*L]?qr[b+2*L+1]:d()[b+2*L+1>>>0];return(f?_p[f]:s_[a])(...kp)}function _g(a){a>>>=0,S?postMessage({cmd:"cleanupThread",thread:a}):Qh(ai[a])}function wg(a){}var Pp=(a,f)=>{var b=Tp[a];if(b===void 0)throw a=Xf(a),b=li(a),di(a),new es(`${f} has unknown type ${b}`);return b},Tf=(a,f,b)=>{var k=[];return a=a.toWireType(k,b),k.length&&(o()[f>>>2>>>0]=Hn(k)),a};function yg(a,f,b){return f>>>=0,b>>>=0,a=qn(a>>>0),f=Pp(f,"emval::as"),Tf(f,b,a)}var $c=a=>{try{a()}catch(f){ta(f)}},rs=0,ui=null,Ef=0,Sc=[],Cf={},$f={},bg=0,Ap=null,Mg=[];function Sf(a){return function(f){if(!Cn){if(rs===0){var b=!1,k=!1;f((L=0)=>{if(!Cn&&(Ef=L,b=!0,k)){rs=2,$c(()=>im(ui)),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.resume(),L=!1;try{var ge=function(){var Rt=s()[ui+8>>>2>>>0];return Rt=er[$f[Rt]],--vs,Rt()}()}catch(Rt){ge=Rt,L=!0}var tt=!1;if(!ui){var gt=Ap;gt&&(Ap=null,(L?gt.reject:gt.resolve)(ge),tt=!0)}if(L&&!tt)throw ge}}),k=!0,b||(rs=1,ui=function(){var L=Oc(65548),ge=L+12;o()[L>>>2>>>0]=ge,o()[L+4>>>2>>>0]=ge+65536,ge=Sc[0];var tt=Cf[ge];return tt===void 0&&(tt=bg++,Cf[ge]=tt,$f[tt]=ge),ge=tt,s()[L+8>>>2>>>0]=ge,L}(),typeof Browser<"u"&&Browser.Kb.Rb&&Browser.Kb.pause(),$c(()=>rm(ui)))}else rs===2?(rs=0,$c(sm),di(ui),ui=null,Mg.forEach(xf)):ta(`invalid state: ${rs}`);return Ef}}(f=>{a().then(f)})}function vg(a){return a>>>=0,Sf(()=>(a=qn(a)).then(Hn))}var kc=[];function xg(a,f,b,k){return b>>>=0,k>>>=0,(a=kc[a>>>0])(null,f=qn(f>>>0),b,k)}var Tg={},Pc=a=>{var f=Tg[a];return f===void 0?li(a):f};function Eg(a,f,b,k,L){return b>>>=0,k>>>=0,L>>>=0,(a=kc[a>>>0])(f=qn(f>>>0),f[b=Pc(b)],k,L)}var kf=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Cg(a){return(a>>>=0)==0?Hn(kf()):(a=Pc(a),Hn(kf()[a]))}var $g=a=>{var f=kc.length;return kc.push(a),f},Sg=(a,f)=>{for(var b=Array(a),k=0;k<a;++k)b[k]=Pp(o()[f+4*k>>>2>>>0],"parameter "+k);return b},Pf=(a,f)=>Object.defineProperty(f,"name",{value:a});function kg(a,f,b){var k=(f=Sg(a,f>>>0)).shift();a--;var L=`return function (obj, func, destructorsRef, args) {
`,ge=0,tt=[];b===0&&tt.push("obj");for(var gt=["retType"],Rt=[k],Gt=0;Gt<a;++Gt)tt.push("arg"+Gt),gt.push("argType"+Gt),Rt.push(f[Gt]),L+=`  var arg${Gt} = argType${Gt}.readValueFromPointer(args${ge?"+"+ge:""});
`,ge+=f[Gt].argPackAdvance;return L+=`  var rv = ${b===1?"new func":"func.call"}(${tt.join(", ")});
`,k.Tb||(gt.push("emval_returnValue"),Rt.push(Tf),L+=`  return emval_returnValue(retType, destructorsRef, rv);
`),gt.push(L+`};
`),a=function(nr){var Fr=Function;if(!(Fr instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof Fr} which is not a function`);var Rr=Pf(Fr.name||"unknownFunctionName",function(){});return Rr.prototype=Fr.prototype,Rr=new Rr,(nr=Fr.apply(Rr,nr))instanceof Object?nr:Rr}(gt)(...Rt),b=`methodCaller<(${f.map(nr=>nr.name).join(", ")}) => ${k.name}>`,$g(Pf(b,a))}function Pg(a){return a=Pc(a>>>0),Hn(l[a])}function Ag(a,f){return f>>>=0,a=qn(a>>>0),f=qn(f),Hn(a[f])}function Ig(a){9<(a>>>=0)&&(Ci[a+1]+=1)}function Fg(){return Hn([])}function Og(a){a=qn(a>>>0);for(var f=Array(a.length),b=0;b<a.length;b++)f[b]=a[b];return Hn(f)}function Bg(a){return Hn(Pc(a>>>0))}function Dg(){return Hn({})}function zg(a){for(var f=qn(a>>>=0);f.length;){var b=f.pop();f.pop()(b)}Cp(a)}function Lg(a,f,b){f>>>=0,b>>>=0,a=qn(a>>>0),f=qn(f),b=qn(b),a[f]=b}function Rg(a,f){return f>>>=0,a=(a=Pp(a>>>0,"_emval_take_value")).readValueFromPointer(f),Hn(a)}function Ng(a,f){a=-9007199254740992>a||9007199254740992<a?NaN:Number(a),f>>>=0,a=new Date(1e3*a),s()[f>>>2>>>0]=a.getUTCSeconds(),s()[f+4>>>2>>>0]=a.getUTCMinutes(),s()[f+8>>>2>>>0]=a.getUTCHours(),s()[f+12>>>2>>>0]=a.getUTCDate(),s()[f+16>>>2>>>0]=a.getUTCMonth(),s()[f+20>>>2>>>0]=a.getUTCFullYear()-1900,s()[f+24>>>2>>>0]=a.getUTCDay(),a=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[f+28>>>2>>>0]=a}var na=a=>a%4==0&&(a%100!=0||a%400==0),Af=[0,31,60,91,121,152,182,213,244,274,305,335],If=[0,31,59,90,120,151,181,212,243,273,304,334];function jg(a,f){a=-9007199254740992>a||9007199254740992<a?NaN:Number(a),f>>>=0,a=new Date(1e3*a),s()[f>>>2>>>0]=a.getSeconds(),s()[f+4>>>2>>>0]=a.getMinutes(),s()[f+8>>>2>>>0]=a.getHours(),s()[f+12>>>2>>>0]=a.getDate(),s()[f+16>>>2>>>0]=a.getMonth(),s()[f+20>>>2>>>0]=a.getFullYear()-1900,s()[f+24>>>2>>>0]=a.getDay();var b=(na(a.getFullYear())?Af:If)[a.getMonth()]+a.getDate()-1|0;s()[f+28>>>2>>>0]=b,s()[f+36>>>2>>>0]=-60*a.getTimezoneOffset(),b=new Date(a.getFullYear(),6,1).getTimezoneOffset();var k=new Date(a.getFullYear(),0,1).getTimezoneOffset();a=0|(b!=k&&a.getTimezoneOffset()==Math.min(k,b)),s()[f+32>>>2>>>0]=a}function Ug(a){a>>>=0;var f=new Date(s()[a+20>>>2>>>0]+1900,s()[a+16>>>2>>>0],s()[a+12>>>2>>>0],s()[a+8>>>2>>>0],s()[a+4>>>2>>>0],s()[a>>>2>>>0],0),b=s()[a+32>>>2>>>0],k=f.getTimezoneOffset(),L=new Date(f.getFullYear(),6,1).getTimezoneOffset(),ge=new Date(f.getFullYear(),0,1).getTimezoneOffset(),tt=Math.min(ge,L);return 0>b?s()[a+32>>>2>>>0]=+(L!=ge&&tt==k):0<b!=(tt==k)&&(L=Math.max(ge,L),f.setTime(f.getTime()+6e4*((0<b?tt:L)-k))),s()[a+24>>>2>>>0]=f.getDay(),b=(na(f.getFullYear())?Af:If)[f.getMonth()]+f.getDate()-1|0,s()[a+28>>>2>>>0]=b,s()[a>>>2>>>0]=f.getSeconds(),s()[a+4>>>2>>>0]=f.getMinutes(),s()[a+8>>>2>>>0]=f.getHours(),s()[a+12>>>2>>>0]=f.getDate(),s()[a+16>>>2>>>0]=f.getMonth(),s()[a+20>>>2>>>0]=f.getYear(),a=f.getTime(),BigInt(isNaN(a)?-1:a/1e3)}function Ff(a,f,b,k,L,ge,tt){return S?Qr(16,1,a,f,b,k,L,ge,tt):-52}function Of(a,f,b,k,L,ge){if(S)return Qr(17,1,a,f,b,k,L,ge)}function Vg(a,f,b,k){a>>>=0,f>>>=0,b>>>=0,k>>>=0;var L=new Date().getFullYear(),ge=new Date(L,0,1),tt=new Date(L,6,1);L=ge.getTimezoneOffset();var gt=tt.getTimezoneOffset(),Rt=Math.max(L,gt);o()[a>>>2>>>0]=60*Rt,s()[f>>>2>>>0]=+(L!=gt),ge=(a=Gt=>Gt.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])(ge),tt=a(tt),gt<L?(ra(ge,b,17),ra(tt,k,17)):(ra(ge,k,17),ra(tt,b,17))}var Ip=[],Bf=(a,f)=>{Ip.length=0;for(var b;b=r()[a++>>>0];){var k=b!=105;f+=(k&=b!=112)&&f%8?4:0,Ip.push(b==112?o()[f>>>2>>>0]:b==106?qr[f>>>3]:b==105?s()[f>>>2>>>0]:d()[f>>>3>>>0]),f+=k?8:4}return Ip};function Wg(a,f,b){return a>>>=0,f=Bf(f>>>0,b>>>0),_p[a](...f)}function Gg(a,f,b){return a>>>=0,f=Bf(f>>>0,b>>>0),_p[a](...f)}var qg=()=>{},Hg=()=>Date.now();function Kg(a,f){return Zt(wn(a>>>0,f>>>0))}var Df,Xg=()=>{throw vs+=1,"unwind"};function Yg(){return 4294901760}Df=()=>performance.timeOrigin+performance.now();var Qg=()=>navigator.hardwareConcurrency;function Zg(){return ta("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Jg(a){a>>>=0;var f=r().length;if(a<=f||4294901760<a)return!1;for(var b=1;4>=b;b*=2){var k=f*(1+.2/b);k=Math.min(k,a+100663296);var L=Math;k=Math.max(a,k);e:{L=(L.min.call(L,4294901760,k+(65536-k%65536)%65536)-or.buffer.byteLength+65535)/65536;try{or.grow(L),vn();var ge=1;break e}catch{}ge=void 0}if(ge)return!0}return!1}var Ac=()=>(ta("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),_d={},zf=a=>{a.forEach(f=>{Ac()})};function e_(){var a=Error().stack.toString().split(`
`);return a[0]=="Error"&&a.shift(),zf(a),_d.Pb=Ac(),_d.ec=a,_d.Pb}function t_(a,f,b){if(a>>>=0,f>>>=0,_d.Pb==a)var k=_d.ec;else(k=Error().stack.toString().split(`
`))[0]=="Error"&&k.shift(),zf(k);for(var L=3;k[L]&&Ac()!=a;)++L;for(a=0;a<b&&k[a+L];++a)s()[f+4*a>>>2>>>0]=Ac();return a}var Fp,Op={},Lf=()=>{if(!Fp){var a,f={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:be};for(a in Op)Op[a]===void 0?delete f[a]:f[a]=Op[a];var b=[];for(a in f)b.push(`${a}=${f[a]}`);Fp=b}return Fp};function Rf(a,f){if(S)return Qr(18,1,a,f);a>>>=0,f>>>=0;var b=0;return Lf().forEach((k,L)=>{var ge=f+b;for(L=o()[a+4*L>>>2>>>0]=ge,ge=0;ge<k.length;++ge)t()[L++>>>0]=k.charCodeAt(ge);t()[L>>>0]=0,b+=k.length+1}),0}function Nf(a,f){if(S)return Qr(19,1,a,f);a>>>=0,f>>>=0;var b=Lf();o()[a>>>2>>>0]=b.length;var k=0;return b.forEach(L=>k+=L.length+1),o()[f>>>2>>>0]=k,0}function jf(a){return S?Qr(20,1,a):52}function Uf(a,f,b,k){return S?Qr(21,1,a,f,b,k):52}function Vf(a,f,b,k){return S?Qr(22,1,a,f,b,k):70}var r_=[null,[],[]];function Wf(a,f,b,k){if(S)return Qr(23,1,a,f,b,k);f>>>=0,b>>>=0,k>>>=0;for(var L=0,ge=0;ge<b;ge++){var tt=o()[f>>>2>>>0],gt=o()[f+4>>>2>>>0];f+=8;for(var Rt=0;Rt<gt;Rt++){var Gt=r()[tt+Rt>>>0],nr=r_[a];Gt===0||Gt===10?((a===1?lr:Zt)(sf(nr,0)),nr.length=0):nr.push(Gt)}L+=gt}return o()[k>>>2>>>0]=L,0}var Gf=[31,29,31,30,31,30,31,31,30,31,30,31],qf=[31,28,31,30,31,30,31,31,30,31,30,31],n_=(a,f)=>{t().set(a,f>>>0)};function Hf(a,f,b,k){function L(Ke,Pr,tn){for(Ke=typeof Ke=="number"?Ke.toString():Ke||"";Ke.length<Pr;)Ke=tn[0]+Ke;return Ke}function ge(Ke,Pr){return L(Ke,Pr,"0")}function tt(Ke,Pr){function tn(am){return 0>am?-1:0<am?1:0}var Ts;return(Ts=tn(Ke.getFullYear()-Pr.getFullYear()))===0&&(Ts=tn(Ke.getMonth()-Pr.getMonth()))===0&&(Ts=tn(Ke.getDate()-Pr.getDate())),Ts}function gt(Ke){switch(Ke.getDay()){case 0:return new Date(Ke.getFullYear()-1,11,29);case 1:return Ke;case 2:return new Date(Ke.getFullYear(),0,3);case 3:return new Date(Ke.getFullYear(),0,2);case 4:return new Date(Ke.getFullYear(),0,1);case 5:return new Date(Ke.getFullYear()-1,11,31);case 6:return new Date(Ke.getFullYear()-1,11,30)}}function Rt(Ke){var Pr=Ke.Bb;for(Ke=new Date(new Date(Ke.Cb+1900,0,1).getTime());0<Pr;){var tn=Ke.getMonth(),Ts=(na(Ke.getFullYear())?Gf:qf)[tn];if(!(Pr>Ts-Ke.getDate())){Ke.setDate(Ke.getDate()+Pr);break}Pr-=Ts-Ke.getDate()+1,Ke.setDate(1),11>tn?Ke.setMonth(tn+1):(Ke.setMonth(0),Ke.setFullYear(Ke.getFullYear()+1))}return tn=new Date(Ke.getFullYear()+1,0,4),Pr=gt(new Date(Ke.getFullYear(),0,4)),tn=gt(tn),0>=tt(Pr,Ke)?0>=tt(tn,Ke)?Ke.getFullYear()+1:Ke.getFullYear():Ke.getFullYear()-1}a>>>=0,f>>>=0,b>>>=0,k>>>=0;var Gt=o()[k+40>>>2>>>0];for(var nr in k={kc:s()[k>>>2>>>0],jc:s()[k+4>>>2>>>0],Hb:s()[k+8>>>2>>>0],Lb:s()[k+12>>>2>>>0],Ib:s()[k+16>>>2>>>0],Cb:s()[k+20>>>2>>>0],ub:s()[k+24>>>2>>>0],Bb:s()[k+28>>>2>>>0],sc:s()[k+32>>>2>>>0],ic:s()[k+36>>>2>>>0],lc:Gt?wn(Gt):""},b=wn(b),Gt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})b=b.replace(new RegExp(nr,"g"),Gt[nr]);var Fr="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Rr="January February March April May June July August September October November December".split(" ");for(nr in Gt={"%a":Ke=>Fr[Ke.ub].substring(0,3),"%A":Ke=>Fr[Ke.ub],"%b":Ke=>Rr[Ke.Ib].substring(0,3),"%B":Ke=>Rr[Ke.Ib],"%C":Ke=>ge((Ke.Cb+1900)/100|0,2),"%d":Ke=>ge(Ke.Lb,2),"%e":Ke=>L(Ke.Lb,2," "),"%g":Ke=>Rt(Ke).toString().substring(2),"%G":Rt,"%H":Ke=>ge(Ke.Hb,2),"%I":Ke=>((Ke=Ke.Hb)==0?Ke=12:12<Ke&&(Ke-=12),ge(Ke,2)),"%j":Ke=>{for(var Pr=0,tn=0;tn<=Ke.Ib-1;Pr+=(na(Ke.Cb+1900)?Gf:qf)[tn++]);return ge(Ke.Lb+Pr,3)},"%m":Ke=>ge(Ke.Ib+1,2),"%M":Ke=>ge(Ke.jc,2),"%n":()=>`
`,"%p":Ke=>0<=Ke.Hb&&12>Ke.Hb?"AM":"PM","%S":Ke=>ge(Ke.kc,2),"%t":()=>"	","%u":Ke=>Ke.ub||7,"%U":Ke=>ge(Math.floor((Ke.Bb+7-Ke.ub)/7),2),"%V":Ke=>{var Pr=Math.floor((Ke.Bb+7-(Ke.ub+6)%7)/7);if(2>=(Ke.ub+371-Ke.Bb-2)%7&&Pr++,Pr)Pr==53&&((tn=(Ke.ub+371-Ke.Bb)%7)==4||tn==3&&na(Ke.Cb)||(Pr=1));else{Pr=52;var tn=(Ke.ub+7-Ke.Bb-1)%7;(tn==4||tn==5&&na(Ke.Cb%400-1))&&Pr++}return ge(Pr,2)},"%w":Ke=>Ke.ub,"%W":Ke=>ge(Math.floor((Ke.Bb+7-(Ke.ub+6)%7)/7),2),"%y":Ke=>(Ke.Cb+1900).toString().substring(2),"%Y":Ke=>Ke.Cb+1900,"%z":Ke=>{var Pr=0<=(Ke=Ke.ic);return Ke=Math.abs(Ke)/60,(Pr?"+":"-")+("0000"+(Ke/60*100+Ke%60)).slice(-4)},"%Z":Ke=>Ke.lc,"%%":()=>"%"},b=b.replace(/%%/g,"\0\0"),Gt)b.includes(nr)&&(b=b.replace(new RegExp(nr,"g"),Gt[nr](k)));return nr=function(Ke){var Pr=Array(vp(Ke)+1);return lf(Ke,Pr,0,Pr.length),Pr}(b=b.replace(/\0\0/g,"%")),nr.length>f?0:(n_(nr,a),nr.length-1)}function i_(a,f,b,k){return Hf(a>>>0,f>>>0,b>>>0,k>>>0)}S||function(){for(var a=l.numThreads-1;a--;)ef();mn.unshift(()=>{Zi++,function(f){S?f():Promise.all(Ji.map(Jh)).then(f)}(()=>Uh())})}();for(var Kf=Array(256),Ic=0;256>Ic;++Ic)Kf[Ic]=String.fromCharCode(Ic);bf=Kf,es=l.BindingError=class extends Error{constructor(a){super(a),this.name="BindingError"}},l.InternalError=class extends Error{constructor(a){super(a),this.name="InternalError"}},Ci.push(0,1,void 0,1,null,1,!0,1,!1,1),l.count_emval_handles=()=>Ci.length/2-5-Ep.length;var s_=[bp,Xh,tf,of,af,uf,df,cf,pf,hf,ff,mf,gf,_f,wf,yf,Ff,Of,Rf,Nf,jf,Uf,Vf,Wf],er=function(){function a(b,k){return er=b.exports,er=function(){var L=er,ge={};for(let[tt,gt]of Object.entries(L))ge[tt]=typeof gt=="function"?(...Rt)=>{Sc.push(tt);try{return gt(...Rt)}finally{Cn||(Sc.pop(),ui&&rs===1&&Sc.length===0&&(rs=0,vs+=1,$c(nm),typeof Fibers<"u"&&Fibers.tc()))}}:gt;return ge}(),er=function(){var L=er,ge=gt=>Rt=>gt(Rt)>>>0,tt=gt=>()=>gt()>>>0;return(L=Object.assign({},L)).Ca=ge(L.Ca),L.fb=tt(L.fb),L.hb=ge(L.hb),L.emscripten_main_runtime_thread_id=tt(L.emscripten_main_runtime_thread_id),L.sb=ge(L.sb),L.tb=tt(L.tb),L}(),Yh.push(er.ib),gn.unshift(er.Ba),Yt=k,Uh(),er}var f=Hh();if(Zi++,l.instantiateWasm)try{return l.instantiateWasm(f,a)}catch(b){Zt(`Module.instantiateWasm callback failed with error: ${b}`),y(b)}return gp||=l.locateFile?Vh("ort-wasm-simd-threaded.jsep.wasm")?"ort-wasm-simd-threaded.jsep.wasm":l.locateFile?l.locateFile("ort-wasm-simd-threaded.jsep.wasm",ze):ze+"ort-wasm-simd-threaded.jsep.wasm":new URL(T("./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm"),T.b).href,function(b,k){var L=gp;return Mt||typeof WebAssembly.instantiateStreaming!="function"||Vh(L)||Wh(L)||typeof fetch!="function"?qh(L,b,k):fetch(L,{credentials:"same-origin"}).then(ge=>WebAssembly.instantiateStreaming(ge,b).then(k,function(tt){return Zt(`wasm streaming compile failed: ${tt}`),Zt("falling back to ArrayBuffer instantiation"),qh(L,b,k)}))}(f,function(b){a(b.instance,b.module)}).catch(y),{}}(),Xf=a=>(Xf=er.Ca)(a),Yf=()=>(Yf=er.Da)();l._OrtInit=(a,f)=>(l._OrtInit=er.Ea)(a,f),l._OrtGetLastError=(a,f)=>(l._OrtGetLastError=er.Fa)(a,f),l._OrtCreateSessionOptions=(a,f,b,k,L,ge,tt,gt,Rt,Gt)=>(l._OrtCreateSessionOptions=er.Ga)(a,f,b,k,L,ge,tt,gt,Rt,Gt),l._OrtAppendExecutionProvider=(a,f)=>(l._OrtAppendExecutionProvider=er.Ha)(a,f),l._OrtAddFreeDimensionOverride=(a,f,b)=>(l._OrtAddFreeDimensionOverride=er.Ia)(a,f,b),l._OrtAddSessionConfigEntry=(a,f,b)=>(l._OrtAddSessionConfigEntry=er.Ja)(a,f,b),l._OrtReleaseSessionOptions=a=>(l._OrtReleaseSessionOptions=er.Ka)(a),l._OrtCreateSession=(a,f,b)=>(l._OrtCreateSession=er.La)(a,f,b),l._OrtReleaseSession=a=>(l._OrtReleaseSession=er.Ma)(a),l._OrtGetInputOutputCount=(a,f,b)=>(l._OrtGetInputOutputCount=er.Na)(a,f,b),l._OrtGetInputName=(a,f)=>(l._OrtGetInputName=er.Oa)(a,f),l._OrtGetOutputName=(a,f)=>(l._OrtGetOutputName=er.Pa)(a,f),l._OrtFree=a=>(l._OrtFree=er.Qa)(a),l._OrtCreateTensor=(a,f,b,k,L,ge)=>(l._OrtCreateTensor=er.Ra)(a,f,b,k,L,ge),l._OrtGetTensorData=(a,f,b,k,L)=>(l._OrtGetTensorData=er.Sa)(a,f,b,k,L),l._OrtReleaseTensor=a=>(l._OrtReleaseTensor=er.Ta)(a),l._OrtCreateRunOptions=(a,f,b,k)=>(l._OrtCreateRunOptions=er.Ua)(a,f,b,k),l._OrtAddRunConfigEntry=(a,f,b)=>(l._OrtAddRunConfigEntry=er.Va)(a,f,b),l._OrtReleaseRunOptions=a=>(l._OrtReleaseRunOptions=er.Wa)(a),l._OrtCreateBinding=a=>(l._OrtCreateBinding=er.Xa)(a),l._OrtBindInput=(a,f,b)=>(l._OrtBindInput=er.Ya)(a,f,b),l._OrtBindOutput=(a,f,b,k)=>(l._OrtBindOutput=er.Za)(a,f,b,k),l._OrtClearBoundOutputs=a=>(l._OrtClearBoundOutputs=er._a)(a),l._OrtReleaseBinding=a=>(l._OrtReleaseBinding=er.$a)(a),l._OrtRunWithBinding=(a,f,b,k,L)=>(l._OrtRunWithBinding=er.ab)(a,f,b,k,L),l._OrtRun=(a,f,b,k,L,ge,tt,gt)=>(l._OrtRun=er.bb)(a,f,b,k,L,ge,tt,gt),l._OrtEndProfiling=a=>(l._OrtEndProfiling=er.cb)(a),l._JsepOutput=(a,f,b)=>(l._JsepOutput=er.db)(a,f,b),l._JsepGetNodeName=a=>(l._JsepGetNodeName=er.eb)(a);var Fc,ia=()=>(ia=er.fb)(),di=l._free=a=>(di=l._free=er.gb)(a),Oc=l._malloc=a=>(Oc=l._malloc=er.hb)(a),Bp=(a,f,b,k,L,ge)=>(Bp=er.kb)(a,f,b,k,L,ge),Qf=()=>(Qf=er.lb)(),Zf=(a,f,b,k,L)=>(Zf=er.mb)(a,f,b,k,L),Dp=a=>(Dp=er.nb)(a),Bc=a=>(Bc=er.ob)(a),Jf=()=>(Jf=er.pb)(),em=(a,f)=>(em=er.qb)(a,f),Dc=a=>(Dc=er.rb)(a),zp=a=>(zp=er.sb)(a),Lp=()=>(Lp=er.tb)(),tm=l.dynCall_ii=(a,f)=>(tm=l.dynCall_ii=er.vb)(a,f),rm=a=>(rm=er.wb)(a),nm=()=>(nm=er.xb)(),im=a=>(im=er.yb)(a),sm=()=>(sm=er.zb)();function om(){0<Zi||(S?(h(l),S||Ec(gn),startWorker(l)):(Ec(mn),0<Zi||Fc||(Fc=!0,l.calledRun=!0,Cn||(S||Ec(gn),h(l),S||Ec(Qi)))))}return l.___start_em_js=881578,l.___stop_em_js=881800,l.stackSave=()=>Lp(),l.stackRestore=a=>Dc(a),l.stackAlloc=a=>zp(a),l.UTF8ToString=wn,l.stringToUTF8=ra,l.lengthBytesUTF8=vp,Ms=function a(){Fc||om(),Fc||(Ms=a)},om(),x}),Ie=ve,globalThis.self?.name==="em-pthread"&&ve()}),Ze,mt,Ct,Et,Ft,Tt,Ut,Wt,Nt=j(()=>{m(),Ze=import.meta.url??(typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0),mt=typeof location>"u"?void 0:location.origin,Ct=(e,t)=>{try{let r=t??Ze;return(r?new URL(e,r):new URL(e)).origin===mt}catch{return!1}},Et=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Ft=(sr(),N(W)).default,Tt=async()=>{if(!Ze)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ct(Ze))return[void 0,Ft()];let e=await Et(Ze);return[e,Ft(e)]},Ut=(je(),N(ot)).default,Wt=async(e,t,r)=>[void 0,Ut]}),We,Ge,vt,Ht,ar,Or,jr,Er,zr=j(()=>{Nt(),Ge=!1,vt=!1,Ht=!1,ar=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Or=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},jr=async e=>{if(Ge)return Promise.resolve();if(vt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ht)throw new Error("previous call to 'initializeWebAssembly()' failed.");vt=!0;let t=e.initTimeout,r=e.numThreads;if(!Or())throw new Error("WebAssembly SIMD is not supported in the current environment.");let n=ar();r>1&&!n&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let i=e.wasmPaths,s=typeof i=="string"?i:void 0,o=i?.mjs,u=o?.href??o,d=i?.wasm,h=d?.href??d,y=e.wasmBinary,[l,x]=await Wt(u,s,r>1),A=!1,P=[];if(t>0&&P.push(new Promise(S=>{setTimeout(()=>{A=!0,S()},t)})),P.push(new Promise((S,Q)=>{let Y={numThreads:r};y?Y.wasmBinary=y:(h||s)&&(Y.locateFile=(D,ne)=>h??(s??ne)+D),x(Y).then(D=>{vt=!1,Ge=!0,We=D,S(),l&&URL.revokeObjectURL(l)},D=>{vt=!1,Ht=!0,Q(D)})})),await Promise.race(P),A)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Er=()=>{if(Ge&&We)return We;throw new Error("WebAssembly is not initialized yet.")}}),Ar,zn,Nr,mi=j(()=>{zr(),Ar=(e,t)=>{let r=Er(),n=r.lengthBytesUTF8(e)+1,i=r._malloc(n);return r.stringToUTF8(e,i,n),t.push(i),i},zn=(e,t,r,n)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([i,s])=>{let o=t?t+i:i;if(typeof s=="object")zn(s,o+".",r,n);else if(typeof s=="string"||typeof s=="number")n(o,s.toString());else if(typeof s=="boolean")n(o,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},Nr=e=>{let t=Er(),r=t.stackSave();try{let n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);let i=t.HEAP32[n/4],s=t.HEAPU32[n/4+1],o=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}}),ki,Xn=j(()=>{zr(),mi(),ki=e=>{let t=Er(),r=0,n=[],i=e||{};try{if(e?.logSeverityLevel===void 0)i.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)i.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(i.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Ar(e.tag,n)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,s),r===0&&Nr("Can't create run options."),e?.extra!==void 0&&zn(e.extra,"",new WeakSet,(o,u)=>{let d=Ar(o,n),h=Ar(u,n);t._OrtAddRunConfigEntry(r,d,h)!==0&&Nr(`Can't set a run config entry: ${o} - ${u}.`)}),[r,n]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),n.forEach(o=>t._free(o)),s}}}),Pi,Ai,Ii,Fi,Oi,ti=j(()=>{zr(),mi(),Pi=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ai=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Ii=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Fi=(e,t,r)=>{for(let n of t){let i=typeof n=="string"?n:n.name;switch(i){case"webnn":if(i="WEBNN",typeof n!="string"){let o=n?.deviceType;if(o){let u=Ar("deviceType",r),d=Ar(o,r);Er()._OrtAddSessionConfigEntry(e,u,d)!==0&&Nr(`Can't set a session config entry: 'deviceType' - ${o}.`)}}break;case"webgpu":if(i="JS",typeof n!="string"){let o=n;if(o?.preferredLayout){if(o.preferredLayout!=="NCHW"&&o.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);let u=Ar("preferredLayout",r),d=Ar(o.preferredLayout,r);Er()._OrtAddSessionConfigEntry(e,u,d)!==0&&Nr(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${i}`)}let s=Ar(i,r);Er()._OrtAppendExecutionProvider(e,s)!==0&&Nr(`Can't append execution provider: ${i}.`)}},Oi=e=>{let t=Er(),r=0,n=[],i=e||{};Ii(i);try{let s=Pi(i.graphOptimizationLevel??"all"),o=Ai(i.executionMode??"sequential"),u=typeof i.logId=="string"?Ar(i.logId,n):0,d=i.logSeverityLevel??2;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log serverity level is not valid: ${d}`);let h=i.logVerbosityLevel??0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);let y=typeof i.optimizedModelFilePath=="string"?Ar(i.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(s,!!i.enableCpuMemArena,!!i.enableMemPattern,o,!!i.enableProfiling,0,u,d,h,y),r===0&&Nr("Can't create session options."),i.executionProviders&&Fi(r,i.executionProviders,n),i.enableGraphCapture!==void 0){if(typeof i.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);let l=Ar("enableGraphCapture",n),x=Ar(i.enableGraphCapture.toString(),n);t._OrtAddSessionConfigEntry(r,l,x)!==0&&Nr(`Can't set a session config entry: 'enableGraphCapture' - ${i.enableGraphCapture}.`)}if(i.freeDimensionOverrides)for(let[l,x]of Object.entries(i.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof x!="number"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let A=Ar(l,n);t._OrtAddFreeDimensionOverride(r,A,x)!==0&&Nr(`Can't set a free dimension override: ${l} - ${x}.`)}return i.extra!==void 0&&zn(i.extra,"",new WeakSet,(l,x)=>{let A=Ar(l,n),P=Ar(x,n);t._OrtAddSessionConfigEntry(r,A,P)!==0&&Nr(`Can't set a session config entry: ${l} - ${x}.`)}),[r,n]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),n.forEach(o=>t._free(o)),s}}}),Yn,$n,Ln,gi,On,_i,wi,yi,rr=j(()=>{Yn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},$n=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},Ln=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n=typeof t=="number"?t:t.reduce((i,s)=>i*s,1);return r>0?Math.ceil(n*r):void 0},gi=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},On=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},_i=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",wi=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool",yi=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),ri,Bi=j(()=>{m(),ri=async e=>{if(typeof e=="string"){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let i=t.body.getReader(),s;try{s=new ArrayBuffer(n)}catch(u){if(u instanceof RangeError){let d=Math.ceil(n/65536);s=new WebAssembly.Memory({initial:d,maximum:d}).buffer}else throw u}let o=0;for(;;){let{done:u,value:d}=await i.read();if(u)break;let h=d.byteLength;new Uint8Array(s,o,h).set(d),o+=h}return new Uint8Array(s,0,n)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),Di,bi,zi,Li,ni,ns,ye,g=j(()=>{rr(),Di=["V","I","W","E","F"],bi=(e,t)=>{console.log(`[${Di[e]},${new Date().toISOString()}]${t}`)},ni=(e,t)=>{zi=e,Li=t},ns=(e,t)=>{let r=On(e),n=On(zi);r>=n&&bi(r,typeof t=="function"?t():t)},ye=(...e)=>{Li&&ns(...e)}}),G,ce=j(()=>{rr(),G=(e,t)=>new(gi(t))(e)}),me=j(()=>{}),Le,ct,Pt,Dt,zt,$t,gr,pr,Cr,Xr=j(()=>{g(),me(),Le=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),ct=[],Pt=e=>Math.ceil(e/16)*16,Dt=e=>{for(let t=0;t<ct.length;t++){let r=ct[t];if(e<=r)return r}return Math.ceil(e/16)*16},zt=1,$t=()=>zt++,gr=async(e,t,r,n)=>{let i=Pt(r),s=e.device.createBuffer({size:i,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=e.getCommandEncoder();e.endComputePass(),o.copyBufferToBuffer(t,0,s,0,i),e.flush(),await s.mapAsync(GPUMapMode.READ);let u=s.getMappedRange();if(n){let d=n();return d.set(new Uint8Array(u,0,r)),d}else return new Uint8Array(u.slice(0,r))}finally{s.destroy()}},pr=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[t]of Le)ct.push(t),this.freeBuffers.set(t,[]),this.freeUniformBuffers.set(t,[]);this.sessionCount=0}upload(e,t){let r=t.buffer,n=t.byteOffset,i=t.byteLength,s=Pt(i),o=this.storageCache.get(e);if(!o)throw new Error("gpu data for uploading does not exist");if(o.originalSize!==i)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${i}`);let u=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),d=u.getMappedRange();new Uint8Array(d).set(new Uint8Array(r,n,i)),u.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(u,0,o.gpuData.buffer,0,s),ye("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`),this.buffersForUploadingPending.push(u)}memcpy(e,t){let r=this.storageCache.get(e);if(!r)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(t);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(r.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let i=Pt(r.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(r.gpuData.buffer,0,n.gpuData.buffer,0,i)}registerExternalBuffer(e,t,r){let n;if(r){if(n=r[0],e===r[1])return ye("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${n}, buffer is the same, skip.`),n;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else n=$t();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:e},originalSize:t}),ye("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${n}, registered.`),n}unregisterExternalBuffer(e){e!==void 0&&(this.storageCache.delete(e),ye("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let r=Dt(e),n,i=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||s){let u=(i?this.freeBuffers:this.freeUniformBuffers).get(r);u?u.length>0?n=u.pop():n=this.backend.device.createBuffer({size:r,usage:t}):n=this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let o={id:$t(),type:0,buffer:n};return this.storageCache.set(o.id,{gpuData:o,originalSize:e}),ye("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${o.id}`),o}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t=this.storageCache.get(e);if(!t){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return ye("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(e,t){let r=this.storageCache.get(e);if(!r)throw new Error("data does not exist");await gr(this.backend,r.gpuData.buffer,r.originalSize,t)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();if(this.buffersForUploadingPending=[],this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let e of this.buffersPending){let t=Le.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(e.size)||[];t===void 0||r.length>=t?e.destroy():r.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let r=this.freeUniformBuffers.get(e.size)||[];t===void 0||r.length>=t?e.destroy():r.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(t=>{t.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(r=>{r.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,this.sessionCount===0&&(ye("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Cr=(...e)=>new pr(...e)}),bn,hr,kr=j(()=>{bn=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},hr=e=>new bn(e)}),xn,Sn,De,Jr,ln,kn,Rn,Jt=j(()=>{xn=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},Sn=class{static calcShape(e,t,r=!1){let n=e.length,i=t.length;if(n===0)return t;if(i===0)return e;let s=Math.max(e.length,t.length),o=new Array(s);if(r){if(n<2||i<2)return;let u=xn.calcMatMulShape([e[n-2],e[n-1]],[t[i-2],t[i-1]]);if(u===void 0)return;[o[s-2],o[s-1]]=u}for(let u=r?3:1;u<=s;u++){let d=n-u<0?1:e[n-u],h=i-u<0?1:t[i-u];if(d!==h&&d>1&&h>1)return;let y=Math.max(d,h);if(d&&h)o[s-u]=Math.max(d,h);else{if(y>1)return;o[s-u]=0}}return o}static isValidBroadcast(e,t){let r=e.length,n=t.length;if(r>n)return!1;for(let i=1;i<=r;i++)if(e[r-i]!==1&&e[r-i]!==t[n-i])return!1;return!0}},De=class Rc{static size(t){return Rc.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,r=4){let n=t.length;if(n===0)return[];let i=new Array(n),s=n-1;for(;s>=0;){if(t[s]%r===0){i[s]=t[s]/r;break}if(r%t[s]!==0)throw new Error("cannot convert shape");i[s]=1,r/=t[s],s--}for(s--;s>=0;s--)i[s]=t[s];return i}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return Rc.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return Rc.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,n){let i=1;for(let s=r;s<n;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");i*=t[s]}return i}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let n=new Array(r);n[r-1]=1,n[r-2]=t[r-1];for(let i=r-3;i>=0;--i)n[i]=n[i+1]*t[i+1];return n}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(n=>this.normalizeAxis(n,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(n=>t[n]):t.slice().reverse()}static padShape(t,r){let n=t.length;return t.map((i,s)=>i+r[s]+r[s+n])}static areEqual(t,r){return t.length!==r.length?!1:t.every((n,i)=>n===r[i])}},Jr=class bd{static adjustPoolAttributes(t,r,n,i,s,o){if(!t&&n.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let u=0;u<r.length-2;u++)u>=n.length?n.push(r[u+2]):n[u]=r[u+2];for(let u=0;u<n.length;u++)if(u<i.length){if(i[u]<0)throw new Error("strides should be greater than or equal to 1")}else i.push(1);for(let u=0;u<n.length;u++)if(u<s.length){if(s[u]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let u=0;u<n.length*2;u++)if(u<o.length){if(o[u]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let u=0;u<n.length;u++){if(n[u]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[u]>=n[u]||o[u+n.length]>=n[u])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,n,i,s,o,u){if(u){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(i.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let d=0;d<t.length-2;d++)bd.adjustPadAndReturnShape(t[d+(o?1:2)],r[d],n[d],i[d],s,d,d+t.length-2,u)}}static computePoolOutputShape(t,r,n,i,s,o,u){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let d=[r[0],r[1]];return bd.computeShapeHelper(t,r,d,n,i,s,o,u),d}static computeConvOutputShape(t,r,n,i,s,o,u){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let d=[t[0],r[0]];return bd.computeShapeHelper(!1,t,d,n,i,s,o,u),d}static computeShapeHelper(t,r,n,i,s,o,u,d){if(t)for(let h=0;h<r.length-2;h++)n.push(1);else for(let h=0;h<r.length-2;h++)n.push(bd.adjustPadAndReturnShape(r[h+2],i[h],s[h],o[h],u,h,h+r.length-2,d))}static adjustPadAndReturnShape(t,r,n,i,s,o,u,d){let h=n*(i-1)+1;if(d&&d!=="NOTSET")switch(d){case"VALID":return s[o]=0,s[u]=0,Math.floor((t-h)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(n!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+i-t;return s[o]=Math.floor(d==="SAME_LOWER"?(y+1)/2:y/2),s[u]=y-s[o],Math.floor((t+y-i)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[o]+s[u]-h)/r+1)}},ln=class{static getShapeOfGemmResult(e,t,r,n,i){if(e.length!==2||r.length!==2)throw new Error("shape need to be of size 2");let s,o,u;t?(s=e[1],o=e[0]):(s=e[0],o=e[1]);let d=-1;if(n?(u=r[0],d=1):(u=r[1],d=0),r[d]!==o)throw new Error("dimension mismatch");if(s<=0||u<=0||o<=0)throw new Error("invalid shape specified");if(i&&!Sn.isValidBroadcast(i,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,o]}},kn=-34028234663852886e22,Rn=34028234663852886e22}),pn,Yr,_r,Br,Ot,br,ii,Qn,Nn,qt,is,ht,Kt,$s,Ss,da,Mi,fr=j(()=>{rr(),Jt(),pn=64,Yr=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},_r=(e,t=1)=>{let r=Yr(e,t);return typeof r=="string"?r:r[0]},Br=(e,t=1)=>{let r=Yr(e,t);return typeof r=="string"?r:r[1]},Ot=(...e)=>{let t=[];return e.forEach(r=>{r.length!==0&&t.push({type:12,data:r},{type:12,data:De.computeStrides(r)})}),t},br=e=>e%4===0?4:e%2===0?2:1,ii=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Qn=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}<f32>(${r})`,Nn=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,qt=(e,t,r,n)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?n==="f16"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:n==="f16"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,is=(e,t,r,n,i)=>{let s=typeof r=="number",o=s?r:r.length,u=[...new Array(o).keys()],d=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,h=Yr(t,i),y=typeof h=="string"?h:h[1],l=typeof h=="string"?h:h[0],x={indices:d,value:y,storage:l,tensor:t},A=ut=>typeof ut=="string"?ut:`${ut}u`,P={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},S=s?"uniforms.":"",Q=`${S}${e}_shape`,Y=`${S}${e}_strides`,D="";for(let ut=0;ut<o-1;ut++)D+=`
    let dim${ut} = current / ${qt(Y,ut,o)};
    let rest${ut} = current % ${qt(Y,ut,o)};
    indices[${ut}] = dim${ut};
    current = rest${ut};
    `;D+=`indices[${o-1}] = current;`;let ne=o<2?"":`
  fn o2i_${e}(offset: u32) -> ${x.indices} {
    var indices: ${x.indices};
    var current = offset;
    ${D}
    return indices;
  }`,he=ut=>(P.offsetToIndices=!0,o<2?ut:`o2i_${e}(${ut})`),be=[];if(o>=2)for(let ut=o-1;ut>=0;ut--)be.push(`${qt(Y,ut,o)} * (indices[${ut}])`);let Ye=o<2?"":`
  fn i2o_${e}(indices: ${x.indices}) -> u32 {
    return ${be.join("+")};
  }`,ze=ut=>(P.indicesToOffset=!0,o<2?ut:`i2o_${e}(${ut})`),Mt=(...ut)=>o===0?"0u":`${x.indices}(${ut.map(A).join(",")})`,Vt=(ut,St)=>o<2?`${ut}`:`${qt(ut,St,o)}`,jt=(ut,St,mr)=>o<2?`${ut}=${mr};`:`${qt(ut,St,o)}=${mr};`,lr={},Zt=(ut,St)=>{P.broadcastedIndicesToOffset=!0;let mr=`${St.name}broadcastedIndicesTo${e}Offset`;if(mr in lr)return`${mr}(${ut})`;let Wr=[];for(let qr=o-1;qr>=0;qr--){let Gn=St.indicesGet("outputIndices",qr+St.rank-o);Wr.push(`${Vt(Y,qr)} * (${Gn} % ${Vt(Q,qr)})`)}return lr[mr]=`fn ${mr}(outputIndices: ${St.type.indices}) -> u32 {
             return ${Wr.length>0?Wr.join("+"):"0u"};
           }`,`${mr}(${ut})`},ur=(ut,St)=>(()=>{if(x.storage===x.value)return`${e}[${ut}]=${St};`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`${e}[${ut}]=vec2<u32>(u32(${St}), select(0u, 0xFFFFFFFFu, ${St} < 0));`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`${e}[${ut}]=vec2<u32>(u32(${St}), 0u);`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`${e}[${ut}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${St}));`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),Sr=ut=>(()=>{if(x.storage===x.value)return`${e}[${ut}]`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`i32(${e}[${ut}].x)`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`u32(${e}[${ut}].x)`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${ut}] & 0xFFu), bool(${e}[${ut}] & 0xFF00u), bool(${e}[${ut}] & 0xFF0000u), bool(${e}[${ut}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),or=o<2?"":`
  fn get_${e}ByIndices(indices: ${x.indices}) -> ${y} {
    return ${Sr(`i2o_${e}(indices)`)};
  }`,Yt=o<2?"":(()=>{let ut=u.map(mr=>`d${mr}: u32`).join(", "),St=u.map(mr=>`d${mr}`).join(", ");return`
  fn get_${e}(${ut}) -> ${y} {
    return get_${e}ByIndices(${Mt(St)});
  }`})(),Tr=(...ut)=>{if(ut.length!==o)throw new Error(`indices length must be ${o}`);let St=ut.map(A).join(",");return o===0?Sr("0u"):o===1?Sr(St[0]):(P.get=!0,P.getByIndices=!0,P.indicesToOffset=!0,`get_${e}(${St})`)},xr=ut=>o<2?Sr(ut):(P.getByIndices=!0,P.indicesToOffset=!0,`get_${e}ByIndices(${ut})`),Xt=o<2?"":`
  fn set_${e}ByIndices(indices: ${x.indices}, value: ${y}) {
    ${ur(`i2o_${e}(indices)`,"value")}
  }`,yr=o<2?"":(()=>{let ut=u.map(mr=>`d${mr}: u32`).join(", "),St=u.map(mr=>`d${mr}`).join(", ");return`
  fn set_${e}(${ut}, value: ${y}) {
    set_${e}ByIndices(${Mt(St)}, value);
  }`})();return{impl:()=>{let ut=[],St=!1;return P.offsetToIndices&&(ut.push(ne),St=!0),P.indicesToOffset&&(ut.push(Ye),St=!0),P.broadcastedIndicesToOffset&&(Object.values(lr).forEach(mr=>ut.push(mr)),St=!0),P.set&&(ut.push(yr),St=!0),P.setByIndices&&(ut.push(Xt),St=!0),P.get&&(ut.push(Yt),St=!0),P.getByIndices&&(ut.push(or),St=!0),!s&&St&&ut.unshift(`const ${Q} = ${x.indices}(${r.join(",")});`,`const ${Y} = ${x.indices}(${De.computeStrides(r).join(",")});`),ut.join(`
`)},type:x,offsetToIndices:he,indicesToOffset:ze,broadcastedIndicesToOffset:Zt,indices:Mt,indicesGet:Vt,indicesSet:jt,set:(...ut)=>{if(ut.length!==o+1)throw new Error(`indices length must be ${o}`);let St=ut[o];if(typeof St!="string")throw new Error("value must be string");let mr=ut.slice(0,o).map(A).join(",");return o===0?ur("0u",St):o===1?ur(mr[0],St):(P.set=!0,P.setByIndices=!0,P.indicesToOffset=!0,`set_${e}(${mr}, ${St})`)},setByOffset:ur,setByIndices:(ut,St)=>o<2?ur(ut,St):(P.setByIndices=!0,P.indicesToOffset=!0,`set_${e}ByIndices(${ut}, ${St});`),get:Tr,getByOffset:Sr,getByIndices:xr,usage:n,name:e,strides:Y,shape:Q,rank:o}},ht=(e,t,r,n=1)=>is(e,t,r,"input",n),Kt=(e,t,r,n=1)=>is(e,t,r,"output",n),$s=(e,t,r,n=1)=>is(e,t,r,"internal",n),Ss=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=pn){let t=typeof e=="number"?e:e[0],r=typeof e=="number"?1:e[1],n=typeof e=="number"?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||r>this.limits.maxComputeWorkgroupSizeY||n>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${r}, ${n}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*r*n>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${r}, ${n}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,o=i?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${t*r*n}u + local_idx;`;return`@compute @workgroup_size(${t}, ${r}, ${n})
  fn main(${s}) {
    ${o}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let r=e.usage==="input"?"read":"read_write",n=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${r}> ${e.name}: array<${n}>;`}declareVariables(...e){return e.map(t=>this.declareVariable(t,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(t=>this.registerInternalVariable(t)),this}registerUniform(e,t,r=1){return this.uniforms.push({name:e,type:t,length:r}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:t,type:r,length:n}of this.uniforms)if(n&&n>4)r==="f16"?e.push(`@align(16) ${t}:array<mat2x4<${r}>, ${Math.ceil(n/8)}>`):e.push(`${t}:array<vec4<${r}>, ${Math.ceil(n/4)}>`);else{let i=n==null||n===1?r:`vec${n}<${r}>`;e.push(`${t}:${i}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let e=t=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(t)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},da=(e,t)=>new Ss(e,t),Mi=(e,t)=>{let r=e.length,n=[];for(let i=0;i<r;i++){let s=r-1-i,o=e[s]||1;(t[t.length-1-i]||1)>1&&o===1&&n.unshift(s)}return n}}),ca,ks,si,pa,Ed,Mn,Cd,ha,jn=j(()=>{rr(),Jt(),kr(),fr(),ca=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},ks=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,si=(e,t)=>De.sortBasedOnPerm(e,ks(e.length,t)),pa=(e,t,r,n)=>{let i=`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`;for(let s=0;s<t;++s)i+=r.indicesSet("a",e[s],`i[${s}]`);return i+="return a;}"},Ed=(e,t)=>{let r=[],n=[];for(let i=0;i<e.length;++i)e[i]!==1&&r.push(e[i]),e[t[i]]!==1&&n.push(t[i]);return{newShape:r,newPerm:n}},Mn=(e,t)=>{let r=e.dataType,n=e.dims.length,i=ks(n,t),s=si(e.dims,i),{newShape:o,newPerm:u}=Ed(e.dims,i),d=De.areEqual(u,[2,3,1]),h=De.areEqual(u,[3,1,2]),y=o.length===2&&u[0]>u[1]||d||h,l=y?o:e.dims,x=s;y&&(l=d?[o[0],o[1]*o[2]]:h?[o[0]*o[1],o[2]]:o,x=[l[1],l[0]]);let A=ht("a",r,l.length),P=Kt("output",r,x.length),S=16,Q;return y?Q=Y=>`
  ${Y.registerUniform("output_size","u32").declareVariables(A,P)}
  var<workgroup> tile : array<array<${P.type.value}, ${S+1}>, ${S}>;
  ${Y.mainStart([S,S,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${S} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${S}u + local_id.x;
    let input_row = workgroup_id_x * ${S}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${A.getByIndices(`${A.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${S}u + local_id.x;
    let output_row = workgroup_id_y * ${S}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${P.setByIndices(`${P.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`:Q=Y=>`
  ${Y.registerUniform("output_size","u32").declareVariables(A,P)}

  ${pa(i,n,A,P)}

  ${Y.mainStart()}
    ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${P.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${P.setByOffset("global_idx",A.getByIndices("aIndices"))}
  }`,{name:y?"TransposeShared":"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let Y=De.size(s);return{outputs:[{dims:s,dataType:e.dataType}],dispatchGroup:y?{x:Math.ceil(x[1]/S),y:Math.ceil(x[0]/S)}:{x:Math.ceil(Y/64)},programUniforms:[{type:12,data:Y},...Ot(l,x)]}},getShaderSource:Q}},Cd=(e,t)=>{ca(e.inputs),e.compute(Mn(e.inputs[0],t.perm))},ha=e=>hr({perm:e.perm})}),fa,ma,ga,_a,wa,Ps,ya,ba,As,Ma,Pn,Is,va,xa,Fs,Ta,Ea,Os,Ca,$a,Bs,$d=j(()=>{rr(),Jt(),fr(),Gs(),jn(),fa={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},ma={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},ga={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},_a={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},wa=(e,t)=>{let r=[];for(let n=t-e;n<t;++n)r.push(n);return r},Ps=(e,t)=>{let r=[],n=e.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&r.push(e[s]);let i=t.map(s=>e[s]);return[r,i]},ya=(e,t)=>{let r=e.length+t.length,n=[],i=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?n.push(e[i++]):n.push(1);return n},ba=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},As=(e,t)=>{let r=[];if(!ba(e,t)){for(let n=0;n<t;++n)e.indexOf(n)===-1&&r.push(n);e.forEach(n=>r.push(n))}return r},Ma=(e,t,r,n,i,s,o)=>{let u=r[0].dims,d=De.size(s),h=De.size(o),y=ht("_A",r[0].dataType,u),l=Kt("output",i,s),x=32,A=`
          var<workgroup> aBestValues : array<f32, ${x}>;
       `;return{name:e,shaderCache:t,getShaderSource:P=>`
        ${P.registerUniform("reduceSize","u32").declareVariables(y,l)}
        ${A}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${P.mainStart(x)}

          let outputIndex = global_idx / ${x};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${ga[n]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${x}) {
           let candidate = f32(${y.getByOffset("offset + k")});
           bestValue = ${fa[n]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${x}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${ma[n]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${l.setByOffset("outputIndex",`${n==="mean"?`${l.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${l.type.storage}(${_a[n]})`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:d},programUniforms:[{type:12,data:h}]})}},Pn=(e,t,r,n)=>{let i=e.inputs.length===1?r:zs(e.inputs,r),s=i.axes;s.length===0&&!i.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((A,P)=>P));let o=De.normalizeAxes(s,e.inputs[0].dims.length),u=o,d=e.inputs[0],h=As(u,e.inputs[0].dims.length);h.length>0&&(d=e.compute(Mn(e.inputs[0],h),{inputs:[0],outputs:[-1]})[0],u=wa(u.length,d.dims.length));let[y,l]=Ps(d.dims,u),x=y;i.keepDims&&(x=ya(y,o)),e.compute(Ma(t,{hint:i.cacheKey,inputDependencies:["type"]},[d],n,e.inputs[0].dataType,x,l),{inputs:[d]})},Is=(e,t)=>{Pn(e,"ReduceMeanShared",t,"mean")},va=(e,t)=>{Pn(e,"ReduceL1Shared",t,"l1")},xa=(e,t)=>{Pn(e,"ReduceL2Shared",t,"l2")},Fs=(e,t)=>{Pn(e,"ReduceLogSumExpShared",t,"logSumExp")},Ta=(e,t)=>{Pn(e,"ReduceMaxShared",t,"max")},Ea=(e,t)=>{Pn(e,"ReduceMinShared",t,"min")},Os=(e,t)=>{Pn(e,"ReduceProdShared",t,"prod")},Ca=(e,t)=>{Pn(e,"ReduceSumShared",t,"sum")},$a=(e,t)=>{Pn(e,"ReduceSumSquareShared",t,"sumSquare")},Bs=(e,t)=>{Pn(e,"ReduceLogSumShared",t,"logSum")}}),An,Ds,ss,zs,Tn,Sa,ka,Ls,Pa,Aa,Rs,Ia,Fa,Ns,Oa,In,js,Ba,Da,Us,za,La,Vs,Ra,Na,Ws,Gs=j(()=>{rr(),Jt(),kr(),fr(),$d(),An=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Ds=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],ss=(e,t,r,n,i,s,o=!1,u=!1)=>{let d=[],h=r[0].dims,y=h.length,l=De.normalizeAxes(i,y),x=!u&&l.length===0;h.forEach((S,Q)=>{x||l.indexOf(Q)>=0?o&&d.push(1):d.push(S)});let A=d.length,P=De.size(d);return{name:e,shaderCache:t,getShaderSource:S=>{let Q=[],Y=ht("_A",r[0].dataType,y),D=Kt("output",s,A),ne=n(Y,D,l),he=ne[2];for(let be=0,Ye=0;be<y;be++)x||l.indexOf(be)>=0?(o&&Ye++,he=`for(var j${be}: u32 = 0; j${be} < ${h[be]}; j${be}++) {
                  ${ne[2].includes("last_index")?`let last_index = j${be};`:""}
                  ${Y.indicesSet("input_indices",be,`j${be}`)}
                  ${he}
                }`):(Q.push(`${Y.indicesSet("input_indices",be,D.indicesGet("output_indices",Ye))};`),Ye++);return`

        ${S.registerUniform("output_size","u32").declareVariables(Y,D)}

        ${S.mainStart()}
          ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${Y.type.indices};
          let output_indices = ${D.offsetToIndices("global_idx")};

          ${Q.join(`
`)}
          ${ne[0]}       // init ops for reduce max/min
          ${ne[1]}
          ${he}
          ${ne[3]}
          ${ne.length===4?D.setByOffset("global_idx","value"):ne.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:d,dataType:s}],dispatchGroup:{x:Math.ceil(P/64)},programUniforms:[{type:12,data:P},...Ot(h,d)]})}},zs=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),hr({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},Tn=(e,t,r,n)=>{let i=e.inputs,s=i.length===1?r:zs(i,r);e.compute(ss(t,{hint:s.cacheKey,inputDependencies:["rank"]},[i[0]],s.noopWithEmptyAxes&&s.axes.length===0?Ds:n,s.axes,i[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Sa=(e,t)=>{An(e.inputs),Tn(e,"ReduceLogSum",t,(r,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${r.getByIndices("input_indices")};`,"value = log(value);"])},ka=(e,t)=>{An(e.inputs),Tn(e,"ReduceL1",t,(r,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${r.getByIndices("input_indices")});`,""])},Ls=(e,t)=>{An(e.inputs),Tn(e,"ReduceL2",t,(r,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${r.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},Pa=(e,t)=>{An(e.inputs),Tn(e,"ReduceLogSumExp",t,(r,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${r.getByIndices("input_indices")});`,"value = log(value);"])},Aa=(e,t)=>{An(e.inputs),Tn(e,"ReduceMax",t,(r,n,i)=>{let s=[];for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&s.push(r.indicesSet("input_indices",o,0));return[`${s.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};`,`value = max(value, ${r.getByIndices("input_indices")});`,""]})},Rs=(e,t)=>{An(e.inputs),Tn(e,"ReduceMean",t,(r,n,i)=>{let s=1;for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&(s*=e.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${r.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]})},Ia=(e,t)=>{An(e.inputs),Tn(e,"ReduceMin",t,(r,n,i)=>{let s=[];for(let o=0;o<r.rank;o++)(i.indexOf(o)>=0||i.length===0)&&s.push(`input_indices[${o}] = 0;`);return[`${s.join(`
`)}`,`var value = ${r.getByIndices("input_indices")};`,`value = min(value, ${r.getByIndices("input_indices")});`,""]})},Fa=(e,t)=>{An(e.inputs),Tn(e,"ReduceProd",t,(r,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${r.getByIndices("input_indices")};`,""])},Ns=(e,t)=>{An(e.inputs),Tn(e,"ReduceSum",t,(r,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${r.getByIndices("input_indices")};`,""])},Oa=(e,t)=>{An(e.inputs),Tn(e,"ReduceSumSquare",t,(r,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${r.getByIndices("input_indices")}; value += t * t;`,""])},In=(e,t,r)=>{if(t.length===0)return r;let n=1,i=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?n*=e[s]:i*=e[s];return i<32&&n>1024},js=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Rs(e,t):Is(e,t)},Ba=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ka(e,t):va(e,t)},Da=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ls(e,t):xa(e,t)},Us=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Pa(e,t):Fs(e,t)},za=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Aa(e,t):Ta(e,t)},La=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ia(e,t):Ea(e,t)},Vs=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Fa(e,t):Os(e,t)},Ra=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ns(e,t):Ca(e,t)},Na=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Oa(e,t):$a(e,t)},Ws=(e,t)=>{In(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sa(e,t):Bs(e,t)}}),qs,Hs,ja,Ks,Ua=j(()=>{rr(),kr(),Gs(),qs=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Hs=(e,t)=>{qs(e.inputs);let r=(n,i,s)=>{let o=[];for(let u=0;u<n.rank;u++)(s.indexOf(u)>=0||s.length===0)&&o.push(`input_indices[${u}] = 0;`);return[`${o.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${n.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${n.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(ss("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ja=(e,t)=>{qs(e.inputs);let r=(n,i,s)=>{let o=[];for(let u=0;u<n.rank;u++)(s.indexOf(u)>=0||s.length===0)&&o.push(`input_indices[${u}] = 0;`);return[`${o.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${n.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${n.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",i.setByOffset("global_idx","best_index")]};e.compute(ss("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Ks=e=>hr(e)}),Va,os,Xs,Wa,Ga,vi,qa,Ha,as=j(()=>{rr(),Jt(),me(),fr(),Va=(e,t)=>{let r=e[0],n=e[1],i=e[2],s=e[3],o=e[4],u=e[5];if(o&&u)throw new Error("Attention cannot have both past and attention_bias");if(r.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let d=r.dims[0],h=r.dims[1],y=r.dims[2];if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(n.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(n.dims[0]!==y)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(i.dims[0]!==n.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let l=i.dims[0]/3,x=l,A=x;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let ne of t.qkvHiddenSizes)if(ne%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");l=t.qkvHiddenSizes[0],x=t.qkvHiddenSizes[1],A=t.qkvHiddenSizes[2]}let P=h;if(l!==x)throw new Error("qkv_hidden_sizes first element should be same as the second");if(i.dims[0]!==l+x+A)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let S=0;if(o){if(x!==A)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(o.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(o.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(o.dims[1]!==d)throw new Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==x/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(S=o.dims[3])}let Q=P+S,Y=-1,D=0;if(s)throw new Error("Mask not supported");if(o)throw new Error("past is not supported");if(u){if(u.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(u.dims[0]!==d||u.dims[1]!==t.numHeads||u.dims[2]!==h||u.dims[3]!==Q)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:d,sequenceLength:h,pastSequenceLength:S,kvSequenceLength:P,totalSequenceLength:Q,maxSequenceLength:Y,inputHiddenSize:y,hiddenSize:l,vHiddenSize:A,headSize:Math.floor(l/t.numHeads),vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:D,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},os=(e,t,r)=>t&&e?`
      let total_sequence_length_input = u32(${t.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${r?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,Xs=(e,t,r,n,i,s,o,u)=>{let d=br(o?1:s),h=64,y=s/d;y<h&&(h=32);let l=Math.ceil(s/d/h),x=[{type:12,data:t},{type:12,data:r},{type:12,data:n},{type:12,data:i},{type:12,data:y},{type:12,data:l}],A=_r(e.dataType,d),P=Br(1,d),S=["type"];o&&S.push("type"),u&&S.push("type");let Q=Y=>{let D=Kt("x",e.dataType,e.dims,d),ne=[D],he=o?ht("seq_lens",o.dataType,o.dims):void 0;he&&ne.push(he);let be=u?ht("total_sequence_length_input",u.dataType,u.dims):void 0;be&&ne.push(be);let Ye=Br(e.dataType),ze=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${h}>;
  var<workgroup> thread_sum: array<f32, ${h}>;
  ${Y.registerUniforms(ze).declareVariables(...ne)}
  ${Y.mainStart([h,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${os(he,be,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${h}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${P}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${P}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(d){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${h}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${P}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${P}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(d){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${h}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${D.type.value}(${Ye}(1.0) / ${Ye}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${P}(x[offset + i]);
        x[offset + i] = ${D.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${D.type.value}(${Ye}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${h};${A};${d}`,inputDependencies:S},getShaderSource:Q,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(s/h),y:i,z:t*r},programUniforms:x})}},Wa=(e,t,r,n,i,s,o,u,d)=>{let h=o+s.kvSequenceLength,y=[s.batchSize,s.numHeads,s.sequenceLength,h],l=e>1&&n,x=s.kvNumHeads?s.kvNumHeads:s.numHeads,A=l?[s.batchSize,x,h,s.headSize]:void 0,P=s.nReps?s.nReps:1,S=s.scale===0?1/Math.sqrt(s.headSize):s.scale,Q=br(s.headSize),Y=s.headSize/Q,D=12,ne={x:Math.ceil(h/D),y:Math.ceil(s.sequenceLength/D),z:s.batchSize*s.numHeads},he=[{type:12,data:s.sequenceLength},{type:12,data:Y},{type:12,data:h},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:1,data:S},{type:12,data:o},{type:12,data:s.kvSequenceLength},{type:12,data:P}],be=l&&n&&De.size(n.dims)>0,Ye=["type","type"];be&&Ye.push("type"),i&&Ye.push("type"),u&&Ye.push("type"),d&&Ye.push("type");let ze=[{dims:y,dataType:t.dataType,gpuDataType:0}];l&&ze.push({dims:A,dataType:t.dataType,gpuDataType:0});let Mt=Vt=>{let jt=ht("q",t.dataType,t.dims,Q),lr=ht("key",r.dataType,r.dims,Q),Zt=[jt,lr];if(be){let Xt=ht("past_key",n.dataType,n.dims,Q);Zt.push(Xt)}i&&Zt.push(ht("attention_bias",i.dataType,i.dims));let ur=u?ht("seq_lens",u.dataType,u.dims):void 0;ur&&Zt.push(ur);let Sr=d?ht("total_sequence_length_input",d.dataType,d.dims):void 0;Sr&&Zt.push(Sr);let or=Kt("output",t.dataType,y),Yt=[or];l&&Yt.push(Kt("present_key",t.dataType,A,Q));let Tr=Br(1,Q),xr=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${D}u;

  var<workgroup> tileQ: array<${jt.type.storage}, ${D*D}>;
  var<workgroup> tileK: array<${jt.type.storage}, ${D*D}>;
  ${Vt.registerUniforms(xr).declareVariables(...Zt,...Yt)}
  ${Vt.mainStart([D,D,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${P===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${P===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${os(ur,Sr,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${be&&l?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${l?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${Tr}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${be&&l?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${l?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${Tr}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(Q){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${Q}`)}})()};
        output[outputIdx] = ${or.type.value} (sum * uniforms.alpha) + ${i?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${Q};${i!==void 0};${n!==void 0};${e}`,inputDependencies:Ye},getRunData:()=>({outputs:ze,dispatchGroup:ne,programUniforms:he}),getShaderSource:Mt}},Ga=(e,t,r,n,i,s,o=void 0,u=void 0)=>{let d=s+i.kvSequenceLength,h=i.nReps?i.nReps:1,y=i.vHiddenSize*h,l=e>1&&n,x=i.kvNumHeads?i.kvNumHeads:i.numHeads,A=l?[i.batchSize,x,d,i.headSize]:void 0,P=[i.batchSize,i.sequenceLength,y],S=12,Q={x:Math.ceil(i.vHeadSize/S),y:Math.ceil(i.sequenceLength/S),z:i.batchSize*i.numHeads},Y=[{type:12,data:i.sequenceLength},{type:12,data:d},{type:12,data:i.vHeadSize},{type:12,data:i.numHeads},{type:12,data:i.headSize},{type:12,data:y},{type:12,data:s},{type:12,data:i.kvSequenceLength},{type:12,data:h}],D=l&&n&&De.size(n.dims)>0,ne=["type","type"];D&&ne.push("type"),o&&ne.push("type"),u&&ne.push("type");let he=[{dims:P,dataType:t.dataType,gpuDataType:0}];l&&he.push({dims:A,dataType:t.dataType,gpuDataType:0});let be=Ye=>{let ze=ht("probs",t.dataType,t.dims),Mt=ht("v",r.dataType,r.dims),Vt=[ze,Mt];D&&Vt.push(ht("past_value",n.dataType,n.dims));let jt=o?ht("seq_lens",o.dataType,o.dims):void 0;o&&Vt.push(jt);let lr=u?ht("total_sequence_length_input",u.dataType,u.dims):void 0;u&&Vt.push(lr);let Zt=[Kt("output",t.dataType,P)];l&&Zt.push(Kt("present_value",t.dataType,A));let ur=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${S}u;
  var<workgroup> tileQ: array<${ze.type.value}, ${S*S}>;
  var<workgroup> tileV: array<${ze.type.value}, ${S*S}>;
  ${Ye.registerUniforms(ur).declareVariables(...Vt,...Zt)}
  ${Ye.mainStart([S,S,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${h===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${h===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${os(jt,lr,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${D&&l?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${l?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${ze.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${D&&l?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${l?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${n!==void 0};${e}`,inputDependencies:ne},getRunData:()=>({outputs:he,dispatchGroup:Q,programUniforms:Y}),getShaderSource:be}},vi=(e,t,r,n,i,s,o,u,d,h,y=void 0,l=void 0)=>{let x=Math.min(e.outputCount,1+(o?1:0)+(u?1:0)),A=x>1?h.pastSequenceLength:0,P=A+h.kvSequenceLength,S=d&&De.size(d.dims)>0?d:void 0,Q=[t,r];x>1&&o&&De.size(o.dims)>0&&Q.push(o),S&&Q.push(S),y&&Q.push(y),l&&Q.push(l);let Y=e.compute(Wa(x,t,r,o,S,h,A,y,l),{inputs:Q,outputs:x>1?[-1,1]:[-1]})[0];e.compute(Xs(Y,h.batchSize,h.numHeads,A,h.sequenceLength,P,y,l),{inputs:y&&l?[Y,y,l]:[Y],outputs:[]});let D=[Y,n];x>1&&u&&De.size(u.dims)>0&&D.push(u),y&&D.push(y),l&&D.push(l),e.compute(Ga(x,Y,n,u,h,A,y,l),{inputs:D,outputs:x>1?[0,2]:[0]})},qa=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],n=t.sequenceLength,i=t.inputHiddenSize,s=t.headSize,o=12,u={x:Math.ceil(t.headSize/o),y:Math.ceil(t.sequenceLength/o),z:t.batchSize*t.numHeads},d=[e.inputs[0],e.inputs[1],e.inputs[2]],h=[{type:12,data:n},{type:12,data:i},{type:12,data:s},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],y=l=>{let x=Kt("output_q",d[0].dataType,r),A=Kt("output_k",d[0].dataType,r),P=Kt("output_v",d[0].dataType,r),S=ht("input",d[0].dataType,d[0].dims),Q=ht("weight",d[1].dataType,d[1].dims),Y=ht("bias",d[2].dataType,d[2].dims),D=S.type.storage,ne=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${D}, ${o*o}>;
  var<workgroup> tileWeightQ: array<${D}, ${o*o}>;
  var<workgroup> tileWeightK: array<${D}, ${o*o}>;
  var<workgroup> tileWeightV: array<${D}, ${o*o}>;
  ${l.registerUniforms(ne).declareVariables(S,Q,Y,x,A,P)}
  ${l.mainStart([o,o,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${D}(0);
    var valueK = ${D}(0);
    var valueV = ${D}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:u,programUniforms:h}),getShaderSource:y},{inputs:d,outputs:[-1,-1,-1]})},Ha=(e,t)=>{let r=Va(e.inputs,t),[n,i,s]=qa(e,r);return vi(e,n,i,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r)}}),Ka,Xa,Ys,Ya,Sd=j(()=>{c(),rr(),Jt(),kr(),fr(),Ka=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(n,i,s)=>{let o=i.length;if(o!==n.length)throw new Error(`${s}: num dimensions != ${o}`);i.forEach((u,d)=>{if(u!==n[d])throw new Error(`${s}: dim[${d}] do not match`)})};if(e[0].dims.length>1){let n=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,n,"Invalid input scale"),r(e[2].dims,n,"Invalid input B"),r(e[3].dims,n,"Invalid input mean"),r(e[4].dims,n,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},Xa=(e,t)=>{let{epsilon:r,spatial:n,format:i}=t,s=e[0].dims,o=n?br(s[s.length-1]):1,u=i==="NHWC"&&s.length>1?o:1,d=De.size(s)/o,h=n,y=h?s.length:s,l=ht("x",e[0].dataType,e[0].dims,o),x=ht("scale",e[1].dataType,e[1].dims,u),A=ht("bias",e[2].dataType,e[2].dims,u),P=ht("inputMean",e[3].dataType,e[3].dims,u),S=ht("inputVar",e[4].dataType,e[4].dims,u),Q=Kt("y",e[0].dataType,y,o),Y=()=>{let ne="";if(n)ne=`let cOffset = ${s.length===1?"0u":i==="NHWC"?`outputIndices[${s.length-1}] / ${o}`:"outputIndices[1]"};`;else if(i==="NCHW")ne=`
            ${Q.indicesSet("outputIndices","0","0")}
            let cOffset = ${Q.indicesToOffset("outputIndices")};`;else{ne=`var cIndices = ${x.type.indices}(0);
                       cIndices[0] = outputIndices[${s.length-1}];`;for(let he=1;he<x.rank;he++)ne+=`cIndices[${he}] = outputIndices[${he}];`;ne+=`let cOffset = ${x.indicesToOffset("cIndices")};`}return ne},D=ne=>`
  const epsilon = ${r};
  ${ne.registerUniform("outputSize","u32").declareVariables(l,x,A,P,S,Q)}
  ${ne.mainStart()}
  ${ne.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${Q.offsetToIndices(`global_idx * ${o}`)};
    ${Y()}
    let scale = ${x.getByOffset("cOffset")};
    let bias = ${A.getByOffset("cOffset")};
    let inputMean = ${P.getByOffset("cOffset")};
    let inputVar = ${S.getByOffset("cOffset")};
    let x = ${l.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${Q.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${n}_${o}`,inputDependencies:h?["rank","type","type","type","type"]:void 0},getShaderSource:D,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h?[{type:12,data:d},...Ot(s)]:[{type:12,data:d}]})}},Ys=e=>hr(e),Ya=(e,t)=>{let{inputs:r,outputCount:n}=e,i=Ys({...t,outputCount:n});if(I.webgpu.validateInputContent&&Ka(r,i),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Xa(r,i))}}),Qs,Qa,Za,Ja=j(()=>{Jt(),fr(),Qs=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Qa=e=>{let t=e[0].dims,r=e[0].dims[2],n=De.size(t)/4,i=e[0].dataType,s=ht("input",i,t,4),o=ht("bias",i,[r],4),u=ht("residual",i,t,4),d=Kt("output",i,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:h=>`
  const channels = ${r}u / 4;
  ${h.declareVariables(s,o,u,d)}

  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let value = ${s.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${u.getByOffset("global_idx")};
    ${d.setByOffset("global_idx","value")}
  }`}},Za=e=>{Qs(e.inputs),e.compute(Qa(e.inputs))}}),el,Ir,Zs,tl,rl,nl,il,Js,sl,ol,al,ll,eo,ul,dl,cl,Ri,to,ls,pl,ro,hl,fl,no,ml,gl,io,_l,wl,so,yl,bl,us,Ml,vl,ds,oo,ao,cs,xl,Tl,El,lo,Cl,$l,uo=j(()=>{rr(),Jt(),kr(),fr(),el=(e,t,r,n,i,s,o)=>{let u=Math.ceil(t/4),d="";typeof i=="string"?d=`${i}(a)`:d=i("a");let h=ht("inputData",r,[u],4),y=Kt("outputData",n,[u],4),l=[{name:"vec_size",type:"u32"}];return o&&l.push(...o),`
      ${e.registerUniforms(l).declareVariables(h,y)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${h.getByOffset("global_idx")};
    ${y.setByOffset("global_idx",d)}
  }`},Ir=(e,t,r,n,i,s=e.dataType,o,u)=>{let d=[{type:12,data:Math.ceil(De.size(e.dims)/4)}];return o&&d.push(...o),{name:t,shaderCache:{hint:i,inputDependencies:["type"]},getShaderSource:h=>el(h,De.size(e.dims),e.dataType,s,r,n,u),getRunData:h=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(De.size(h[0].dims)/64/4)},programUniforms:d})}},Zs=e=>{e.compute(Ir(e.inputs[0],"Abs","abs"))},tl=e=>{e.compute(Ir(e.inputs[0],"Acos","acos"))},rl=e=>{e.compute(Ir(e.inputs[0],"Acosh","acosh"))},nl=e=>{e.compute(Ir(e.inputs[0],"Asin","asin"))},il=e=>{e.compute(Ir(e.inputs[0],"Asinh","asinh"))},Js=e=>{e.compute(Ir(e.inputs[0],"Atan","atan"))},sl=e=>{e.compute(Ir(e.inputs[0],"Atanh","atanh"))},ol=e=>hr(e),al=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Ir(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},ll=e=>{let t,r,n=e.length>=2&&e[1].data!==0,i=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=n?e[1].getFloat32Array()[0]:-34028234663852886e22,r=i?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=n?e[1].getUint16Array()[0]:64511,r=i?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return hr({min:t,max:r})},eo=(e,t)=>{let r=t||ll(e.inputs),n=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"Clip",i=>`clamp(${i}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`,void 0,r.cacheKey,void 0,[{type:e.inputs[0].dataType,data:r.min},{type:e.inputs[0].dataType,data:r.max}],[{name:"min",type:n},{name:"max",type:n}]),{inputs:[0]})},ul=e=>{e.compute(Ir(e.inputs[0],"Ceil","ceil"))},dl=e=>{e.compute(Ir(e.inputs[0],"Cos","cos"))},cl=e=>{e.compute(Ir(e.inputs[0],"Cosh","cosh"))},Ri=e=>hr(e),to=(e,t)=>{let r=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"Elu",n=>`elu_vf32(${n})`,`
  const elu_alpha_ = ${r}(${t.alpha});

  fn elu_f32(a: ${r}) -> ${r} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},ls=(e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,pl=e=>{let t=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,ls(t)))},ro=e=>{e.compute(Ir(e.inputs[0],"Exp","exp"))},hl=e=>{e.compute(Ir(e.inputs[0],"Floor","floor"))},fl=e=>{let t=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,ls(t)))},no=(e,t)=>{let r=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"LeakyRelu",n=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},ml=e=>{e.compute(Ir(e.inputs[0],"Not",t=>`!${t}`))},gl=e=>{e.compute(Ir(e.inputs[0],"Neg",t=>`-${t}`))},io=e=>{e.compute(Ir(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},_l=e=>{let t=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},wl=e=>{e.compute(Ir(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},so=e=>hr(e),yl=(e,t)=>{let r=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"HardSigmoid",n=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${n} + vec4<${r}>(${t.beta})))`,void 0,t.cacheKey))},bl=e=>{e.compute(Ir(e.inputs[0],"Sin","sin"))},us=e=>{e.compute(Ir(e.inputs[0],"Sinh","sinh"))},Ml=e=>{e.compute(Ir(e.inputs[0],"Sqrt","sqrt"))},vl=e=>{e.compute(Ir(e.inputs[0],"Tan","tan"))},ds=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,oo=e=>{e.compute(Ir(e.inputs[0],"Tanh",ds))},ao=(e="f32")=>`
const fast_gelu_a: ${e} = 0.5;
const fast_gelu_b: ${e} = 0.7978845608028654;
const fast_gelu_c: ${e} = 0.035677408136300125;

fn tanh_v(v: vec4<${e}>) -> vec4<${e}> {
  return ${ds("v")};
}
`,cs=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,xl=e=>{let t=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"FastGelu",cs,ao(t),void 0,e.inputs[0].dataType))},Tl=(e,t)=>{let r=Br(e.inputs[0].dataType);return e.compute(Ir(e.inputs[0],"ThresholdedRelu",n=>`select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},El=e=>{e.compute(Ir(e.inputs[0],"Log","log"))},lo=(e,t)=>`
const alpha = vec4<${e}>(${t});
const one = ${e}(1.0);
const zero = ${e}(0.0);

fn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {
  let v = x *alpha;
  var x1 : vec4<${e}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,Cl=e=>`quick_gelu_impl(${e})`,$l=(e,t)=>{let r=Br(e.inputs[0].dataType);e.compute(Ir(e.inputs[0],"QuickGelu",Cl,lo(r,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),co,Sl,kl,Pl=j(()=>{Jt(),fr(),uo(),co=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Sl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=ht("input",e[0].dataType,e[0].dims,4),n=ht("bias",e[0].dataType,[e[0].dims[2]],4),i=Kt("output",e[0].dataType,t,4),s=De.size(t)/4,o=_r(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:u=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${u.declareVariables(r,n,i)}

  ${ls(o)}

  ${u.mainStart()}
    ${u.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${i.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},kl=e=>{co(e.inputs),e.compute(Sl(e.inputs))}}),Al,Il,En,Fl,Ol,po,Bl,Dl,ho,zl,Ll,fo,Rl,kd=j(()=>{rr(),Jt(),fr(),Al=(e,t,r,n,i,s,o,u,d,h,y,l)=>{let x,A;typeof u=="string"?x=A=(D,ne)=>`${u}((${D}),(${ne}))`:typeof u=="function"?x=A=u:(x=u.scalar,A=u.vector);let P=Kt("outputData",y,n.length,4),S=ht("aData",d,t.length,4),Q=ht("bData",h,r.length,4),Y;if(i)if(s){let D=De.size(t)===1,ne=De.size(r)===1,he=t.length>0&&t[t.length-1]%4===0,be=r.length>0&&r[r.length-1]%4===0;D||ne?Y=P.setByOffset("global_idx",A(D?`${S.type.value}(${S.getByOffset("0")}.x)`:S.getByOffset("global_idx"),ne?`${Q.type.value}(${Q.getByOffset("0")}.x)`:Q.getByOffset("global_idx"))):Y=`
            let outputIndices = ${P.offsetToIndices("global_idx * 4u")};
            let offsetA = ${S.broadcastedIndicesToOffset("outputIndices",P)};
            let offsetB = ${Q.broadcastedIndicesToOffset("outputIndices",P)};
            ${P.setByOffset("global_idx",A(o||he?S.getByOffset("offsetA / 4u"):`${S.type.value}(${S.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||be?Q.getByOffset("offsetB / 4u"):`${Q.type.value}(${Q.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else Y=P.setByOffset("global_idx",A(S.getByOffset("global_idx"),Q.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let D=(ne,he,be="")=>{let Ye=`aData[indexA${he}][componentA${he}]`,ze=`bData[indexB${he}][componentB${he}]`;return`
            let outputIndices${he} = ${P.offsetToIndices(`global_idx * 4u + ${he}u`)};
            let offsetA${he} = ${S.broadcastedIndicesToOffset(`outputIndices${he}`,P)};
            let offsetB${he} = ${Q.broadcastedIndicesToOffset(`outputIndices${he}`,P)};
            let indexA${he} = offsetA${he} / 4u;
            let indexB${he} = offsetB${he} / 4u;
            let componentA${he} = offsetA${he} % 4u;
            let componentB${he} = offsetB${he} % 4u;
            ${ne}[${he}] = ${be}(${x(Ye,ze)});
          `};y===9?Y=`
            var data = vec4<u32>(0);
            ${D("data",0,"u32")}
            ${D("data",1,"u32")}
            ${D("data",2,"u32")}
            ${D("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:Y=`
            ${D("outputData[global_idx]",0)}
            ${D("outputData[global_idx]",1)}
            ${D("outputData[global_idx]",2)}
            ${D("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(S,Q,P)}

        ${l??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${Y}
      }`},Il=(e,t,r,n,i,s,o=r.dataType)=>{let u=!De.areEqual(r.dims,n.dims),d=r.dims,h=De.size(r.dims),y=!1,l=!1,x=[u];if(u){let A=Sn.calcShape(r.dims,n.dims,!1);if(!A)throw new Error("Can't perform binary op on the given tensors");d=A,h=De.size(d);let P=De.size(r.dims)===1,S=De.size(n.dims)===1,Q=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,Y=n.dims.length>0&&n.dims[n.dims.length-1]%4===0;x.push(P),x.push(S),x.push(Q),x.push(Y);let D=1;for(let ne=1;ne<d.length;ne++){let he=r.dims[r.dims.length-ne]??1,be=n.dims[n.dims.length-ne]??1;if(he===be)D*=he;else break}D%4===0?(l=!0,y=!0):(P||S||Q||Y)&&(y=!0)}else y=!0;return x.push(y),{name:e,shaderCache:{hint:t+x.map(A=>A.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:A=>Al(A,r.dims,n.dims,d,y,u,l,i,r.dataType,n.dataType,o,s),getRunData:()=>({outputs:[{dims:d,dataType:o}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(De.size(d)/4)},...Ot(r.dims,n.dims,d)]})}},En=(e,t,r,n,i,s)=>{e.compute(Il(t,i??"",e.inputs[0],e.inputs[1],r,n,s))},Fl=e=>{En(e,"Add",(t,r)=>`${t}+${r}`)},Ol=e=>{En(e,"Div",(t,r)=>`${t}/${r}`)},po=e=>{En(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Bl=e=>{En(e,"Mul",(t,r)=>`${t}*${r}`)},Dl=e=>{let t=ht("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;En(e,"Pow",{scalar:(r,n)=>`pow_custom(${r},${n})`,vector:(r,n)=>`pow_vector_custom(${r},${n})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},ho=e=>{En(e,"Sub",(t,r)=>`${t}-${r}`)},zl=e=>{En(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ll=e=>{En(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},fo=e=>{En(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Rl=e=>{En(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}}),Nl,jl,ps,Ul,Vl,Wl,Pd=j(()=>{rr(),Jt(),kr(),fr(),Nl=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let r=0,n=e[r],i=n.dataType,s=n.dims.length;e.forEach((o,u)=>{if(u!==r){if(o.dataType!==i)throw new Error("input tensors should be one type");if(o.dims.length!==s)throw new Error("input tensors should have the same shape");o.dims.forEach((d,h)=>{if(h!==t&&d!==n.dims[h])throw new Error("non concat dimensions must match")})}})},jl=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,ps=(e,t)=>{let r=e.length,n=[];for(let i=0;i<r;++i){let s=t.setByOffset("global_idx",e[i].getByIndices("indices"));r===1?n.push(s):i===0?n.push(`if (inputIndex == ${i}u) { ${s} }`):i===r-1?n.push(`else { ${s} }`):n.push(`else if (inputIndex == ${i}) { ${s} }`)}return n.join(`
`)},Ul=(e,t,r,n)=>{let i=De.size(r),s=new Array(e.length),o=new Array(e.length),u=0,d=[],h=[],y=[{type:12,data:i}];for(let S=0;S<e.length;++S)u+=e[S].dims[t],s[S]=u,h.push(e[S].dims.length),o[S]=ht(`input${S}`,n,h[S]),d.push("rank"),y.push({type:12,data:s[S]});for(let S=0;S<e.length;++S)y.push(...Ot(e[S].dims));y.push(...Ot(r));let l=Kt("output",n,r.length),x=l.indicesGet("indices",t),A=Array.from(Array(s.length).keys()).map(S=>`uniforms.sizeInConcatAxis${S}`).join(","),P=S=>`

  ${(()=>{S.registerUniform("outputSize","u32");for(let Q=0;Q<e.length;Q++)S.registerUniform(`sizeInConcatAxis${Q}`,"u32");return S.declareVariables(...o,l)})()}

  ${jl(s.length,A)}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${l.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${x});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${s.length}u>(${A});
      ${x} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${ps(o,l)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:n}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:y}),getShaderSource:P}},Vl=(e,t)=>{let r=e.inputs,n=r[0].dims,i=De.normalizeAxis(t.axis,n.length);Nl(r,i);let s=n.slice();s[i]=r.reduce((u,d)=>u+(d.dims.length>i?d.dims[i]:0),0);let o=r.filter(u=>De.size(u.dims)>0);e.compute(Ul(o,i,s,r[0].dataType),{inputs:o})},Wl=e=>hr({axis:e.axis})}),Zn,Un,Jn,mo,Vn=j(()=>{rr(),Jt(),Zn=(e,t,r="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Un=(e,t)=>{e.activation==="Clip"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation==="HardSigmoid"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation==="LeakyRelu"&&t.push({type:1,data:e.alpha})},Jn=(e,t)=>{e.activation==="Clip"?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):e.activation==="HardSigmoid"?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):e.activation==="LeakyRelu"&&t.push({name:"alpha",type:"f32"})},mo=e=>{let t=e?.activation||"";if(t==="HardSigmoid"){let[r,n]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:n}}else if(t==="Clip"){let[r,n]=e?.activation_params||[kn,Rn];return{activation:t,clipMax:n,clipMin:r}}else if(t==="LeakyRelu"){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}}),hn,go,hs=j(()=>{hn=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},go=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `}),_o,wo=j(()=>{_o=e=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));
}
`}),Gl,ql,Ni,yo,Hl,ji,Kl,bo,Ui=j(()=>{rr(),Jt(),fr(),Vn(),hs(),Gl=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,ql=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,Ni=(e,t,r="f32",n,i=!1,s=32,o=!1,u=32)=>{let d=t[1]*e[1],h=t[0]*e[0],y=i?d:s,l=i?s:d,x=y/t[0],A=s/t[1];if(!((i&&x===4&&e[1]===4||!i&&(x===3||x===4))&&y%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${i} is true, innerElementSize ${x} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${x} must be 3 or 4.
  tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${x}<${r}>, ${y/x}>, ${l}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${h/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${x};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o?"0":"i32(globalId.z)"};
  ${n?`let batchIndices = ${n.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${d};

  let num_tiles = ${o?`${Math.ceil(u/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o?`i32(globalId.z) * ${u}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${A};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Gl(i,n)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${A}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${x===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${ql(i,x)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},yo=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,Hl=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",ji=(e,t,r="f32",n,i=!1,s=32,o=!1,u=32,d=!1)=>{let h=e[1]*t[1],y=e[0]*t[0],l=i?h:s,x=i?s:h;if(!(x%t[1]===0&&l%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${x} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let A=x/t[1],P=l/t[0],S=s/t[1],Q=d?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${h};
    let globalColStart = i32(workgroupId.x) * ${y};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${x}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {
          ${yo(i,n)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${n?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${i?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${h};

let tileRowA = i32(localId.y) * ${A};
let tileColA = i32(localId.x) * ${P};
let tileRowB = i32(localId.y) * ${S};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${A}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${P}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${yo(i,n)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${n?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Hl(i)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${l}>, ${x}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${y}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o?"0":"i32(globalId.z)"};
    ${n?`let batchIndices = ${n.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${o?`${Math.ceil(u/s)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${u}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;
    ${Q}
  }
`},Kl=(e,t,r,n,i,s=!1)=>{let[o,u,d]=i,[h,y,l,x]=n,A=Mi(o,d),P=Mi(u,d),S=_r(n[0].type.tensor),Q=()=>{let D=y.rank,ne=h.rank,he=`var aIndices: ${y.type.indices};`;for(let be=D-2-1,Ye=ne-1;be>=0;be--,Ye--)he+=`
aIndices[${be}] = ${ne>1?`batchIndices[${Ye}]`:"batchIndices"};`;return A.forEach(be=>{he+=`
aIndices[${be}] = 0;`}),he+=`
aIndices[${D-2}] = u32(row);
                   aIndices[${D-1}] = u32(colIn);`,he},Y=()=>{let D=l.rank,ne=h.rank,he=`var bIndices: ${l.type.indices};`;for(let be=D-2-1,Ye=ne-1;be>=0;be--,Ye--)he+=`
bIndices[${be}] = ${ne>1?`batchIndices[${Ye}]`:"batchIndices"};`;return P.forEach(be=>{he+=`
bIndices[${be}] = 0;`}),he+=`
bIndices[${D-2}] = u32(row);
                   bIndices[${D-1}] = u32(colIn);`,he};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${hn(e,S)} {
      var value = ${hn(e,S)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${Q()}
        value = ${y.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${h.type.indices}) -> ${hn(e,S)} {
      var value = ${hn(e,S)}(0.0);
      let col = colIn * ${e};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${Y()}
        value = ${l.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${hn(e,S)}) {
      let col = colIn * ${e};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${s?"bias[colIn]":`${hn(e,S)}(bias[row])`};`:""}
        ${r}
        ${x.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},bo=(e,t,r,n,i=!1,s)=>{let o=e[0].dims,u=e[1].dims,d=o.slice(0,-2),h=u.slice(0,-2),y=n?n.slice(0,-2):r.slice(0,-2),l=De.size(y),x=o[o.length-2],A=o[o.length-1],P=u[u.length-1],S=A%4===0&&P%4===0,Q=x<=8?[4,1,1]:[4,4,1],Y=[8,8,1],D=[Math.ceil(P/Y[0]/Q[0]),Math.ceil(x/Y[1]/Q[1]),Math.ceil(l/Y[2]/Q[2])],ne=S?4:1,he=[...d,x,A/ne],be=he.length,Ye=[...h,A,P/ne],ze=Ye.length,Mt=[l,x,P/ne],Vt=[{type:6,data:x},{type:6,data:P},{type:6,data:A}];Un(t,Vt),Vt.push(...Ot(y,he,Ye));let jt=["rank","rank"],lr=e.length>2;lr&&(Vt.push(...Ot(e[2].dims)),jt.push("rank")),Vt.push(...Ot(Mt));let Zt=ur=>{let Sr=y.length,or=$s("batchDims",e[0].dataType,Sr,1),Yt=_r(e[0].dataType),Tr=ht("a",e[0].dataType,be,ne),xr=ht("b",e[1].dataType,ze,ne),Xt=Kt("result",e[0].dataType,Mt.length,ne),yr=[Tr,xr];if(lr){let qr=i?ne:1;yr.push(ht("bias",e[2].dataType,e[2].dims.length,qr))}let ut=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Jn(t,ut);let St=_r(Xt.type.tensor),mr=Zn(t,Xt.type.value,St),Wr=Kl(ne,lr,mr,[or,Tr,xr,Xt],[d,h,y],i);return`
  ${ur.registerUniforms(ut).registerInternalVariables(or).declareVariables(...yr,Xt)}
  ${Wr}
  ${S?Ni(Q,Y,Yt,or):ji(Q,Y,Yt,or)}
                   `};return{name:"MatMul",shaderCache:{hint:`${Q};${t.activation};${S};${i}`,inputDependencies:jt},getRunData:()=>({outputs:[{dims:s?s(r):r,dataType:e[0].dataType}],dispatchGroup:{x:D[0],y:D[1],z:D[2]},programUniforms:Vt}),getShaderSource:Zt}}}),Xl,Yl,Ad=j(()=>{rr(),g(),fr(),Vn(),hs(),wo(),Ui(),Xl=(e,t,r,n,i=!1,s,o=4,u=4,d=4,h="f32")=>{let y=Vt=>{switch(Vt){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Vt} is not supported.`)}},l=Vt=>{switch(Vt){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${Vt} is not supported.`)}},x=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,A=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,P=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",S=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",Q=e?"row":"col",Y=e?"col":"row",D=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${Q} / outWidth;
    let outCol = ${Q} % outWidth;

    let WRow = ${Y} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${Y} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${Y} % inChannels;
    var resData = ${hn(o,h)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${P} && xCol >= 0 && xCol < ${S}) {
      ${x}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${y(o)}
    }
    return resData;`,ne=e?t&&n?`
    let col = colIn * ${o};
    ${D}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${D}
    }
    return ${hn(o,h)}(0.0);`:n&&r?`
    let col = colIn * ${o};
    ${D}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${D}
    }
    return ${hn(o,h)}(0.0);`,he=`${l(u)}`,be=hn(d,h),Ye=hn(e?o:u,h),ze=hn(e?u:o,h),Mt=Zn(s,be,h);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ye} {
      ${e?ne:he}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${ze} {
      ${e?he:ne}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${be}) {
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${A}
      ${go(i)}
      ${Mt}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Yl=(e,t,r,n,i,s,o,u,d)=>{let h=t.format==="NHWC",y=h?e[0].dims[3]:e[0].dims[1],l=r[0],x=h?r[2]:r[3],A=h?r[1]:r[2],P=h?r[3]:r[1],S=h&&(y%4===0||y%3===0)&&P%4===0,Q=h?P:x*A,Y=h?x*A:P,D=[8,8,1],ne=n<=8?[4,1,1]:[4,4,1],he=[Math.ceil(Q/D[0]/ne[0]),Math.ceil(Y/D[1]/ne[1]),Math.ceil(l/D[2]/ne[2])];ye("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${he}`);let be=S?h&&y%4!==0?3:4:1,Ye=D[1]*ne[1],ze=D[0]*ne[0],Mt=Math.max(D[0]*be,D[1]),Vt=n%Ye===0,jt=i%ze===0,lr=s%Mt===0,Zt=S?[be,4,4]:[1,1,1],ur=[{type:6,data:n},{type:6,data:i},{type:6,data:s},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Un(t,ur),ur.push(...Ot(e[0].dims,e[1].dims));let Sr=["rank","rank"];o&&(ur.push(...Ot(e[2].dims)),Sr.push("rank")),ur.push(...Ot(r));let or=Yt=>{let Tr=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Jn(t,Tr);let xr=S?4:1,Xt=_r(e[0].dataType),yr=`
      fn setOutputAtIndex(flatIndex : i32, value : ${S?`vec4<${Xt}>`:Xt}) {
        result[flatIndex] = ${S?`vec4<${Xt}>`:Xt}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${S?`vec4<${Xt}>`:Xt}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${S?"/ 4":""}, value);
      }`,ut=ht("x",e[0].dataType,e[0].dims.length,be===3?1:be),St=ht("w",e[1].dataType,e[1].dims.length,xr),mr=[ut,St],Wr=Kt("result",e[0].dataType,r.length,xr);if(o){let qr=ht("bias",e[2].dataType,e[2].dims.length,xr);mr.push(qr),yr+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${S?`vec4<${Xt}>`:Xt} {
          return bias[coords.${h?"w":"y"}${S?"/ 4":""}];
        }`}return`
        ${_o("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Yt.registerUniforms(Tr).declareVariables(...mr,Wr)}
        ${yr}
        ${Xl(h,Vt,jt,lr,o,t,Zt[0],Zt[1],Zt[2],Xt)}
        ${S?Ni(ne,D,Xt,void 0,!h,Mt):ji(ne,D,Xt,void 0,!h,Mt,!1,void 0,u)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${be};${S};${Vt};${jt};${lr};${Ye};${ze};${Mt}`,inputDependencies:Sr},getRunData:()=>({outputs:[{dims:d?d(r):r,dataType:e[0].dataType}],dispatchGroup:{x:he[0],y:he[1],z:he[2]},programUniforms:ur}),getShaderSource:or}}}),Ql,Mo,Vi,vo,xo,Zl,To,Jl,Id=j(()=>{rr(),g(),Jt(),fr(),Vn(),hs(),Ql=e=>{let t=1;for(let r=0;r<e.length;r++)t*=e[r];return t},Mo=e=>typeof e=="number"?[e,e,e]:e,Vi=(e,t)=>t<=1?e:e+(e-1)*(t-1),vo=(e,t,r,n=1)=>{let i=Vi(t,n);return Math.floor((e[0]*(r-1)-r+i)/2)},xo=(e,t,r,n,i)=>{i==null&&(i=vo(e,t[0],n[0]));let s=[0,0,0,r];for(let o=0;o<3;o++)e[o]+2*i>=t[o]&&(s[o]=Math.trunc((e[o]-t[o]+2*i)/n[o]+1));return s},Zl=(e,t,r,n,i,s,o,u,d,h)=>{let y,l,x,A;if(e==="VALID"&&(e=0),typeof e=="number"){y={top:e,bottom:e,left:e,right:e,front:e,back:e};let P=xo([t,r,n,1],[u,d,h],1,[i,s,o],e);l=P[0],x=P[1],A=P[2]}else if(Array.isArray(e)){if(!e.every((S,Q,Y)=>S===Y[0]))throw Error(`Unsupported padding parameter: ${e}`);y={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let P=xo([t,r,n,1],[u,d,h],1,[i,s,o],e[0]);l=P[0],x=P[1],A=P[2]}else if(e==="SAME_UPPER"){l=Math.ceil(t/i),x=Math.ceil(r/s),A=Math.ceil(n/o);let P=(l-1)*i+u-t,S=(x-1)*s+d-r,Q=(A-1)*o+h-n,Y=Math.floor(P/2),D=P-Y,ne=Math.floor(S/2),he=S-ne,be=Math.floor(Q/2),Ye=Q-be;y={top:ne,bottom:he,left:be,right:Ye,front:Y,back:D}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:y,outDepth:l,outHeight:x,outWidth:A}},To=(e,t,r,n,i,s=!1,o="channelsLast")=>{let u,d,h,y,l;if(o==="channelsLast")[u,d,h,y,l]=e;else if(o==="channelsFirst")[u,l,d,h,y]=e;else throw new Error(`Unknown dataFormat ${o}`);let[x,,A,P,S]=t,[Q,Y,D]=Mo(r),[ne,he,be]=Mo(n),Ye=Vi(A,ne),ze=Vi(P,he),Mt=Vi(S,be),{padInfo:Vt,outDepth:jt,outHeight:lr,outWidth:Zt}=Zl(i,d,h,y,Q,Y,D,Ye,ze,Mt),ur=s?x*l:x,Sr=[0,0,0,0,0];return o==="channelsFirst"?Sr=[u,ur,jt,lr,Zt]:o==="channelsLast"&&(Sr=[u,jt,lr,Zt,ur]),{batchSize:u,dataFormat:o,inDepth:d,inHeight:h,inWidth:y,inChannels:l,outDepth:jt,outHeight:lr,outWidth:Zt,outChannels:ur,padInfo:Vt,strideDepth:Q,strideHeight:Y,strideWidth:D,filterDepth:A,filterHeight:P,filterWidth:S,effectiveFilterDepth:Ye,effectiveFilterHeight:ze,effectiveFilterWidth:Mt,dilationDepth:ne,dilationHeight:he,dilationWidth:be,inShape:e,outShape:Sr,filterShape:t}},Jl=(e,t,r,n,i,s)=>{let o=s==="channelsLast";o?e[0].dims[3]:e[0].dims[1];let u=[64,1,1],d={x:r.map((Q,Y)=>Y)},h=[Math.ceil(Ql(d.x.map(Q=>r[Q]))/u[0]),1,1];ye("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${h}`);let y=1,l=De.size(r),x=[{type:12,data:l},{type:12,data:n},{type:12,data:i},{type:12,data:t.strides},{type:12,data:t.dilations}];Un(t,x),x.push(...Ot(e[0].dims,e[1].dims));let A=["rank","rank"],P=e.length===3;P&&(x.push(...Ot(e[2].dims)),A.push("rank")),x.push(...Ot(r));let S=Q=>{let Y=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:n.length},{name:"pads",type:"u32",length:i.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Jn(t,Y);let D=1,ne=_r(e[0].dataType),he=ht("x",e[0].dataType,e[0].dims.length,y),be=ht("W",e[1].dataType,e[1].dims.length,D),Ye=[he,be],ze=Kt("result",e[0].dataType,r.length,D),Mt="";if(P){let lr=ht("bias",e[2].dataType,e[2].dims.length,D);Ye.push(lr),Mt+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${ne} {
          return bias[${o?qt("coords",4,5):qt("coords",1,5)}];
        }`}let Vt=hn(y,ne),jt=Zn(t,Vt,ne);return`
            ${Mt}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${he.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${be.getByIndices("aIndices")};
            }
          ${Q.registerUniforms(Y).declareVariables(...Ye,ze)}
          ${Q.mainStart()}
          ${Q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${ze.offsetToIndices("global_idx")};
              let batch = ${qt("coords",0,he.rank)};
              let d2 = ${o?qt("coords",he.rank-1,he.rank):qt("coords",1,he.rank)};
              let xFRCCorner = vec3<u32>(${o?qt("coords",1,he.rank):qt("coords",2,he.rank)},
              ${o?qt("coords",2,he.rank):qt("coords",3,he.rank)},
              ${o?qt("coords",3,he.rank):qt("coords",4,he.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o?qt("uniforms.x_shape",1,he.rank):qt("uniforms.x_shape",2,he.rank)};
              let xShapeZ = ${o?qt("uniforms.x_shape",2,he.rank):qt("uniforms.x_shape",3,he.rank)};
              let xShapeW = ${o?qt("uniforms.x_shape",3,he.rank):qt("uniforms.x_shape",4,he.rank)};
              let xShapeU = ${o?qt("uniforms.x_shape",4,he.rank):qt("uniforms.x_shape",1,he.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${P?"value = value + getBiasByOutputCoords(coords)":""};
              ${jt}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${o};${y};${P}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:h[0],y:h[1],z:h[2]},programUniforms:x}),getShaderSource:S}}}),ei,eu,Fd=j(()=>{rr(),Jt(),fr(),Vn(),ei=(e,t,r,n)=>{let i=e.length>2,s=i?"value += b[output_channel];":"",o=e[0].dims,u=e[1].dims,d=t.format==="NHWC",h=d?r[3]:r[1],y=h/t.group,l=d&&y>=4?br(h):1,x=De.size(r)/l,A=[{type:12,data:x},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:y}];Un(t,A),A.push(...Ot(o,[u[0],u[1],u[2],u[3]/l]));let P=i?["rank","rank","rank"]:["rank","rank"];A.push(...Ot([r[0],r[1],r[2],r[3]/l]));let S=Q=>{let Y=Kt("output",e[0].dataType,r.length,l),D=_r(Y.type.tensor),ne=Zn(t,Y.type.value,D),he=ht("x",e[0].dataType,o.length),be=ht("w",e[1].dataType,u.length,l),Ye=[he,be];i&&Ye.push(ht("b",e[2].dataType,e[2].dims,l));let ze=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Jn(t,ze);let Mt=d?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${he.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${be.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${he.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${be.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${Q.registerUniforms(ze).declareVariables(...Ye,Y)}

  ${Q.mainStart()}
    ${Q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${Y.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${d?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d?1:2}], outputIndices[${d?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${l} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${d?2:1}];

    var value: ${Y.type.value} = ${Y.type.value}(0);
    ${Mt}
    ${s}
    ${ne}
    ${Y.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${l}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:A}),getShaderSource:S}},eu=(e,t,r,n)=>{let i=e.length>2,s=br(r[3]),o=br(r[2]),u=De.size(r)/s/o,d=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/s],h=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/s],y=[r[0],r[1],r[2],r[3]/s],l=[{type:12,data:u},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Un(t,l),l.push(...Ot(d,h,y));let x=(o-1)*t.strides[1]+h[1],A=P=>{let S=Kt("output",e[0].dataType,y.length,s),Q=_r(S.type.tensor),Y=Zn(t,S.type.value,Q),D=ht("x",e[0].dataType,d.length,s),ne=ht("w",e[1].dataType,h.length,s),he=[D,ne];i&&he.push(ht("b",e[2].dataType,e[2].dims,s));let be=i?"value += b[output_channel];":"",Ye=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Jn(t,Ye),`
  ${P.registerUniforms(Ye).declareVariables(...he,S)}
  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${D.type.value}, ${x}>;
    var values: array<${S.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${h[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${x}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${D.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${D.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${h[1]}; w_width++) {
          let w_val = ${ne.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${be}
      ${Y}
      ${S.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${s};${o};${x};${h[0]};${h[1]}`,inputDependencies:i?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:l}),getShaderSource:A}}}),Eo,tu,Co,ru=j(()=>{rr(),Jt(),Ui(),fr(),Vn(),Eo=(e,t,r,n,i=!1,s)=>{let o=e[0].dims,u=e[1].dims,d=o[o.length-2],h=u[u.length-1],y=o[o.length-1],l=br(h),x=br(y),A=br(d),P=De.size(r)/l/A,S=e.length>2,Q=n?n.slice(0,-2):r.slice(0,-2),Y=[De.size(Q),d,h],D=[{type:12,data:P},{type:12,data:d},{type:12,data:h},{type:12,data:y}];Un(t,D),D.push(...Ot(Q,o,u)),S&&D.push(...Ot(e[2].dims)),D.push(...Ot(Y));let ne=he=>{let be=$s("batch_dims",e[0].dataType,Q.length),Ye=ht("a",e[0].dataType,o.length,x),ze=ht("b",e[1].dataType,u.length,l),Mt=Kt("output",e[0].dataType,Y.length,l),Vt=_r(Mt.type.tensor),jt=Zn(t,Mt.type.value,Vt),lr=[Ye,ze],Zt="";if(S){let yr=i?l:1;lr.push(ht("bias",e[2].dataType,e[2].dims.length,yr)),Zt=`${i?`value += bias[col / ${yr}];`:`value += ${Mt.type.value}(bias[row + i]);`}`}let ur=o.slice(0,-2),Sr=u.slice(0,-2),or=Mi(ur,Q),Yt=Mi(Sr,Q),Tr=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Jn(t,Tr);let xr=(yr,ut)=>{let St=yr.rank,mr=yr.name;if(St===2)return`var ${mr}_indices = ${yr.type.indices}(0u, 0u);`;let Wr=be.rank,qr=`var ${mr}_indices: ${yr.type.indices};`;for(let Gn=St-2-1,Dn=Wr-1;Gn>=0;Gn--,Dn--)qr+=`
${mr}_indices[${Gn}] = ${Wr>1?`batch_indices[${Dn}]`:"batch_indices"};`;return ut.forEach(Gn=>{qr+=`
${mr}_indices[${Gn}] = 0;`}),qr+=`${mr}_indices[${St-2}] = 0u;
                     ${mr}_indices[${St-1}] = 0u;`,qr},Xt=()=>{let yr=`var a_data: ${Ye.type.value};`;for(let ut=0;ut<x;ut++)yr+=`
              let b_data${ut} = b[(b_offset + (k + ${ut}) * uniforms.N + col) / ${l}];`;for(let ut=0;ut<A;ut++){yr+=`a_data = a[(a_offset + (row + ${ut}) * uniforms.K + k) / ${x}];`;for(let St=0;St<x;St++)yr+=`
            values[${ut}] = fma(${ze.type.value}(a_data${x===1?"":`[${St}]`}), b_data${St}, values[${ut}]);
`}return yr};return`
  ${he.registerUniforms(Tr).registerInternalVariables(be).declareVariables(...lr,Mt)}
  ${he.mainStart()}
    ${he.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${l})) * ${l};
    var index1 = global_idx / (uniforms.N / ${l});
    let stride1 = uniforms.M / ${A};
    let row = (index1 % stride1) * ${A};
    let batch = index1 / stride1;

    ${r.length===2?"":`let batch_indices = ${be.offsetToIndices("batch")};`}
    ${xr(Ye,or)}
    let a_offset = ${Ye.indicesToOffset("a_indices")};
    ${xr(ze,Yt)}
    let b_offset = ${ze.indicesToOffset("b_indices")};
    var values: array<${Mt.type.value}, ${A}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${x}) {
      ${Xt()}
    }
    for (var i = 0u; i < ${A}u; i++) {
      var value = values[i];
      ${Zt}
      ${jt}
      let cur_indices = ${Mt.type.indices}(batch, row + i, col);
      let offset = ${Mt.indicesToOffset("cur_indices")};
      ${Mt.setByOffset(`offset / ${l}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${l};${x};${A};${i}`,inputDependencies:S?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:s?s(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(P/64)},programUniforms:D}),getShaderSource:ne}},tu=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Co=e=>{tu(e.inputs);let t=Sn.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let r=t[t.length-1],n=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&n<8?e.compute(Eo(e.inputs,{activation:""},t)):e.compute(bo(e.inputs,{activation:""},t))}}),nu,fs,iu,xi,$o,So,su,Wi,ko,Od=j(()=>{Jt(),Ad(),Id(),Ui(),Fd(),Vn(),ru(),jn(),nu=(e,t,r,n,i,s)=>{let o=e[0],u=e.slice(s?1:2,s?3:4),d=u.length,h=t[0],y=t.slice(2).map((x,A)=>x+(x-1)*(r[A]-1)),l=u.map((x,A)=>x+n[A]+n[A+d]).map((x,A)=>Math.floor((x-y[A]+i[A])/i[A]));return l.splice(0,0,o),l.splice(s?3:1,0,h),l},fs=[2,3,1,0],iu=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],n=e[1].dims[1]*t.group;if(r!==n)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let i=e[0].dims.length-2;if(t.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(t.strides.length!==i)throw new Error(`strides should be ${i}D`);if(t.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},xi=(e,t)=>{let r=e.kernelShape.slice();r.length<t[1].dims.length-2&&r.push(...Array(t[1].dims.length-2-r.length).fill(0));for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let n=e.pads.slice();Jr.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,e.format==="NHWC",e.autoPad);let i=Object.assign({},e);return Object.assign(i,{kernelShape:r,pads:n}),i},$o=e=>{let t=mo(e),r=e.format,n=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,s=e.group,o=e.kernel_shape,u=e.pads,d=e.strides,h=e.w_is_const();return{autoPad:n,format:r,dilations:i,group:s,kernelShape:o,pads:u,strides:d,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},So=(e,t,r,n)=>{let i=r.format==="NHWC",s=nu(t[0].dims,t[1].dims,r.dilations,r.pads,r.strides,i);if(r.group!==1){let Ye=[t[0]];if(i){let ze=e.kernelCustomData.wT??e.compute(Mn(t[1],fs),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=ze),Ye.push(ze)}else Ye.push(t[1]);t.length===3&&Ye.push(t[2]),!e.adapterInfo.isArchitecture("ampere")&&i&&t[1].dims[0]===r.group&&t[1].dims[1]===1&&r.dilations[0]===1&&r.dilations[1]===1?e.compute(eu(Ye,r,s,n),{inputs:Ye}):e.compute(ei(Ye,r,s,n),{inputs:Ye});return}let o=t.length===3,u=t[0].dims[i?1:2],d=t[0].dims[i?2:3],h=t[0].dims[i?3:1],y=t[1].dims[2],l=t[1].dims[3],x=s[i?1:2],A=s[i?2:3],P=s[i?3:1],S=i&&y===u&&l===d&&r.pads[0]===0&&r.pads[1]===0;if(S||y===1&&l===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let Ye=s[0],ze,Mt,Vt,jt=[];if(i){let ur=e.kernelCustomData.wT??e.compute(Mn(t[1],fs),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=ur),S){let Sr=u*d*h;ze=t[0].reshape([1,Ye,Sr]),Mt=ur.reshape([1,Sr,P]),Vt=[1,Ye,P]}else ze=t[0].reshape([Ye,u*d,h]),Mt=ur.reshape([1,h,P]),Vt=[Ye,x*A,P];jt.push(ze),jt.push(Mt)}else ze=t[0].reshape([Ye,h,u*d]),Mt=t[1].reshape([1,P,h]),Vt=[Ye,P,x*A],jt.push(Mt),jt.push(ze);o&&jt.push(t[2]);let lr=Vt[2],Zt=jt[0].dims[jt[0].dims.length-1];lr<8&&Zt<8?e.compute(Eo(jt,r,s,Vt,i,n),{inputs:jt}):e.compute(bo(jt,r,s,Vt,i,n),{inputs:jt});return}let Q=!0,Y=e.kernelCustomData.wT??e.compute(Mn(t[1],fs),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Y);let D=[t[0],Y];o&&D.push(t[2]);let ne=i?x*A:P,he=i?P:x*A,be=y*l*h;e.compute(Yl(D,r,s,ne,he,be,o,Q,n),{inputs:D})},su=(e,t)=>{let r=t.format==="NHWC",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let i=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),o=[1].concat(t.dilations),u=[1].concat(t.kernelShape),d=xi({...t,pads:i,strides:s,dilations:o,kernelShape:u},n);So(e,n,d,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]])},Wi=(e,t,r)=>{let n=r.format==="NHWC"?"channelsLast":"channelsFirst",i=xi(r,t),s=r.autoPad==="NOTSET"?r.pads:r.autoPad,o=To(t[0].dims,t[1].dims,r.strides,r.dilations,s,!1,n);e.compute(Jl(t,i,o.outShape,[o.filterDepth,o.filterHeight,o.filterWidth],[o.padInfo.front,o.padInfo.top,o.padInfo.left],n))},ko=(e,t)=>{if(iu(e.inputs,t),e.inputs[0].dims.length===3)su(e,t);else if(e.inputs[0].dims.length===5)Wi(e,e.inputs,t);else{let r=xi(t,e.inputs);So(e,e.inputs,r)}}}),ou,au,Po=j(()=>{rr(),g(),fr(),Vn(),hs(),wo(),Ui(),ou=(e,t=!1,r,n,i=4)=>{let s=Q=>{switch(Q){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${n}(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${Q} is not supported.`)}},o=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,u=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,d=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",h=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",y=e?"row":"col",l=e?"col":"row",x=`
      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${y} / outWidth;
      let outCol = ${y} % outWidth;

      let WRow = ${l} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${l} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${d}) || fract(xR) > 0.0) {
        return ${n}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {
        return ${n}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${l} % inChannels;
      ${o}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${i}];`,A=e?`
      let col = colIn * ${i};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${x}
      }
      return ${n}(0.0);`:`
      let col = colIn * ${i};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${x}
      }
      return ${n}(0.0);`,P=`
      let col = colIn * ${i};
      let inChannels = ${e?"i32(uniforms.x_shape[3])":"i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${e?"row < uniforms.dim_inner && col < uniforms.dim_b_outer":"row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${s(i)}
      }
      return ${n}(0.0);
      `,S=Zn(r,n);return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {
    ${e?A:P}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {
    ${e?P:A}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {
    let col = colIn * ${i};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${u}
      ${go(t)}
      ${S}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${i}] = value;
    }
  }`},au=(e,t,r,n,i,s,o,u)=>{let d=t.format==="NHWC",h=d?e[0].dims[3]:e[0].dims[1],y=r[0],l=d?r[2]:r[3],x=d?r[1]:r[2],A=d?r[3]:r[1],P=d&&h%4===0&&h%3&&A%4===0,S=d?A:l*x,Q=d?l*x:A,Y=[8,8,1],D=n<=8?[4,1,1]:[4,4,1],ne=[Math.ceil(S/Y[0]/D[0]),Math.ceil(Q/Y[1]/D[1]),Math.ceil(y/Y[2]/D[2])];ye("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${ne}`);let he=P?4:1,be=Math.max(Y[0]*he,Y[1]),Ye=P?4:1,ze=[t.kernelShape[d?1:2],t.kernelShape[d?2:3]],Mt=[ze[0]+(t.dilations[0]<=1?0:(ze[0]-1)*(t.dilations[0]-1)),ze[1]+(t.dilations[1]<=1?0:(ze[1]-1)*(t.dilations[1]-1))],Vt=[Mt[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),Mt[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],jt=[{type:6,data:n},{type:6,data:i},{type:6,data:s},{type:6,data:t.strides},{type:6,data:t.dilations},{type:6,data:ze},{type:6,data:Vt}];Un(t,jt),jt.push(...Ot(e[0].dims,e[1].dims));let lr=["rank","rank"];o&&(jt.push(...Ot(e[2].dims)),lr.push("rank")),jt.push(...Ot(r));let Zt=ur=>{let Sr=ht("x",e[0].dataType,e[0].dims.length,Ye),or=ht("w",e[1].dataType,e[1].dims.length,1),Yt=Kt("result",e[0].dataType,r.length,Ye),Tr=[Sr,or],xr="";if(o){let ut=ht("bias",e[2].dataType,e[2].dims.length,Ye);Tr.push(ut),xr+=`
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${ut.type.value} {
            return bias[coords.${d?"w":"y"}${P?"/ 4":""}];
          }`}let Xt=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"strides",type:"i32",length:2},{name:"dilations",type:"i32",length:2},{name:"filter_dims",type:"i32",length:ze.length},{name:"pads",type:"i32",length:Vt.length}];Jn(t,Xt);let yr=_r(e[0].dataType,1);if(yr!=="f16"&&yr!=="f32")throw new Error(`elemType ${yr} is not supported.`);return`
        ${_o("uniforms.result_strides")}
        ${ur.registerUniforms(Xt).declareVariables(...Tr,Yt)};
        ${xr}
        ${ou(d,o,t,Sr.type.value,he)}
        ${P?Ni(D,Y,yr,void 0,!d,be):ji(D,Y,yr,void 0,!d,be,!1,void 0,u)}`};return{name:"Conv2DTransposeMatMul",shaderCache:{hint:`${t.cacheKey};${D};${Y};${P}`,inputDependencies:lr},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:ne[0],y:ne[1],z:ne[2]},programUniforms:jt}),getShaderSource:Zt}}}),lu,Ao,Bd=j(()=>{rr(),g(),Jt(),fr(),lu=(e,t,r,n,i,s=!1,o,u,d=!1)=>{let h=d?1:2,y=d?2:3,l=d?3:1,x=s?2:1,A=`
  fn setOutputAtIndex(flatIndex : u32, value : ${s?`vec4<${o}>`:o}) {
    result[flatIndex] = ${s?`vec4<${o}>`:o}(value);
  }`;n&&(A+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${s?`vec4<${o}>`:o} {
      return bias[coords.${d?"w":"y"}${s?"/ 4":""}];
    }`);let P=s?4:1,S=ht("W",t[1].dataType,t[1].dims.length,P),Q=ht("Dy",t[0].dataType,t[0].dims.length,P),Y=[Q,S];n&&Y.push(ht("bias",t[2].dataType,[r[l]].length,P));let D=Kt("result",t[0].dataType,r.length,P),ne=`{
        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${i?"global_id.z":"workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${i?"global_id.y":"workgroup_id.y"} * ${x};
        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${o}>, ${x}>;
        for (var i = 0; i < ${x}; i++) {
          dotProd[i] = vec4<${o}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${o}(dyCorner.x) + ${o}(wR)) / ${o}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${o}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${o}(dyCorner.y) + ${o}(wC)) / ${o}(uniforms.strides.y);
            let dyC2 = (${o}(dyCorner.y) + 1.0 + ${o}(wC)) / ${o}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${o}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${o}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Q.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Q.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${o}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${l}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Q.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${S.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Q.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${o}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${x}; i = i + 1) {
          let value = dotProd[i] + ${n?"bias[c+i]":`vec4<${o}>(0.0)`};
          ${D.set("batch","r","c + i","d1","value")};
        }
      }`,he=`
          let outputIndices = ${D.offsetToIndices("global_idx")};
          let batch = ${D.indicesGet("outputIndices",0)};
          let d1 = ${D.indicesGet("outputIndices",l)};
          let r = ${D.indicesGet("outputIndices",h)};
          let c = ${D.indicesGet("outputIndices",y)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${o}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${o}(dyRCorner) + ${o}(wR)) / ${o}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${o}(uniforms.Dy_shape[${h}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${o}(dyCCorner) + ${o}(wC)) / ${o}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${o}(uniforms.Dy_shape[${y}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${d?Q.get("batch","idyR","idyC","inputChannel"):Q.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${S.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${n?"bias[d1]":`${o}(0.0)`};
          ${D.setByOffset("global_idx","value")};
        `;return`
  ${e.registerUniforms(u).declareVariables(...Y,D)}
  ${A}

    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${s?ne:he}}`},Ao=(e,t,r)=>{let n=e.length>2,i=t.outputShape,s=De.size(i),o=[Math.ceil(s/64),1,1];ye("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${o}`);let u=t.format==="NHWC",d=["rank","rank"],h=[t.strides[0],t.strides[1]],y=[t.kernelShape[u?1:2],t.kernelShape[u?2:3]],l=[t.dilations[0],t.dilations[1]],x=[y[0]+(t.dilations[0]<=1?0:(t.kernelShape[u?1:2]-1)*(t.dilations[0]-1)),y[1]+(t.dilations[1]<=1?0:(t.kernelShape[u?2:3]-1)*(t.dilations[1]-1))],A=[x[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),x[1]-1-Math.floor(t.pads[1]+t.pads[3])/2],P=!1,S=t.group,Q=e[1].dims,Y=Q[0]/S,D=Q[1],ne=[{type:12,data:s},{type:12,data:h},{type:12,data:y},{type:12,data:l},{type:12,data:x},{type:6,data:A},{type:12,data:Y},{type:12,data:D},...Ot(e[0].dims,e[1].dims)];n&&(ne.push(...Ot(e[2].dims)),d.push("rank")),ne.push(...Ot(i));let he=o[1]===1&&o[2]===1,be=Ye=>{let ze=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:h.length},{name:"filter_dims",type:"u32",length:y.length},{name:"dilations",type:"u32",length:y.length},{name:"effective_filter_dims",type:"u32",length:x.length},{name:"pads",type:"i32",length:A.length},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],Mt=_r(e[0].dataType);return`${lu(Ye,e,i,n,he,P,Mt,ze,u)}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};`,inputDependencies:d},getRunData:()=>({dispatchGroup:{x:o[0],y:o[1],z:o[2]},outputs:[{dims:r?r(i):i,dataType:e[0].dataType}],programUniforms:ne}),getShaderSource:be}}}),Dd,uu,du,Io,Ti,cu,pu,hu,fu,mu,Fo=j(()=>{Po(),Bd(),Vn(),jn(),Dd=(e,t,r,n,i,s)=>(e-1)*t+r+(n-1)*i+1-s,uu=(e,t,r,n,i)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[n]=s,r[i]=e-s):t==="SAME_LOWER"&&(r[n]=e-s,r[i]=s)},du=(e,t,r,n,i,s,o,u,d,h)=>{let y=e.length-2,l=h.length===0;d.length<y&&d.push(...Array(y-d.length).fill(0));let x=e[0],A=t[u?3:1]*i;for(let P=0,S=e.length-y-(u?1:0);P<y;++P,++S){let Q=e[S],Y=l?Q*o[P]:h[P],D=Dd(Q,o[P],s[P],t[S],r[P],Y);uu(D,n,s,P,P+y),l&&h.push(o[P]*(Q-1)+d[P]+(t[S]-1)*r[P]+1-s[P]-s[P+y])}h.splice(0,0,x),h.splice(u?3:1,0,A)},Io=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((l,x)=>l*x,1)===0){r.length=0;for(let l=2;l<t[1].dims.length;++l)r.push(t[1].dims[l])}let n=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(n?3:1,0,t[1].dims[1]);let i=e.pads.slice(),s=e.outputShape.slice(),o=e.outputPadding.slice(),u=t[0].dims,d=e.dilations.slice();if(d.reduce((l,x)=>l+x,0)===0){let l=t[0].dims.length-2;d=new Array(l).fill(1)}let h=e.strides.slice();if(h.reduce((l,x)=>l+x,0)===0){let l=t[0].dims.length-2;h=new Array(l).fill(1)}du(u,r,d,e.autoPad,e.group,i,h,n,o,s);let y=Object.assign({},e);return Object.assign(y,{kernelShape:r,pads:i,outputPadding:o,outputShape:s,dilations:d,strides:h}),y},Ti=e=>{let t=mo(e),r=e.format,n=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],i=e.dilations,s=e.group,o=e.kernelShape,u=e.pads,d=e.strides,h=e.wIsConst(),y=e.outputPadding,l=e.outputShape;return{autoPad:n,format:r,dilations:i,group:s,kernelShape:o,outputPadding:y,outputShape:l,pads:u,strides:d,wIsConst:h,...t,cacheKey:`${e.format};${t.activation};`}},cu=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],n=e[1].dims[0];if(r!==n)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==i))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((o,u)=>o+u,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((o,u)=>o+u,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((o,u)=>o+u,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((o,u)=>o+u,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},pu=[2,3,1,0],hu=(e,t,r)=>{let n=Io(r,t),i=r.format==="NHWC",s=n.outputShape,o=s[i?3:1],u=t[0].dims[i?3:1];if(n.group!==1||o===1&&u===1){e.compute(Ao(t,n));return}let d=s[i?1:2],h=s[i?2:3],y=t[1].dims[2],l=t[1].dims[3],x=i?d*h:o,A=i?o:d*h,P=y*l*u,S=!0,Q=e.kernelCustomData.wT??e.compute(Mn(t[1],pu),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=Q);let Y=[t[0],Q],D=t.length===3;D&&(!i&&t[2].dims.length===1?Y.push(t[2].reshape([t[2].dims[0],1,1])):Y.push(t[2])),e.compute(au(Y,n,s,x,A,P,D,S),{inputs:Y})},fu=(e,t)=>{let r=t.format==="NHWC",n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&n.push(e.inputs[2]);let i=t.kernelShape;(i.length===0||i[0]===0)&&(i=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let o=t.strides;(o.length===0||o[0]===0)&&(o=[1]);let u=t.pads;u.length===0&&(u=[0,0]),u=[0,u[0],0,u[1]],o=[1].concat(o),s=[1].concat(s),i=[1].concat(i);let d=Io({...t,pads:u,strides:o,dilations:s,kernelShape:i},n);e.compute(Ao(n,d,h=>r?[h[0],h[2],h[3]]:[h[0],h[1],h[3]]))},mu=(e,t)=>{cu(e.inputs,t),e.inputs[0].dims.length===3?fu(e,t):hu(e,e.inputs,t)}}),zd,gu,_u,Ld=j(()=>{rr(),Jt(),kr(),fr(),zd=(e,t,r,n)=>{let i=De.size(t),s=t.length,o=ht("input",e,s),u=Kt("output",e,s),d=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),h=De.normalizeAxis(d,s),y=l=>{let x=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,A=qt("uniforms.input_shape","uniforms.axis",s),P=n.reverse?x+(n.exclusive?" + 1":""):"0",S=n.reverse?A:x+(n.exclusive?"":" + 1");return`
                ${l.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,u)}
                ${l.mainStart()}
                  ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${u.offsetToIndices("global_idx")};
                  var sum = ${u.type.value}(0);
                  let first : i32 = ${P};
                  let last : i32 = ${S};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${u.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:n.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},{type:12,data:h},...Ot(t,t)]}),getShaderSource:y}},gu=(e,t)=>{let r=e.inputs[0].dims,n=e.inputs[0].dataType,i=e.inputs[1];e.compute(zd(n,r,i,t),{inputs:[0]})},_u=e=>{let t=e.exclusive===1,r=e.reverse===1;return hr({exclusive:t,reverse:r})}}),wu,yu,Oo,bu,Mu,vu=j(()=>{rr(),Jt(),kr(),fr(),wu=e=>{if(!e||e.length!==1)throw new Error("DepthToSpace requires 1 input.");if(e[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},yu=(e,t,r,n)=>{let i=[];i.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let s=0;s<t;++s)i.push(r.indicesSet("a",e[s],`i[${s}]`));return i.push("return a;}"),i.join(`
`)},Oo=(e,t)=>{let r,n,i,s,o,u,d=t.format==="NHWC",h=t.blocksize,y=t.mode==="DCR";d?([r,n,i,s]=e.dims,o=y?[r,n,i,h,h,s/h**2]:[r,n,i,s/h**2,h,h],u=y?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,n,i,s]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],o=y?[r,h,h,s/h**2,n,i]:[r,s/h**2,h,h,n,i],u=y?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let l=e.reshape(o),x=l.dims.length,A=e.dataType,P=ht("a",A,x),S=Kt("output",A,x),Q=Y=>`
  ${Y.registerUniform("output_size","u32").declareVariables(P,S)}

  ${yu(u,x,P,S)}

  ${Y.mainStart()}
    ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${S.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${S.setByOffset("global_idx",P.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:Y=>{let D=d?[r,n*h,i*h,s/h**2]:[r,s/h**2,n*h,i*h],ne=De.size(D),he=l.dims,be=De.sortBasedOnPerm(he,u);return{outputs:[{dims:D,dataType:Y[0].dataType}],dispatchGroup:{x:Math.ceil(ne/64)},programUniforms:[{type:12,data:ne},...Ot(he,be)]}},getShaderSource:Q}},bu=(e,t)=>{wu(e.inputs),e.compute(Oo(e.inputs[0],t))},Mu=e=>hr({blocksize:e.blocksize,mode:e.mode,format:e.format})}),ms,Gi,gs,xu,Tu,_s,Eu,Bo,Cu,$u,Do,zo=j(()=>{rr(),Jt(),kr(),fr(),ms="[a-zA-Z]|\\.\\.\\.",Gi="("+ms+")+",gs="^"+Gi+"$",xu="("+Gi+",)*"+Gi,Tu="^"+xu+"$",_s=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let r=this.symbolToIndices.get(e);r===void 0?r=[t]:r.push(t),this.symbolToIndices.set(e,r)}},Eu=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[r,n]=t.includes("->")?t.split("->",2):[t,""];if(!r.match(RegExp(Tu)))throw new Error("Invalid LHS term");if(r.split(",").forEach((i,s)=>{let o=e[s].dims.slice();if(!i.match(RegExp(gs)))throw new Error("Invalid LHS term");let u=this.processTerm(i,!0,o,s);this.lhs.push(u)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([i,s])=>s.count===1||i==="...").map(([i])=>i).join("");else if(!n.match(RegExp(Gi)))throw new Error("Invalid RHS");n.match(RegExp(ms,"g"))?.forEach(i=>{if(i==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let s=this.symbolToInfo.get(i);if(s===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(s.dimValue)}}),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(e,t,r){let n=this.symbolToInfo.get(e);if(n!==void 0){if(n.dimValue!==t&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(r)}else n={count:1,dimValue:t,inputIndices:[r]};this.symbolToInfo.set(e,n)}processTerm(e,t,r,n=-1){let i=r.length,s=!1,o=[],u=0;if(!e.match(RegExp(gs))&&!t&&e!=="")throw new Error("Invalid LHS term");let d=e.match(RegExp(ms,"g")),h=new _s(n);return d?.forEach((y,l)=>{if(y==="..."){if(s)throw new Error("Only one ellipsis is allowed per input term");s=!0;let x=i-d.length+1;if(x<0)throw new Error("Ellipsis out of bounds");if(o=r.slice(u,u+x),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else if(t)this.hasEllipsis=!0,this.ellipsisDims=o;else throw new Error("Ellipsis must be specified in the LHS");for(let A=0;A<o.length;A++){let P=String.fromCharCode(48+A);h.addSymbol(P,l+A),this.addSymbol(P,r[u++],n)}}else h.addSymbol(y,l+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(y,r[u++],n)}),h}},Bo=e=>e+"_max",Cu=(e,t,r,n)=>{let i=e.map(h=>h.length).map((h,y)=>ht(`input${y}`,t,h)),s=De.size(n),o=Kt("output",t,n.length),u=[...r.symbolToInfo.keys()].filter(h=>!r.rhs.symbolToIndices.has(h)),d=h=>{let y=[],l="var prod = 1.0;",x="var sum = 0.0;",A="sum += prod;",P=[],S=[],Q=[],Y=[],D=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach((he,be)=>{if(r.rhs.symbolToIndices.has(be)){let Ye=r.rhs.symbolToIndices.get(be)?.[0];Ye!==void 0&&r.lhs.forEach((ze,Mt)=>{if(he.inputIndices.includes(Mt)){let Vt=ze.symbolToIndices.get(be);if(Vt===void 0)throw new Error("Invalid symbol error");Vt.forEach(jt=>{y.push(`${i[Mt].indicesSet(`input${Mt}Indices`,jt,o.indicesGet("outputIndices",Ye))}`)})}})}else r.lhs.forEach((Ye,ze)=>{if(he.inputIndices.includes(ze)){let Mt=Ye.symbolToIndices.get(be);if(Mt===void 0)throw new Error("Invalid symbol error");Mt.forEach(Vt=>{P.push(`${i[ze].indicesSet(`input${ze}Indices`,Vt,`${be}`)}`)}),Y.push(`prod *= ${i[ze].getByIndices(`input${ze}Indices`)};`)}}),S.push(`for(var ${be}: u32 = 0; ${be} < uniforms.${Bo(be)}; ${be}++) {`),Q.push("}")});let ne=D?[...y,`let sum = ${i.map((he,be)=>he.getByIndices(`input${be}Indices`)).join(" * ")};`]:[...y,x,...S,...P,l,...Y,A,...Q];return`
            ${h.registerUniforms(u.map(he=>({name:`${Bo(he)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...i,o)}

            ${h.mainStart()}
            ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${i.map((he,be)=>`var input${be}Indices: ${i[be].type.indices};`).join(`
`)}
            ${ne.join(`
`)};
            ${o.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let h=u.filter(l=>r.symbolToInfo.has(l)).map(l=>({type:12,data:r.symbolToInfo.get(l)?.dimValue||0}));h.push({type:12,data:s});let y=e.map((l,x)=>[...Ot(l)]).reduce((l,x)=>l.concat(x),h);return y.push(...Ot(n)),{outputs:[{dims:n,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:y}},getShaderSource:d}},$u=(e,t)=>{let r=new Eu(e.inputs,t.equation),n=r.outputDims,i=e.inputs.map((s,o)=>s.dims);e.compute(Cu(i,e.inputs[0].dataType,r,n))},Do=e=>{let t=e.equation.replace(/\s+/g,"");return hr({equation:t})}}),Rd,Lo,Su,Ro,ku,Nd=j(()=>{rr(),Jt(),fr(),Rd=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=r.length<t.length?0:r.length-t.length,i=t.length<r.length?0:t.length-r.length;for(;n<r.length&&i<t.length;++n,++i)if(r[n]!==t[i]&&r[n]!==1&&t[i]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Lo=(e,t)=>{let r=e.length-t.length,n=[];for(let i=0;i<r;++i)n.push(e[i]);for(let i=0;i<t.length;++i)n.push(t[i]===1?e[i+r]:t[i]);return n},Su=(e,t)=>e.length>t.length?Lo(e,t):Lo(t,e),Ro=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=Su(t,r),i=e[0].dataType,s=i===9?4:1,o=Math.ceil(De.size(n)/s),u=h=>{let y=ht("input",i,t.length,s),l=Kt("output",i,n.length,s),x;if(i===9){let A=(P,S,Q="")=>`
          let outputIndices${S} = ${l.offsetToIndices(`outputOffset + ${S}u`)};
          let offset${S} = ${y.broadcastedIndicesToOffset(`outputIndices${S}`,l)};
          let index${S} = offset${S} / 4u;
          let component${S} = offset${S} % 4u;
          ${P}[${S}] = ${Q}(${y.getByOffset(`index${S}`)}[component${S}]);
        `;x=`
        let outputOffset = global_idx * ${s};
        var data = vec4<u32>(0);
        ${A("data",0,"u32")}
        ${A("data",1,"u32")}
        ${A("data",2,"u32")}
        ${A("data",3,"u32")}
        ${l.setByOffset("global_idx","data")}
      }`}else x=`
        let outputIndices = ${l.offsetToIndices("global_idx")};
        let inputOffset = ${y.broadcastedIndicesToOffset("outputIndices",l)};
        ${l.setByOffset("global_idx",y.getByOffset("inputOffset"))}
      }`;return`
    ${h.registerUniform("vec_size","u32").declareVariables(y,l)}
    ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${x}`},d=[{type:12,data:o},...Ot(t,n)];return{name:"Expand",shaderCache:{hint:`${n.length}`,inputDependencies:["rank"]},getShaderSource:u,getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:d})}},ku=e=>{Rd(e.inputs),e.compute(Ro(e.inputs),{inputs:[0]})}}),No,Pu,jd=j(()=>{rr(),Jt(),fr(),uo(),No=e=>{let t=e[0].dataType,r=De.size(e[0].dims),n=De.size(e[1].dims),i=n%4===0,s=o=>{let u=ht("x",t,[1],4),d=ht("bias",t,[1],4),h=Kt("y",t,[1],4),y=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],l=A=>`
      let bias${A}_offset: u32 = (global_idx * 4 + ${A}) % uniforms.bias_size;
      let bias${A} = ${d.getByOffset(`bias${A}_offset / 4`)}[bias${A}_offset % 4];`,x=i?`
      let bias = ${d.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${l(0)}${l(1)}${l(2)}${l(3)}
      let bias = ${u.type.value}(bias0, bias1, bias2, bias3);`;return`${o.registerUniforms(y).declareVariables(u,d,h)}

    ${ao(Br(t))}

    ${o.mainStart(pn)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${u.getByOffset("global_idx")};
      ${x}
      let x_in = x + bias;
      ${h.setByOffset("global_idx",cs("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${i}`,inputDependencies:["type","type"]},getShaderSource:s,getRunData:o=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:n}],dispatchGroup:{x:Math.ceil(r/pn/4)}})}},Pu=e=>{e.inputs.length<2||De.size(e.inputs[1].dims)===0?xl(e):e.compute(No(e.inputs))}}),jo,Ud,Vd,Uo,Au=j(()=>{rr(),Jt(),kr(),fr(),jo=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Ud=(e,t)=>{let r=e[0].dims,n=e[1].dims,i=r.length,s=De.normalizeAxis(t.axis,i),o=r.slice(0);o.splice(s,1,...n);let u=r[s],d=e[0].dataType===9?4:1,h=Math.ceil(De.size(o)/d),y=[{type:12,data:h},{type:6,data:u},{type:12,data:s},...Ot(e[0].dims,e[1].dims,o)],l=x=>{let A=ht("data",e[0].dataType,e[0].dims.length,d),P=ht("inputIndices",e[1].dataType,e[1].dims.length),S=Kt("output",e[0].dataType,o.length,d),Q=D=>{let ne=n.length,he=`var indicesIndices${D}  = ${P.type.indices}(0);`;for(let be=0;be<ne;be++)he+=`${ne>1?`indicesIndices${D}[${be}]`:`indicesIndices${D}`} = ${o.length>1?`outputIndices${D}[uniforms.axis + ${be}]`:`outputIndices${D}`};`;he+=`
          var idx${D} = ${P.getByIndices(`indicesIndices${D}`)};
          if (idx${D} < 0) {
            idx${D} = idx${D} + uniforms.axisDimLimit;
          }
          var dataIndices${D} : ${A.type.indices};
        `;for(let be=0,Ye=0;be<i;be++)be===s?(he+=`${i>1?`dataIndices${D}[${be}]`:`dataIndices${D}`} = u32(idx${D});`,Ye+=ne):(he+=`${i>1?`dataIndices${D}[${be}]`:`dataIndices${D}`} = ${o.length>1?`outputIndices${D}[${Ye}]`:`outputIndices${D}`};`,Ye++);return he},Y;if(e[0].dataType===9){let D=(ne,he,be="")=>`
          let outputIndices${he} = ${S.offsetToIndices(`outputOffset + ${he}u`)};
          ${Q(he)};
          let offset${he} = ${A.indicesToOffset(`dataIndices${he}`)};
          let index${he} = offset${he} / 4u;
          let component${he} = offset${he} % 4u;
          ${ne}[${he}] = ${be}(${A.getByOffset(`index${he}`)}[component${he}]);
        `;Y=`
        let outputOffset = global_idx * ${d};
        var value = vec4<u32>(0);
        ${D("value",0,"u32")}
        ${D("value",1,"u32")}
        ${D("value",2,"u32")}
        ${D("value",3,"u32")}
        ${S.setByOffset("global_idx","value")}
      `}else Y=`
      let outputIndices = ${S.offsetToIndices("global_idx")};
      ${Q("")};
      let value = ${A.getByIndices("dataIndices")};
      ${S.setByOffset("global_idx","value")};
      `;return`
      ${x.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(A,P,S)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${Y}
      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:l}},Vd=e=>hr({axis:e.axis}),Uo=(e,t)=>{let r=e.inputs;jo(r),e.compute(Ud(e.inputs,t))}}),Iu,Fu,Vo,Ou,Wd=j(()=>{rr(),Jt(),kr(),fr(),Iu=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let r=De.normalizeAxis(t.quantizeAxis,e[0].dims.length),n=t.blockSize,i=e[0],s=e[2],o=e.length===4?e[3]:void 0;if(s.dims.length!==i.dims.length||!i.dims.map((u,d)=>d===r?Math.ceil(u/n)===s.dims[d]:u===s.dims[d]).reduce((u,d)=>u&&d,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(o){if(o.dataType!==i.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(o.dims.length!==s.dims.length||!o.dims.map((u,d)=>u===s.dims[d]).reduce((u,d)=>u&&d,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Fu=(e,t)=>{let r=e[0].dims,n=e[1].dims,i=r.length,s=De.normalizeAxis(t.gatherAxis,i),o=De.normalizeAxis(t.quantizeAxis,i),u=r.slice(0);u.splice(s,1,...n);let d=De.size(u),h=e[2].dataType,y=e[0].dataType===22,l=[{type:12,data:d},{type:12,data:o},{type:12,data:s},{type:12,data:t.blockSize},...Ot(...e.map((A,P)=>A.dims),u)],x=A=>{let P=ht("data",e[0].dataType,e[0].dims.length),S=ht("inputIndices",e[1].dataType,e[1].dims.length),Q=ht("scales",e[2].dataType,e[2].dims.length),Y=e.length>3?ht("zeroPoint",e[3].dataType,e[3].dims.length):void 0,D=Kt("output",h,u.length),ne=[P,S,Q];Y&&ne.push(Y);let he=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${A.registerUniforms(he).declareVariables(...ne,D)}
        ${A.mainStart()}
        let output_indices = ${D.offsetToIndices("global_idx")};
        var indices_indices = ${S.type.indices}(0);
        ${n.length>1?`
          for (var i: u32 = 0; i < ${n.length}; i++) {
            let index = ${D.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${S.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${D.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${P.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${D.indicesGet("output_indices","i")};
          ${P.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${S.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${r[s]};
        }
        ${P.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${u.length}; i++) {
          let index = ${D.indicesGet("output_indices",`i + ${n.length} - 1`)};
          ${P.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${P.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${P.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${y?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${Q.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${Q.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${Q.getByIndices("scale_indices")};
        ${Y?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${Y.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${Y.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${y?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${Br(h)}(quantized_data - zero_point) * scale;
        ${D.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((A,P)=>P!==1).map(A=>A.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(A,P)=>"rank")},getRunData:()=>({outputs:[{dims:u,dataType:h}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:l}),getShaderSource:x}},Vo=(e,t)=>{let r=e.inputs;Iu(r,t),e.compute(Fu(e.inputs,t))},Ou=e=>hr({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),Wo,Bu,Du,Go,Gd=j(()=>{rr(),Jt(),kr(),fr(),Wo=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Bu=(e,t)=>{let r=e[0].dims,n=e[0].dataType,i=r.length,s=e[1].dims,o=e[1].dataType,u=De.normalizeAxis(t.axis,i),d=r[u],h=s.slice(0),y=De.size(h),l=ht("input",n,i),x=ht("indicesInput",o,s.length),A=Kt("output",n,h.length),P=[{type:12,data:y},{type:6,data:d},{type:12,data:u}];return P.push(...Ot(r,s,h)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:h,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:P}),getShaderSource:S=>`
      ${S.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(l,x,A)}
      ${S.mainStart()}
      ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${A.offsetToIndices("global_idx")};

      var idx = ${x.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${l.type.indices}(outputIndices);
      ${l.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${l.getByIndices("inputIndices")};

      ${A.setByOffset("global_idx","value")};
  }`}},Du=e=>hr({axis:e.axis}),Go=(e,t)=>{let r=e.inputs;Wo(r),e.compute(Bu(e.inputs,t))}}),zu,Lu,Ru,Lr,Kc=j(()=>{rr(),Jt(),fr(),zu=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Lu=(e,t)=>{let r=e[0].dims.slice(),n=e[1].dims.slice(),[i,s,o]=ln.getShapeOfGemmResult(r,t.transA,n,t.transB,e.length===3?e[2].dims:void 0),u=[i,s];if(!u)throw new Error("Can't use gemm on the given tensors");let d=De.size(u),h=[{type:12,data:d},{type:12,data:i},{type:12,data:s},{type:12,data:o},{type:1,data:t.alpha},{type:1,data:t.beta}],y=["type","type"];e.length===3&&(h.push(...Ot(e[2].dims)),y.push("rank")),h.push(...Ot(u));let l=x=>{let A="";t.transA&&t.transB?A="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":t.transA&&!t.transB?A="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!t.transA&&t.transB?A="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!t.transA&&!t.transB&&(A="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let P=t.alpha===1?"":"value *= uniforms.alpha;",S=ht("a",e[0].dataType,e[0].dims),Q=ht("b",e[1].dataType,e[1].dims),Y=S.type.value,D=null,ne=[S,Q];e.length===3&&(D=ht("c",e[2].dataType,e[2].dims.length),ne.push(D));let he=Kt("output",e[0].dataType,u.length);ne.push(he);let be=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${x.registerUniforms(be).declareVariables(...ne)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${Y}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${A}
    }

    ${P}
    ${D!=null?`let cOffset = ${D.broadcastedIndicesToOffset("vec2(m, n)",he)}; value += ${Y}(uniforms.beta) * ${D.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`};return{name:"Gemm",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:l}},Ru=e=>{let t=e.transA,r=e.transB,n=e.alpha,i=e.beta;return{transA:t,transB:r,alpha:n,beta:i,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},Lr=(e,t)=>{zu(e.inputs),e.compute(Lu(e.inputs,t))}}),yn,qd,qo,Ho,Nu,qi,ju,Ko=j(()=>{rr(),Jt(),kr(),me(),as(),fr(),jn(),yn=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,qd=(e,t)=>{let r=e[0],n=yn(e,1),i=yn(e,2),s=yn(e,3),o=yn(e,4),u=yn(e,5),d=yn(e,6),h=yn(e,7);if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let y=r.dims[0],l=r.dims[1],x=r.dims.length===3?r.dims[2]:t.numHeads*r.dims[4],A=l,P=0,S=0,Q=Math.floor(x/t.numHeads);if(d&&h&&De.size(d.dims)&&De.size(h.dims)){if(d.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(d.dims[0]!==y||d.dims[1]!==t.numHeads||d.dims[3]!==Q)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(h.dims[0]!==y||h.dims[1]!==t.numHeads||h.dims[3]!==Q)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[2]!==h.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(h.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');P=d.dims[2],S=d.dims[2]}else if(d&&De.size(d.dims)||h&&De.size(h.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let Y;if(n&&De.size(n.dims)>0){if(r.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(n.dims.length===3){if(n.dims[2]!==r.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');Y=2,A=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==Q)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw new Error('Expect "value" be none when "key" has packed kv format.');Y=5,A=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==Q)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');Y=0,A=n.dims[2]}}else{if(r.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(r.dims[2]!==t.numHeads||r.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');Y=3}if(s&&De.size(s.dims)>0){if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(n&&n.dims.length===5&&n.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let D=P+A,ne=0;if(o&&De.size(o.dims)>0){ne=8;let ze=o.dims;throw ze.length===1?ze[0]===y?ne=1:ze[0]===3*y+2&&(ne=3):ze.length===2&&ze[0]===y&&ze[1]===D&&(ne=5),ne===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let he=!1,be=x;if(i&&De.size(i.dims)>0){if(i.dims.length!==3&&i.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==i.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(A!==i.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');be=i.dims[2]}else{if(A!==i.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');be=i.dims[1]*i.dims[3],he=!0}}let Ye=!1;if(o&&De.size(o.dims)>0)throw new Error("Key padding mask is not supported");if(u&&De.size(u.dims)>0){if(u.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(u.dims[0]!==y||u.dims[1]!==t.numHeads||u.dims[2]!==l||u.dims[3]!==D)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:y,sequenceLength:l,pastSequenceLength:P,kvSequenceLength:A,totalSequenceLength:D,maxSequenceLength:S,inputHiddenSize:0,hiddenSize:x,vHiddenSize:be,headSize:Q,vHeadSize:Math.floor(be/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:ne,scale:t.scale,broadcastResPosBias:Ye,passPastInKv:he,qkvFormat:Y}},qo=e=>hr({...e}),Ho=hr({perm:[0,2,1,3]}),Nu=(e,t,r,n,i,s,o)=>{let u=[n,i,s],d=De.size(u),h=[{type:12,data:d},{type:12,data:o},{type:12,data:s}],y=l=>{let x=Kt("qkv_with_bias",t.dataType,u),A=ht("qkv",t.dataType,u),P=ht("bias",r.dataType,u),S=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${l.registerUniforms(S).declareVariables(A,P,x)}
  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:y},{inputs:[t,r],outputs:[-1]})[0]},qi=(e,t,r,n,i,s,o,u)=>{let d=s;if(o&&De.size(o.dims)>0){if(n===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return d=Nu(e,s,o,t,n,r*i,u),d=d.reshape([t,n,r,i]),r===1||n===1?d:e.compute(Mn(d,Ho.perm),{inputs:[d],outputs:[-1]})[0]}else return s.dims.length===3&&(d=s.reshape([t,n,r,i])),r===1||n===1?d:e.compute(Mn(d,Ho.perm),{inputs:[d],outputs:[-1]})[0]},ju=(e,t)=>{let r=qd(e.inputs,t),n=e.inputs[0],i=yn(e.inputs,1),s=yn(e.inputs,2),o=yn(e.inputs,3),u=yn(e.inputs,4),d=yn(e.inputs,5),h=yn(e.inputs,6),y=yn(e.inputs,7);if(n.dims.length===5)throw new Error("Packed QKV is not implemented");if(i?.dims.length===5)throw new Error("Packed KV is not implemented");let l=i&&s&&i.dims.length===4&&s.dims.length===4,x=qi(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,n,o,0);if(l)return vi(e,x,i,s,u,void 0,h,y,d,r);if(!i||!s)throw new Error("key and value must be provided");let A=qi(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,i,o,r.hiddenSize),P=qi(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,s,o,2*r.hiddenSize);vi(e,x,A,P,u,void 0,h,y,d,r)}}),Xo,Uu,Vu,Yo,Wu,Hd,Gu,qu=j(()=>{rr(),Jt(),kr(),fr(),Xo=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Uu=(e,t)=>{let r=[],n=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),n=r.length),hr({numOutputs:n,axis:t.axis,splitSizes:r})},Vu=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < ${qt("uniforms.size_in_split_axis","i",e)}) {
        return i;
    }
    }
    return ${e}u;
}`,Yo=e=>{let t=e.length,r=[];for(let n=0;n<t;++n){let i=e[n].setByIndices("indices","input[global_idx]");t===1?r.push(i):n===0?r.push(`if (output_number == ${n}u) { ${i} }`):n===t-1?r.push(`else { ${i} }`):r.push(`else if (output_number == ${n}) { ${i} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},Wu=(e,t)=>{let r=e[0].dims,n=De.size(r),i=e[0].dataType,s=De.normalizeAxis(t.axis,r.length),o=new Array(t.numOutputs),u=ht("input",i,r.length),d=new Array(t.numOutputs),h=[],y=[],l=0,x=[{type:12,data:n}];for(let P=0;P<t.numOutputs;P++){l+=t.splitSizes[P],d[P]=l;let S=r.slice();S[s]=t.splitSizes[P],y.push(S),o[P]=Kt(`output${P}`,i,S.length),h.push({dims:y[P],dataType:e[0].dataType})}x.push({type:12,data:d},...Ot(r,...y));let A=P=>`
  ${P.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",d.length).declareVariables(u,...o)}
  ${Vu(d.length)}
  ${Yo(o)}

  ${P.mainStart()}
    ${P.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${u.offsetToIndices("global_idx")};
    var index = ${u.indicesGet("indices",s)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${qt("uniforms.size_in_split_axis","output_number - 1u",d.length)};
      ${u.indicesSet("indices",s,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:A,getRunData:()=>({outputs:h,dispatchGroup:{x:Math.ceil(n/64)},programUniforms:x})}},Hd=(e,t)=>{Xo(e.inputs);let r=e.inputs.length===1?t:Uu(e.inputs,t);e.compute(Wu(e.inputs,r),{inputs:[0]})},Gu=e=>{let t=e.axis,r=e.splitSizes,n=e.numOutputs<0?r.length:e.numOutputs;if(n!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return hr({axis:t,numOutputs:n,splitSizes:r})}}),Hu,Ku,Qo,Xu,Kd=j(()=>{kr(),as(),Ko(),qu(),jn(),Hu=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let r=e[0],n=e[1],i=e[2],s=e[3],o=e[4];if(t.localWindowSize!==-1)throw new Error("Local attention is not supported");if(t.softcap!==0)throw new Error("Softcap is not supported");if(t.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let u=!1,d=r.dims[0],h=r.dims[1],y=r.dims.length===3?u?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],l=h,x=0,A=!n||n.dims.length===0,P=Math.floor(A?y/(t.numHeads+2*t.kvNumHeads):y/t.numHeads);A&&(y=P*t.numHeads);let S=s&&s.dims.length!==0,Q=o&&o.dims.length!==0;if(S&&s.dims.length===4&&s.dims[0]===d&&s.dims[1]!==t.kvNumHeads&&s.dims[2]===t.kvNumHeads&&s.dims[3]===P)throw new Error("BSNH pastKey/pastValue is not supported");if(S&&Q){if(s.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(o.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');x=s.dims[2]}else if(S||Q)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let Y=1;if(n&&n.dims.length>0){if(r.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(n.dims.length===3){if(r.dims[2]%n.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');l=n.dims[1]}else if(n.dims.length===5){if(n.dims[2]!==t.numHeads||n.dims[3]!==2||n.dims[4]!==P)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(i)throw new Error('Expect "value" be none when "key" has packed kv format.');l=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==P)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');l=n.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');Y=3}let D=0,ne=!1,he=t.kvNumHeads?P*t.kvNumHeads:y;if(i&&i.dims.length>0){if(i.dims.length!==3&&i.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==i.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(i.dims.length===3){if(l!==i.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');he=i.dims[2]}else{if(l!==i.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');he=i.dims[1]*i.dims[3],ne=!0}}let be=e.length>4?e[5]:void 0;if(be&&be.dims.length!==1&&be.dims[0]!==d)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:d,sequenceLength:h,pastSequenceLength:x,kvSequenceLength:l,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:y,vHiddenSize:he,headSize:P,vHeadSize:Math.floor(he/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:D,scale:t.scale,broadcastResPosBias:!1,passPastInKv:ne,qkvFormat:Y}},Ku=hr({perm:[0,2,1,3]}),Qo=(e,t,r)=>{let n=t,i=r.kvNumHeads;return t.dims.length===3&&r.kvSequenceLength!==0&&(n=t.reshape([r.batchSize,r.kvSequenceLength,i,r.headSize]),n=e.compute(Mn(n,Ku.perm),{inputs:[n],outputs:[-1]})[0]),n},Xu=(e,t)=>{let r=Hu(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let n=e.inputs[0],i=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,s=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,o=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,u=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,d=e.inputs.length>4?e.inputs[5]:void 0,h=e.inputs.length>5?e.inputs[6]:void 0,y=r.kvNumHeads?r.kvNumHeads:r.numHeads,l=hr({axis:2,numOutputs:3,splitSizes:[r.numHeads*r.headSize,y*r.headSize,y*r.headSize]}),[x,A,P]=!i&&!s?e.compute(Wu([n],l),{inputs:[n],outputs:[-1,-1,-1]}):[n,i,s],S=qi(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,x,void 0,0);vi(e,S,Qo(e,A,r),Qo(e,P,r),void 0,void 0,o,u,void 0,r,d,h)}}),Zo,Yu,Qu,Zu,Xd=j(()=>{rr(),Jt(),jn(),fr(),Zo=(e,t,r,n,i,s,o,u)=>{let d=br(s),h=d===1?"f32":`vec${d}f`,y=d===1?"vec2f":`mat2x${d}f`,l=i*o,x=[i,o,s/d],A=[i,o,2],P=["rank","type","type"],S=[];S.push(...Ot(x,A));let Q=Y=>{let D=ht("x",t.dataType,3,d),ne=ht("scale",r.dataType,r.dims),he=ht("bias",n.dataType,n.dims),be=Kt("output",1,3,2),Ye=[D,ne,he,be],ze=64;return`
  var<workgroup> workgroup_shared : array<${y}, ${ze}>;
  const workgroup_size = ${ze}u;
  ${Y.declareVariables(...Ye)}
  ${Y.mainStart(ze)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${h}(0);
    var squared_sum = ${h}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${h}(${D.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${y}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${Nn("workgroup_shared[0][0]",d)} / f32(hight * ${d});
      let squared_sum_final = ${Nn("workgroup_shared[0][1]",d)} / f32(hight * ${d});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${u}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${d};${u}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:A,dataType:1}],dispatchGroup:{x:l},programUniforms:S}),getShaderSource:Q},{inputs:[t,r,n],outputs:[-1]})[0]},Yu=(e,t,r)=>{let n=t[0].dims,i=n,s=2,o=n[0],u=n[1],d=De.sizeFromDimension(n,s),h=br(d),y=De.size(i)/h,l=Zo(e,t[0],t[1],t[2],o,d,u,r.epsilon),x=[o,u,d/h],A=[o,u],P=["type","none"],S=Q=>{let Y=ht("x",t[0].dataType,x.length,h),D=ht("scale_shift",1,A.length,2),ne=Kt("output",t[0].dataType,x.length,h),he=[Y,D,ne];return`
  ${Q.registerUniform("output_size","u32").declareVariables(...he)}
  ${Q.mainStart()}
  ${Q.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${ne.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${D.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${Y.getByOffset("global_idx")} * ${ne.type.value}(scale_shift.x) + ${ne.type.value}(scale_shift.y);
      ${ne.setByOffset("global_idx","value")};
  }`};e.compute({name:"InstanceNormalization",shaderCache:{hint:`${h}`,inputDependencies:P},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...Ot(x,A,x)]}),getShaderSource:S},{inputs:[t[0],l]})},Qu=(e,t,r)=>{let n=t[0].dims,i=n,s=n[0],o=n[n.length-1],u=De.sizeFromDimension(n,1)/o,d=br(o),h=De.size(i)/d,y=[{type:12,data:u},{type:12,data:Math.floor(o/d)}],l=["type","type"],x=[0,n.length-1];for(let Q=0;Q<n.length-2;Q++)x.push(Q+1);let A=e.compute(Mn(e.inputs[0],x),{inputs:[e.inputs[0]],outputs:[-1]})[0],P=Zo(e,A,t[1],t[2],s,u,o,r.epsilon),S=Q=>{let Y=_r(t[0].dataType),D=d===1?"vec2f":`mat${d}x2f`,ne=Ye=>{let ze=Ye===0?"x":"y",Mt=d===1?"f32":`vec${d}f`;switch(d){case 1:return`${Y}(${Mt}(scale.${ze}))`;case 2:return`vec2<${Y}>(${Mt}(scale[0].${ze}, scale[1].${ze}))`;case 4:return`vec4<${Y}>(${Mt}(scale[0].${ze}, scale[1].${ze}, scale[2].${ze}, scale[3].${ze}))`;default:throw new Error(`Not supported compoents ${d}`)}},he=ht("input",t[0].dataType,t[0].dims,d),be=Kt("output",t[0].dataType,i,d);return`
  @group(0) @binding(0) var<storage, read> input : array<${he.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${D}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${be.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${Q.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${ne(0)}, ${ne(1)});
  }`};e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${d}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:S},{inputs:[t[0],P]})},Zu=(e,t)=>{t.format==="NHWC"?Qu(e,e.inputs,t):Yu(e,e.inputs,t)}}),Ju,ed,td,Yd=j(()=>{rr(),Jt(),fr(),Ju=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},ed=(e,t,r)=>{let n=t.simplified,i=e[0].dims,s=e[1],o=!n&&e[2],u=i,d=De.normalizeAxis(t.axis,i.length),h=De.sizeToDimension(i,d),y=De.sizeFromDimension(i,d),l=De.size(s.dims),x=o?De.size(o.dims):0;if(l!==y||o&&x!==y)throw new Error(`Size of X.shape()[axis:] == ${y}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${l} and bias size of ${x}`);let A=[];for(let be=0;be<i.length;++be)be<d?A.push(i[be]):A.push(1);let P=br(y),S=["type","type"],Q=[{type:12,data:h},{type:1,data:y},{type:12,data:Math.floor(y/P)},{type:1,data:t.epsilon}];o&&S.push("type");let Y=r>1,D=r>2,ne=be=>{let Ye=_r(e[0].dataType),ze=[ht("x",e[0].dataType,e[0].dims,P),ht("scale",s.dataType,s.dims,P)];o&&ze.push(ht("bias",o.dataType,o.dims,P)),ze.push(Kt("output",e[0].dataType,u,P)),Y&&ze.push(Kt("mean_data_output",1,A)),D&&ze.push(Kt("inv_std_output",1,A));let Mt=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${be.registerUniforms(Mt).declareVariables(...ze)}
  ${be.mainStart()}
    ${be.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${ii("f32",P)};
    var mean_square_vector = ${ii("f32",P)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Qn(Ye,P,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${Nn("mean_vector",P)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${Nn("mean_square_vector",P)} / uniforms.norm_size ${n?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Qn(Ye,P,"x[j + offset]")};
      let f32scale = ${Qn(Ye,P,"scale[j]")};
      output[j + offset] = ${ze[0].type.value}((f32input ${n?"":"- mean"}) * inv_std_dev * f32scale
        ${o?`+ ${Qn(Ye,P,"bias[j]")}`:""}
      );
    }

    ${Y?"mean_data_output[global_idx] = mean":""};
    ${D?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},he=[{dims:u,dataType:e[0].dataType}];return Y&&he.push({dims:A,dataType:1}),D&&he.push({dims:A,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${P};${r};${n}`,inputDependencies:S},getRunData:()=>({outputs:he,dispatchGroup:{x:Math.ceil(h/64)},programUniforms:Q}),getShaderSource:ne}},td=(e,t)=>{Ju(e.inputs),e.compute(ed(e.inputs,t,e.outputCount))}}),rd,Qd,Zd,Jd,ec,Xc=j(()=>{rr(),Jt(),kr(),fr(),rd=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let r=e[0],n=r.dims.length;if(r.dims[n-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let i=Math.floor((t.k+t.blockSize-1)/t.blockSize),s=t.blockSize/8*t.bits,o=e[1];if(!De.areEqual(o.dims,[t.n,i,s]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let u=e[2].dims;if(De.size(u)!==t.n*i)throw new Error("scales input size error.");if(e.length===4){let d=e[3].dims,h=t.bits>4?t.n*i:t.n*Math.floor((i+1)/2);if(De.size(d)!==h)throw new Error("zeroPoints input size error.")}},Qd=(e,t)=>{let r=e[0].dims,n=r.length,i=r[n-2],s=t.k,o=t.n,u=r.slice(0,n-2),d=De.size(u),h=e[1].dims[2]/4,y=e[0].dataType,l=br(t.k),x=br(h),A=br(o),P=u.concat([i,o]),S=i>1&&o/A%2===0?2:1,Q=De.size(P)/A/S,Y=64,D=[],ne=[d,i,s/l],he=De.convertShape(e[1].dims).slice();he.splice(-1,1,h/x),D.push(...Ot(ne)),D.push(...Ot(he)),D.push(...Ot(e[2].dims)),e.length===4&&D.push(...Ot(De.convertShape(e[3].dims)));let be=[d,i,o/A];D.push(...Ot(be));let Ye=ze=>{let Mt=ne.length,Vt=ht("a",e[0].dataType,Mt,l),jt=ht("b",12,he.length,x),lr=ht("scales",e[2].dataType,e[2].dims.length),Zt=[Vt,jt,lr],ur=e.length===4?ht("zero_points",12,e[3].dims.length):void 0;ur&&Zt.push(ur);let Sr=be.length,or=Kt("output",e[0].dataType,Sr,A),Yt=_r(e[0].dataType),Tr=(()=>{switch(l){case 1:return`array<${Yt}, 8>`;case 2:return`mat4x2<${Yt}>`;case 4:return`mat2x4<${Yt}>`;default:throw new Error(`${l}-component is not supported.`)}})(),xr=()=>{let ut=`
          // reuse a data
            var input_offset = ${Vt.indicesToOffset(`${Vt.type.indices}(batch, row, word_offset)`)};
            var a_data: ${Tr};
            for (var j: u32 = 0; j < ${8/l}; j++) {
              a_data[j] = ${Vt.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let St=0;St<A*S;St++)ut+=`
            b_value = ${x===1?`b${St}_data`:`b${St}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${Tr}(${Array.from({length:4},(mr,Wr)=>`${Yt}(b_value_lower[${Wr}]), ${Yt}(b_value_upper[${Wr}])`).join(", ")});
            b_dequantized_values = ${l===1?`${Tr}(${Array.from({length:8},(mr,Wr)=>`(b_quantized_values[${Wr}] - ${ur?`zero_point${St}`:"zero_point"}) * scale${St}`).join(", ")});`:`(b_quantized_values - ${Tr}(${Array(8).fill(`${ur?`zero_point${St}`:"zero_point"}`).join(",")})) * scale${St};`};
            workgroup_shared[local_id.x * ${S} + ${Math.floor(St/A)}]${A>1?`[${St%A}]`:""} += ${Array.from({length:8/l},(mr,Wr)=>`${l===1?`a_data[${Wr}] * b_dequantized_values[${Wr}]`:`dot(a_data[${Wr}], b_dequantized_values[${Wr}])`}`).join(" + ")};
          `;return ut},Xt=()=>{let ut=`
            var col_index = col * ${A};
            ${ur?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Yt}(8);`}
            `;for(let St=0;St<A*S;St++)ut+=`
            let scale${St} = ${lr.getByOffset("col_index * nBlocksPerCol + block")};
            ${ur?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${ur.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${St} = ${Yt}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return ut},yr=()=>{let ut=`col_index = col * ${A};`;for(let St=0;St<A*S;St++)ut+=`
            let b${St}_data = ${jt.getByIndices(`${jt.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return ut+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${Tr};
            var b_dequantized_values: ${Tr};`,ut};return`
        var<workgroup> workgroup_shared: array<${or.type.value}, ${S*Y}>;
        ${ze.declareVariables(...Zt,or)}
        ${ze.mainStart([Y,1,1])}
          let output_indices = ${or.offsetToIndices(`(global_idx / ${Y}) * ${S}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${Y}) {
            //process one block
            var word_offset: u32 = block * ${t.blockSize/l};
            ${Xt()}
            for (var word: u32 = 0; word < ${h}; word += ${x}) {
              ${yr()}
              for (var i: u32 = 0; i < ${x}; i++) {
                ${xr()}
                word_offset += ${8/l};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${S}) {
            var output_value: ${or.type.value} = ${or.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${Y}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${S};
            }
            ${or.setByIndices(`${or.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${l};${x};${A};${S};${Y}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:P,dataType:y}],dispatchGroup:{x:Q},programUniforms:D}),getShaderSource:Ye}},Zd=(e,t)=>{let r=e[0].dims,n=r.length,i=r[n-2],s=t.k,o=t.n,u=r.slice(0,n-2),d=De.size(u),h=e[1].dims[2]/4,y=e[0].dataType,l=br(t.k),x=br(h),A=u.concat([i,o]),P=128,S=o%8===0?8:o%4===0?4:1,Q=P/S,Y=Q*x*8,D=Y/l,ne=Y/t.blockSize,he=De.size(A)/S,be=[],Ye=[d,i,s/l],ze=De.convertShape(e[1].dims).slice();ze.splice(-1,1,h/x),be.push(...Ot(Ye)),be.push(...Ot(ze)),be.push(...Ot(e[2].dims)),e.length===4&&be.push(...Ot(De.convertShape(e[3].dims)));let Mt=[d,i,o];be.push(...Ot(Mt));let Vt=jt=>{let lr=Ye.length,Zt=ht("a",e[0].dataType,lr,l),ur=ht("b",12,ze.length,x),Sr=ht("scales",e[2].dataType,e[2].dims.length),or=[Zt,ur,Sr],Yt=e.length===4?ht("zero_points",12,e[3].dims.length):void 0;Yt&&or.push(Yt);let Tr=Mt.length,xr=Kt("output",e[0].dataType,Tr),Xt=_r(e[0].dataType),yr=()=>{switch(l){case 1:return`
          let a_data0 = vec4<${Xt}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${Xt}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${Xt}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${Xt}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${l}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${Zt.type.value}, ${D}>;
        var<workgroup> inter_results: array<array<${xr.type.value}, ${Q}>, ${S}>;
        ${jt.declareVariables(...or,xr)}
        ${jt.mainStart([Q,S,1])}
          let output_indices = ${xr.offsetToIndices(`workgroup_index * ${S}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${ne} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${D};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${D}; a_offset += ${P})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${Zt.getByIndices(`${Zt.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${Zt.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${ne} + local_id.x;
            ${Yt?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${Yt.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${Xt}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${Xt}(8);`}
            let scale = ${Sr.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${ur.getByIndices(`${ur.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${t.blockSize/l};
            for (var i: u32 = 0; i < ${x}; i++) {
              ${yr()}
              let b_value = ${x===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${Xt}>(${Array.from({length:4},(ut,St)=>`${Xt}(b_value_lower[${St}]), ${Xt}(b_value_upper[${St}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${Xt}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(ut,St)=>`${`dot(a_data${St}, b_dequantized_values[${St}])`}`).join(" + ")};
              word_offset += ${8/l};
            }
            workgroupBarrier();
          }

          if (local_idx < ${S}) {
            var output_value: ${xr.type.value} = ${xr.type.value}(0);
            for (var b = 0u; b < ${Q}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${xr.setByIndices(`${xr.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${l};${x};${Q};${S}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:A,dataType:y}],dispatchGroup:{x:he},programUniforms:be}),getShaderSource:Vt}},Jd=(e,t)=>{rd(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(Zd(e.inputs,t)):e.compute(Qd(e.inputs,t))},ec=e=>hr(e)}),tc,rc,nc,ic,sc,oc,ac,lc,uc,Yc=j(()=>{rr(),Jt(),fr(),tc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},rc=(e,t,r)=>{let n="";for(let i=t-1;i>=0;--i)n+=`
            k = i32(${e.indicesGet("indices",i)}) - ${qt("uniforms.pads",i,r)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${qt("uniforms.x_shape",i,t)})) {
              break;
            }
            offset += k * i32(${qt("uniforms.x_strides",i,t)});
        `;return`
          value = ${e.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${n}
            value = x[offset];
          }
      `},nc=(e,t,r)=>{let n="";for(let i=t-1;i>=0;--i)n+=`
                k = i32(${e.indicesGet("indices",i)}) - ${qt("uniforms.pads",i,r)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${qt("uniforms.x_shape",i,t)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${qt("uniforms.x_shape",i,t)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${qt("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `},ic=(e,t,r)=>{let n="";for(let i=t-1;i>=0;--i)n+=`
                k = i32(${e.indicesGet("indices",i)}) - ${qt("uniforms.pads",i,r)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${qt("uniforms.x_shape",i,t)})) {
                  k = i32(${qt("uniforms.x_shape",i,t)}) - 1;
                }
                offset += k * i32(${qt("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `},sc=(e,t,r)=>{let n="";for(let i=t-1;i>=0;--i)n+=`
                k = i32(${e.indicesGet("indices",i)}) - ${qt("uniforms.pads",i,r)};
                if (k < 0)  {
                  k += i32(${qt("uniforms.x_shape",i,t)}]);
                }
                if (k >= i32(${qt("uniforms.x_shape",i,t)})) {
                  k -= i32(${qt("uniforms.x_shape",i,t)});
                }
                offset += k * i32(${qt("uniforms.x_strides",i,t)});
            `;return`
              var offset = 0;
              var k = 0;
              ${n}
              value = x[offset];
          `},oc=(e,t,r)=>{switch(r.mode){case 0:return rc(e,t,r.pads.length);case 1:return nc(e,t,r.pads.length);case 2:return ic(e,t,r.pads.length);case 3:return sc(e,t,r.pads.length);default:throw new Error("Invalid mode")}},ac=(e,t)=>{let r=De.padShape(e[0].dims.slice(),t.pads),n=e[0].dims,i=De.size(r),s=[{type:12,data:i},{type:6,data:t.pads}],o=e.length>=3&&e[2].data;t.mode===0&&s.push({type:o?e[2].dataType:1,data:t.value}),s.push(...Ot(e[0].dims,r));let u=["rank"],d=h=>{let y=Kt("output",e[0].dataType,r.length),l=ht("x",e[0].dataType,n.length),x=l.type.value,A=oc(y,n.length,t),P=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return t.mode===0&&P.push({name:"constant_value",type:o?x:"f32"}),`
            ${h.registerUniforms(P).declareVariables(l,y)}
            ${h.mainStart()}
            ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${y.offsetToIndices("global_idx")};

            var value = ${x}(0);
            ${A}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${t.mode}${o}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(De.size(r)/64)},programUniforms:s}),getShaderSource:d}},lc=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),n=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,i=e[0].dims.length,s=new Int32Array(2*i).fill(0);if(e.length>=4){let u=e[3].getBigInt64Array();for(let d=0;d<u.length;d++)s[Number(u[d])]=Number(r[d]),s[Number(u[d])+i]=Number(r[d+u.length])}else r.forEach((u,d)=>s[Number(d)]=Number(u));let o=[];return s.forEach(u=>o.push(u)),{mode:t.mode,value:n,pads:o}}else return t},uc=(e,t)=>{tc(e.inputs);let r=lc(e.inputs,t);e.compute(ac(e.inputs,r),{inputs:[0]})}}),ws,nd,id,sd,od,dc,cc,ad,ld,pc,hc,ud,fc,mc,dd,cr,cd,nn,un,_n=j(()=>{c(),rr(),Jt(),fr(),ws=e=>{if(I.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},nd=(e,t,r)=>{let n=t.format==="NHWC",i=e.dims.slice();n&&i.splice(1,0,i.pop());let s=Object.hasOwnProperty.call(t,"dilations"),o=t.kernelShape.slice(),u=t.strides.slice(),d=s?t.dilations.slice():[],h=t.pads.slice();Jr.adjustPoolAttributes(r,i,o,u,d,h);let y=Jr.computePoolOutputShape(r,i,u,d,o,h,t.autoPad),l=Object.assign({},t);s?Object.assign(l,{kernelShape:o,strides:u,pads:h,dilations:d,cacheKey:t.cacheKey}):Object.assign(l,{kernelShape:o,strides:u,pads:h,cacheKey:t.cacheKey});let x=y.slice();return x.push(x.splice(1,1)[0]),[l,n?x:y]},id=(e,t)=>{let r=t.format==="NHWC",n=De.size(e),i=De.size(t.kernelShape),s=[{type:12,data:n},{type:12,data:i}],o=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let u=t.kernelShape[t.kernelShape.length-1],d=t.strides[t.strides.length-1],h=t.pads[t.pads.length/2-1],y=t.pads[t.pads.length-1],l=!!(h+y);s.push({type:12,data:u},{type:12,data:d},{type:12,data:h},{type:12,data:y}),o.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let x=!1;if(t.kernelShape.length===2){let A=t.kernelShape[t.kernelShape.length-2],P=t.strides[t.strides.length-2],S=t.pads[t.pads.length/2-2],Q=t.pads[t.pads.length-2];x=!!(S+Q),s.push({type:12,data:A},{type:12,data:P},{type:12,data:S},{type:12,data:Q}),o.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,o,!0,l,x]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let u=De.computeStrides(t.kernelShape);s.push({type:12,data:u},{type:12,data:t.pads},{type:12,data:t.strides}),o.push({name:"kernelStrides",type:"u32",length:u.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let d=t.pads.reduce((h,y)=>h+y);return[s,o,!!d,!1,!1]}},sd=(e,t,r,n,i,s,o,u,d,h,y,l)=>{let x=i.format==="NHWC",A=t.type.value,P=Kt("output",t.type.tensor,n);if(i.kernelShape.length<=2){let S="",Q="",Y="",D=r-(x?2:1);if(y?S=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${D}] = indices[${D}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${D}] < 0 || xIndices[${D}]
                      >= uniforms.x_shape[${D}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`:S=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${D}] = indices[${D}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`,i.kernelShape.length===2){let ne=r-(x?3:2);l?Q=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ne}] = indices[${ne}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${ne}] < 0 || xIndices[${ne}] >= uniforms.x_shape[${ne}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:Q=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${ne}] = indices[${ne}] * uniforms.sh - uniforms.phStart + j;
                `,Y=`
              }
            `}return`
            ${e.registerUniforms(d).declareVariables(t,P)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${P.offsetToIndices("global_idx")};
              var xIndices = ${P.offsetToIndices("global_idx")};

              var value = ${A}(${u});
              var pad = 0;
              ${Q}
              ${S}
              ${Y}
              ${o}

              output[global_idx] = value;
            }`}else{if(x)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let S=i.kernelShape.length,Q=i.pads.length,Y="";return h?Y=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:Y=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.registerUniforms(d).declareVariables(t,P)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${P.offsetToIndices("global_idx")};
              var xIndices = ${P.offsetToIndices("global_idx")};

              var offsets: array<u32, ${S}>;

              var value = ${A}(${u});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${S-1}u; j++) {
                  offsets[j] = offset / ${qt("uniforms.kernelStrides","j",S)};
                  offset -= offsets[j] * ${qt("uniforms.kernelStrides","j",S)};
                }
                offsets[${S-1}] = offset;

                isPad = false;
                for (var j = ${r-S}u; j < ${r}u; j++) {
                  xIndices[j] = indices[j] * ${qt("uniforms.strides",`j - ${r-S}u`,S)}
                    + offsets[j - ${r-S}u] - ${qt("uniforms.pads","j - 2u",Q)};
                  ${Y}
              }
              ${o}

              output[global_idx] = value;
            }`}},od=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,dc=e=>`${od(e)};${e.countIncludePad}`,cc=e=>`${od(e)};${e.storageOrder};${e.dilations}`,ad=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ld=(e,t,r,n)=>{let[i,s]=nd(t,n,r),o=ht("x",t.dataType,t.dims.length),u=o.type.value,d="value += x_val;",h="";i.countIncludePad?h+=`value /= ${u}(uniforms.kernelSize);`:h+=`value /= ${u}(i32(uniforms.kernelSize) - pad);`;let[y,l,x,A,P]=id(s,i);y.push(...Ot(t.dims,s));let S=["rank"];return{name:e,shaderCache:{hint:`${n.cacheKey};${x};${A};${P}`,inputDependencies:S},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(De.size(s)/64)},programUniforms:y}),getShaderSource:Q=>sd(Q,o,t.dims.length,s.length,i,d,h,0,l,x,A,P)}},pc=e=>{let t=e.count_include_pad!==0,r=ad(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let n={countIncludePad:t,...r,cacheKey:""};return{...n,cacheKey:dc(n)}},hc=(e,t)=>{ws(e.inputs),e.compute(ld("AveragePool",e.inputs[0],!1,t))},ud={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},fc=e=>{let t=e.format;return{format:t,...ud,cacheKey:t}},mc=(e,t)=>{ws(e.inputs),e.compute(ld("GlobalAveragePool",e.inputs[0],!0,t))},dd=(e,t,r,n)=>{let[i,s]=nd(t,n,r),o=`
      value = max(x_val, value);
    `,u="",d=ht("x",t.dataType,t.dims.length),h=["rank"],[y,l,x,A,P]=id(s,i);return y.push(...Ot(t.dims,s)),{name:e,shaderCache:{hint:`${n.cacheKey};${x};${A};${P}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(De.size(s)/64)},programUniforms:y}),getShaderSource:S=>sd(S,d,t.dims.length,s.length,i,o,u,t.dataType===10?-65504:-1e5,l,x,A,P)}},cr=(e,t)=>{ws(e.inputs),e.compute(dd("MaxPool",e.inputs[0],!1,t))},cd=e=>{let t=e.storage_order,r=e.dilations,n=ad(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let i={storageOrder:t,dilations:r,...n,cacheKey:""};return{...i,cacheKey:cc(i)}},nn=e=>{let t=e.format;return{format:t,...ud,cacheKey:t}},un=(e,t)=>{ws(e.inputs),e.compute(dd("GlobalMaxPool",e.inputs[0],!0,t))}}),oi,gc,pd,hd,_=j(()=>{rr(),Jt(),kr(),fr(),oi=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(e.length===3&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[0].dataType===6&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((r,n)=>r===e[2].dims[n]).reduce((r,n)=>r&&n,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((i,s)=>s===t.axis||i===e[0].dims[s]).reduce((i,s)=>i&&s,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let r=e[0].dims[t.axis],n=e[1].dims[t.axis];if(t.blockSize<Math.ceil(r/n)||t.blockSize>Math.ceil(r/(n-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},gc=(e,t)=>{let r=De.normalizeAxis(t.axis,e[0].dims.length),n=e[0].dataType,i=n===3,s=e[0].dims,o=e[1].dataType,u=De.size(s),d=n===3||n===2,h=d?[Math.ceil(De.size(e[0].dims)/4)]:e[0].dims,y=e[1].dims,l=e.length>2?e[2]:void 0,x=l?d?[Math.ceil(De.size(l.dims)/4)]:l.dims:void 0,A=y.length===0||y.length===1&&y[0]===1,P=A===!1&&y.length===1,S=br(u),Q=A&&(!d||S===4),Y=Q?S:1,D=Q&&!d?S:1,ne=ht("input",d?12:n,h.length,D),he=ht("scale",o,y.length),be=l?ht("zero_point",d?12:n,x.length):void 0,Ye=Kt("output",o,s.length,Y),ze=[ne,he];be&&ze.push(be);let Mt=[h,y];l&&Mt.push(x);let Vt=[{type:12,data:u/Y},{type:12,data:r},{type:12,data:t.blockSize},...Ot(...Mt,s)],jt=lr=>{let Zt=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${lr.registerUniforms(Zt).declareVariables(...ze,Ye)}
      ${lr.mainStart()}
          ${lr.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${Ye.offsetToIndices("global_idx")};

          // Set input x
          ${d?`
            let input = ${ne.getByOffset("global_idx / 4")};
            let x_vec = ${i?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${Y===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${ne.getByOffset("global_idx")};`};

          // Set scale input
          ${A?`let scale_value= ${he.getByOffset("0")}`:P?`
            let scale_index = ${Ye.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${he.getByOffset("scale_index")};`:`
            var scale_indices: ${he.type.indices} = output_indices;
            let index = ${he.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${he.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${he.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${be?A?d?`
                let zero_point_input = ${be.getByOffset("0")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${be.getByOffset("0")}`:P?d?`
                let zero_point_index = ${Ye.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${be.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${Ye.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${be.getByOffset("zero_point_index")};`:d?`
                let zero_point_offset = ${he.indicesToOffset("scale_indices")};
                let zero_point_input = ${be.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${i?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${be.getByIndices("scale_indices")};`:`let zero_point_value = ${d?i?"i32":"u32":ne.type.value}(0);`};
      // Compute and write output
      ${Ye.setByOffset("global_idx",`${Ye.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:be?["rank","rank","rank"]:["rank","rank"]},getShaderSource:jt,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/Y/64),y:1,z:1},programUniforms:Vt})}},pd=(e,t)=>{oi(e.inputs,t),e.compute(gc(e.inputs,t))},hd=e=>hr({axis:e.axis,blockSize:e.blockSize})}),w,le,qe,Je=j(()=>{c(),rr(),fr(),w=(e,t,r)=>{let n=e===t,i=e<t&&r<0,s=e>t&&r>0;if(n||i||s)throw new Error("Range these inputs' contents are invalid.")},le=(e,t,r,n)=>{let i=Math.abs(Math.ceil((t-e)/r)),s=[i],o=i,u=[{type:12,data:o},{type:n,data:e},{type:n,data:r},...Ot(s)],d=h=>{let y=Kt("output",n,s.length),l=y.type.value,x=[{name:"outputSize",type:"u32"},{name:"start",type:l},{name:"delta",type:l}];return`
        ${h.registerUniforms(x).declareVariables(y)}
        ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${l}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${n}`},getShaderSource:d,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:u})}},qe=e=>{let t=0,r=0,n=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],n=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],n=e.inputs[2].getFloat32Array()[0]),I.webgpu.validateInputContent&&w(t,r,n),e.compute(le(t,r,n,e.inputs[0].dataType),{inputs:[]})}}),ft,Bt,It,Qt,wr,Ur,Dr,$r,tr,rn,Mr,vr,Vr,dn,Gr,sn,fn,en,on,Jo=j(()=>{rr(),Jt(),kr(),fr(),ft=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Bt=(e,t,r)=>{t.every(i=>i>=0&&i<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let n=new Array(r).fill(1);return t.forEach((i,s)=>n[i]=e[s]),n},It=(e,t,r,n,i,s)=>{let[o,u,d]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],h=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach(y=>s.push(y));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(u>0&&e.length>u&&e[u].dims.length===1&&e[u].dims[0]>0){if(e[u].getFloat32Array().forEach(y=>n.push(y)),n.length!==0&&n.length!==h&&r>=18&&n.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ft(n,t),t.axes.length>0&&Bt(n,t.axes,h).forEach((y,l)=>n[l]=y)}if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0&&(e[d].getBigInt64Array().forEach(y=>i.push(Number(y))),i.length!==0&&i.length!==h&&r>=18&&i.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(n.length!==0&&n.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(i.length!==0&&i.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof n<"u"&&typeof i<"u"&&n.length>0&&i.length>h)throw new Error("Resize requires only of scales or sizes to be specified")},Qt=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`return ${t}(xResized) / ${t}(xScale);`;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);
                    return whole + fract;
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +
                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /
                        ${t}(lengthResized - 1);
                  } else {
                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);
                  const adjustment = ${t}(lengthResized) / outputWidth;
                  const center = ${t}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",wr=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Ur=(e,t,r)=>{let n=new Array(r).fill(0).concat(new Array(r).fill(1)),i=e.length===0?n:e.slice();return t.length>0?(t.forEach((s,o)=>{n[s]=i[o],n[o+r]=i[t.length+o]}),n):i},Dr=(e,t,r,n)=>{let i=[];if(r.length>0)if(n.length>0){if(e.forEach(s=>i.push(s)),Math.max(...n)>e.length)throw new Error("axes is out of bound");n.forEach((s,o)=>i[s]=r[o])}else r.forEach(s=>i.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");i=e.map((s,o)=>Math.round(s*t[o]))}return i},$r=(e,t,r)=>{let n=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let i=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=n),r.axes.forEach(s=>i[s]=Math.round(e[s]*t[s]))):(t.fill(n,0,t.length),i.forEach((s,o)=>i[o]=Math.round(s*t[o]))),i},tr=(e,t,r,n,i)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {
      var original_indices: array<${e.type.value}, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var scale = ${qt("uniforms.scales","i",n)};
        var roi_low = ${qt("uniforms.roi","i",i)};
        var roi_hi = ${qt("uniforms.roi",`i + ${t.length}`,i)};
        if (scale == 1.0) {
          original_indices[i] = ${e.type.value}(output_index);
        } else {
          var input_shape_i = ${qt("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${qt("uniforms.output_shape","i",r.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,rn=(e,t,r,n,i,s,o)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
      var input_indices: ${e.type.indices};
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${qt("uniforms.scales","i",i)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${qt("uniforms.roi","i",s)};
          var roi_hi = ${qt("uniforms.roi",`i + ${r.length}`,s)};
          var input_shape_i = ${qt("uniforms.input_shape","i",r.length)};
          var output_shape_i = ${qt("uniforms.output_shape","i",n.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${e.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,Mr=(e,t)=>`
    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var input_index = ${e.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${qt("uniforms.input_shape","i",t.length)}) {
          return false;
        }
      }
      return true;
    }`,vr=(e,t,r,n)=>e.rank>n?`
    ${e.indicesSet("input_indices",t,"channel")};
    ${e.indicesSet("input_indices",r,"batch")};
`:"",Vr=(e,t,r,n,i)=>{let[s,o,u,d]=r.length===2?[-1,0,1,-1]:[0,2,3,1],h=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${h} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",o,`max(0, min(row, ${r[o]} - 1))`)};
      ${e.indicesSet("input_indices",u,`max(0, min(col, ${r[u]} - 1))`)};
      ${vr(e,d,s,2)}
      return ${e.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${h} = originalIndices[${o}];
      var col:${h} = originalIndices[${u}];
      ${n?`if (row < 0 || row > (${r[o]} - 1) || col < 0 || col > (${r[u]} - 1)) {
        return ${i};
      }`:""};
      row = max(0, min(row, ${r[o]} - 1));
      col = max(0, min(col, ${r[u]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${r.length>2?`u32(originalIndices[${d}])`:"0"};
      var batch: u32 =  ${r.length>2?`u32(originalIndices[${s}])`:"0"};
      var x11: ${h} = getInputValue(batch, channel, row1, col1);
      var x12: ${h} = getInputValue(batch, channel, row1, col2);
      var x21: ${h} = getInputValue(batch, channel, row2, col1);
      var x22: ${h} = getInputValue(batch, channel, row2, col2);
      var dx1: ${h} = abs(row - ${h}(row1));
      var dx2: ${h} = abs(${h}(row2) - row);
      var dy1: ${h} = abs(col - ${h}(col1));
      var dy2: ${h} = abs(${h}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},dn=(e,t,r,n,i,s,o,u,d,h)=>{let y=r.length===2,[l,x]=y?[0,1]:[2,3],A=e.type.value,P=S=>{let Q=S===l?"row":"col";return`
      fn ${Q}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${A} {
        var output_index = ${t.indicesGet("output_indices",S)};
        var originalIdx: ${A} = getOriginalCoordinateFromResizedCoordinate(output_index, ${i[S]},
        ${n[S]}, ${r[S]}, ${s[S]}, ${s[S]} + ${r.length});
        var fractOriginalIdx: ${A} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${u} && (originalIdx < 0 || originalIdx > (${r[S]} - 1))) {
          return ${d};
        }
        var data: array<${A}, 4> = array<${A}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${Q}: ${A} = originalIdx + ${A}(i);
          if (${Q} < 0 || ${Q} >= ${r[S]}) {
            ${h?`coefs[i + 1] = 0.0;
                        continue;`:u?`return ${d};`:`${Q} = max(0, min(${Q}, ${r[S]} - 1));`};
          }
        var input_indices_copy: ${e.type.indices} = input_indices;
          ${e.indicesSet("input_indices_copy",S,`u32(${Q})`)};
          data[i + 1] = ${S===l?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${P(l)};
    ${P(x)};
  fn getCubicInterpolationCoefs(s: ${A}) -> array<${A}, 4> {
    var absS = abs(s);
    var coeffs: array<${A}, 4> = array<${A}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${A} = 1.0 - absS;
    var twoMinusAbsS: ${A} = 2.0 - absS;
    var onePlusAbsS: ${A} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${A}, 4>, coefs: array<${A}, 4>) -> ${A} {
    var coefsSum: ${A} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${A} {
    var input_indices: ${e.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},Gr=(e,t,r,n,i)=>{let[s,o,u,d,h]=r.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],y=e.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${y} {
      var input_indices: ${e.type.indices};
      ${e.indicesSet("input_indices",o,`max(0, min(depth, ${r[o]} - 1))`)};
      ${e.indicesSet("input_indices",u,`max(0, min(height, ${r[u]} - 1))`)};
      ${e.indicesSet("input_indices",d,`max(0, min(width, ${r[d]} - 1))`)};
      ${vr(e,h,s,3)}
      return ${e.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${y} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${y} = originalIndices[${o}];
      var height:${y} = originalIndices[${u}];
      var width:${y} = originalIndices[${d}];
      ${n?`if (depth < 0 || depth > (${r[o]} - 1) || height < 0 || height > (${r[u]} - 1) || width < 0 || (width > ${r[d]} - 1)) {
      return ${i};
        }`:""};

    depth = max(0, min(depth, ${r[o]} - 1));
      height = max(0, min(height, ${r[u]} - 1));
      width = max(0, min(width, ${r[d]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${r.length>3?`u32(originalIndices[${h}])`:"0"};
      var batch: u32 =  ${r.length>3?`u32(originalIndices[${s}])`:"0"};

      var x111: ${y} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${y} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${y} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${y} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${y} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${y} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${y} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${y} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${y} = abs(depth - ${y}(depth1));
      var dx2: ${y} = abs(${y}(depth2) - depth);
      var dy1: ${y} = abs(height - ${y}(height1));
      var dy2: ${y} = abs(${y}(height2) - height);
      var dz1: ${y} = abs(width - ${y}(width1));
      var dz2: ${y} = abs(${y}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},sn=(e,t,r,n,i,s)=>{let o=e.dims,u=Ur(s,t.axes,o.length),d=Dr(o,n,i,t.axes),h=n.slice();n.length===0&&(h=o.map((D,ne)=>D===0?1:d[ne]/D),t.keepAspectRatioPolicy!=="stretch"&&(d=$r(o,h,t)));let y=Kt("output",e.dataType,d.length),l=ht("input",e.dataType,o.length),x=De.size(d),A=o.length===d.length&&o.every((D,ne)=>D===d[ne]),P=t.coordinateTransformMode==="tf_crop_and_resize",S=t.extrapolationValue,Q=l.type.value,Y=D=>`
      ${A?"":`
      ${Qt(t.coordinateTransformMode,Q)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${Mr(l,o)};
              ${wr(t.nearestMode,r,Q)};
              ${rn(l,y,o,d,h.length,u.length,P)};
              `;case"linear":return`
              ${tr(y,o,d,h.length,u.length)};
              ${(()=>{if(o.length===2||o.length===4)return`${Vr(l,y,o,P,S)}`;if(o.length===3||o.length===5)return`${Gr(l,y,o,P,S)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(o.length===2||o.length===4)return`${dn(l,y,o,d,h,u,t.cubicCoeffA,P,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${D.registerUniform("output_size","u32").registerUniform("scales","f32",h.length).registerUniform("roi","f32",u.length).declareVariables(l,y)}
      ${D.mainStart()}
        ${D.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${A?"output[global_idx] = input[global_idx];":`
        let output_indices = ${y.offsetToIndices("global_idx")};
        var input_indices: ${l.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${l.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${o.length===2||o.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${h.length>0?h:""}|${i.length>0?i:""}|${u.length>0?u:""}|${A}|${o}`,inputDependencies:["rank"]},getShaderSource:Y,getRunData:()=>({outputs:[{dims:d,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(x/64)},programUniforms:[{type:12,data:x},{type:1,data:h},{type:1,data:u},...Ot(o,d)]})}},fn=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},en=(e,t)=>{let r=[],n=[],i=[],s=fn(e);if(t.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");It(e.inputs,t,s,r,n,i),e.compute(sn(e.inputs[0],t,s,r,n,i),{inputs:[0]})},on=e=>{let t=e.antialias,r=e.axes,n=e.coordinateTransformMode,i=e.cubicCoeffA,s=e.excludeOutside!==0,o=e.extrapolationValue,u=e.keepAspectRatioPolicy,d=e.mode,h=e.nearestMode===""?"simple":e.nearestMode;return hr({antialias:t,axes:r,coordinateTransformMode:n,cubicCoeffA:i,excludeOutside:s,extrapolationValue:o,keepAspectRatioPolicy:u,mode:d,nearestMode:h})}}),Hi,Qc,Bn,Ki=j(()=>{rr(),Jt(),kr(),fr(),Hi=(e,t)=>{let[r,n,i,s]=e,{numHeads:o,rotaryEmbeddingDim:u}=t;if(r.dims.length!==3&&r.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!De.areEqual(n.dims,[])&&!De.areEqual(n.dims,[1])&&n.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);if(i.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${i.dims.length}`);if(s.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(!De.areEqual(i.dims,s.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(u>0&&o===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let d=r.dims[0],h=r.dims[r.dims.length-2],y=i.dims[0],l=De.sizeFromDimension(r.dims,1)/h,x=u===0?i.dims[1]*2:l/o;if(u>x)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(n.dims.length===2){if(d!==n.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);if(h!==n.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`)}if(x/2!==i.dims[1]&&u/2!==i.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${i.dims[1]}`);if(h>y)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},Qc=(e,t)=>{let{interleaved:r,numHeads:n,rotaryEmbeddingDim:i,scale:s}=t,o=e[0].dims[0],u=De.sizeFromDimension(e[0].dims,1),d=e[0].dims[e[0].dims.length-2],h=u/d,y=e[2].dims[1],l=i===0?y*2:h/n,x=new Array(o,d,h/l,l-y),A=De.computeStrides(x),P=[{type:1,data:s},{type:12,data:x},{type:12,data:A},...e[0].dims.length===3?new Array({type:12,data:[u,h,l,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[u,l,d*l,1]}):[],...Ot(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],S=Q=>{let Y=ht("input",e[0].dataType,e[0].dims.length),D=ht("position_ids",e[1].dataType,e[1].dims.length),ne=ht("cos_cache",e[2].dataType,e[2].dims.length),he=ht("sin_cache",e[3].dataType,e[3].dims.length),be=Kt("output",e[0].dataType,e[0].dims.length);return Q.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:x.length},{name:"global_strides",type:"u32",length:A.length},{name:"input_output_strides",type:"u32",length:A.length}]),`
        ${Q.declareVariables(Y,D,ne,he,be)}

        ${Q.mainStart(pn)}
          let half_rotary_emb_dim = uniforms.${ne.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${Q.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${D.broadcastedIndicesToOffset("bsnh.xy",Kt("",D.type.tensor,2))};
            let position_id =
                u32(${D.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});
            let j = i + select(half_rotary_emb_dim, 1, ${r});
            let re = ${Y.getByOffset("i")} * ${ne.get("position_id","bsnh[3]")} -
                ${Y.getByOffset("j")} * ${he.get("position_id","bsnh[3]")};
            ${be.setByOffset("i","re")}
            let im = ${Y.getByOffset("i")} * ${he.get("position_id","bsnh[3]")} +
                ${Y.getByOffset("j")} * ${ne.get("position_id","bsnh[3]")};
            ${be.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${be.setByOffset("k",Y.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:hr({interleaved:r}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:S,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(De.size(x)/pn)},programUniforms:P})}},Bn=(e,t)=>{Hi(e.inputs,t),e.compute(Qc(e.inputs,t))}}),_c,wc,yc,bc=j(()=>{rr(),Jt(),fr(),_c=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],n=e[2];if(t.dataType!==r.dataType||t.dataType!==n.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let i=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==i)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(n.dims.length!==1)throw new Error("Gamma must be 1D");if(n.dims[n.dims.length-1]!==i)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let o=e[3];if(o.dims.length!==1)throw new Error("Beta must be 1D");if(o.dims[o.dims.length-1]!==i)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let o=e[4];if(o.dims.length!==1)throw new Error("Bias must be 1D");if(o.dims[o.dims.length-1]!==i)throw new Error("Bias must have the same hidden size as input")}},wc=(e,t,r,n)=>{let i=t.simplified,s=e[0].dims,o=De.size(s),u=s,d=o,h=s.slice(-1)[0],y=n?s.slice(0,-1).concat(1):[],l=!i&&e.length>3,x=e.length>4,A=n&&r>1,P=n&&r>2,S=r>3,Q=64,Y=br(h),D=[{type:12,data:d},{type:12,data:Y},{type:12,data:h},{type:1,data:t.epsilon}],ne=be=>{let Ye=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],ze=[ht("x",e[0].dataType,e[0].dims,Y),ht("skip",e[1].dataType,e[1].dims,Y),ht("gamma",e[2].dataType,e[2].dims,Y)];l&&ze.push(ht("beta",e[3].dataType,e[3].dims,Y)),x&&ze.push(ht("bias",e[4].dataType,e[4].dims,Y)),ze.push(Kt("output",e[0].dataType,u,Y)),A&&ze.push(Kt("mean_output",1,y)),P&&ze.push(Kt("inv_std_output",1,y)),S&&ze.push(Kt("input_skip_bias_sum",e[0].dataType,u,Y));let Mt=_r(e[0].dataType),Vt=_r(1,Y);return`

      ${be.registerUniforms(Ye).declareVariables(...ze)}
      var<workgroup> sum_shared : array<${Vt}, ${Q}>;
      var<workgroup> sum_squared_shared : array<${Vt}, ${Q}>;

      ${be.mainStart([Q,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${Q};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${Q};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${Q-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${x?"bias[offset1d + i]":Mt+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${S?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Qn(Mt,Y,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${Q};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${Nn("sum",Y)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${Nn("square_sum",Y)} / f32(uniforms.hidden_size) ${i?"":"- mean * mean"} + uniforms.epsilon);
        ${A?"mean_output[global_idx] = mean;":""}
        ${P?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${i?"":`- ${Mt}(mean)`}) *
            ${Mt}(inv_std_dev) * gamma[offset1d + i]
            ${l?"+ beta[offset1d + i]":""};
        }
      }`},he=[{dims:u,dataType:e[0].dataType}];return r>1&&he.push({dims:y,dataType:1}),r>2&&he.push({dims:y,dataType:1}),r>3&&he.push({dims:s,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${Y};${A};${P};${S}`,inputDependencies:e.map((be,Ye)=>"type")},getShaderSource:ne,getRunData:()=>({outputs:he,dispatchGroup:{x:Math.ceil(d/h)},programUniforms:D})}},yc=(e,t)=>{_c(e.inputs);let r=[0];e.outputCount>1&&r.push(-3),e.outputCount>2&&r.push(-3),e.outputCount>3&&r.push(3),e.compute(wc(e.inputs,t,e.outputCount,!1),{outputs:r})}}),Yp,fd,Qp,Zc,Zp,Jp,eh,th,km=j(()=>{rr(),Jt(),kr(),fr(),Yp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,n)=>{if(e[n+1].dataType!==6&&e[n+1].dataType!==7)throw new Error(`Input ${n} must be an array of int32 or int64`)})},fd=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(n=>r.push(Number(n)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(n=>r.push(Number(n)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Qp=(e,t)=>{if(e.length>1){let r=fd(e,1),n=fd(e,2),i=fd(e,3);return i.length===0&&(i=[...Array(e[0].dims.length).keys()]),hr({starts:r,ends:n,axes:i})}else return t},Zc=(e,t,r,n,i)=>{let s=e;return e<0&&(s+=r[n[t]]),i[t]<0?Math.max(0,Math.min(s,r[n[t]]-1)):Math.max(0,Math.min(s,r[n[t]]))},Zp=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {
          var input_indices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            let input_shape_i = ${qt("uniforms.input_shape","i",r.length)};
            let steps_i = ${qt("uniforms.steps","i",r.length)};
            let signs_i = ${qt("uniforms.signs","i",r.length)};
            let starts_i = ${qt("uniforms.starts","i",r.length)};
            var output_index = ${t.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${e.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,Jp=(e,t)=>{let r=e[0].dims,n=De.size(r),i=t.axes.length>0?De.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=fd(e,4);s.forEach(Y=>Y!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(i.length).fill(1));let o=t.starts.map((Y,D)=>Zc(Y,D,r,i,s)),u=t.ends.map((Y,D)=>Zc(Y,D,r,i,s));if(i.length!==o.length||i.length!==u.length)throw new Error("start, ends and axes should have the same number of elements");if(i.length!==r.length)for(let Y=0;Y<r.length;++Y)i.includes(Y)||(o.splice(Y,0,0),u.splice(Y,0,r[Y]),s.splice(Y,0,1));let d=s.map(Y=>Math.sign(Y));s.forEach((Y,D,ne)=>{if(Y<0){let he=(u[D]-o[D])/Y,be=o[D],Ye=be+he*s[D];o[D]=Ye,u[D]=be,ne[D]=-Y}});let h=r.slice(0);i.forEach((Y,D)=>{h[Y]=Math.ceil((u[Y]-o[Y])/s[Y])});let y={dims:h,dataType:e[0].dataType},l=Kt("output",e[0].dataType,h.length),x=ht("input",e[0].dataType,e[0].dims.length),A=De.size(h),P=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:d.length},{name:"steps",type:"u32",length:s.length}],S=[{type:12,data:A},{type:12,data:o},{type:6,data:d},{type:12,data:s},...Ot(e[0].dims,h)],Q=Y=>`
      ${Y.registerUniforms(P).declareVariables(x,l)}
        ${Zp(x,l,r)}
        ${Y.mainStart()}
          ${Y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${l.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${l.setByOffset("global_idx",x.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${d.length}_${o.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:Q,getRunData:()=>({outputs:[y],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:S})}},eh=(e,t)=>{Yp(e.inputs,t);let r=Qp(e.inputs,t);e.compute(Jp(e.inputs,r),{inputs:[0]})},th=e=>{let t=e.starts,r=e.ends,n=e.axes;return hr({starts:t,ends:r,axes:n})}}),rh,nh,ih,sh,Pm=j(()=>{rr(),Jt(),kr(),jn(),fr(),rh=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},nh=(e,t)=>{let r=e.inputs[0],n=r.dims,i=De.size(n),s=64,o=n.length,u=De.normalizeAxis(t.axis,o),d=u<n.length-1,h,y=[];d?(y=Array.from({length:o},(ze,Mt)=>Mt),y[u]=o-1,y[o-1]=u,h=e.compute(Mn(r,y),{inputs:[r],outputs:[-1]})[0]):h=r;let l=h.dims,x=l[o-1],A=i/x,P=br(x),S=x/P,Q=(ze,Mt)=>Mt===4?`max(max(${ze}.x, ${ze}.y), max(${ze}.z, ${ze}.w))`:Mt===2?`max(${ze}.x, ${ze}.y)`:Mt===3?`max(max(${ze}.x, ${ze}.y), ${ze}.z)`:ze,Y=ht("x",h.dataType,h.dims,P),D=Kt("result",h.dataType,h.dims,P),ne=Y.type.value,he=_r(h.dataType)==="f32"?`var threadMax = ${ne}(-3.402823e+38f);`:`var threadMax = ${ne}(-65504.0h);`,be=ze=>`
      var<workgroup> rowMaxShared : ${ne};
      var<workgroup> rowSumShared : ${ne};
      var<workgroup> threadShared : array<${ne}, ${s}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${ne} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${ne}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${ze.registerUniform("packedCols","i32").declareVariables(Y,D)}
      ${ze.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${s};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${he}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${ne}(${Q("threadShared[0]",P)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${ne}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${ne}(${Nn("threadShared[0]",P)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,Ye=e.compute({name:"Softmax",shaderCache:{hint:`${P}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:l,dataType:h.dataType}],dispatchGroup:{x:A},programUniforms:[{type:6,data:S}]}),getShaderSource:be},{inputs:[h],outputs:[d?-1:0]})[0];d&&e.compute(Mn(Ye,y),{inputs:[Ye]})},ih=(e,t)=>{rh(e.inputs),nh(e,t)},sh=e=>hr({axis:e.axis})}),Jc,oh,ah,lh,uh,Am=j(()=>{rr(),Jt(),fr(),Jc=e=>Array.from(e.getBigInt64Array(),Number),oh=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Jc(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ah=(e,t)=>{let r=[];for(let n=0;n<e.length;++n)r.push(e[n]*t[n]);return r},lh=(e,t)=>{let r=e[0].dims,n=t??Jc(e[1]),i=ah(r,n),s=De.size(i),o=e[0].dataType,u=ht("input",o,r.length),d=Kt("output",o,i.length),h=y=>`
      const inputShape = ${u.indices(...r)};
      ${y.registerUniform("output_size","u32").declareVariables(u,d)}
      ${y.mainStart()}
      ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${d.offsetToIndices("global_idx")};
      var input_indices: ${u.type.indices};
      for (var i = 0; i < ${r.length}; i++) {
        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${d.indicesGet("output_indices","i")}  % input_dim_i;

        ${u.indicesSet("input_indices","i","input_dim_value")}
      }
      ${d.setByOffset("global_idx",u.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},...Ot(e[0].dims,i)]}),getShaderSource:h}},uh=e=>{oh(e.inputs),e.compute(lh(e.inputs),{inputs:[0]})}}),dh,ch,ph,Im=j(()=>{rr(),Jt(),fr(),dh=(e,t,r,n,i)=>{let s=Kt("output_data",i,r.length,4),o=ht("a_data",t[1].dataType,t[1].dims.length,4),u=ht("b_data",t[2].dataType,t[2].dims.length,4),d=ht("c_data",t[0].dataType,t[0].dims.length,4),h,y=(l,x,A)=>`select(${x}, ${l}, ${A})`;if(!n)h=s.setByOffset("global_idx",y(o.getByOffset("global_idx"),u.getByOffset("global_idx"),d.getByOffset("global_idx")));else{let l=(x,A,P="")=>{let S=`a_data[index_a${A}][component_a${A}]`,Q=`b_data[index_b${A}][component_b${A}]`,Y=`bool(c_data[index_c${A}] & (0xffu << (component_c${A} * 8)))`;return`
            let output_indices${A} = ${s.offsetToIndices(`global_idx * 4u + ${A}u`)};
            let offset_a${A} = ${o.broadcastedIndicesToOffset(`output_indices${A}`,s)};
            let offset_b${A} = ${u.broadcastedIndicesToOffset(`output_indices${A}`,s)};
            let offset_c${A} = ${d.broadcastedIndicesToOffset(`output_indices${A}`,s)};
            let index_a${A} = offset_a${A} / 4u;
            let index_b${A} = offset_b${A} / 4u;
            let index_c${A} = offset_c${A} / 4u;
            let component_a${A} = offset_a${A} % 4u;
            let component_b${A} = offset_b${A} % 4u;
            let component_c${A} = offset_c${A} % 4u;
            ${x}[${A}] = ${P}(${y(S,Q,Y)});
          `};i===9?h=`
            var data = vec4<u32>(0);
            ${l("data",0,"u32")}
            ${l("data",1,"u32")}
            ${l("data",2,"u32")}
            ${l("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:h=`
            ${l("output_data[global_idx]",0)}
            ${l("output_data[global_idx]",1)}
            ${l("output_data[global_idx]",2)}
            ${l("output_data[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(d,o,u,s)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${h}
      }`},ch=e=>{let t=e[1].dims,r=e[2].dims,n=e[0].dims,i=e[1].dataType,s=!(De.areEqual(t,r)&&De.areEqual(r,n)),o=t,u=De.size(t);if(s){let h=Sn.calcShape(Sn.calcShape(t,r,!1),n,!1);if(!h)throw new Error("Can't perform where op on the given tensors");o=h,u=De.size(o)}let d=Math.ceil(u/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:h=>dh(h,e,o,s,i),getRunData:()=>({outputs:[{dims:o,dataType:i}],dispatchGroup:{x:Math.ceil(u/64/4)},programUniforms:[{type:12,data:d},...Ot(n,t,r,o)]})}},ph=e=>{e.compute(ch(e.inputs))}}),hh,Fm=j(()=>{Ua(),as(),Sd(),Ja(),Pl(),kd(),Pd(),Od(),Fo(),Ld(),vu(),zo(),Nd(),jd(),Au(),Wd(),Gd(),Kc(),Kd(),Xd(),Yd(),ru(),Xc(),Ko(),Yc(),_n(),_(),Je(),Gs(),Jo(),Ki(),bc(),km(),Pm(),qu(),Am(),jn(),uo(),Im(),hh=new Map([["Abs",[Zs]],["Acos",[tl]],["Acosh",[rl]],["Add",[Fl]],["ArgMax",[ja,Ks]],["ArgMin",[Hs,Ks]],["Asin",[nl]],["Asinh",[il]],["Atan",[Js]],["Atanh",[sl]],["Attention",[Ha]],["AveragePool",[hc,pc]],["BatchNormalization",[Ya]],["BiasAdd",[Za]],["BiasSplitGelu",[kl]],["Cast",[al,ol]],["Ceil",[ul]],["Clip",[eo]],["Concat",[Vl,Wl]],["Conv",[ko,$o]],["ConvTranspose",[mu,Ti]],["Cos",[dl]],["Cosh",[cl]],["CumSum",[gu,_u]],["DepthToSpace",[bu,Mu]],["DequantizeLinear",[pd,hd]],["Div",[Ol]],["Einsum",[$u,Do]],["Elu",[to,Ri]],["Equal",[po]],["Erf",[pl]],["Exp",[ro]],["Expand",[ku]],["FastGelu",[Pu]],["Floor",[hl]],["FusedConv",[ko,$o]],["Gather",[Uo,Vd]],["GatherElements",[Go,Du]],["GatherBlockQuantized",[Vo,Ou]],["Gelu",[fl]],["Gemm",[Lr,Ru]],["GlobalAveragePool",[mc,fc]],["GlobalMaxPool",[un,nn]],["Greater",[zl]],["GreaterOrEqual",[fo]],["GroupQueryAttention",[Xu]],["HardSigmoid",[yl,so]],["InstanceNormalization",[Zu]],["LayerNormalization",[td]],["LeakyRelu",[no,Ri]],["Less",[Ll]],["LessOrEqual",[Rl]],["Log",[El]],["MatMul",[Co]],["MatMulNBits",[Jd,ec]],["MaxPool",[cr,cd]],["Mul",[Bl]],["MultiHeadAttention",[ju,qo]],["Neg",[gl]],["Not",[ml]],["Pad",[uc]],["Pow",[Dl]],["QuickGelu",[$l,Ri]],["Range",[qe]],["Reciprocal",[io]],["ReduceMin",[La]],["ReduceMean",[js]],["ReduceMax",[za]],["ReduceSum",[Ra]],["ReduceProd",[Vs]],["ReduceL1",[Ba]],["ReduceL2",[Da]],["ReduceLogSum",[Ws]],["ReduceLogSumExp",[Us]],["ReduceSumSquare",[Na]],["Relu",[_l]],["Resize",[en,on]],["RotaryEmbedding",[Bn]],["Sigmoid",[wl]],["Sin",[bl]],["Sinh",[us]],["Slice",[eh,th]],["SkipLayerNormalization",[yc]],["Split",[Hd,Gu]],["Sqrt",[Ml]],["Softmax",[ih,sh]],["Sub",[ho]],["Tan",[vl]],["Tanh",[oo]],["ThresholdedRelu",[Tl,Ri]],["Tile",[uh]],["Transpose",[Cd,ha]],["Where",[ph]]])}),fh,Om=j(()=>{c(),g(),fr(),fh=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,r,n,i){rt(e.programInfo.name);let s=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let u=[];for(let h of t)u.push({binding:u.length,resource:{buffer:h.buffer}});for(let h of r)u.push({binding:u.length,resource:{buffer:h.buffer}});i&&u.push({binding:u.length,resource:i});let d=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:u,label:e.programInfo.name});if(this.backend.sessionStatus==="capturing"){let h={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:d,dispatchGroup:n};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(h)}o.setPipeline(e.computePipeline),o.setBindGroup(0,d),o.dispatchWorkgroups(...n),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Qe(e.programInfo.name)}dispose(){}build(e,t){rt(e.name);let r=this.backend.device,n=[];r.features.has("shader-f16")&&n.push("enable f16;");let i=da(t,this.backend.device.limits),s=e.getShaderSource(i),o=`${n.join(`
`)}
${i.additionalImplementations}
${s}`,u=r.createShaderModule({code:o,label:e.name});ye("verbose",()=>`[WebGPU] ${e.name} shader code: ${o}`);let d=r.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto",label:e.name});return Qe(e.name),{programInfo:e,computePipeline:d,uniformVariablesInfo:i.variablesInfo}}normalizeDispatchGroupSize(e){let t=typeof e=="number"?e:e.x,r=typeof e=="number"?1:e.y||1,n=typeof e=="number"?1:e.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=i&&r<=i&&n<=i)return[t,r,n];let s=t*r*n,o=Math.ceil(Math.sqrt(s));if(o>i){if(o=Math.ceil(Math.cbrt(s)),o>i)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}}),mh,gh,_h,wh,Bm=j(()=>{c(),rr(),g(),ce(),Xr(),Fm(),Om(),mh=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let n=0;n<e.length;++n){let i=e[n].dataType;switch(t[n]){case"none":{r.push("");break}case"type":{r.push(`${i}`);break}case"rank":{let s=e[n].dims.length;r.push(`${i};${s}`);break}case"dims":{let s=e[n].dims.join(",");r.push(`${i};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[n]}`)}}return r.join("|")},gh=(e,t,r)=>{let n=e.name;return e.shaderCache?.hint&&(n+="["+e.shaderCache.hint+"]"),n+=":"+r+`:${mh(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,n},_h=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},wh=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let r=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:r};t.features.has("chromium-experimental-timestamp-query-inside-passes")?r.push("chromium-experimental-timestamp-query-inside-passes"):t.features.has("timestamp-query")&&r.push("timestamp-query"),t.features.has("shader-f16")&&r.push("shader-f16"),this.device=await t.requestDevice(n),this.adapterInfo=new _h(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Cr(this),this.programManager=new fh(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,ni(e.logLevel,!!e.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};this.queryType==="at-passes"&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;rt(),this.endComputePass();let e;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),e=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&e.mapAsync(GPUMapMode.READ).then(()=>{let t=new BigUint64Array(e.getMappedRange()),r=this.pendingQueries.get(e);for(let n=0;n<t.length/2;n++){let i=r[n],s=i.kernelId,o=this.kernels.get(s),u=o.kernelType,d=o.kernelName,h=i.programName,y=i.inputTensorViews,l=i.outputTensorViews,x=t[n*2],A=t[n*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=x);let P=Number(x-this.queryTimeBase),S=Number(A-this.queryTimeBase);if(!Number.isSafeInteger(P)||!Number.isSafeInteger(S))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:y.map(Q=>({dims:Q.dims,dataType:$n(Q.dataType)})),outputsMetadata:l.map(Q=>({dims:Q.dims,dataType:$n(Q.dataType)})),kernelId:s,kernelType:u,kernelName:d,programName:h,startTime:P,endTime:S});else{let Q="";y.forEach((D,ne)=>{Q+=`input[${ne}]: [${D.dims}] | ${$n(D.dataType)}, `});let Y="";l.forEach((D,ne)=>{Y+=`output[${ne}]: [${D.dims}] | ${$n(D.dataType)}, `}),console.log(`[profiling] kernel "${s}|${u}|${d}|${h}" ${Q}${Y}execution time: ${S-P} ns`)}st("GPU",`${h}::${x}::${A}`)}e.unmap(),this.pendingQueries.delete(e)}),Qe()}run(e,t,r,n,i,s){rt(e.name);let o=[];for(let D=0;D<t.length;++D){let ne=t[D].data;if(ne===0)continue;let he=this.gpuDataManager.get(ne);if(!he)throw new Error(`no GPU data for input: ${ne}`);o.push(he)}let{outputs:u,dispatchGroup:d,programUniforms:h}=e.getRunData(t),y=r.length===0?u.map((D,ne)=>ne):r;if(y.length!==u.length)throw new Error(`Output size ${y.length} must be equal to ${u.length}.`);let l=[],x=[];for(let D=0;D<u.length;++D){if(!Number.isInteger(y[D])||y[D]<-3||y[D]>=s)throw new Error(`Invalid output index: ${y[D]}`);if(y[D]===-3)continue;let ne=y[D]===-1,he=y[D]===-2,be=ne||he?i(u[D].dataType,u[D].dims):n(y[D],u[D].dataType,u[D].dims);if(l.push(be),be.data===0)continue;let Ye=this.gpuDataManager.get(be.data);if(!Ye)throw new Error(`no GPU data for output: ${be.data}`);if(ne&&this.temporaryData.push(Ye),he){let ze=this.kernelPersistentData.get(this.currentKernelId);ze||(ze=[],this.kernelPersistentData.set(this.currentKernelId,ze)),ze.push(Ye)}x.push(Ye)}if(o.length!==t.length||x.length!==l.length){if(x.length===0)return Qe(e.name),l;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let A;if(h){let D=0,ne=[];h.forEach(ze=>{let Mt=typeof ze.data=="number"?[ze.data]:ze.data;if(Mt.length===0)return;let Vt=ze.type===10?2:4,jt,lr;ze.type===10?(lr=Mt.length>4?16:Mt.length>2?8:Mt.length*Vt,jt=Mt.length>4?16:Vt*Mt.length):(lr=Mt.length<=2?Mt.length*Vt:16,jt=16),D=Math.ceil(D/lr)*lr,ne.push(D);let Zt=ze.type===10?8:4;D+=Mt.length>4?Math.ceil(Mt.length/Zt)*jt:Mt.length*Vt});let he=16;D=Math.ceil(D/he)*he;let be=new ArrayBuffer(D);h.forEach((ze,Mt)=>{let Vt=ne[Mt],jt=typeof ze.data=="number"?[ze.data]:ze.data;if(ze.type===6)new Int32Array(be,Vt,jt.length).set(jt);else if(ze.type===12)new Uint32Array(be,Vt,jt.length).set(jt);else if(ze.type===10)new Uint16Array(be,Vt,jt.length).set(jt);else if(ze.type===1)new Float32Array(be,Vt,jt.length).set(jt);else throw new Error(`Unsupported uniform type: ${$n(ze.type)}`)});let Ye=this.gpuDataManager.create(D,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(Ye.buffer,0,be,0,D),this.gpuDataManager.release(Ye.id),A={offset:0,size:D,buffer:Ye.buffer}}let P=this.programManager.normalizeDispatchGroupSize(d),S=P[1]===1&&P[2]===1,Q=gh(e,t,S),Y=this.programManager.getArtifact(Q);if(Y||(Y=this.programManager.build(e,P),this.programManager.setArtifact(Q,Y),ye("info",()=>`[artifact] key: ${Q}, programName: ${e.name}`)),h&&Y.uniformVariablesInfo){if(h.length!==Y.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${Y.uniformVariablesInfo.length}, got ${h.length} in program "${Y.programInfo.name}".`);for(let D=0;D<h.length;D++){let ne=h[D],he=ne.type,be=typeof ne.data=="number"?1:ne.data.length,[Ye,ze]=Y.uniformVariablesInfo[D];if(he!==Ye||be!==ze)throw new Error(`Uniform variable ${D} mismatch: expect type ${Ye} with size ${ze}, got type ${he} with size ${be} in program "${Y.programInfo.name}".`)}}if(ye("info",()=>`[ProgramManager] run "${e.name}" (key=${Q}) with ${P[0]}x${P[1]}x${P[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let D={kernelId:this.currentKernelId,programName:Y.programInfo.name,inputTensorViews:t,outputTensorViews:l};this.pendingKernels.push(D),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(D)}return this.programManager.run(Y,o,x,P,A),Qe(e.name),l}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,r,n){let i=hh.get(e);if(!i)throw new Error(`kernel not implemented: ${e}`);let s={kernelType:e,kernelName:n,kernelEntry:i[0],attributes:[i[1],r]};this.kernels.set(t,s)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let r of t)this.gpuDataManager.release(r.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,r){let n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);let i=n.kernelType,s=n.kernelName,o=n.kernelEntry,u=n.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${i}] ${s}" is not allowed to be called recursively`);this.currentKernelId=e,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),ye("info",()=>`[WebGPU] Start to run kernel "[${i}] ${s}"...`);let d=this.env.debug;this.temporaryData=[];try{return d&&this.device.pushErrorScope("validation"),o(t,u[1]),0}catch(h){return r.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${s}" failed. ${h}`)),1}finally{d&&r.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${i}] ${s}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,r,n){let i=this.sessionExternalDataMapping.get(e);i||(i=new Map,this.sessionExternalDataMapping.set(e,i));let s=i.get(t),o=this.gpuDataManager.registerExternalBuffer(r,n,s);return i.set(t,[o,r]),o}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(r=>this.gpuDataManager.unregisterExternalBuffer(r[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,r){return async()=>{let n=await gr(this,e,t);return G(n.buffer,r)}}writeTimestamp(e){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){ye("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){ye("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){ye("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),r=e.length;this.pendingKernels=[];for(let n=0;n<r;n++){let i=this.getComputePassEncoder(),s=e[n];this.writeTimestamp(this.pendingDispatchNumber*2),i.setPipeline(s.computePipeline),i.setBindGroup(0,s.bindGroup),i.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(t[n]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),yh,ep,tp,rp,bh,Mh,Dm=j(()=>{g(),yh=1,ep=()=>yh++,tp=class{constructor(e){this.sessionId=e.sessionId,this.mlContext=e.context,this.mlTensor=e.tensor,this.dataType=e.dataType,this.tensorShape=e.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}destroy(){ye("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}sameTypeAndShape(e,t){return this.dataType===e&&this.tensorShape.every((r,n)=>r===t[n])}},rp=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&this.tensorManager.releaseTensor(this.tensorWrapper)}async ensureTensor(e,t,r){if(this.wrapper){if(this.wrapper.sameTypeAndShape(e,t))return this.wrapper.tensor;r&&(this.activeUpload=new Uint8Array(await this.wrapper.read())),this.tensorManager.releaseTensor(this.wrapper)}let n=MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,n,!0,!0),r&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){if(this.wrapper){this.wrapper.write(e);return}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(e){if(this.activeUpload)if(e){e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},bh=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}reserveTensorId(){let e=ep();return this.tensorTrackersById.set(e,new rp(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,r,n){ye("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${r}, copyOld: ${n}}`);let i=this.tensorTrackersById.get(e);if(!i)throw new Error("Tensor not found.");return i.ensureTensor(t,r,n)}upload(e,t){let r=this.tensorTrackersById.get(e);if(!r)throw new Error("Tensor not found.");r.upload(t)}async download(e,t){ye("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`);let r=this.tensorTrackersById.get(e);if(!r)throw new Error("Tensor not found.");return r.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,r,n){let i=ep(),s=new tp({sessionId:this.backend.currentSessionId,context:e,tensor:t,dataType:r,shape:n});return this.tensorTrackersById.set(i,new rp(this,s)),this.externalTensors.add(s),i}async getCachedTensor(e,t,r,n,i){let s=this.backend.currentSessionId;for(let[d,h]of this.freeTensors.entries())if(h.sameTypeAndShape(e,t)){let y=this.freeTensors.splice(d,1)[0];return y.sessionId=s,y}let o=this.backend.currentContext;ye("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`);let u=await o.createTensor({dataType:e,shape:t,dimensions:t,usage:r,writable:n,readable:i});return new tp({sessionId:s,context:o,tensor:u,dataType:e,shape:t})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},Mh=(...e)=>new bh(...e)}),np,vh,zm=j(()=>{rr(),zr(),ce(),Dm(),g(),np=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),vh=class{constructor(e){this.tensorManager=Mh(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,ni(e.logLevel,!!e.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(e){this.activeSessionId=e}get currentContext(){let e=this.getMLContext(this.currentSessionId);if(!e)throw new Error(`No MLContext found for session ${this.currentSessionId}`);return e}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let r=this.sessionIdsByMLContext.get(t);r||(r=new Set,this.sessionIdsByMLContext.set(t,r)),r.add(e)}onReleaseSession(e){let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let r=this.sessionIdsByMLContext.get(t);r.delete(e),r.size===0&&this.sessionIdsByMLContext.delete(t)}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){ye("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,r,n){let i=np.get(t);if(!i)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(e,i,r,n)}uploadTensor(e,t){if(!Er().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");ye("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let r=await this.tensorManager.download(e);return G(r,t)}}registerMLTensor(e,t,r){let n=np.get(t);if(!n)throw new Error(`Unsupported ONNX data type: ${t}`);let i=this.tensorManager.registerTensor(this.currentContext,e,n,r);return ye("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${n}, dimensions: ${r}} -> {tensorId: ${i}}`),i}registerMLConstant(e,t,r,n,i,s){if(!s)throw new Error("External mounted files are not available.");let o=e;e.startsWith("./")&&(o=e.substring(2));let u=s.get(o);if(!u)throw new Error(`File with name ${o} not found in preloaded files.`);if(t+r>u.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let d=u.slice(t,t+r).buffer,h;switch(i.dataType){case"float32":h=new Float32Array(d);break;case"float16":h=new Uint16Array(d);break;case"int32":h=new Int32Array(d);break;case"uint32":h=new Uint32Array(d);break;case"int64":h=new BigInt64Array(d);break;case"uint64":h=new BigUint64Array(d);break;case"int8":h=new Int8Array(d);break;case"uint8":h=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`)}return ye("verbose",()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`),n.constant(i,h)}flush(){}}}),xh={};O(xh,{init:()=>Eh});var Mc,Th,Eh,Lm=j(()=>{rr(),Bm(),g(),Jt(),zm(),Mc=class Cm{constructor(t,r,n,i){this.module=t,this.dataType=r,this.data=n,this.dims=i}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=De.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=De.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=De.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let t=De.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(De.size(t)!==De.size(this.dims))throw new Error("Invalid new shape");return new Cm(this.module,this.dataType,this.data,t)}},Th=class{constructor(e,t,r){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let n=e.HEAPU32,i=r>>>2;this.opKernelContext=n[i++];let s=n[i++];this.outputCount=n[i++],this.customDataOffset=n[i++],this.customDataSize=n[i++];let o=[];for(let u=0;u<s;u++){let d=n[i++],h=n[i++],y=n[i++],l=[];for(let x=0;x<y;x++)l.push(n[i++]);o.push(new Mc(e,d,h,l))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}getMaxComputeWorkgroupSizes(){return[this.backend.device.limits.maxComputeWorkgroupSizeX,this.backend.device.limits.maxComputeWorkgroupSizeY,this.backend.device.limits.maxComputeWorkgroupSizeZ]}getMaxComputeWorkgroupStoragesize(){return this.backend.device.limits.maxComputeWorkgroupStorageSize}compute(e,t){let r=t?.inputs?.map(o=>typeof o=="number"?this.inputs[o]:o)??this.inputs,n=t?.outputs??[],i=(o,u,d)=>new Mc(this.module,u,this.output(o,d),d),s=(o,u)=>{let d=Ln(o,u);if(!d)throw new Error(`Unsupported data type: ${o}`);let h=d>0?this.backend.gpuDataManager.create(d).id:0;return new Mc(this.module,o,h,u)};return this.backend.run(e,r,n,i,s,this.outputCount)}output(e,t){let r=this.module.stackSave();try{let n=this.module.stackAlloc((1+t.length)*4),i=n>>2;this.module.HEAPU32[i++]=t.length;for(let s=0;s<t.length;s++)this.module.HEAPU32[i++]=t[s];return this.module._JsepOutput(this.opKernelContext,e,n)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(r)}}},Eh=async(e,t,r,n)=>{let i=t.jsepInit;if(!i)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(e==="webgpu"){let s=new wh;await s.initialize(r,n),i("webgpu",[s,o=>s.alloc(o),o=>s.free(o),(o,u,d,h=!1)=>{if(h)ye("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${o}, dst=${u}, size=${d}`),s.memcpy(o,u);else{ye("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${o}, gpuDataId=${u}, size=${d}`);let y=t.HEAPU8.subarray(o>>>0,(o>>>0)+d);s.upload(u,y)}},async(o,u,d)=>{ye("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${u}, size=${d}`),await s.download(o,()=>t.HEAPU8.subarray(u>>>0,(u>>>0)+d))},(o,u,d)=>s.createKernel(o,u,d,t.UTF8ToString(t._JsepGetNodeName(u))),o=>s.releaseKernel(o),(o,u,d,h)=>{ye("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${d}, kernel=${o}, contextDataOffset=${u}`);let y=new Th(t,s,u);return s.computeKernel(o,y,h)},()=>s.captureBegin(),()=>s.captureEnd(),()=>s.replay()])}else{let s=new vh(r);i("webnn",[s,()=>s.reserveTensorId(),o=>s.releaseTensorId(o),async(o,u,d,h)=>s.ensureTensor(o,u,d,h),(o,u)=>{s.uploadTensor(o,u)},async(o,u)=>s.downloadTensor(o,u)])}}}),Ch,ip,sp,Xi,$h,vc,op,ap,lp,up,dp,cp,Sh=j(()=>{Xn(),ti(),rr(),zr(),mi(),Bi(),Ch=(e,t)=>{Er()._OrtInit(e,t)!==0&&Nr("Can't initialize onnxruntime.")},ip=async e=>{Ch(e.wasm.numThreads,On(e.logLevel))},sp=async(e,t)=>{{let r=(Lm(),N(xh)).init;if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let n=e.webgpu.adapter;if(n){if(typeof n.limits!="object"||typeof n.features!="object"||typeof n.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let i=e.webgpu.powerPreference;if(i!==void 0&&i!=="low-power"&&i!=="high-performance")throw new Error(`Invalid powerPreference setting: "${i}"`);let s=e.webgpu.forceFallbackAdapter;if(s!==void 0&&typeof s!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${s}"`);if(n=await navigator.gpu.requestAdapter({powerPreference:i,forceFallbackAdapter:s}),!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await r("webgpu",Er(),e,n)}if(t==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",Er(),e)}}},Xi=new Map,$h=e=>{let t=Er(),r=t.stackSave();try{let n=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,n,n+4)!==0&&Nr("Can't get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(r)}},vc=e=>{let t=Er(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},op=async(e,t)=>{let r,n,i=Er();Array.isArray(e)?[r,n]=e:e.buffer===i.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=vc(e);let s=0,o=0,u=0,d=[],h=[],y=[];try{if([o,d]=Oi(t),t?.externalData&&i.mountExternalData){let D=[];for(let ne of t.externalData){let he=typeof ne=="string"?ne:ne.path;D.push(ri(typeof ne=="string"?ne:ne.data).then(be=>{i.mountExternalData(he,be)}))}await Promise.all(D)}for(let D of t?.executionProviders??[])if((typeof D=="string"?D:D.name)==="webnn"){if(i.shouldTransferToMLTensor=!1,i.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof D!="string"){let ne=D,he=ne?.context,be=ne?.gpuDevice,Ye=ne?.deviceType,ze=ne?.powerPreference;he?i.currentContext=he:be?i.currentContext=await navigator.ml.createContext(be):i.currentContext=await navigator.ml.createContext({deviceType:Ye,powerPreference:ze})}else i.currentContext=await navigator.ml.createContext();break}s=await i._OrtCreateSession(r,n,o),s===0&&Nr("Can't create a session."),i.jsepOnCreateSession?.(),i.currentContext&&(i.jsepRegisterMLContext(s,i.currentContext),i.currentContext=void 0,i.shouldTransferToMLTensor=!0);let[l,x]=$h(s),A=!!t?.enableGraphCapture,P=[],S=[],Q=[];for(let D=0;D<l;D++){let ne=i._OrtGetInputName(s,D);ne===0&&Nr("Can't get an input name."),h.push(ne),P.push(i.UTF8ToString(ne))}for(let D=0;D<x;D++){let ne=i._OrtGetOutputName(s,D);ne===0&&Nr("Can't get an output name."),y.push(ne);let he=i.UTF8ToString(ne);S.push(he);{if(A&&t?.preferredOutputLocation===void 0){Q.push("gpu-buffer");continue}let be=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[he]??"cpu";if(be!=="cpu"&&be!=="cpu-pinned"&&be!=="gpu-buffer"&&be!=="ml-tensor")throw new Error(`Not supported preferred output location: ${be}.`);if(A&&be!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${be}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);Q.push(be)}}let Y=null;return Q.some(D=>D==="gpu-buffer"||D==="ml-tensor")&&(u=i._OrtCreateBinding(s),u===0&&Nr("Can't create IO binding."),Y={handle:u,outputPreferredLocations:Q,outputPreferredLocationsEncoded:Q.map(D=>yi(D))}),Xi.set(s,[s,h,y,Y,A,!1]),[s,P,S]}catch(l){throw h.forEach(x=>i._OrtFree(x)),y.forEach(x=>i._OrtFree(x)),u!==0&&i._OrtReleaseBinding(u),s!==0&&i._OrtReleaseSession(s),l}finally{i._free(r),o!==0&&i._OrtReleaseSessionOptions(o),d.forEach(l=>i._free(l)),i.unmountExternalData?.()}},ap=e=>{let t=Er(),r=Xi.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[n,i,s,o,u]=r;o&&(u&&t._OrtClearBoundOutputs(o.handle),t._OrtReleaseBinding(o.handle)),t.jsepOnReleaseSession?.(e),i.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(n),Xi.delete(e)},lp=(e,t,r,n,i,s=!1)=>{if(!e){t.push(0);return}let o=Er(),u=e[0],d=e[1],h=e[3],y,l;if(u==="string"&&(h==="gpu-buffer"||h==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(s&&h!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(h==="gpu-buffer"){let P=e[2].gpuBuffer;l=Ln(Yn(u),d);let S=o.jsepRegisterBuffer;if(!S)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');y=S(n,i,P,l)}else if(h==="ml-tensor"){let P=e[2].mlTensor;l=Ln(Yn(u),d);let S=o.jsepRegisterMLTensor;if(!S)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');y=S(P,Yn(u),d)}else{let P=e[2];if(Array.isArray(P)){l=4*P.length,y=o._malloc(l),r.push(y);let S=y/4;for(let Q=0;Q<P.length;Q++){if(typeof P[Q]!="string")throw new TypeError(`tensor data at index ${Q} is not a string`);o.HEAPU32[S++]=Ar(P[Q],r)}}else l=P.byteLength,y=o._malloc(l),r.push(y),o.HEAPU8.set(new Uint8Array(P.buffer,P.byteOffset,l),y)}let x=o.stackSave(),A=o.stackAlloc(4*d.length);try{let P=A/4;d.forEach(Q=>o.HEAP32[P++]=Q);let S=o._OrtCreateTensor(Yn(u),y,l,A,d.length,yi(h));S===0&&Nr(`Can't create tensor for input/output. session=${n}, index=${i}.`),t.push(S)}finally{o.stackRestore(x)}},up=async(e,t,r,n,i,s)=>{let o=Er(),u=Xi.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let d=u[0],h=u[1],y=u[2],l=u[3],x=u[4],A=u[5],P=t.length,S=n.length,Q=0,Y=[],D=[],ne=[],he=[],be=o.stackSave(),Ye=o.stackAlloc(P*4),ze=o.stackAlloc(P*4),Mt=o.stackAlloc(S*4),Vt=o.stackAlloc(S*4);try{o.jsepOnRunStart?.(d),[Q,Y]=ki(s);for(let Yt=0;Yt<P;Yt++)lp(r[Yt],D,he,e,t[Yt],x);for(let Yt=0;Yt<S;Yt++)lp(i[Yt],ne,he,e,P+n[Yt],x);let jt=Ye/4,lr=ze/4,Zt=Mt/4,ur=Vt/4;for(let Yt=0;Yt<P;Yt++)o.HEAPU32[jt++]=D[Yt],o.HEAPU32[lr++]=h[t[Yt]];for(let Yt=0;Yt<S;Yt++)o.HEAPU32[Zt++]=ne[Yt],o.HEAPU32[ur++]=y[n[Yt]];if(l&&!A){let{handle:Yt,outputPreferredLocations:Tr,outputPreferredLocationsEncoded:xr}=l;if(h.length!==P)throw new Error(`input count from feeds (${P}) is expected to be always equal to model's input count (${h.length}).`);for(let Xt=0;Xt<P;Xt++){let yr=t[Xt];await o._OrtBindInput(Yt,h[yr],D[Xt])!==0&&Nr(`Can't bind input[${Xt}] for session=${e}.`)}for(let Xt=0;Xt<S;Xt++){let yr=n[Xt];i[Xt]?.[3]?o._OrtBindOutput(Yt,y[yr],ne[Xt],0)!==0&&Nr(`Can't bind pre-allocated output[${Xt}] for session=${e}.`):o._OrtBindOutput(Yt,y[yr],0,xr[yr])!==0&&Nr(`Can't bind output[${Xt}] to ${Tr[Xt]} for session=${e}.`)}Xi.set(e,[d,h,y,l,x,!0])}let Sr;l?Sr=await o._OrtRunWithBinding(d,l.handle,S,Mt,Q):Sr=await o._OrtRun(d,ze,Ye,P,Vt,S,Mt,Q),Sr!==0&&Nr("failed to call OrtRun().");let or=[];for(let Yt=0;Yt<S;Yt++){let Tr=o.HEAPU32[Mt/4+Yt];if(Tr===ne[Yt]){or.push(i[Yt]);continue}let xr=o.stackSave(),Xt=o.stackAlloc(4*4),yr=!1,ut,St=0;try{o._OrtGetTensorData(Tr,Xt,Xt+4,Xt+8,Xt+12)!==0&&Nr(`Can't access output tensor data on index ${Yt}.`);let mr=Xt/4,Wr=o.HEAPU32[mr++];St=o.HEAPU32[mr++];let qr=o.HEAPU32[mr++],Gn=o.HEAPU32[mr++],Dn=[];for(let mn=0;mn<Gn;mn++)Dn.push(o.HEAPU32[qr/4+mn]);o._OrtFree(qr);let Cn=Dn.reduce((mn,gn)=>mn*gn,1);ut=$n(Wr);let vn=l?.outputPreferredLocations[n[Yt]];if(ut==="string"){if(vn==="gpu-buffer"||vn==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let mn=[],gn=St/4;for(let Qi=0;Qi<Cn;Qi++){let Zi=o.HEAPU32[gn++],Ms=Qi===Cn-1?void 0:o.HEAPU32[gn]-Zi;mn.push(o.UTF8ToString(Zi,Ms))}or.push([ut,Dn,mn,"cpu"])}else if(vn==="gpu-buffer"&&Cn>0){let mn=o.jsepGetBuffer;if(!mn)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let gn=mn(St),Qi=Ln(Wr,Cn);if(Qi===void 0||!_i(ut))throw new Error(`Unsupported data type: ${ut}`);yr=!0,or.push([ut,Dn,{gpuBuffer:gn,download:o.jsepCreateDownloader(gn,Qi,ut),dispose:()=>{o._OrtReleaseTensor(Tr)}},"gpu-buffer"])}else if(vn==="ml-tensor"&&Cn>0){let mn=o.jsepEnsureTensor;if(!mn)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Ln(Wr,Cn)===void 0||!wi(ut))throw new Error(`Unsupported data type: ${ut}`);let gn=await mn(St,Wr,Dn,!1);yr=!0,or.push([ut,Dn,{mlTensor:gn,download:o.jsepCreateMLTensorDownloader(St,ut),dispose:()=>{o.jsepReleaseTensorId(St),o._OrtReleaseTensor(Tr)}},"ml-tensor"])}else{let mn=gi(ut),gn=new mn(Cn);new Uint8Array(gn.buffer,gn.byteOffset,gn.byteLength).set(o.HEAPU8.subarray(St,St+gn.byteLength)),or.push([ut,Dn,gn,"cpu"])}}finally{o.stackRestore(xr),ut==="string"&&St&&o._free(St),yr||o._OrtReleaseTensor(Tr)}}return l&&!x&&(o._OrtClearBoundOutputs(l.handle),Xi.set(e,[d,h,y,l,x,!1])),or}finally{o.stackRestore(be),D.forEach(jt=>o._OrtReleaseTensor(jt)),ne.forEach(jt=>o._OrtReleaseTensor(jt)),he.forEach(jt=>o._free(jt)),Q!==0&&o._OrtReleaseRunOptions(Q),Y.forEach(jt=>o._free(jt))}},dp=e=>{let t=Er(),r=Xi.get(e);if(!r)throw new Error("invalid session id");let n=r[0],i=t._OrtEndProfiling(n);i===0&&Nr("Can't get an profile file name."),t._OrtFree(i)},cp=e=>{let t=[];for(let r of e){let n=r[2];!Array.isArray(n)&&"buffer"in n&&t.push(n.buffer)}return t}}),Yi,Wn,ea,md,gd,xc,pp,Tc,ys,bs,kh,Ph,Ah,Ih,Fh,Oh,Bh,Dh,zh=j(()=>{c(),Sh(),zr(),Nt(),Yi=()=>!!I.wasm.proxy&&typeof document<"u",ea=!1,md=!1,gd=!1,Tc=new Map,ys=(e,t)=>{let r=Tc.get(e);r?r.push(t):Tc.set(e,[t])},bs=()=>{if(ea||!md||gd||!Wn)throw new Error("worker not ready")},kh=e=>{switch(e.data.type){case"init-wasm":ea=!1,e.data.err?(gd=!0,pp[1](e.data.err)):(md=!0,pp[0]()),xc&&(URL.revokeObjectURL(xc),xc=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Tc.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},Ph=async()=>{if(!md){if(ea)throw new Error("multiple calls to 'initWasm()' detected.");if(gd)throw new Error("previous call to 'initWasm()' failed.");if(ea=!0,Yi())return new Promise((e,t)=>{Wn?.terminate(),Tt().then(([r,n])=>{try{Wn=n,Wn.onerror=s=>t(s),Wn.onmessage=kh,pp=[e,t];let i={type:"init-wasm",in:I};Wn.postMessage(i),xc=r}catch(i){t(i)}},t)});try{await jr(I.wasm),await ip(I),md=!0}catch(e){throw gd=!0,e}finally{ea=!1}}},Ah=async e=>{if(Yi())return bs(),new Promise((t,r)=>{ys("init-ep",[t,r]);let n={type:"init-ep",in:{epName:e,env:I}};Wn.postMessage(n)});await sp(I,e)},Ih=async e=>Yi()?(bs(),new Promise((t,r)=>{ys("copy-from",[t,r]);let n={type:"copy-from",in:{buffer:e}};Wn.postMessage(n,[e.buffer])})):vc(e),Fh=async(e,t)=>{if(Yi()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return bs(),new Promise((r,n)=>{ys("create",[r,n]);let i={type:"create",in:{model:e,options:{...t}}},s=[];e instanceof Uint8Array&&s.push(e.buffer),Wn.postMessage(i,s)})}else return op(e,t)},Oh=async e=>{if(Yi())return bs(),new Promise((t,r)=>{ys("release",[t,r]);let n={type:"release",in:e};Wn.postMessage(n)});ap(e)},Bh=async(e,t,r,n,i,s)=>{if(Yi()){if(r.some(o=>o[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(i.some(o=>o))throw new Error("pre-allocated output tensor is not supported for proxy.");return bs(),new Promise((o,u)=>{ys("run",[o,u]);let d=r,h={type:"run",in:{sessionId:e,inputIndices:t,inputs:d,outputIndices:n,options:s}};Wn.postMessage(h,cp(d))})}else return up(e,t,r,n,i,s)},Dh=async e=>{if(Yi())return bs(),new Promise((t,r)=>{ys("end-profiling",[t,r]);let n={type:"end-profiling",in:e};Wn.postMessage(n)});dp(e)}}),hp,Lh,Rh,Rm=j(()=>{c(),zh(),rr(),m(),Bi(),hp=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Lh=e=>{switch(e[3]){case"cpu":return new X(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!_i(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:i}=e[2];return X.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:i})}case"ml-tensor":{let t=e[0];if(!wi(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:i}=e[2];return X.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:i})}default:throw new Error(`invalid data location: ${e[3]}`)}},Rh=class{async fetchModelAndCopyToWasmMemory(e){return Ih(await ri(e))}async loadModel(e,t){rt();let r;typeof e=="string"?r=await this.fetchModelAndCopyToWasmMemory(e):r=e,[this.sessionId,this.inputNames,this.outputNames]=await Fh(r,t),Qe()}async dispose(){return Oh(this.sessionId)}async run(e,t,r){rt();let n=[],i=[];Object.entries(e).forEach(l=>{let x=l[0],A=l[1],P=this.inputNames.indexOf(x);if(P===-1)throw new Error(`invalid input '${x}'`);n.push(A),i.push(P)});let s=[],o=[];Object.entries(t).forEach(l=>{let x=l[0],A=l[1],P=this.outputNames.indexOf(x);if(P===-1)throw new Error(`invalid output '${x}'`);s.push(A),o.push(P)});let u=n.map((l,x)=>hp(l,()=>`input "${this.inputNames[i[x]]}"`)),d=s.map((l,x)=>l?hp(l,()=>`output "${this.outputNames[o[x]]}"`):null),h=await Bh(this.sessionId,i,u,o,d,r),y={};for(let l=0;l<h.length;l++)y[this.outputNames[o[l]]]=s[l]??Lh(h[l]);return Qe(),y}startProfiling(){}endProfiling(){Dh(this.sessionId)}}}),Nh={};O(Nh,{OnnxruntimeWebAssemblyBackend:()=>mp,initializeFlags:()=>fp,wasmBackend:()=>jh});var fp,mp,jh,Nm=j(()=>{c(),zh(),Rm(),Nt(),fp=()=>{if((typeof I.wasm.initTimeout!="number"||I.wasm.initTimeout<0)&&(I.wasm.initTimeout=0),I.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof I.wasm.proxy!="boolean"&&(I.wasm.proxy=!1),typeof I.wasm.trace!="boolean"&&(I.wasm.trace=!1),typeof I.wasm.numThreads!="number"||!Number.isInteger(I.wasm.numThreads)||I.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)I.wasm.numThreads=1;else{let e=typeof navigator>"u"?Ee("node:os").cpus().length:navigator.hardwareConcurrency;I.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},mp=class{async init(e){fp(),await Ph(),await Ah(e)}async createInferenceSessionHandler(e,t){let r=new Rh;return await r.loadModel(e,t),Promise.resolve(r)}},jh=new mp});c(),c(),c();var jm="1.21.0-dev.20241024-d9ca84ef96",Um=C;{let e=(Nm(),N(Nh)).wasmBackend;$e("webgpu",e,5),$e("webnn",e,5),$e("cpu",e,10),$e("wasm",e,10)}Object.defineProperty(I.versions,"web",{value:jm,enumerable:!0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},"./src/backends/onnx.js":(oe,R,T)=>{var E;T.r(R),T.d(R,{Tensor:()=>Ee.Tensor,createInferenceSession:()=>U,deviceToExecutionProviders:()=>$e,isONNXProxy:()=>te,isONNXTensor:()=>ue});var Z=T("./src/env.js"),re=T("?2ce3"),fe=T("./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs"),Ee=T("./node_modules/onnxruntime-common/dist/esm/index.js");const j=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),O=[];let M,N;const K=Symbol.for("onnxruntime");if(K in globalThis)N=globalThis[K];else if(Z.apis.IS_NODE_ENV){switch(N=re??(E||(E=T.t(re,2))),Es.platform){case"win32":O.push("dml");break;case"linux":Es.arch==="x64"&&O.push("cuda");break}O.push("cpu"),M=["cpu"]}else N=fe,Z.apis.IS_WEBNN_AVAILABLE&&O.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),Z.apis.IS_WEBGPU_AVAILABLE&&O.push("webgpu"),O.push("wasm"),M=["wasm"];const ae=N.InferenceSession;function $e(ee=null){if(!ee)return M;switch(ee){case"auto":return O;case"gpu":return O.filter(q=>["webgpu","cuda","dml","webnn-gpu"].includes(q))}if(O.includes(ee))return[j[ee]??ee];throw new Error(`Unsupported device: "${ee}". Should be one of: ${O.join(", ")}.`)}let Te=null;async function U(ee,q,B){Te&&await Te;const H=ae.create(ee,q);Te??=H;const I=await H;return I.config=B,I}function ue(ee){return ee instanceof N.Tensor}const ke=N?.env;ke?.wasm&&(ke.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${Z.env.version}/dist/`,ke.wasm.proxy=!1,(typeof crossOriginIsolated>"u"||!crossOriginIsolated)&&(ke.wasm.numThreads=1)),ke?.webgpu&&(ke.webgpu.powerPreference="high-performance");function te(){return ke?.wasm?.proxy}Z.env.backends.onnx=ke},"./src/configs.js":(oe,R,T)=>{T.r(R),T.d(R,{AutoConfig:()=>O,PretrainedConfig:()=>j,getKeyValueShapes:()=>Ee});var E=T("./src/utils/core.js"),Z=T("./src/utils/hub.js");async function re(M,N){return await(0,Z.getModelJSON)(M,"config.json",!0,N)}function fe(M){const N={};let K={};switch(M.model_type){case"llava":case"paligemma":case"florence2":K=fe(M.text_config);break;case"moondream1":K=fe(M.phi_config);break;case"musicgen":K=fe(M.decoder);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":N.num_heads="n_head",N.num_layers="n_layer",N.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"phi":case"phi3":case"falcon":N.num_heads="num_attention_heads",N.num_layers="num_hidden_layers",N.hidden_size="hidden_size";break;case"llama":case"olmo":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":N.num_heads="num_key_value_heads",N.num_layers="num_hidden_layers",N.hidden_size="hidden_size",N.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":N.num_heads="num_key_value_heads",N.num_layers="num_hidden_layers",N.dim_kv="head_dim";break;case"openelm":N.num_heads="num_kv_heads",N.num_layers="num_transformer_layers",N.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":N.num_heads="num_heads",N.num_layers="num_layers",N.hidden_size="hidden_size";break;case"bloom":N.num_heads="n_head",N.num_layers="n_layer",N.hidden_size="hidden_size";break;case"mpt":N.num_heads="n_heads",N.num_layers="n_layers",N.hidden_size="d_model";break;case"t5":case"mt5":case"longt5":N.num_decoder_layers="num_decoder_layers",N.num_decoder_heads="num_heads",N.decoder_dim_kv="d_kv",N.num_encoder_layers="num_layers",N.num_encoder_heads="num_heads",N.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":N.num_decoder_layers="decoder_layers",N.num_decoder_heads="decoder_attention_heads",N.decoder_hidden_size="d_model",N.num_encoder_layers="encoder_layers",N.num_encoder_heads="encoder_attention_heads",N.encoder_hidden_size="d_model";break;case"speecht5":N.num_decoder_layers="decoder_layers",N.num_decoder_heads="decoder_attention_heads",N.decoder_hidden_size="hidden_size",N.num_encoder_layers="encoder_layers",N.num_encoder_heads="encoder_attention_heads",N.encoder_hidden_size="hidden_size";break;case"trocr":N.num_encoder_layers=N.num_decoder_layers="decoder_layers",N.num_encoder_heads=N.num_decoder_heads="decoder_attention_heads",N.encoder_hidden_size=N.decoder_hidden_size="d_model";break;case"musicgen_decoder":N.num_encoder_layers=N.num_decoder_layers="num_hidden_layers",N.num_encoder_heads=N.num_decoder_heads="num_attention_heads",N.encoder_hidden_size=N.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const $e=fe(M.decoder),Te="num_decoder_layers"in $e,U=(0,E.pick)(M,["model_type","is_encoder_decoder"]);return Te?(U.num_decoder_layers=$e.num_decoder_layers,U.num_decoder_heads=$e.num_decoder_heads,U.decoder_hidden_size=$e.decoder_hidden_size,U.num_encoder_layers=$e.num_encoder_layers,U.num_encoder_heads=$e.num_encoder_heads,U.encoder_hidden_size=$e.encoder_hidden_size):(U.num_layers=$e.num_layers,U.num_heads=$e.num_heads,U.hidden_size=$e.hidden_size),U}const ae={...K,...(0,E.pick)(M,["model_type","multi_query","is_encoder_decoder"])};for(const $e in N)ae[$e]=M[N[$e]];return ae}function Ee(M,{prefix:N="past_key_values"}={}){const K={},ae=M.normalized_config,$e=1;if(ae.is_encoder_decoder&&"num_encoder_heads"in ae&&"num_decoder_heads"in ae){const Te=ae.encoder_dim_kv??ae.encoder_hidden_size/ae.num_encoder_heads,U=ae.decoder_dim_kv??ae.decoder_hidden_size/ae.num_decoder_heads,ue=[$e,ae.num_encoder_heads,0,Te],ke=[$e,ae.num_decoder_heads,0,U];for(let te=0;te<ae.num_decoder_layers;++te)K[`${N}.${te}.encoder.key`]=ue,K[`${N}.${te}.encoder.value`]=ue,K[`${N}.${te}.decoder.key`]=ke,K[`${N}.${te}.decoder.value`]=ke}else{const Te=ae.num_heads,U=ae.num_layers,ue=ae.dim_kv??ae.hidden_size/(ae.num_attention_heads??Te);if(ae.model_type==="falcon"){const ke=[$e*Te,0,ue];for(let te=0;te<U;++te)K[`${N}.${te}.key`]=ke,K[`${N}.${te}.value`]=ke}else if(ae.multi_query){const ke=[$e*Te,0,2*ue];for(let te=0;te<U;++te)K[`${N}.${te}.key_value`]=ke}else if(ae.model_type==="bloom"){const ke=[$e*Te,ue,0],te=[$e*Te,0,ue];for(let ee=0;ee<U;++ee)K[`${N}.${ee}.key`]=ke,K[`${N}.${ee}.value`]=te}else if(ae.model_type==="openelm")for(let ke=0;ke<U;++ke){const te=[$e,Te[ke],0,ue];K[`${N}.${ke}.key`]=te,K[`${N}.${ke}.value`]=te}else{const ke=[$e,Te,0,ue];for(let te=0;te<U;++te)K[`${N}.${te}.key`]=ke,K[`${N}.${te}.value`]=ke}}return K}class j{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(N){Object.assign(this,N),this.normalized_config=fe(this)}static async from_pretrained(N,{progress_callback:K=null,config:ae=null,cache_dir:$e=null,local_files_only:Te=!1,revision:U="main"}={}){ae&&!(ae instanceof j)&&(ae=new j(ae));const ue=ae??await re(N,{progress_callback:K,config:ae,cache_dir:$e,local_files_only:Te,revision:U});return new this(ue)}}class O{static async from_pretrained(...N){return j.from_pretrained(...N)}}},"./src/env.js":(oe,R,T)=>{T.r(R),T.d(R,{apis:()=>U,env:()=>B});var E=T("?569f"),Z=T("?3f59"),re=T("?154a");const fe="3.0.2",Ee=typeof self<"u",j=Ee&&self.constructor.name==="DedicatedWorkerGlobalScope",O=Ee&&"caches"in self,M=typeof navigator<"u"&&"gpu"in navigator,N=typeof navigator<"u"&&"ml"in navigator,K=typeof Es<"u",ae=K&&Es?.release?.name==="node",$e=!H(E),Te=!H(Z),U=Object.freeze({IS_BROWSER_ENV:Ee,IS_WEBWORKER_ENV:j,IS_WEB_CACHE_AVAILABLE:O,IS_WEBGPU_AVAILABLE:M,IS_WEBNN_AVAILABLE:N,IS_PROCESS_AVAILABLE:K,IS_NODE_ENV:ae,IS_FS_AVAILABLE:$e,IS_PATH_AVAILABLE:Te}),ue=$e&&Te;let ke="./";if(ue){const I=Object(import.meta).url;I?ke=Z.dirname(Z.dirname(re.fileURLToPath(I))):typeof __dirname<"u"&&(ke=Z.dirname(__dirname))}const te=ue?Z.join(ke,"/.cache/"):null,ee="/models/",q=ue?Z.join(ke,ee):ee,B={version:fe,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!Ee,localModelPath:q,useFS:$e,useBrowserCache:O,useFSCache:$e,cacheDir:te,useCustomCache:!1,customCache:null};function H(I){return Object.keys(I).length===0}},"./src/generation/configuration_utils.js":(oe,R,T)=>{T.r(R),T.d(R,{GenerationConfig:()=>Z});var E=T("./src/utils/core.js");class Z{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(fe){Object.assign(this,(0,E.pick)(fe,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(oe,R,T)=>{T.r(R),T.d(R,{ClassifierFreeGuidanceLogitsProcessor:()=>ue,ForcedBOSTokenLogitsProcessor:()=>j,ForcedEOSTokenLogitsProcessor:()=>O,LogitsProcessor:()=>re,LogitsProcessorList:()=>Ee,LogitsWarper:()=>fe,MinLengthLogitsProcessor:()=>$e,MinNewTokensLengthLogitsProcessor:()=>Te,NoBadWordsLogitsProcessor:()=>U,NoRepeatNGramLogitsProcessor:()=>K,RepetitionPenaltyLogitsProcessor:()=>ae,SuppressTokensAtBeginLogitsProcessor:()=>M,TemperatureLogitsWarper:()=>ke,TopKLogitsWarper:()=>ee,TopPLogitsWarper:()=>te,WhisperTimeStampLogitsProcessor:()=>N});var E=T("./src/utils/generic.js");T("./src/utils/tensor.js");var Z=T("./src/utils/maths.js");class re extends E.Callable{_call(B,H){throw Error("`_call` should be implemented in a subclass")}}class fe extends E.Callable{_call(B,H){throw Error("`_call` should be implemented in a subclass")}}class Ee extends E.Callable{constructor(){super(),this.processors=[]}push(B){this.processors.push(B)}extend(B){this.processors.push(...B)}_call(B,H){let I=H;for(const Me of this.processors)I=Me(B,I);return I}[Symbol.iterator](){return this.processors.values()}}class j extends re{constructor(B){super(),this.bos_token_id=B}_call(B,H){for(let I=0;I<B.length;++I)if(B[I].length===1){const Me=H[I].data;Me.fill(-1/0),Me[this.bos_token_id]=0}return H}}class O extends re{constructor(B,H){super(),this.max_length=B,this.eos_token_id=Array.isArray(H)?H:[H]}_call(B,H){for(let I=0;I<B.length;++I)if(B[I].length===this.max_length-1){const Me=H[I].data;Me.fill(-1/0);for(const xe of this.eos_token_id)Me[xe]=0}return H}}class M extends re{constructor(B,H){super(),this.begin_suppress_tokens=B,this.begin_index=H}_call(B,H){for(let I=0;I<B.length;++I)if(B[I].length===this.begin_index){const Me=H[I].data;for(const xe of this.begin_suppress_tokens)Me[xe]=-1/0}return H}}class N extends re{constructor(B,H){super(),this.eos_token_id=Array.isArray(B.eos_token_id)?B.eos_token_id[0]:B.eos_token_id,this.no_timestamps_token_id=B.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=H.length,H.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=B.max_initial_timestamp_index}_call(B,H){for(let I=0;I<B.length;++I){const Me=H[I].data;if(Me[this.no_timestamps_token_id]=-1/0,B[I].length===this.begin_index-1){Me.fill(-1/0),Me[this.timestamp_begin]=0;continue}const xe=B[I].slice(this.begin_index),Ce=xe.length>=1&&xe[xe.length-1]>=this.timestamp_begin,Ve=xe.length<2||xe[xe.length-2]>=this.timestamp_begin;if(Ce&&(Ve?Me.subarray(this.timestamp_begin).fill(-1/0):Me.subarray(0,this.eos_token_id).fill(-1/0)),B[I].length===this.begin_index&&this.max_initial_timestamp_index!==null){const Ae=this.timestamp_begin+this.max_initial_timestamp_index;Me.subarray(Ae+1).fill(-1/0)}const Ue=(0,Z.log_softmax)(Me),Ne=Math.log(Ue.subarray(this.timestamp_begin).map(Math.exp).reduce((Ae,ie)=>Ae+ie)),Pe=(0,Z.max)(Ue.subarray(0,this.timestamp_begin))[0];Ne>Pe&&Me.subarray(0,this.timestamp_begin).fill(-1/0)}return H}}class K extends re{constructor(B){super(),this.no_repeat_ngram_size=B}getNgrams(B){const H=B.length,I=[];for(let xe=0;xe<H+1-this.no_repeat_ngram_size;++xe){const Ce=[];for(let Ve=0;Ve<this.no_repeat_ngram_size;++Ve)Ce.push(B[xe+Ve]);I.push(Ce.map(Number))}const Me=new Map;for(const xe of I){const Ce=xe.slice(0,xe.length-1),Ve=JSON.stringify(Ce),Ue=Me.get(Ve)??[];Ue.push(xe[xe.length-1]),Me.set(Ve,Ue)}return Me}getGeneratedNgrams(B,H){const I=H.slice(H.length+1-this.no_repeat_ngram_size,H.length);return B.get(JSON.stringify(I.map(Number)))??[]}calcBannedNgramTokens(B){const H=[];if(B.length+1<this.no_repeat_ngram_size)return H;{const I=this.getNgrams(B);return this.getGeneratedNgrams(I,B)}}_call(B,H){for(let I=0;I<B.length;++I){const Me=H[I].data,xe=this.calcBannedNgramTokens(B[I]);for(const Ce of xe)Me[Ce]=-1/0}return H}}class ae extends re{constructor(B){super(),this.penalty=B}_call(B,H){for(let I=0;I<B.length;++I){const Me=H[I].data;for(const xe of B[I]){const Ce=Number(xe);Me[Ce]<0?Me[Ce]*=this.penalty:Me[Ce]/=this.penalty}}return H}}class $e extends re{constructor(B,H){super(),this.min_length=B,this.eos_token_id=Array.isArray(H)?H:[H]}_call(B,H){for(let I=0;I<B.length;++I)if(B[I].length<this.min_length){const Me=H[I].data;for(const xe of this.eos_token_id)Me[xe]=-1/0}return H}}class Te extends re{constructor(B,H,I){super(),this.prompt_length_to_skip=B,this.min_new_tokens=H,this.eos_token_id=Array.isArray(I)?I:[I]}_call(B,H){for(let I=0;I<B.length;++I)if(B[I].length-this.prompt_length_to_skip<this.min_new_tokens){const xe=H[I].data;for(const Ce of this.eos_token_id)xe[Ce]=-1/0}return H}}class U extends re{constructor(B,H){super(),this.bad_words_ids=B,this.eos_token_id=Array.isArray(H)?H:[H]}_call(B,H){for(let I=0;I<B.length;++I){const Me=H[I].data,xe=B[I];for(const Ce of this.bad_words_ids){let Ve=!0;for(let Ue=1;Ue<=Ce.length-1&&Ce.length<xe.length;++Ue)if(Ce.at(-Ue-1)!=xe.at(-Ue)){Ve=!1;break}Ve&&(Me[Ce.at(-1)]=-1/0)}}return H}}class ue extends re{constructor(B){if(super(),B<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${B}.`);this.guidance_scale=B}_call(B,H){if(H.dims[0]!==2*B.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${H.dims[0]} for the logits and ${B.length} for the input ids.`);const I=B.length,Me=H.slice([0,I],null),xe=H.slice([I,H.dims[0]],null);for(let Ce=0;Ce<xe.data.length;++Ce)xe.data[Ce]+=(Me.data[Ce]-xe.data[Ce])*this.guidance_scale;return xe}}class ke extends fe{constructor(B){super(),this.temperature=B}_call(B,H){const I=H.data;for(let Me=0;Me<I.length;++Me)I[Me]/=this.temperature;return H}}class te extends fe{constructor(B,{filter_value:H=-1/0,min_tokens_to_keep:I=1}={}){if(super(),B<0||B>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${B}`);if(!Number.isInteger(I)||I<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${I}`);this.top_p=B,this.filter_value=H,this.min_tokens_to_keep=I}}class ee extends fe{constructor(B,{filter_value:H=-1/0,min_tokens_to_keep:I=1}={}){if(super(),!Number.isInteger(B)||B<0)throw new Error(`\`top_k\` must be a positive integer, but is ${B}`);this.top_k=Math.max(B,I),this.filter_value=H}}},"./src/generation/logits_sampler.js":(oe,R,T)=>{T.r(R),T.d(R,{LogitsSampler:()=>fe});var E=T("./src/utils/generic.js"),Z=T("./src/utils/tensor.js"),re=T("./src/utils/maths.js");T("./src/generation/configuration_utils.js");class fe extends E.Callable{constructor(N){super(),this.generation_config=N}async _call(N){return this.sample(N)}async sample(N){throw Error("sample should be implemented in subclasses.")}getLogits(N,K){let ae=N.dims.at(-1),$e=N.data;if(K===-1)$e=$e.slice(-ae);else{let Te=K*ae;$e=$e.slice(Te,Te+ae)}return $e}randomSelect(N){let K=0;for(let $e=0;$e<N.length;++$e)K+=N[$e];let ae=Math.random()*K;for(let $e=0;$e<N.length;++$e)if(ae-=N[$e],ae<=0)return $e;return 0}static getSampler(N){if(N.do_sample)return new j(N);if(N.num_beams>1)return new O(N);if(N.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${N.num_return_sequences}.`);return new Ee(N)}}class Ee extends fe{async sample(N){const K=(0,re.max)(N.data)[1];return[[BigInt(K),0]]}}class j extends fe{async sample(N){let K=N.dims.at(-1);this.generation_config.top_k>0&&(K=Math.min(this.generation_config.top_k,K));const[ae,$e]=await(0,Z.topk)(N,K),Te=(0,re.softmax)(ae.data);return Array.from({length:this.generation_config.num_beams},()=>{const U=this.randomSelect(Te);return[$e.data[U],Math.log(Te[U])]})}}class O extends fe{async sample(N){let K=N.dims.at(-1);this.generation_config.top_k>0&&(K=Math.min(this.generation_config.top_k,K));const[ae,$e]=await(0,Z.topk)(N,K),Te=(0,re.softmax)(ae.data);return Array.from({length:this.generation_config.num_beams},(U,ue)=>[$e.data[ue],Math.log(Te[ue])])}}},"./src/generation/stopping_criteria.js":(oe,R,T)=>{T.r(R),T.d(R,{EosTokenCriteria:()=>Ee,InterruptableStoppingCriteria:()=>j,MaxLengthCriteria:()=>fe,StoppingCriteria:()=>Z,StoppingCriteriaList:()=>re});var E=T("./src/utils/generic.js");class Z extends E.Callable{_call(M,N){throw Error("StoppingCriteria needs to be subclassed")}}class re extends E.Callable{constructor(){super(),this.criteria=[]}push(M){this.criteria.push(M)}extend(M){M instanceof re?M=M.criteria:M instanceof Z&&(M=[M]),this.criteria.push(...M)}_call(M,N){const K=new Array(M.length).fill(!1);for(const ae of this.criteria){const $e=ae(M,N);for(let Te=0;Te<K.length;++Te)K[Te]||=$e[Te]}return K}[Symbol.iterator](){return this.criteria.values()}}class fe extends Z{constructor(M,N=null){super(),this.max_length=M,this.max_position_embeddings=N}_call(M){return M.map(N=>N.length>=this.max_length)}}class Ee extends Z{constructor(M){super(),Array.isArray(M)||(M=[M]),this.eos_token_id=M}_call(M,N){return M.map(K=>{const ae=K.at(-1);return this.eos_token_id.some($e=>ae==$e)})}}class j extends Z{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(M,N){return new Array(M.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(oe,R,T)=>{T.r(R),T.d(R,{BaseStreamer:()=>fe,TextStreamer:()=>j,WhisperTextStreamer:()=>O});var E=T("./src/utils/core.js"),Z=T("./src/tokenizers.js"),re=T("./src/env.js");class fe{put(N){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const Ee=re.apis.IS_PROCESS_AVAILABLE?M=>Es.stdout.write(M):M=>console.log(M);class j extends fe{constructor(N,{skip_prompt:K=!1,callback_function:ae=null,token_callback_function:$e=null,decode_kwargs:Te={},...U}={}){super(),this.tokenizer=N,this.skip_prompt=K,this.callback_function=ae??Ee,this.token_callback_function=$e,this.decode_kwargs={...Te,...U},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(N){if(N.length>1)throw Error("TextStreamer only supports batch size of 1");if(this.skip_prompt&&this.next_tokens_are_prompt){this.next_tokens_are_prompt=!1;return}const K=N[0];this.token_callback_function?.(K),this.token_cache=(0,E.mergeArrays)(this.token_cache,K);const ae=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let $e;ae.endsWith(`
`)?($e=ae.slice(this.print_len),this.token_cache=[],this.print_len=0):ae.length>0&&(0,Z.is_chinese_char)(ae.charCodeAt(ae.length-1))?($e=ae.slice(this.print_len),this.print_len+=$e.length):($e=ae.slice(this.print_len,ae.lastIndexOf(" ")+1),this.print_len+=$e.length),this.on_finalized_text($e,!1)}end(){let N;this.token_cache.length>0?(N=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):N="",this.next_tokens_are_prompt=!0,this.on_finalized_text(N,!0)}on_finalized_text(N,K){N.length>0&&this.callback_function?.(N),K&&this.callback_function===Ee&&re.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.(`
`)}}class O extends j{constructor(N,{skip_prompt:K=!1,callback_function:ae=null,token_callback_function:$e=null,on_chunk_start:Te=null,on_chunk_end:U=null,on_finalize:ue=null,time_precision:ke=.02,skip_special_tokens:te=!0,decode_kwargs:ee={}}={}){super(N,{skip_prompt:K,callback_function:ae,token_callback_function:$e,decode_kwargs:{skip_special_tokens:te,...ee}}),this.timestamp_begin=N.timestamp_begin,this.on_chunk_start=Te,this.on_chunk_end=U,this.on_finalize=ue,this.time_precision=ke,this.waiting_for_timestamp=!1}put(N){if(N.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const K=N[0];if(K.length===1){const ae=Number(K[0])-this.timestamp_begin;if(ae>=0){const $e=ae*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.($e):this.on_chunk_start?.($e),this.waiting_for_timestamp=!this.waiting_for_timestamp,N=[[]]}}return super.put(N)}end(){super.end(),this.on_finalize?.()}}},"./src/models.js":(oe,R,T)=>{T.r(R),T.d(R,{ASTForAudioClassification:()=>is,ASTModel:()=>qt,ASTPreTrainedModel:()=>Nn,AlbertForMaskedLM:()=>rr,AlbertForQuestionAnswering:()=>yi,AlbertForSequenceClassification:()=>wi,AlbertModel:()=>_i,AlbertPreTrainedModel:()=>On,AutoModel:()=>Zd,AutoModelForAudioClassification:()=>dc,AutoModelForAudioFrameClassification:()=>ad,AutoModelForCTC:()=>od,AutoModelForCausalLM:()=>ic,AutoModelForDepthEstimation:()=>ud,AutoModelForDocumentQuestionAnswering:()=>ld,AutoModelForImageClassification:()=>lc,AutoModelForImageFeatureExtraction:()=>mc,AutoModelForImageMatting:()=>pc,AutoModelForImageSegmentation:()=>uc,AutoModelForImageToImage:()=>hc,AutoModelForMaskGeneration:()=>sd,AutoModelForMaskedLM:()=>sc,AutoModelForNormalEstimation:()=>fc,AutoModelForObjectDetection:()=>nd,AutoModelForQuestionAnswering:()=>oc,AutoModelForSemanticSegmentation:()=>Yc,AutoModelForSeq2SeqLM:()=>Xc,AutoModelForSequenceClassification:()=>Jd,AutoModelForSpeechSeq2Seq:()=>tc,AutoModelForTextToSpectrogram:()=>rc,AutoModelForTextToWaveform:()=>nc,AutoModelForTokenClassification:()=>ec,AutoModelForUniversalSegmentation:()=>ws,AutoModelForVision2Seq:()=>ac,AutoModelForXVector:()=>cc,AutoModelForZeroShotObjectDetection:()=>id,BartForConditionalGeneration:()=>ce,BartForSequenceClassification:()=>me,BartModel:()=>G,BartPretrainedModel:()=>g,BaseModelOutput:()=>it,BeitForImageClassification:()=>bl,BeitModel:()=>yl,BeitPreTrainedModel:()=>so,BertForMaskedLM:()=>xt,BertForQuestionAnswering:()=>Be,BertForSequenceClassification:()=>et,BertForTokenClassification:()=>X,BertModel:()=>wt,BertPreTrainedModel:()=>He,BlenderbotForConditionalGeneration:()=>pr,BlenderbotModel:()=>gr,BlenderbotPreTrainedModel:()=>$t,BlenderbotSmallForConditionalGeneration:()=>bn,BlenderbotSmallModel:()=>Xr,BlenderbotSmallPreTrainedModel:()=>Cr,BloomForCausalLM:()=>Xa,BloomModel:()=>Ka,BloomPreTrainedModel:()=>as,CLIPModel:()=>pa,CLIPPreTrainedModel:()=>si,CLIPSegForImageSegmentation:()=>ba,CLIPSegModel:()=>ya,CLIPSegPreTrainedModel:()=>Ps,CLIPTextModel:()=>Ed,CLIPTextModelWithProjection:()=>Mn,CLIPVisionModel:()=>Cd,CLIPVisionModelWithProjection:()=>ha,CamembertForMaskedLM:()=>we,CamembertForQuestionAnswering:()=>sr,CamembertForSequenceClassification:()=>Fe,CamembertForTokenClassification:()=>Xe,CamembertModel:()=>W,CamembertPreTrainedModel:()=>m,CausalLMOutput:()=>oi,CausalLMOutputWithPast:()=>gc,ChineseCLIPModel:()=>wa,ChineseCLIPPreTrainedModel:()=>_a,ClapAudioModelWithProjection:()=>Cu,ClapModel:()=>Eu,ClapPreTrainedModel:()=>_s,ClapTextModelWithProjection:()=>Bo,CodeGenForCausalLM:()=>ka,CodeGenModel:()=>Sa,CodeGenPreTrainedModel:()=>Tn,CohereForCausalLM:()=>La,CohereModel:()=>za,CoherePreTrainedModel:()=>Us,ConvBertForMaskedLM:()=>z,ConvBertForQuestionAnswering:()=>dt,ConvBertForSequenceClassification:()=>pe,ConvBertForTokenClassification:()=>Se,ConvBertModel:()=>J,ConvBertPreTrainedModel:()=>$,ConvNextForImageClassification:()=>ql,ConvNextModel:()=>Gl,ConvNextPreTrainedModel:()=>wo,ConvNextV2ForImageClassification:()=>Hl,ConvNextV2Model:()=>yo,ConvNextV2PreTrainedModel:()=>Ni,DPTForDepthEstimation:()=>kd,DPTModel:()=>Rl,DPTPreTrainedModel:()=>fo,DebertaForMaskedLM:()=>ve,DebertaForQuestionAnswering:()=>Ze,DebertaForSequenceClassification:()=>Ie,DebertaForTokenClassification:()=>je,DebertaModel:()=>V,DebertaPreTrainedModel:()=>ot,DebertaV2ForMaskedLM:()=>Et,DebertaV2ForQuestionAnswering:()=>Ut,DebertaV2ForSequenceClassification:()=>Ft,DebertaV2ForTokenClassification:()=>Tt,DebertaV2Model:()=>Ct,DebertaV2PreTrainedModel:()=>mt,DecisionTransformerModel:()=>Ru,DecisionTransformerPreTrainedModel:()=>Lu,DeiTForImageClassification:()=>kl,DeiTModel:()=>Sl,DeiTPreTrainedModel:()=>co,DepthAnythingForDepthEstimation:()=>jl,DepthAnythingPreTrainedModel:()=>Nl,DepthProForDepthEstimation:()=>Zn,DepthProPreTrainedModel:()=>Pd,DetrForObjectDetection:()=>vl,DetrForSegmentation:()=>ds,DetrModel:()=>Ml,DetrObjectDetectionOutput:()=>oo,DetrPreTrainedModel:()=>us,DetrSegmentationOutput:()=>ao,Dinov2ForImageClassification:()=>bo,Dinov2Model:()=>Kl,Dinov2PreTrainedModel:()=>ji,DistilBertForMaskedLM:()=>Ht,DistilBertForQuestionAnswering:()=>vt,DistilBertForSequenceClassification:()=>We,DistilBertForTokenClassification:()=>Ge,DistilBertModel:()=>Nt,DistilBertPreTrainedModel:()=>Wt,DonutSwinModel:()=>_o,DonutSwinPreTrainedModel:()=>hs,EfficientNetForImageClassification:()=>jd,EfficientNetModel:()=>Pu,EfficientNetPreTrainedModel:()=>No,ElectraForMaskedLM:()=>pt,ElectraForQuestionAnswering:()=>c,ElectraForSequenceClassification:()=>bt,ElectraForTokenClassification:()=>C,ElectraModel:()=>At,ElectraPreTrainedModel:()=>at,EsmForMaskedLM:()=>jr,EsmForSequenceClassification:()=>Er,EsmForTokenClassification:()=>zr,EsmModel:()=>Or,EsmPreTrainedModel:()=>ar,FalconForCausalLM:()=>Tu,FalconModel:()=>xu,FalconPreTrainedModel:()=>gs,FastViTForImageClassification:()=>dl,FastViTModel:()=>ul,FastViTPreTrainedModel:()=>eo,Florence2ForConditionalGeneration:()=>ks,Florence2PreTrainedModel:()=>ca,GLPNForDepthEstimation:()=>go,GLPNModel:()=>hn,GLPNPreTrainedModel:()=>Vn,GPT2LMHeadModel:()=>Pn,GPT2Model:()=>Ma,GPT2PreTrainedModel:()=>As,GPTBigCodeForCausalLM:()=>zs,GPTBigCodeModel:()=>ss,GPTBigCodePreTrainedModel:()=>Ds,GPTJForCausalLM:()=>An,GPTJModel:()=>$d,GPTJPreTrainedModel:()=>Bs,GPTNeoForCausalLM:()=>Ea,GPTNeoModel:()=>Ta,GPTNeoPreTrainedModel:()=>Fs,GPTNeoXForCausalLM:()=>$a,GPTNeoXModel:()=>Ca,GPTNeoXPreTrainedModel:()=>Os,Gemma2ForCausalLM:()=>qs,Gemma2Model:()=>Gs,Gemma2PreTrainedModel:()=>Ws,GemmaForCausalLM:()=>Na,GemmaModel:()=>Ra,GemmaPreTrainedModel:()=>Vs,GraniteForCausalLM:()=>Da,GraniteModel:()=>Ba,GranitePreTrainedModel:()=>js,GroupViTModel:()=>ll,GroupViTPreTrainedModel:()=>al,HieraForImageClassification:()=>Il,HieraModel:()=>Al,HieraPreTrainedModel:()=>Pl,HubertForCTC:()=>du,HubertForSequenceClassification:()=>Io,HubertModel:()=>uu,HubertPreTrainedModel:()=>Dd,ImageMattingOutput:()=>pd,JAISLMHeadModel:()=>xa,JAISModel:()=>va,JAISPreTrainedModel:()=>Is,LlamaForCausalLM:()=>Aa,LlamaModel:()=>Pa,LlamaPreTrainedModel:()=>Ls,LlavaForConditionalGeneration:()=>Mi,LlavaPreTrainedModel:()=>da,LongT5ForConditionalGeneration:()=>Li,LongT5Model:()=>zi,LongT5PreTrainedModel:()=>bi,M2M100ForConditionalGeneration:()=>Id,M2M100Model:()=>Jl,M2M100PreTrainedModel:()=>To,MBartForCausalLM:()=>zt,MBartForConditionalGeneration:()=>Pt,MBartForSequenceClassification:()=>Dt,MBartModel:()=>ct,MBartPreTrainedModel:()=>Le,MPNetForMaskedLM:()=>Ai,MPNetForQuestionAnswering:()=>Oi,MPNetForSequenceClassification:()=>Ii,MPNetForTokenClassification:()=>Fi,MPNetModel:()=>Pi,MPNetPreTrainedModel:()=>Xn,MT5ForConditionalGeneration:()=>ye,MT5Model:()=>ns,MT5PreTrainedModel:()=>ni,MarianMTModel:()=>Zl,MarianModel:()=>xo,MarianPreTrainedModel:()=>vo,MaskFormerForInstanceSegmentation:()=>mo,MaskFormerModel:()=>Jn,MaskFormerPreTrainedModel:()=>Un,MaskedLMOutput:()=>un,MistralForCausalLM:()=>Mu,MistralModel:()=>bu,MistralPreTrainedModel:()=>Oo,MobileBertForMaskedLM:()=>Nr,MobileBertForQuestionAnswering:()=>ki,MobileBertForSequenceClassification:()=>mi,MobileBertModel:()=>zn,MobileBertPreTrainedModel:()=>Ar,MobileLLMForCausalLM:()=>Fa,MobileLLMModel:()=>Ia,MobileLLMPreTrainedModel:()=>Rs,MobileNetV1ForImageClassification:()=>Fu,MobileNetV1Model:()=>Iu,MobileNetV1PreTrainedModel:()=>Au,MobileNetV2ForImageClassification:()=>Wd,MobileNetV2Model:()=>Ou,MobileNetV2PreTrainedModel:()=>Vo,MobileNetV3ForImageClassification:()=>Du,MobileNetV3Model:()=>Bu,MobileNetV3PreTrainedModel:()=>Wo,MobileNetV4ForImageClassification:()=>zu,MobileNetV4Model:()=>Gd,MobileNetV4PreTrainedModel:()=>Go,MobileViTForImageClassification:()=>pl,MobileViTModel:()=>ls,MobileViTPreTrainedModel:()=>to,MobileViTV2ForImageClassification:()=>fl,MobileViTV2Model:()=>hl,MobileViTV2PreTrainedModel:()=>ro,ModelOutput:()=>Re,Moondream1ForConditionalGeneration:()=>fr,MptForCausalLM:()=>Sd,MptModel:()=>Ya,MptPreTrainedModel:()=>Ys,MusicgenForCausalLM:()=>Vd,MusicgenForConditionalGeneration:()=>Uo,MusicgenModel:()=>Ud,MusicgenPreTrainedModel:()=>jo,NomicBertModel:()=>lt,NomicBertPreTrainedModel:()=>st,OPTForCausalLM:()=>Za,OPTModel:()=>Qa,OPTPreTrainedModel:()=>Qs,OlmoForCausalLM:()=>In,OlmoModel:()=>Oa,OlmoPreTrainedModel:()=>Ns,OpenELMForCausalLM:()=>Ks,OpenELMModel:()=>ja,OpenELMPreTrainedModel:()=>Hs,OwlViTForObjectDetection:()=>gl,OwlViTModel:()=>ml,OwlViTPreTrainedModel:()=>no,Owlv2ForObjectDetection:()=>wl,Owlv2Model:()=>_l,Owlv2PreTrainedModel:()=>io,Phi3ForCausalLM:()=>Ha,Phi3Model:()=>qa,Phi3PreTrainedModel:()=>vi,PhiForCausalLM:()=>Ga,PhiModel:()=>Wa,PhiPreTrainedModel:()=>Xs,PreTrainedModel:()=>de,PretrainedMixin:()=>Lr,PvtForImageClassification:()=>rl,PvtModel:()=>tl,PvtPreTrainedModel:()=>Zs,PyAnnoteForAudioFrameClassification:()=>nu,PyAnnoteModel:()=>ru,PyAnnotePreTrainedModel:()=>Co,QuestionAnsweringModelOutput:()=>_n,Qwen2ForCausalLM:()=>os,Qwen2Model:()=>Va,Qwen2PreTrainedModel:()=>Ua,RTDetrForObjectDetection:()=>Tl,RTDetrModel:()=>xl,RTDetrObjectDetectionOutput:()=>El,RTDetrPreTrainedModel:()=>cs,ResNetForImageClassification:()=>Ol,ResNetModel:()=>Fl,ResNetPreTrainedModel:()=>En,RoFormerForMaskedLM:()=>_t,RoFormerForQuestionAnswering:()=>kt,RoFormerForSequenceClassification:()=>yt,RoFormerForTokenClassification:()=>Lt,RoFormerModel:()=>Qe,RoFormerPreTrainedModel:()=>rt,RobertaForMaskedLM:()=>xn,RobertaForQuestionAnswering:()=>Jr,RobertaForSequenceClassification:()=>Sn,RobertaForTokenClassification:()=>De,RobertaModel:()=>kr,RobertaPreTrainedModel:()=>hr,SamImageSegmentationOutput:()=>Vi,SamModel:()=>Mo,SamPreTrainedModel:()=>Ql,SapiensForDepthEstimation:()=>Vl,SapiensForNormalEstimation:()=>Wl,SapiensForSemanticSegmentation:()=>Ul,SapiensPreTrainedModel:()=>ps,SegformerForImageClassification:()=>Lo,SegformerForSemanticSegmentation:()=>Su,SegformerModel:()=>Rd,SegformerPreTrainedModel:()=>zo,Seq2SeqLMOutput:()=>dd,SequenceClassifierOutput:()=>cr,SiglipModel:()=>fa,SiglipPreTrainedModel:()=>jn,SiglipTextModel:()=>ma,SiglipVisionModel:()=>ga,SpeechT5ForSpeechToText:()=>gu,SpeechT5ForTextToSpeech:()=>_u,SpeechT5HifiGan:()=>Ld,SpeechT5Model:()=>zd,SpeechT5PreTrainedModel:()=>Fo,SqueezeBertForMaskedLM:()=>$n,SqueezeBertForQuestionAnswering:()=>gi,SqueezeBertForSequenceClassification:()=>Ln,SqueezeBertModel:()=>Yn,SqueezeBertPreTrainedModel:()=>ti,StableLmForCausalLM:()=>Nd,StableLmModel:()=>ku,StableLmPreTrainedModel:()=>Ro,Starcoder2ForCausalLM:()=>Gi,Starcoder2Model:()=>ms,Starcoder2PreTrainedModel:()=>vu,Swin2SRForImageSuperResolution:()=>Ll,Swin2SRModel:()=>zl,Swin2SRPreTrainedModel:()=>ho,SwinForImageClassification:()=>Dl,SwinModel:()=>Bl,SwinPreTrainedModel:()=>po,T5ForConditionalGeneration:()=>Di,T5Model:()=>Bi,T5PreTrainedModel:()=>ri,TableTransformerForObjectDetection:()=>$l,TableTransformerModel:()=>Cl,TableTransformerObjectDetectionOutput:()=>uo,TableTransformerPreTrainedModel:()=>lo,TokenClassifierOutput:()=>nn,TrOCRForCausalLM:()=>yu,TrOCRPreTrainedModel:()=>wu,UniSpeechForCTC:()=>So,UniSpeechForSequenceClassification:()=>su,UniSpeechModel:()=>$o,UniSpeechPreTrainedModel:()=>xi,UniSpeechSatForAudioFrameClassification:()=>au,UniSpeechSatForCTC:()=>Od,UniSpeechSatForSequenceClassification:()=>ou,UniSpeechSatModel:()=>ko,UniSpeechSatPreTrainedModel:()=>Wi,ViTForImageClassification:()=>Ir,ViTMAEModel:()=>il,ViTMAEPreTrainedModel:()=>nl,ViTMSNForImageClassification:()=>ol,ViTMSNModel:()=>sl,ViTMSNPreTrainedModel:()=>Js,ViTModel:()=>el,ViTPreTrainedModel:()=>Ja,VisionEncoderDecoderModel:()=>Ss,VitMatteForImageMatting:()=>Ri,VitMattePreTrainedModel:()=>cl,VitsModel:()=>Do,VitsModelOutput:()=>hd,VitsPreTrainedModel:()=>$u,Wav2Vec2BertForCTC:()=>Ao,Wav2Vec2BertForSequenceClassification:()=>Bd,Wav2Vec2BertModel:()=>lu,Wav2Vec2BertPreTrainedModel:()=>Po,Wav2Vec2ForAudioFrameClassification:()=>tu,Wav2Vec2ForCTC:()=>Fd,Wav2Vec2ForSequenceClassification:()=>Eo,Wav2Vec2Model:()=>eu,Wav2Vec2PreTrainedModel:()=>ei,WavLMForAudioFrameClassification:()=>mu,WavLMForCTC:()=>pu,WavLMForSequenceClassification:()=>hu,WavLMForXVector:()=>fu,WavLMModel:()=>cu,WavLMPreTrainedModel:()=>Ti,WeSpeakerResNetModel:()=>iu,WeSpeakerResNetPreTrainedModel:()=>fs,WhisperForConditionalGeneration:()=>$s,WhisperModel:()=>Kt,WhisperPreTrainedModel:()=>ht,XLMForQuestionAnswering:()=>Yr,XLMForSequenceClassification:()=>Jt,XLMForTokenClassification:()=>pn,XLMModel:()=>kn,XLMPreTrainedModel:()=>ln,XLMRobertaForMaskedLM:()=>Ot,XLMRobertaForQuestionAnswering:()=>Qn,XLMRobertaForSequenceClassification:()=>br,XLMRobertaForTokenClassification:()=>ii,XLMRobertaModel:()=>Br,XLMRobertaPreTrainedModel:()=>_r,XLMWithLMHeadModel:()=>Rn,XVectorOutput:()=>cd,YolosForObjectDetection:()=>Yl,YolosModel:()=>Xl,YolosObjectDetectionOutput:()=>Ad,YolosPreTrainedModel:()=>Ui});var E=T("./src/configs.js"),Z=T("./src/backends/onnx.js"),re=T("./src/utils/dtypes.js"),fe=T("./src/utils/generic.js"),Ee=T("./src/utils/core.js"),j=T("./src/utils/hub.js"),O=T("./src/utils/constants.js"),M=T("./src/generation/logits_process.js"),N=T("./src/generation/configuration_utils.js"),K=T("./src/utils/tensor.js"),ae=T("./src/utils/maths.js"),$e=T("./src/generation/stopping_criteria.js"),Te=T("./src/generation/logits_sampler.js"),U=T("./src/env.js"),ue=T("./src/models/whisper/generation_whisper.js"),ke=T("./src/models/whisper/common_whisper.js");const te={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7},ee=new Map,q=new Map,B=new Map;async function H(_,w,le){const qe=le.config?.["transformers.js_config"]??{};let Je=le.device??qe.device;Je&&typeof Je!="string"&&(Je.hasOwnProperty(w)?Je=Je[w]:(console.warn(`device not specified for "${w}". Using the default device.`),Je=null));const ft=Je??(U.apis.IS_NODE_ENV?"cpu":"wasm"),Bt=(0,Z.deviceToExecutionProviders)(ft);let It=le.dtype??qe.dtype;typeof It!="string"&&(It&&It.hasOwnProperty(w)?It=It[w]:(It=re.DEFAULT_DEVICE_DTYPE_MAPPING[ft]??re.DATA_TYPES.fp32,console.warn(`dtype not specified for "${w}". Using the default dtype (${It}) for this device (${ft}).`)));const Qt=It;if(re.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(Qt)){if(Qt===re.DATA_TYPES.fp16&&ft==="webgpu"&&!await(0,re.isWebGpuFp16Supported)())throw new Error(`The device (${ft}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${Qt}. Should be one of: ${Object.keys(re.DATA_TYPES).join(", ")}`);const wr=qe.kv_cache_dtype?typeof qe.kv_cache_dtype=="string"?qe.kv_cache_dtype:qe.kv_cache_dtype[Qt]??"float32":void 0;if(wr&&!["float32","float16"].includes(wr))throw new Error(`Invalid kv_cache_dtype: ${wr}. Should be one of: float32, float16`);const Ur={dtype:Qt,kv_cache_dtype:wr},Dr=re.DEFAULT_DTYPE_SUFFIX_MAPPING[Qt],$r=`${le.subfolder??""}/${w}${Dr}.onnx`,tr={...le.session_options};tr.executionProviders??=Bt;const rn=qe.free_dimension_overrides;rn?tr.freeDimensionOverrides??=rn:ft.startsWith("webnn")&&!tr.freeDimensionOverrides&&console.warn('WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.');const Mr=(0,j.getModelFile)(_,$r,!0,le),vr=le.use_external_data_format??qe.use_external_data_format;let Vr=[];if(vr&&(vr===!0||typeof vr=="object"&&vr.hasOwnProperty(w)&&vr[w]===!0)){if(U.apis.IS_NODE_ENV)throw new Error("External data format is not yet supported in Node.js");const Gr=`${w}${Dr}.onnx_data`,sn=`${le.subfolder??""}/${Gr}`;Vr.push(new Promise(async(fn,en)=>{const on=await(0,j.getModelFile)(_,sn,!0,le);fn({path:Gr,data:on})}))}else tr.externalData!==void 0&&(Vr=tr.externalData.map(async Gr=>{if(typeof Gr.data=="string"){const sn=await(0,j.getModelFile)(_,Gr.data,!0,le);return{...Gr,data:sn}}return Gr}));if(Vr.length>0&&(tr.externalData=await Promise.all(Vr)),ft==="webgpu"){const Gr=(0,E.getKeyValueShapes)(le.config,{prefix:"present"});if(Object.keys(Gr).length>0&&!(0,Z.isONNXProxy)()){const sn={};for(const fn in Gr)sn[fn]="gpu-buffer";tr.preferredOutputLocation=sn}}return{buffer:await Mr,session_options:tr,session_config:Ur}}async function I(_,w,le){return Object.fromEntries(await Promise.all(Object.keys(w).map(async qe=>{const{buffer:Je,session_options:ft,session_config:Bt}=await H(_,w[qe],le),It=await(0,Z.createInferenceSession)(Je,ft,Bt);return[qe,It]})))}async function Me(_,w,le){return Object.fromEntries(await Promise.all(Object.keys(w).map(async qe=>{const Je=await(0,j.getModelJSON)(_,w[qe],!1,le);return[qe,Je]})))}function xe(_,w){const le=Object.create(null),qe=[];for(const Bt of _.inputNames){const It=w[Bt];if(!(It instanceof K.Tensor)){qe.push(Bt);continue}le[Bt]=(0,Z.isONNXProxy)()?It.clone():It}if(qe.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${qe.join(", ")}.`);const Je=Object.keys(w).length,ft=_.inputNames.length;if(Je>ft){let Bt=Object.keys(w).filter(It=>!_.inputNames.includes(It));console.warn(`WARNING: Too many inputs were provided (${Je} > ${ft}). The following inputs will be ignored: "${Bt.join(", ")}".`)}return le}async function Ce(_,w){const le=xe(_,w);try{const qe=Object.fromEntries(Object.entries(le).map(([ft,Bt])=>[ft,Bt.ort_tensor]));let Je=await _.run(qe);return Je=Ve(Je),Je}catch(qe){throw console.error(`An error occurred during model execution: "${qe}".`),console.error("Inputs given to model:",le),qe}}function Ve(_){for(let w in _)(0,Z.isONNXTensor)(_[w])?_[w]=new K.Tensor(_[w]):typeof _[w]=="object"&&Ve(_[w]);return _}function Ue(_){if(_ instanceof K.Tensor)return _;if(_.length===0)throw Error("items must be non-empty");if(Array.isArray(_[0])){if(_.some(w=>w.length!==_[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new K.Tensor("int64",BigInt64Array.from(_.flat().map(w=>BigInt(w))),[_.length,_[0].length])}else return new K.Tensor("int64",BigInt64Array.from(_.map(w=>BigInt(w))),[1,_.length])}function Ne(_){return new K.Tensor("bool",[_],[1])}async function Pe(_,w){let{encoder_outputs:le,input_ids:qe,decoder_input_ids:Je,...ft}=w;if(!le){const It=(0,Ee.pick)(w,_.sessions.model.inputNames);le=(await Ae(_,It)).last_hidden_state}return ft.input_ids=Je,ft.encoder_hidden_states=le,_.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(ft.encoder_attention_mask=w.attention_mask),await ie(_,ft,!0)}async function Ae(_,w){const le=_.sessions.model,qe=(0,Ee.pick)(w,le.inputNames);if(le.inputNames.includes("inputs_embeds")&&!qe.inputs_embeds){if(!w.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");qe.inputs_embeds=await _.encode_text({input_ids:w.input_ids})}return le.inputNames.includes("token_type_ids")&&!qe.token_type_ids&&(qe.token_type_ids=new K.Tensor("int64",new BigInt64Array(qe.input_ids.data.length),qe.input_ids.dims)),await Ce(le,qe)}async function ie(_,w,le=!1){const qe=_.sessions[le?"decoder_model_merged":"model"],{past_key_values:Je,...ft}=w;qe.inputNames.includes("use_cache_branch")&&(ft.use_cache_branch=Ne(!!Je)),qe.inputNames.includes("position_ids")&&ft.attention_mask&&!ft.position_ids&&(ft.position_ids=se(ft,Je)),_.addPastKeyValues(ft,Je);const Bt=(0,Ee.pick)(ft,qe.inputNames);return await Ce(qe,Bt)}async function F(_,{input_ids:w=null,attention_mask:le=null,pixel_values:qe=null,position_ids:Je=null,inputs_embeds:ft=null,past_key_values:Bt=null,generation_config:It=null,logits_processor:Qt=null,...wr}){if(!ft){if(ft=await _.encode_text({input_ids:w}),qe&&w.dims[1]!==1){const Dr=await _.encode_image({pixel_values:qe});({inputs_embeds:ft,attention_mask:le}=_._merge_input_ids_with_image_features({image_features:Dr,inputs_embeds:ft,input_ids:w,attention_mask:le}))}else if(Bt&&qe&&w.dims[1]===1){const Dr=w.dims[1],$r=Object.values(Bt)[0].dims.at(-2);le=(0,K.cat)([(0,K.ones)([w.dims[0],$r]),le.slice(null,[le.dims[1]-Dr,le.dims[1]])],1)}}return await ie(_,{inputs_embeds:ft,past_key_values:Bt,attention_mask:le,position_ids:Je,generation_config:It,logits_processor:Qt},!0)}function se(_,w=null){const{input_ids:le,inputs_embeds:qe,attention_mask:Je}=_,[ft,Bt]=Je.dims,It=new BigInt64Array(Je.data.length);for(let wr=0;wr<ft;++wr){const Ur=wr*Bt;let Dr=BigInt(0);for(let $r=0;$r<Bt;++$r){const tr=Ur+$r;Je.data[tr]===0n?It[tr]=BigInt(1):(It[tr]=Dr,Dr+=Je.data[tr])}}let Qt=new K.Tensor("int64",It,Je.dims);if(w){const wr=-(le??qe).dims.at(1);Qt=Qt.slice(null,[wr,null])}return Qt}function _e(_,w,le,qe){if(le.past_key_values){const Je=Object.values(le.past_key_values)[0].dims.at(-2),{input_ids:ft,attention_mask:Bt}=le;if(!(Bt&&Bt.dims[1]>ft.dims[1])){if(Je<ft.dims[1])le.input_ids=ft.slice(null,[Je,null]);else if(_.config.image_token_index!=null&&ft.data.some(It=>It==_.config.image_token_index)){const It=_.config.num_image_tokens;if(!It)throw new Error("`num_image_tokens` is missing in the model configuration.");const Qt=ft.dims[1]-(Je-It);le.input_ids=ft.slice(null,[-Qt,null]),le.attention_mask=(0,K.ones)([1,Je+Qt])}}}return le}function Oe(_,w,le,qe){return le.past_key_values&&(w=w.map(Je=>[Je.at(-1)])),{...le,decoder_input_ids:Ue(w)}}function nt(_,...w){return _.config.is_encoder_decoder?Oe(_,...w):_e(_,...w)}class de extends fe.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(w,le,qe){super(),this.config=w,this.sessions=le,this.configs=qe;const Je=B.get(this.constructor),ft=ee.get(Je);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,ft){case te.DecoderOnly:this.can_generate=!0,this._forward=ie,this._prepare_inputs_for_generation=_e;break;case te.Seq2Seq:case te.Vision2Seq:case te.Musicgen:this.can_generate=!0,this._forward=Pe,this._prepare_inputs_for_generation=Oe;break;case te.EncoderDecoder:this._forward=Pe;break;case te.ImageTextToText:this.can_generate=!0,this._forward=F,this._prepare_inputs_for_generation=nt;break;default:this._forward=Ae;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const w=[];for(const le of Object.values(this.sessions))le?.handler?.dispose&&w.push(le.handler.dispose());return await Promise.all(w)}static async from_pretrained(w,{progress_callback:le=null,config:qe=null,cache_dir:Je=null,local_files_only:ft=!1,revision:Bt="main",model_file_name:It=null,subfolder:Qt="onnx",device:wr=null,dtype:Ur=null,use_external_data_format:Dr=null,session_options:$r={}}={}){let tr={progress_callback:le,config:qe,cache_dir:Je,local_files_only:ft,revision:Bt,model_file_name:It,subfolder:Qt,device:wr,dtype:Ur,use_external_data_format:Dr,session_options:$r};const rn=B.get(this),Mr=ee.get(rn);qe=tr.config=await E.AutoConfig.from_pretrained(w,tr);let vr;if(Mr===te.DecoderOnly)vr=await Promise.all([I(w,{model:tr.model_file_name??"model"},tr),Me(w,{generation_config:"generation_config.json"},tr)]);else if(Mr===te.Seq2Seq||Mr===te.Vision2Seq)vr=await Promise.all([I(w,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},tr),Me(w,{generation_config:"generation_config.json"},tr)]);else if(Mr===te.MaskGeneration)vr=await Promise.all([I(w,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},tr)]);else if(Mr===te.EncoderDecoder)vr=await Promise.all([I(w,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},tr)]);else if(Mr===te.ImageTextToText){const Vr={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};qe.is_encoder_decoder&&(Vr.model="encoder_model"),vr=await Promise.all([I(w,Vr,tr),Me(w,{generation_config:"generation_config.json"},tr)])}else Mr===te.Musicgen?vr=await Promise.all([I(w,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},tr),Me(w,{generation_config:"generation_config.json"},tr)]):(Mr!==te.EncoderOnly&&console.warn(`Model type for '${rn??qe?.model_type}' not found, assuming encoder-only architecture. Please report this at ${O.GITHUB_ISSUE_URL}.`),vr=await Promise.all([I(w,{model:tr.model_file_name??"model"},tr)]));return new this(qe,...vr)}async _call(w){return await this.forward(w)}async forward(w){return await this._forward(this,w)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(w){const le=new M.LogitsProcessorList;return w.temperature!==null&&w.temperature!==1&&le.push(new M.TemperatureLogitsWarper(w.temperature)),w.top_k!==null&&w.top_k!==0&&le.push(new M.TopKLogitsWarper(w.top_k)),w.top_p!==null&&w.top_p<1&&le.push(new M.TopPLogitsWarper(w.top_p)),le}_get_logits_processor(w,le,qe=null){const Je=new M.LogitsProcessorList;if(w.repetition_penalty!==null&&w.repetition_penalty!==1&&Je.push(new M.RepetitionPenaltyLogitsProcessor(w.repetition_penalty)),w.no_repeat_ngram_size!==null&&w.no_repeat_ngram_size>0&&Je.push(new M.NoRepeatNGramLogitsProcessor(w.no_repeat_ngram_size)),w.bad_words_ids!==null&&Je.push(new M.NoBadWordsLogitsProcessor(w.bad_words_ids,w.eos_token_id)),w.min_length!==null&&w.eos_token_id!==null&&w.min_length>0&&Je.push(new M.MinLengthLogitsProcessor(w.min_length,w.eos_token_id)),w.min_new_tokens!==null&&w.eos_token_id!==null&&w.min_new_tokens>0&&Je.push(new M.MinNewTokensLengthLogitsProcessor(le,w.min_new_tokens,w.eos_token_id)),w.forced_bos_token_id!==null&&Je.push(new M.ForcedBOSTokenLogitsProcessor(w.forced_bos_token_id)),w.forced_eos_token_id!==null&&Je.push(new M.ForcedEOSTokenLogitsProcessor(w.max_length,w.forced_eos_token_id)),w.begin_suppress_tokens!==null){const ft=le>1||w.forced_bos_token_id===null?le:le+1;Je.push(new M.SuppressTokensAtBeginLogitsProcessor(w.begin_suppress_tokens,ft))}return w.guidance_scale!==null&&w.guidance_scale>1&&Je.push(new M.ClassifierFreeGuidanceLogitsProcessor(w.guidance_scale)),qe!==null&&Je.extend(qe),Je}_prepare_generation_config(w,le,qe=N.GenerationConfig){const Je={...this.config};for(const Bt of["decoder","generator","text_config"])Bt in Je&&Object.assign(Je,Je[Bt]);const ft=new qe(Je);return Object.assign(ft,this.generation_config??{}),w&&Object.assign(ft,w),le&&Object.assign(ft,(0,Ee.pick)(le,Object.getOwnPropertyNames(ft))),ft}_get_stopping_criteria(w,le=null){const qe=new $e.StoppingCriteriaList;return w.max_length!==null&&qe.push(new $e.MaxLengthCriteria(w.max_length,this.config.max_position_embeddings??null)),w.eos_token_id!==null&&qe.push(new $e.EosTokenCriteria(w.eos_token_id)),le&&qe.extend(le),qe}_validate_model_class(){if(!this.can_generate){const w=[Xo,Yo,Ko,qo],le=B.get(this.constructor),qe=new Set,Je=this.config.model_type;for(const Bt of w){const It=Bt.get(Je);It&&qe.add(It[0])}let ft=`The current model class (${le}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw qe.size>0&&(ft+=` Please use the following class instead: ${[...qe].join(", ")}`),Error(ft)}}prepare_inputs_for_generation(...w){return this._prepare_inputs_for_generation(this,...w)}_update_model_kwargs_for_generation({generated_input_ids:w,outputs:le,model_inputs:qe,is_encoder_decoder:Je}){return qe.past_key_values=this.getPastKeyValues(le,qe.past_key_values),qe.input_ids=new K.Tensor("int64",w.flat(),[w.length,1]),Je||(qe.attention_mask=(0,K.cat)([qe.attention_mask,(0,K.ones)([qe.attention_mask.dims[0],1])],1)),qe.position_ids=null,qe}_prepare_model_inputs({inputs:w,bos_token_id:le,model_kwargs:qe}){const Je=(0,Ee.pick)(qe,this.forward_params),ft=this.main_input_name;if(ft in Je){if(w)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Je[ft]=w;return{inputs_tensor:Je[ft],model_inputs:Je,model_input_name:ft}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:w,model_inputs:le,model_input_name:qe,generation_config:Je}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!le.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:Bt,pixel_values:It,attention_mask:Qt,...wr}=le,Ur=await this._prepare_inputs_embeds(le);le={...wr,...(0,Ee.pick)(Ur,["inputs_embeds","attention_mask"])}}let{last_hidden_state:ft}=await Ae(this,le);if(Je.guidance_scale!==null&&Je.guidance_scale>1)ft=(0,K.cat)([ft,(0,K.full_like)(ft,0)],0),"attention_mask"in le&&(le.attention_mask=(0,K.cat)([le.attention_mask,(0,K.zeros_like)(le.attention_mask)],0));else if(le.decoder_input_ids){const Bt=Ue(le.decoder_input_ids).dims[0];if(Bt!==ft.dims[0]){if(ft.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${ft.dims[0]}) than the decoder inputs (${Bt}).`);ft=(0,K.cat)(Array.from({length:Bt},()=>ft),0)}}return le.encoder_outputs=ft,le}_prepare_decoder_input_ids_for_generation({batch_size:w,model_input_name:le,model_kwargs:qe,decoder_start_token_id:Je,bos_token_id:ft,generation_config:Bt}){let{decoder_input_ids:It,...Qt}=qe;if(!(It instanceof K.Tensor)){if(It)Array.isArray(It[0])||(It=Array.from({length:w},()=>It));else if(Je??=ft,this.config.model_type==="musicgen")It=Array.from({length:w*this.config.decoder.num_codebooks},()=>[Je]);else if(Array.isArray(Je)){if(Je.length!==w)throw new Error(`\`decoder_start_token_id\` expcted to have length ${w} but got ${Je.length}`);It=Je}else It=Array.from({length:w},()=>[Je]);It=Ue(It)}return qe.decoder_attention_mask=(0,K.ones_like)(It),{input_ids:It,model_inputs:Qt}}async generate({inputs:w=null,generation_config:le=null,logits_processor:qe=null,stopping_criteria:Je=null,streamer:ft=null,...Bt}){this._validate_model_class(),le=this._prepare_generation_config(le,Bt);let{inputs_tensor:It,model_inputs:Qt,model_input_name:wr}=this._prepare_model_inputs({inputs:w,model_kwargs:Bt});const Ur=this.config.is_encoder_decoder;Ur&&("encoder_outputs"in Qt||(Qt=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:It,model_inputs:Qt,model_input_name:wr,generation_config:le})));let Dr;Ur?{input_ids:Dr,model_inputs:Qt}=this._prepare_decoder_input_ids_for_generation({batch_size:Qt[wr].dims.at(0),model_input_name:wr,model_kwargs:Qt,decoder_start_token_id:le.decoder_start_token_id,bos_token_id:le.bos_token_id,generation_config:le}):Dr=Qt[wr];let $r=Dr.dims.at(-1);le.max_new_tokens!==null&&(le.max_length=$r+le.max_new_tokens);const tr=this._get_logits_processor(le,$r,qe),rn=this._get_stopping_criteria(le,Je),Mr=Qt[wr].dims.at(0),vr=Te.LogitsSampler.getSampler(le),Vr=new Array(Mr).fill(0),dn=Dr.tolist();ft&&ft.put(dn);let Gr,sn={};for(;;){if(Qt=this.prepare_inputs_for_generation(dn,Qt,le),Gr=await this.forward(Qt),le.output_attentions&&le.return_dict_in_generate){const Bn=this.getAttentions(Gr);for(const Ki in Bn)Ki in sn||(sn[Ki]=[]),sn[Ki].push(Bn[Ki])}const on=Gr.logits.slice(null,-1,null),Jo=tr(dn,on),Hi=[];for(let Bn=0;Bn<Jo.dims.at(0);++Bn){const Ki=Jo[Bn],_c=await vr(Ki);for(const[wc,yc]of _c){const bc=BigInt(wc);Vr[Bn]+=yc,dn[Bn].push(bc),Hi.push([bc]);break}}if(ft&&ft.put(Hi),rn(dn).every(Bn=>Bn))break;Qt=this._update_model_kwargs_for_generation({generated_input_ids:Hi,outputs:Gr,model_inputs:Qt,is_encoder_decoder:Ur})}ft&&ft.end();const fn=this.getPastKeyValues(Gr,Qt.past_key_values,!0),en=new K.Tensor("int64",dn.flat(),[dn.length,dn[0].length]);if(le.return_dict_in_generate)return{sequences:en,past_key_values:fn,...sn};for(const on of Object.values(Gr))on.location==="gpu-buffer"&&on.dispose();return en}getPastKeyValues(w,le,qe=!1){const Je=Object.create(null);for(const ft in w)if(ft.startsWith("present")){const Bt=ft.replace("present","past_key_values"),It=ft.includes("encoder");if(It&&le?Je[Bt]=le[Bt]:Je[Bt]=w[ft],le&&(!It||qe)){const Qt=le[Bt];Qt.location==="gpu-buffer"&&Qt.dispose()}}return Je}getAttentions(w){const le={};for(const qe of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Je in w)Je.startsWith(qe)&&(qe in le||(le[qe]=[]),le[qe].push(w[Je]));return le}addPastKeyValues(w,le){if(le)Object.assign(w,le);else{const Je=(this.sessions.decoder_model_merged??this.sessions.model)?.config?.kv_cache_dtype??"float32",ft=Je==="float16"?new Uint16Array:[],Bt=(0,E.getKeyValueShapes)(this.config);for(const It in Bt)w[It]=new K.Tensor(Je,ft,Bt[It])}}async encode_image({pixel_values:w}){const le=(await Ce(this.sessions.vision_encoder,{pixel_values:w})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${le.dims[1]}).`),this.config.num_image_tokens=le.dims[1]),le}async encode_text({input_ids:w}){return(await Ce(this.sessions.embed_tokens,{input_ids:w})).inputs_embeds}}class Re{}class it extends Re{constructor({last_hidden_state:w,hidden_states:le=null,attentions:qe=null}){super(),this.last_hidden_state=w,this.hidden_states=le,this.attentions=qe}}class He extends de{}class wt extends He{}class xt extends He{async _call(w){return new un(await super._call(w))}}class et extends He{async _call(w){return new cr(await super._call(w))}}class X extends He{async _call(w){return new nn(await super._call(w))}}class Be extends He{async _call(w){return new _n(await super._call(w))}}class st extends de{}class lt extends st{}class rt extends de{}class Qe extends rt{}class _t extends rt{async _call(w){return new un(await super._call(w))}}class yt extends rt{async _call(w){return new cr(await super._call(w))}}class Lt extends rt{async _call(w){return new nn(await super._call(w))}}class kt extends rt{async _call(w){return new _n(await super._call(w))}}class $ extends de{}class J extends ${}class z extends ${async _call(w){return new un(await super._call(w))}}class pe extends ${async _call(w){return new cr(await super._call(w))}}class Se extends ${async _call(w){return new nn(await super._call(w))}}class dt extends ${async _call(w){return new _n(await super._call(w))}}class at extends de{}class At extends at{}class pt extends at{async _call(w){return new un(await super._call(w))}}class bt extends at{async _call(w){return new cr(await super._call(w))}}class C extends at{async _call(w){return new nn(await super._call(w))}}class c extends at{async _call(w){return new _n(await super._call(w))}}class m extends de{}class W extends m{}class we extends m{async _call(w){return new un(await super._call(w))}}class Fe extends m{async _call(w){return new cr(await super._call(w))}}class Xe extends m{async _call(w){return new nn(await super._call(w))}}class sr extends m{async _call(w){return new _n(await super._call(w))}}class ot extends de{}class V extends ot{}class ve extends ot{async _call(w){return new un(await super._call(w))}}class Ie extends ot{async _call(w){return new cr(await super._call(w))}}class je extends ot{async _call(w){return new nn(await super._call(w))}}class Ze extends ot{async _call(w){return new _n(await super._call(w))}}class mt extends de{}class Ct extends mt{}class Et extends mt{async _call(w){return new un(await super._call(w))}}class Ft extends mt{async _call(w){return new cr(await super._call(w))}}class Tt extends mt{async _call(w){return new nn(await super._call(w))}}class Ut extends mt{async _call(w){return new _n(await super._call(w))}}class Wt extends de{}class Nt extends Wt{}class We extends Wt{async _call(w){return new cr(await super._call(w))}}class Ge extends Wt{async _call(w){return new nn(await super._call(w))}}class vt extends Wt{async _call(w){return new _n(await super._call(w))}}class Ht extends Wt{async _call(w){return new un(await super._call(w))}}class ar extends de{}class Or extends ar{}class jr extends ar{async _call(w){return new un(await super._call(w))}}class Er extends ar{async _call(w){return new cr(await super._call(w))}}class zr extends ar{async _call(w){return new nn(await super._call(w))}}class Ar extends de{}class zn extends Ar{}class Nr extends Ar{async _call(w){return new un(await super._call(w))}}class mi extends Ar{async _call(w){return new cr(await super._call(w))}}class ki extends Ar{async _call(w){return new _n(await super._call(w))}}class Xn extends de{}class Pi extends Xn{}class Ai extends Xn{async _call(w){return new un(await super._call(w))}}class Ii extends Xn{async _call(w){return new cr(await super._call(w))}}class Fi extends Xn{async _call(w){return new nn(await super._call(w))}}class Oi extends Xn{async _call(w){return new _n(await super._call(w))}}class ti extends de{}class Yn extends ti{}class $n extends ti{async _call(w){return new un(await super._call(w))}}class Ln extends ti{async _call(w){return new cr(await super._call(w))}}class gi extends ti{async _call(w){return new _n(await super._call(w))}}class On extends de{}class _i extends On{}class wi extends On{async _call(w){return new cr(await super._call(w))}}class yi extends On{async _call(w){return new _n(await super._call(w))}}class rr extends On{async _call(w){return new un(await super._call(w))}}class ri extends de{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Bi extends ri{}class Di extends ri{}class bi extends de{}class zi extends bi{}class Li extends bi{}class ni extends de{}class ns extends ni{}class ye extends ni{}class g extends de{}class G extends g{}class ce extends g{}class me extends g{async _call(w){return new cr(await super._call(w))}}class Le extends de{}class ct extends Le{}class Pt extends Le{}class Dt extends Le{async _call(w){return new cr(await super._call(w))}}class zt extends Le{}class $t extends de{}class gr extends $t{}class pr extends $t{}class Cr extends de{}class Xr extends Cr{}class bn extends Cr{}class hr extends de{}class kr extends hr{}class xn extends hr{async _call(w){return new un(await super._call(w))}}class Sn extends hr{async _call(w){return new cr(await super._call(w))}}class De extends hr{async _call(w){return new nn(await super._call(w))}}class Jr extends hr{async _call(w){return new _n(await super._call(w))}}class ln extends de{}class kn extends ln{}class Rn extends ln{async _call(w){return new un(await super._call(w))}}class Jt extends ln{async _call(w){return new cr(await super._call(w))}}class pn extends ln{async _call(w){return new nn(await super._call(w))}}class Yr extends ln{async _call(w){return new _n(await super._call(w))}}class _r extends de{}class Br extends _r{}class Ot extends _r{async _call(w){return new un(await super._call(w))}}class br extends _r{async _call(w){return new cr(await super._call(w))}}class ii extends _r{async _call(w){return new nn(await super._call(w))}}class Qn extends _r{async _call(w){return new _n(await super._call(w))}}class Nn extends de{}class qt extends Nn{}class is extends Nn{}class ht extends de{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Kt extends ht{}class $s extends ht{_prepare_generation_config(w,le){return super._prepare_generation_config(w,le,ue.WhisperGenerationConfig)}_retrieve_init_tokens(w){const le=[w.decoder_start_token_id];let qe=w.language;const Je=w.task;if(w.is_multilingual){qe||(console.warn("No language specified - defaulting to English (en)."),qe="en");const Bt=`<|${(0,ke.whisper_language_to_code)(qe)}|>`;le.push(w.lang_to_id[Bt]),le.push(w.task_to_id[Je??"transcribe"])}else if(qe||Je)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!w.return_timestamps&&w.no_timestamps_token_id&&le.at(-1)!==w.no_timestamps_token_id?le.push(w.no_timestamps_token_id):w.return_timestamps&&le.at(-1)===w.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),le.pop()),le.filter(ft=>ft!=null)}async generate({inputs:w=null,generation_config:le=null,logits_processor:qe=null,stopping_criteria:Je=null,...ft}){le=this._prepare_generation_config(le,ft);const Bt=ft.decoder_input_ids??this._retrieve_init_tokens(le);if(le.return_timestamps&&(qe??=new M.LogitsProcessorList,qe.push(new M.WhisperTimeStampLogitsProcessor(le,Bt))),le.begin_suppress_tokens&&(qe??=new M.LogitsProcessorList,qe.push(new M.SuppressTokensAtBeginLogitsProcessor(le.begin_suppress_tokens,Bt.length))),le.return_token_timestamps){if(!le.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");le.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),le.output_attentions=!0,le.return_dict_in_generate=!0}const It=await super.generate({inputs:w,generation_config:le,logits_processor:qe,decoder_input_ids:Bt,...ft});return le.return_token_timestamps&&(It.token_timestamps=this._extract_token_timestamps(It,le.alignment_heads,le.num_frames)),It}_extract_token_timestamps(w,le,qe=null,Je=.02){if(!w.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");qe==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let ft=this.config.median_filter_width;ft===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),ft=7);const Bt=w.cross_attentions,It=Array.from({length:this.config.decoder_layers},(Mr,vr)=>(0,K.cat)(Bt.map(Vr=>Vr[vr]),2)),Qt=(0,K.stack)(le.map(([Mr,vr])=>{if(Mr>=It.length)throw new Error(`Layer index ${Mr} is out of bounds for cross attentions (length ${It.length}).`);return qe?It[Mr].slice(null,vr,null,[0,qe]):It[Mr].slice(null,vr)})).transpose(1,0,2,3),[wr,Ur]=(0,K.std_mean)(Qt,-2,0,!0),Dr=Qt.clone();for(let Mr=0;Mr<Dr.dims[0];++Mr){const vr=Dr[Mr];for(let Vr=0;Vr<vr.dims[0];++Vr){const dn=vr[Vr],Gr=wr[Mr][Vr][0].data,sn=Ur[Mr][Vr][0].data;for(let fn=0;fn<dn.dims[0];++fn){let en=dn[fn].data;for(let on=0;on<en.length;++on)en[on]=(en[on]-sn[on])/Gr[on];en.set((0,ae.medianFilter)(en,ft))}}}const $r=[(0,K.mean)(Dr,1)],tr=w.sequences.dims,rn=new K.Tensor("float32",new Float32Array(tr[0]*tr[1]),tr);for(let Mr=0;Mr<tr[0];++Mr){const vr=$r[Mr].neg().squeeze_(0),[Vr,dn]=(0,ae.dynamic_time_warping)(vr.tolist()),Gr=Array.from({length:Vr.length-1},(en,on)=>Vr[on+1]-Vr[on]),sn=(0,Ee.mergeArrays)([1],Gr).map(en=>!!en),fn=[];for(let en=0;en<sn.length;++en)sn[en]&&fn.push(dn[en]*Je);rn[Mr].data.set(fn,1)}return rn}}class Ss extends de{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class da extends de{forward_params=["input_ids","pixel_values","attention_mask","position_ids","past_key_values"]}class Mi extends da{_merge_input_ids_with_image_features({inputs_embeds:w,image_features:le,input_ids:qe,attention_mask:Je}){const ft=this.config.image_token_index,It=qe.tolist().map($r=>$r.findIndex(tr=>tr==ft)),Qt=It.every($r=>$r===-1),wr=It.every($r=>$r!==-1);if(!Qt&&!wr)throw new Error("Every input should contain either 0 or 1 image token.");if(Qt)return{inputs_embeds:w,attention_mask:Je};const Ur=[],Dr=[];for(let $r=0;$r<It.length;++$r){const tr=It[$r],rn=w[$r],Mr=le[$r],vr=Je[$r];Ur.push((0,K.cat)([rn.slice([0,tr]),Mr,rn.slice([tr+1,rn.dims[0]])],0)),Dr.push((0,K.cat)([vr.slice([0,tr]),(0,K.ones)([Mr.dims[0]]),vr.slice([tr+1,vr.dims[0]])],0))}return{inputs_embeds:(0,K.stack)(Ur,0),attention_mask:(0,K.stack)(Dr,0)}}}class fr extends Mi{}class ca extends de{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class ks extends ca{_merge_input_ids_with_image_features({inputs_embeds:w,image_features:le,input_ids:qe,attention_mask:Je}){return{inputs_embeds:(0,K.cat)([le,w],1),attention_mask:(0,K.cat)([(0,K.ones)(le.dims.slice(0,2)),Je],1)}}async _prepare_inputs_embeds({input_ids:w,pixel_values:le,inputs_embeds:qe,attention_mask:Je}){if(!w&&!le)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let ft,Bt;return w&&(ft=await this.encode_text({input_ids:w})),le&&(Bt=await this.encode_image({pixel_values:le})),ft&&Bt?{inputs_embeds:qe,attention_mask:Je}=this._merge_input_ids_with_image_features({inputs_embeds:ft,image_features:Bt,input_ids:w,attention_mask:Je}):qe=ft||Bt,{inputs_embeds:qe,attention_mask:Je}}async forward({input_ids:w,pixel_values:le,attention_mask:qe,decoder_input_ids:Je,decoder_attention_mask:ft,encoder_outputs:Bt,past_key_values:It,inputs_embeds:Qt,decoder_inputs_embeds:wr}){if(Qt||({inputs_embeds:Qt,attention_mask:qe}=await this._prepare_inputs_embeds({input_ids:w,pixel_values:le,inputs_embeds:Qt,attention_mask:qe})),!Bt){let{last_hidden_state:$r}=await Ae(this,{inputs_embeds:Qt,attention_mask:qe});Bt=$r}if(!wr){if(!Je)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");wr=await this.encode_text({input_ids:Je})}return await ie(this,{inputs_embeds:wr,attention_mask:ft,encoder_attention_mask:qe,encoder_hidden_states:Bt,past_key_values:It},!0)}}class si extends de{}class pa extends si{}class Ed extends si{static async from_pretrained(w,le={}){return le.model_file_name??="text_model",super.from_pretrained(w,le)}}class Mn extends si{static async from_pretrained(w,le={}){return le.model_file_name??="text_model",super.from_pretrained(w,le)}}class Cd extends si{static async from_pretrained(w,le={}){return le.model_file_name??="vision_model",super.from_pretrained(w,le)}}class ha extends si{static async from_pretrained(w,le={}){return le.model_file_name??="vision_model",super.from_pretrained(w,le)}}class jn extends de{}class fa extends jn{}class ma extends jn{static async from_pretrained(w,le={}){return le.model_file_name??="text_model",super.from_pretrained(w,le)}}class ga extends si{static async from_pretrained(w,le={}){return le.model_file_name??="vision_model",super.from_pretrained(w,le)}}class _a extends de{}class wa extends _a{}class Ps extends de{}class ya extends Ps{}class ba extends Ps{}class As extends de{}class Ma extends As{}class Pn extends As{}class Is extends de{}class va extends Is{}class xa extends Is{}class Fs extends de{}class Ta extends Fs{}class Ea extends Fs{}class Os extends de{}class Ca extends Os{}class $a extends Os{}class Bs extends de{}class $d extends Bs{}class An extends Bs{}class Ds extends de{}class ss extends Ds{}class zs extends Ds{}class Tn extends de{}class Sa extends Tn{}class ka extends Tn{}class Ls extends de{}class Pa extends Ls{}class Aa extends Ls{}class Rs extends de{}class Ia extends Rs{}class Fa extends Rs{}class Ns extends de{}class Oa extends Ns{}class In extends Ns{}class js extends de{}class Ba extends js{}class Da extends js{}class Us extends de{}class za extends Us{}class La extends Us{}class Vs extends de{}class Ra extends Vs{}class Na extends Vs{}class Ws extends de{}class Gs extends Ws{}class qs extends Ws{}class Hs extends de{}class ja extends Hs{}class Ks extends Hs{}class Ua extends de{}class Va extends Ua{}class os extends Ua{}class Xs extends de{}class Wa extends Xs{}class Ga extends Xs{}class vi extends de{}class qa extends vi{}class Ha extends vi{}class as extends de{}class Ka extends as{}class Xa extends as{}class Ys extends de{}class Ya extends Ys{}class Sd extends Ys{}class Qs extends de{}class Qa extends Qs{}class Za extends Qs{}class Ja extends de{}class el extends Ja{}class Ir extends Ja{async _call(w){return new cr(await super._call(w))}}class Zs extends de{}class tl extends Zs{}class rl extends Zs{async _call(w){return new cr(await super._call(w))}}class nl extends de{}class il extends nl{}class Js extends de{}class sl extends Js{}class ol extends Js{async _call(w){return new cr(await super._call(w))}}class al extends de{}class ll extends al{}class eo extends de{}class ul extends eo{}class dl extends eo{async _call(w){return new cr(await super._call(w))}}class cl extends de{}class Ri extends cl{async _call(w){return new pd(await super._call(w))}}class to extends de{}class ls extends to{}class pl extends to{async _call(w){return new cr(await super._call(w))}}class ro extends de{}class hl extends ro{}class fl extends ro{async _call(w){return new cr(await super._call(w))}}class no extends de{}class ml extends no{}class gl extends no{}class io extends de{}class _l extends io{}class wl extends io{}class so extends de{}class yl extends so{}class bl extends so{async _call(w){return new cr(await super._call(w))}}class us extends de{}class Ml extends us{}class vl extends us{async _call(w){return new oo(await super._call(w))}}class ds extends us{async _call(w){return new ao(await super._call(w))}}class oo extends Re{constructor({logits:w,pred_boxes:le}){super(),this.logits=w,this.pred_boxes=le}}class ao extends Re{constructor({logits:w,pred_boxes:le,pred_masks:qe}){super(),this.logits=w,this.pred_boxes=le,this.pred_masks=qe}}class cs extends de{}class xl extends cs{}class Tl extends cs{async _call(w){return new El(await super._call(w))}}class El extends Re{constructor({logits:w,pred_boxes:le}){super(),this.logits=w,this.pred_boxes=le}}class lo extends de{}class Cl extends lo{}class $l extends lo{async _call(w){return new uo(await super._call(w))}}class uo extends oo{}class co extends de{}class Sl extends co{}class kl extends co{async _call(w){return new cr(await super._call(w))}}class Pl extends de{}class Al extends Pl{}class Il extends Pl{async _call(w){return new cr(await super._call(w))}}class En extends de{}class Fl extends En{}class Ol extends En{async _call(w){return new cr(await super._call(w))}}class po extends de{}class Bl extends po{}class Dl extends po{async _call(w){return new cr(await super._call(w))}}class ho extends de{}class zl extends ho{}class Ll extends ho{}class fo extends de{}class Rl extends fo{}class kd extends fo{}class Nl extends de{}class jl extends Nl{}class ps extends de{}class Ul extends ps{}class Vl extends ps{}class Wl extends ps{}class Pd extends de{}class Zn extends Pd{}class Un extends de{}class Jn extends Un{}class mo extends Un{}class Vn extends de{}class hn extends Vn{}class go extends Vn{}class hs extends de{}class _o extends hs{}class wo extends de{}class Gl extends wo{}class ql extends wo{async _call(w){return new cr(await super._call(w))}}class Ni extends de{}class yo extends Ni{}class Hl extends Ni{async _call(w){return new cr(await super._call(w))}}class ji extends de{}class Kl extends ji{}class bo extends ji{async _call(w){return new cr(await super._call(w))}}class Ui extends de{}class Xl extends Ui{}class Yl extends Ui{async _call(w){return new Ad(await super._call(w))}}class Ad extends Re{constructor({logits:w,pred_boxes:le}){super(),this.logits=w,this.pred_boxes=le}}class Ql extends de{}class Mo extends Ql{async get_image_embeddings({pixel_values:w}){return await Ae(this,{pixel_values:w})}async forward(w){if((!w.image_embeddings||!w.image_positional_embeddings)&&(w={...w,...await this.get_image_embeddings(w)}),!w.input_labels&&w.input_points){const qe=w.input_points.dims.slice(0,-1),Je=qe.reduce((ft,Bt)=>ft*Bt,1);w.input_labels=new K.Tensor("int64",new BigInt64Array(Je).fill(1n),qe)}const le={image_embeddings:w.image_embeddings,image_positional_embeddings:w.image_positional_embeddings};return w.input_points&&(le.input_points=w.input_points),w.input_labels&&(le.input_labels=w.input_labels),w.input_boxes&&(le.input_boxes=w.input_boxes),await Ce(this.sessions.prompt_encoder_mask_decoder,le)}async _call(w){return new Vi(await super._call(w))}}class Vi extends Re{constructor({iou_scores:w,pred_masks:le}){super(),this.iou_scores=w,this.pred_masks=le}}class vo extends de{}class xo extends vo{}class Zl extends vo{}class To extends de{}class Jl extends To{}class Id extends To{}class ei extends de{}class eu extends ei{}class Fd extends ei{async _call(w){return new oi(await super._call(w))}}class Eo extends ei{async _call(w){return new cr(await super._call(w))}}class tu extends ei{async _call(w){return new nn(await super._call(w))}}class Co extends de{}class ru extends Co{}class nu extends Co{async _call(w){return new nn(await super._call(w))}}class fs extends de{}class iu extends fs{}class xi extends de{}class $o extends xi{}class So extends xi{async _call(w){return new oi(await super._call(w))}}class su extends xi{async _call(w){return new cr(await super._call(w))}}class Wi extends de{}class ko extends Wi{}class Od extends Wi{async _call(w){return new oi(await super._call(w))}}class ou extends Wi{async _call(w){return new cr(await super._call(w))}}class au extends Wi{async _call(w){return new nn(await super._call(w))}}class Po extends de{}class lu extends Po{}class Ao extends Po{async _call(w){return new oi(await super._call(w))}}class Bd extends Po{async _call(w){return new cr(await super._call(w))}}class Dd extends de{}class uu extends ei{}class du extends ei{async _call(w){return new oi(await super._call(w))}}class Io extends ei{async _call(w){return new cr(await super._call(w))}}class Ti extends de{}class cu extends Ti{}class pu extends Ti{async _call(w){return new oi(await super._call(w))}}class hu extends Ti{async _call(w){return new cr(await super._call(w))}}class fu extends Ti{async _call(w){return new cd(await super._call(w))}}class mu extends Ti{async _call(w){return new nn(await super._call(w))}}class Fo extends de{}class zd extends Fo{}class gu extends Fo{}class _u extends Fo{async generate_speech(w,le,{threshold:qe=.5,minlenratio:Je=0,maxlenratio:ft=20,vocoder:Bt=null}={}){const It={input_ids:w},{encoder_outputs:Qt,encoder_attention_mask:wr}=await Ae(this,It),Ur=Qt.dims[1]/this.config.reduction_factor,Dr=Math.floor(Ur*ft),$r=Math.floor(Ur*Je),tr=this.config.num_mel_bins;let rn=[],Mr=null,vr=null,Vr=0;for(;;){++Vr;const sn=Ne(!!vr);let fn;vr?fn=vr.output_sequence_out:fn=new K.Tensor("float32",new Float32Array(tr),[1,1,tr]);let en={use_cache_branch:sn,output_sequence:fn,encoder_attention_mask:wr,speaker_embeddings:le,encoder_hidden_states:Qt};this.addPastKeyValues(en,Mr),vr=await Ce(this.sessions.decoder_model_merged,en),Mr=this.getPastKeyValues(vr,Mr);const{prob:on,spectrum:Jo}=vr;if(rn.push(Jo),Vr>=$r&&(Array.from(on.data).filter(Hi=>Hi>=qe).length>0||Vr>=Dr))break}const dn=(0,K.cat)(rn),{waveform:Gr}=await Ce(Bt.sessions.model,{spectrogram:dn});return{spectrogram:dn,waveform:Gr}}}class Ld extends de{main_input_name="spectrogram"}class wu extends de{}class yu extends wu{}class Oo extends de{}class bu extends Oo{}class Mu extends Oo{}class vu extends de{}class ms extends vu{}class Gi extends vu{}class gs extends de{}class xu extends gs{}class Tu extends gs{}class _s extends de{}class Eu extends _s{}class Bo extends _s{static async from_pretrained(w,le={}){return le.model_file_name??="text_model",super.from_pretrained(w,le)}}class Cu extends _s{static async from_pretrained(w,le={}){return le.model_file_name??="audio_model",super.from_pretrained(w,le)}}class $u extends de{}class Do extends $u{async _call(w){return new hd(await super._call(w))}}class zo extends de{}class Rd extends zo{}class Lo extends zo{}class Su extends zo{}class Ro extends de{}class ku extends Ro{}class Nd extends Ro{}class No extends de{}class Pu extends No{}class jd extends No{async _call(w){return new cr(await super._call(w))}}class jo extends de{}class Ud extends jo{}class Vd extends jo{}class Uo extends de{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(w){const[le,qe]=w.dims,Je=this.config.decoder.num_codebooks,ft=qe-Je;let Bt=0;for(let wr=0;wr<w.size;++wr){if(w.data[wr]===this.config.decoder.pad_token_id)continue;const Ur=wr%qe,Dr=Math.floor(wr/qe)%Je,$r=Ur-Dr;$r>0&&$r<=ft&&(w.data[Bt++]=w.data[wr])}const It=Math.floor(le/Je),Qt=Bt/(It*Je);return new K.Tensor(w.type,w.data.slice(0,Bt),[It,Je,Qt])}prepare_inputs_for_generation(w,le,qe){let Je=structuredClone(w);for(let Bt=0;Bt<Je.length;++Bt)for(let It=0;It<Je[Bt].length;++It)Bt%this.config.decoder.num_codebooks>=It&&(Je[Bt][It]=BigInt(this.config.decoder.pad_token_id));return qe.guidance_scale!==null&&qe.guidance_scale>1&&(Je=Je.concat(Je)),super.prepare_inputs_for_generation(Je,le,qe)}async generate(w){const le=await super.generate(w),qe=this._apply_and_filter_by_delay_pattern_mask(le).unsqueeze_(0),{audio_values:Je}=await Ce(this.sessions.encodec_decode,{audio_codes:qe});return Je}}class Au extends de{}class Iu extends Au{}class Fu extends Au{async _call(w){return new cr(await super._call(w))}}class Vo extends de{}class Ou extends Vo{}class Wd extends Vo{async _call(w){return new cr(await super._call(w))}}class Wo extends de{}class Bu extends Wo{}class Du extends Wo{async _call(w){return new cr(await super._call(w))}}class Go extends de{}class Gd extends Go{}class zu extends Go{async _call(w){return new cr(await super._call(w))}}class Lu extends de{}class Ru extends Lu{}class Lr{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(w,{progress_callback:le=null,config:qe=null,cache_dir:Je=null,local_files_only:ft=!1,revision:Bt="main",model_file_name:It=null,subfolder:Qt="onnx",device:wr=null,dtype:Ur=null,use_external_data_format:Dr=null,session_options:$r={}}={}){const tr={progress_callback:le,config:qe,cache_dir:Je,local_files_only:ft,revision:Bt,model_file_name:It,subfolder:Qt,device:wr,dtype:Ur,use_external_data_format:Dr,session_options:$r};if(tr.config=await E.AutoConfig.from_pretrained(w,tr),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);for(const rn of this.MODEL_CLASS_MAPPINGS){const Mr=rn.get(tr.config.model_type);if(Mr)return await Mr[1].from_pretrained(w,tr)}if(this.BASE_IF_FAIL)return console.warn(`Unknown model class "${tr.config.model_type}", attempting to construct from base class.`),await de.from_pretrained(w,tr);throw Error(`Unsupported model type: ${tr.config.model_type}`)}}const Kc=new Map([["bert",["BertModel",wt]],["nomic_bert",["NomicBertModel",lt]],["roformer",["RoFormerModel",Qe]],["electra",["ElectraModel",At]],["esm",["EsmModel",Or]],["convbert",["ConvBertModel",J]],["camembert",["CamembertModel",W]],["deberta",["DebertaModel",V]],["deberta-v2",["DebertaV2Model",Ct]],["mpnet",["MPNetModel",Pi]],["albert",["AlbertModel",_i]],["distilbert",["DistilBertModel",Nt]],["roberta",["RobertaModel",kr]],["xlm",["XLMModel",kn]],["xlm-roberta",["XLMRobertaModel",Br]],["clap",["ClapModel",Eu]],["clip",["CLIPModel",pa]],["clipseg",["CLIPSegModel",ya]],["chinese_clip",["ChineseCLIPModel",wa]],["siglip",["SiglipModel",fa]],["mobilebert",["MobileBertModel",zn]],["squeezebert",["SqueezeBertModel",Yn]],["wav2vec2",["Wav2Vec2Model",eu]],["wav2vec2-bert",["Wav2Vec2BertModel",lu]],["unispeech",["UniSpeechModel",$o]],["unispeech-sat",["UniSpeechSatModel",ko]],["hubert",["HubertModel",uu]],["wavlm",["WavLMModel",cu]],["audio-spectrogram-transformer",["ASTModel",qt]],["vits",["VitsModel",Do]],["pyannote",["PyAnnoteModel",ru]],["wespeaker-resnet",["WeSpeakerResNetModel",iu]],["detr",["DetrModel",Ml]],["rt_detr",["RTDetrModel",xl]],["table-transformer",["TableTransformerModel",Cl]],["vit",["ViTModel",el]],["pvt",["PvtModel",tl]],["vit_msn",["ViTMSNModel",sl]],["vit_mae",["ViTMAEModel",il]],["groupvit",["GroupViTModel",ll]],["fastvit",["FastViTModel",ul]],["mobilevit",["MobileViTModel",ls]],["mobilevitv2",["MobileViTV2Model",hl]],["owlvit",["OwlViTModel",ml]],["owlv2",["Owlv2Model",_l]],["beit",["BeitModel",yl]],["deit",["DeiTModel",Sl]],["hiera",["HieraModel",Al]],["convnext",["ConvNextModel",Gl]],["convnextv2",["ConvNextV2Model",yo]],["dinov2",["Dinov2Model",Kl]],["resnet",["ResNetModel",Fl]],["swin",["SwinModel",Bl]],["swin2sr",["Swin2SRModel",zl]],["donut-swin",["DonutSwinModel",_o]],["yolos",["YolosModel",Xl]],["dpt",["DPTModel",Rl]],["glpn",["GLPNModel",hn]],["hifigan",["SpeechT5HifiGan",Ld]],["efficientnet",["EfficientNetModel",Pu]],["decision_transformer",["DecisionTransformerModel",Ru]],["mobilenet_v1",["MobileNetV1Model",Iu]],["mobilenet_v2",["MobileNetV2Model",Ou]],["mobilenet_v3",["MobileNetV3Model",Bu]],["mobilenet_v4",["MobileNetV4Model",Gd]],["maskformer",["MaskFormerModel",Jn]]]),yn=new Map([["t5",["T5Model",Bi]],["longt5",["LongT5Model",zi]],["mt5",["MT5Model",ns]],["bart",["BartModel",G]],["mbart",["MBartModel",ct]],["marian",["MarianModel",xo]],["whisper",["WhisperModel",Kt]],["m2m_100",["M2M100Model",Jl]],["blenderbot",["BlenderbotModel",gr]],["blenderbot-small",["BlenderbotSmallModel",Xr]]]),qd=new Map([["bloom",["BloomModel",Ka]],["jais",["JAISModel",va]],["gpt2",["GPT2Model",Ma]],["gptj",["GPTJModel",$d]],["gpt_bigcode",["GPTBigCodeModel",ss]],["gpt_neo",["GPTNeoModel",Ta]],["gpt_neox",["GPTNeoXModel",Ca]],["codegen",["CodeGenModel",Sa]],["llama",["LlamaModel",Pa]],["olmo",["OlmoModel",Oa]],["mobilellm",["MobileLLMModel",Ia]],["granite",["GraniteModel",Ba]],["cohere",["CohereModel",za]],["gemma",["GemmaModel",Ra]],["gemma2",["Gemma2Model",Gs]],["openelm",["OpenELMModel",ja]],["qwen2",["Qwen2Model",Va]],["phi",["PhiModel",Wa]],["phi3",["Phi3Model",qa]],["mpt",["MptModel",Ya]],["opt",["OPTModel",Qa]],["mistral",["MistralModel",bu]],["starcoder2",["Starcoder2Model",ms]],["falcon",["FalconModel",xu]],["stablelm",["StableLmModel",ku]]]),qo=new Map([["speecht5",["SpeechT5ForSpeechToText",gu]],["whisper",["WhisperForConditionalGeneration",$s]]]),Ho=new Map([["speecht5",["SpeechT5ForTextToSpeech",_u]]]),Nu=new Map([["vits",["VitsModel",Do]],["musicgen",["MusicgenForConditionalGeneration",Uo]]]),qi=new Map([["bert",["BertForSequenceClassification",et]],["roformer",["RoFormerForSequenceClassification",yt]],["electra",["ElectraForSequenceClassification",bt]],["esm",["EsmForSequenceClassification",Er]],["convbert",["ConvBertForSequenceClassification",pe]],["camembert",["CamembertForSequenceClassification",Fe]],["deberta",["DebertaForSequenceClassification",Ie]],["deberta-v2",["DebertaV2ForSequenceClassification",Ft]],["mpnet",["MPNetForSequenceClassification",Ii]],["albert",["AlbertForSequenceClassification",wi]],["distilbert",["DistilBertForSequenceClassification",We]],["roberta",["RobertaForSequenceClassification",Sn]],["xlm",["XLMForSequenceClassification",Jt]],["xlm-roberta",["XLMRobertaForSequenceClassification",br]],["bart",["BartForSequenceClassification",me]],["mbart",["MBartForSequenceClassification",Dt]],["mobilebert",["MobileBertForSequenceClassification",mi]],["squeezebert",["SqueezeBertForSequenceClassification",Ln]]]),ju=new Map([["bert",["BertForTokenClassification",X]],["roformer",["RoFormerForTokenClassification",Lt]],["electra",["ElectraForTokenClassification",C]],["esm",["EsmForTokenClassification",zr]],["convbert",["ConvBertForTokenClassification",Se]],["camembert",["CamembertForTokenClassification",Xe]],["deberta",["DebertaForTokenClassification",je]],["deberta-v2",["DebertaV2ForTokenClassification",Tt]],["mpnet",["MPNetForTokenClassification",Fi]],["distilbert",["DistilBertForTokenClassification",Ge]],["roberta",["RobertaForTokenClassification",De]],["xlm",["XLMForTokenClassification",pn]],["xlm-roberta",["XLMRobertaForTokenClassification",ii]]]),Ko=new Map([["t5",["T5ForConditionalGeneration",Di]],["longt5",["LongT5ForConditionalGeneration",Li]],["mt5",["MT5ForConditionalGeneration",ye]],["bart",["BartForConditionalGeneration",ce]],["mbart",["MBartForConditionalGeneration",Pt]],["marian",["MarianMTModel",Zl]],["m2m_100",["M2M100ForConditionalGeneration",Id]],["blenderbot",["BlenderbotForConditionalGeneration",pr]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",bn]]]),Xo=new Map([["bloom",["BloomForCausalLM",Xa]],["gpt2",["GPT2LMHeadModel",Pn]],["jais",["JAISLMHeadModel",xa]],["gptj",["GPTJForCausalLM",An]],["gpt_bigcode",["GPTBigCodeForCausalLM",zs]],["gpt_neo",["GPTNeoForCausalLM",Ea]],["gpt_neox",["GPTNeoXForCausalLM",$a]],["codegen",["CodeGenForCausalLM",ka]],["llama",["LlamaForCausalLM",Aa]],["olmo",["OlmoForCausalLM",In]],["mobilellm",["MobileLLMForCausalLM",Fa]],["granite",["GraniteForCausalLM",Da]],["cohere",["CohereForCausalLM",La]],["gemma",["GemmaForCausalLM",Na]],["gemma2",["Gemma2ForCausalLM",qs]],["openelm",["OpenELMForCausalLM",Ks]],["qwen2",["Qwen2ForCausalLM",os]],["phi",["PhiForCausalLM",Ga]],["phi3",["Phi3ForCausalLM",Ha]],["mpt",["MptForCausalLM",Sd]],["opt",["OPTForCausalLM",Za]],["mbart",["MBartForCausalLM",zt]],["mistral",["MistralForCausalLM",Mu]],["starcoder2",["Starcoder2ForCausalLM",Gi]],["falcon",["FalconForCausalLM",Tu]],["trocr",["TrOCRForCausalLM",yu]],["stablelm",["StableLmForCausalLM",Nd]]]),Uu=new Map([["bert",["BertForMaskedLM",xt]],["roformer",["RoFormerForMaskedLM",_t]],["electra",["ElectraForMaskedLM",pt]],["esm",["EsmForMaskedLM",jr]],["convbert",["ConvBertForMaskedLM",z]],["camembert",["CamembertForMaskedLM",we]],["deberta",["DebertaForMaskedLM",ve]],["deberta-v2",["DebertaV2ForMaskedLM",Et]],["mpnet",["MPNetForMaskedLM",Ai]],["albert",["AlbertForMaskedLM",rr]],["distilbert",["DistilBertForMaskedLM",Ht]],["roberta",["RobertaForMaskedLM",xn]],["xlm",["XLMWithLMHeadModel",Rn]],["xlm-roberta",["XLMRobertaForMaskedLM",Ot]],["mobilebert",["MobileBertForMaskedLM",Nr]],["squeezebert",["SqueezeBertForMaskedLM",$n]]]),Vu=new Map([["bert",["BertForQuestionAnswering",Be]],["roformer",["RoFormerForQuestionAnswering",kt]],["electra",["ElectraForQuestionAnswering",c]],["convbert",["ConvBertForQuestionAnswering",dt]],["camembert",["CamembertForQuestionAnswering",sr]],["deberta",["DebertaForQuestionAnswering",Ze]],["deberta-v2",["DebertaV2ForQuestionAnswering",Ut]],["mpnet",["MPNetForQuestionAnswering",Oi]],["albert",["AlbertForQuestionAnswering",yi]],["distilbert",["DistilBertForQuestionAnswering",vt]],["roberta",["RobertaForQuestionAnswering",Jr]],["xlm",["XLMForQuestionAnswering",Yr]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Qn]],["mobilebert",["MobileBertForQuestionAnswering",ki]],["squeezebert",["SqueezeBertForQuestionAnswering",gi]]]),Yo=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Ss]]]),Wu=new Map([["llava",["LlavaForConditionalGeneration",Mi]],["moondream1",["Moondream1ForConditionalGeneration",fr]],["florence2",["Florence2ForConditionalGeneration",ks]]]),Hd=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Ss]]]),Gu=new Map([["vit",["ViTForImageClassification",Ir]],["pvt",["PvtForImageClassification",rl]],["vit_msn",["ViTMSNForImageClassification",ol]],["fastvit",["FastViTForImageClassification",dl]],["mobilevit",["MobileViTForImageClassification",pl]],["mobilevitv2",["MobileViTV2ForImageClassification",fl]],["beit",["BeitForImageClassification",bl]],["deit",["DeiTForImageClassification",kl]],["hiera",["HieraForImageClassification",Il]],["convnext",["ConvNextForImageClassification",ql]],["convnextv2",["ConvNextV2ForImageClassification",Hl]],["dinov2",["Dinov2ForImageClassification",bo]],["resnet",["ResNetForImageClassification",Ol]],["swin",["SwinForImageClassification",Dl]],["segformer",["SegformerForImageClassification",Lo]],["efficientnet",["EfficientNetForImageClassification",jd]],["mobilenet_v1",["MobileNetV1ForImageClassification",Fu]],["mobilenet_v2",["MobileNetV2ForImageClassification",Wd]],["mobilenet_v3",["MobileNetV3ForImageClassification",Du]],["mobilenet_v4",["MobileNetV4ForImageClassification",zu]]]),qu=new Map([["detr",["DetrForObjectDetection",vl]],["rt_detr",["RTDetrForObjectDetection",Tl]],["table-transformer",["TableTransformerForObjectDetection",$l]],["yolos",["YolosForObjectDetection",Yl]]]),Hu=new Map([["owlvit",["OwlViTForObjectDetection",gl]],["owlv2",["Owlv2ForObjectDetection",wl]]]),Ku=new Map([["detr",["DetrForSegmentation",ds]],["clipseg",["CLIPSegForImageSegmentation",ba]]]),Qo=new Map([["segformer",["SegformerForSemanticSegmentation",Su]],["sapiens",["SapiensForSemanticSegmentation",Ul]]]),Xu=new Map([["detr",["DetrForSegmentation",ds]],["maskformer",["MaskFormerForInstanceSegmentation",mo]]]),Kd=new Map([["sam",["SamModel",Mo]]]),Zo=new Map([["wav2vec2",["Wav2Vec2ForCTC",Fd]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Ao]],["unispeech",["UniSpeechForCTC",So]],["unispeech-sat",["UniSpeechSatForCTC",Od]],["wavlm",["WavLMForCTC",pu]],["hubert",["HubertForCTC",du]]]),Yu=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Eo]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Bd]],["unispeech",["UniSpeechForSequenceClassification",su]],["unispeech-sat",["UniSpeechSatForSequenceClassification",ou]],["wavlm",["WavLMForSequenceClassification",hu]],["hubert",["HubertForSequenceClassification",Io]],["audio-spectrogram-transformer",["ASTForAudioClassification",is]]]),Qu=new Map([["wavlm",["WavLMForXVector",fu]]]),Zu=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",au]],["wavlm",["WavLMForAudioFrameClassification",mu]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",tu]],["pyannote",["PyAnnoteForAudioFrameClassification",nu]]]),Xd=new Map([["vitmatte",["VitMatteForImageMatting",Ri]]]),Ju=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Ll]]]),ed=new Map([["dpt",["DPTForDepthEstimation",kd]],["depth_anything",["DepthAnythingForDepthEstimation",jl]],["glpn",["GLPNForDepthEstimation",go]],["sapiens",["SapiensForDepthEstimation",Vl]],["depth_pro",["DepthProForDepthEstimation",Zn]]]),td=new Map([["sapiens",["SapiensForNormalEstimation",Wl]]]),Yd=new Map([["clip",["CLIPVisionModelWithProjection",ha]],["siglip",["SiglipVisionModel",ga]]]),rd=[[Kc,te.EncoderOnly],[yn,te.EncoderDecoder],[qd,te.DecoderOnly],[qi,te.EncoderOnly],[ju,te.EncoderOnly],[Ko,te.Seq2Seq],[qo,te.Seq2Seq],[Xo,te.DecoderOnly],[Uu,te.EncoderOnly],[Vu,te.EncoderOnly],[Yo,te.Vision2Seq],[Wu,te.ImageTextToText],[Gu,te.EncoderOnly],[Ku,te.EncoderOnly],[Xu,te.EncoderOnly],[Qo,te.EncoderOnly],[Xd,te.EncoderOnly],[Ju,te.EncoderOnly],[ed,te.EncoderOnly],[td,te.EncoderOnly],[qu,te.EncoderOnly],[Hu,te.EncoderOnly],[Kd,te.MaskGeneration],[Zo,te.EncoderOnly],[Yu,te.EncoderOnly],[Ho,te.Seq2Seq],[Nu,te.EncoderOnly],[Qu,te.EncoderOnly],[Zu,te.EncoderOnly],[Yd,te.EncoderOnly]];for(const[_,w]of rd)for(const[le,qe]of _.values())ee.set(le,w),B.set(qe,le),q.set(le,qe);const Qd=[["MusicgenForConditionalGeneration",Uo,te.Musicgen],["CLIPTextModelWithProjection",Mn,te.EncoderOnly],["SiglipTextModel",ma,te.EncoderOnly],["ClapTextModelWithProjection",Bo,te.EncoderOnly],["ClapAudioModelWithProjection",Cu,te.EncoderOnly]];for(const[_,w,le]of Qd)ee.set(_,le),B.set(w,_),q.set(_,w);class Zd extends Lr{static MODEL_CLASS_MAPPINGS=rd.map(w=>w[0]);static BASE_IF_FAIL=!0}class Jd extends Lr{static MODEL_CLASS_MAPPINGS=[qi]}class ec extends Lr{static MODEL_CLASS_MAPPINGS=[ju]}class Xc extends Lr{static MODEL_CLASS_MAPPINGS=[Ko]}class tc extends Lr{static MODEL_CLASS_MAPPINGS=[qo]}class rc extends Lr{static MODEL_CLASS_MAPPINGS=[Ho]}class nc extends Lr{static MODEL_CLASS_MAPPINGS=[Nu]}class ic extends Lr{static MODEL_CLASS_MAPPINGS=[Xo]}class sc extends Lr{static MODEL_CLASS_MAPPINGS=[Uu]}class oc extends Lr{static MODEL_CLASS_MAPPINGS=[Vu]}class ac extends Lr{static MODEL_CLASS_MAPPINGS=[Yo]}class lc extends Lr{static MODEL_CLASS_MAPPINGS=[Gu]}class uc extends Lr{static MODEL_CLASS_MAPPINGS=[Ku]}class Yc extends Lr{static MODEL_CLASS_MAPPINGS=[Qo]}class ws extends Lr{static MODEL_CLASS_MAPPINGS=[Xu]}class nd extends Lr{static MODEL_CLASS_MAPPINGS=[qu]}class id extends Lr{static MODEL_CLASS_MAPPINGS=[Hu]}class sd extends Lr{static MODEL_CLASS_MAPPINGS=[Kd]}class od extends Lr{static MODEL_CLASS_MAPPINGS=[Zo]}class dc extends Lr{static MODEL_CLASS_MAPPINGS=[Yu]}class cc extends Lr{static MODEL_CLASS_MAPPINGS=[Qu]}class ad extends Lr{static MODEL_CLASS_MAPPINGS=[Zu]}class ld extends Lr{static MODEL_CLASS_MAPPINGS=[Hd]}class pc extends Lr{static MODEL_CLASS_MAPPINGS=[Xd]}class hc extends Lr{static MODEL_CLASS_MAPPINGS=[Ju]}class ud extends Lr{static MODEL_CLASS_MAPPINGS=[ed]}class fc extends Lr{static MODEL_CLASS_MAPPINGS=[td]}class mc extends Lr{static MODEL_CLASS_MAPPINGS=[Yd]}class dd extends Re{constructor({logits:w,past_key_values:le,encoder_outputs:qe,decoder_attentions:Je=null,cross_attentions:ft=null}){super(),this.logits=w,this.past_key_values=le,this.encoder_outputs=qe,this.decoder_attentions=Je,this.cross_attentions=ft}}class cr extends Re{constructor({logits:w}){super(),this.logits=w}}class cd extends Re{constructor({logits:w,embeddings:le}){super(),this.logits=w,this.embeddings=le}}class nn extends Re{constructor({logits:w}){super(),this.logits=w}}class un extends Re{constructor({logits:w}){super(),this.logits=w}}class _n extends Re{constructor({start_logits:w,end_logits:le}){super(),this.start_logits=w,this.end_logits=le}}class oi extends Re{constructor({logits:w}){super(),this.logits=w}}class gc extends Re{constructor({logits:w,past_key_values:le}){super(),this.logits=w,this.past_key_values=le}}class pd extends Re{constructor({alphas:w}){super(),this.alphas=w}}class hd extends Re{constructor({waveform:w,spectrogram:le}){super(),this.waveform=w,this.spectrogram=le}}},"./src/models/whisper/common_whisper.js":(oe,R,T)=>{T.r(R),T.d(R,{WHISPER_LANGUAGE_MAPPING:()=>Z,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>re,whisper_language_to_code:()=>fe});const E=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],Z=new Map(E),re=new Map([...E.map(([Ee,j])=>[j,Ee]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function fe(Ee){Ee=Ee.toLowerCase();let j=re.get(Ee);if(j===void 0)if(Z.has(Ee))j=Ee;else{const M=Ee.length===2?Z.keys():Z.values();throw new Error(`Language "${Ee}" is not supported. Must be one of: ${JSON.stringify(M)}`)}return j}},"./src/models/whisper/generation_whisper.js":(oe,R,T)=>{T.r(R),T.d(R,{WhisperGenerationConfig:()=>Z});var E=T("./src/generation/configuration_utils.js");class Z extends E.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}},"./src/ops/registry.js":(oe,R,T)=>{T.r(R),T.d(R,{TensorOpRegistry:()=>fe});var E=T("./src/backends/onnx.js"),Z=T("./src/utils/tensor.js");const re=async(Ee,j,O)=>{const M=await(0,E.createInferenceSession)(new Uint8Array(Ee),j);return async N=>{const K=Object.fromEntries(Object.entries(N).map(([$e,Te])=>[$e,Te.ort_tensor])),ae=await M.run(K);return Array.isArray(O)?O.map($e=>new Z.Tensor(ae[$e])):new Z.Tensor(ae[O])}};class fe{static session_options={};static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=re([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=re([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=re([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=re([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=re([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=re([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}}},"./src/pipelines.js":(oe,R,T)=>{T.r(R),T.d(R,{AudioClassificationPipeline:()=>Ve,AutomaticSpeechRecognitionPipeline:()=>Ne,DepthEstimationPipeline:()=>Re,DocumentQuestionAnsweringPipeline:()=>Oe,FeatureExtractionPipeline:()=>xe,FillMaskPipeline:()=>te,ImageClassificationPipeline:()=>Ae,ImageFeatureExtractionPipeline:()=>Ce,ImageSegmentationPipeline:()=>ie,ImageToImagePipeline:()=>de,ImageToTextPipeline:()=>Pe,ObjectDetectionPipeline:()=>se,Pipeline:()=>Te,QuestionAnsweringPipeline:()=>ke,SummarizationPipeline:()=>q,Text2TextGenerationPipeline:()=>ee,TextClassificationPipeline:()=>U,TextGenerationPipeline:()=>I,TextToAudioPipeline:()=>nt,TokenClassificationPipeline:()=>ue,TranslationPipeline:()=>B,ZeroShotAudioClassificationPipeline:()=>Ue,ZeroShotClassificationPipeline:()=>Me,ZeroShotImageClassificationPipeline:()=>F,ZeroShotObjectDetectionPipeline:()=>_e,pipeline:()=>wt});var E=T("./src/tokenizers.js"),Z=T("./src/models.js"),re=T("./src/processors.js"),fe=T("./src/utils/generic.js"),Ee=T("./src/utils/core.js"),j=T("./src/utils/maths.js"),O=T("./src/utils/audio.js"),M=T("./src/utils/tensor.js"),N=T("./src/utils/image.js");async function K(et){return Array.isArray(et)||(et=[et]),await Promise.all(et.map(X=>N.RawImage.read(X)))}async function ae(et,X){return Array.isArray(et)||(et=[et]),await Promise.all(et.map(Be=>typeof Be=="string"||Be instanceof URL?(0,O.read_audio)(Be,X):Be instanceof Float64Array?new Float32Array(Be):Be))}function $e(et,X){X&&(et=et.map(Qe=>Qe|0));const[Be,st,lt,rt]=et;return{xmin:Be,ymin:st,xmax:lt,ymax:rt}}class Te extends fe.Callable{constructor({task:X,model:Be,tokenizer:st=null,processor:lt=null}){super(),this.task=X,this.model=Be,this.tokenizer=st,this.processor=lt}async dispose(){await this.model.dispose()}}class U extends Te{constructor(X){super(X)}async _call(X,{top_k:Be=1}={}){const st=this.tokenizer(X,{padding:!0,truncation:!0}),lt=await this.model(st),rt=this.model.config.problem_type==="multi_label_classification"?yt=>yt.sigmoid():yt=>new M.Tensor("float32",(0,j.softmax)(yt.data),yt.dims),Qe=this.model.config.id2label,_t=[];for(const yt of lt.logits){const Lt=rt(yt),kt=await(0,M.topk)(Lt,Be),$=kt[0].tolist(),z=kt[1].tolist().map((pe,Se)=>({label:Qe?Qe[pe]:`LABEL_${pe}`,score:$[Se]}));Be===1?_t.push(...z):_t.push(z)}return Array.isArray(X)||Be===1?_t:_t[0]}}class ue extends Te{constructor(X){super(X)}async _call(X,{ignore_labels:Be=["O"]}={}){const st=Array.isArray(X),lt=this.tokenizer(st?X:[X],{padding:!0,truncation:!0}),Qe=(await this.model(lt)).logits,_t=this.model.config.id2label,yt=[];for(let Lt=0;Lt<Qe.dims[0];++Lt){const kt=lt.input_ids[Lt],$=Qe[Lt],J=[];for(let z=0;z<$.dims[0];++z){const pe=$[z],Se=(0,j.max)(pe.data)[1],dt=_t?_t[Se]:`LABEL_${Se}`;if(Be.includes(dt))continue;const at=this.tokenizer.decode([kt[z].item()],{skip_special_tokens:!0});if(at==="")continue;const At=(0,j.softmax)(pe.data);J.push({entity:dt,score:At[Se],index:z,word:at})}yt.push(J)}return st?yt:yt[0]}}class ke extends Te{constructor(X){super(X)}async _call(X,Be,{top_k:st=1}={}){const lt=this.tokenizer(X,{text_pair:Be,padding:!0,truncation:!0}),{start_logits:rt,end_logits:Qe}=await this.model(lt),_t=lt.input_ids.tolist(),yt=lt.attention_mask.tolist(),Lt=this.tokenizer.all_special_ids,kt=[];for(let $=0;$<rt.dims[0];++$){const J=_t[$],z=J.findIndex(pt=>pt==this.tokenizer.sep_token_id);yt[$].map((pt,bt)=>pt==1&&(bt===0||bt>z&&Lt.findIndex(C=>C==J[bt])===-1));const pe=rt[$].tolist(),Se=Qe[$].tolist();for(let pt=1;pt<pe.length;++pt)(yt[$]==0||pt<=z||Lt.findIndex(bt=>bt==J[pt])!==-1)&&(pe[pt]=-1/0,Se[pt]=-1/0);const dt=(0,j.softmax)(pe).map((pt,bt)=>[pt,bt]),at=(0,j.softmax)(Se).map((pt,bt)=>[pt,bt]);dt[0][0]=0,at[0][0]=0;const At=(0,Ee.product)(dt,at).filter(pt=>pt[0][1]<=pt[1][1]).map(pt=>[pt[0][1],pt[1][1],pt[0][0]*pt[1][0]]).sort((pt,bt)=>bt[2]-pt[2]);for(let pt=0;pt<Math.min(At.length,st);++pt){const[bt,C,c]=At[pt],m=J.slice(bt,C+1),W=this.tokenizer.decode(m,{skip_special_tokens:!0});kt.push({answer:W,score:c})}}return st===1?kt[0]:kt}}class te extends Te{constructor(X){super(X)}async _call(X,{top_k:Be=5}={}){const st=this.tokenizer(X,{padding:!0,truncation:!0}),{logits:lt}=await this.model(st),rt=[],Qe=st.input_ids.tolist();for(let _t=0;_t<Qe.length;++_t){const yt=Qe[_t],Lt=yt.findIndex(pe=>pe==this.tokenizer.mask_token_id);if(Lt===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const kt=lt[_t][Lt],$=await(0,M.topk)(new M.Tensor("float32",(0,j.softmax)(kt.data),kt.dims),Be),J=$[0].tolist(),z=$[1].tolist();rt.push(z.map((pe,Se)=>{const dt=yt.slice();return dt[Lt]=pe,{score:J[Se],token:Number(pe),token_str:this.tokenizer.model.vocab[pe],sequence:this.tokenizer.decode(dt,{skip_special_tokens:!0})}}))}return Array.isArray(X)?rt:rt[0]}}class ee extends Te{_key="generated_text";constructor(X){super(X)}async _call(X,Be={}){Array.isArray(X)||(X=[X]),this.model.config.prefix&&(X=X.map(yt=>this.model.config.prefix+yt));const st=this.model.config.task_specific_params;st&&st[this.task]&&st[this.task].prefix&&(X=X.map(yt=>st[this.task].prefix+yt));const lt=this.tokenizer,rt={padding:!0,truncation:!0};let Qe;this instanceof B&&"_build_translation_inputs"in lt?Qe=lt._build_translation_inputs(X,rt,Be):Qe=lt(X,rt);const _t=await this.model.generate({...Qe,...Be});return lt.batch_decode(_t,{skip_special_tokens:!0}).map(yt=>({[this._key]:yt}))}}class q extends ee{_key="summary_text";constructor(X){super(X)}}class B extends ee{_key="translation_text";constructor(X){super(X)}}function H(et){return Array.isArray(et)&&et.every(X=>"role"in X&&"content"in X)}class I extends Te{constructor(X){super(X)}async _call(X,Be={}){let st=!1,lt=!1,rt;if(typeof X=="string")rt=X=[X];else if(Array.isArray(X)&&X.every(z=>typeof z=="string"))st=!0,rt=X;else{if(H(X))X=[X];else if(Array.isArray(X)&&X.every(H))st=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");lt=!0,rt=X.map(z=>this.tokenizer.apply_chat_template(z,{tokenize:!1,add_generation_prompt:!0}))}const Qe=Be.add_special_tokens??!1,_t=lt?!1:Be.return_full_text??!0;this.tokenizer.padding_side="left";const yt=this.tokenizer(rt,{add_special_tokens:Qe,padding:!0,truncation:!0}),Lt=await this.model.generate({...yt,...Be}),kt=this.tokenizer.batch_decode(Lt,{skip_special_tokens:!0});let $;!_t&&yt.input_ids.dims.at(-1)>0&&($=this.tokenizer.batch_decode(yt.input_ids,{skip_special_tokens:!0}).map(z=>z.length));const J=Array.from({length:X.length},z=>[]);for(let z=0;z<kt.length;++z){const pe=Math.floor(z/Lt.dims[0]*X.length);$&&(kt[z]=kt[z].slice($[pe])),J[pe].push({generated_text:lt?[...X[pe],{role:"assistant",content:kt[z]}]:kt[z]})}return!st&&J.length===1?J[0]:J}}class Me extends Te{constructor(X){super(X),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([Be,st])=>[Be.toLowerCase(),st])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(X,Be,{hypothesis_template:st="This example is {}.",multi_label:lt=!1}={}){const rt=Array.isArray(X);rt||(X=[X]),Array.isArray(Be)||(Be=[Be]);const Qe=Be.map(Lt=>st.replace("{}",Lt)),_t=lt||Be.length===1,yt=[];for(const Lt of X){const kt=[];for(const z of Qe){const pe=this.tokenizer(Lt,{text_pair:z,padding:!0,truncation:!0}),Se=await this.model(pe);_t?kt.push([Se.logits.data[this.contradiction_id],Se.logits.data[this.entailment_id]]):kt.push(Se.logits.data[this.entailment_id])}const J=(_t?kt.map(z=>(0,j.softmax)(z)[1]):(0,j.softmax)(kt)).map((z,pe)=>[z,pe]).sort((z,pe)=>pe[0]-z[0]);yt.push({sequence:Lt,labels:J.map(z=>Be[z[1]]),scores:J.map(z=>z[0])})}return rt?yt:yt[0]}}class xe extends Te{constructor(X){super(X)}async _call(X,{pooling:Be="none",normalize:st=!1,quantize:lt=!1,precision:rt="binary"}={}){const Qe=this.tokenizer(X,{padding:!0,truncation:!0}),_t=await this.model(Qe);let yt=_t.last_hidden_state??_t.logits??_t.token_embeddings;if(Be!=="none")if(Be==="mean")yt=(0,M.mean_pooling)(yt,Qe.attention_mask);else if(Be==="cls")yt=yt.slice(null,0);else throw Error(`Pooling method '${Be}' not supported.`);return st&&(yt=yt.normalize(2,-1)),lt&&(yt=(0,M.quantize_embeddings)(yt,rt)),yt}}class Ce extends Te{constructor(X){super(X)}async _call(X,{pool:Be=null}={}){const st=await K(X),{pixel_values:lt}=await this.processor(st),rt=await this.model({pixel_values:lt});let Qe;if(Be){if(!("pooler_output"in rt))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");Qe=rt.pooler_output}else Qe=rt.last_hidden_state??rt.logits??rt.image_embeds;return Qe}}class Ve extends Te{constructor(X){super(X)}async _call(X,{top_k:Be=5}={}){const st=this.processor.feature_extractor.config.sampling_rate,lt=await ae(X,st),rt=this.model.config.id2label,Qe=[];for(const _t of lt){const yt=await this.processor(_t),kt=(await this.model(yt)).logits[0],$=await(0,M.topk)(new M.Tensor("float32",(0,j.softmax)(kt.data),kt.dims),Be),J=$[0].tolist(),pe=$[1].tolist().map((Se,dt)=>({label:rt?rt[Se]:`LABEL_${Se}`,score:J[dt]}));Qe.push(pe)}return Array.isArray(X)?Qe:Qe[0]}}class Ue extends Te{constructor(X){super(X)}async _call(X,Be,{hypothesis_template:st="This is a sound of {}."}={}){const lt=!Array.isArray(X);lt&&(X=[X]);const rt=Be.map(kt=>st.replace("{}",kt)),Qe=this.tokenizer(rt,{padding:!0,truncation:!0}),_t=this.processor.feature_extractor.config.sampling_rate,yt=await ae(X,_t),Lt=[];for(const kt of yt){const $=await this.processor(kt),J=await this.model({...Qe,...$}),z=(0,j.softmax)(J.logits_per_audio.data);Lt.push([...z].map((pe,Se)=>({score:pe,label:Be[Se]})))}return lt?Lt[0]:Lt}}class Ne extends Te{constructor(X){super(X)}async _call(X,Be={}){switch(this.model.config.model_type){case"whisper":return this._call_whisper(X,Be);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(X,Be);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(X,Be){Be.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),Be.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const st=!Array.isArray(X);st&&(X=[X]);const lt=this.processor.feature_extractor.config.sampling_rate,rt=await ae(X,lt),Qe=[];for(const _t of rt){const yt=await this.processor(_t),kt=(await this.model(yt)).logits[0],$=[];for(const z of kt)$.push((0,j.max)(z.data)[1]);const J=this.tokenizer.decode($);Qe.push({text:J})}return st?Qe[0]:Qe}async _call_whisper(X,Be){const st=Be.return_timestamps??!1,lt=Be.chunk_length_s??0,rt=Be.force_full_sequences??!1;let Qe=Be.stride_length_s??null;const _t={...Be};st==="word"&&(_t.return_token_timestamps=!0,_t.return_timestamps=!1);const yt=!Array.isArray(X);yt&&(X=[X]);const Lt=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,kt=this.processor.feature_extractor.config.hop_length,$=this.processor.feature_extractor.config.sampling_rate,J=await ae(X,$),z=[];for(const pe of J){let Se=[];if(lt>0){if(Qe===null)Qe=lt/6;else if(lt<=Qe)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const At=$*lt,pt=$*Qe,bt=At-2*pt;let C=0;for(;;){const c=C+At,m=pe.subarray(C,c),W=await this.processor(m),we=C===0,Fe=c>=pe.length;if(Se.push({stride:[m.length,we?0:pt,Fe?0:pt],input_features:W.input_features,is_last:Fe}),Fe)break;C+=bt}}else Se=[{stride:[pe.length,0,0],input_features:(await this.processor(pe)).input_features,is_last:!0}];for(const At of Se){_t.num_frames=Math.floor(At.stride[0]/kt);const pt=await this.model.generate({inputs:At.input_features,..._t});st==="word"?(At.tokens=pt.sequences.tolist()[0],At.token_timestamps=pt.token_timestamps.tolist()[0].map(bt=>(0,j.round)(bt,2))):At.tokens=pt[0].tolist(),At.stride=At.stride.map(bt=>bt/$)}const[dt,at]=this.tokenizer._decode_asr(Se,{time_precision:Lt,return_timestamps:st,force_full_sequences:rt});z.push({text:dt,...at})}return yt?z[0]:z}}class Pe extends Te{constructor(X){super(X)}async _call(X,Be={}){const st=Array.isArray(X),lt=await K(X),{pixel_values:rt}=await this.processor(lt),Qe=[];for(const _t of rt){_t.dims=[1,..._t.dims];const yt=await this.model.generate({inputs:_t,...Be}),Lt=this.tokenizer.batch_decode(yt,{skip_special_tokens:!0}).map(kt=>({generated_text:kt.trim()}));Qe.push(Lt)}return st?Qe:Qe[0]}}class Ae extends Te{constructor(X){super(X)}async _call(X,{top_k:Be=5}={}){const st=await K(X),{pixel_values:lt}=await this.processor(st),rt=await this.model({pixel_values:lt}),Qe=this.model.config.id2label,_t=[];for(const yt of rt.logits){const Lt=await(0,M.topk)(new M.Tensor("float32",(0,j.softmax)(yt.data),yt.dims),Be),kt=Lt[0].tolist(),J=Lt[1].tolist().map((z,pe)=>({label:Qe?Qe[z]:`LABEL_${z}`,score:kt[pe]}));_t.push(J)}return Array.isArray(X)?_t:_t[0]}}class ie extends Te{constructor(X){super(X),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(X,{threshold:Be=.5,mask_threshold:st=.5,overlap_mask_area_threshold:lt=.8,label_ids_to_fuse:rt=null,target_sizes:Qe=null,subtask:_t=null}={}){if(Array.isArray(X)&&X.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Lt=await K(X),kt=Lt.map(at=>[at.height,at.width]),{pixel_values:$,pixel_mask:J}=await this.processor(Lt),z=await this.model({pixel_values:$,pixel_mask:J});let pe=null;if(_t!==null)pe=this.subtasks_mapping[_t];else for(let[at,At]of Object.entries(this.subtasks_mapping))if(At in this.processor.feature_extractor){pe=this.processor.feature_extractor[At].bind(this.processor.feature_extractor),_t=at;break}const Se=this.model.config.id2label,dt=[];if(_t==="panoptic"||_t==="instance"){const at=pe(z,Be,st,lt,rt,Qe??kt)[0],At=at.segmentation;for(const pt of at.segments_info){const bt=new Uint8ClampedArray(At.data.length);for(let c=0;c<At.data.length;++c)At.data[c]===pt.id&&(bt[c]=255);const C=new N.RawImage(bt,At.dims[1],At.dims[0],1);dt.push({score:pt.score,label:Se[pt.label_id],mask:C})}}else if(_t==="semantic"){const{segmentation:at,labels:At}=pe(z,Qe??kt)[0];for(const pt of At){const bt=new Uint8ClampedArray(at.data.length);for(let c=0;c<at.data.length;++c)at.data[c]===pt&&(bt[c]=255);const C=new N.RawImage(bt,at.dims[1],at.dims[0],1);dt.push({score:null,label:Se[pt],mask:C})}}else throw Error(`Subtask ${_t} not supported.`);return dt}}class F extends Te{constructor(X){super(X)}async _call(X,Be,{hypothesis_template:st="This is a photo of {}"}={}){const lt=Array.isArray(X),rt=await K(X),Qe=Be.map(J=>st.replace("{}",J)),_t=this.tokenizer(Qe,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:yt}=await this.processor(rt),Lt=await this.model({..._t,pixel_values:yt}),kt=this.model.config.model_type==="siglip"?J=>J.sigmoid().data:J=>(0,j.softmax)(J.data),$=[];for(const J of Lt.logits_per_image){const pe=[...kt(J)].map((Se,dt)=>({score:Se,label:Be[dt]}));pe.sort((Se,dt)=>dt.score-Se.score),$.push(pe)}return lt?$:$[0]}}class se extends Te{constructor(X){super(X)}async _call(X,{threshold:Be=.9,percentage:st=!1}={}){const lt=Array.isArray(X);if(lt&&X.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const rt=await K(X),Qe=st?null:rt.map(z=>[z.height,z.width]),{pixel_values:_t,pixel_mask:yt}=await this.processor(rt),Lt=await this.model({pixel_values:_t,pixel_mask:yt}),kt=this.processor.feature_extractor.post_process_object_detection(Lt,Be,Qe),$=this.model.config.id2label,J=kt.map(z=>z.boxes.map((pe,Se)=>({score:z.scores[Se],label:$[z.classes[Se]],box:$e(pe,!st)})));return lt?J:J[0]}}class _e extends Te{constructor(X){super(X)}async _call(X,Be,{threshold:st=.1,top_k:lt=null,percentage:rt=!1}={}){const Qe=Array.isArray(X),_t=await K(X),yt=this.tokenizer(Be,{padding:!0,truncation:!0}),Lt=await this.processor(_t),kt=[];for(let $=0;$<_t.length;++$){const J=_t[$],z=rt?null:[[J.height,J.width]],pe=Lt.pixel_values[$].unsqueeze_(0),Se=await this.model({...yt,pixel_values:pe}),dt=this.processor.feature_extractor.post_process_object_detection(Se,st,z,!0)[0];let at=dt.boxes.map((At,pt)=>({score:dt.scores[pt],label:Be[dt.classes[pt]],box:$e(At,!rt)})).sort((At,pt)=>pt.score-At.score);lt!==null&&(at=at.slice(0,lt)),kt.push(at)}return Qe?kt:kt[0]}}class Oe extends Te{constructor(X){super(X)}async _call(X,Be,st={}){const lt=(await K(X))[0],{pixel_values:rt}=await this.processor(lt),Qe=`<s_docvqa><s_question>${Be}</s_question><s_answer>`,_t=this.tokenizer(Qe,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,yt=await this.model.generate({inputs:rt,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:_t,...st}),kt=this.tokenizer.batch_decode(yt)[0].match(/<s_answer>(.*?)<\/s_answer>/);let $=null;return kt&&kt.length>=2&&($=kt[1].trim()),[{answer:$}]}}class nt extends Te{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(X){super(X),this.vocoder=X.vocoder??null}async _call(X,{speaker_embeddings:Be=null}={}){return this.processor?this._call_text_to_spectrogram(X,{speaker_embeddings:Be}):this._call_text_to_waveform(X)}async _call_text_to_waveform(X){const Be=this.tokenizer(X,{padding:!0,truncation:!0}),{waveform:st}=await this.model(Be),lt=this.model.config.sampling_rate;return{audio:st.data,sampling_rate:lt}}async _call_text_to_spectrogram(X,{speaker_embeddings:Be}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await Z.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof Be=="string"||Be instanceof URL)&&(Be=new Float32Array(await(await fetch(Be)).arrayBuffer())),Be instanceof Float32Array)Be=new M.Tensor("float32",Be,[1,Be.length]);else if(!(Be instanceof M.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:st}=this.tokenizer(X,{padding:!0,truncation:!0}),{waveform:lt}=await this.model.generate_speech(st,Be,{vocoder:this.vocoder}),rt=this.processor.feature_extractor.config.sampling_rate;return{audio:lt.data,sampling_rate:rt}}}class de extends Te{constructor(X){super(X)}async _call(X){const Be=await K(X),st=await this.processor(Be),lt=await this.model(st),rt=[];for(const Qe of lt.reconstruction){const _t=Qe.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");rt.push(N.RawImage.fromTensor(_t))}return rt.length>1?rt:rt[0]}}class Re extends Te{constructor(X){super(X)}async _call(X){const Be=await K(X),st=await this.processor(Be),{predicted_depth:lt}=await this.model(st),rt=[];for(let Qe=0;Qe<Be.length;++Qe){const _t=(0,M.interpolate)(lt[Qe],Be[Qe].size.reverse(),"bilinear",!1),yt=_t.mul_(255/(0,j.max)(_t.data)[0]).to("uint8");rt.push({predicted_depth:lt[Qe],depth:N.RawImage.fromTensor(yt)})}return rt.length>1?rt:rt[0]}}const it=Object.freeze({"text-classification":{tokenizer:E.AutoTokenizer,pipeline:U,model:Z.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:E.AutoTokenizer,pipeline:ue,model:Z.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:E.AutoTokenizer,pipeline:ke,model:Z.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:E.AutoTokenizer,pipeline:te,model:Z.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:E.AutoTokenizer,pipeline:q,model:Z.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:E.AutoTokenizer,pipeline:B,model:Z.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:E.AutoTokenizer,pipeline:ee,model:Z.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:E.AutoTokenizer,pipeline:I,model:Z.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:E.AutoTokenizer,pipeline:Me,model:Z.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:Ve,model:Z.AutoModelForAudioClassification,processor:re.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:E.AutoTokenizer,pipeline:Ue,model:Z.AutoModel,processor:re.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:E.AutoTokenizer,pipeline:Ne,model:[Z.AutoModelForSpeechSeq2Seq,Z.AutoModelForCTC],processor:re.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:E.AutoTokenizer,pipeline:nt,model:[Z.AutoModelForTextToWaveform,Z.AutoModelForTextToSpectrogram],processor:[re.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:E.AutoTokenizer,pipeline:Pe,model:Z.AutoModelForVision2Seq,processor:re.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:Ae,model:Z.AutoModelForImageClassification,processor:re.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:ie,model:[Z.AutoModelForImageSegmentation,Z.AutoModelForSemanticSegmentation,Z.AutoModelForUniversalSegmentation],processor:re.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"zero-shot-image-classification":{tokenizer:E.AutoTokenizer,pipeline:F,model:Z.AutoModel,processor:re.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:se,model:Z.AutoModelForObjectDetection,processor:re.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:E.AutoTokenizer,pipeline:_e,model:Z.AutoModelForZeroShotObjectDetection,processor:re.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:E.AutoTokenizer,pipeline:Oe,model:Z.AutoModelForDocumentQuestionAnswering,processor:re.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:de,model:Z.AutoModelForImageToImage,processor:re.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Re,model:Z.AutoModelForDepthEstimation,processor:re.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:E.AutoTokenizer,pipeline:xe,model:Z.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:re.AutoProcessor,pipeline:Ce,model:[Z.AutoModelForImageFeatureExtraction,Z.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),He=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function wt(et,X=null,{progress_callback:Be=null,config:st=null,cache_dir:lt=null,local_files_only:rt=!1,revision:Qe="main",device:_t=null,dtype:yt=null,model_file_name:Lt=null,session_options:kt={}}={}){et=He[et]??et;const $=it[et.split("_",1)[0]];if(!$)throw Error(`Unsupported pipeline: ${et}. Must be one of [${Object.keys(it)}]`);X||(X=$.default.model,console.log(`No model specified. Using default model: "${X}".`));const J={progress_callback:Be,config:st,cache_dir:lt,local_files_only:rt,revision:Qe,device:_t,dtype:yt,model_file_name:Lt,session_options:kt},z=new Map([["tokenizer",$.tokenizer],["model",$.model],["processor",$.processor]]),pe=await xt(z,X,J);pe.task=et,(0,Ee.dispatchCallback)(Be,{status:"ready",task:et,model:X});const Se=$.pipeline;return new Se(pe)}async function xt(et,X,Be){const st=Object.create(null),lt=[];for(const[rt,Qe]of et.entries()){if(!Qe)continue;let _t;Array.isArray(Qe)?_t=new Promise(async(yt,Lt)=>{let kt;for(const $ of Qe){if($===null){yt(null);return}try{yt(await $.from_pretrained(X,Be));return}catch(J){if(J.message?.includes("Unsupported model type"))kt=J;else if(J.message?.includes("Could not locate file"))kt=J;else{Lt(J);return}}}Lt(kt)}):_t=Qe.from_pretrained(X,Be),st[rt]=_t,lt.push(_t)}await Promise.all(lt);for(const[rt,Qe]of Object.entries(st))st[rt]=await Qe;return st}},"./src/processors.js":(oe,R,T)=>{T.r(R),T.d(R,{ASTFeatureExtractor:()=>Se,AutoProcessor:()=>sr,BeitFeatureExtractor:()=>Be,BitImageProcessor:()=>xe,CLIPFeatureExtractor:()=>Ve,CLIPImageProcessor:()=>Ue,ChineseCLIPFeatureExtractor:()=>Ne,ClapFeatureExtractor:()=>dt,ConvNextFeatureExtractor:()=>Ae,ConvNextImageProcessor:()=>ie,DPTFeatureExtractor:()=>I,DPTImageProcessor:()=>Me,DeiTFeatureExtractor:()=>X,DetrFeatureExtractor:()=>Qe,DonutFeatureExtractor:()=>st,DonutImageProcessor:()=>lt,EfficientNetImageProcessor:()=>_e,FeatureExtractor:()=>te,Florence2Processor:()=>Xe,GLPNFeatureExtractor:()=>Ce,ImageFeatureExtractor:()=>ee,MaskFormerFeatureExtractor:()=>_t,MobileNetV1FeatureExtractor:()=>Oe,MobileNetV2FeatureExtractor:()=>nt,MobileNetV3FeatureExtractor:()=>de,MobileNetV4FeatureExtractor:()=>Re,MobileViTFeatureExtractor:()=>it,MobileViTImageProcessor:()=>He,NougatImageProcessor:()=>rt,OwlViTFeatureExtractor:()=>wt,OwlViTProcessor:()=>Fe,Owlv2ImageProcessor:()=>xt,Processor:()=>bt,PvtImageProcessor:()=>H,PyAnnoteFeatureExtractor:()=>at,PyAnnoteProcessor:()=>W,RTDetrImageProcessor:()=>et,SamImageProcessor:()=>Lt,SamProcessor:()=>C,SapiensFeatureExtractor:()=>q,SeamlessM4TFeatureExtractor:()=>pe,SegformerFeatureExtractor:()=>B,SiglipImageProcessor:()=>Pe,SpeechT5FeatureExtractor:()=>pt,SpeechT5Processor:()=>we,Swin2SRImageProcessor:()=>kt,ViTFeatureExtractor:()=>F,ViTImageProcessor:()=>se,VitMatteImageProcessor:()=>$,Wav2Vec2FeatureExtractor:()=>z,Wav2Vec2ProcessorWithLM:()=>m,WeSpeakerFeatureExtractor:()=>At,WhisperFeatureExtractor:()=>J,WhisperProcessor:()=>c,YolosFeatureExtractor:()=>yt});var E=T("./src/utils/generic.js"),Z=T("./src/utils/core.js"),re=T("./src/utils/hub.js"),fe=T("./src/utils/maths.js"),Ee=T("./src/utils/tensor.js");T("./src/utils/image.js");var j=T("./src/utils/audio.js");function O([ot,V,ve,Ie]){return[ot-ve/2,V-Ie/2,ot+ve/2,V+Ie/2]}function M(ot,V=.5,ve=null,Ie=!1){const je=ot.logits,Ze=ot.pred_boxes,[mt,Ct,Et]=je.dims;if(ve!==null&&ve.length!==mt)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Ft=[];for(let Tt=0;Tt<mt;++Tt){let Ut=ve!==null?ve[Tt]:null,Wt={boxes:[],classes:[],scores:[]},Nt=je[Tt],We=Ze[Tt];for(let Ge=0;Ge<Ct;++Ge){let vt=Nt[Ge],Ht=[],ar;if(Ie){ar=vt.sigmoid().data;for(let Or=0;Or<ar.length;++Or)ar[Or]>V&&Ht.push(Or)}else{let Or=(0,fe.max)(vt.data)[1];if(Or===Et-1||(ar=(0,fe.softmax)(vt.data),ar[Or]<V))continue;Ht.push(Or)}for(const Or of Ht){let jr=We[Ge].data;jr=O(jr),Ut!==null&&(jr=jr.map((Er,zr)=>Er*Ut[(zr+1)%2])),Wt.boxes.push(jr),Wt.classes.push(Or),Wt.scores.push(ar[Or])}}Ft.push(Wt)}return Ft}function N(ot,V=null){const ve=ot.logits,Ie=ve.dims[0];if(V!==null&&V.length!==Ie)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const je=[];for(let Ze=0;Ze<Ie;++Ze){const mt=V!==null?V[Ze]:null;let Ct=ve[Ze];mt!==null&&(Ct=(0,Ee.interpolate)(Ct,mt,"bilinear",!1));const[Et,Ft]=mt??Ct.dims.slice(-2),Tt=new Ee.Tensor("int32",new Int32Array(Et*Ft),[Et,Ft]),Ut=Ct[0].data,Wt=Tt.data;for(let Ge=1;Ge<Ct.dims[0];++Ge){const vt=Ct[Ge].data;for(let Ht=0;Ht<vt.length;++Ht)vt[Ht]>Ut[Ht]&&(Ut[Ht]=vt[Ht],Wt[Ht]=Ge)}const Nt=new Array(Ct.dims[0]);for(let Ge=0;Ge<Wt.length;++Ge){const vt=Wt[Ge];Nt[vt]=vt}const We=Nt.filter(Ge=>Ge!==void 0);je.push({segmentation:Tt,labels:We})}return je}function K(ot,V,ve,Ie){const je=[],Ze=[],mt=[];for(let Ct=0;Ct<ot.dims[0];++Ct){const Et=ot[Ct],Ft=V[Ct],Tt=(0,fe.max)(Et.data)[1];if(Tt===Ie)continue;const Wt=(0,fe.softmax)(Et.data)[Tt];Wt>ve&&(je.push(Ft),Ze.push(Wt),mt.push(Tt))}return[je,Ze,mt]}function ae(ot,V,ve,Ie=.5,je=.8){const Ze=[];let mt=0,Ct=0;const Et=V[ve].data;for(let Tt=0;Tt<ot.length;++Tt)ot[Tt]===ve&&(Ze.push(Tt),++mt),Et[Tt]>=Ie&&++Ct;let Ft=mt>0&&Ct>0;return Ft&&(Ft=mt/Ct>je),[Ft,Ze]}function $e(ot,V,ve,Ie,je,Ze=null,mt=null){const[Ct,Et]=mt??ot[0].dims,Ft=new Ee.Tensor("int32",new Int32Array(Ct*Et),[Ct,Et]),Tt=[];if(mt!==null)for(let Ge=0;Ge<ot.length;++Ge)ot[Ge]=(0,Ee.interpolate)(ot[Ge],mt,"bilinear",!1);const Ut=new Int32Array(ot[0].data.length),Wt=new Float32Array(ot[0].data.length);for(let Ge=0;Ge<ot.length;++Ge){let vt=V[Ge];const Ht=ot[Ge].data;for(let ar=0;ar<Ht.length;++ar)Ht[ar]*=vt,Ht[ar]>Wt[ar]&&(Ut[ar]=Ge,Wt[ar]=Ht[ar])}let Nt=0;const We=Ft.data;for(let Ge=0;Ge<ve.length;++Ge){const vt=ve[Ge],[Ht,ar]=ae(Ut,ot,Ge,Ie,je);if(Ht){++Nt;for(const Or of ar)We[Or]=Nt;Tt.push({id:Nt,label_id:vt,score:V[Ge]})}}return[Ft,Tt]}function Te(ot,V=.5,ve=.5,Ie=.8,je=null,Ze=null){je===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),je=new Set);const mt=ot.class_queries_logits??ot.logits,Et=(ot.masks_queries_logits??ot.pred_masks).sigmoid();let[Ft,Tt,Ut]=mt.dims;if(Ut-=1,Ze!==null&&Ze.length!==Ft)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let Wt=[];for(let Nt=0;Nt<Ft;++Nt){let We=Ze!==null?Ze[Nt]:null,Ge=mt[Nt],vt=Et[Nt],[Ht,ar,Or]=K(Ge,vt,V,Ut);if(Or.length===0){let[zr,Ar]=We??vt.dims.slice(-2),zn=new Ee.Tensor("int32",new Int32Array(zr*Ar).fill(-1),[zr,Ar]);Wt.push({segmentation:zn,segments_info:[]});continue}let[jr,Er]=$e(Ht,ar,Or,ve,Ie,je,We);Wt.push({segmentation:jr,segments_info:Er})}return Wt}function U(ot,V){if(!(ot instanceof Float32Array||ot instanceof Float64Array))throw new Error(`${V} expects input to be a Float32Array or a Float64Array, but got ${ot?.constructor?.name??typeof ot} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}function ue(ot,V,ve=0,Ie=null){const je=ot/V;let Ze=(0,fe.bankers_round)(je)*V;return Ie!==null&&Ze>Ie&&(Ze=Math.floor(je)*V),Ze<ve&&(Ze=Math.ceil(je)*V),Ze}function ke([ot,V],ve){return[Math.max(Math.floor(ot/ve),1)*ve,Math.max(Math.floor(V/ve),1)*ve]}class te extends E.Callable{constructor(V){super(),this.config=V}}class ee extends te{constructor(V){super(V),this.image_mean=this.config.image_mean??this.config.mean,this.image_std=this.config.image_std??this.config.std,this.resample=this.config.resample??2,this.do_rescale=this.config.do_rescale??!0,this.rescale_factor=this.config.rescale_factor??1/255,this.do_normalize=this.config.do_normalize,this.do_resize=this.config.do_resize,this.do_thumbnail=this.config.do_thumbnail,this.size=this.config.size,this.size_divisibility=this.config.size_divisibility??this.config.size_divisor,this.do_center_crop=this.config.do_center_crop,this.crop_size=this.config.crop_size,this.do_convert_rgb=this.config.do_convert_rgb??!0,this.do_crop_margin=this.config.do_crop_margin,this.pad_size=this.config.pad_size,this.do_pad=this.config.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=this.config.do_flip_channel_order??!1}async thumbnail(V,ve,Ie=2){const je=V.height,Ze=V.width,mt=ve.height,Ct=ve.width;let Et=Math.min(je,mt),Ft=Math.min(Ze,Ct);return Et===je&&Ft===Ze?V:(je>Ze?Ft=Math.floor(Ze*Et/je):Ze>je&&(Et=Math.floor(je*Ft/Ze)),await V.resize(Ft,Et,{resample:Ie}))}async crop_margin(V,ve=200){const Ie=V.clone().grayscale(),je=(0,fe.min)(Ie.data)[0],mt=(0,fe.max)(Ie.data)[0]-je;if(mt===0)return V;const Ct=ve/255;let Et=Ie.width,Ft=Ie.height,Tt=0,Ut=0;const Wt=Ie.data;for(let Nt=0;Nt<Ie.height;++Nt){const We=Nt*Ie.width;for(let Ge=0;Ge<Ie.width;++Ge)(Wt[We+Ge]-je)/mt<Ct&&(Et=Math.min(Et,Ge),Ft=Math.min(Ft,Nt),Tt=Math.max(Tt,Ge),Ut=Math.max(Ut,Nt))}return V=await V.crop([Et,Ft,Tt,Ut]),V}pad_image(V,ve,Ie,{mode:je="constant",center:Ze=!1,constant_values:mt=0}={}){const[Ct,Et,Ft]=ve;let Tt,Ut;if(typeof Ie=="number"?(Tt=Ie,Ut=Ie):(Tt=Ie.width,Ut=Ie.height),Tt!==Et||Ut!==Ct){const Wt=new Float32Array(Tt*Ut*Ft);if(Array.isArray(mt))for(let Ge=0;Ge<Wt.length;++Ge)Wt[Ge]=mt[Ge%Ft];else mt!==0&&Wt.fill(mt);const[Nt,We]=Ze?[Math.floor((Tt-Et)/2),Math.floor((Ut-Ct)/2)]:[0,0];for(let Ge=0;Ge<Ct;++Ge){const vt=(Ge+We)*Tt,Ht=Ge*Et;for(let ar=0;ar<Et;++ar){const Or=(vt+ar+Nt)*Ft,jr=(Ht+ar)*Ft;for(let Er=0;Er<Ft;++Er)Wt[Or+Er]=V[jr+Er]}}if(je==="symmetric"){if(Ze)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const Ge=Ct-1,vt=Et-1;for(let Ht=0;Ht<Ut;++Ht){const ar=Ht*Tt,Or=(0,Z.calculateReflectOffset)(Ht,Ge)*Et;for(let jr=0;jr<Tt;++jr){if(Ht<Ct&&jr<Et)continue;const Er=(ar+jr)*Ft,zr=(Or+(0,Z.calculateReflectOffset)(jr,vt))*Ft;for(let Ar=0;Ar<Ft;++Ar)Wt[Er+Ar]=V[zr+Ar]}}}V=Wt,ve=[Ut,Tt,Ft]}return[V,ve]}rescale(V){for(let ve=0;ve<V.length;++ve)V[ve]=this.rescale_factor*V[ve]}get_resize_output_image_size(V,ve){const[Ie,je]=V.size;let Ze,mt;if(this.do_thumbnail){const{height:Ct,width:Et}=ve;Ze=Math.min(Ct,Et)}else Number.isInteger(ve)?(Ze=ve,mt=this.config.max_size??Ze):ve!==void 0&&(Ze=ve.shortest_edge,mt=ve.longest_edge);if(Ze!==void 0||mt!==void 0){const Ct=Ze===void 0?1:Math.max(Ze/Ie,Ze/je),Et=Ie*Ct,Ft=je*Ct,Tt=mt===void 0?1:Math.min(mt/Et,mt/Ft);let Ut=Math.floor(Number((Et*Tt).toFixed(2))),Wt=Math.floor(Number((Ft*Tt).toFixed(2)));return this.size_divisibility!==void 0&&([Ut,Wt]=ke([Ut,Wt],this.size_divisibility)),[Ut,Wt]}else if(ve!==void 0&&ve.width!==void 0&&ve.height!==void 0){let Ct=ve.width,Et=ve.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let Ft=Et/je,Tt=Ct/Ie;Math.abs(1-Tt)<Math.abs(1-Ft)?Ft=Tt:Tt=Ft,Et=ue(Ft*je,this.config.ensure_multiple_of),Ct=ue(Tt*Ie,this.config.ensure_multiple_of)}return[Ct,Et]}else{if(this.size_divisibility!==void 0)return ke([Ie,je],this.size_divisibility);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(ve)}`)}}async resize(V){const[ve,Ie]=this.get_resize_output_image_size(V,this.size);return await V.resize(ve,Ie,{resample:this.resample})}async preprocess(V,{do_normalize:ve=null,do_pad:Ie=null,do_convert_rgb:je=null,do_convert_grayscale:Ze=null,do_flip_channel_order:mt=null}={}){this.do_crop_margin&&(V=await this.crop_margin(V));const[Ct,Et]=V.size;if(je??this.do_convert_rgb?V=V.rgb():Ze&&(V=V.grayscale()),this.do_resize&&(V=await this.resize(V)),this.do_thumbnail&&(V=await this.thumbnail(V,this.size,this.resample)),this.do_center_crop){let Nt,We;Number.isInteger(this.crop_size)?(Nt=this.crop_size,We=this.crop_size):(Nt=this.crop_size.width,We=this.crop_size.height),V=await V.center_crop(Nt,We)}const Ft=[V.height,V.width];let Tt=Float32Array.from(V.data),Ut=[V.height,V.width,V.channels];if(this.do_rescale&&this.rescale(Tt),ve??this.do_normalize){let Nt=this.image_mean;Array.isArray(this.image_mean)||(Nt=new Array(V.channels).fill(Nt));let We=this.image_std;if(Array.isArray(this.image_std)||(We=new Array(V.channels).fill(Nt)),Nt.length!==V.channels||We.length!==V.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${Nt.length}) and \`image_std\` (${We.length}) must match the number of channels in the image (${V.channels}).`);for(let Ge=0;Ge<Tt.length;Ge+=V.channels)for(let vt=0;vt<V.channels;++vt)Tt[Ge+vt]=(Tt[Ge+vt]-Nt[vt])/We[vt]}if(Ie??this.do_pad){if(this.pad_size)[Tt,Ut]=this.pad_image(Tt,[V.height,V.width,V.channels],this.pad_size);else if(this.size_divisibility){const[Nt,We]=ke([Ut[1],Ut[0]],this.size_divisibility);[Tt,Ut]=this.pad_image(Tt,Ut,{width:Nt,height:We})}}if(mt??this.do_flip_channel_order){if(Ut[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let Nt=0;Nt<Tt.length;Nt+=3){const We=Tt[Nt];Tt[Nt]=Tt[Nt+2],Tt[Nt+2]=We}}const Wt=new Ee.Tensor("float32",Tt,Ut).permute(2,0,1);return{original_size:[Et,Ct],reshaped_input_size:Ft,pixel_values:Wt}}async _call(V,...ve){Array.isArray(V)||(V=[V]);const Ie=await Promise.all(V.map(Ze=>this.preprocess(Ze)));return{pixel_values:(0,Ee.stack)(Ie.map(Ze=>Ze.pixel_values),0),original_sizes:Ie.map(Ze=>Ze.original_size),reshaped_input_sizes:Ie.map(Ze=>Ze.reshaped_input_size)}}}class q extends ee{post_process_semantic_segmentation(...V){return N(...V)}}class B extends ee{post_process_semantic_segmentation(...V){return N(...V)}}class H extends ee{}class I extends ee{}class Me extends I{}class xe extends ee{}class Ce extends ee{}class Ve extends ee{}class Ue extends Ve{}class Ne extends ee{}class Pe extends ee{}class Ae extends ee{constructor(V){super(V),this.crop_pct=this.config.crop_pct??224/256}async resize(V){const ve=this.size?.shortest_edge;if(ve===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(ve<384){const Ie=Math.floor(ve/this.crop_pct),[je,Ze]=this.get_resize_output_image_size(V,{shortest_edge:Ie});V=await V.resize(je,Ze,{resample:this.resample}),V=await V.center_crop(ve,ve)}else V=await V.resize(ve,ve,{resample:this.resample});return V}}class ie extends Ae{}class F extends ee{}class se extends ee{}class _e extends ee{constructor(V){super(V),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(ve=>ve*ve))}}class Oe extends ee{}class nt extends ee{}class de extends ee{}class Re extends ee{}class it extends ee{}class He extends it{}class wt extends ee{post_process_object_detection(...V){return M(...V)}}class xt extends wt{}class et extends ee{post_process_object_detection(...V){return M(...V)}}class X extends ee{}class Be extends ee{}class st extends ee{pad_image(V,ve,Ie,je={}){const[Ze,mt,Ct]=ve;let Et=this.image_mean;Array.isArray(this.image_mean)||(Et=new Array(Ct).fill(Et));let Ft=this.image_std;Array.isArray(Ft)||(Ft=new Array(Ct).fill(Et));const Tt=Et.map((Ut,Wt)=>-Ut/Ft[Wt]);return super.pad_image(V,ve,Ie,{center:!0,constant_values:Tt,...je})}}class lt extends st{}class rt extends st{}class Qe extends ee{async _call(V){const ve=await super._call(V),Ie=[ve.pixel_values.dims[0],64,64],je=(0,Ee.full)(Ie,1n);return{...ve,pixel_mask:je}}post_process_object_detection(...V){return M(...V)}post_process_panoptic_segmentation(...V){return Te(...V)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class _t extends ee{post_process_panoptic_segmentation(...V){return Te(...V)}post_process_instance_segmentation(){throw Error("Not implemented yet")}}class yt extends ee{post_process_object_detection(...V){return M(...V)}}class Lt extends ee{reshape_input_points(V,ve,Ie,je=!1){V=structuredClone(V);let Ze=(0,Z.calculateDimensions)(V);if(Ze.length===3)je||(Ze=[1,...Ze]),V=[V];else if(Ze.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let mt=0;mt<V.length;++mt){let Ct=ve[mt],Et=Ie[mt],Ft=[Et[0]/Ct[0],Et[1]/Ct[1]];for(let Tt=0;Tt<V[mt].length;++Tt)for(let Ut=0;Ut<V[mt][Tt].length;++Ut)for(let Wt=0;Wt<V[mt][Tt][Ut].length;++Wt)V[mt][Tt][Ut][Wt]*=Ft[Wt%2]}return new Ee.Tensor("float32",Float32Array.from(V.flat(1/0)),Ze)}add_input_labels(V,ve){let Ie=(0,Z.calculateDimensions)(V);if(Ie.length===2)Ie=[1,...Ie],V=[V];else if(Ie.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(Ie.some((je,Ze)=>je!==ve.dims[Ze]))throw Error(`The first ${Ie.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new Ee.Tensor("int64",V.flat(1/0).map(BigInt),Ie)}async _call(V,{input_points:ve=null,input_labels:Ie=null,input_boxes:je=null}={}){const Ze=await super._call(V);if(ve&&(Ze.input_points=this.reshape_input_points(ve,Ze.original_sizes,Ze.reshaped_input_sizes)),Ie){if(!Ze.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");Ze.input_labels=this.add_input_labels(Ie,Ze.input_points)}return je&&(Ze.input_boxes=this.reshape_input_points(je,Ze.original_sizes,Ze.reshaped_input_sizes,!0)),Ze}async post_process_masks(V,ve,Ie,{mask_threshold:je=0,binarize:Ze=!0,pad_size:mt=null}={}){const Ct=[];mt=mt??this.pad_size;const Et=[mt.height,mt.width];for(let Ft=0;Ft<ve.length;++Ft){const Tt=ve[Ft],Ut=Ie[Ft];let Wt=await(0,Ee.interpolate_4d)(V[Ft],{mode:"bilinear",size:Et});if(Wt=Wt.slice(null,null,[0,Ut[0]],[0,Ut[1]]),Wt=await(0,Ee.interpolate_4d)(Wt,{mode:"bilinear",size:Tt}),Ze){const Nt=Wt.data,We=new Uint8Array(Nt.length);for(let Ge=0;Ge<Nt.length;++Ge)Nt[Ge]>je&&(We[Ge]=1);Wt=new Ee.Tensor("bool",We,Wt.dims)}Ct.push(Wt)}return Ct}generate_crop_boxes(V,ve,{crop_n_layers:Ie=0,overlap_ratio:je=512/1500,points_per_crop:Ze=32,crop_n_points_downscale_factor:mt=1}={}){}}class kt extends ee{pad_image(V,ve,Ie,je={}){const[Ze,mt,Ct]=ve;return super.pad_image(V,ve,{width:mt+(Ie-mt%Ie)%Ie,height:Ze+(Ie-Ze%Ie)%Ie},{mode:"symmetric",center:!1,constant_values:-1,...je})}}class $ extends ee{async _call(V,ve){Array.isArray(V)||(V=[V]),Array.isArray(ve)||(ve=[ve]);const Ie=await Promise.all(V.map(mt=>this.preprocess(mt))),je=await Promise.all(ve.map(mt=>this.preprocess(mt,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,Ee.stack)(Ie.map((mt,Ct)=>(0,Ee.cat)([mt.pixel_values,je[Ct].pixel_values],0)),0),original_sizes:Ie.map(mt=>mt.original_size),reshaped_input_sizes:Ie.map(mt=>mt.reshaped_input_size)}}}class J extends te{constructor(V){super(V),this.config.mel_filters??=(0,j.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,j.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(V){const ve=await(0,j.spectrogram)(V,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:this.config.nb_max_frames}),Ie=ve.data,je=(0,fe.max)(Ie)[0];for(let Ze=0;Ze<Ie.length;++Ze)Ie[Ze]=(Math.max(Ie[Ze],je-8)+4)/4;return ve}async _call(V){U(V,"WhisperFeatureExtractor");let ve;return V.length>this.config.n_samples?(console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),ve=V.slice(0,this.config.n_samples)):(ve=new Float32Array(this.config.n_samples),ve.set(V)),{input_features:(await this._extract_fbank_features(ve)).unsqueeze_(0)}}}class z extends te{_zero_mean_unit_var_norm(V){const Ie=V.reduce((Ze,mt)=>Ze+mt,0)/V.length,je=V.reduce((Ze,mt)=>Ze+(mt-Ie)**2,0)/V.length;return V.map(Ze=>(Ze-Ie)/Math.sqrt(je+1e-7))}async _call(V){U(V,"Wav2Vec2FeatureExtractor"),V instanceof Float64Array&&(V=new Float32Array(V));let ve=V;this.config.do_normalize&&(ve=this._zero_mean_unit_var_norm(ve));const Ie=[1,ve.length];return{input_values:new Ee.Tensor("float32",ve,Ie),attention_mask:new Ee.Tensor("int64",new BigInt64Array(ve.length).fill(1n),Ie)}}}class pe extends te{constructor(V){super(V);const ve=this.config.sampling_rate,Ie=(0,j.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(ve/2),ve,null,"kaldi",!0);for(let je=0;je<Ie.length;++je)Ie[je].push(0);this.mel_filters=Ie,this.window=(0,j.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(V,ve){return V=V.map(Ie=>Ie*32768),(0,j.spectrogram)(V,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:ve,transpose:!0})}async _call(V,{padding:ve=!0,pad_to_multiple_of:Ie=2,do_normalize_per_mel_bins:je=!0,return_attention_mask:Ze=!0}={}){U(V,"SeamlessM4TFeatureExtractor");let mt=await this._extract_fbank_features(V,this.config.max_length);if(je){const[We,Ge]=mt.dims,vt=mt.data;for(let Ht=0;Ht<Ge;++Ht){let ar=0;for(let zr=0;zr<We;++zr)ar+=vt[zr*Ge+Ht];const Or=ar/We;let jr=0;for(let zr=0;zr<We;++zr)jr+=(vt[zr*Ge+Ht]-Or)**2;jr/=We-1;const Er=Math.sqrt(jr+1e-7);for(let zr=0;zr<We;++zr){const Ar=zr*Ge+Ht;vt[Ar]=(vt[Ar]-Or)/Er}}}let Ct;if(ve){const[We,Ge]=mt.dims,vt=mt.data,Ht=We%Ie;if(Ht>0){const ar=new Float32Array(Ge*(We+Ht));ar.set(vt),ar.fill(this.config.padding_value,vt.length);const Or=We+Ht;mt=new Ee.Tensor(mt.type,ar,[Or,Ge]),Ze&&(Ct=new Ee.Tensor("int64",new BigInt64Array(Or),[1,Or]),Ct.data.fill(1n,0,We))}}const[Et,Ft]=mt.dims,Tt=this.config.stride;if(Et%Tt!==0)throw new Error(`The number of frames (${Et}) must be a multiple of the stride (${Tt}).`);const Wt=mt.view(1,Math.floor(Et/Tt),Ft*Tt),Nt={input_features:Wt};if(Ze){const We=Wt.dims[1],Ge=new BigInt64Array(We);if(Ct){const vt=Ct.data;for(let Ht=1,ar=0;Ht<Et;Ht+=Tt,++ar)Ge[ar]=vt[Ht]}else Ge.fill(1n);Nt.attention_mask=new Ee.Tensor("int64",Ge,[1,We])}return Nt}}class Se extends te{constructor(V){super(V);const ve=this.config.sampling_rate,Ie=(0,j.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(ve/2),ve,null,"kaldi",!0);for(let je=0;je<Ie.length;++je)Ie[je].push(0);this.mel_filters=Ie,this.window=(0,j.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(V,ve){return(0,j.spectrogram)(V,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:ve,transpose:!0})}async _call(V){U(V,"ASTFeatureExtractor");const ve=await this._extract_fbank_features(V,this.config.max_length);if(this.config.do_normalize){const Ie=this.std*2,je=ve.data;for(let Ze=0;Ze<je.length;++Ze)je[Ze]=(je[Ze]-this.mean)/Ie}return{input_values:ve.unsqueeze_(0)}}}class dt extends te{constructor(V){super(V),this.mel_filters=(0,j.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,j.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,j.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(V,ve,Ie,je){let Ze;const mt=V.length-ve;if(mt>0)if(Ie==="rand_trunc"){const Ct=Math.floor(Math.random()*(mt+1));V=V.subarray(Ct,Ct+ve),Ze=await this._extract_fbank_features(V,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${Ie}" not implemented`);else{if(mt<0){let Ct=new Float64Array(ve);if(Ct.set(V),je==="repeat")for(let Et=V.length;Et<ve;Et+=V.length)Ct.set(V.subarray(0,Math.min(V.length,ve-Et)),Et);else if(je==="repeatpad")for(let Et=V.length;Et<-mt;Et+=V.length)Ct.set(V,Et);V=Ct}if(Ie==="fusion")throw new Error(`Truncation strategy "${Ie}" not implemented`);Ze=await this._extract_fbank_features(V,this.mel_filters_slaney,this.config.nb_max_samples)}return Ze.unsqueeze_(0)}async _extract_fbank_features(V,ve,Ie=null){return(0,j.spectrogram)(V,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:ve,log_mel:"dB",max_num_frames:Ie,do_pad:!1,transpose:!0})}async _call(V,{max_length:ve=null}={}){return U(V,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(V,ve??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}class at extends te{async _call(V){U(V,"PyAnnoteFeatureExtractor"),V instanceof Float64Array&&(V=new Float32Array(V));const ve=[1,1,V.length];return{input_values:new Ee.Tensor("float32",V,ve)}}samples_to_frames(V){return(V-this.config.offset)/this.config.step}post_process_speaker_diarization(V,ve){const Ie=ve/this.samples_to_frames(ve)/this.config.sampling_rate,je=[];for(const Ze of V.tolist()){const mt=[];let Ct=-1;for(let Et=0;Et<Ze.length;++Et){const Ft=(0,fe.softmax)(Ze[Et]),[Tt,Ut]=(0,fe.max)(Ft),[Wt,Nt]=[Et,Et+1];Ut!==Ct?(Ct=Ut,mt.push({id:Ut,start:Wt,end:Nt,score:Tt})):(mt.at(-1).end=Nt,mt.at(-1).score+=Tt)}je.push(mt.map(({id:Et,start:Ft,end:Tt,score:Ut})=>({id:Et,start:Ft*Ie,end:Tt*Ie,confidence:Ut/(Tt-Ft)})))}return je}}class At extends te{constructor(V){super(V);const ve=this.config.sampling_rate,Ie=(0,j.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(ve/2),ve,null,"kaldi",!0);for(let je=0;je<Ie.length;++je)Ie[je].push(0);this.mel_filters=Ie,this.window=(0,j.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(V){return V=V.map(ve=>ve*32768),(0,j.spectrogram)(V,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(V){U(V,"WeSpeakerFeatureExtractor");const ve=(await this._extract_fbank_features(V)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const Ie=ve.mean(1).data,je=ve.data,[Ze,mt,Ct]=ve.dims;for(let Et=0;Et<Ze;++Et){const Ft=Et*mt*Ct,Tt=Et*Ct;for(let Ut=0;Ut<mt;++Ut){const Wt=Ft+Ut*Ct;for(let Nt=0;Nt<Ct;++Nt)je[Wt+Nt]-=Ie[Tt+Nt]}}}return{input_features:ve}}}class pt extends te{}class bt extends E.Callable{constructor(V){super(),this.feature_extractor=V}async _call(V,...ve){return await this.feature_extractor(V,...ve)}}class C extends bt{async _call(...V){return await this.feature_extractor(...V)}post_process_masks(...V){return this.feature_extractor.post_process_masks(...V)}reshape_input_points(...V){return this.feature_extractor.reshape_input_points(...V)}}class c extends bt{async _call(V){return await this.feature_extractor(V)}}class m extends bt{async _call(V){return await this.feature_extractor(V)}}class W extends bt{async _call(V){return await this.feature_extractor(V)}post_process_speaker_diarization(...V){return this.feature_extractor.post_process_speaker_diarization(...V)}}class we extends bt{async _call(V){return await this.feature_extractor(V)}}class Fe extends bt{}class Xe extends bt{constructor(V){super(V);const{tasks_answer_post_processing_type:ve,task_prompts_without_inputs:Ie,task_prompts_with_input:je}=V.config;this.tasks_answer_post_processing_type=new Map(Object.entries(ve??{})),this.task_prompts_without_inputs=new Map(Object.entries(Ie??{})),this.task_prompts_with_input=new Map(Object.entries(je??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(V){typeof V=="string"&&(V=[V]);const ve=[];for(const Ie of V)if(this.task_prompts_without_inputs.has(Ie))ve.push(this.task_prompts_without_inputs.get(Ie));else{for(const[je,Ze]of this.task_prompts_with_input)if(Ie.includes(je)){ve.push(Ze.replaceAll("{input}",Ie).replaceAll(je,""));break}ve.length!==V.length&&ve.push(Ie)}return ve}post_process_generation(V,ve,Ie){const je=this.tasks_answer_post_processing_type.get(ve)??"pure_text";V=V.replaceAll("<s>","").replaceAll("</s>","");let Ze;switch(je){case"pure_text":Ze=V;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const mt=je==="ocr"?"quad_boxes":"bboxes",Ct=V.matchAll(this.regexes[mt]),Et=[],Ft=[];for(const[Tt,Ut,...Wt]of Ct)Et.push(Ut?Ut.trim():Et.at(-1)??""),Ft.push(Wt.map((Nt,We)=>(Number(Nt)+.5)/this.size_per_bin*Ie[We%2]));Ze={labels:Et,[mt]:Ft};break;default:throw new Error(`Task "${ve}" (of type "${je}") not yet implemented.`)}return{[ve]:Ze}}}class sr{static FEATURE_EXTRACTOR_CLASS_MAPPING={ImageFeatureExtractor:ee,WhisperFeatureExtractor:J,ViTFeatureExtractor:F,MobileViTFeatureExtractor:it,MobileViTImageProcessor:He,MobileNetV1FeatureExtractor:Oe,MobileNetV2FeatureExtractor:nt,MobileNetV3FeatureExtractor:de,MobileNetV4FeatureExtractor:Re,OwlViTFeatureExtractor:wt,Owlv2ImageProcessor:xt,CLIPFeatureExtractor:Ve,CLIPImageProcessor:Ue,Florence2Processor:Xe,ChineseCLIPFeatureExtractor:Ne,SiglipImageProcessor:Pe,ConvNextFeatureExtractor:Ae,ConvNextImageProcessor:ie,SegformerFeatureExtractor:B,SapiensFeatureExtractor:q,BitImageProcessor:xe,DPTImageProcessor:Me,DPTFeatureExtractor:I,PvtImageProcessor:H,GLPNFeatureExtractor:Ce,BeitFeatureExtractor:Be,DeiTFeatureExtractor:X,DetrFeatureExtractor:Qe,RTDetrImageProcessor:et,MaskFormerFeatureExtractor:_t,YolosFeatureExtractor:yt,DonutFeatureExtractor:st,DonutImageProcessor:lt,NougatImageProcessor:rt,EfficientNetImageProcessor:_e,ViTImageProcessor:se,VitMatteImageProcessor:$,SamImageProcessor:Lt,Swin2SRImageProcessor:kt,Wav2Vec2FeatureExtractor:z,SeamlessM4TFeatureExtractor:pe,SpeechT5FeatureExtractor:pt,ASTFeatureExtractor:Se,ClapFeatureExtractor:dt,PyAnnoteFeatureExtractor:at,WeSpeakerFeatureExtractor:At};static PROCESSOR_CLASS_MAPPING={WhisperProcessor:c,Wav2Vec2ProcessorWithLM:m,PyAnnoteProcessor:W,SamProcessor:C,SpeechT5Processor:we,OwlViTProcessor:Fe,Florence2Processor:Xe};static async from_pretrained(V,{progress_callback:ve=null,config:Ie=null,cache_dir:je=null,local_files_only:Ze=!1,revision:mt="main"}={}){let Ct=Ie??await(0,re.getModelJSON)(V,"preprocessor_config.json",!0,{progress_callback:ve,config:Ie,cache_dir:je,local_files_only:Ze,revision:mt}),Et=Ct.feature_extractor_type??Ct.image_processor_type,Ft=this.FEATURE_EXTRACTOR_CLASS_MAPPING[Et];if(!Ft)if(Ct.size!==void 0)console.warn(`Feature extractor type "${Et}" not found, assuming ImageFeatureExtractor due to size parameter in config.`),Ft=ee;else throw new Error(`Unknown Feature Extractor type: ${Et}`);let Tt=this.PROCESSOR_CLASS_MAPPING[Ct.processor_class]??bt,Ut=new Ft(Ct);return new Tt(Ut)}}},"./src/tokenizers.js":(oe,R,T)=>{T.r(R),T.d(R,{AlbertTokenizer:()=>mt,AutoTokenizer:()=>ns,BartTokenizer:()=>jr,BertTokenizer:()=>Ze,BlenderbotSmallTokenizer:()=>Di,BlenderbotTokenizer:()=>Bi,BloomTokenizer:()=>zn,CLIPTokenizer:()=>wi,CamembertTokenizer:()=>Ge,CodeGenTokenizer:()=>_i,CodeLlamaTokenizer:()=>ki,CohereTokenizer:()=>ni,ConvBertTokenizer:()=>Wt,DebertaTokenizer:()=>Ft,DebertaV2Tokenizer:()=>Tt,DistilBertTokenizer:()=>We,ElectraTokenizer:()=>Ht,EsmTokenizer:()=>Fi,FalconTokenizer:()=>Ai,GPT2Tokenizer:()=>Or,GPTNeoXTokenizer:()=>Ii,GemmaTokenizer:()=>ti,Grok1Tokenizer:()=>Yn,HerbertTokenizer:()=>Ut,LlamaTokenizer:()=>mi,M2M100Tokenizer:()=>gi,MBart50Tokenizer:()=>zr,MBartTokenizer:()=>Er,MPNetTokenizer:()=>Pi,MarianTokenizer:()=>rr,MobileBertTokenizer:()=>Ct,NllbTokenizer:()=>Ln,NougatTokenizer:()=>zi,PreTrainedTokenizer:()=>je,Qwen2Tokenizer:()=>Oi,RoFormerTokenizer:()=>Nt,RobertaTokenizer:()=>Ar,SiglipTokenizer:()=>yi,SpeechT5Tokenizer:()=>bi,SqueezeBertTokenizer:()=>Et,T5Tokenizer:()=>ar,TokenizerModel:()=>Ce,VitsTokenizer:()=>Li,Wav2Vec2CTCTokenizer:()=>ri,WhisperTokenizer:()=>On,XLMRobertaTokenizer:()=>Xn,XLMTokenizer:()=>vt,is_chinese_char:()=>te});var E=T("./src/utils/generic.js"),Z=T("./src/utils/core.js"),re=T("./src/utils/hub.js"),fe=T("./src/utils/maths.js"),Ee=T("./src/utils/tensor.js"),j=T("./src/utils/data-structures.js"),O=T("./node_modules/@huggingface/jinja/dist/index.js"),M=T("./src/models/whisper/common_whisper.js");T("./src/utils/constants.js");async function N(ye,g){const G=await Promise.all([(0,re.getModelJSON)(ye,"tokenizer.json",!0,g),(0,re.getModelJSON)(ye,"tokenizer_config.json",!0,g)]);return g.legacy!==null&&(G[1].legacy=g.legacy),G}function K(ye,g){const G=[];let ce=0;for(const me of ye.matchAll(g)){const Le=me[0];ce<me.index&&G.push(ye.slice(ce,me.index)),Le.length>0&&G.push(Le),ce=me.index+Le.length}return ce<ye.length&&G.push(ye.slice(ce)),G}function ae(ye,g=!0){if(ye.Regex!==void 0){let G=ye.Regex.replace(/\\([#&~])/g,"$1");for(const[ce,me]of Me)G=G.replaceAll(ce,me);return new RegExp(G,"gu")}else if(ye.String!==void 0){const G=(0,Z.escapeRegExp)(ye.String);return new RegExp(g?G:`(${G})`,"gu")}else return console.warn("Unknown pattern type:",ye),null}function $e(ye){return new Map(Object.entries(ye))}function Te(ye){const g=ye.dims;switch(g.length){case 1:return ye.tolist();case 2:if(g[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return ye.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${g.length}.`)}}function U(ye){return ye.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function ue(ye){return ye.replace(/\p{M}/gu,"")}function ke(ye){return ue(ye.toLowerCase())}function te(ye){return ye>=19968&&ye<=40959||ye>=13312&&ye<=19903||ye>=131072&&ye<=173791||ye>=173824&&ye<=177983||ye>=177984&&ye<=178207||ye>=178208&&ye<=183983||ye>=63744&&ye<=64255||ye>=194560&&ye<=195103}function ee(ye,g,G){const ce=[];let me=0;for(;me<ye.length;){if(ce.push(ye[me]),(g.get(ye[me])??G)!==G){++me;continue}for(;++me<ye.length&&(g.get(ye[me])??G)===G;)g.get(ce.at(-1))!==G&&(ce[ce.length-1]+=ye[me])}return ce}function q(ye){return ye.match(/\S+/g)||[]}const B="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",H=new RegExp(`^[${B}]+$`,"gu"),I=".,!?",Me=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${I}])]+`,` ?[^\\s${I}]+`]]);class xe{constructor(g){this.content=g.content,this.id=g.id,this.single_word=g.single_word??!1,this.lstrip=g.lstrip??!1,this.rstrip=g.rstrip??!1,this.special=g.special??!1,this.normalized=g.normalized??null}}class Ce extends E.Callable{constructor(g){super(),this.config=g,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(g,...G){switch(g.type){case"WordPiece":return new Ve(g);case"Unigram":return new Ue(g,...G);case"BPE":return new Ae(g);default:if(g.vocab)return Array.isArray(g.vocab)?new Ue(g,...G):new ie(g,...G);throw new Error(`Unknown TokenizerModel type: ${g.type}`)}}_call(g){return g=this.encode(g),this.fuse_unk&&(g=ee(g,this.tokens_to_ids,this.unk_token_id)),g}encode(g){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(g){return g.map(G=>this.tokens_to_ids.get(G)??this.unk_token_id)}convert_ids_to_tokens(g){return g.map(G=>this.vocab[G]??this.unk_token)}}class Ve extends Ce{constructor(g){super(g),this.tokens_to_ids=$e(g.vocab),this.unk_token_id=this.tokens_to_ids.get(g.unk_token),this.unk_token=g.unk_token,this.max_input_chars_per_word=g.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[G,ce]of this.tokens_to_ids)this.vocab[ce]=G}encode(g){const G=[];for(const ce of g){const me=[...ce];if(me.length>this.max_input_chars_per_word){G.push(this.unk_token);continue}let Le=!1,ct=0;const Pt=[];for(;ct<me.length;){let Dt=me.length,zt=null;for(;ct<Dt;){let $t=me.slice(ct,Dt).join("");if(ct>0&&($t=this.config.continuing_subword_prefix+$t),this.tokens_to_ids.has($t)){zt=$t;break}--Dt}if(zt===null){Le=!0;break}Pt.push(zt),ct=Dt}Le?G.push(this.unk_token):G.push(...Pt)}return G}}class Ue extends Ce{constructor(g,G){super(g);const ce=g.vocab.length;this.vocab=new Array(ce),this.scores=new Array(ce);for(let me=0;me<ce;++me){const Le=g.vocab[me];this.vocab[me]=Le[0],this.scores[me]=Le[1]}this.unk_token_id=g.unk_id,this.unk_token=this.vocab[g.unk_id],this.tokens_to_ids=new Map(this.vocab.map((me,Le)=>[me,Le])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=G.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,fe.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new j.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(g){const G=g.chars,ce=1;let me=0;for(;me<G.length;){let Le=!1;const ct=G.slice(me).join(""),Pt=this.trie.commonPrefixSearch(ct);for(const Dt of Pt){const zt=this.tokens_to_ids.get(Dt),$t=this.scores[zt],gr=(0,Z.len)(Dt);g.insert(me,gr,$t,zt),!Le&&gr===ce&&(Le=!0)}Le||g.insert(me,ce,this.unk_score,this.unk_token_id),me+=ce}}tokenize(g){const G=new j.TokenLattice(g,this.bos_token_id,this.eos_token_id);return this.populateNodes(G),G.tokens()}encode(g){const G=[];for(const ce of g){const me=this.tokenize(ce);G.push(...me)}return G}}const Ne=(()=>{const ye=[...Array.from({length:94},(me,Le)=>Le+33),...Array.from({length:12},(me,Le)=>Le+161),...Array.from({length:82},(me,Le)=>Le+174)],g=ye.slice();let G=0;for(let me=0;me<256;++me)ye.includes(me)||(ye.push(me),g.push(256+G),G+=1);const ce=g.map(me=>String.fromCharCode(me));return Object.fromEntries(ye.map((me,Le)=>[me,ce[Le]]))})(),Pe=(0,Z.reverseDictionary)(Ne);class Ae extends Ce{constructor(g){super(g),this.tokens_to_ids=$e(g.vocab),this.unk_token_id=this.tokens_to_ids.get(g.unk_token),this.unk_token=g.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[ce,me]of this.tokens_to_ids)this.vocab[me]=ce;const G=Array.isArray(g.merges[0]);this.merges=G?g.merges:g.merges.map(ce=>ce.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((ce,me)=>[JSON.stringify(ce),me])),this.end_of_word_suffix=g.end_of_word_suffix,this.continuing_subword_suffix=g.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(g){if(g.length===0)return[];const G=this.cache.get(g);if(G!==void 0)return G;const ce=Array.from(g);this.end_of_word_suffix&&(ce[ce.length-1]+=this.end_of_word_suffix);let me=[];if(ce.length>1){const Le=new j.PriorityQueue((Dt,zt)=>Dt.score<zt.score);let ct={token:ce[0],bias:0,prev:null,next:null},Pt=ct;for(let Dt=1;Dt<ce.length;++Dt){const zt={bias:Dt/ce.length,token:ce[Dt],prev:Pt,next:null};Pt.next=zt,this._add_node(Le,Pt),Pt=zt}for(;!Le.isEmpty();){const Dt=Le.pop();if(Dt.deleted||!Dt.next||Dt.next.deleted)continue;if(Dt.deleted=!0,Dt.next.deleted=!0,Dt.prev){const $t={...Dt.prev};Dt.prev.deleted=!0,Dt.prev=$t,$t.prev?$t.prev.next=$t:ct=$t}const zt={token:Dt.token+Dt.next.token,bias:Dt.bias,prev:Dt.prev,next:Dt.next.next};zt.prev?(zt.prev.next=zt,this._add_node(Le,zt.prev)):ct=zt,zt.next&&(zt.next.prev=zt,this._add_node(Le,zt))}for(let Dt=ct;Dt!==null;Dt=Dt.next)me.push(Dt.token)}else me=ce;if(this.continuing_subword_suffix)for(let Le=0;Le<me.length-1;++Le)me[Le]+=this.continuing_subword_suffix;return this.cache.set(g,me),me}_add_node(g,G){const ce=this.bpe_ranks.get(JSON.stringify([G.token,G.next.token]));ce!==void 0&&(G.score=ce+G.bias,g.push(G))}encode(g){const G=[];for(const ce of g){if(this.ignore_merges&&this.tokens_to_ids.has(ce)){G.push(ce);continue}const me=this.bpe(ce);for(const Le of me)if(this.tokens_to_ids.has(Le))G.push(Le);else if(this.byte_fallback){const ct=Array.from(this.text_encoder.encode(Le)).map(Pt=>`<0x${Pt.toString(16).toUpperCase().padStart(2,"0")}>`);ct.every(Pt=>this.tokens_to_ids.has(Pt))?G.push(...ct):G.push(this.unk_token)}else G.push(this.unk_token)}return G}}class ie extends Ce{constructor(g,G){super(g),this.tokens_to_ids=$e(G.target_lang?g.vocab[G.target_lang]:g.vocab),this.bos_token=G.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=G.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=G.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=G.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[ce,me]of this.tokens_to_ids)this.vocab[me]=ce}encode(g){return g}}class F extends E.Callable{constructor(g){super(),this.config=g}static fromConfig(g){if(g===null)return null;switch(g.type){case"BertNormalizer":return new xt(g);case"Precompiled":return new we(g);case"Sequence":return new wt(g);case"Replace":return new se(g);case"NFC":return new _e(g);case"NFKC":return new Oe(g);case"NFKD":return new nt(g);case"Strip":return new de(g);case"StripAccents":return new Re(g);case"Lowercase":return new it(g);case"Prepend":return new He(g);default:throw new Error(`Unknown Normalizer type: ${g.type}`)}}normalize(g){throw Error("normalize should be implemented in subclass.")}_call(g){return this.normalize(g)}}class se extends F{normalize(g){const G=ae(this.config.pattern);return G===null?g:g.replaceAll(G,this.config.content)}}class _e extends F{normalize(g){return g=g.normalize("NFC"),g}}class Oe extends F{normalize(g){return g=g.normalize("NFKC"),g}}class nt extends F{normalize(g){return g=g.normalize("NFKD"),g}}class de extends F{normalize(g){return this.config.strip_left&&this.config.strip_right?g=g.trim():(this.config.strip_left&&(g=g.trimStart()),this.config.strip_right&&(g=g.trimEnd())),g}}class Re extends F{normalize(g){return g=ue(g),g}}class it extends F{normalize(g){return g=g.toLowerCase(),g}}class He extends F{normalize(g){return g=this.config.prepend+g,g}}class wt extends F{constructor(g){super(g),this.normalizers=g.normalizers.map(G=>F.fromConfig(G))}normalize(g){return this.normalizers.reduce((G,ce)=>ce.normalize(G),g)}}class xt extends F{_tokenize_chinese_chars(g){const G=[];for(let ce=0;ce<g.length;++ce){const me=g[ce],Le=me.charCodeAt(0);te(Le)?(G.push(" "),G.push(me),G.push(" ")):G.push(me)}return G.join("")}stripAccents(g){return g.normalize("NFD").replace(/\p{Mn}/gu,"")}_is_control(g){switch(g){case"	":case`
`:case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(g)}}_clean_text(g){const G=[];for(const ce of g){const me=ce.charCodeAt(0);me===0||me===65533||this._is_control(ce)||(/^\s$/.test(ce)?G.push(" "):G.push(ce))}return G.join("")}normalize(g){return this.config.clean_text&&(g=this._clean_text(g)),this.config.handle_chinese_chars&&(g=this._tokenize_chinese_chars(g)),this.config.lowercase?(g=g.toLowerCase(),this.config.strip_accents!==!1&&(g=this.stripAccents(g))):this.config.strip_accents&&(g=this.stripAccents(g)),g}}class et extends E.Callable{static fromConfig(g){if(g===null)return null;switch(g.type){case"BertPreTokenizer":return new X(g);case"Sequence":return new Fe(g);case"Whitespace":return new Xe(g);case"WhitespaceSplit":return new sr(g);case"Metaspace":return new m(g);case"ByteLevel":return new Be(g);case"Split":return new st(g);case"Punctuation":return new lt(g);case"Digits":return new rt(g);case"Replace":return new ot(g);default:throw new Error(`Unknown PreTokenizer type: ${g.type}`)}}pre_tokenize_text(g,G){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(g,G){return(Array.isArray(g)?g.map(ce=>this.pre_tokenize_text(ce,G)):this.pre_tokenize_text(g,G)).flat()}_call(g,G){return this.pre_tokenize(g,G)}}class X extends et{constructor(g){super(),this.pattern=new RegExp(`[^\\s${B}]+|[${B}]`,"gu")}pre_tokenize_text(g,G){return g.trim().match(this.pattern)||[]}}class Be extends et{constructor(g){super(),this.config=g,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=Ne,this.text_encoder=new TextEncoder}pre_tokenize_text(g,G){return this.add_prefix_space&&!g.startsWith(" ")&&(g=" "+g),(this.use_regex?g.match(this.pattern)||[]:[g]).map(me=>Array.from(this.text_encoder.encode(me),Le=>this.byte_encoder[Le]).join(""))}}class st extends et{constructor(g){super(),this.config=g,this.pattern=ae(this.config.pattern,this.config.invert)}pre_tokenize_text(g,G){return this.pattern===null?[]:this.config.invert?g.match(this.pattern)||[]:K(g,this.pattern)}}class lt extends et{constructor(g){super(),this.config=g,this.pattern=new RegExp(`[^${B}]+|[${B}]+`,"gu")}pre_tokenize_text(g,G){return g.match(this.pattern)||[]}}class rt extends et{constructor(g){super(),this.config=g;const G=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(G,"gu")}pre_tokenize_text(g,G){return g.match(this.pattern)||[]}}class Qe extends E.Callable{constructor(g){super(),this.config=g}static fromConfig(g){if(g===null)return null;switch(g.type){case"TemplateProcessing":return new Lt(g);case"ByteLevel":return new kt(g);case"RobertaProcessing":return new yt(g);case"BertProcessing":return new _t(g);case"Sequence":return new $(g);default:throw new Error(`Unknown PostProcessor type: ${g.type}`)}}post_process(g,...G){throw Error("post_process should be implemented in subclass.")}_call(g,...G){return this.post_process(g,...G)}}class _t extends Qe{constructor(g){super(g),this.cls=g.cls[0],this.sep=g.sep[0]}post_process(g,G=null,{add_special_tokens:ce=!0}={}){ce&&(g=(0,Z.mergeArrays)([this.cls],g,[this.sep]));let me=new Array(g.length).fill(0);if(G!==null){const Le=ce&&this instanceof yt?[this.sep]:[],ct=ce?[this.sep]:[];g=(0,Z.mergeArrays)(g,Le,G,ct),me=(0,Z.mergeArrays)(me,new Array(G.length+Le.length+ct.length).fill(1))}return{tokens:g,token_type_ids:me}}}class yt extends _t{}class Lt extends Qe{constructor(g){super(g),this.single=g.single,this.pair=g.pair}post_process(g,G=null,{add_special_tokens:ce=!0}={}){const me=G===null?this.single:this.pair;let Le=[],ct=[];for(const Pt of me)"SpecialToken"in Pt?ce&&(Le.push(Pt.SpecialToken.id),ct.push(Pt.SpecialToken.type_id)):"Sequence"in Pt&&(Pt.Sequence.id==="A"?(Le=(0,Z.mergeArrays)(Le,g),ct=(0,Z.mergeArrays)(ct,new Array(g.length).fill(Pt.Sequence.type_id))):Pt.Sequence.id==="B"&&(Le=(0,Z.mergeArrays)(Le,G),ct=(0,Z.mergeArrays)(ct,new Array(G.length).fill(Pt.Sequence.type_id))));return{tokens:Le,token_type_ids:ct}}}class kt extends Qe{post_process(g,G=null){return G&&(g=(0,Z.mergeArrays)(g,G)),{tokens:g}}}class $ extends Qe{constructor(g){super(g),this.processors=g.processors.map(G=>Qe.fromConfig(G))}post_process(g,G=null,ce={}){let me;for(const Le of this.processors)if(Le instanceof kt)g=Le.post_process(g).tokens,G&&(G=Le.post_process(G).tokens);else{const ct=Le.post_process(g,G,ce);g=ct.tokens,me=ct.token_type_ids}return{tokens:g,token_type_ids:me}}}class J extends E.Callable{constructor(g){super(),this.config=g,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=g.trim_offsets}static fromConfig(g){if(g===null)return null;switch(g.type){case"WordPiece":return new at(g);case"Metaspace":return new W(g);case"ByteLevel":return new At(g);case"Replace":return new z(g);case"ByteFallback":return new pe(g);case"Fuse":return new Se(g);case"Strip":return new dt(g);case"Sequence":return new bt(g);case"CTC":return new pt(g);case"BPEDecoder":return new C(g);default:throw new Error(`Unknown Decoder type: ${g.type}`)}}_call(g){return this.decode(g)}decode(g){return this.decode_chain(g).join("")}decode_chain(g){throw Error("`decode_chain` should be implemented in subclass.")}}class z extends J{decode_chain(g){const G=ae(this.config.pattern);return G===null?g:g.map(ce=>ce.replaceAll(G,this.config.content))}}class pe extends J{constructor(g){super(g),this.text_decoder=new TextDecoder}decode_chain(g){const G=[];let ce=[];for(const me of g){let Le=null;if(me.length===6&&me.startsWith("<0x")&&me.endsWith(">")){const ct=parseInt(me.slice(3,5),16);isNaN(ct)||(Le=ct)}if(Le!==null)ce.push(Le);else{if(ce.length>0){const ct=this.text_decoder.decode(Uint8Array.from(ce));G.push(ct),ce=[]}G.push(me)}}if(ce.length>0){const me=this.text_decoder.decode(Uint8Array.from(ce));G.push(me),ce=[]}return G}}class Se extends J{decode_chain(g){return[g.join("")]}}class dt extends J{constructor(g){super(g),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(g){return g.map(G=>{let ce=0;for(let Le=0;Le<this.start&&G[Le]===this.content;++Le){ce=Le+1;continue}let me=G.length;for(let Le=0;Le<this.stop;++Le){const ct=G.length-Le-1;if(G[ct]===this.content){me=ct;continue}else break}return G.slice(ce,me)})}}class at extends J{constructor(g){super(g),this.cleanup=g.cleanup}decode_chain(g){return g.map((G,ce)=>(ce!==0&&(G.startsWith(this.config.prefix)?G=G.replace(this.config.prefix,""):G=" "+G),this.cleanup&&(G=U(G)),G))}}class At extends J{constructor(g){super(g),this.byte_decoder=Pe,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(g){const G=g.join(""),ce=new Uint8Array([...G].map(Le=>this.byte_decoder[Le]));return this.text_decoder.decode(ce)}decode_chain(g){const G=[];let ce=[];for(const me of g)this.added_tokens.find(Le=>Le.content===me)!==void 0?(ce.length>0&&(G.push(this.convert_tokens_to_string(ce)),ce=[]),G.push(me)):ce.push(me);return ce.length>0&&G.push(this.convert_tokens_to_string(ce)),G}}class pt extends J{constructor(g){super(g),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(g){if(g.length===0)return"";const G=[g[0]];for(let Le=1;Le<g.length;++Le)g[Le]!==G.at(-1)&&G.push(g[Le]);let me=G.filter(Le=>Le!==this.pad_token).join("");return this.cleanup&&(me=U(me).replaceAll(this.word_delimiter_token," ").trim()),me}decode_chain(g){return[this.convert_tokens_to_string(g)]}}class bt extends J{constructor(g){super(g),this.decoders=g.decoders.map(G=>J.fromConfig(G))}decode_chain(g){return this.decoders.reduce((G,ce)=>ce.decode_chain(G),g)}}class C extends J{constructor(g){super(g),this.suffix=this.config.suffix}decode_chain(g){return g.map((G,ce)=>G.replaceAll(this.suffix,ce===g.length-1?"":" "))}}class c extends J{decode_chain(g){let G="";for(let ce=1;ce<g.length;ce+=2)G+=g[ce];return[G]}}class m extends et{constructor(g){super(),this.addPrefixSpace=g.add_prefix_space,this.replacement=g.replacement,this.strRep=g.str_rep||this.replacement,this.prepend_scheme=g.prepend_scheme??"always"}pre_tokenize_text(g,{section_index:G=void 0}={}){let ce=g.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!ce.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&G===0)&&(ce=this.strRep+ce),[ce]}}class W extends J{constructor(g){super(g),this.addPrefixSpace=g.add_prefix_space,this.replacement=g.replacement}decode_chain(g){const G=[];for(let ce=0;ce<g.length;++ce){let me=g[ce].replaceAll(this.replacement," ");this.addPrefixSpace&&ce==0&&me.startsWith(" ")&&(me=me.substring(1)),G.push(me)}return G}}class we extends F{constructor(g){super(g),this.charsmap=g.precompiled_charsmap}normalize(g){return g=g.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),g=g.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),g.includes("")?g=g.split("").map(ce=>ce.normalize("NFKC")).join(""):g=g.normalize("NFKC"),g}}class Fe extends et{constructor(g){super(),this.tokenizers=g.pretokenizers.map(G=>et.fromConfig(G))}pre_tokenize_text(g,G){return this.tokenizers.reduce((ce,me)=>me.pre_tokenize(ce,G),[g])}}class Xe extends et{constructor(g){super()}pre_tokenize_text(g,G){return g.match(/\w+|[^\w\s]+/g)||[]}}class sr extends et{constructor(g){super()}pre_tokenize_text(g,G){return q(g)}}class ot extends et{constructor(g){super(),this.config=g,this.pattern=ae(this.config.pattern),this.content=this.config.content}pre_tokenize_text(g,G){return this.pattern===null?[g]:[g.replaceAll(this.pattern,this.config.content)]}}const V=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function ve(ye,g,G,ce){for(const me of Object.keys(ye)){const Le=g-ye[me].length,ct=G(me),Pt=new Array(Le).fill(ct);ye[me]=ce==="right"?(0,Z.mergeArrays)(ye[me],Pt):(0,Z.mergeArrays)(Pt,ye[me])}}function Ie(ye,g){for(const G of Object.keys(ye))ye[G].length=g}class je extends E.Callable{return_token_type_ids=!1;padding_side="right";constructor(g,G){super(),this._tokenizer_config=G,this.normalizer=F.fromConfig(g.normalizer),this.pre_tokenizer=et.fromConfig(g.pre_tokenizer),this.model=Ce.fromConfig(g.model,G),this.post_processor=Qe.fromConfig(g.post_processor),this.decoder=J.fromConfig(g.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const ce of g.added_tokens){const me=new xe(ce);this.added_tokens.push(me),this.model.tokens_to_ids.set(me.content,me.id),this.model.vocab[me.id]=me.content,me.special&&(this.special_tokens.push(me.content),this.all_special_ids.push(me.id))}if(this.additional_special_tokens=G.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort((ce,me)=>me.content.length-ce.content.length).map(ce=>`${ce.lstrip?"\\s*":""}(${(0,Z.escapeRegExp)(ce.content)})${ce.rstrip?"\\s*":""}`).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.model_max_length=G.model_max_length,this.remove_space=G.remove_space,this.clean_up_tokenization_spaces=G.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=G.do_lowercase_and_remove_accent??!1,G.padding_side&&(this.padding_side=G.padding_side),this.legacy=!1,this.chat_template=G.chat_template??null,Array.isArray(this.chat_template)){const ce=Object.create(null);for(const{name:me,template:Le}of this.chat_template){if(typeof me!="string"||typeof Le!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');ce[me]=Le}this.chat_template=ce}this._compiled_template_cache=new Map}getToken(...g){for(const G of g){const ce=this._tokenizer_config[G];if(ce)if(typeof ce=="object"){if(ce.__type==="AddedToken")return ce.content;throw Error(`Unknown token: ${ce}`)}else return ce}return null}static async from_pretrained(g,{progress_callback:G=null,config:ce=null,cache_dir:me=null,local_files_only:Le=!1,revision:ct="main",legacy:Pt=null}={}){const Dt=await N(g,{progress_callback:G,config:ce,cache_dir:me,local_files_only:Le,revision:ct,legacy:Pt});return new this(...Dt)}_call(g,{text_pair:G=null,add_special_tokens:ce=!0,padding:me=!1,truncation:Le=null,max_length:ct=null,return_tensor:Pt=!0,return_token_type_ids:Dt=null}={}){const zt=Array.isArray(g);let $t;if(zt){if(g.length===0)throw Error("text array must be non-empty");if(G!==null){if(Array.isArray(G)){if(g.length!==G.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");$t=g.map((pr,Cr)=>this._encode_plus(pr,{text_pair:G[Cr],add_special_tokens:ce,return_token_type_ids:Dt}))}else $t=g.map(pr=>this._encode_plus(pr,{add_special_tokens:ce,return_token_type_ids:Dt}))}else{if(g==null)throw Error("text may not be null or undefined");if(Array.isArray(G))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");$t=[this._encode_plus(g,{text_pair:G,add_special_tokens:ce,return_token_type_ids:Dt})]}if(ct===null?me==="max_length"?ct=this.model_max_length:ct=(0,fe.max)($t.map(pr=>pr.input_ids.length))[0]:Le||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),ct=Math.min(ct,this.model_max_length??1/0),me||Le)for(let pr=0;pr<$t.length;++pr)$t[pr].input_ids.length!==ct&&($t[pr].input_ids.length>ct?Le&&Ie($t[pr],ct):me&&ve($t[pr],ct,Cr=>Cr==="input_ids"?this.pad_token_id:0,this.padding_side));const gr={};if(Pt){if(!(me&&Le)&&$t.some(Cr=>{for(const Xr of Object.keys(Cr))if(Cr[Xr].length!==$t[0][Xr]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const pr=[$t.length,$t[0].input_ids.length];for(const Cr of Object.keys($t[0]))gr[Cr]=new Ee.Tensor("int64",BigInt64Array.from($t.flatMap(Xr=>Xr[Cr]).map(BigInt)),pr)}else{for(const pr of Object.keys($t[0]))gr[pr]=$t.map(Cr=>Cr[pr]);if(!zt)for(const pr of Object.keys(gr))gr[pr]=gr[pr][0]}return gr}_encode_text(g){return g===null?null:(this.added_tokens_regex?g.split(this.added_tokens_regex).filter(me=>me):[g]).map((me,Le)=>{if(this.added_tokens.find(Pt=>Pt.content===me)!==void 0)return me;{if(this.remove_space===!0&&(me=me.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(me=ke(me)),this.normalizer!==null&&(me=this.normalizer(me)),me.length===0)return[];const Pt=this.pre_tokenizer!==null?this.pre_tokenizer(me,{section_index:Le}):[me];return this.model(Pt)}}).flat()}_encode_plus(g,{text_pair:G=null,add_special_tokens:ce=!0,return_token_type_ids:me=null}={}){const{tokens:Le,token_type_ids:ct}=this._tokenize_helper(g,{pair:G,add_special_tokens:ce}),Pt=this.model.convert_tokens_to_ids(Le),Dt={input_ids:Pt,attention_mask:new Array(Pt.length).fill(1)};return(me??this.return_token_type_ids)&&ct&&(Dt.token_type_ids=ct),Dt}_tokenize_helper(g,{pair:G=null,add_special_tokens:ce=!1}={}){const me=this._encode_text(g),Le=this._encode_text(G);return this.post_processor?this.post_processor(me,Le,{add_special_tokens:ce}):{tokens:(0,Z.mergeArrays)(me??[],Le??[])}}tokenize(g,{pair:G=null,add_special_tokens:ce=!1}={}){return this._tokenize_helper(g,{pair:G,add_special_tokens:ce}).tokens}encode(g,{text_pair:G=null,add_special_tokens:ce=!0,return_token_type_ids:me=null}={}){return this._encode_plus(g,{text_pair:G,add_special_tokens:ce,return_token_type_ids:me}).input_ids}batch_decode(g,G={}){return g instanceof Ee.Tensor&&(g=g.tolist()),g.map(ce=>this.decode(ce,G))}decode(g,G={}){if(g instanceof Ee.Tensor&&(g=Te(g)),!Array.isArray(g)||g.length===0||!(0,Z.isIntegralNumber)(g[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(g,G)}decode_single(g,{skip_special_tokens:G=!1,clean_up_tokenization_spaces:ce=null}){let me=this.model.convert_ids_to_tokens(g);G&&(me=me.filter(ct=>!this.special_tokens.includes(ct)));let Le=this.decoder?this.decoder(me):me.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Le=Le.replaceAll(this.decoder.end_of_word_suffix," "),G&&(Le=Le.trim())),(ce??this.clean_up_tokenization_spaces)&&(Le=U(Le)),Le}get_chat_template({chat_template:g=null,tools:G=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const ce=this.chat_template;if(g!==null&&Object.hasOwn(ce,g))g=ce[g];else if(g===null)if(G!==null&&"tool_use"in ce)g=ce.tool_use;else if("default"in ce)g=ce.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(ce).sort()}.`)}else if(g===null)if(this.chat_template)g=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return g}apply_chat_template(g,{tools:G=null,documents:ce=null,chat_template:me=null,add_generation_prompt:Le=!1,tokenize:ct=!0,padding:Pt=!1,truncation:Dt=!1,max_length:zt=null,return_tensor:$t=!0,return_dict:gr=!1,tokenizer_kwargs:pr={},...Cr}={}){if(me=this.get_chat_template({chat_template:me,tools:G}),typeof me!="string")throw Error(`chat_template must be a string, but got ${typeof me}`);let Xr=this._compiled_template_cache.get(me);Xr===void 0&&(Xr=new O.Template(me),this._compiled_template_cache.set(me,Xr));const bn=Object.create(null);for(const kr of V){const xn=this.getToken(kr);xn&&(bn[kr]=xn)}const hr=Xr.render({messages:g,add_generation_prompt:Le,tools:G,documents:ce,...bn,...Cr});if(ct){const kr=this._call(hr,{add_special_tokens:!1,padding:Pt,truncation:Dt,max_length:zt,return_tensor:$t,...pr});return gr?kr:kr.input_ids}return hr}}class Ze extends je{return_token_type_ids=!0}class mt extends je{return_token_type_ids=!0}class Ct extends je{return_token_type_ids=!0}class Et extends je{return_token_type_ids=!0}class Ft extends je{return_token_type_ids=!0}class Tt extends je{return_token_type_ids=!0}class Ut extends je{return_token_type_ids=!0}class Wt extends je{return_token_type_ids=!0}class Nt extends je{return_token_type_ids=!0}class We extends je{}class Ge extends je{}class vt extends je{return_token_type_ids=!0;constructor(g,G){super(g,G),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Ht extends je{return_token_type_ids=!0}class ar extends je{}class Or extends je{}class jr extends je{}class Er extends je{constructor(g,G){super(g,G),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(ce=>this.languageRegex.test(ce)),this.lang_to_token=ce=>ce}_build_translation_inputs(g,G,ce){return $n(this,g,G,ce)}}class zr extends Er{}class Ar extends je{}class zn extends je{}const Nr="";class mi extends je{padding_side="left";constructor(g,G){super(g,G),this.legacy=G.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new m({replacement:Nr,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(g){if(g===null)return null;if(this.legacy||g.length===0)return super._encode_text(g);let G=super._encode_text(Nr+g.replaceAll(Nr," "));return G.length>1&&G[0]===Nr&&this.special_tokens.includes(G[1])&&(G=G.slice(1)),G}}class ki extends je{}class Xn extends je{}class Pi extends je{}class Ai extends je{}class Ii extends je{}class Fi extends je{}class Oi extends je{}class ti extends je{}class Yn extends je{}function $n(ye,g,G,ce){if(!("language_codes"in ye)||!Array.isArray(ye.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in ye)||!(ye.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in ye)||typeof ye.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const me=ce.src_lang,Le=ce.tgt_lang;if(!ye.language_codes.includes(Le))throw new Error(`Target language code "${Le}" is not valid. Must be one of: {${ye.language_codes.join(", ")}}`);if(me!==void 0){if(!ye.language_codes.includes(me))throw new Error(`Source language code "${me}" is not valid. Must be one of: {${ye.language_codes.join(", ")}}`);for(const ct of ye.post_processor.config.single)if("SpecialToken"in ct&&ye.languageRegex.test(ct.SpecialToken.id)){ct.SpecialToken.id=ye.lang_to_token(me);break}}return ce.forced_bos_token_id=ye.model.convert_tokens_to_ids([ye.lang_to_token(Le)])[0],ye._call(g,G)}class Ln extends je{constructor(g,G){super(g,G),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(ce=>this.languageRegex.test(ce)),this.lang_to_token=ce=>ce}_build_translation_inputs(g,G,ce){return $n(this,g,G,ce)}}class gi extends je{constructor(g,G){super(g,G),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(ce=>this.languageRegex.test(ce)).map(ce=>ce.slice(2,-2)),this.lang_to_token=ce=>`__${ce}__`}_build_translation_inputs(g,G,ce){return $n(this,g,G,ce)}}class On extends je{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(g,{return_timestamps:G=!1,return_language:ce=!1,time_precision:me=null,force_full_sequences:Le=!0}={}){if(me===null)throw Error("Must specify time_precision");let ct=null;const Pt=G==="word";function Dt(){return{language:ct,timestamp:[null,null],text:""}}const zt=[];let $t=Dt(),gr=0;const pr=this.timestamp_begin;let Cr=[],Xr=[],bn=!1,hr=null;const kr=new Set(this.all_special_ids);for(const De of g){const Jr=De.tokens,ln=Pt?De.token_timestamps:null;let kn=null,Rn=pr;if("stride"in De){const[Yr,_r,Br]=De.stride;if(gr-=_r,hr=Yr-Br,_r&&(Rn=_r/me+pr),Br)for(let Ot=Jr.length-1;Ot>=0;--Ot){const br=Number(Jr[Ot]);if(br>=pr){if(kn!==null&&(br-pr)*me<hr)break;kn=br}}}let Jt=[],pn=[];for(let Yr=0;Yr<Jr.length;++Yr){const _r=Number(Jr[Yr]);if(kr.has(_r)){const Br=this.decode([_r]),Ot=M.WHISPER_LANGUAGE_MAPPING.get(Br.slice(2,-2));if(Ot!==void 0){if(ct!==null&&Ot!==ct&&!G){Cr.push(Jt);const br=this.findLongestCommonSequence(Cr)[0],ii=this.decode(br);$t.text=ii,zt.push($t),Cr=[],Jt=[],$t=Dt()}ct=$t.language=Ot}}else if(_r>=pr){const Br=(_r-pr)*me+gr,Ot=(0,fe.round)(Br,2);if(kn!==null&&_r>=kn)bn=!0;else if(bn||Cr.length>0&&_r<Rn)bn=!1;else if($t.timestamp[0]===null)$t.timestamp[0]=Ot;else if(Ot!==$t.timestamp[0]){$t.timestamp[1]=Ot,Cr.push(Jt),Pt&&Xr.push(pn);const[br,ii]=this.findLongestCommonSequence(Cr,Xr),Qn=this.decode(br);$t.text=Qn,Pt&&($t.words=this.collateWordTimestamps(br,ii,ct)),zt.push($t),Cr=[],Jt=[],Xr=[],pn=[],$t=Dt()}}else if(Jt.push(_r),Pt){let Br=(0,fe.round)(ln[Yr]+gr,2),Ot;if(Yr+1<ln.length){Ot=(0,fe.round)(ln[Yr+1]+gr,2);const br=this.decode([_r]);H.test(br)&&(Ot=(0,fe.round)(Math.min(Br+me,Ot),2))}else Ot=null;pn.push([Br,Ot])}}if("stride"in De){const[Yr,_r,Br]=De.stride;gr+=Yr-Br}Jt.length>0?(Cr.push(Jt),Pt&&Xr.push(pn)):Cr.every(Yr=>Yr.length===0)&&($t=Dt(),Cr=[],Jt=[],Xr=[],pn=[])}if(Cr.length>0){if(Le&&G)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[De,Jr]=this.findLongestCommonSequence(Cr,Xr),ln=this.decode(De);$t.text=ln,Pt&&($t.words=this.collateWordTimestamps(De,Jr,ct)),zt.push($t)}let xn=Object.create(null);const Sn=zt.map(De=>De.text).join("");if(G||ce){for(let De=0;De<zt.length;++De){const Jr=zt[De];G||delete Jr.timestamp,ce||delete Jr.language}if(Pt){const De=[];for(const Jr of zt)for(const ln of Jr.words)De.push(ln);xn={chunks:De}}else xn={chunks:zt}}return[Sn,xn]}findLongestCommonSequence(g,G=null){let ce=g[0],me=ce.length,Le=[];const ct=Array.isArray(G)&&G.length>0;let Pt=ct?[]:null,Dt=ct?G[0]:null;for(let zt=1;zt<g.length;++zt){const $t=g[zt];let gr=0,pr=[me,me,0,0];const Cr=$t.length;for(let De=1;De<me+Cr;++De){const Jr=Math.max(0,me-De),ln=Math.min(me,me+Cr-De),kn=ce.slice(Jr,ln),Rn=Math.max(0,De-me),Jt=Math.min(Cr,De),pn=$t.slice(Rn,Jt);if(kn.length!==pn.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let Yr;ct?Yr=kn.filter((Ot,br)=>Ot===pn[br]&&Dt[Jr+br]<=G[zt][Rn+br]).length:Yr=kn.filter((Ot,br)=>Ot===pn[br]).length;const _r=De/1e4,Br=Yr/De+_r;Yr>1&&Br>gr&&(gr=Br,pr=[Jr,ln,Rn,Jt])}const[Xr,bn,hr,kr]=pr,xn=Math.floor((bn+Xr)/2),Sn=Math.floor((kr+hr)/2);Le.push(...ce.slice(0,xn)),ce=$t.slice(Sn),me=ce.length,ct&&(Pt.push(...Dt.slice(0,xn)),Dt=G[zt].slice(Sn))}return Le.push(...ce),ct?(Pt.push(...Dt),[Le,Pt]):[Le,[]]}collateWordTimestamps(g,G,ce){const[me,Le,ct]=this.combineTokensIntoWords(g,ce),Pt=[];for(let Dt=0;Dt<me.length;++Dt){const zt=ct[Dt];Pt.push({text:me[Dt],timestamp:[G[zt.at(0)][0],G[zt.at(-1)][1]]})}return Pt}combineTokensIntoWords(g,G,ce=`"'([{-`,me=`"'.,!?:)]}`){G=G??"english";let Le,ct,Pt;return["chinese","japanese","thai","lao","myanmar"].includes(G)?[Le,ct,Pt]=this.splitTokensOnUnicode(g):[Le,ct,Pt]=this.splitTokensOnSpaces(g),this.mergePunctuations(Le,ct,Pt,ce,me)}decode(g,G){let ce;return G?.decode_with_timestamps?(g instanceof Ee.Tensor&&(g=Te(g)),ce=this.decodeWithTimestamps(g,G)):ce=super.decode(g,G),ce}decodeWithTimestamps(g,G){const ce=G?.time_precision??.02,me=Array.from(this.all_special_ids).at(-1)+1;let Le=[[]];for(let ct of g)if(ct=Number(ct),ct>=me){const Pt=((ct-me)*ce).toFixed(2);Le.push(`<|${Pt}|>`),Le.push([])}else Le[Le.length-1].push(ct);return Le=Le.map(ct=>typeof ct=="string"?ct:super.decode(ct,G)),Le.join("")}splitTokensOnUnicode(g){const G=this.decode(g,{decode_with_timestamps:!0}),ce="",me=[],Le=[],ct=[];let Pt=[],Dt=[],zt=0;for(let $t=0;$t<g.length;++$t){const gr=g[$t];Pt.push(gr),Dt.push($t);const pr=this.decode(Pt,{decode_with_timestamps:!0});(!pr.includes(ce)||G[zt+pr.indexOf(ce)]===ce)&&(me.push(pr),Le.push(Pt),ct.push(Dt),Pt=[],Dt=[],zt+=pr.length)}return[me,Le,ct]}splitTokensOnSpaces(g){const[G,ce,me]=this.splitTokensOnUnicode(g),Le=[],ct=[],Pt=[],Dt=new RegExp(`^[${B}]$`,"gu");for(let zt=0;zt<G.length;++zt){const $t=G[zt],gr=ce[zt],pr=me[zt],Cr=gr[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),Xr=$t.startsWith(" "),bn=$t.trim(),hr=Dt.test(bn);if(Cr||Xr||hr||Le.length===0)Le.push($t),ct.push(gr),Pt.push(pr);else{const kr=Le.length-1;Le[kr]+=$t,ct[kr].push(...gr),Pt[kr].push(...pr)}}return[Le,ct,Pt]}mergePunctuations(g,G,ce,me,Le){const ct=structuredClone(g),Pt=structuredClone(G),Dt=structuredClone(ce);let zt=ct.length-2,$t=ct.length-1;for(;zt>=0;)ct[zt].startsWith(" ")&&me.includes(ct[zt].trim())?(ct[$t]=ct[zt]+ct[$t],Pt[$t]=(0,Z.mergeArrays)(Pt[zt],Pt[$t]),Dt[$t]=(0,Z.mergeArrays)(Dt[zt],Dt[$t]),ct[zt]="",Pt[zt]=[],Dt[zt]=[]):$t=zt,--zt;for(zt=0,$t=1;$t<ct.length;)!ct[zt].endsWith(" ")&&Le.includes(ct[$t])?(ct[zt]+=ct[$t],Pt[zt]=(0,Z.mergeArrays)(Pt[zt],Pt[$t]),Dt[zt]=(0,Z.mergeArrays)(Dt[zt],Dt[$t]),ct[$t]="",Pt[$t]=[],Dt[$t]=[]):zt=$t,++$t;return[ct.filter(gr=>gr),Pt.filter(gr=>gr.length>0),Dt.filter(gr=>gr.length>0)]}}class _i extends je{}class wi extends je{}class yi extends je{}class rr extends je{constructor(g,G){super(g,G),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(ce=>this.languageRegex.test(ce)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(g){if(g===null)return null;const[G,...ce]=g.trim().split(this.languageRegex);if(ce.length===0)return super._encode_text(G);if(ce.length===2){const[me,Le]=ce;return this.supported_language_codes.includes(me)||console.warn(`Unsupported language code "${me}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,Z.mergeArrays)([me],super._encode_text(Le))}}}class ri extends je{}class Bi extends je{}class Di extends je{}class bi extends je{}class zi extends je{}class Li extends je{constructor(g,G){super(g,G),this.decoder=new c({})}}class ni extends je{}class ns{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:ar,DistilBertTokenizer:We,CamembertTokenizer:Ge,DebertaTokenizer:Ft,DebertaV2Tokenizer:Tt,BertTokenizer:Ze,HerbertTokenizer:Ut,ConvBertTokenizer:Wt,RoFormerTokenizer:Nt,XLMTokenizer:vt,ElectraTokenizer:Ht,MobileBertTokenizer:Ct,SqueezeBertTokenizer:Et,AlbertTokenizer:mt,GPT2Tokenizer:Or,BartTokenizer:jr,MBartTokenizer:Er,MBart50Tokenizer:zr,RobertaTokenizer:Ar,WhisperTokenizer:On,CodeGenTokenizer:_i,CLIPTokenizer:wi,SiglipTokenizer:yi,MarianTokenizer:rr,BloomTokenizer:zn,NllbTokenizer:Ln,M2M100Tokenizer:gi,LlamaTokenizer:mi,CodeLlamaTokenizer:ki,XLMRobertaTokenizer:Xn,MPNetTokenizer:Pi,FalconTokenizer:Ai,GPTNeoXTokenizer:Ii,EsmTokenizer:Fi,Wav2Vec2CTCTokenizer:ri,BlenderbotTokenizer:Bi,BlenderbotSmallTokenizer:Di,SpeechT5Tokenizer:bi,NougatTokenizer:zi,VitsTokenizer:Li,Qwen2Tokenizer:Oi,GemmaTokenizer:ti,Grok1Tokenizer:Yn,CohereTokenizer:ni,PreTrainedTokenizer:je};static async from_pretrained(g,{progress_callback:G=null,config:ce=null,cache_dir:me=null,local_files_only:Le=!1,revision:ct="main",legacy:Pt=null}={}){const[Dt,zt]=await N(g,{progress_callback:G,config:ce,cache_dir:me,local_files_only:Le,revision:ct,legacy:Pt}),$t=zt.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let gr=this.TOKENIZER_CLASS_MAPPING[$t];return gr||(console.warn(`Unknown tokenizer class "${$t}", attempting to construct from base class.`),gr=je),new gr(Dt,zt)}}},"./src/utils/audio.js":(oe,R,T)=>{T.r(R),T.d(R,{hamming:()=>M,hanning:()=>O,mel_filter_bank:()=>ue,read_audio:()=>Ee,spectrogram:()=>B,window_function:()=>H});var E=T("./src/utils/hub.js"),Z=T("./src/utils/maths.js"),re=T("./src/utils/core.js"),fe=T("./src/utils/tensor.js");async function Ee(I,Me){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const xe=await(await(0,E.getFile)(I)).arrayBuffer(),Ce=new AudioContext({sampleRate:Me});typeof Me>"u"&&console.warn(`No sampling rate provided, using default of ${Ce.sampleRate}Hz.`);const Ve=await Ce.decodeAudioData(xe);let Ue;if(Ve.numberOfChannels===2){const Ne=Math.sqrt(2),Pe=Ve.getChannelData(0),Ae=Ve.getChannelData(1);Ue=new Float32Array(Pe.length);for(let ie=0;ie<Ve.length;++ie)Ue[ie]=Ne*(Pe[ie]+Ae[ie])/2}else Ue=Ve.getChannelData(0);return Ue}function j(I,Me){if(I<1)return new Float64Array;if(I===1)return new Float64Array([1]);const xe=1-Me,Ce=2*Math.PI/(I-1),Ve=new Float64Array(I);for(let Ue=0;Ue<I;++Ue)Ve[Ue]=Me-xe*Math.cos(Ue*Ce);return Ve}function O(I){return j(I,.5)}function M(I){return j(I,.54)}const N={htk:I=>2595*Math.log10(1+I/700),kaldi:I=>1127*Math.log(1+I/700),slaney:(I,Me=1e3,xe=15,Ce=27/Math.log(6.4))=>I>=Me?xe+Math.log(I/Me)*Ce:3*I/200};function K(I,Me="htk"){const xe=N[Me];if(!xe)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof I=="number"?xe(I):I.map(Ce=>xe(Ce))}const ae={htk:I=>700*(10**(I/2595)-1),kaldi:I=>700*(Math.exp(I/1127)-1),slaney:(I,Me=1e3,xe=15,Ce=Math.log(6.4)/27)=>I>=xe?Me*Math.exp(Ce*(I-xe)):200*I/3};function $e(I,Me="htk"){const xe=ae[Me];if(!xe)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof I=="number"?xe(I):I.map(Ce=>xe(Ce))}function Te(I,Me){const xe=Float64Array.from({length:Me.length-1},(Ne,Pe)=>Me[Pe+1]-Me[Pe]),Ce=Array.from({length:I.length},()=>new Array(Me.length));for(let Ne=0;Ne<I.length;++Ne){const Pe=Ce[Ne];for(let Ae=0;Ae<Me.length;++Ae)Pe[Ae]=Me[Ae]-I[Ne]}const Ve=Me.length-2,Ue=Array.from({length:Ve},()=>new Array(I.length));for(let Ne=0;Ne<I.length;++Ne){const Pe=Ce[Ne];for(let Ae=0;Ae<Ve;++Ae){const ie=-Pe[Ae]/xe[Ae],F=Pe[Ae+2]/xe[Ae+1];Ue[Ae][Ne]=Math.max(0,Math.min(ie,F))}}return Ue}function U(I,Me,xe){const Ce=(Me-I)/(xe-1);return Float64Array.from({length:xe},(Ve,Ue)=>I+Ce*Ue)}function ue(I,Me,xe,Ce,Ve,Ue=null,Ne="htk",Pe=!1){if(Ue!==null&&Ue!=="slaney")throw new Error('norm must be one of null or "slaney"');const Ae=K(xe,Ne),ie=K(Ce,Ne),F=U(Ae,ie,Me+2);let se=$e(F,Ne),_e;if(Pe){const nt=Ve/(I*2);_e=K(Float64Array.from({length:I},(de,Re)=>Re*nt),Ne),se=F}else _e=U(0,Math.floor(Ve/2),I);const Oe=Te(_e,se);if(Ue!==null&&Ue==="slaney")for(let nt=0;nt<Me;++nt){const de=Oe[nt],Re=2/(se[nt+2]-se[nt]);for(let it=0;it<I;++it)de[it]*=Re}return Oe}function ke(I,Me,xe){const Ce=new I.constructor(I.length+Me+xe),Ve=I.length-1;for(let Ue=0;Ue<I.length;++Ue)Ce[Me+Ue]=I[Ue];for(let Ue=1;Ue<=Me;++Ue)Ce[Me-Ue]=I[(0,re.calculateReflectOffset)(Ue,Ve)];for(let Ue=1;Ue<=xe;++Ue)Ce[Ve+Me+Ue]=I[(0,re.calculateReflectOffset)(Ve-Ue,Ve)];return Ce}function te(I,Me,xe,Ce,Ve){if(xe<=0)throw new Error("reference must be greater than zero");if(Ce<=0)throw new Error("min_value must be greater than zero");xe=Math.max(Ce,xe);const Ue=Math.log10(xe);for(let Ne=0;Ne<I.length;++Ne)I[Ne]=Me*Math.log10(Math.max(Ce,I[Ne])-Ue);if(Ve!==null){if(Ve<=0)throw new Error("db_range must be greater than zero");const Ne=(0,Z.max)(I)[0]-Ve;for(let Pe=0;Pe<I.length;++Pe)I[Pe]=Math.max(I[Pe],Ne)}return I}function ee(I,Me=1,xe=1e-5,Ce=null){return te(I,20,Me,xe,Ce)}function q(I,Me=1,xe=1e-10,Ce=null){return te(I,10,Me,xe,Ce)}async function B(I,Me,xe,Ce,{fft_length:Ve=null,power:Ue=1,center:Ne=!0,pad_mode:Pe="reflect",onesided:Ae=!0,preemphasis:ie=null,mel_filters:F=null,mel_floor:se=1e-10,log_mel:_e=null,reference:Oe=1,min_value:nt=1e-10,db_range:de=null,remove_dc_offset:Re=null,min_num_frames:it=null,max_num_frames:He=null,do_pad:wt=!0,transpose:xt=!1}={}){const et=Me.length;if(Ve===null&&(Ve=xe),xe>Ve)throw Error(`frame_length (${xe}) may not be larger than fft_length (${Ve})`);if(et!==xe)throw new Error(`Length of the window (${et}) must equal frame_length (${xe})`);if(Ce<=0)throw new Error("hop_length must be greater than zero");if(Ue===null&&F!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(Ne){if(Pe!=="reflect")throw new Error(`pad_mode="${Pe}" not implemented yet.`);const J=Math.floor((Ve-1)/2)+1;I=ke(I,J,J)}let X=Math.floor(1+Math.floor((I.length-xe)/Ce));it!==null&&X<it&&(X=it);const Be=Ae?Math.floor(Ve/2)+1:Ve;let st=X,lt=X;He!==null&&(He>X?wt&&(lt=He):lt=st=He);const rt=new Z.FFT(Ve),Qe=new Float64Array(Ve),_t=new Float64Array(rt.outputBufferSize),yt=new Float32Array(Be*lt);for(let J=0;J<st;++J){const z=J*Ce,pe=Math.min(I.length-z,xe);pe!==xe&&Qe.fill(0,0,xe);for(let Se=0;Se<pe;++Se)Qe[Se]=I[z+Se];if(Re){let Se=0;for(let at=0;at<pe;++at)Se+=Qe[at];const dt=Se/pe;for(let at=0;at<pe;++at)Qe[at]-=dt}if(ie!==null){for(let Se=pe-1;Se>=1;--Se)Qe[Se]-=ie*Qe[Se-1];Qe[0]*=1-ie}for(let Se=0;Se<Me.length;++Se)Qe[Se]*=Me[Se];rt.realTransform(_t,Qe);for(let Se=0;Se<Be;++Se){const dt=Se<<1;yt[Se*lt+J]=_t[dt]**2+_t[dt+1]**2}}if(Ue!==null&&Ue!==2){const J=2/Ue;for(let z=0;z<yt.length;++z)yt[z]**=J}const Lt=F.length;let kt=await(0,fe.matmul)(new fe.Tensor("float32",F.flat(),[Lt,Be]),new fe.Tensor("float32",yt,[Be,lt]));xt&&(kt=kt.transpose(1,0));const $=kt.data;for(let J=0;J<$.length;++J)$[J]=Math.max(se,$[J]);if(Ue!==null&&_e!==null){const J=Math.min($.length,st*Lt);switch(_e){case"log":for(let z=0;z<J;++z)$[z]=Math.log($[z]);break;case"log10":for(let z=0;z<J;++z)$[z]=Math.log10($[z]);break;case"dB":if(Ue===1)ee($,Oe,nt,de);else if(Ue===2)q($,Oe,nt,de);else throw new Error(`Cannot use log_mel option '${_e}' with power ${Ue}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${_e}'`)}}return kt}function H(I,Me,{periodic:xe=!0,frame_length:Ce=null,center:Ve=!0}={}){const Ue=xe?I+1:I;let Ne;switch(Me){case"boxcar":Ne=new Float64Array(Ue).fill(1);break;case"hann":case"hann_window":Ne=O(Ue);break;case"hamming":Ne=M(Ue);break;case"povey":Ne=O(Ue).map(Pe=>Math.pow(Pe,.85));break;default:throw new Error(`Unknown window type ${Me}.`)}if(xe&&(Ne=Ne.subarray(0,I)),Ce===null)return Ne;if(I>Ce)throw new Error(`Length of the window (${I}) may not be larger than frame_length (${Ce})`);return Ne}},"./src/utils/constants.js":(oe,R,T)=>{T.r(R),T.d(R,{GITHUB_ISSUE_URL:()=>E});const E="https://github.com/huggingface/transformers.js/issues/new/choose"},"./src/utils/core.js":(oe,R,T)=>{T.r(R),T.d(R,{calculateDimensions:()=>j,calculateReflectOffset:()=>K,dispatchCallback:()=>E,escapeRegExp:()=>re,isIntegralNumber:()=>Ee,isTypedArray:()=>fe,len:()=>$e,mergeArrays:()=>M,pick:()=>ae,pop:()=>O,product:()=>N,reverseDictionary:()=>Z});function E(Te,U){Te&&Te(U)}function Z(Te){return Object.fromEntries(Object.entries(Te).map(([U,ue])=>[ue,U]))}function re(Te){return Te.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function fe(Te){return Te?.prototype?.__proto__?.constructor?.name==="TypedArray"}function Ee(Te){return Number.isInteger(Te)||typeof Te=="bigint"}function j(Te){const U=[];let ue=Te;for(;Array.isArray(ue);)U.push(ue.length),ue=ue[0];return U}function O(Te,U,ue=void 0){const ke=Te[U];if(ke!==void 0)return delete Te[U],ke;if(ue===void 0)throw Error(`Key ${U} does not exist in object.`);return ue}function M(...Te){return Array.prototype.concat.apply([],Te)}function N(...Te){return Te.reduce((U,ue)=>U.flatMap(ke=>ue.map(te=>[ke,te])))}function K(Te,U){return Math.abs((Te+U)%(2*U)-U)}function ae(Te,U){return Object.assign({},...U.map(ue=>{if(Te[ue]!==void 0)return{[ue]:Te[ue]}}))}function $e(Te){let U=0;for(const ue of Te)++U;return U}},"./src/utils/data-structures.js":(oe,R,T)=>{T.r(R),T.d(R,{CharTrie:()=>Z,PriorityQueue:()=>E,TokenLattice:()=>fe});class E{constructor(O=(N,K)=>N>K,M=1/0){this._heap=[],this._comparator=O,this._maxSize=M}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...O){return this.extend(O)}extend(O){for(const M of O)if(this.size<this._maxSize)this._heap.push(M),this._siftUp();else{const N=this._smallest();this._comparator(M,this._heap[N])&&(this._heap[N]=M,this._siftUpFrom(N))}return this.size}pop(){const O=this.peek(),M=this.size-1;return M>0&&this._swap(0,M),this._heap.pop(),this._siftDown(),O}replace(O){const M=this.peek();return this._heap[0]=O,this._siftDown(),M}_parent(O){return(O+1>>>1)-1}_left(O){return(O<<1)+1}_right(O){return O+1<<1}_greater(O,M){return this._comparator(this._heap[O],this._heap[M])}_swap(O,M){const N=this._heap[O];this._heap[O]=this._heap[M],this._heap[M]=N}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(O){for(;O>0&&this._greater(O,this._parent(O));)this._swap(O,this._parent(O)),O=this._parent(O)}_siftDown(){let O=0;for(;this._left(O)<this.size&&this._greater(this._left(O),O)||this._right(O)<this.size&&this._greater(this._right(O),O);){const M=this._right(O)<this.size&&this._greater(this._right(O),this._left(O))?this._right(O):this._left(O);this._swap(O,M),O=M}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class Z{constructor(){this.root=re.default()}extend(O){for(const M of O)this.push(M)}push(O){let M=this.root;for(const N of O){let K=M.children.get(N);K===void 0&&(K=re.default(),M.children.set(N,K)),M=K}M.isLeaf=!0}*commonPrefixSearch(O){let M=this.root;if(M===void 0)return;let N="";for(const K of O){if(N+=K,M=M.children.get(K),M===void 0)return;M.isLeaf&&(yield N)}}}class re{constructor(O,M){this.isLeaf=O,this.children=M}static default(){return new re(!1,new Map)}}class fe{constructor(O,M,N){this.chars=Array.from(O),this.len=this.chars.length,this.bosTokenId=M,this.eosTokenId=N,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const K=new Ee(this.bosTokenId,0,0,0,0),ae=new Ee(this.eosTokenId,1,this.len,0,0);this.nodes.push(K.clone()),this.nodes.push(ae.clone()),this.beginNodes[this.len].push(ae),this.endNodes[0].push(K)}insert(O,M,N,K){const ae=this.nodes.length,$e=new Ee(K,ae,O,M,N);this.beginNodes[O].push($e),this.endNodes[O+M].push($e),this.nodes.push($e)}viterbi(){const O=this.len;let M=0;for(;M<=O;){if(this.beginNodes[M].length==0)return[];for(let Te of this.beginNodes[M]){Te.prev=null;let U=0,ue=null;for(let ke of this.endNodes[M]){const te=ke.backtraceScore+Te.score;(ue===null||te>U)&&(ue=ke.clone(),U=te)}if(ue!==null)Te.prev=ue,Te.backtraceScore=U;else return[]}++M}const N=[],ae=this.beginNodes[O][0].prev;if(ae===null)return[];let $e=ae.clone();for(;$e.prev!==null;)N.push($e.clone()),$e=$e.clone().prev.clone();return N.reverse(),N}piece(O){return this.chars.slice(O.pos,O.pos+O.length).join("")}tokens(){return this.viterbi().map(M=>this.piece(M))}tokenIds(){return this.viterbi().map(M=>M.tokenId)}}class Ee{constructor(O,M,N,K,ae){this.tokenId=O,this.nodeId=M,this.pos=N,this.length=K,this.score=ae,this.prev=null,this.backtraceScore=0}clone(){const O=new Ee(this.tokenId,this.nodeId,this.pos,this.length,this.score);return O.prev=this.prev,O.backtraceScore=this.backtraceScore,O}}},"./src/utils/devices.js":(oe,R,T)=>{T.r(R),T.d(R,{DEVICE_TYPES:()=>E});const E=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(oe,R,T)=>{T.r(R),T.d(R,{DATA_TYPES:()=>fe,DEFAULT_DEVICE_DTYPE_MAPPING:()=>Ee,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>j,isWebGpuFp16Supported:()=>re});var E=T("./src/env.js"),Z=T("./src/utils/devices.js");const re=function(){let O;return async function(){if(O===void 0)if(!E.apis.IS_WEBGPU_AVAILABLE)O=!1;else try{O=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{O=!1}return O}}(),fe=Object.freeze({fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),Ee=Object.freeze({[Z.DEVICE_TYPES.wasm]:fe.q8}),j=Object.freeze({[fe.fp32]:"",[fe.fp16]:"_fp16",[fe.int8]:"_int8",[fe.uint8]:"_uint8",[fe.q8]:"_quantized",[fe.q4]:"_q4",[fe.q4f16]:"_q4f16",[fe.bnb4]:"_bnb4"})},"./src/utils/generic.js":(oe,R,T)=>{T.r(R),T.d(R,{Callable:()=>E});const E=class{constructor(){let Z=function(...re){return Z._call(...re)};return Object.setPrototypeOf(Z,new.target.prototype)}_call(...Z){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(oe,R,T)=>{T.r(R),T.d(R,{getFile:()=>M,getModelFile:()=>Te,getModelJSON:()=>U});var E=T("?7a2c"),Z=T("?a42a"),re=T("./src/env.js"),fe=T("./src/utils/core.js");const Ee={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class j{constructor(ee){if(this.filePath=ee,this.headers=new Headers,this.exists=E.existsSync(ee),this.exists){this.status=200,this.statusText="OK";let q=E.statSync(ee);this.headers.set("content-length",q.size.toString()),this.updateContentType();let B=this;this.body=new ReadableStream({start(H){B.arrayBuffer().then(I=>{H.enqueue(new Uint8Array(I)),H.close()})}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const ee=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",Ee[ee]??"application/octet-stream")}clone(){let ee=new j(this.filePath);return ee.exists=this.exists,ee.status=this.status,ee.statusText=this.statusText,ee.headers=new Headers(this.headers),ee}async arrayBuffer(){return(await E.promises.readFile(this.filePath)).buffer}async blob(){const ee=await E.promises.readFile(this.filePath);return new Blob([ee],{type:this.headers.get("content-type")})}async text(){return await E.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function O(te,ee=null,q=null){let B;try{B=new URL(te)}catch{return!1}return!(ee&&!ee.includes(B.protocol)||q&&!q.includes(B.hostname))}async function M(te){if(re.env.useFS&&!O(te,["http:","https:","blob:"]))return new j(te);if(typeof Es<"u"&&Es?.release?.name==="node"){const ee=!!Np?.TESTING_REMOTELY,q=re.env.version,B=new Headers;if(B.set("User-Agent",`transformers.js/${q}; is_ci/${ee};`),O(te,["http:","https:"],["huggingface.co","hf.co"])){const I=Np?.HF_TOKEN??Np?.HF_ACCESS_TOKEN;I&&B.set("Authorization",`Bearer ${I}`)}return fetch(te,{headers:B})}else return fetch(te)}const N={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function K(te,ee,q){if(!q)return null;const B=N[te]??`Error (${te}) occurred while trying to load file`;throw Error(`${B}: "${ee}".`)}class ae{constructor(ee){this.path=ee}async match(ee){let q=Z.join(this.path,ee),B=new j(q);if(B.exists)return B}async put(ee,q){const B=w_.from(await q.arrayBuffer());let H=Z.join(this.path,ee);try{await E.promises.mkdir(Z.dirname(H),{recursive:!0}),await E.promises.writeFile(H,B)}catch(I){console.warn("An error occurred while writing the file to cache:",I)}}}async function $e(te,...ee){for(let q of ee)try{let B=await te.match(q);if(B)return B}catch{continue}}async function Te(te,ee,q=!0,B={}){if(!re.env.allowLocalModels){if(B.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!re.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,fe.dispatchCallback)(B.progress_callback,{status:"initiate",name:te,file:ee});let H;if(!H&&re.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{H=await caches.open("transformers-cache")}catch(_e){console.warn("An error occurred while opening the browser cache:",_e)}}if(!H&&re.env.useFSCache&&(H=new ae(B.cache_dir??re.env.cacheDir)),!H&&re.env.useCustomCache){if(!re.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!re.env.customCache.match||!re.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");H=re.env.customCache}const I=B.revision??"main";let Me=ke(te,ee),xe=ke(re.env.localModelPath,Me),Ce=ke(re.env.remoteHost,re.env.remotePathTemplate.replaceAll("{model}",te).replaceAll("{revision}",encodeURIComponent(I)),ee),Ve=I==="main"?Me:ke(te,I,ee),Ue,Ne=H instanceof ae?Ve:Ce,Pe=!1,Ae;H&&(Ae=await $e(H,xe,Ne));const ie=Ae!==void 0;if(Ae===void 0){if(re.env.allowLocalModels)if(O(Me,["http:","https:"])){if(B.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${Me}.`);if(!re.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${Me}.`)}else try{Ae=await M(xe),Ue=xe}catch(Oe){console.warn(`Unable to load from local path "${xe}": "${Oe}"`)}if(Ae===void 0||Ae.status===404){if(B.local_files_only||!re.env.allowRemoteModels){if(q)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${xe}".`);return null}if(Ae=await M(Ce),Ae.status!==200)return K(Ae.status,Ce,q);Ue=Ne}Pe=H&&typeof Response<"u"&&Ae instanceof Response&&Ae.status===200}(0,fe.dispatchCallback)(B.progress_callback,{status:"download",name:te,file:ee});const F={status:"progress",name:te,file:ee};let se;return B.progress_callback?ie&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(se=new Uint8Array(await Ae.arrayBuffer()),(0,fe.dispatchCallback)(B.progress_callback,{...F,progress:100,loaded:se.length,total:se.length})):se=await ue(Ae,_e=>{(0,fe.dispatchCallback)(B.progress_callback,{...F,..._e})}):se=new Uint8Array(await Ae.arrayBuffer()),Pe&&Ue&&await H.match(Ue)===void 0&&await H.put(Ue,new Response(se,{headers:Ae.headers})).catch(_e=>{console.warn(`Unable to add response to browser cache: ${_e}.`)}),(0,fe.dispatchCallback)(B.progress_callback,{status:"done",name:te,file:ee}),se}async function U(te,ee,q=!0,B={}){let H=await Te(te,ee,q,B);if(H===null)return{};let Me=new TextDecoder("utf-8").decode(H);return JSON.parse(Me)}async function ue(te,ee){const q=te.headers.get("Content-Length");q===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let B=parseInt(q??"0"),H=new Uint8Array(B),I=0;const Me=te.body.getReader();async function xe(){const{done:Ce,value:Ve}=await Me.read();if(Ce)return;let Ue=I+Ve.length;if(Ue>B){B=Ue;let Pe=new Uint8Array(B);Pe.set(H),H=Pe}H.set(Ve,I),I=Ue;const Ne=I/B*100;return ee({progress:Ne,loaded:I,total:B}),xe()}return await xe(),H}function ke(...te){return te=te.map((ee,q)=>(q&&(ee=ee.replace(new RegExp("^/"),"")),q!==te.length-1&&(ee=ee.replace(new RegExp("/$"),"")),ee)),te.join("/")}},"./src/utils/image.js":(oe,R,T)=>{T.r(R),T.d(R,{RawImage:()=>$e});var E=T("./src/utils/hub.js"),Z=T("./src/env.js"),re=T("./src/utils/tensor.js"),fe=T("?2b25");const Ee=typeof self<"u",j=Ee&&self.constructor.name==="DedicatedWorkerGlobalScope";let O,M,N;if(Ee)O=(Te,U)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(Te,U)},N=self.createImageBitmap,M=self.ImageData;else if(fe)N=async Te=>{const ue=(await Te.metadata()).channels,{data:ke,info:te}=await Te.rotate().raw().toBuffer({resolveWithObject:!0}),ee=new $e(new Uint8ClampedArray(ke),te.width,te.height,te.channels);return ue!==void 0&&ue!==te.channels&&ee.convert(ue),ee};else throw new Error("Unable to load image processing library.");const K={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},ae=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class $e{constructor(U,ue,ke,te){this.data=U,this.width=ue,this.height=ke,this.channels=te}get size(){return[this.width,this.height]}static async read(U){if(U instanceof $e)return U;if(typeof U=="string"||U instanceof URL)return await this.fromURL(U);throw new Error(`Unsupported input type: ${typeof U}`)}static fromCanvas(U){if(!Ee)throw new Error("fromCanvas() is only supported in browser environments.");const ke=U.getContext("2d").getImageData(0,0,U.width,U.height).data;return new $e(ke,U.width,U.height,4)}static async fromURL(U){const ue=await(0,E.getFile)(U);if(ue.status!==200)throw new Error(`Unable to read image from "${U}" (${ue.status} ${ue.statusText})`);const ke=await ue.blob();return this.fromBlob(ke)}static async fromBlob(U){if(Ee){const ue=await N(U),ke=O(ue.width,ue.height).getContext("2d");return ke.drawImage(ue,0,0),new this(ke.getImageData(0,0,ue.width,ue.height).data,ue.width,ue.height,4)}else{const ue=fe(await U.arrayBuffer());return await N(ue)}}static fromTensor(U,ue="CHW"){if(U.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${U.dims.length} dimensions.`);if(ue==="CHW")U=U.transpose(1,2,0);else if(ue!=="HWC")throw new Error(`Unsupported channel format: ${ue}`);if(!(U.data instanceof Uint8ClampedArray||U.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${U.type}`);switch(U.dims[2]){case 1:case 2:case 3:case 4:return new $e(U.data,U.dims[1],U.dims[0],U.dims[2]);default:throw new Error(`Unsupported number of channels: ${U.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const U=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let ue=0,ke=0;ue<this.data.length;ue+=this.channels){const te=this.data[ue],ee=this.data[ue+1],q=this.data[ue+2];U[ke++]=Math.round(.2989*te+.587*ee+.114*q)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(U,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const U=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let ue=0,ke=0;ue<this.data.length;++ue)U[ke++]=this.data[ue],U[ke++]=this.data[ue],U[ke++]=this.data[ue];break;case 4:for(let ue=0,ke=0;ue<this.data.length;ue+=4)U[ke++]=this.data[ue],U[ke++]=this.data[ue+1],U[ke++]=this.data[ue+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(U,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const U=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let ue=0,ke=0;ue<this.data.length;++ue)U[ke++]=this.data[ue],U[ke++]=this.data[ue],U[ke++]=this.data[ue],U[ke++]=255;break;case 3:for(let ue=0,ke=0;ue<this.data.length;ue+=3)U[ke++]=this.data[ue],U[ke++]=this.data[ue+1],U[ke++]=this.data[ue+2],U[ke++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(U,this.width,this.height,4)}async resize(U,ue,{resample:ke=2}={}){let te=K[ke]??ke;if(Ee){const ee=this.channels,q=this.toCanvas(),B=O(U,ue).getContext("2d");return B.drawImage(q,0,0,U,ue),new $e(B.getImageData(0,0,U,ue).data,U,ue,4).convert(ee)}else{let ee=this.toSharp();switch(te){case"box":case"hamming":(te==="box"||te==="hamming")&&(console.warn(`Resampling method ${te} is not yet supported. Using bilinear instead.`),te="bilinear");case"nearest":case"bilinear":case"bicubic":ee=ee.affine([U/this.width,0,0,ue/this.height],{interpolator:te});break;case"lanczos":ee=ee.resize({width:U,height:ue,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${te} is not supported.`)}return await N(ee)}}async pad([U,ue,ke,te]){if(U=Math.max(U,0),ue=Math.max(ue,0),ke=Math.max(ke,0),te=Math.max(te,0),U===0&&ue===0&&ke===0&&te===0)return this;if(Ee){const ee=this.channels,q=this.toCanvas(),B=this.width+U+ue,H=this.height+ke+te,I=O(B,H).getContext("2d");return I.drawImage(q,0,0,this.width,this.height,U,ke,B,H),new $e(I.getImageData(0,0,B,H).data,B,H,4).convert(ee)}else{const ee=this.toSharp().extend({left:U,right:ue,top:ke,bottom:te});return await N(ee)}}async crop([U,ue,ke,te]){if(U=Math.max(U,0),ue=Math.max(ue,0),ke=Math.min(ke,this.width-1),te=Math.min(te,this.height-1),U===0&&ue===0&&ke===this.width-1&&te===this.height-1)return this;const ee=ke-U+1,q=te-ue+1;if(Ee){const B=this.channels,H=this.toCanvas(),I=O(ee,q).getContext("2d");return I.drawImage(H,U,ue,ee,q,0,0,ee,q),new $e(I.getImageData(0,0,ee,q).data,ee,q,4).convert(B)}else{const B=this.toSharp().extract({left:U,top:ue,width:ee,height:q});return await N(B)}}async center_crop(U,ue){if(this.width===U&&this.height===ue)return this;const ke=(this.width-U)/2,te=(this.height-ue)/2;if(Ee){const ee=this.channels,q=this.toCanvas(),B=O(U,ue).getContext("2d");let H=0,I=0,Me=0,xe=0;return ke>=0?H=ke:Me=-ke,te>=0?I=te:xe=-te,B.drawImage(q,H,I,U,ue,Me,xe,U,ue),new $e(B.getImageData(0,0,U,ue).data,U,ue,4).convert(ee)}else{let ee=this.toSharp();if(ke>=0&&te>=0)ee=ee.extract({left:Math.floor(ke),top:Math.floor(te),width:U,height:ue});else if(ke<=0&&te<=0){const q=Math.floor(-te),B=Math.floor(-ke);ee=ee.extend({top:q,left:B,right:U-this.width-B,bottom:ue-this.height-q})}else{let q=[0,0],B=0;te<0?(q[0]=Math.floor(-te),q[1]=ue-this.height-q[0]):B=Math.floor(te);let H=[0,0],I=0;ke<0?(H[0]=Math.floor(-ke),H[1]=U-this.width-H[0]):I=Math.floor(ke),ee=ee.extend({top:q[0],bottom:q[1],left:H[0],right:H[1]}).extract({left:I,top:B,width:U,height:ue})}return await N(ee)}}async toBlob(U="image/png",ue=1){if(!Ee)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:U,quality:ue})}toTensor(U="CHW"){let ue=new re.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(U!=="HWC")if(U==="CHW")ue=ue.permute(2,0,1);else throw new Error(`Unsupported channel format: ${U}`);return ue}toCanvas(){if(!Ee)throw new Error("toCanvas() is only supported in browser environments.");const U=this.clone().rgba(),ue=O(U.width,U.height),ke=new M(U.data,U.width,U.height);return ue.getContext("2d").putImageData(ke,0,0),ue}_update(U,ue,ke,te=null){return this.data=U,this.width=ue,this.height=ke,te!==null&&(this.channels=te),this}clone(){return new $e(this.data.slice(),this.width,this.height,this.channels)}convert(U){if(this.channels===U)return this;switch(U){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(U){if(Ee){if(j)throw new Error("Unable to save an image from a Web Worker.");const ue=U.split(".").pop().toLowerCase(),ke=ae.get(ue)??"image/png",te=await this.toBlob(ke),ee=URL.createObjectURL(te),q=document.createElement("a");q.href=ee,q.download=U,q.click(),q.remove()}else{if(Z.env.useFS)return await this.toSharp().toFile(U);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(Ee)throw new Error("toSharp() is only supported in server-side environments.");return fe(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}},"./src/utils/maths.js":(oe,R,T)=>{T.r(R),T.d(R,{FFT:()=>Te,bankers_round:()=>ke,cos_sim:()=>j,dot:()=>Ee,dynamic_time_warping:()=>te,interpolate_data:()=>E,log_softmax:()=>fe,magnitude:()=>O,max:()=>N,medianFilter:()=>U,min:()=>M,permute_data:()=>Z,round:()=>ue,softmax:()=>re});function E(ee,[q,B,H],[I,Me],xe="bilinear",Ce=!1){const Ve=Me/H,Ue=I/B,Ne=new ee.constructor(I*Me*q),Pe=B*H,Ae=I*Me;for(let ie=0;ie<I;++ie)for(let F=0;F<Me;++F){const se=ie*Me+F,_e=(F+.5)/Ve-.5,Oe=(ie+.5)/Ue-.5;let nt=Math.floor(_e),de=Math.floor(Oe);const Re=Math.min(nt+1,H-1),it=Math.min(de+1,B-1);nt=Math.max(nt,0),de=Math.max(de,0);const He=_e-nt,wt=Oe-de,xt=(1-He)*(1-wt),et=He*(1-wt),X=(1-He)*wt,Be=He*wt,st=de*H,lt=it*H,rt=st+nt,Qe=st+Re,_t=lt+nt,yt=lt+Re;for(let Lt=0;Lt<q;++Lt){const kt=Lt*Pe;Ne[Lt*Ae+se]=xt*ee[kt+rt]+et*ee[kt+Qe]+X*ee[kt+_t]+Be*ee[kt+yt]}}return Ne}function Z(ee,q,B){const H=new Array(B.length),I=new Array(B.length);for(let Ce=B.length-1,Ve=1;Ce>=0;--Ce)I[Ce]=Ve,H[Ce]=q[B[Ce]],Ve*=H[Ce];const Me=B.map((Ce,Ve)=>I[B.indexOf(Ve)]),xe=new ee.constructor(ee.length);for(let Ce=0;Ce<ee.length;++Ce){let Ve=0;for(let Ue=q.length-1,Ne=Ce;Ue>=0;--Ue)Ve+=Ne%q[Ue]*Me[Ue],Ne=Math.floor(Ne/q[Ue]);xe[Ve]=ee[Ce]}return[xe,H]}function re(ee){const q=N(ee)[0],B=ee.map(Me=>Math.exp(Me-q)),H=B.reduce((Me,xe)=>Me+xe,0);return B.map(Me=>Me/H)}function fe(ee){const q=N(ee)[0];let B=0;for(let Me=0;Me<ee.length;++Me)B+=Math.exp(ee[Me]-q);const H=Math.log(B);return ee.map(Me=>Me-q-H)}function Ee(ee,q){let B=0;for(let H=0;H<ee.length;++H)B+=ee[H]*q[H];return B}function j(ee,q){const B=Ee(ee,q),H=O(ee),I=O(q);return B/(H*I)}function O(ee){return Math.sqrt(ee.reduce((q,B)=>q+B*B,0))}function M(ee){if(ee.length===0)throw Error("Array must not be empty");let q=ee[0],B=0;for(let H=1;H<ee.length;++H)ee[H]<q&&(q=ee[H],B=H);return[q,B]}function N(ee){if(ee.length===0)throw Error("Array must not be empty");let q=ee[0],B=0;for(let H=1;H<ee.length;++H)ee[H]>q&&(q=ee[H],B=H);return[Number(q),B]}function K(ee){return ee>0&&(ee&ee-1)===0}class ae{constructor(q){if(this.size=q|0,this.size<=1||!K(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=q<<1,this.table=new Float64Array(this.size*2);for(let H=0;H<this.table.length;H+=2){const I=Math.PI*H/this.size;this.table[H]=Math.cos(I),this.table[H+1]=-Math.sin(I)}let B=0;for(let H=1;this.size>H;H<<=1)++B;this._width=B%2===0?B-1:B,this._bitrev=new Int32Array(1<<this._width);for(let H=0;H<this._bitrev.length;++H){this._bitrev[H]=0;for(let I=0;I<this._width;I+=2){const Me=this._width-I-2;this._bitrev[H]|=(H>>>I&3)<<Me}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(q,B){const H=B||new Array(q.length>>>1);for(let I=0;I<q.length;I+=2)H[I>>>1]=q[I];return H}toComplexArray(q,B){const H=B||this.createComplexArray();for(let I=0;I<H.length;I+=2)H[I]=q[I>>>1],H[I+1]=0;return H}transform(q,B){if(q===B)throw new Error("Input and output buffers must be different");this._transform4(q,B,1)}realTransform(q,B){if(q===B)throw new Error("Input and output buffers must be different");this._realTransform4(q,B,1)}inverseTransform(q,B){if(q===B)throw new Error("Input and output buffers must be different");this._transform4(q,B,-1);for(let H=0;H<q.length;++H)q[H]/=this.size}_transform4(q,B,H){const I=this._csize;let xe=1<<this._width,Ce=I/xe<<1,Ve,Ue;const Ne=this._bitrev;if(Ce===4)for(Ve=0,Ue=0;Ve<I;Ve+=Ce,++Ue){const Ae=Ne[Ue];this._singleTransform2(B,q,Ve,Ae,xe)}else for(Ve=0,Ue=0;Ve<I;Ve+=Ce,++Ue){const Ae=Ne[Ue];this._singleTransform4(B,q,Ve,Ae,xe,H)}const Pe=this.table;for(xe>>=2;xe>=2;xe>>=2){Ce=I/xe<<1;const Ae=Ce>>>2;for(Ve=0;Ve<I;Ve+=Ce){const ie=Ve+Ae-1;for(let F=Ve,se=0;F<ie;F+=2,se+=xe){const _e=F,Oe=_e+Ae,nt=Oe+Ae,de=nt+Ae,Re=q[_e],it=q[_e+1],He=q[Oe],wt=q[Oe+1],xt=q[nt],et=q[nt+1],X=q[de],Be=q[de+1],st=Pe[se],lt=H*Pe[se+1],rt=He*st-wt*lt,Qe=He*lt+wt*st,_t=Pe[2*se],yt=H*Pe[2*se+1],Lt=xt*_t-et*yt,kt=xt*yt+et*_t,$=Pe[3*se],J=H*Pe[3*se+1],z=X*$-Be*J,pe=X*J+Be*$,Se=Re+Lt,dt=it+kt,at=Re-Lt,At=it-kt,pt=rt+z,bt=Qe+pe,C=H*(rt-z),c=H*(Qe-pe);q[_e]=Se+pt,q[_e+1]=dt+bt,q[Oe]=at+c,q[Oe+1]=At-C,q[nt]=Se-pt,q[nt+1]=dt-bt,q[de]=at-c,q[de+1]=At+C}}}}_singleTransform2(q,B,H,I,Me){const xe=q[I],Ce=q[I+1],Ve=q[I+Me],Ue=q[I+Me+1];B[H]=xe+Ve,B[H+1]=Ce+Ue,B[H+2]=xe-Ve,B[H+3]=Ce-Ue}_singleTransform4(q,B,H,I,Me,xe){const Ce=Me*2,Ve=Me*3,Ue=q[I],Ne=q[I+1],Pe=q[I+Me],Ae=q[I+Me+1],ie=q[I+Ce],F=q[I+Ce+1],se=q[I+Ve],_e=q[I+Ve+1],Oe=Ue+ie,nt=Ne+F,de=Ue-ie,Re=Ne-F,it=Pe+se,He=Ae+_e,wt=xe*(Pe-se),xt=xe*(Ae-_e);B[H]=Oe+it,B[H+1]=nt+He,B[H+2]=de+xt,B[H+3]=Re-wt,B[H+4]=Oe-it,B[H+5]=nt-He,B[H+6]=de-xt,B[H+7]=Re+wt}_realTransform4(q,B,H){const I=this._csize;let xe=1<<this._width,Ce=I/xe<<1,Ve,Ue;const Ne=this._bitrev;if(Ce===4)for(Ve=0,Ue=0;Ve<I;Ve+=Ce,++Ue){const ie=Ne[Ue];this._singleRealTransform2(B,q,Ve,ie>>>1,xe>>>1)}else for(Ve=0,Ue=0;Ve<I;Ve+=Ce,++Ue){const ie=Ne[Ue];this._singleRealTransform4(B,q,Ve,ie>>>1,xe>>>1,H)}const Pe=this.table;for(xe>>=2;xe>=2;xe>>=2){Ce=I/xe<<1;const ie=Ce>>>1,F=ie>>>1,se=F>>>1;for(Ve=0;Ve<I;Ve+=Ce)for(let _e=0,Oe=0;_e<=se;_e+=2,Oe+=xe){const nt=Ve+_e,de=nt+F,Re=de+F,it=Re+F,He=q[nt],wt=q[nt+1],xt=q[de],et=q[de+1],X=q[Re],Be=q[Re+1],st=q[it],lt=q[it+1],rt=He,Qe=wt,_t=Pe[Oe],yt=H*Pe[Oe+1],Lt=xt*_t-et*yt,kt=xt*yt+et*_t,$=Pe[2*Oe],J=H*Pe[2*Oe+1],z=X*$-Be*J,pe=X*J+Be*$,Se=Pe[3*Oe],dt=H*Pe[3*Oe+1],at=st*Se-lt*dt,At=st*dt+lt*Se,pt=rt+z,bt=Qe+pe,C=rt-z,c=Qe-pe,m=Lt+at,W=kt+At,we=H*(Lt-at),Fe=H*(kt-At);if(q[nt]=pt+m,q[nt+1]=bt+W,q[de]=C+Fe,q[de+1]=c-we,_e===0){q[Re]=pt-m,q[Re+1]=bt-W;continue}if(_e===se)continue;const Xe=Ve+F-_e,sr=Ve+ie-_e;q[Xe]=C-H*Fe,q[Xe+1]=-c-H*we,q[sr]=pt-H*m,q[sr+1]=-bt+H*W}}const Ae=I>>>1;for(let ie=2;ie<Ae;ie+=2)q[I-ie]=q[ie],q[I-ie+1]=-q[ie+1]}_singleRealTransform2(q,B,H,I,Me){const xe=q[I],Ce=q[I+Me];B[H]=xe+Ce,B[H+1]=0,B[H+2]=xe-Ce,B[H+3]=0}_singleRealTransform4(q,B,H,I,Me,xe){const Ce=Me*2,Ve=Me*3,Ue=q[I],Ne=q[I+Me],Pe=q[I+Ce],Ae=q[I+Ve],ie=Ue+Pe,F=Ue-Pe,se=Ne+Ae,_e=xe*(Ne-Ae);B[H]=ie+se,B[H+1]=0,B[H+2]=F,B[H+3]=-_e,B[H+4]=ie-se,B[H+5]=0,B[H+6]=F,B[H+7]=_e}}class $e{constructor(q){const B=2*(q-1),H=2*(2*q-1),I=2**Math.ceil(Math.log2(H));this.bufferSize=I,this._a=B;const Me=new Float64Array(H),xe=new Float64Array(I);this._chirpBuffer=new Float64Array(I),this._buffer1=new Float64Array(I),this._buffer2=new Float64Array(I),this._outBuffer1=new Float64Array(I),this._outBuffer2=new Float64Array(I);const Ce=-2*Math.PI/q,Ve=Math.cos(Ce),Ue=Math.sin(Ce);for(let Ne=0;Ne<H>>1;++Ne){const Pe=(Ne+1-q)**2/2,Ae=Math.sqrt(Ve**2+Ue**2)**Pe,ie=Pe*Math.atan2(Ue,Ve),F=2*Ne;Me[F]=Ae*Math.cos(ie),Me[F+1]=Ae*Math.sin(ie),xe[F]=Me[F],xe[F+1]=-Me[F+1]}this._slicedChirpBuffer=Me.subarray(B,H),this._f=new ae(I>>1),this._f.transform(this._chirpBuffer,xe)}_transform(q,B,H){const I=this._buffer1,Me=this._buffer2,xe=this._outBuffer1,Ce=this._outBuffer2,Ve=this._chirpBuffer,Ue=this._slicedChirpBuffer,Ne=this._a;if(H)for(let Pe=0;Pe<Ue.length;Pe+=2){const Ae=Pe+1,ie=Pe>>1,F=B[ie];I[Pe]=F*Ue[Pe],I[Ae]=F*Ue[Ae]}else for(let Pe=0;Pe<Ue.length;Pe+=2){const Ae=Pe+1;I[Pe]=B[Pe]*Ue[Pe]-B[Ae]*Ue[Ae],I[Ae]=B[Pe]*Ue[Ae]+B[Ae]*Ue[Pe]}this._f.transform(xe,I);for(let Pe=0;Pe<Ve.length;Pe+=2){const Ae=Pe+1;Me[Pe]=xe[Pe]*Ve[Pe]-xe[Ae]*Ve[Ae],Me[Ae]=xe[Pe]*Ve[Ae]+xe[Ae]*Ve[Pe]}this._f.inverseTransform(Ce,Me);for(let Pe=0;Pe<Ce.length;Pe+=2){const Ae=Ce[Pe+Ne],ie=Ce[Pe+Ne+1],F=Ue[Pe],se=Ue[Pe+1];q[Pe]=Ae*F-ie*se,q[Pe+1]=Ae*se+ie*F}}transform(q,B){this._transform(q,B,!1)}realTransform(q,B){this._transform(q,B,!0)}}class Te{constructor(q){this.fft_length=q,this.isPowerOfTwo=K(q),this.isPowerOfTwo?(this.fft=new ae(q),this.outputBufferSize=2*q):(this.fft=new $e(q),this.outputBufferSize=this.fft.bufferSize)}realTransform(q,B){this.fft.realTransform(q,B)}transform(q,B){this.fft.transform(q,B)}}function U(ee,q){if(q%2===0||q<=0)throw new Error("Window size must be a positive odd number");const B=new ee.constructor(ee.length),H=new ee.constructor(q),I=Math.floor(q/2);for(let Me=0;Me<ee.length;++Me){let xe=0;for(let Ce=-I;Ce<=I;++Ce){let Ve=Me+Ce;Ve<0?Ve=Math.abs(Ve):Ve>=ee.length&&(Ve=2*(ee.length-1)-Ve),H[xe++]=ee[Ve]}H.sort(),B[Me]=H[I]}return B}function ue(ee,q){const B=Math.pow(10,q);return Math.round(ee*B)/B}function ke(ee){const q=Math.round(ee);return Math.abs(ee)%1===.5?q%2===0?q:q-1:q}function te(ee){const q=ee.length,B=ee[0].length,H=[q+1,B+1],I=Array.from({length:H[0]},()=>Array(H[1]).fill(1/0));I[0][0]=0;const Me=Array.from({length:H[0]},()=>Array(H[1]).fill(-1));for(let Ne=1;Ne<H[1];++Ne)for(let Pe=1;Pe<H[0];++Pe){const Ae=I[Pe-1][Ne-1],ie=I[Pe-1][Ne],F=I[Pe][Ne-1];let se,_e;Ae<ie&&Ae<F?(se=Ae,_e=0):ie<Ae&&ie<F?(se=ie,_e=1):(se=F,_e=2),I[Pe][Ne]=ee[Pe-1][Ne-1]+se,Me[Pe][Ne]=_e}for(let Ne=0;Ne<H[1];++Ne)Me[0][Ne]=2;for(let Ne=0;Ne<H[0];++Ne)Me[Ne][0]=1;let xe=q,Ce=B,Ve=[],Ue=[];for(;xe>0||Ce>0;)switch(Ve.push(xe-1),Ue.push(Ce-1),Me[xe][Ce]){case 0:--xe,--Ce;break;case 1:--xe;break;case 2:--Ce;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${xe}, ${Ce}]. Please file a bug report.`)}return Ve.reverse(),Ue.reverse(),[Ve,Ue]}},"./src/utils/tensor.js":(oe,R,T)=>{T.r(R),T.d(R,{Tensor:()=>Ee,cat:()=>ee,full:()=>xe,full_like:()=>Ce,interpolate:()=>M,interpolate_4d:()=>N,layer_norm:()=>U,matmul:()=>K,mean:()=>H,mean_pooling:()=>Te,ones:()=>Ve,ones_like:()=>Ue,permute:()=>O,quantize_embeddings:()=>Ae,rfft:()=>ae,stack:()=>q,std_mean:()=>B,topk:()=>$e,zeros:()=>Ne,zeros_like:()=>Pe});var E=T("./src/utils/maths.js"),Z=T("./src/backends/onnx.js"),re=T("./src/ops/registry.js");const fe=Object.freeze({float32:Float32Array,float16:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array});class Ee{get dims(){return this.ort_tensor.dims}set dims(F){this.ort_tensor.dims=F}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...F){return(0,Z.isONNXTensor)(F[0])?this.ort_tensor=F[0]:this.ort_tensor=new Z.Tensor(F[0],F[1],F[2]),new Proxy(this,{get:(se,_e)=>{if(typeof _e=="string"){let Oe=Number(_e);if(Number.isInteger(Oe))return se._getitem(Oe)}return se[_e]},set:(se,_e,Oe)=>se[_e]=Oe})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[F,...se]=this.dims;if(se.length>0){const _e=se.reduce((Oe,nt)=>Oe*nt);for(let Oe=0;Oe<F;++Oe)yield this._subarray(Oe,_e,se)}else yield*this.data}_getitem(F){const[se,..._e]=this.dims;if(F=te(F,se),_e.length>0){const Oe=_e.reduce((nt,de)=>nt*de);return this._subarray(F,Oe,_e)}else return new Ee(this.type,[this.data[F]],_e)}indexOf(F){const se=this.data;for(let _e=0;_e<se.length;++_e)if(se[_e]==F)return _e;return-1}_subarray(F,se,_e){const Oe=F*se,nt=(F+1)*se,de="subarray"in this.data?this.data.subarray(Oe,nt):this.data.slice(Oe,nt);return new Ee(this.type,de,_e)}item(){const F=this.data;if(F.length!==1)throw new Error(`a Tensor with ${F.length} elements cannot be converted to Scalar`);return F[0]}tolist(){return j(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const F=this.data;for(let se=0;se<F.length;++se)F[se]=1/(1+Math.exp(-F[se]));return this}map(F){return this.clone().map_(F)}map_(F){const se=this.data;for(let _e=0;_e<se.length;++_e)se[_e]=F(se[_e],_e,se);return this}mul(F){return this.clone().mul_(F)}mul_(F){const se=this.data;for(let _e=0;_e<se.length;++_e)se[_e]*=F;return this}div(F){return this.clone().div_(F)}div_(F){const se=this.data;for(let _e=0;_e<se.length;++_e)se[_e]/=F;return this}add(F){return this.clone().add_(F)}add_(F){const se=this.data;for(let _e=0;_e<se.length;++_e)se[_e]+=F;return this}sub(F){return this.clone().sub_(F)}sub_(F){const se=this.data;for(let _e=0;_e<se.length;++_e)se[_e]-=F;return this}clone(){return new Ee(this.type,this.data.slice(),this.dims.slice())}slice(...F){const se=[],_e=[];for(let He=0;He<this.dims.length;++He){let wt=F[He];if(wt==null)_e.push([0,this.dims[He]]),se.push(this.dims[He]);else if(typeof wt=="number")wt=te(wt,this.dims[He],He),_e.push([wt,wt+1]);else if(Array.isArray(wt)&&wt.length===2){let[xt,et]=wt;if(xt=xt===null?0:te(xt,this.dims[He],He,!1),et=et===null?this.dims[He]:te(et,this.dims[He],He,!1),xt>et)throw new Error(`Invalid slice: ${wt}`);const X=[Math.max(xt,0),Math.min(et,this.dims[He])];_e.push(X),se.push(X[1]-X[0])}else throw new Error(`Invalid slice: ${wt}`)}const Oe=_e.map(([He,wt])=>wt-He),nt=Oe.reduce((He,wt)=>He*wt),de=this.data,Re=new de.constructor(nt),it=this.stride();for(let He=0;He<nt;++He){let wt=0;for(let xt=Oe.length-1,et=He;xt>=0;--xt){const X=Oe[xt];wt+=(et%X+_e[xt][0])*it[xt],et=Math.floor(et/X)}Re[He]=de[wt]}return new Ee(this.type,Re,se)}permute(...F){return O(this,F)}transpose(...F){return this.permute(...F)}sum(F=null,se=!1){return this.norm(1,F,se)}norm(F="fro",se=null,_e=!1){if(F==="fro")F=2;else if(typeof F=="string")throw Error(`Unsupported norm: ${F}`);const Oe=this.data;if(se===null){let Re=Oe.reduce((it,He)=>it+He**F,0)**(1/F);return new Ee(this.type,[Re],[])}se=te(se,this.dims.length);const nt=this.dims.slice();nt[se]=1;const de=new Oe.constructor(Oe.length/this.dims[se]);for(let Re=0;Re<Oe.length;++Re){let it=0;for(let He=this.dims.length-1,wt=Re,xt=1;He>=0;--He){const et=this.dims[He];if(He!==se){const X=wt%et;it+=X*xt,xt*=nt[He]}wt=Math.floor(wt/et)}de[it]+=Oe[Re]**F}if(F!==1)for(let Re=0;Re<de.length;++Re)de[Re]=de[Re]**(1/F);return _e||nt.splice(se,1),new Ee(this.type,de,nt)}normalize_(F=2,se=1){se=te(se,this.dims.length);const _e=this.norm(F,se,!0),Oe=this.data,nt=_e.data;for(let de=0;de<Oe.length;++de){let Re=0;for(let it=this.dims.length-1,He=de,wt=1;it>=0;--it){const xt=this.dims[it];if(it!==se){const et=He%xt;Re+=et*wt,wt*=this.dims[it]}He=Math.floor(He/xt)}Oe[de]/=nt[Re]}return this}normalize(F=2,se=1){return this.clone().normalize_(F,se)}stride(){return I(this.dims)}squeeze(F=null){return new Ee(this.type,this.data,ue(this.dims,F))}squeeze_(F=null){return this.dims=ue(this.dims,F),this}unsqueeze(F=null){return new Ee(this.type,this.data,ke(this.dims,F))}unsqueeze_(F=null){return this.dims=ke(this.dims,F),this}flatten_(F=0,se=-1){se=(se+this.dims.length)%this.dims.length;let _e=this.dims.slice(0,F),Oe=this.dims.slice(F,se+1),nt=this.dims.slice(se+1);return this.dims=[..._e,Oe.reduce((de,Re)=>de*Re,1),...nt],this}flatten(F=0,se=-1){return this.clone().flatten_(F,se)}view(...F){let se=-1;for(let Oe=0;Oe<F.length;++Oe)if(F[Oe]===-1){if(se!==-1)throw new Error("Only one dimension can be inferred");se=Oe}const _e=this.data;if(se!==-1){const Oe=F.reduce((nt,de,Re)=>Re!==se?nt*de:nt,1);F[se]=_e.length/Oe}return new Ee(this.type,_e,F)}neg_(){const F=this.data;for(let se=0;se<F.length;++se)F[se]=-F[se];return this}neg(){return this.clone().neg_()}clamp_(F,se){const _e=this.data;for(let Oe=0;Oe<_e.length;++Oe)_e[Oe]=Math.min(Math.max(_e[Oe],F),se);return this}clamp(F,se){return this.clone().clamp_(F,se)}round_(){const F=this.data;for(let se=0;se<F.length;++se)F[se]=Math.round(F[se]);return this}round(){return this.clone().round_()}mean(F=null,se=!1){return H(this,F,se)}to(F){if(this.type===F)return this;if(!fe.hasOwnProperty(F))throw new Error(`Unsupported type: ${F}`);return new Ee(F,fe[F].from(this.data),this.dims)}}function j(ie,F){const se=ie.length,_e=F.reduce((nt,de)=>nt*de);if(se!==_e)throw Error(`cannot reshape array of size ${se} into shape (${F})`);let Oe=ie;for(let nt=F.length-1;nt>=0;nt--)Oe=Oe.reduce((de,Re)=>{let it=de[de.length-1];return it.length<F[nt]?it.push(Re):de.push([Re]),de},[[]]);return Oe[0]}function O(ie,F){const[se,_e]=(0,E.permute_data)(ie.data,ie.dims,F);return new Ee(ie.type,se,_e)}function M(ie,[F,se],_e="bilinear",Oe=!1){const nt=ie.dims.at(-3)??1,de=ie.dims.at(-2),Re=ie.dims.at(-1);let it=(0,E.interpolate_data)(ie.data,[nt,de,Re],[F,se],_e,Oe);return new Ee(ie.type,it,[nt,F,se])}async function N(ie,{size:F=null,mode:se="bilinear"}={}){if(ie.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!F)throw new Error("`interpolate_4d` requires a `size` argument.");let _e;if(F.length===2)_e=[...ie.dims.slice(0,2),...F];else if(F.length===3)_e=[ie.dims[0],...F];else if(F.length===4)_e=F;else throw new Error("`size` must be of length 2, 3, or 4.");let Oe;if(se==="bilinear")Oe=await re.TensorOpRegistry.bilinear_interpolate_4d;else if(se==="bicubic")Oe=await re.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${se}`);const nt=new Ee("int64",new BigInt64Array(_e.map(BigInt)),[_e.length]);return await Oe({x:ie,s:nt})}async function K(ie,F){return await(await re.TensorOpRegistry.matmul)({a:ie,b:F})}async function ae(ie,F){return await(await re.TensorOpRegistry.rfft)({x:ie,a:F})}async function $e(ie,F){const se=await re.TensorOpRegistry.top_k;return F===null?F=ie.dims.at(-1):F=Math.min(F,ie.dims.at(-1)),await se({x:ie,k:new Ee("int64",[BigInt(F)],[1])})}function Te(ie,F){const se=ie.data,_e=F.data,Oe=[ie.dims[0],ie.dims[2]],nt=new se.constructor(Oe[0]*Oe[1]),[de,Re,it]=ie.dims;let He=0;for(let wt=0;wt<de;++wt){const xt=wt*it*Re;for(let et=0;et<it;++et){let X=0,Be=0;const st=wt*Re,lt=xt+et;for(let Qe=0;Qe<Re;++Qe){const _t=Number(_e[st+Qe]);Be+=_t,X+=se[lt+Qe*it]*_t}const rt=X/Be;nt[He++]=rt}}return new Ee(ie.type,nt,Oe)}function U(ie,F,{eps:se=1e-5}={}){if(ie.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[_e,Oe]=ie.dims;if(F.length!==1&&F[0]!==Oe)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[nt,de]=B(ie,1,0,!0),Re=nt.data,it=de.data,He=ie.data,wt=new He.constructor(He.length);for(let xt=0;xt<_e;++xt){const et=xt*Oe;for(let X=0;X<Oe;++X){const Be=et+X;wt[Be]=(He[Be]-it[xt])/(Re[xt]+se)}}return new Ee(ie.type,wt,ie.dims)}function ue(ie,F){return ie=ie.slice(),F===null?ie=ie.filter(se=>se!==1):typeof F=="number"?ie[F]===1&&ie.splice(F,1):Array.isArray(F)&&(ie=ie.filter((se,_e)=>se!==1||!F.includes(_e))),ie}function ke(ie,F){return F=te(F,ie.length+1),ie=ie.slice(),ie.splice(F,0,1),ie}function te(ie,F,se=null,_e=!0){if(_e&&(ie<-F||ie>=F))throw new Error(`IndexError: index ${ie} is out of bounds for dimension${se===null?"":" "+se} with size ${F}`);return ie<0&&(ie=(ie%F+F)%F),ie}function ee(ie,F=0){F=te(F,ie[0].dims.length);const se=ie[0].dims.slice();se[F]=ie.reduce((de,Re)=>de+Re.dims[F],0);const _e=se.reduce((de,Re)=>de*Re,1),Oe=new ie[0].data.constructor(_e),nt=ie[0].type;if(F===0){let de=0;for(const Re of ie){const it=Re.data;Oe.set(it,de),de+=it.length}}else{let de=0;for(let Re=0;Re<ie.length;++Re){const{data:it,dims:He}=ie[Re];for(let wt=0;wt<it.length;++wt){let xt=0;for(let et=He.length-1,X=wt,Be=1;et>=0;--et){const st=He[et];let lt=X%st;et===F&&(lt+=de),xt+=lt*Be,Be*=se[et],X=Math.floor(X/st)}Oe[xt]=it[wt]}de+=He[F]}}return new Ee(nt,Oe,se)}function q(ie,F=0){return ee(ie.map(se=>se.unsqueeze(F)),F)}function B(ie,F=null,se=1,_e=!1){const Oe=ie.data,nt=ie.dims;if(F===null){const et=Oe.reduce((lt,rt)=>lt+rt,0)/Oe.length,X=Math.sqrt(Oe.reduce((lt,rt)=>lt+(rt-et)**2,0)/(Oe.length-se)),Be=new Ee(ie.type,[et],[]);return[new Ee(ie.type,[X],[]),Be]}F=te(F,nt.length);const de=H(ie,F,_e),Re=de.data,it=nt.slice();it[F]=1;const He=new Oe.constructor(Oe.length/nt[F]);for(let xt=0;xt<Oe.length;++xt){let et=0;for(let X=nt.length-1,Be=xt,st=1;X>=0;--X){const lt=nt[X];if(X!==F){const rt=Be%lt;et+=rt*st,st*=it[X]}Be=Math.floor(Be/lt)}He[et]+=(Oe[xt]-Re[et])**2}for(let xt=0;xt<He.length;++xt)He[xt]=Math.sqrt(He[xt]/(nt[F]-se));return _e||it.splice(F,1),[new Ee(ie.type,He,it),de]}function H(ie,F=null,se=!1){const _e=ie.data;if(F===null){const Re=_e.reduce((it,He)=>it+He,0);return new Ee(ie.type,[Re/_e.length],[])}const Oe=ie.dims;F=te(F,Oe.length);const nt=Oe.slice();nt[F]=1;const de=new _e.constructor(_e.length/Oe[F]);for(let Re=0;Re<_e.length;++Re){let it=0;for(let He=Oe.length-1,wt=Re,xt=1;He>=0;--He){const et=Oe[He];if(He!==F){const X=wt%et;it+=X*xt,xt*=nt[He]}wt=Math.floor(wt/et)}de[it]+=_e[Re]}if(Oe[F]!==1)for(let Re=0;Re<de.length;++Re)de[Re]=de[Re]/Oe[F];return se||nt.splice(F,1),new Ee(ie.type,de,nt)}function I(ie){const F=new Array(ie.length);for(let se=ie.length-1,_e=1;se>=0;--se)F[se]=_e,_e*=ie[se];return F}function Me(ie,F,se,_e){const Oe=ie.reduce((nt,de)=>nt*de,1);return new Ee(se,new _e(Oe).fill(F),ie)}function xe(ie,F){let se,_e;if(typeof F=="number")se="float32",_e=Float32Array;else if(typeof F=="bigint")se="int64",_e=BigInt64Array;else throw new Error(`Unsupported data type: ${typeof F}`);return Me(ie,F,se,_e)}function Ce(ie,F){return xe(ie.dims,F)}function Ve(ie){return Me(ie,1n,"int64",BigInt64Array)}function Ue(ie){return Ve(ie.dims)}function Ne(ie){return Me(ie,0n,"int64",BigInt64Array)}function Pe(ie){return Ne(ie.dims)}function Ae(ie,F){if(ie.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(ie.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(F))throw new Error("The precision must be either 'binary' or 'ubinary'");const se=F==="binary",_e=se?"int8":"uint8",Oe=se?Int8Array:Uint8Array,nt=ie.data,de=new Oe(nt.length/8);for(let Re=0;Re<nt.length;++Re){const it=nt[Re]>0?1:0,He=Math.floor(Re/8),wt=Re%8;de[He]|=it<<7-wt,se&&wt===0&&(de[He]-=128)}return new Ee(_e,de,[ie.dims[0],ie.dims[1]/8])}}},lm={};function Kr(oe){var R=lm[oe];if(R!==void 0)return R.exports;var T=lm[oe]={exports:{}};return xm[oe](T,T.exports,Kr),T.exports}Kr.m=xm;(()=>{var oe=Object.getPrototypeOf?T=>Object.getPrototypeOf(T):T=>T.__proto__,R;Kr.t=function(T,E){if(E&1&&(T=this(T)),E&8||typeof T=="object"&&T&&(E&4&&T.__esModule||E&16&&typeof T.then=="function"))return T;var Z=Object.create(null);Kr.r(Z);var re={};R=R||[null,oe({}),oe([]),oe(oe)];for(var fe=E&2&&T;typeof fe=="object"&&!~R.indexOf(fe);fe=oe(fe))Object.getOwnPropertyNames(fe).forEach(Ee=>re[Ee]=()=>T[Ee]);return re.default=()=>T,Kr.d(Z,re),Z}})();Kr.d=(oe,R)=>{for(var T in R)Kr.o(R,T)&&!Kr.o(oe,T)&&Object.defineProperty(oe,T,{enumerable:!0,get:R[T]})};Kr.o=(oe,R)=>Object.prototype.hasOwnProperty.call(oe,R);Kr.r=oe=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(oe,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(oe,"__esModule",{value:!0})};(()=>{var oe;if(typeof import.meta.url=="string"&&(oe=import.meta.url),!oe)throw new Error("Automatic publicPath is not supported in this browser");oe=oe.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),Kr.p=oe})();Kr.b=new URL("./",import.meta.url);var p={};/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/Kr.r(p);Kr.d(p,{ASTFeatureExtractor:()=>ir.ASTFeatureExtractor,ASTForAudioClassification:()=>v.ASTForAudioClassification,ASTModel:()=>v.ASTModel,ASTPreTrainedModel:()=>v.ASTPreTrainedModel,AlbertForMaskedLM:()=>v.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>v.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>v.AlbertForSequenceClassification,AlbertModel:()=>v.AlbertModel,AlbertPreTrainedModel:()=>v.AlbertPreTrainedModel,AlbertTokenizer:()=>dr.AlbertTokenizer,AudioClassificationPipeline:()=>Hr.AudioClassificationPipeline,AutoConfig:()=>jp.AutoConfig,AutoModel:()=>v.AutoModel,AutoModelForAudioClassification:()=>v.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>v.AutoModelForAudioFrameClassification,AutoModelForCTC:()=>v.AutoModelForCTC,AutoModelForCausalLM:()=>v.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>v.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>v.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>v.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>v.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>v.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>v.AutoModelForImageSegmentation,AutoModelForImageToImage:()=>v.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>v.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>v.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>v.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>v.AutoModelForObjectDetection,AutoModelForQuestionAnswering:()=>v.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>v.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>v.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>v.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>v.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>v.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>v.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>v.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>v.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>v.AutoModelForVision2Seq,AutoModelForXVector:()=>v.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>v.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>ir.AutoProcessor,AutoTokenizer:()=>dr.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>Hr.AutomaticSpeechRecognitionPipeline,BartForConditionalGeneration:()=>v.BartForConditionalGeneration,BartForSequenceClassification:()=>v.BartForSequenceClassification,BartModel:()=>v.BartModel,BartPretrainedModel:()=>v.BartPretrainedModel,BartTokenizer:()=>dr.BartTokenizer,BaseModelOutput:()=>v.BaseModelOutput,BaseStreamer:()=>Up.BaseStreamer,BeitFeatureExtractor:()=>ir.BeitFeatureExtractor,BeitForImageClassification:()=>v.BeitForImageClassification,BeitModel:()=>v.BeitModel,BeitPreTrainedModel:()=>v.BeitPreTrainedModel,BertForMaskedLM:()=>v.BertForMaskedLM,BertForQuestionAnswering:()=>v.BertForQuestionAnswering,BertForSequenceClassification:()=>v.BertForSequenceClassification,BertForTokenClassification:()=>v.BertForTokenClassification,BertModel:()=>v.BertModel,BertPreTrainedModel:()=>v.BertPreTrainedModel,BertTokenizer:()=>dr.BertTokenizer,BitImageProcessor:()=>ir.BitImageProcessor,BlenderbotForConditionalGeneration:()=>v.BlenderbotForConditionalGeneration,BlenderbotModel:()=>v.BlenderbotModel,BlenderbotPreTrainedModel:()=>v.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>v.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>v.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>v.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>dr.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>dr.BlenderbotTokenizer,BloomForCausalLM:()=>v.BloomForCausalLM,BloomModel:()=>v.BloomModel,BloomPreTrainedModel:()=>v.BloomPreTrainedModel,BloomTokenizer:()=>dr.BloomTokenizer,CLIPFeatureExtractor:()=>ir.CLIPFeatureExtractor,CLIPImageProcessor:()=>ir.CLIPImageProcessor,CLIPModel:()=>v.CLIPModel,CLIPPreTrainedModel:()=>v.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>v.CLIPSegForImageSegmentation,CLIPSegModel:()=>v.CLIPSegModel,CLIPSegPreTrainedModel:()=>v.CLIPSegPreTrainedModel,CLIPTextModel:()=>v.CLIPTextModel,CLIPTextModelWithProjection:()=>v.CLIPTextModelWithProjection,CLIPTokenizer:()=>dr.CLIPTokenizer,CLIPVisionModel:()=>v.CLIPVisionModel,CLIPVisionModelWithProjection:()=>v.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>v.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>v.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>v.CamembertForSequenceClassification,CamembertForTokenClassification:()=>v.CamembertForTokenClassification,CamembertModel:()=>v.CamembertModel,CamembertPreTrainedModel:()=>v.CamembertPreTrainedModel,CamembertTokenizer:()=>dr.CamembertTokenizer,CausalLMOutput:()=>v.CausalLMOutput,CausalLMOutputWithPast:()=>v.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>ir.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>v.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>v.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>v.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>ir.ClapFeatureExtractor,ClapModel:()=>v.ClapModel,ClapPreTrainedModel:()=>v.ClapPreTrainedModel,ClapTextModelWithProjection:()=>v.ClapTextModelWithProjection,CodeGenForCausalLM:()=>v.CodeGenForCausalLM,CodeGenModel:()=>v.CodeGenModel,CodeGenPreTrainedModel:()=>v.CodeGenPreTrainedModel,CodeGenTokenizer:()=>dr.CodeGenTokenizer,CodeLlamaTokenizer:()=>dr.CodeLlamaTokenizer,CohereForCausalLM:()=>v.CohereForCausalLM,CohereModel:()=>v.CohereModel,CoherePreTrainedModel:()=>v.CoherePreTrainedModel,CohereTokenizer:()=>dr.CohereTokenizer,ConvBertForMaskedLM:()=>v.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>v.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>v.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>v.ConvBertForTokenClassification,ConvBertModel:()=>v.ConvBertModel,ConvBertPreTrainedModel:()=>v.ConvBertPreTrainedModel,ConvBertTokenizer:()=>dr.ConvBertTokenizer,ConvNextFeatureExtractor:()=>ir.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>v.ConvNextForImageClassification,ConvNextImageProcessor:()=>ir.ConvNextImageProcessor,ConvNextModel:()=>v.ConvNextModel,ConvNextPreTrainedModel:()=>v.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>v.ConvNextV2ForImageClassification,ConvNextV2Model:()=>v.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>v.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>ir.DPTFeatureExtractor,DPTForDepthEstimation:()=>v.DPTForDepthEstimation,DPTImageProcessor:()=>ir.DPTImageProcessor,DPTModel:()=>v.DPTModel,DPTPreTrainedModel:()=>v.DPTPreTrainedModel,DebertaForMaskedLM:()=>v.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>v.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>v.DebertaForSequenceClassification,DebertaForTokenClassification:()=>v.DebertaForTokenClassification,DebertaModel:()=>v.DebertaModel,DebertaPreTrainedModel:()=>v.DebertaPreTrainedModel,DebertaTokenizer:()=>dr.DebertaTokenizer,DebertaV2ForMaskedLM:()=>v.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>v.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>v.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>v.DebertaV2ForTokenClassification,DebertaV2Model:()=>v.DebertaV2Model,DebertaV2PreTrainedModel:()=>v.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>dr.DebertaV2Tokenizer,DecisionTransformerModel:()=>v.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>v.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>ir.DeiTFeatureExtractor,DeiTForImageClassification:()=>v.DeiTForImageClassification,DeiTModel:()=>v.DeiTModel,DeiTPreTrainedModel:()=>v.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>v.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>v.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>Hr.DepthEstimationPipeline,DepthProForDepthEstimation:()=>v.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>v.DepthProPreTrainedModel,DetrFeatureExtractor:()=>ir.DetrFeatureExtractor,DetrForObjectDetection:()=>v.DetrForObjectDetection,DetrForSegmentation:()=>v.DetrForSegmentation,DetrModel:()=>v.DetrModel,DetrObjectDetectionOutput:()=>v.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>v.DetrPreTrainedModel,DetrSegmentationOutput:()=>v.DetrSegmentationOutput,Dinov2ForImageClassification:()=>v.Dinov2ForImageClassification,Dinov2Model:()=>v.Dinov2Model,Dinov2PreTrainedModel:()=>v.Dinov2PreTrainedModel,DistilBertForMaskedLM:()=>v.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>v.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>v.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>v.DistilBertForTokenClassification,DistilBertModel:()=>v.DistilBertModel,DistilBertPreTrainedModel:()=>v.DistilBertPreTrainedModel,DistilBertTokenizer:()=>dr.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>Hr.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>ir.DonutFeatureExtractor,DonutImageProcessor:()=>ir.DonutImageProcessor,DonutSwinModel:()=>v.DonutSwinModel,DonutSwinPreTrainedModel:()=>v.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>v.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>ir.EfficientNetImageProcessor,EfficientNetModel:()=>v.EfficientNetModel,EfficientNetPreTrainedModel:()=>v.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>v.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>v.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>v.ElectraForSequenceClassification,ElectraForTokenClassification:()=>v.ElectraForTokenClassification,ElectraModel:()=>v.ElectraModel,ElectraPreTrainedModel:()=>v.ElectraPreTrainedModel,ElectraTokenizer:()=>dr.ElectraTokenizer,EosTokenCriteria:()=>wd.EosTokenCriteria,EsmForMaskedLM:()=>v.EsmForMaskedLM,EsmForSequenceClassification:()=>v.EsmForSequenceClassification,EsmForTokenClassification:()=>v.EsmForTokenClassification,EsmModel:()=>v.EsmModel,EsmPreTrainedModel:()=>v.EsmPreTrainedModel,EsmTokenizer:()=>dr.EsmTokenizer,FFT:()=>Fn.FFT,FalconForCausalLM:()=>v.FalconForCausalLM,FalconModel:()=>v.FalconModel,FalconPreTrainedModel:()=>v.FalconPreTrainedModel,FalconTokenizer:()=>dr.FalconTokenizer,FastViTForImageClassification:()=>v.FastViTForImageClassification,FastViTModel:()=>v.FastViTModel,FastViTPreTrainedModel:()=>v.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>Hr.FeatureExtractionPipeline,FeatureExtractor:()=>ir.FeatureExtractor,FillMaskPipeline:()=>Hr.FillMaskPipeline,Florence2ForConditionalGeneration:()=>v.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>v.Florence2PreTrainedModel,Florence2Processor:()=>ir.Florence2Processor,GLPNFeatureExtractor:()=>ir.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>v.GLPNForDepthEstimation,GLPNModel:()=>v.GLPNModel,GLPNPreTrainedModel:()=>v.GLPNPreTrainedModel,GPT2LMHeadModel:()=>v.GPT2LMHeadModel,GPT2Model:()=>v.GPT2Model,GPT2PreTrainedModel:()=>v.GPT2PreTrainedModel,GPT2Tokenizer:()=>dr.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>v.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>v.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>v.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>v.GPTJForCausalLM,GPTJModel:()=>v.GPTJModel,GPTJPreTrainedModel:()=>v.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>v.GPTNeoForCausalLM,GPTNeoModel:()=>v.GPTNeoModel,GPTNeoPreTrainedModel:()=>v.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>v.GPTNeoXForCausalLM,GPTNeoXModel:()=>v.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>v.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>dr.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>v.Gemma2ForCausalLM,Gemma2Model:()=>v.Gemma2Model,Gemma2PreTrainedModel:()=>v.Gemma2PreTrainedModel,GemmaForCausalLM:()=>v.GemmaForCausalLM,GemmaModel:()=>v.GemmaModel,GemmaPreTrainedModel:()=>v.GemmaPreTrainedModel,GemmaTokenizer:()=>dr.GemmaTokenizer,GraniteForCausalLM:()=>v.GraniteForCausalLM,GraniteModel:()=>v.GraniteModel,GranitePreTrainedModel:()=>v.GranitePreTrainedModel,Grok1Tokenizer:()=>dr.Grok1Tokenizer,GroupViTModel:()=>v.GroupViTModel,GroupViTPreTrainedModel:()=>v.GroupViTPreTrainedModel,HerbertTokenizer:()=>dr.HerbertTokenizer,HieraForImageClassification:()=>v.HieraForImageClassification,HieraModel:()=>v.HieraModel,HieraPreTrainedModel:()=>v.HieraPreTrainedModel,HubertForCTC:()=>v.HubertForCTC,HubertForSequenceClassification:()=>v.HubertForSequenceClassification,HubertModel:()=>v.HubertModel,HubertPreTrainedModel:()=>v.HubertPreTrainedModel,ImageClassificationPipeline:()=>Hr.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>Hr.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>ir.ImageFeatureExtractor,ImageMattingOutput:()=>v.ImageMattingOutput,ImageSegmentationPipeline:()=>Hr.ImageSegmentationPipeline,ImageToImagePipeline:()=>Hr.ImageToImagePipeline,ImageToTextPipeline:()=>Hr.ImageToTextPipeline,InterruptableStoppingCriteria:()=>wd.InterruptableStoppingCriteria,JAISLMHeadModel:()=>v.JAISLMHeadModel,JAISModel:()=>v.JAISModel,JAISPreTrainedModel:()=>v.JAISPreTrainedModel,LlamaForCausalLM:()=>v.LlamaForCausalLM,LlamaModel:()=>v.LlamaModel,LlamaPreTrainedModel:()=>v.LlamaPreTrainedModel,LlamaTokenizer:()=>dr.LlamaTokenizer,LlavaForConditionalGeneration:()=>v.LlavaForConditionalGeneration,LlavaPreTrainedModel:()=>v.LlavaPreTrainedModel,LongT5ForConditionalGeneration:()=>v.LongT5ForConditionalGeneration,LongT5Model:()=>v.LongT5Model,LongT5PreTrainedModel:()=>v.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>v.M2M100ForConditionalGeneration,M2M100Model:()=>v.M2M100Model,M2M100PreTrainedModel:()=>v.M2M100PreTrainedModel,M2M100Tokenizer:()=>dr.M2M100Tokenizer,MBart50Tokenizer:()=>dr.MBart50Tokenizer,MBartForCausalLM:()=>v.MBartForCausalLM,MBartForConditionalGeneration:()=>v.MBartForConditionalGeneration,MBartForSequenceClassification:()=>v.MBartForSequenceClassification,MBartModel:()=>v.MBartModel,MBartPreTrainedModel:()=>v.MBartPreTrainedModel,MBartTokenizer:()=>dr.MBartTokenizer,MPNetForMaskedLM:()=>v.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>v.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>v.MPNetForSequenceClassification,MPNetForTokenClassification:()=>v.MPNetForTokenClassification,MPNetModel:()=>v.MPNetModel,MPNetPreTrainedModel:()=>v.MPNetPreTrainedModel,MPNetTokenizer:()=>dr.MPNetTokenizer,MT5ForConditionalGeneration:()=>v.MT5ForConditionalGeneration,MT5Model:()=>v.MT5Model,MT5PreTrainedModel:()=>v.MT5PreTrainedModel,MarianMTModel:()=>v.MarianMTModel,MarianModel:()=>v.MarianModel,MarianPreTrainedModel:()=>v.MarianPreTrainedModel,MarianTokenizer:()=>dr.MarianTokenizer,MaskFormerFeatureExtractor:()=>ir.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>v.MaskFormerForInstanceSegmentation,MaskFormerModel:()=>v.MaskFormerModel,MaskFormerPreTrainedModel:()=>v.MaskFormerPreTrainedModel,MaskedLMOutput:()=>v.MaskedLMOutput,MaxLengthCriteria:()=>wd.MaxLengthCriteria,MistralForCausalLM:()=>v.MistralForCausalLM,MistralModel:()=>v.MistralModel,MistralPreTrainedModel:()=>v.MistralPreTrainedModel,MobileBertForMaskedLM:()=>v.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>v.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>v.MobileBertForSequenceClassification,MobileBertModel:()=>v.MobileBertModel,MobileBertPreTrainedModel:()=>v.MobileBertPreTrainedModel,MobileBertTokenizer:()=>dr.MobileBertTokenizer,MobileLLMForCausalLM:()=>v.MobileLLMForCausalLM,MobileLLMModel:()=>v.MobileLLMModel,MobileLLMPreTrainedModel:()=>v.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>ir.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>v.MobileNetV1ForImageClassification,MobileNetV1Model:()=>v.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>v.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>ir.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>v.MobileNetV2ForImageClassification,MobileNetV2Model:()=>v.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>v.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>ir.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>v.MobileNetV3ForImageClassification,MobileNetV3Model:()=>v.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>v.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>ir.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>v.MobileNetV4ForImageClassification,MobileNetV4Model:()=>v.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>v.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>ir.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>v.MobileViTForImageClassification,MobileViTImageProcessor:()=>ir.MobileViTImageProcessor,MobileViTModel:()=>v.MobileViTModel,MobileViTPreTrainedModel:()=>v.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>v.MobileViTV2ForImageClassification,MobileViTV2Model:()=>v.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>v.MobileViTV2PreTrainedModel,ModelOutput:()=>v.ModelOutput,Moondream1ForConditionalGeneration:()=>v.Moondream1ForConditionalGeneration,MptForCausalLM:()=>v.MptForCausalLM,MptModel:()=>v.MptModel,MptPreTrainedModel:()=>v.MptPreTrainedModel,MusicgenForCausalLM:()=>v.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>v.MusicgenForConditionalGeneration,MusicgenModel:()=>v.MusicgenModel,MusicgenPreTrainedModel:()=>v.MusicgenPreTrainedModel,NllbTokenizer:()=>dr.NllbTokenizer,NomicBertModel:()=>v.NomicBertModel,NomicBertPreTrainedModel:()=>v.NomicBertPreTrainedModel,NougatImageProcessor:()=>ir.NougatImageProcessor,NougatTokenizer:()=>dr.NougatTokenizer,OPTForCausalLM:()=>v.OPTForCausalLM,OPTModel:()=>v.OPTModel,OPTPreTrainedModel:()=>v.OPTPreTrainedModel,ObjectDetectionPipeline:()=>Hr.ObjectDetectionPipeline,OlmoForCausalLM:()=>v.OlmoForCausalLM,OlmoModel:()=>v.OlmoModel,OlmoPreTrainedModel:()=>v.OlmoPreTrainedModel,OpenELMForCausalLM:()=>v.OpenELMForCausalLM,OpenELMModel:()=>v.OpenELMModel,OpenELMPreTrainedModel:()=>v.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>ir.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>v.OwlViTForObjectDetection,OwlViTModel:()=>v.OwlViTModel,OwlViTPreTrainedModel:()=>v.OwlViTPreTrainedModel,OwlViTProcessor:()=>ir.OwlViTProcessor,Owlv2ForObjectDetection:()=>v.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>ir.Owlv2ImageProcessor,Owlv2Model:()=>v.Owlv2Model,Owlv2PreTrainedModel:()=>v.Owlv2PreTrainedModel,Phi3ForCausalLM:()=>v.Phi3ForCausalLM,Phi3Model:()=>v.Phi3Model,Phi3PreTrainedModel:()=>v.Phi3PreTrainedModel,PhiForCausalLM:()=>v.PhiForCausalLM,PhiModel:()=>v.PhiModel,PhiPreTrainedModel:()=>v.PhiPreTrainedModel,Pipeline:()=>Hr.Pipeline,PreTrainedModel:()=>v.PreTrainedModel,PreTrainedTokenizer:()=>dr.PreTrainedTokenizer,PretrainedConfig:()=>jp.PretrainedConfig,PretrainedMixin:()=>v.PretrainedMixin,Processor:()=>ir.Processor,PvtForImageClassification:()=>v.PvtForImageClassification,PvtImageProcessor:()=>ir.PvtImageProcessor,PvtModel:()=>v.PvtModel,PvtPreTrainedModel:()=>v.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>ir.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>v.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>v.PyAnnoteModel,PyAnnotePreTrainedModel:()=>v.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>ir.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>v.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>Hr.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>v.Qwen2ForCausalLM,Qwen2Model:()=>v.Qwen2Model,Qwen2PreTrainedModel:()=>v.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>dr.Qwen2Tokenizer,RTDetrForObjectDetection:()=>v.RTDetrForObjectDetection,RTDetrImageProcessor:()=>ir.RTDetrImageProcessor,RTDetrModel:()=>v.RTDetrModel,RTDetrObjectDetectionOutput:()=>v.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>v.RTDetrPreTrainedModel,RawImage:()=>b_.RawImage,ResNetForImageClassification:()=>v.ResNetForImageClassification,ResNetModel:()=>v.ResNetModel,ResNetPreTrainedModel:()=>v.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>v.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>v.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>v.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>v.RoFormerForTokenClassification,RoFormerModel:()=>v.RoFormerModel,RoFormerPreTrainedModel:()=>v.RoFormerPreTrainedModel,RoFormerTokenizer:()=>dr.RoFormerTokenizer,RobertaForMaskedLM:()=>v.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>v.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>v.RobertaForSequenceClassification,RobertaForTokenClassification:()=>v.RobertaForTokenClassification,RobertaModel:()=>v.RobertaModel,RobertaPreTrainedModel:()=>v.RobertaPreTrainedModel,RobertaTokenizer:()=>dr.RobertaTokenizer,SamImageProcessor:()=>ir.SamImageProcessor,SamImageSegmentationOutput:()=>v.SamImageSegmentationOutput,SamModel:()=>v.SamModel,SamPreTrainedModel:()=>v.SamPreTrainedModel,SamProcessor:()=>ir.SamProcessor,SapiensFeatureExtractor:()=>ir.SapiensFeatureExtractor,SapiensForDepthEstimation:()=>v.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>v.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>v.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>v.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>ir.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>ir.SegformerFeatureExtractor,SegformerForImageClassification:()=>v.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>v.SegformerForSemanticSegmentation,SegformerModel:()=>v.SegformerModel,SegformerPreTrainedModel:()=>v.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>v.Seq2SeqLMOutput,SequenceClassifierOutput:()=>v.SequenceClassifierOutput,SiglipImageProcessor:()=>ir.SiglipImageProcessor,SiglipModel:()=>v.SiglipModel,SiglipPreTrainedModel:()=>v.SiglipPreTrainedModel,SiglipTextModel:()=>v.SiglipTextModel,SiglipTokenizer:()=>dr.SiglipTokenizer,SiglipVisionModel:()=>v.SiglipVisionModel,SpeechT5FeatureExtractor:()=>ir.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>v.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>v.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>v.SpeechT5HifiGan,SpeechT5Model:()=>v.SpeechT5Model,SpeechT5PreTrainedModel:()=>v.SpeechT5PreTrainedModel,SpeechT5Processor:()=>ir.SpeechT5Processor,SpeechT5Tokenizer:()=>dr.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>v.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>v.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>v.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>v.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>v.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>dr.SqueezeBertTokenizer,StableLmForCausalLM:()=>v.StableLmForCausalLM,StableLmModel:()=>v.StableLmModel,StableLmPreTrainedModel:()=>v.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>v.Starcoder2ForCausalLM,Starcoder2Model:()=>v.Starcoder2Model,Starcoder2PreTrainedModel:()=>v.Starcoder2PreTrainedModel,StoppingCriteria:()=>wd.StoppingCriteria,StoppingCriteriaList:()=>wd.StoppingCriteriaList,SummarizationPipeline:()=>Hr.SummarizationPipeline,Swin2SRForImageSuperResolution:()=>v.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>ir.Swin2SRImageProcessor,Swin2SRModel:()=>v.Swin2SRModel,Swin2SRPreTrainedModel:()=>v.Swin2SRPreTrainedModel,SwinForImageClassification:()=>v.SwinForImageClassification,SwinModel:()=>v.SwinModel,SwinPreTrainedModel:()=>v.SwinPreTrainedModel,T5ForConditionalGeneration:()=>v.T5ForConditionalGeneration,T5Model:()=>v.T5Model,T5PreTrainedModel:()=>v.T5PreTrainedModel,T5Tokenizer:()=>dr.T5Tokenizer,TableTransformerForObjectDetection:()=>v.TableTransformerForObjectDetection,TableTransformerModel:()=>v.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>v.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>v.TableTransformerPreTrainedModel,Tensor:()=>cn.Tensor,Text2TextGenerationPipeline:()=>Hr.Text2TextGenerationPipeline,TextClassificationPipeline:()=>Hr.TextClassificationPipeline,TextGenerationPipeline:()=>Hr.TextGenerationPipeline,TextStreamer:()=>Up.TextStreamer,TextToAudioPipeline:()=>Hr.TextToAudioPipeline,TokenClassificationPipeline:()=>Hr.TokenClassificationPipeline,TokenClassifierOutput:()=>v.TokenClassifierOutput,TokenizerModel:()=>dr.TokenizerModel,TrOCRForCausalLM:()=>v.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>v.TrOCRPreTrainedModel,TranslationPipeline:()=>Hr.TranslationPipeline,UniSpeechForCTC:()=>v.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>v.UniSpeechForSequenceClassification,UniSpeechModel:()=>v.UniSpeechModel,UniSpeechPreTrainedModel:()=>v.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>v.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>v.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>v.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>v.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>v.UniSpeechSatPreTrainedModel,ViTFeatureExtractor:()=>ir.ViTFeatureExtractor,ViTForImageClassification:()=>v.ViTForImageClassification,ViTImageProcessor:()=>ir.ViTImageProcessor,ViTMAEModel:()=>v.ViTMAEModel,ViTMAEPreTrainedModel:()=>v.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>v.ViTMSNForImageClassification,ViTMSNModel:()=>v.ViTMSNModel,ViTMSNPreTrainedModel:()=>v.ViTMSNPreTrainedModel,ViTModel:()=>v.ViTModel,ViTPreTrainedModel:()=>v.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>v.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>v.VitMatteForImageMatting,VitMatteImageProcessor:()=>ir.VitMatteImageProcessor,VitMattePreTrainedModel:()=>v.VitMattePreTrainedModel,VitsModel:()=>v.VitsModel,VitsModelOutput:()=>v.VitsModelOutput,VitsPreTrainedModel:()=>v.VitsPreTrainedModel,VitsTokenizer:()=>dr.VitsTokenizer,Wav2Vec2BertForCTC:()=>v.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>v.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>v.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>v.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>dr.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>ir.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>v.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>v.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>v.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>v.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>v.Wav2Vec2PreTrainedModel,Wav2Vec2ProcessorWithLM:()=>ir.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>v.WavLMForAudioFrameClassification,WavLMForCTC:()=>v.WavLMForCTC,WavLMForSequenceClassification:()=>v.WavLMForSequenceClassification,WavLMForXVector:()=>v.WavLMForXVector,WavLMModel:()=>v.WavLMModel,WavLMPreTrainedModel:()=>v.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>ir.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>v.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>v.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>ir.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>v.WhisperForConditionalGeneration,WhisperModel:()=>v.WhisperModel,WhisperPreTrainedModel:()=>v.WhisperPreTrainedModel,WhisperProcessor:()=>ir.WhisperProcessor,WhisperTextStreamer:()=>Up.WhisperTextStreamer,WhisperTokenizer:()=>dr.WhisperTokenizer,XLMForQuestionAnswering:()=>v.XLMForQuestionAnswering,XLMForSequenceClassification:()=>v.XLMForSequenceClassification,XLMForTokenClassification:()=>v.XLMForTokenClassification,XLMModel:()=>v.XLMModel,XLMPreTrainedModel:()=>v.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>v.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>v.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>v.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>v.XLMRobertaForTokenClassification,XLMRobertaModel:()=>v.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>v.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>dr.XLMRobertaTokenizer,XLMTokenizer:()=>dr.XLMTokenizer,XLMWithLMHeadModel:()=>v.XLMWithLMHeadModel,XVectorOutput:()=>v.XVectorOutput,YolosFeatureExtractor:()=>ir.YolosFeatureExtractor,YolosForObjectDetection:()=>v.YolosForObjectDetection,YolosModel:()=>v.YolosModel,YolosObjectDetectionOutput:()=>v.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>v.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>Hr.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>Hr.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>Hr.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>Hr.ZeroShotObjectDetectionPipeline,bankers_round:()=>Fn.bankers_round,cat:()=>cn.cat,cos_sim:()=>Fn.cos_sim,dot:()=>Fn.dot,dynamic_time_warping:()=>Fn.dynamic_time_warping,env:()=>y_.env,full:()=>cn.full,full_like:()=>cn.full_like,getKeyValueShapes:()=>jp.getKeyValueShapes,hamming:()=>oa.hamming,hanning:()=>oa.hanning,interpolate:()=>cn.interpolate,interpolate_4d:()=>cn.interpolate_4d,interpolate_data:()=>Fn.interpolate_data,is_chinese_char:()=>dr.is_chinese_char,layer_norm:()=>cn.layer_norm,log_softmax:()=>Fn.log_softmax,magnitude:()=>Fn.magnitude,matmul:()=>cn.matmul,max:()=>Fn.max,mean:()=>cn.mean,mean_pooling:()=>cn.mean_pooling,medianFilter:()=>Fn.medianFilter,mel_filter_bank:()=>oa.mel_filter_bank,min:()=>Fn.min,ones:()=>cn.ones,ones_like:()=>cn.ones_like,permute:()=>cn.permute,permute_data:()=>Fn.permute_data,pipeline:()=>Hr.pipeline,quantize_embeddings:()=>cn.quantize_embeddings,read_audio:()=>oa.read_audio,rfft:()=>cn.rfft,round:()=>Fn.round,softmax:()=>Fn.softmax,spectrogram:()=>oa.spectrogram,stack:()=>cn.stack,std_mean:()=>cn.std_mean,topk:()=>cn.topk,window_function:()=>oa.window_function,zeros:()=>cn.zeros,zeros_like:()=>cn.zeros_like});var y_=Kr("./src/env.js"),Hr=Kr("./src/pipelines.js"),v=Kr("./src/models.js"),dr=Kr("./src/tokenizers.js"),ir=Kr("./src/processors.js"),jp=Kr("./src/configs.js"),oa=Kr("./src/utils/audio.js"),b_=Kr("./src/utils/image.js"),cn=Kr("./src/utils/tensor.js"),Fn=Kr("./src/utils/maths.js"),Up=Kr("./src/generation/streamers.js"),wd=Kr("./src/generation/stopping_criteria.js");p.ASTFeatureExtractor;p.ASTForAudioClassification;p.ASTModel;p.ASTPreTrainedModel;p.AlbertForMaskedLM;p.AlbertForQuestionAnswering;p.AlbertForSequenceClassification;p.AlbertModel;p.AlbertPreTrainedModel;p.AlbertTokenizer;p.AudioClassificationPipeline;p.AutoConfig;p.AutoModel;p.AutoModelForAudioClassification;p.AutoModelForAudioFrameClassification;p.AutoModelForCTC;p.AutoModelForCausalLM;p.AutoModelForDepthEstimation;p.AutoModelForDocumentQuestionAnswering;p.AutoModelForImageClassification;p.AutoModelForImageFeatureExtraction;p.AutoModelForImageMatting;p.AutoModelForImageSegmentation;p.AutoModelForImageToImage;p.AutoModelForMaskGeneration;p.AutoModelForMaskedLM;p.AutoModelForNormalEstimation;p.AutoModelForObjectDetection;p.AutoModelForQuestionAnswering;p.AutoModelForSemanticSegmentation;p.AutoModelForSeq2SeqLM;p.AutoModelForSequenceClassification;p.AutoModelForSpeechSeq2Seq;p.AutoModelForTextToSpectrogram;p.AutoModelForTextToWaveform;p.AutoModelForTokenClassification;p.AutoModelForUniversalSegmentation;p.AutoModelForVision2Seq;p.AutoModelForXVector;p.AutoModelForZeroShotObjectDetection;p.AutoProcessor;p.AutoTokenizer;p.AutomaticSpeechRecognitionPipeline;p.BartForConditionalGeneration;p.BartForSequenceClassification;p.BartModel;p.BartPretrainedModel;p.BartTokenizer;p.BaseModelOutput;p.BaseStreamer;p.BeitFeatureExtractor;p.BeitForImageClassification;p.BeitModel;p.BeitPreTrainedModel;p.BertForMaskedLM;p.BertForQuestionAnswering;p.BertForSequenceClassification;p.BertForTokenClassification;p.BertModel;p.BertPreTrainedModel;p.BertTokenizer;p.BitImageProcessor;p.BlenderbotForConditionalGeneration;p.BlenderbotModel;p.BlenderbotPreTrainedModel;p.BlenderbotSmallForConditionalGeneration;p.BlenderbotSmallModel;p.BlenderbotSmallPreTrainedModel;p.BlenderbotSmallTokenizer;p.BlenderbotTokenizer;p.BloomForCausalLM;p.BloomModel;p.BloomPreTrainedModel;p.BloomTokenizer;p.CLIPFeatureExtractor;p.CLIPImageProcessor;p.CLIPModel;p.CLIPPreTrainedModel;p.CLIPSegForImageSegmentation;p.CLIPSegModel;p.CLIPSegPreTrainedModel;p.CLIPTextModel;p.CLIPTextModelWithProjection;p.CLIPTokenizer;p.CLIPVisionModel;p.CLIPVisionModelWithProjection;p.CamembertForMaskedLM;p.CamembertForQuestionAnswering;p.CamembertForSequenceClassification;p.CamembertForTokenClassification;p.CamembertModel;p.CamembertPreTrainedModel;p.CamembertTokenizer;p.CausalLMOutput;p.CausalLMOutputWithPast;p.ChineseCLIPFeatureExtractor;p.ChineseCLIPModel;p.ChineseCLIPPreTrainedModel;p.ClapAudioModelWithProjection;p.ClapFeatureExtractor;p.ClapModel;p.ClapPreTrainedModel;p.ClapTextModelWithProjection;p.CodeGenForCausalLM;p.CodeGenModel;p.CodeGenPreTrainedModel;p.CodeGenTokenizer;p.CodeLlamaTokenizer;p.CohereForCausalLM;p.CohereModel;p.CoherePreTrainedModel;p.CohereTokenizer;p.ConvBertForMaskedLM;p.ConvBertForQuestionAnswering;p.ConvBertForSequenceClassification;p.ConvBertForTokenClassification;p.ConvBertModel;p.ConvBertPreTrainedModel;p.ConvBertTokenizer;p.ConvNextFeatureExtractor;p.ConvNextForImageClassification;p.ConvNextImageProcessor;p.ConvNextModel;p.ConvNextPreTrainedModel;p.ConvNextV2ForImageClassification;p.ConvNextV2Model;p.ConvNextV2PreTrainedModel;p.DPTFeatureExtractor;p.DPTForDepthEstimation;p.DPTImageProcessor;p.DPTModel;p.DPTPreTrainedModel;p.DebertaForMaskedLM;p.DebertaForQuestionAnswering;p.DebertaForSequenceClassification;p.DebertaForTokenClassification;p.DebertaModel;p.DebertaPreTrainedModel;p.DebertaTokenizer;p.DebertaV2ForMaskedLM;p.DebertaV2ForQuestionAnswering;p.DebertaV2ForSequenceClassification;p.DebertaV2ForTokenClassification;p.DebertaV2Model;p.DebertaV2PreTrainedModel;p.DebertaV2Tokenizer;p.DecisionTransformerModel;p.DecisionTransformerPreTrainedModel;p.DeiTFeatureExtractor;p.DeiTForImageClassification;p.DeiTModel;p.DeiTPreTrainedModel;p.DepthAnythingForDepthEstimation;p.DepthAnythingPreTrainedModel;p.DepthEstimationPipeline;p.DepthProForDepthEstimation;p.DepthProPreTrainedModel;p.DetrFeatureExtractor;p.DetrForObjectDetection;p.DetrForSegmentation;p.DetrModel;p.DetrObjectDetectionOutput;p.DetrPreTrainedModel;p.DetrSegmentationOutput;p.Dinov2ForImageClassification;p.Dinov2Model;p.Dinov2PreTrainedModel;p.DistilBertForMaskedLM;p.DistilBertForQuestionAnswering;p.DistilBertForSequenceClassification;p.DistilBertForTokenClassification;p.DistilBertModel;p.DistilBertPreTrainedModel;p.DistilBertTokenizer;p.DocumentQuestionAnsweringPipeline;p.DonutFeatureExtractor;p.DonutImageProcessor;p.DonutSwinModel;p.DonutSwinPreTrainedModel;p.EfficientNetForImageClassification;p.EfficientNetImageProcessor;p.EfficientNetModel;p.EfficientNetPreTrainedModel;p.ElectraForMaskedLM;p.ElectraForQuestionAnswering;p.ElectraForSequenceClassification;p.ElectraForTokenClassification;p.ElectraModel;p.ElectraPreTrainedModel;p.ElectraTokenizer;p.EosTokenCriteria;p.EsmForMaskedLM;p.EsmForSequenceClassification;p.EsmForTokenClassification;p.EsmModel;p.EsmPreTrainedModel;p.EsmTokenizer;p.FFT;p.FalconForCausalLM;p.FalconModel;p.FalconPreTrainedModel;p.FalconTokenizer;p.FastViTForImageClassification;p.FastViTModel;p.FastViTPreTrainedModel;p.FeatureExtractionPipeline;p.FeatureExtractor;p.FillMaskPipeline;p.Florence2ForConditionalGeneration;p.Florence2PreTrainedModel;p.Florence2Processor;p.GLPNFeatureExtractor;p.GLPNForDepthEstimation;p.GLPNModel;p.GLPNPreTrainedModel;p.GPT2LMHeadModel;p.GPT2Model;p.GPT2PreTrainedModel;p.GPT2Tokenizer;p.GPTBigCodeForCausalLM;p.GPTBigCodeModel;p.GPTBigCodePreTrainedModel;p.GPTJForCausalLM;p.GPTJModel;p.GPTJPreTrainedModel;p.GPTNeoForCausalLM;p.GPTNeoModel;p.GPTNeoPreTrainedModel;p.GPTNeoXForCausalLM;p.GPTNeoXModel;p.GPTNeoXPreTrainedModel;p.GPTNeoXTokenizer;p.Gemma2ForCausalLM;p.Gemma2Model;p.Gemma2PreTrainedModel;p.GemmaForCausalLM;p.GemmaModel;p.GemmaPreTrainedModel;p.GemmaTokenizer;p.GraniteForCausalLM;p.GraniteModel;p.GranitePreTrainedModel;p.Grok1Tokenizer;p.GroupViTModel;p.GroupViTPreTrainedModel;p.HerbertTokenizer;p.HieraForImageClassification;p.HieraModel;p.HieraPreTrainedModel;p.HubertForCTC;p.HubertForSequenceClassification;p.HubertModel;p.HubertPreTrainedModel;p.ImageClassificationPipeline;p.ImageFeatureExtractionPipeline;p.ImageFeatureExtractor;p.ImageMattingOutput;p.ImageSegmentationPipeline;p.ImageToImagePipeline;p.ImageToTextPipeline;p.InterruptableStoppingCriteria;p.JAISLMHeadModel;p.JAISModel;p.JAISPreTrainedModel;p.LlamaForCausalLM;p.LlamaModel;p.LlamaPreTrainedModel;p.LlamaTokenizer;p.LlavaForConditionalGeneration;p.LlavaPreTrainedModel;p.LongT5ForConditionalGeneration;p.LongT5Model;p.LongT5PreTrainedModel;p.M2M100ForConditionalGeneration;p.M2M100Model;p.M2M100PreTrainedModel;p.M2M100Tokenizer;p.MBart50Tokenizer;p.MBartForCausalLM;p.MBartForConditionalGeneration;p.MBartForSequenceClassification;p.MBartModel;p.MBartPreTrainedModel;p.MBartTokenizer;p.MPNetForMaskedLM;p.MPNetForQuestionAnswering;p.MPNetForSequenceClassification;p.MPNetForTokenClassification;p.MPNetModel;p.MPNetPreTrainedModel;p.MPNetTokenizer;p.MT5ForConditionalGeneration;p.MT5Model;p.MT5PreTrainedModel;p.MarianMTModel;p.MarianModel;p.MarianPreTrainedModel;p.MarianTokenizer;p.MaskFormerFeatureExtractor;p.MaskFormerForInstanceSegmentation;p.MaskFormerModel;p.MaskFormerPreTrainedModel;p.MaskedLMOutput;p.MaxLengthCriteria;p.MistralForCausalLM;p.MistralModel;p.MistralPreTrainedModel;p.MobileBertForMaskedLM;p.MobileBertForQuestionAnswering;p.MobileBertForSequenceClassification;p.MobileBertModel;p.MobileBertPreTrainedModel;p.MobileBertTokenizer;p.MobileLLMForCausalLM;p.MobileLLMModel;p.MobileLLMPreTrainedModel;p.MobileNetV1FeatureExtractor;p.MobileNetV1ForImageClassification;p.MobileNetV1Model;p.MobileNetV1PreTrainedModel;p.MobileNetV2FeatureExtractor;p.MobileNetV2ForImageClassification;p.MobileNetV2Model;p.MobileNetV2PreTrainedModel;p.MobileNetV3FeatureExtractor;p.MobileNetV3ForImageClassification;p.MobileNetV3Model;p.MobileNetV3PreTrainedModel;p.MobileNetV4FeatureExtractor;p.MobileNetV4ForImageClassification;p.MobileNetV4Model;p.MobileNetV4PreTrainedModel;p.MobileViTFeatureExtractor;p.MobileViTForImageClassification;p.MobileViTImageProcessor;p.MobileViTModel;p.MobileViTPreTrainedModel;p.MobileViTV2ForImageClassification;p.MobileViTV2Model;p.MobileViTV2PreTrainedModel;p.ModelOutput;p.Moondream1ForConditionalGeneration;p.MptForCausalLM;p.MptModel;p.MptPreTrainedModel;p.MusicgenForCausalLM;p.MusicgenForConditionalGeneration;p.MusicgenModel;p.MusicgenPreTrainedModel;p.NllbTokenizer;p.NomicBertModel;p.NomicBertPreTrainedModel;p.NougatImageProcessor;p.NougatTokenizer;p.OPTForCausalLM;p.OPTModel;p.OPTPreTrainedModel;p.ObjectDetectionPipeline;p.OlmoForCausalLM;p.OlmoModel;p.OlmoPreTrainedModel;p.OpenELMForCausalLM;p.OpenELMModel;p.OpenELMPreTrainedModel;p.OwlViTFeatureExtractor;p.OwlViTForObjectDetection;p.OwlViTModel;p.OwlViTPreTrainedModel;p.OwlViTProcessor;p.Owlv2ForObjectDetection;p.Owlv2ImageProcessor;p.Owlv2Model;p.Owlv2PreTrainedModel;p.Phi3ForCausalLM;p.Phi3Model;p.Phi3PreTrainedModel;p.PhiForCausalLM;p.PhiModel;p.PhiPreTrainedModel;p.Pipeline;p.PreTrainedModel;p.PreTrainedTokenizer;p.PretrainedConfig;p.PretrainedMixin;p.Processor;p.PvtForImageClassification;p.PvtImageProcessor;p.PvtModel;p.PvtPreTrainedModel;p.PyAnnoteFeatureExtractor;p.PyAnnoteForAudioFrameClassification;p.PyAnnoteModel;p.PyAnnotePreTrainedModel;p.PyAnnoteProcessor;p.QuestionAnsweringModelOutput;p.QuestionAnsweringPipeline;p.Qwen2ForCausalLM;p.Qwen2Model;p.Qwen2PreTrainedModel;p.Qwen2Tokenizer;p.RTDetrForObjectDetection;p.RTDetrImageProcessor;p.RTDetrModel;p.RTDetrObjectDetectionOutput;p.RTDetrPreTrainedModel;p.RawImage;p.ResNetForImageClassification;p.ResNetModel;p.ResNetPreTrainedModel;p.RoFormerForMaskedLM;p.RoFormerForQuestionAnswering;p.RoFormerForSequenceClassification;p.RoFormerForTokenClassification;p.RoFormerModel;p.RoFormerPreTrainedModel;p.RoFormerTokenizer;p.RobertaForMaskedLM;p.RobertaForQuestionAnswering;p.RobertaForSequenceClassification;p.RobertaForTokenClassification;p.RobertaModel;p.RobertaPreTrainedModel;p.RobertaTokenizer;p.SamImageProcessor;p.SamImageSegmentationOutput;p.SamModel;p.SamPreTrainedModel;p.SamProcessor;p.SapiensFeatureExtractor;p.SapiensForDepthEstimation;p.SapiensForNormalEstimation;p.SapiensForSemanticSegmentation;p.SapiensPreTrainedModel;p.SeamlessM4TFeatureExtractor;p.SegformerFeatureExtractor;p.SegformerForImageClassification;p.SegformerForSemanticSegmentation;p.SegformerModel;p.SegformerPreTrainedModel;p.Seq2SeqLMOutput;p.SequenceClassifierOutput;p.SiglipImageProcessor;p.SiglipModel;p.SiglipPreTrainedModel;p.SiglipTextModel;p.SiglipTokenizer;p.SiglipVisionModel;p.SpeechT5FeatureExtractor;p.SpeechT5ForSpeechToText;p.SpeechT5ForTextToSpeech;p.SpeechT5HifiGan;p.SpeechT5Model;p.SpeechT5PreTrainedModel;p.SpeechT5Processor;p.SpeechT5Tokenizer;p.SqueezeBertForMaskedLM;p.SqueezeBertForQuestionAnswering;p.SqueezeBertForSequenceClassification;p.SqueezeBertModel;p.SqueezeBertPreTrainedModel;p.SqueezeBertTokenizer;p.StableLmForCausalLM;p.StableLmModel;p.StableLmPreTrainedModel;p.Starcoder2ForCausalLM;p.Starcoder2Model;p.Starcoder2PreTrainedModel;p.StoppingCriteria;p.StoppingCriteriaList;p.SummarizationPipeline;p.Swin2SRForImageSuperResolution;p.Swin2SRImageProcessor;p.Swin2SRModel;p.Swin2SRPreTrainedModel;p.SwinForImageClassification;p.SwinModel;p.SwinPreTrainedModel;p.T5ForConditionalGeneration;p.T5Model;p.T5PreTrainedModel;p.T5Tokenizer;p.TableTransformerForObjectDetection;p.TableTransformerModel;p.TableTransformerObjectDetectionOutput;p.TableTransformerPreTrainedModel;p.Tensor;p.Text2TextGenerationPipeline;p.TextClassificationPipeline;p.TextGenerationPipeline;p.TextStreamer;p.TextToAudioPipeline;p.TokenClassificationPipeline;p.TokenClassifierOutput;p.TokenizerModel;p.TrOCRForCausalLM;p.TrOCRPreTrainedModel;p.TranslationPipeline;p.UniSpeechForCTC;p.UniSpeechForSequenceClassification;p.UniSpeechModel;p.UniSpeechPreTrainedModel;p.UniSpeechSatForAudioFrameClassification;p.UniSpeechSatForCTC;p.UniSpeechSatForSequenceClassification;p.UniSpeechSatModel;p.UniSpeechSatPreTrainedModel;p.ViTFeatureExtractor;p.ViTForImageClassification;p.ViTImageProcessor;p.ViTMAEModel;p.ViTMAEPreTrainedModel;p.ViTMSNForImageClassification;p.ViTMSNModel;p.ViTMSNPreTrainedModel;p.ViTModel;p.ViTPreTrainedModel;p.VisionEncoderDecoderModel;p.VitMatteForImageMatting;p.VitMatteImageProcessor;p.VitMattePreTrainedModel;p.VitsModel;p.VitsModelOutput;p.VitsPreTrainedModel;p.VitsTokenizer;p.Wav2Vec2BertForCTC;p.Wav2Vec2BertForSequenceClassification;p.Wav2Vec2BertModel;p.Wav2Vec2BertPreTrainedModel;p.Wav2Vec2CTCTokenizer;p.Wav2Vec2FeatureExtractor;p.Wav2Vec2ForAudioFrameClassification;p.Wav2Vec2ForCTC;p.Wav2Vec2ForSequenceClassification;p.Wav2Vec2Model;p.Wav2Vec2PreTrainedModel;p.Wav2Vec2ProcessorWithLM;p.WavLMForAudioFrameClassification;p.WavLMForCTC;p.WavLMForSequenceClassification;p.WavLMForXVector;p.WavLMModel;p.WavLMPreTrainedModel;p.WeSpeakerFeatureExtractor;p.WeSpeakerResNetModel;p.WeSpeakerResNetPreTrainedModel;p.WhisperFeatureExtractor;p.WhisperForConditionalGeneration;p.WhisperModel;p.WhisperPreTrainedModel;p.WhisperProcessor;p.WhisperTextStreamer;p.WhisperTokenizer;p.XLMForQuestionAnswering;p.XLMForSequenceClassification;p.XLMForTokenClassification;p.XLMModel;p.XLMPreTrainedModel;p.XLMRobertaForMaskedLM;p.XLMRobertaForQuestionAnswering;p.XLMRobertaForSequenceClassification;p.XLMRobertaForTokenClassification;p.XLMRobertaModel;p.XLMRobertaPreTrainedModel;p.XLMRobertaTokenizer;p.XLMTokenizer;p.XLMWithLMHeadModel;p.XVectorOutput;p.YolosFeatureExtractor;p.YolosForObjectDetection;p.YolosModel;p.YolosObjectDetectionOutput;p.YolosPreTrainedModel;p.ZeroShotAudioClassificationPipeline;p.ZeroShotClassificationPipeline;p.ZeroShotImageClassificationPipeline;p.ZeroShotObjectDetectionPipeline;p.bankers_round;p.cat;p.cos_sim;p.dot;p.dynamic_time_warping;p.env;p.full;p.full_like;p.getKeyValueShapes;p.hamming;p.hanning;p.interpolate;p.interpolate_4d;p.interpolate_data;p.is_chinese_char;p.layer_norm;p.log_softmax;p.magnitude;p.matmul;p.max;p.mean;p.mean_pooling;p.medianFilter;p.mel_filter_bank;p.min;p.ones;p.ones_like;p.permute;p.permute_data;var M_=p.pipeline;p.quantize_embeddings;p.read_audio;p.rfft;p.round;p.softmax;p.spectrogram;p.stack;p.std_mean;p.topk;p.window_function;p.zeros;p.zeros_like;const Vp=10,um=(oe=0)=>R=>`\x1B[${R+oe}m`,dm=(oe=0)=>R=>`\x1B[${38+oe};5;${R}m`,cm=(oe=0)=>(R,T,E)=>`\x1B[${38+oe};2;${R};${T};${E}m`,Zr={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};Object.keys(Zr.modifier);const v_=Object.keys(Zr.color),x_=Object.keys(Zr.bgColor);[...v_,...x_];function T_(){const oe=new Map;for(const[R,T]of Object.entries(Zr)){for(const[E,Z]of Object.entries(T))Zr[E]={open:`\x1B[${Z[0]}m`,close:`\x1B[${Z[1]}m`},T[E]=Zr[E],oe.set(Z[0],Z[1]);Object.defineProperty(Zr,R,{value:T,enumerable:!1})}return Object.defineProperty(Zr,"codes",{value:oe,enumerable:!1}),Zr.color.close="\x1B[39m",Zr.bgColor.close="\x1B[49m",Zr.color.ansi=um(),Zr.color.ansi256=dm(),Zr.color.ansi16m=cm(),Zr.bgColor.ansi=um(Vp),Zr.bgColor.ansi256=dm(Vp),Zr.bgColor.ansi16m=cm(Vp),Object.defineProperties(Zr,{rgbToAnsi256:{value(R,T,E){return R===T&&T===E?R<8?16:R>248?231:Math.round((R-8)/247*24)+232:16+36*Math.round(R/255*5)+6*Math.round(T/255*5)+Math.round(E/255*5)},enumerable:!1},hexToRgb:{value(R){const T=/[a-f\d]{6}|[a-f\d]{3}/i.exec(R.toString(16));if(!T)return[0,0,0];let[E]=T;E.length===3&&(E=[...E].map(re=>re+re).join(""));const Z=Number.parseInt(E,16);return[Z>>16&255,Z>>8&255,Z&255]},enumerable:!1},hexToAnsi256:{value:R=>Zr.rgbToAnsi256(...Zr.hexToRgb(R)),enumerable:!1},ansi256ToAnsi:{value(R){if(R<8)return 30+R;if(R<16)return 90+(R-8);let T,E,Z;if(R>=232)T=((R-232)*10+8)/255,E=T,Z=T;else{R-=16;const Ee=R%36;T=Math.floor(R/36)/5,E=Math.floor(Ee/6)/5,Z=Ee%6/5}const re=Math.max(T,E,Z)*2;if(re===0)return 30;let fe=30+(Math.round(Z)<<2|Math.round(E)<<1|Math.round(T));return re===2&&(fe+=60),fe},enumerable:!1},rgbToAnsi:{value:(R,T,E)=>Zr.ansi256ToAnsi(Zr.rgbToAnsi256(R,T,E)),enumerable:!1},hexToAnsi:{value:R=>Zr.ansi256ToAnsi(Zr.hexToAnsi256(R)),enumerable:!1}}),Zr}const hi=T_(),zc=(()=>{if(navigator.userAgentData){const oe=navigator.userAgentData.brands.find(({brand:R})=>R==="Chromium");if(oe&&oe.version>93)return 3}return/\b(Chrome|Chromium)\//.test(navigator.userAgent)?1:0})(),pm=zc!==0&&{level:zc,hasBasic:!0,has256:zc>=2,has16m:zc>=3},E_={stdout:pm,stderr:pm};function C_(oe,R,T){let E=oe.indexOf(R);if(E===-1)return oe;const Z=R.length;let re=0,fe="";do fe+=oe.slice(re,E)+R+T,re=E+Z,E=oe.indexOf(R,re);while(E!==-1);return fe+=oe.slice(re),fe}function $_(oe,R,T,E){let Z=0,re="";do{const fe=oe[E-1]==="\r";re+=oe.slice(Z,fe?E-1:E)+R+(fe?`\r
`:`
`)+T,Z=E+1,E=oe.indexOf(`
`,Z)}while(E!==-1);return re+=oe.slice(Z),re}const{stdout:hm,stderr:fm}=E_,qp=Symbol("GENERATOR"),la=Symbol("STYLER"),vd=Symbol("IS_EMPTY"),mm=["ansi","ansi","ansi256","ansi16m"],ua=Object.create(null),S_=(oe,R={})=>{if(R.level&&!(Number.isInteger(R.level)&&R.level>=0&&R.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const T=hm?hm.level:0;oe.level=R.level===void 0?T:R.level},k_=oe=>{const R=(...T)=>T.join(" ");return S_(R,oe),Object.setPrototypeOf(R,Td.prototype),R};function Td(oe){return k_(oe)}Object.setPrototypeOf(Td.prototype,Function.prototype);for(const[oe,R]of Object.entries(hi))ua[oe]={get(){const T=Uc(this,Kp(R.open,R.close,this[la]),this[vd]);return Object.defineProperty(this,oe,{value:T}),T}};ua.visible={get(){const oe=Uc(this,this[la],!0);return Object.defineProperty(this,"visible",{value:oe}),oe}};const Hp=(oe,R,T,...E)=>oe==="rgb"?R==="ansi16m"?hi[T].ansi16m(...E):R==="ansi256"?hi[T].ansi256(hi.rgbToAnsi256(...E)):hi[T].ansi(hi.rgbToAnsi(...E)):oe==="hex"?Hp("rgb",R,T,...hi.hexToRgb(...E)):hi[T][oe](...E),P_=["rgb","hex","ansi256"];for(const oe of P_){ua[oe]={get(){const{level:T}=this;return function(...E){const Z=Kp(Hp(oe,mm[T],"color",...E),hi.color.close,this[la]);return Uc(this,Z,this[vd])}}};const R="bg"+oe[0].toUpperCase()+oe.slice(1);ua[R]={get(){const{level:T}=this;return function(...E){const Z=Kp(Hp(oe,mm[T],"bgColor",...E),hi.bgColor.close,this[la]);return Uc(this,Z,this[vd])}}}}const A_=Object.defineProperties(()=>{},{...ua,level:{enumerable:!0,get(){return this[qp].level},set(oe){this[qp].level=oe}}}),Kp=(oe,R,T)=>{let E,Z;return T===void 0?(E=oe,Z=R):(E=T.openAll+oe,Z=R+T.closeAll),{open:oe,close:R,openAll:E,closeAll:Z,parent:T}},Uc=(oe,R,T)=>{const E=(...Z)=>I_(E,Z.length===1?""+Z[0]:Z.join(" "));return Object.setPrototypeOf(E,A_),E[qp]=oe,E[la]=R,E[vd]=T,E},I_=(oe,R)=>{if(oe.level<=0||!R)return oe[vd]?"":R;let T=oe[la];if(T===void 0)return R;const{openAll:E,closeAll:Z}=T;if(R.includes("\x1B"))for(;T!==void 0;)R=C_(R,T.close,T.open),T=T.parent;const re=R.indexOf(`
`);return re!==-1&&(R=$_(R,Z,E,re)),E+R+Z};Object.defineProperties(Td.prototype,ua);const Wc=Td();Td({level:fm?fm.level:0});function F_(oe){return oe&&oe.__esModule&&Object.prototype.hasOwnProperty.call(oe,"default")?oe.default:oe}var Nc={exports:{}},O_=Nc.exports,gm;function B_(){return gm||(gm=1,function(oe,R){(function(T,E){oe.exports=E()})(O_,function(){var T=1e3,E=6e4,Z=36e5,re="millisecond",fe="second",Ee="minute",j="hour",O="day",M="week",N="month",K="quarter",ae="year",$e="date",Te="Invalid Date",U=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,ue=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,ke={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(Ne){var Pe=["th","st","nd","rd"],Ae=Ne%100;return"["+Ne+(Pe[(Ae-20)%10]||Pe[Ae]||Pe[0])+"]"}},te=function(Ne,Pe,Ae){var ie=String(Ne);return!ie||ie.length>=Pe?Ne:""+Array(Pe+1-ie.length).join(Ae)+Ne},ee={s:te,z:function(Ne){var Pe=-Ne.utcOffset(),Ae=Math.abs(Pe),ie=Math.floor(Ae/60),F=Ae%60;return(Pe<=0?"+":"-")+te(ie,2,"0")+":"+te(F,2,"0")},m:function Ne(Pe,Ae){if(Pe.date()<Ae.date())return-Ne(Ae,Pe);var ie=12*(Ae.year()-Pe.year())+(Ae.month()-Pe.month()),F=Pe.clone().add(ie,N),se=Ae-F<0,_e=Pe.clone().add(ie+(se?-1:1),N);return+(-(ie+(Ae-F)/(se?F-_e:_e-F))||0)},a:function(Ne){return Ne<0?Math.ceil(Ne)||0:Math.floor(Ne)},p:function(Ne){return{M:N,y:ae,w:M,d:O,D:$e,h:j,m:Ee,s:fe,ms:re,Q:K}[Ne]||String(Ne||"").toLowerCase().replace(/s$/,"")},u:function(Ne){return Ne===void 0}},q="en",B={};B[q]=ke;var H="$isDayjsObject",I=function(Ne){return Ne instanceof Ve||!(!Ne||!Ne[H])},Me=function Ne(Pe,Ae,ie){var F;if(!Pe)return q;if(typeof Pe=="string"){var se=Pe.toLowerCase();B[se]&&(F=se),Ae&&(B[se]=Ae,F=se);var _e=Pe.split("-");if(!F&&_e.length>1)return Ne(_e[0])}else{var Oe=Pe.name;B[Oe]=Pe,F=Oe}return!ie&&F&&(q=F),F||!ie&&q},xe=function(Ne,Pe){if(I(Ne))return Ne.clone();var Ae=typeof Pe=="object"?Pe:{};return Ae.date=Ne,Ae.args=arguments,new Ve(Ae)},Ce=ee;Ce.l=Me,Ce.i=I,Ce.w=function(Ne,Pe){return xe(Ne,{locale:Pe.$L,utc:Pe.$u,x:Pe.$x,$offset:Pe.$offset})};var Ve=function(){function Ne(Ae){this.$L=Me(Ae.locale,null,!0),this.parse(Ae),this.$x=this.$x||Ae.x||{},this[H]=!0}var Pe=Ne.prototype;return Pe.parse=function(Ae){this.$d=function(ie){var F=ie.date,se=ie.utc;if(F===null)return new Date(NaN);if(Ce.u(F))return new Date;if(F instanceof Date)return new Date(F);if(typeof F=="string"&&!/Z$/i.test(F)){var _e=F.match(U);if(_e){var Oe=_e[2]-1||0,nt=(_e[7]||"0").substring(0,3);return se?new Date(Date.UTC(_e[1],Oe,_e[3]||1,_e[4]||0,_e[5]||0,_e[6]||0,nt)):new Date(_e[1],Oe,_e[3]||1,_e[4]||0,_e[5]||0,_e[6]||0,nt)}}return new Date(F)}(Ae),this.init()},Pe.init=function(){var Ae=this.$d;this.$y=Ae.getFullYear(),this.$M=Ae.getMonth(),this.$D=Ae.getDate(),this.$W=Ae.getDay(),this.$H=Ae.getHours(),this.$m=Ae.getMinutes(),this.$s=Ae.getSeconds(),this.$ms=Ae.getMilliseconds()},Pe.$utils=function(){return Ce},Pe.isValid=function(){return this.$d.toString()!==Te},Pe.isSame=function(Ae,ie){var F=xe(Ae);return this.startOf(ie)<=F&&F<=this.endOf(ie)},Pe.isAfter=function(Ae,ie){return xe(Ae)<this.startOf(ie)},Pe.isBefore=function(Ae,ie){return this.endOf(ie)<xe(Ae)},Pe.$g=function(Ae,ie,F){return Ce.u(Ae)?this[ie]:this.set(F,Ae)},Pe.unix=function(){return Math.floor(this.valueOf()/1e3)},Pe.valueOf=function(){return this.$d.getTime()},Pe.startOf=function(Ae,ie){var F=this,se=!!Ce.u(ie)||ie,_e=Ce.p(Ae),Oe=function(et,X){var Be=Ce.w(F.$u?Date.UTC(F.$y,X,et):new Date(F.$y,X,et),F);return se?Be:Be.endOf(O)},nt=function(et,X){return Ce.w(F.toDate()[et].apply(F.toDate("s"),(se?[0,0,0,0]:[23,59,59,999]).slice(X)),F)},de=this.$W,Re=this.$M,it=this.$D,He="set"+(this.$u?"UTC":"");switch(_e){case ae:return se?Oe(1,0):Oe(31,11);case N:return se?Oe(1,Re):Oe(0,Re+1);case M:var wt=this.$locale().weekStart||0,xt=(de<wt?de+7:de)-wt;return Oe(se?it-xt:it+(6-xt),Re);case O:case $e:return nt(He+"Hours",0);case j:return nt(He+"Minutes",1);case Ee:return nt(He+"Seconds",2);case fe:return nt(He+"Milliseconds",3);default:return this.clone()}},Pe.endOf=function(Ae){return this.startOf(Ae,!1)},Pe.$set=function(Ae,ie){var F,se=Ce.p(Ae),_e="set"+(this.$u?"UTC":""),Oe=(F={},F[O]=_e+"Date",F[$e]=_e+"Date",F[N]=_e+"Month",F[ae]=_e+"FullYear",F[j]=_e+"Hours",F[Ee]=_e+"Minutes",F[fe]=_e+"Seconds",F[re]=_e+"Milliseconds",F)[se],nt=se===O?this.$D+(ie-this.$W):ie;if(se===N||se===ae){var de=this.clone().set($e,1);de.$d[Oe](nt),de.init(),this.$d=de.set($e,Math.min(this.$D,de.daysInMonth())).$d}else Oe&&this.$d[Oe](nt);return this.init(),this},Pe.set=function(Ae,ie){return this.clone().$set(Ae,ie)},Pe.get=function(Ae){return this[Ce.p(Ae)]()},Pe.add=function(Ae,ie){var F,se=this;Ae=Number(Ae);var _e=Ce.p(ie),Oe=function(Re){var it=xe(se);return Ce.w(it.date(it.date()+Math.round(Re*Ae)),se)};if(_e===N)return this.set(N,this.$M+Ae);if(_e===ae)return this.set(ae,this.$y+Ae);if(_e===O)return Oe(1);if(_e===M)return Oe(7);var nt=(F={},F[Ee]=E,F[j]=Z,F[fe]=T,F)[_e]||1,de=this.$d.getTime()+Ae*nt;return Ce.w(de,this)},Pe.subtract=function(Ae,ie){return this.add(-1*Ae,ie)},Pe.format=function(Ae){var ie=this,F=this.$locale();if(!this.isValid())return F.invalidDate||Te;var se=Ae||"YYYY-MM-DDTHH:mm:ssZ",_e=Ce.z(this),Oe=this.$H,nt=this.$m,de=this.$M,Re=F.weekdays,it=F.months,He=F.meridiem,wt=function(X,Be,st,lt){return X&&(X[Be]||X(ie,se))||st[Be].slice(0,lt)},xt=function(X){return Ce.s(Oe%12||12,X,"0")},et=He||function(X,Be,st){var lt=X<12?"AM":"PM";return st?lt.toLowerCase():lt};return se.replace(ue,function(X,Be){return Be||function(st){switch(st){case"YY":return String(ie.$y).slice(-2);case"YYYY":return Ce.s(ie.$y,4,"0");case"M":return de+1;case"MM":return Ce.s(de+1,2,"0");case"MMM":return wt(F.monthsShort,de,it,3);case"MMMM":return wt(it,de);case"D":return ie.$D;case"DD":return Ce.s(ie.$D,2,"0");case"d":return String(ie.$W);case"dd":return wt(F.weekdaysMin,ie.$W,Re,2);case"ddd":return wt(F.weekdaysShort,ie.$W,Re,3);case"dddd":return Re[ie.$W];case"H":return String(Oe);case"HH":return Ce.s(Oe,2,"0");case"h":return xt(1);case"hh":return xt(2);case"a":return et(Oe,nt,!0);case"A":return et(Oe,nt,!1);case"m":return String(nt);case"mm":return Ce.s(nt,2,"0");case"s":return String(ie.$s);case"ss":return Ce.s(ie.$s,2,"0");case"SSS":return Ce.s(ie.$ms,3,"0");case"Z":return _e}return null}(X)||_e.replace(":","")})},Pe.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},Pe.diff=function(Ae,ie,F){var se,_e=this,Oe=Ce.p(ie),nt=xe(Ae),de=(nt.utcOffset()-this.utcOffset())*E,Re=this-nt,it=function(){return Ce.m(_e,nt)};switch(Oe){case ae:se=it()/12;break;case N:se=it();break;case K:se=it()/3;break;case M:se=(Re-de)/6048e5;break;case O:se=(Re-de)/864e5;break;case j:se=Re/Z;break;case Ee:se=Re/E;break;case fe:se=Re/T;break;default:se=Re}return F?se:Ce.a(se)},Pe.daysInMonth=function(){return this.endOf(N).$D},Pe.$locale=function(){return B[this.$L]},Pe.locale=function(Ae,ie){if(!Ae)return this.$L;var F=this.clone(),se=Me(Ae,ie,!0);return se&&(F.$L=se),F},Pe.clone=function(){return Ce.w(this.$d,this)},Pe.toDate=function(){return new Date(this.valueOf())},Pe.toJSON=function(){return this.isValid()?this.toISOString():null},Pe.toISOString=function(){return this.$d.toISOString()},Pe.toString=function(){return this.$d.toUTCString()},Ne}(),Ue=Ve.prototype;return xe.prototype=Ue,[["$ms",re],["$s",fe],["$m",Ee],["$H",j],["$W",O],["$M",N],["$y",ae],["$D",$e]].forEach(function(Ne){Ue[Ne[1]]=function(Pe){return this.$g(Pe,Ne[0],Ne[1])}}),xe.extend=function(Ne,Pe){return Ne.$i||(Ne(Pe,Ve,xe),Ne.$i=!0),xe},xe.locale=Me,xe.isDayjs=I,xe.unix=function(Ne){return xe(1e3*Ne)},xe.en=B[q],xe.Ls=B,xe.p={},xe})}(Nc)),Nc.exports}var D_=B_(),Gc=F_(D_);const z_={BASE_URL:"/NoLLMChat/",DEV:!1,MODE:"production",PROD:!0,SSR:!1,VITE_BASE_URL:"/NoLLMChat/",VITE_ROUTE_MODE:"hash"},$m=(typeof z_<"u",typeof window<"u"&&typeof window.localStorage<"u"?window.localStorage.getItem("__DEBUG__")==="true":!1),L_=$m?console.log:void 0,R_=$m?console.debug:void 0,N_=console.warn,j_=console.error,qc=console.group,Hc=console.groupEnd,U_=(oe,...R)=>{qc(Wc.blueBright(` INFO: ${oe} [${Gc().format("DD-MM-YYYY HH:mm:ss")}]`)),L_?.(...R),Hc()},V_=(oe,...R)=>{qc(Wc.redBright(` ERROR: ${oe} [${Gc().format("DD-MM-YYYY HH:mm:ss")}]`)),j_?.(...R),Hc()},W_=(oe,...R)=>{qc(Wc.yellowBright(` WARN: ${oe} [${Gc().format("DD-MM-YYYY HH:mm:ss")}]`)),N_?.(...R),Hc()},jc=(oe,...R)=>{qc(Wc.greenBright(` DEBUG: ${oe} [${Gc().format("DD-MM-YYYY HH:mm:ss")}]`)),R_?.(...R),Hc()},Md=new Map,Sm="_WORKER_INIT_";function xd(oe,R,T){if(!Md.get(oe)&&oe!==Sm){W_("[No process found for message]",oe);return}self.postMessage({messageId:oe,type:R,payload:T}),jc("[Send Worker to Main Thread]",{id:oe,type:R,payload:T})}function G_(oe){return async R=>{try{const T=await oe(R);xd(R.messageId,"complete",T)}catch(T){V_("Handle Worker Message",T,{payload:R}),xd(R.messageId,"error",{error:T instanceof Error?T.message:"An error occurred",error_code:"UNKNOWN_ERROR"})}finally{Md.delete(R.messageId)}}}function q_(oe,R){self.addEventListener("message",async T=>{Md.set(T.data.messageId,Promise.race([G_(oe)(T.data),new Promise(E=>setTimeout(()=>E(!0),12e4)).then(()=>{Md.has(T.data.messageId)&&(xd(T.data.messageId,"error",{error:"Operation timed out",error_code:"TIMEOUT_ERROR"}),Md.delete(T.data.messageId))})])),xd(T.data.messageId,"started","Started processing")})}async function H_(oe){xd(Sm,"complete","Worker initialized")}let yd;async function K_(oe){switch(jc("[Database worker received message]",oe,oe.type),oe.type){case"load":{const[R,T]=oe.payload;return jc("Loading model:",R,T),(!yd||yd.model.name!==R)&&(yd=await M_("feature-extraction",R,T)),!0}case"embedding":{if(!yd)throw new Error("Pipe is not ready yet.");jc("Embedding:",oe.payload);const[R,T]=oe.payload;return(await yd(R,T)).tolist()}default:throw new Error("Invalid operation")}}q_(K_);U_("Embedding worker initialized");H_();
//# sourceMappingURL=embedding.worker-BYcm8UQf.js.map
