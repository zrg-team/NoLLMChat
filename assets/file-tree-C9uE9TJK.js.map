{"version":3,"file":"file-tree-C9uE9TJK.js","sources":["../../src/services/web-container/utils/file-tree.ts"],"sourcesContent":["import type { DirectoryNode, FileNode, FileSystemTree } from '@webcontainer/api'\nimport { nanoid } from 'nanoid'\nimport { logDebug } from 'src/utils/logger'\n\nexport interface ElementTree {\n  id: string\n  isSelectable: boolean\n  name: string\n  file: string\n  content?: string\n  children?: ElementTree[]\n}\n\nexport function convertToElementsTree(\n  tree: FileSystemTree,\n  parentPath: string = '',\n): ElementTree[] {\n  const elements: ElementTree[] = []\n\n  for (const [name, node] of Object.entries(tree)) {\n    const id = nanoid()\n    const path = [parentPath, name].filter(Boolean).join('/')\n    const file = 'file' in node && 'contents' in node.file ? node.file : undefined\n    const element: ElementTree = {\n      id,\n      isSelectable: true,\n      content: typeof file?.contents === 'string' ? file.contents : undefined,\n      file: path,\n      name,\n      children: [],\n    }\n\n    if ('directory' in node) {\n      element.children = convertToElementsTree(node.directory, path)\n    }\n\n    elements.push(element)\n  }\n\n  return elements\n}\n\nexport function parseJSONLToFileSystemTree(jsonl: string): FileSystemTree {\n  const lines = jsonl.trim().split('\\n')\n  const root: FileSystemTree = {}\n\n  lines.forEach((line) => {\n    const { file, content } = JSON.parse(line)\n    const parts = file.split('/')\n    let currentNode: FileSystemTree = root\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n\n      if (i === parts.length - 1) {\n        // Last part is a file\n        currentNode[part] = {\n          file: {\n            contents: content,\n          },\n        }\n      } else {\n        // Intermediate parts are directories\n        if (!currentNode[part]) {\n          currentNode[part] = {\n            directory: {},\n          }\n        }\n        currentNode = (currentNode[part] as DirectoryNode).directory\n      }\n    }\n  })\n\n  return root\n}\n\nexport function parseFileSystemTreeToJSONL(tree: FileSystemTree): string {\n  const lines: string[] = []\n\n  function traverse(node: FileSystemTree, path: string[] = []) {\n    for (const [name, value] of Object.entries(node)) {\n      if ('file' in value) {\n        // It's a file node\n        const filePath = [...path, name].join('/')\n        if ('contents' in value.file) {\n          const content = value.file.contents\n          lines.push(JSON.stringify({ file: filePath, content }))\n        }\n      } else if ('directory' in value) {\n        // It's a directory node\n        traverse(value.directory, [...path, name])\n      }\n    }\n  }\n\n  traverse(tree)\n  return lines.join('\\n')\n}\n\nexport type FileSystemTreeChange = {\n  path: string\n  content: string | Uint8Array\n  type?: 'create_or_update' | 'delete'\n}\n\nexport function updateFileSystemTree(\n  tree: FileSystemTree,\n  changes: FileSystemTreeChange[],\n): FileSystemTree {\n  logDebug(\n    `[UpdateCodeContainerFile] Changes ${changes.map((c) => `${c.type || 'create_or_update'}:${c.path}`).join(', ')}`,\n  )\n  changes.forEach(({ path, content, type = 'create_or_update' }) => {\n    // if path starts with './', remove it\n    const parts = path.replace(/^\\.\\//, '').split('/')\n    let currentNode: FileSystemTree | FileNode = tree\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n\n      if (i === parts.length - 1) {\n        // Last part should be the file\n        if (type === 'delete') {\n          if (part in currentNode && 'file' in currentNode[part]) {\n            delete currentNode[part]\n          } else {\n            console.warn(`Path \"${path}\" is not a file or does not exist.`)\n          }\n        } else {\n          // Default type is 'create_or_update'\n          if (part in currentNode && 'file' in currentNode[part]) {\n            ;(currentNode[part] as FileNode).file.contents = content\n          } else {\n            // Create new file node if it doesn't exist\n            ;(currentNode as FileSystemTree)[part] = {\n              file: {\n                contents: content,\n              },\n            } as FileNode\n          }\n        }\n      } else {\n        if (part in currentNode && 'directory' in currentNode[part]) {\n          currentNode = (currentNode[part] as DirectoryNode).directory\n        } else {\n          if (type === 'delete') {\n            console.warn(`Path \"${path}\" does not exist.`)\n            break // Exit the loop for this change, but continue with others\n          } else {\n            // Create new directory node if it doesn't exist\n            ;(currentNode as FileSystemTree)[part] = {\n              directory: {},\n            } as DirectoryNode\n            currentNode = (currentNode[part] as DirectoryNode).directory\n          }\n        }\n      }\n    }\n  })\n\n  return tree\n}\n"],"names":["parseJSONLToFileSystemTree","jsonl","lines","root","line","file","content","parts","currentNode","i","part","parseFileSystemTreeToJSONL","tree","traverse","node","path","name","value","filePath","updateFileSystemTree","changes","logDebug","c","type"],"mappings":"qYA0CO,SAASA,EAA2BC,EAA+B,CACxE,MAAMC,EAAQD,EAAM,KAAA,EAAO,MAAM;AAAA,CAAI,EAC/BE,EAAuB,CAAA,EAE7B,OAAAD,EAAM,QAASE,GAAS,CACtB,KAAM,CAAE,KAAAC,EAAM,QAAAC,CAAA,EAAY,KAAK,MAAMF,CAAI,EACnCG,EAAQF,EAAK,MAAM,GAAG,EAC5B,IAAIG,EAA8BL,EAElC,QAASM,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAAK,CACrC,MAAMC,EAAOH,EAAME,CAAC,EAEhBA,IAAMF,EAAM,OAAS,EAEvBC,EAAYE,CAAI,EAAI,CAClB,KAAM,CACJ,SAAUJ,CAAA,CACZ,GAIGE,EAAYE,CAAI,IACnBF,EAAYE,CAAI,EAAI,CAClB,UAAW,CAAA,CAAC,GAGhBF,EAAeA,EAAYE,CAAI,EAAoB,UAEvD,CACF,CAAC,EAEMP,CACT,CAEO,SAASQ,EAA2BC,EAA8B,CACvE,MAAMV,EAAkB,CAAA,EAExB,SAASW,EAASC,EAAsBC,EAAiB,GAAI,CAC3D,SAAW,CAACC,EAAMC,CAAK,IAAK,OAAO,QAAQH,CAAI,EAC7C,GAAI,SAAUG,EAAO,CAEnB,MAAMC,EAAW,CAAC,GAAGH,EAAMC,CAAI,EAAE,KAAK,GAAG,EACzC,GAAI,aAAcC,EAAM,KAAM,CAC5B,MAAMX,EAAUW,EAAM,KAAK,SAC3Bf,EAAM,KAAK,KAAK,UAAU,CAAE,KAAMgB,EAAU,QAAAZ,CAAA,CAAS,CAAC,CACxD,CACF,KAAW,cAAeW,GAExBJ,EAASI,EAAM,UAAW,CAAC,GAAGF,EAAMC,CAAI,CAAC,CAG/C,CAEA,OAAAH,EAASD,CAAI,EACNV,EAAM,KAAK;AAAA,CAAI,CACxB,CAQO,SAASiB,EACdP,EACAQ,EACgB,CAChB,OAAAC,EACE,qCAAqCD,EAAQ,IAAKE,GAAM,GAAGA,EAAE,MAAQ,kBAAkB,IAAIA,EAAE,IAAI,EAAE,EAAE,KAAK,IAAI,CAAC,EAAA,EAEjHF,EAAQ,QAAQ,CAAC,CAAE,KAAAL,EAAM,QAAAT,EAAS,KAAAiB,EAAO,sBAAyB,CAEhE,MAAMhB,EAAQQ,EAAK,QAAQ,QAAS,EAAE,EAAE,MAAM,GAAG,EACjD,IAAIP,EAAyCI,EAE7C,QAAS,EAAI,EAAG,EAAIL,EAAM,OAAQ,IAAK,CACrC,MAAMG,EAAOH,EAAM,CAAC,EAEpB,GAAI,IAAMA,EAAM,OAAS,EAEnBgB,IAAS,SACPb,KAAQF,GAAe,SAAUA,EAAYE,CAAI,EACnD,OAAOF,EAAYE,CAAI,EAEvB,QAAQ,KAAK,SAASK,CAAI,oCAAoC,EAI5DL,KAAQF,GAAe,SAAUA,EAAYE,CAAI,EACjDF,EAAYE,CAAI,EAAe,KAAK,SAAWJ,EAG/CE,EAA+BE,CAAI,EAAI,CACvC,KAAM,CACJ,SAAUJ,CAAA,CACZ,UAKFI,KAAQF,GAAe,cAAeA,EAAYE,CAAI,EACxDF,EAAeA,EAAYE,CAAI,EAAoB,kBAE/Ca,IAAS,SAAU,CACrB,QAAQ,KAAK,SAASR,CAAI,mBAAmB,EAC7C,KACF,MAEIP,EAA+BE,CAAI,EAAI,CACvC,UAAW,CAAA,CAAC,EAEdF,EAAeA,EAAYE,CAAI,EAAoB,SAI3D,CACF,CAAC,EAEME,CACT"}