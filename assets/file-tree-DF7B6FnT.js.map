{"version":3,"file":"file-tree-DF7B6FnT.js","sources":["../../src/services/web-container/utils/file-tree.ts"],"sourcesContent":["import type { DirectoryNode, FileNode, FileSystemTree } from '@webcontainer/api'\nimport { nanoid } from 'nanoid'\nimport { logDebug } from 'src/utils/logger'\n\nexport interface ElementTree {\n  id: string\n  isSelectable: boolean\n  name: string\n  file: string\n  content?: string\n  children?: ElementTree[]\n}\n\nexport function convertToElementsTree(\n  tree: FileSystemTree,\n  parentPath: string = '',\n): ElementTree[] {\n  const elements: ElementTree[] = []\n\n  for (const [name, node] of Object.entries(tree)) {\n    const id = nanoid()\n    const path = [parentPath, name].filter(Boolean).join('/')\n    const file = 'file' in node && 'contents' in node.file ? node.file : undefined\n    const element: ElementTree = {\n      id,\n      isSelectable: true,\n      content: typeof file?.contents === 'string' ? file.contents : undefined,\n      file: path,\n      name,\n      children: [],\n    }\n\n    if ('directory' in node) {\n      element.children = convertToElementsTree(node.directory, path)\n    }\n\n    elements.push(element)\n  }\n\n  return elements\n}\n\nexport function parseJSONLToFileSystemTree(jsonl: string): FileSystemTree {\n  const lines = jsonl.trim().split('\\n')\n  const root: FileSystemTree = {}\n\n  lines.forEach((line) => {\n    const { file, content } = JSON.parse(line)\n    const parts = file.split('/')\n    let currentNode: FileSystemTree = root\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n\n      if (i === parts.length - 1) {\n        // Last part is a file\n        currentNode[part] = {\n          file: {\n            contents: content,\n          },\n        }\n      } else {\n        // Intermediate parts are directories\n        if (!currentNode[part]) {\n          currentNode[part] = {\n            directory: {},\n          }\n        }\n        currentNode = (currentNode[part] as DirectoryNode).directory\n      }\n    }\n  })\n\n  return root\n}\n\nexport function parseFileSystemTreeToJSONL(tree: FileSystemTree): string {\n  const lines: string[] = []\n\n  function traverse(node: FileSystemTree, path: string[] = []) {\n    for (const [name, value] of Object.entries(node)) {\n      if ('file' in value) {\n        // It's a file node\n        const filePath = [...path, name].join('/')\n        if ('contents' in value.file) {\n          const content = value.file.contents\n          lines.push(JSON.stringify({ file: filePath, content }))\n        }\n      } else if ('directory' in value) {\n        // It's a directory node\n        traverse(value.directory, [...path, name])\n      }\n    }\n  }\n\n  traverse(tree)\n  return lines.join('\\n')\n}\n\nexport type FileSystemTreeChange = {\n  path: string\n  content: string | Uint8Array\n  type?: 'create_or_update' | 'delete'\n}\n\nexport function updateFileSystemTree(\n  tree: FileSystemTree,\n  changes: FileSystemTreeChange[],\n): FileSystemTree {\n  logDebug(\n    `[UpdateCodeContainerFile] Changes ${changes.map((c) => `${c.type || 'create_or_update'}:${c.path}`).join(', ')}`,\n  )\n  changes.forEach(({ path, content, type = 'create_or_update' }) => {\n    // if path starts with './', remove it\n    const parts = path.replace(/^\\.\\//, '').split('/')\n    let currentNode: FileSystemTree | FileNode = tree\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n\n      if (i === parts.length - 1) {\n        // Last part should be the file\n        if (type === 'delete') {\n          if (part in currentNode && 'file' in currentNode[part]) {\n            delete currentNode[part]\n          } else {\n            console.warn(`Path \"${path}\" is not a file or does not exist.`)\n          }\n        } else {\n          // Default type is 'create_or_update'\n          if (part in currentNode && 'file' in currentNode[part]) {\n            ;(currentNode[part] as FileNode).file.contents = content\n          } else {\n            // Create new file node if it doesn't exist\n            ;(currentNode as FileSystemTree)[part] = {\n              file: {\n                contents: content,\n              },\n            } as FileNode\n          }\n        }\n      } else {\n        if (part in currentNode && 'directory' in currentNode[part]) {\n          currentNode = (currentNode[part] as DirectoryNode).directory\n        } else {\n          if (type === 'delete') {\n            console.warn(`Path \"${path}\" does not exist.`)\n            break // Exit the loop for this change, but continue with others\n          } else {\n            // Create new directory node if it doesn't exist\n            ;(currentNode as FileSystemTree)[part] = {\n              directory: {},\n            } as DirectoryNode\n            currentNode = (currentNode[part] as DirectoryNode).directory\n          }\n        }\n      }\n    }\n  })\n\n  return tree\n}\n"],"names":["convertToElementsTree","tree","parentPath","elements","name","node","id","nanoid","path","file","element","parseJSONLToFileSystemTree","jsonl","lines","root","line","content","parts","currentNode","i","part","parseFileSystemTreeToJSONL","traverse","value","filePath","updateFileSystemTree","changes","logDebug","c","type"],"mappings":"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"}