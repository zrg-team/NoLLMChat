const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/a-arrow-down-CNgTFKiX.js","assets/createLucideIcon-DZXM6zSt.js","assets/a-arrow-up-B9wQ0n5y.js","assets/a-large-small-DpE3uMLX.js","assets/accessibility-BTnojjqo.js","assets/activity-BV5dJOSn.js","assets/air-vent-C3OeElxE.js","assets/airplay-MA6h-mv3.js","assets/alarm-clock-check-Bi7lI1D6.js","assets/alarm-clock-minus-BA893cAT.js","assets/alarm-clock-off-B8Ovf6Wj.js","assets/alarm-clock-plus-B7fIEiK2.js","assets/alarm-clock-D2QfusPH.js","assets/alarm-smoke-BYMc0iqM.js","assets/album-DyEsDi0I.js","assets/align-center-horizontal-DJpnp8xS.js","assets/align-center-vertical-2D_xmb3-.js","assets/align-center-DxV665v9.js","assets/align-end-horizontal-B9otDtbj.js","assets/align-end-vertical-B59f6FdD.js","assets/align-horizontal-distribute-center-D75mlCsq.js","assets/align-horizontal-distribute-end-C-IiQVg5.js","assets/align-horizontal-distribute-start-DguOdxAh.js","assets/align-horizontal-justify-center-0PimLbwH.js","assets/align-horizontal-justify-end-NCrF7X5b.js","assets/align-horizontal-justify-start-iElZuQ3I.js","assets/align-horizontal-space-around-D6HtsJnu.js","assets/align-horizontal-space-between-BjiR_3i2.js","assets/align-justify-4pvDMUCh.js","assets/align-left-Cqzr8iGo.js","assets/align-right-1KImZF6n.js","assets/align-start-horizontal-BA_2L9Fu.js","assets/align-start-vertical-CiBHjYBk.js","assets/align-vertical-distribute-center-CYrYJdDL.js","assets/align-vertical-distribute-end-C2fuEiYb.js","assets/align-vertical-distribute-start-mBapIGxY.js","assets/align-vertical-justify-center-DeKXBHHZ.js","assets/align-vertical-justify-end-CkgLpEFM.js","assets/align-vertical-justify-start-BEE-h20u.js","assets/align-vertical-space-around-Cdn9z6YT.js","assets/align-vertical-space-between-1JopZKn6.js","assets/ambulance-DA26gD6Q.js","assets/ampersand-DkdtRtHb.js","assets/ampersands-Z0JkED6b.js","assets/amphora-CQ7Mbpz7.js","assets/anchor-CZKyLhSd.js","assets/angry-C0i7P0_7.js","assets/annoyed-C6euMJ7n.js","assets/antenna-mTjXFUAh.js","assets/anvil-DBREkQn0.js","assets/aperture-DL1SAQKG.js","assets/app-window-mac-C8vU1k03.js","assets/app-window-BhQRaU_L.js","assets/apple-Dy-ujZyW.js","assets/archive-restore-C0zvuQuh.js","assets/archive-x-DQ3qt71s.js","assets/archive-DD3cO-ED.js","assets/armchair-DLPm7n7K.js","assets/arrow-big-down-dash-D2604AgH.js","assets/arrow-big-down-TsHZQBLv.js","assets/arrow-big-left-dash-CEZ_1a-T.js","assets/arrow-big-left-BRZ4iTqA.js","assets/arrow-big-right-dash-CbP6UW9b.js","assets/arrow-big-right-Cjlsn9kY.js","assets/arrow-big-up-dash-DddDY_ia.js","assets/arrow-big-up-BKq5KqZa.js","assets/arrow-down-0-1-BihVD2pC.js","assets/arrow-down-1-0-WgTiZYXI.js","assets/arrow-down-a-z-YcLnJAQD.js","assets/arrow-down-from-line-CBRB6ENT.js","assets/arrow-down-left-CWCjk_Is.js","assets/arrow-down-narrow-wide-elowrhZ9.js","assets/arrow-down-right-CNGB1kiu.js","assets/arrow-down-to-dot-BeQ4HObF.js","assets/arrow-down-to-line-DgeYuGZs.js","assets/arrow-down-up-BGNOUW_e.js","assets/arrow-down-wide-narrow-LRJvG0g8.js","assets/arrow-down-z-a-CpfCvc1m.js","assets/arrow-down-DFxVDlwy.js","assets/arrow-left-from-line-DJRIk_AK.js","assets/arrow-left-right-BrxXkcXK.js","assets/arrow-left-to-line-DZrtFKNw.js","assets/arrow-left-DLeWS8Mb.js","assets/arrow-right-from-line-CjwKsOVk.js","assets/arrow-right-left-BQP6JFyz.js","assets/arrow-right-to-line-Dk8uewpk.js","assets/arrow-right-CIkThkMt.js","assets/arrow-up-0-1-DL-9Bije.js","assets/arrow-up-1-0-pTpHHl1N.js","assets/arrow-up-a-z-DNMYkfgn.js","assets/arrow-up-down-DcqsP6NQ.js","assets/arrow-up-from-dot-bjqq3Cwq.js","assets/arrow-up-from-line-KMGVj1eM.js","assets/arrow-up-left-LGmeazzA.js","assets/arrow-up-narrow-wide-Ctxu26v8.js","assets/arrow-up-right-Dpw8RRdp.js","assets/arrow-up-to-line-D6BbUIFG.js","assets/arrow-up-wide-narrow-Bit2ffto.js","assets/arrow-up-z-a-DXZ2MUzZ.js","assets/arrow-up-D1U8y_Tl.js","assets/arrows-up-from-line-ULCd1pNm.js","assets/asterisk-BlmzvwMw.js","assets/at-sign-4V4ivrJA.js","assets/atom-Bj0BKS8N.js","assets/audio-lines-BsvzexBK.js","assets/audio-waveform-BJsZ3B2r.js","assets/award-BoKcpalN.js","assets/axe-B_SQj5op.js","assets/axis-3d-CxykbP2x.js","assets/baby-DEZOlzPs.js","assets/backpack-3rwM3fwE.js","assets/badge-alert-BcfUpkIy.js","assets/badge-cent-BuGODZYc.js","assets/badge-check-CfuuyCBE.js","assets/badge-dollar-sign-CvzR4o1F.js","assets/badge-euro-Cky69N-t.js","assets/badge-help-C2tWL6Tx.js","assets/badge-indian-rupee-FcLp71lG.js","assets/badge-info-DZxfp_KF.js","assets/badge-japanese-yen-B1tW21Me.js","assets/badge-minus-BVhxm7m7.js","assets/badge-percent-C9m8KyvJ.js","assets/badge-plus-yugNfxm4.js","assets/badge-pound-sterling-CXHhelo_.js","assets/badge-russian-ruble-DTR2Y1m4.js","assets/badge-swiss-franc-Bq43hpml.js","assets/badge-x-CQRpD5V9.js","assets/badge-Dmz7ZAjw.js","assets/baggage-claim-y2NtKY_7.js","assets/ban-D-xNyWx4.js","assets/banana-RCegBd1Y.js","assets/bandage-DBJPJ8fq.js","assets/banknote-DyZECi_p.js","assets/barcode-DWNqC0La.js","assets/baseline-qmQD8jHC.js","assets/bath-BWSFd-Qa.js","assets/battery-charging-VJeaEvFV.js","assets/battery-full-D-CIQ6M6.js","assets/battery-low-DDIjF3AJ.js","assets/battery-medium-BL2CQWq0.js","assets/battery-warning-Dqw5-0jg.js","assets/battery-B5KZOXt_.js","assets/beaker-CE6tGKp8.js","assets/bean-off-Bkvxoul5.js","assets/bean-CeWxl3NJ.js","assets/bed-double-ZEqgfqiZ.js","assets/bed-single-DfDBO4Gu.js","assets/bed-CibShMzY.js","assets/beef-BIfWEQbY.js","assets/beer-off-CSMSNoI8.js","assets/beer-vq2b1q8p.js","assets/bell-dot-DtPrHq9Z.js","assets/bell-electric-BPwUP_--.js","assets/bell-minus-BWePvRho.js","assets/bell-off-BYLs5wFg.js","assets/bell-plus-Bd8JJos_.js","assets/bell-ring-BtiPCCH_.js","assets/bell-DI45p5tm.js","assets/between-horizontal-end-ChnJUp7d.js","assets/between-horizontal-start-Bsh4DQFm.js","assets/between-vertical-end-Vp_2HsW8.js","assets/between-vertical-start-Dmf91WuT.js","assets/biceps-flexed-D0oT7V2L.js","assets/bike-B0ULIHvG.js","assets/binary-F8m93qvh.js","assets/binoculars-Bejd4-29.js","assets/biohazard-BGeR5Mf0.js","assets/bird-C3G1fusS.js","assets/bitcoin-DlrSbdIw.js","assets/blend-DV42QTku.js","assets/blinds-Utpn-bT-.js","assets/blocks-BRezn43_.js","assets/bluetooth-connected-Bfjam4tx.js","assets/bluetooth-off-BV6nQhL6.js","assets/bluetooth-searching-BXvFFLQ1.js","assets/bluetooth-CAluXsSq.js","assets/bold-FnAWDcX0.js","assets/bolt-CdPzDJ5b.js","assets/bomb-B9w7pbH8.js","assets/bone-7AQ4GnhW.js","assets/book-a-8z1upIeF.js","assets/book-audio-Cad0hetH.js","assets/book-check-Dq-LlNJn.js","assets/book-copy-Ds1aGlg7.js","assets/book-dashed-DHwoltPA.js","assets/book-down-B0MAOnit.js","assets/book-headphones-Bw3bUiVe.js","assets/book-heart-BAA4yG2a.js","assets/book-image-BA78VVCu.js","assets/book-key-BbBcM2Rz.js","assets/book-lock-BqMTGTxi.js","assets/book-marked-kTMOppyN.js","assets/book-minus-C1iEdc6u.js","assets/book-open-check-BzqTO65n.js","assets/book-open-text-Ctp_ymdr.js","assets/book-open-exPuCE-B.js","assets/book-plus-BaJj6Q8C.js","assets/book-text-C6b4Lz6I.js","assets/book-type-CY_90Tc6.js","assets/book-up-2-BjYhUBt6.js","assets/book-up-dINznO0P.js","assets/book-user-Dl_rQLIA.js","assets/book-x-C9Q8z1l4.js","assets/book-DaA8Gwwp.js","assets/bookmark-check-Dq-JPpNK.js","assets/bookmark-minus-CTTlpTLN.js","assets/bookmark-plus-2QEyp_Ru.js","assets/bookmark-x-mCUSLQzg.js","assets/bookmark-Do-4AbzQ.js","assets/boom-box-xtx1YFxh.js","assets/bot-message-square-BxtYpfq0.js","assets/bot-off-C1tqkT3z.js","assets/bot-dn3ByO8f.js","assets/box-DD7nA-Fb.js","assets/boxes-UTBkxpqD.js","assets/braces-B6Rz8iBP.js","assets/brackets-snZdZLEi.js","assets/brain-circuit-CxqnWimR.js","assets/brain-cog-BDRE6Qyd.js","assets/brain-D_zwc5uP.js","assets/brick-wall-DOVgBje0.js","assets/briefcase-business-Dp4uwtwN.js","assets/briefcase-conveyor-belt-DH7uZLyk.js","assets/briefcase-medical-DEdebRen.js","assets/briefcase-DdK5_k-B.js","assets/bring-to-front-DGHzytgz.js","assets/brush-QdE_5cqO.js","assets/bug-off-CNS65E6j.js","assets/bug-play-Czf5TG-P.js","assets/bug-CZ04fsbS.js","assets/building-2-D5UiovxX.js","assets/building-a8RUYBD0.js","assets/bus-front-CwKNEH4e.js","assets/bus-CAawFz-r.js","assets/cable-car-BsW5NeUM.js","assets/cable-Bh7-5O2W.js","assets/cake-slice-CYXisVP-.js","assets/cake-B3hU4_6z.js","assets/calculator-BJqCaAda.js","assets/calendar-1-BHZAxDLw.js","assets/calendar-arrow-down-HRmUVz_7.js","assets/calendar-arrow-up-BkWwQokX.js","assets/calendar-check-2-Dmogfini.js","assets/calendar-check-O8XG7PB1.js","assets/calendar-clock-CVdpziL9.js","assets/calendar-cog-QF7-2jbl.js","assets/calendar-days-D8KoiZSC.js","assets/calendar-fold-DTRAHpID.js","assets/calendar-heart-D0cLBSOM.js","assets/calendar-minus-2-wWtVKytY.js","assets/calendar-minus-CsUOTuXs.js","assets/calendar-off-BRks4HI1.js","assets/calendar-plus-2-Cvyjw0-k.js","assets/calendar-plus-CJVfKZqg.js","assets/calendar-range-B36JW6yG.js","assets/calendar-search-BZqBBS8_.js","assets/calendar-sync-Ci0_otk7.js","assets/calendar-x-2-DLNRWKv4.js","assets/calendar-x-t7FgZ6So.js","assets/calendar-BWv0HE5b.js","assets/camera-off-hfH0lhs7.js","assets/camera-DMa_dwkr.js","assets/candy-cane-DQEoG8EI.js","assets/candy-off-DaR3wMkf.js","assets/candy-D6P5HLzq.js","assets/cannabis-C-lhRUSR.js","assets/captions-off-CYhJiY-P.js","assets/captions-D4UOIQAi.js","assets/car-front-CFncvNJI.js","assets/car-taxi-front-Bqm8F-hW.js","assets/car--LuoYZni.js","assets/caravan-BXCX22i4.js","assets/carrot-DXNZ1Yuf.js","assets/case-lower-1xbuIgIF.js","assets/case-sensitive-OgcSuAHc.js","assets/case-upper-TkVUcIEI.js","assets/cassette-tape-Df-EoJq5.js","assets/cast-DTKl0MC_.js","assets/castle-CzIwmuJy.js","assets/cat-CpRWYaw-.js","assets/cctv-Aw5cimi-.js","assets/chart-area-D8qPS1x8.js","assets/chart-bar-big-EbyrrK0E.js","assets/chart-bar-decreasing-PZHG7-gp.js","assets/chart-bar-increasing-CoaASwK0.js","assets/chart-bar-stacked-BAmkK5hX.js","assets/chart-bar-Dpjih5lp.js","assets/chart-candlestick-Cz02SZWS.js","assets/chart-column-big-DtPvDuul.js","assets/chart-column-decreasing-CkAmV0Y0.js","assets/chart-column-increasing-CchC2HgR.js","assets/chart-column-stacked-CdXl7fqV.js","assets/chart-column-CNVUaQK8.js","assets/chart-gantt-BwZ8T9fL.js","assets/chart-line-IQ9bIChM.js","assets/chart-network-CNuTC2qC.js","assets/chart-no-axes-column-decreasing-CvjZt9vS.js","assets/chart-no-axes-column-increasing-CoV_pko3.js","assets/chart-no-axes-column-DqM0IITS.js","assets/chart-no-axes-combined-CGWPMdIe.js","assets/chart-no-axes-gantt-CUcxUqe1.js","assets/chart-pie-CbebJP6G.js","assets/chart-scatter-BifbikuY.js","assets/chart-spline-Bq_xDId3.js","assets/check-check-6VWZjV6r.js","assets/check-CPckYtjn.js","assets/chef-hat-DONYNtc3.js","assets/cherry-CIzMzjAf.js","assets/chevron-down-C2fRMLBZ.js","assets/chevron-first-BcGyV6tV.js","assets/chevron-last-C0Krzyoe.js","assets/chevron-left-BNfsxm0Y.js","assets/chevron-right-CwUZymH_.js","assets/chevron-up-RPiEHaJX.js","assets/chevrons-down-up-BGNr779D.js","assets/chevrons-down-d9ri72d9.js","assets/chevrons-left-right-ellipsis-CKgw5gba.js","assets/chevrons-left-right-DAgwACXJ.js","assets/chevrons-left-CBjCvM5j.js","assets/chevrons-right-left-Cl8xjMHl.js","assets/chevrons-right-DF1Arxz_.js","assets/chevrons-up-down-Ot1-6qFg.js","assets/chevrons-up-DBsGVBaR.js","assets/chrome-CSJf2Ix5.js","assets/church-DuOPvZwI.js","assets/cigarette-off-BFnBdYef.js","assets/cigarette-DkJ-309E.js","assets/circle-alert-b0mAlR-t.js","assets/circle-arrow-down-CPrRJslw.js","assets/circle-arrow-left-DSlmo6km.js","assets/circle-arrow-out-down-left-DC_7eRC5.js","assets/circle-arrow-out-down-right-BccoPRKj.js","assets/circle-arrow-out-up-left-Bi9zehYX.js","assets/circle-arrow-out-up-right-BIy4wm6D.js","assets/circle-arrow-right-Cn-yXKXq.js","assets/circle-arrow-up-C6Qp3f37.js","assets/circle-check-big-CTKrCgJH.js","assets/circle-check-CJCb06ho.js","assets/circle-chevron-down-CjL6vH1m.js","assets/circle-chevron-left-D9CSzwa1.js","assets/circle-chevron-right-fHwaQO4p.js","assets/circle-chevron-up-BU2Og7x6.js","assets/circle-dashed-C4Ab2Fbk.js","assets/circle-divide-D9qejqwt.js","assets/circle-dollar-sign-DxganEpg.js","assets/circle-dot-dashed-BA-_5KIT.js","assets/circle-dot-4P8oD9wS.js","assets/circle-ellipsis-Bn6NX4-S.js","assets/circle-equal-CdNcPDrF.js","assets/circle-fading-arrow-up-B1PlP5Dw.js","assets/circle-fading-plus-BY3l23Pc.js","assets/circle-gauge-Bm9yogCI.js","assets/circle-help-D_aIlF8k.js","assets/circle-minus-8KAADzGn.js","assets/circle-off-BdTsy2B_.js","assets/circle-parking-off-U15oeXe4.js","assets/circle-parking-C9D4P0bO.js","assets/circle-pause-DSZdDIN8.js","assets/circle-percent-CE2epsJj.js","assets/circle-play-C4z7vtxq.js","assets/circle-plus-BPoY3o2h.js","assets/circle-power-DjnCjAdX.js","assets/circle-slash-2-BoxurmkJ.js","assets/circle-slash-B1Yo0nYY.js","assets/circle-stop-DLZLqldk.js","assets/circle-user-round-DT2N1vPY.js","assets/circle-user-DPFij0A2.js","assets/circle-x-B-I8uv7m.js","assets/circle-DvxVmImz.js","assets/circuit-board-9qZfVJ8e.js","assets/citrus-CVZ4eS0n.js","assets/clapperboard-BQBJ6IfV.js","assets/clipboard-check-C-FQue5C.js","assets/clipboard-copy-DCR1NQhJ.js","assets/clipboard-list-Bs_qQXbA.js","assets/clipboard-minus-kocRP6Nt.js","assets/clipboard-paste-co0vpJ9s.js","assets/clipboard-pen-line-BhzikuEt.js","assets/clipboard-pen-CdpgEUOy.js","assets/clipboard-plus-DtXkvhyH.js","assets/clipboard-type-BzPaKUfn.js","assets/clipboard-x-CwO_DQQJ.js","assets/clipboard-CHNM15QN.js","assets/clock-1-CVPOZmwx.js","assets/clock-10-DuiKOJr6.js","assets/clock-11-BSAM5KpW.js","assets/clock-12-CNCrGVms.js","assets/clock-2-DaQeXY6H.js","assets/clock-3-bFAH1nr1.js","assets/clock-4-DsFuAqMB.js","assets/clock-5-8dFuQmor.js","assets/clock-6-DFf85dsx.js","assets/clock-7-CH18bWH6.js","assets/clock-8-wwMWqk10.js","assets/clock-9-BtiAslNv.js","assets/clock-alert-z5rPU87V.js","assets/clock-arrow-down-GgrCVDaG.js","assets/clock-arrow-up-BBVsOhNW.js","assets/clock-_3ygTBWJ.js","assets/cloud-alert-DNyjV0ki.js","assets/cloud-cog-DrDex3Vw.js","assets/cloud-download-CDVo9ZxQ.js","assets/cloud-drizzle-DshlseGs.js","assets/cloud-fog-B-49gfwL.js","assets/cloud-hail-2_KmvWAG.js","assets/cloud-lightning-CnDz1mY0.js","assets/cloud-moon-rain-BbS5FPWL.js","assets/cloud-moon-BzOmy06X.js","assets/cloud-off-DoHien0c.js","assets/cloud-rain-wind-BKSSDZXS.js","assets/cloud-rain-6GiFcjEk.js","assets/cloud-snow-DZZgr0v1.js","assets/cloud-sun-rain-DIaF8dzO.js","assets/cloud-sun-B0dePQlH.js","assets/cloud-upload-Cumo_iRR.js","assets/cloud-tKmdkj2z.js","assets/cloudy-au2bvBXD.js","assets/clover-SII4acey.js","assets/club-hHRo-182.js","assets/code-xml-Bnweu91j.js","assets/code-DBSjMocy.js","assets/codepen-Bdu6WKGs.js","assets/codesandbox-DTR2kC42.js","assets/coffee-CL2F77fr.js","assets/cog-AmR-J1JP.js","assets/coins-B86gEVs3.js","assets/columns-2-Sjl9Dt9z.js","assets/columns-3-CAXm5b1i.js","assets/columns-4-Re2uofFz.js","assets/combine-DNBKGv7K.js","assets/command-BxtJdNGV.js","assets/compass-BUtgqjrT.js","assets/component-BSdIVhkg.js","assets/computer-DxzHOa3-.js","assets/concierge-bell-ChjcXyrk.js","assets/cone-CwKNDygv.js","assets/construction-BA2IrPEV.js","assets/contact-round-VOiL36nM.js","assets/contact-Dzat8syf.js","assets/container-VZlHej8r.js","assets/contrast-c4wDClX0.js","assets/cookie-DTjfrSZ1.js","assets/cooking-pot-DBdeBUQS.js","assets/copy-check-8FRSgrzQ.js","assets/copy-minus-Ch_CgxeX.js","assets/copy-plus-CA_G-2Ny.js","assets/copy-slash-DpEicipx.js","assets/copy-x-DPeF6_yU.js","assets/copy-ALodIprG.js","assets/copyleft-ByPmNnCq.js","assets/copyright-Gsz3a-OB.js","assets/corner-down-left-DG5L0yOQ.js","assets/corner-down-right-H4Jiff4L.js","assets/corner-left-down-Cr091f01.js","assets/corner-left-up-XRINktEE.js","assets/corner-right-down-DSRQPYkT.js","assets/corner-right-up-WUTl4hxN.js","assets/corner-up-left-DrueFrBR.js","assets/corner-up-right-27NXpavZ.js","assets/cpu-Br1Fz7L6.js","assets/creative-commons-BVy_loTN.js","assets/credit-card-OOWKVQux.js","assets/croissant-BlDVGEky.js","assets/crop-CAKe7iNq.js","assets/cross-CIZ6svUC.js","assets/crosshair-D17BQ_bu.js","assets/crown-22QFwKj9.js","assets/cuboid-DOWVnwLZ.js","assets/cup-soda-iQOVEyMz.js","assets/currency-3rgN8-wI.js","assets/cylinder-BRo-RYzy.js","assets/dam-CyTj6ylN.js","assets/database-backup-D5ZjDfy3.js","assets/database-zap-L4VA1lYL.js","assets/database-C0xVpXri.js","assets/delete-Cm0BJsA1.js","assets/dessert-DehgdjJo.js","assets/diameter-BgvRPTgJ.js","assets/diamond-minus-BUOILXuB.js","assets/diamond-percent-CzbWfju_.js","assets/diamond-plus-C53V5483.js","assets/diamond-DgZPsO--.js","assets/dice-1-DCGONojd.js","assets/dice-2-DzjFfZxr.js","assets/dice-3-Cslb52pU.js","assets/dice-4-BFk6zNPV.js","assets/dice-5-NRGQ2V8h.js","assets/dice-6-2mgfo5Qk.js","assets/dices-COiGX6dd.js","assets/diff-BawOTqHr.js","assets/disc-2-DbmansM9.js","assets/disc-3-ClqhPTwL.js","assets/disc-album-CfWkOC2U.js","assets/disc-BpNQIa5m.js","assets/divide-CdwMN9XU.js","assets/dna-off-D8yrN4rj.js","assets/dna-p2ScuGXe.js","assets/dock--V3m7mBx.js","assets/dog-BbvufOBz.js","assets/dollar-sign-DEkbCkKt.js","assets/donut-Du9z4tkM.js","assets/door-closed-_oNJrMLb.js","assets/door-open-xYgoCiIV.js","assets/dot-BaevGMZ5.js","assets/download-C1yPNiwc.js","assets/drafting-compass-BIRIUOGu.js","assets/drama-BwE-vxXe.js","assets/dribbble-DI0Y0-6r.js","assets/drill-D4qMzmUc.js","assets/droplet-ClydckDo.js","assets/droplets-B27XyqlJ.js","assets/drum-DU3Np5u1.js","assets/drumstick-8fFBJKts.js","assets/dumbbell-jmGGzeh5.js","assets/ear-off-HFSvUmjy.js","assets/ear-B361V_NG.js","assets/earth-lock-Di3uJtDM.js","assets/earth-5RgtO9-h.js","assets/eclipse-K4zmlEzJ.js","assets/egg-fried-DMV1nlLP.js","assets/egg-off-8YcxtNR2.js","assets/egg-C72zXt8d.js","assets/ellipsis-vertical-D8hmFrmQ.js","assets/ellipsis-COcYJXxW.js","assets/equal-approximately-DPByTU4u.js","assets/equal-not-JfGO7p1a.js","assets/equal-CqllXzB7.js","assets/eraser-pDSTAyjr.js","assets/ethernet-port-ro1gGPBK.js","assets/euro-CNK7R8O6.js","assets/expand-DZUsp3mV.js","assets/external-link-VIERdOxn.js","assets/eye-closed-DznUOff0.js","assets/eye-off-Y-ZRqGUc.js","assets/eye-C4XtbrYp.js","assets/facebook-DjNukR1A.js","assets/factory-BqE7rhXg.js","assets/fan-BeRcsRiy.js","assets/fast-forward--JekP9FH.js","assets/feather-6srbvdQe.js","assets/fence-B79FgCwg.js","assets/ferris-wheel-CzvstotA.js","assets/figma-CmCdt3Uo.js","assets/file-archive-BYzQkTeu.js","assets/file-audio-2-DyF5FKqJ.js","assets/file-audio-DdjBe7MQ.js","assets/file-axis-3d-DYPGeTLS.js","assets/file-badge-2-B2SYqIQQ.js","assets/file-badge-WYI8kFZY.js","assets/file-box-DwJlfo25.js","assets/file-chart-column-increasing-B51PyJkl.js","assets/file-chart-column-UnfykTuh.js","assets/file-chart-line-s9fQR7tA.js","assets/file-chart-pie-D2q3URIY.js","assets/file-check-2-ldwIaQ7s.js","assets/file-check-DJivRSOg.js","assets/file-clock-p_MuxKnC.js","assets/file-code-2-CKzZFGgV.js","assets/file-code-lXOJi3bD.js","assets/file-cog-CWsc-qY8.js","assets/file-diff-BqVcdH0d.js","assets/file-digit-4XWs2yeh.js","assets/file-down-DH8l3vnd.js","assets/file-heart-B8Yjs8AY.js","assets/file-image-iQ4VEC1H.js","assets/file-input-eSlwQKsk.js","assets/file-json-2-B97miwWT.js","assets/file-json-BY_Y07o7.js","assets/file-key-2-1fbXIkQi.js","assets/file-key-Bv9fgqw0.js","assets/file-lock-2-BKodZbc3.js","assets/file-lock-DgLaIajE.js","assets/file-minus-2-3iCEs4CB.js","assets/file-minus-DlD4J6FC.js","assets/file-music-B-tEnrTF.js","assets/file-output-BWAnUEm5.js","assets/file-pen-line-D6_fcdYM.js","assets/file-pen-CLxzxJUv.js","assets/file-plus-2-C-SzOcNJ.js","assets/file-plus-FeVQIC8Y.js","assets/file-question-DyLQczCY.js","assets/file-scan-D0I0fcoe.js","assets/file-search-2-DcHAWKrl.js","assets/file-search-DdKIlelM.js","assets/file-sliders-i1MXjxlH.js","assets/file-spreadsheet-CJrbQ4Pm.js","assets/file-stack-CGW3mCIs.js","assets/file-symlink-DULBkQLN.js","assets/file-terminal-DZwlrPsS.js","assets/file-text-DdIPdENM.js","assets/file-type-2-DRpLym11.js","assets/file-type-DuUEhY_a.js","assets/file-up-BVwId72b.js","assets/file-user-Bk9iAwYd.js","assets/file-video-2-BSauLPRA.js","assets/file-video-DPY-IHtH.js","assets/file-volume-2-5j8Uzn8Q.js","assets/file-volume-DPeAGIR3.js","assets/file-warning-D7UGYFef.js","assets/file-x-2-lekOmOj7.js","assets/file-x-CqZV7npW.js","assets/file-Cu_wxXYl.js","assets/files-CJux2Tj-.js","assets/film-eL_Rsw7v.js","assets/filter-x-CmeTILLI.js","assets/filter-Bs0n9QGS.js","assets/fingerprint-B2QO6BLU.js","assets/fire-extinguisher-CQrpVBWm.js","assets/fish-off-D3ESZj-4.js","assets/fish-symbol-BvmdhVMD.js","assets/fish-DOt1ZYGV.js","assets/flag-off-LHMVKh7p.js","assets/flag-triangle-left-9fJGWkfs.js","assets/flag-triangle-right-BHGMp2dq.js","assets/flag-HgutDrm0.js","assets/flame-kindling-DWmv4t30.js","assets/flame-N15Sdz2_.js","assets/flashlight-off-Qc5aZE_g.js","assets/flashlight-DWUuzkKC.js","assets/flask-conical-off-ij3IJ_ly.js","assets/flask-conical-IOnnNJEQ.js","assets/flask-round-D2w58WO1.js","assets/flip-horizontal-2-DUXOoSbA.js","assets/flip-horizontal-DzpJLAEi.js","assets/flip-vertical-2-DOlBQngj.js","assets/flip-vertical-CYPdFufq.js","assets/flower-2-CGuSJyYt.js","assets/flower-DL-Lfocn.js","assets/focus-BdmvRuKx.js","assets/fold-horizontal-DFodSdmp.js","assets/fold-vertical-Dvto7KeK.js","assets/folder-archive-BYnCNLHW.js","assets/folder-check-DGzRodlu.js","assets/folder-clock-BVtsZ9a7.js","assets/folder-closed-Dkmh7ykV.js","assets/folder-code-CquK7_dR.js","assets/folder-cog-Bfzk3ADX.js","assets/folder-dot-DjXxVX1i.js","assets/folder-down-43Vj-1f_.js","assets/folder-git-2-DQ-VdXM5.js","assets/folder-git-BKDF3C7V.js","assets/folder-heart-DlRys5Wx.js","assets/folder-input-BmE5bnka.js","assets/folder-kanban-DEydVrMi.js","assets/folder-key-CDBC1W_r.js","assets/folder-lock-Zu-fRHdh.js","assets/folder-minus-BwfgwMk-.js","assets/folder-open-dot-ChklAteg.js","assets/folder-open-dIe9OhV5.js","assets/folder-output-WO5TqpFl.js","assets/folder-pen-BXOuGWUO.js","assets/folder-plus-DvFPOHns.js","assets/folder-root-9KqnzvI8.js","assets/folder-search-2-CyDgtpNg.js","assets/folder-search-DQ8COQsr.js","assets/folder-symlink-BpyZfyNN.js","assets/folder-sync-Cv-qewKR.js","assets/folder-tree-cOe1nVqj.js","assets/folder-up-BAL5whnz.js","assets/folder-x-DlK37-Lz.js","assets/folder-Dbc0RVEZ.js","assets/folders-DmFCYl45.js","assets/footprints-tgLmDYeA.js","assets/forklift-oUhsGGLu.js","assets/forward-BIlFUz9S.js","assets/frame-KdJurEs1.js","assets/framer-BSAx1pOy.js","assets/frown-BNXjdP6h.js","assets/fuel-H9fueOcb.js","assets/fullscreen-CMMxgps6.js","assets/gallery-horizontal-end-BvIHg_FM.js","assets/gallery-horizontal-BCBMVwA6.js","assets/gallery-thumbnails-C9SUqVLZ.js","assets/gallery-vertical-end-BVm-l-ZV.js","assets/gallery-vertical-FDtQSzbm.js","assets/gamepad-2-BNUFujqL.js","assets/gamepad-V8eKDHmH.js","assets/gauge-7K9mtUsZ.js","assets/gavel-BxEKYog1.js","assets/gem-6qug6Zdz.js","assets/ghost-Brz2FcPb.js","assets/gift-BkQ663EA.js","assets/git-branch-plus-DjozWHvt.js","assets/git-branch-BLMboX0D.js","assets/git-commit-horizontal-LfHozc0p.js","assets/git-commit-vertical-rExEMeG6.js","assets/git-compare-arrows-CysL1z0P.js","assets/git-compare-UEy-Hhlr.js","assets/git-fork-CkdE2Z6H.js","assets/git-graph-BG-stPv6.js","assets/git-merge-czpaqJX2.js","assets/git-pull-request-arrow-B64dDBXT.js","assets/git-pull-request-closed-DUDp-nsq.js","assets/git-pull-request-create-arrow-vfGm9yCJ.js","assets/git-pull-request-create-fXOb9vAu.js","assets/git-pull-request-draft-DPqJG2BL.js","assets/git-pull-request-CwWKXsfo.js","assets/github-BUIHmzij.js","assets/gitlab-2h4b_GLE.js","assets/glass-water-ZhkHNt9E.js","assets/glasses-CKpD9BDt.js","assets/globe-lock-DJg6jj3f.js","assets/globe-C6URFmcD.js","assets/goal-Cl0uK3A-.js","assets/grab-CRirJ3QI.js","assets/graduation-cap-5YvoOu27.js","assets/grape-iRxIXnwJ.js","assets/grid-2x2-check-B5CrWXhe.js","assets/grid-2x2-plus-Dd-xZWW1.js","assets/grid-2x2-x-BNqEmhMe.js","assets/grid-2x2-CIiHKHxU.js","assets/grid-3x3-C04nVtGa.js","assets/grip-horizontal-BRuGzazd.js","assets/grip-vertical-RdR8DjMM.js","assets/grip-Dmx326So.js","assets/group-BMQoB3kG.js","assets/guitar-D3qOoMYy.js","assets/ham-C2WfYl21.js","assets/hammer--UY98v81.js","assets/hand-coins-Co9_qnM4.js","assets/hand-heart-DQtNFjnz.js","assets/hand-helping-DIpf50KX.js","assets/hand-metal-B8YktXyq.js","assets/hand-platter-CQOn896H.js","assets/hand-BJ4oVcYT.js","assets/handshake-0HiSdyC4.js","assets/hard-drive-download-CGFHrtu-.js","assets/hard-drive-upload-C4pYpCwI.js","assets/hard-drive-CN5SQUbY.js","assets/hard-hat-kYmwPkAl.js","assets/hash-pJzgCwMe.js","assets/haze-F-yjVPlz.js","assets/hdmi-port-CmEptjJU.js","assets/heading-1-Cszmf0Cv.js","assets/heading-2-whJmJX3i.js","assets/heading-3-CoqdyJic.js","assets/heading-4-73W48Kbb.js","assets/heading-5-gAU1e5u3.js","assets/heading-6-DXg8lvIj.js","assets/heading-DiIb6Viz.js","assets/headphone-off-BBUz12Qx.js","assets/headphones-chKf6I-l.js","assets/headset-DqjFGBP1.js","assets/heart-crack-BGxBCM2R.js","assets/heart-handshake-CptQ3Y3H.js","assets/heart-off-BCXNhLS6.js","assets/heart-pulse-C7jcreP5.js","assets/heart-z64Rry_O.js","assets/heater-CIL56VUr.js","assets/hexagon-C3Aa5cvj.js","assets/highlighter-DPBZrIaM.js","assets/history-BRhxCEwK.js","assets/hop-off-CjDbT42F.js","assets/hop-BdZsdLvJ.js","assets/hospital-CbNcjmeo.js","assets/hotel-DVdG0D_Q.js","assets/hourglass-DTxy3Qxg.js","assets/house-plug-Cg9zDZde.js","assets/house-plus-CvZ_I0uG.js","assets/house-DAP4hey1.js","assets/ice-cream-bowl-CNHAN7V2.js","assets/ice-cream-cone-C9P8xOc8.js","assets/id-card-BmJSgM-p.js","assets/image-down-DBU6zyCz.js","assets/image-minus-BZ0Z5lta.js","assets/image-off-BJB6Gno-.js","assets/image-play-BnurUCoQ.js","assets/image-plus-BiGF5RMx.js","assets/image-up-DCoOD52F.js","assets/image-upscale-mv9bue4I.js","assets/image-D8TYY2B5.js","assets/images-D0xXufz4.js","assets/import-CmLLob3U.js","assets/inbox-D79nCtE_.js","assets/indent-decrease-D0cNPHwt.js","assets/indent-increase-CmjYEhgs.js","assets/indian-rupee-DcAguhtv.js","assets/infinity-B3ZvpxMk.js","assets/info-h8vJgs86.js","assets/inspection-panel-DlTQr1Ti.js","assets/instagram-B93Xj182.js","assets/italic-CRRIvtav.js","assets/iteration-ccw-D7xF4-u6.js","assets/iteration-cw-Bk241U2r.js","assets/japanese-yen-mZ9l81hm.js","assets/joystick-C_DU3Dqn.js","assets/kanban-D8y2PCYw.js","assets/key-round-CbiL4vXg.js","assets/key-square-DsNGLLWc.js","assets/key-Dus8xFFg.js","assets/keyboard-music-u1hIMk0C.js","assets/keyboard-off-D_MTg_Xm.js","assets/keyboard-TwlyQStD.js","assets/lamp-ceiling-BNc5V7zY.js","assets/lamp-desk-DywckqNc.js","assets/lamp-floor-C5ulkcr4.js","assets/lamp-wall-down-DwFOBp4U.js","assets/lamp-wall-up-Dk5fTn7P.js","assets/lamp-Z-FeWWkO.js","assets/land-plot-qufbVe5P.js","assets/landmark-D3ufVarT.js","assets/languages-C44K1QEo.js","assets/laptop-minimal-check-DGKmQ-3Q.js","assets/laptop-minimal-qqbY6nKw.js","assets/laptop-CpXOA6Jq.js","assets/lasso-select-VPQK6u8t.js","assets/lasso-VYBAvXhf.js","assets/laugh-CZVTyO2G.js","assets/layers-2-DiVQ1axR.js","assets/layers-3-Cij7gzDD.js","assets/layers-CSiETsWi.js","assets/layout-dashboard-ClZKAXRs.js","assets/layout-grid-DpEI0rbf.js","assets/layout-list-DX72k6kd.js","assets/layout-panel-left-BYukh-Cv.js","assets/layout-panel-top-C_mkKuk7.js","assets/layout-template-u7Q6cvXP.js","assets/leaf-Dp9L_g55.js","assets/leafy-green-DQuSuiyQ.js","assets/lectern-ScdRULAn.js","assets/letter-text-DePKyvjw.js","assets/library-big-N07NaA9n.js","assets/library-YLdvCUN9.js","assets/life-buoy-SuDW6l9u.js","assets/ligature-D94o63sl.js","assets/lightbulb-off-BUvJqJw6.js","assets/lightbulb-Cez3EIYi.js","assets/link-2-off-DncVXL-o.js","assets/link-2-CJaA6n6k.js","assets/link-1rrFhL5n.js","assets/linkedin-C5a0Rf2Z.js","assets/list-check-BYuV6scQ.js","assets/list-checks-fcoo-cJc.js","assets/list-collapse-Bac3vufw.js","assets/list-end-BAkgFyej.js","assets/list-filter-CdNBKCtB.js","assets/list-minus-CiRGdabl.js","assets/list-music-DDjnPdlD.js","assets/list-ordered-CU5N6fJc.js","assets/list-plus-DwTupgTd.js","assets/list-restart-pjS246il.js","assets/list-start-BPgUDmUN.js","assets/list-todo-efH1_AQm.js","assets/list-tree-CRktdGJV.js","assets/list-video-BeFsqvrI.js","assets/list-x-nroYKNzt.js","assets/list-BB7Nay6y.js","assets/loader-circle-Dbm6Dzit.js","assets/loader-pinwheel-D2NcbIIL.js","assets/loader-Cxfgy6If.js","assets/locate-fixed-meXTmoRw.js","assets/locate-off-aTf9QMQO.js","assets/locate-BSlb_idg.js","assets/lock-keyhole-open-Bd9auBkf.js","assets/lock-keyhole-5vb7BKDM.js","assets/lock-open-opTqjhkk.js","assets/lock-D6iJjZz2.js","assets/log-in-DQRh49_w.js","assets/log-out-Cka8piFl.js","assets/logs-BTWLC5Bw.js","assets/lollipop-CxGy1X8F.js","assets/luggage-CCUUro4I.js","assets/magnet-Bu1B5Qgh.js","assets/mail-check-Cqc-tXHc.js","assets/mail-minus-DhdztvdJ.js","assets/mail-open-BRcnj0gX.js","assets/mail-plus-CHjsnGss.js","assets/mail-question-esfAi8Z_.js","assets/mail-search-BD8-DAee.js","assets/mail-warning-DygFAavs.js","assets/mail-x-B3MH_fKo.js","assets/mail-CshXiMxD.js","assets/mailbox-BUDfkX4u.js","assets/mails-iKqzBZfi.js","assets/map-pin-check-inside-DTL8tYCt.js","assets/map-pin-check-_SM7Vnf5.js","assets/map-pin-house-BfNVmTy9.js","assets/map-pin-minus-inside-Cw4n1wSh.js","assets/map-pin-minus-B-qkPGTE.js","assets/map-pin-off-CFnDDuaN.js","assets/map-pin-plus-inside-DFF71zDy.js","assets/map-pin-plus-JE3lmZtU.js","assets/map-pin-x-inside-DE3WIi4f.js","assets/map-pin-x-Ccov6lQ0.js","assets/map-pin-DZy8kSdq.js","assets/map-pinned-Dy40J_4E.js","assets/map-C5jv-Por.js","assets/martini-C9Yc4ixl.js","assets/maximize-2-DuyZOozx.js","assets/maximize-CN2oHIgM.js","assets/medal-Bd4R30Oz.js","assets/megaphone-off-B1nRDGAX.js","assets/megaphone-DP0aNPhK.js","assets/meh-Bz2xhAXI.js","assets/memory-stick-CpGBcfyG.js","assets/menu-CJz4PFqb.js","assets/merge-DzxJLbnp.js","assets/message-circle-code-D86Wt10d.js","assets/message-circle-dashed-i1sZSNyA.js","assets/message-circle-heart-yqglnhFL.js","assets/message-circle-more-DYvVgOE-.js","assets/message-circle-off-CQqQaXqF.js","assets/message-circle-plus-Dm3F1H6i.js","assets/message-circle-question-BanRYOA8.js","assets/message-circle-reply-Ck2z7CzE.js","assets/message-circle-warning-BfBuZKTY.js","assets/message-circle-x-DPyRpOzX.js","assets/message-circle-D2Z7irgD.js","assets/message-square-code-o-m-9TKC.js","assets/message-square-dashed-fflvV7lZ.js","assets/message-square-diff-DX-zFE2h.js","assets/message-square-dot-Cgp9X3Yf.js","assets/message-square-heart-CuaVIN9a.js","assets/message-square-lock-CbTgVrHr.js","assets/message-square-more-DTzTjgs-.js","assets/message-square-off-CNj9eeRB.js","assets/message-square-plus-C8rBpeSi.js","assets/message-square-quote-TKvqjvOb.js","assets/message-square-reply-PjRI5xnl.js","assets/message-square-share-DGs8YU6H.js","assets/message-square-text-DfUhWnyN.js","assets/message-square-warning-Ci4F3F4M.js","assets/message-square-x-AeP7m__2.js","assets/message-square-CgIrJ6RD.js","assets/messages-square-5Cv1tGvZ.js","assets/mic-off-COxD8jwo.js","assets/mic-vocal-Cv6_gWc0.js","assets/mic-De8fcxlJ.js","assets/microchip-Mn0VyVoS.js","assets/microscope-GrXqLA7H.js","assets/microwave-49Ppbl26.js","assets/milestone-Cu93GL3_.js","assets/milk-off-BwljurOk.js","assets/milk-Cxaf0W8K.js","assets/minimize-2-DqU3tP4M.js","assets/minimize-DfCcmDN-.js","assets/minus-Ccxh3YCz.js","assets/monitor-check-CYtd_uTU.js","assets/monitor-cog-CCtksGYF.js","assets/monitor-dot-CVNBS52k.js","assets/monitor-down-ozj1QdGE.js","assets/monitor-off-BYV1DHcZ.js","assets/monitor-pause-ChmkWbL4.js","assets/monitor-play-CAshM8xz.js","assets/monitor-smartphone-Bt9Ys_aU.js","assets/monitor-speaker-DPOJLSxE.js","assets/monitor-stop-CInllMFy.js","assets/monitor-up-C_GS7DWb.js","assets/monitor-x-C1yPE3gW.js","assets/monitor-B4d3ERzI.js","assets/moon-star-DyX3RHF7.js","assets/moon-sgy_arMg.js","assets/mountain-snow-lKrym0VU.js","assets/mountain-C6ZwoRGG.js","assets/mouse-off-CPdKoa4n.js","assets/mouse-pointer-2-whBnHKlP.js","assets/mouse-pointer-ban-BnB2dCII.js","assets/mouse-pointer-click-Co_GuJrp.js","assets/mouse-pointer-DU-epVho.js","assets/mouse-BK4ey5cv.js","assets/move-3d-De2Bqpl1.js","assets/move-diagonal-2-DAcyzdEf.js","assets/move-diagonal-DRebUNSX.js","assets/move-down-left-De5aleAs.js","assets/move-down-right-OOEN9x6Y.js","assets/move-down-CZ7XhOsM.js","assets/move-horizontal-Dn7gzJkn.js","assets/move-left-DJgICMIe.js","assets/move-right-CDx1T7r0.js","assets/move-up-left-qMfS2myB.js","assets/move-up-right-DkBHPFAh.js","assets/move-up-DsAfig7k.js","assets/move-vertical-tj3LOdvp.js","assets/move-DHt0ziIN.js","assets/music-2-CJTEfpH0.js","assets/music-3-js26bEOe.js","assets/music-4-Da0ek3C2.js","assets/music-CajUk8Sn.js","assets/navigation-2-off-jT1Pomho.js","assets/navigation-2-4YqN1HVB.js","assets/navigation-off-DECPLUU_.js","assets/navigation-DiKo9BW7.js","assets/network-CoVrDhj6.js","assets/newspaper-BBvv2FS5.js","assets/nfc-DPKak7fb.js","assets/notebook-pen-CfOifqYd.js","assets/notebook-tabs-Dh2UnFJE.js","assets/notebook-text-BO76-Lln.js","assets/notebook-w0g4P_4d.js","assets/notepad-text-dashed-VoQBfGHE.js","assets/notepad-text-DExTfkNe.js","assets/nut-off-BZDLISFG.js","assets/nut-DWf4YH75.js","assets/octagon-alert-3jASwgbh.js","assets/octagon-minus-xwRBDvwe.js","assets/octagon-pause-B4gj59W1.js","assets/octagon-x-CIMLIk7F.js","assets/octagon-DAzerjpi.js","assets/omega-BeNJUY5_.js","assets/option-CURQ2rLU.js","assets/orbit-CU76gnWA.js","assets/origami-AtKW2ceJ.js","assets/package-2-DIHkJm1n.js","assets/package-check-qEH7axoU.js","assets/package-minus-DO-uimoe.js","assets/package-open-DTdGIXoO.js","assets/package-plus-BtTdXrry.js","assets/package-search-CjX5B37h.js","assets/package-x-ByCaae86.js","assets/package-B23X1pqr.js","assets/paint-bucket-B_ORouV0.js","assets/paint-roller-CAj2TAXd.js","assets/paintbrush-vertical-B6PHr8F9.js","assets/paintbrush-D5h8VB6T.js","assets/palette-B6ad8QQx.js","assets/panel-bottom-close-xFGVFeSJ.js","assets/panel-bottom-dashed-B7EPFkVK.js","assets/panel-bottom-open-CO6JfQda.js","assets/panel-bottom-BO4_Xyon.js","assets/panel-left-close-DwPT2lCx.js","assets/panel-left-dashed-DLir9UTb.js","assets/panel-left-open-DJSbSPLo.js","assets/panel-left-loUv7Vd6.js","assets/panel-right-close-CWQbCFzP.js","assets/panel-right-dashed-BWdV10G5.js","assets/panel-right-open-Cbn6BCeY.js","assets/panel-right-DyzdYwhU.js","assets/panel-top-close-CQvukO6H.js","assets/panel-top-dashed-Dv3tKlr7.js","assets/panel-top-open-DCt8duqA.js","assets/panel-top-DdlYn9q2.js","assets/panels-left-bottom-bvphh8Gv.js","assets/panels-right-bottom-kSo32rfl.js","assets/panels-top-left-BmRp2hoA.js","assets/paperclip-DTrwIVa5.js","assets/parentheses-EYq3N4R2.js","assets/parking-meter-B0ix1MKr.js","assets/party-popper-DdK7f71h.js","assets/pause-C4MN17wa.js","assets/paw-print-fp31Thu_.js","assets/pc-case-CEJp-fy8.js","assets/pen-line-BD7ohWoN.js","assets/pen-off-Du145n-Z.js","assets/pen-tool-BEoq8Fmc.js","assets/pen-DyLZYDtG.js","assets/pencil-line-DEr_fcMI.js","assets/pencil-off-BX2Ga3mO.js","assets/pencil-ruler-BGygN75R.js","assets/pencil-mNw5-cto.js","assets/pentagon-D7VacO7s.js","assets/percent-Cs5Mx4D7.js","assets/person-standing-DiFOuDw4.js","assets/philippine-peso-De9Fc_nb.js","assets/phone-call-CUZcXul5.js","assets/phone-forwarded-BPTER9Kj.js","assets/phone-incoming-Dt73X6Ro.js","assets/phone-missed-DpmoWUXc.js","assets/phone-off-CTCTWzhd.js","assets/phone-outgoing-CV7XHRJa.js","assets/phone-BBktAOZk.js","assets/pi-BFZw3Ta7.js","assets/piano-B3iwXZ86.js","assets/pickaxe-BsYYRGKS.js","assets/picture-in-picture-2-CgzAH1TL.js","assets/picture-in-picture-aTIXojGe.js","assets/piggy-bank-7hBufohM.js","assets/pilcrow-left-0SUEvJ-5.js","assets/pilcrow-right-Dlx1eeq6.js","assets/pilcrow-kPd6D4Ed.js","assets/pill-bottle-Cmg8Oyok.js","assets/pill-DCZU1IQ7.js","assets/pin-off-cShDVekk.js","assets/pin-CR8nHAd7.js","assets/pipette--kucMh3_.js","assets/pizza-08-bm5Ze.js","assets/plane-landing-COFJdI_1.js","assets/plane-takeoff-DbOyu5ZP.js","assets/plane-DKHhxME8.js","assets/play-D_NhYIlD.js","assets/plug-2-B4qZfvCY.js","assets/plug-zap-C7Ex6xsf.js","assets/plug-CM1g-vIF.js","assets/plus-DdseC9r5.js","assets/pocket-knife-S1p-1HJI.js","assets/pocket-DTzAVvHn.js","assets/podcast-CIGU_kOy.js","assets/pointer-off-BcVPcgCZ.js","assets/pointer-C2yg_2MO.js","assets/popcorn-BBhfI42E.js","assets/popsicle-C-7P5p2m.js","assets/pound-sterling-DSwWW3MW.js","assets/power-off-PIzIxR8y.js","assets/power-SoPH6jGM.js","assets/presentation-DiBafRCu.js","assets/printer-check-BUo7-q96.js","assets/printer-I6rGxyj5.js","assets/projector-DOX5ya_Y.js","assets/proportions-DKBGEGxm.js","assets/puzzle-DfKEzeGe.js","assets/pyramid-Dif-fsvN.js","assets/qr-code-BQw69i46.js","assets/quote-ClRi4mcN.js","assets/rabbit-fR2eVFqu.js","assets/radar-BfDQ7VLq.js","assets/radiation-d_SV23a6.js","assets/radical-DhEWwG69.js","assets/radio-receiver-C0OMzSkb.js","assets/radio-tower-BUomHJOX.js","assets/radio-Cg8IMAd0.js","assets/radius-JHpnhlNH.js","assets/rail-symbol-CWvdZ5-Y.js","assets/rainbow-4rsuNdH9.js","assets/rat-Dkld-KTM.js","assets/ratio-BUJ8wjNY.js","assets/receipt-cent-Dph2tbE5.js","assets/receipt-euro-C0IwpLkt.js","assets/receipt-indian-rupee-Bl8pw0vU.js","assets/receipt-japanese-yen-BfS89qEg.js","assets/receipt-pound-sterling-CiBIBOUe.js","assets/receipt-russian-ruble-BlDAiyFf.js","assets/receipt-swiss-franc-CjhYzp8H.js","assets/receipt-text-buK2KDmS.js","assets/receipt-BnHuE4bU.js","assets/rectangle-ellipsis-DFlwkpEa.js","assets/rectangle-horizontal-DzRXuK8l.js","assets/rectangle-vertical-BXCWDtEA.js","assets/recycle-BR1JdXwE.js","assets/redo-2-CqxerChX.js","assets/redo-dot-CJ3Jo1xQ.js","assets/redo-DlwdCVfl.js","assets/refresh-ccw-dot-BDOwumzo.js","assets/refresh-ccw-m-iSj44n.js","assets/refresh-cw-off-DaPPzhwQ.js","assets/refresh-cw-DcoCnemg.js","assets/refrigerator-MrxcQW3Y.js","assets/regex-DjdIAFzO.js","assets/remove-formatting-BwrNAjeG.js","assets/repeat-1-BqGhH8X_.js","assets/repeat-2-CKmA8z6-.js","assets/repeat-DgzCzclY.js","assets/replace-all-BHGqvSSQ.js","assets/replace-CDr8_n98.js","assets/reply-all-BO2Og2YK.js","assets/reply-ZqIESeto.js","assets/rewind-DfNr5M-P.js","assets/ribbon-CDBtDSS3.js","assets/rocket-CfH-1Pdv.js","assets/rocking-chair-C1XMWFHk.js","assets/roller-coaster-BttcDROq.js","assets/rotate-3d-gNIQemtN.js","assets/rotate-ccw-square-BCVyZvmp.js","assets/rotate-ccw-dlLNXhoE.js","assets/rotate-cw-square-DOlRKlj3.js","assets/rotate-cw-BGT2m2PK.js","assets/route-off-uZqL7aqb.js","assets/route-Bha1ydGC.js","assets/router-B-ah6UNW.js","assets/rows-2-Gb7LyExn.js","assets/rows-3-DCq-h-3o.js","assets/rows-4-DQr9t05I.js","assets/rss-CgYj3RbE.js","assets/ruler-ckbz8_sd.js","assets/russian-ruble-Bmb98CW_.js","assets/sailboat-CzlpzFxb.js","assets/salad-D9FsYhRj.js","assets/sandwich-D7UvkHlN.js","assets/satellite-dish-Cz3DEYfg.js","assets/satellite-DOYutYf3.js","assets/save-all-CgWKrGvP.js","assets/save-off-CXI1vqEk.js","assets/save-CQmp2_y9.js","assets/scale-3d-BcL4wqCe.js","assets/scale-ChlwlE_u.js","assets/scaling-BJGY6hZ_.js","assets/scan-barcode-CRF7suI2.js","assets/scan-eye-Btm_rTkN.js","assets/scan-face-DUTFib9B.js","assets/scan-line-BRDDiAWJ.js","assets/scan-qr-code-CuOQt2JT.js","assets/scan-search-n6k4Vj3s.js","assets/scan-text-ClPXusip.js","assets/scan-a_3coLTF.js","assets/school-Cwy27akY.js","assets/scissors-line-dashed-DknQhmHn.js","assets/scissors-BP1zqW-v.js","assets/screen-share-off-VX-Yxil8.js","assets/screen-share-4M0uPEog.js","assets/scroll-text-DLBbOjQt.js","assets/scroll-BA7q5dKi.js","assets/search-check-u0fwMgrS.js","assets/search-code-xbGLOexC.js","assets/search-slash-DH4Qe4Mu.js","assets/search-x-dTEhVEJz.js","assets/search-D7kIVwe-.js","assets/section-B_T-AgzR.js","assets/send-horizontal-DHhkqEfh.js","assets/send-to-back-CSNcgYfK.js","assets/send-D_NN200H.js","assets/separator-horizontal-gRpYracC.js","assets/separator-vertical-CTV85Vld.js","assets/server-cog-DrN-050Z.js","assets/server-crash-BzEZ--D2.js","assets/server-off-CHZSjDHB.js","assets/server-C39xl1us.js","assets/settings-2-CyFNhmUK.js","assets/settings-Igo5nVNu.js","assets/shapes-Rnu6oGyW.js","assets/share-2-DTpQ1v0V.js","assets/share-D7aLU9h_.js","assets/sheet-CIea-_0m.js","assets/shell-y36qaomb.js","assets/shield-alert-BvjCtV-3.js","assets/shield-ban-DaTUzHSj.js","assets/shield-check-CIwmwzhP.js","assets/shield-ellipsis-CooR3ETR.js","assets/shield-half-D7nNtye0.js","assets/shield-minus-HnBpDVRS.js","assets/shield-off-BD2awVfF.js","assets/shield-plus-eb2mQ7gD.js","assets/shield-question-BC89YmtW.js","assets/shield-x-DaXcARRg.js","assets/shield-MWSYE9vy.js","assets/ship-wheel-D6VgGPjj.js","assets/ship-D6M-QmgW.js","assets/shirt-EUG1z6Ds.js","assets/shopping-bag-BQxhT18V.js","assets/shopping-basket-DlUvCqzu.js","assets/shopping-cart-DaNr8Jpj.js","assets/shovel-CP8luLfc.js","assets/shower-head-DWxfzGNX.js","assets/shrink-DKiJRirJ.js","assets/shrub-a7Ugbo1n.js","assets/shuffle-WasQYWHk.js","assets/sigma-B6HPCbDK.js","assets/signal-high-CQBhrN7w.js","assets/signal-low-d7YXFVH8.js","assets/signal-medium-B0YyHXY9.js","assets/signal-zero-DEdolONL.js","assets/signal-CyyObhgV.js","assets/signature-RU8DJd5b.js","assets/signpost-big-CyNP0Pui.js","assets/signpost-B_7Nnsm3.js","assets/siren-Bc76eztt.js","assets/skip-back-BmWAFLrx.js","assets/skip-forward-0iAwImod.js","assets/skull-_Hp61ud-.js","assets/slack-BdmnCi1c.js","assets/slash-DI57qHyh.js","assets/slice--Q7XcU0g.js","assets/sliders-horizontal-CClgq_H8.js","assets/sliders-vertical-D9SzdZRU.js","assets/smartphone-charging-UmBc35R6.js","assets/smartphone-nfc-DUl95Pi9.js","assets/smartphone-DIa2EHTr.js","assets/smile-plus-DneNZl4k.js","assets/smile-B_vUcJ7Z.js","assets/snail-CrtHsjGE.js","assets/snowflake-XCqQ3KtC.js","assets/sofa-BQWDMmhz.js","assets/soup-Ddk2N7g3.js","assets/space-DgiPm8Oa.js","assets/spade-L2bFjZqI.js","assets/sparkle-BMFZMYYT.js","assets/sparkles-eoNyNVVU.js","assets/speaker-2oagIJaQ.js","assets/speech-DDc28of2.js","assets/spell-check-2-_ObA9_kC.js","assets/spell-check-DNiHoAgH.js","assets/spline-DiJmrV3J.js","assets/split-7aAkzmHE.js","assets/spray-can-CWOey69j.js","assets/sprout-DBNvP83W.js","assets/square-activity-gQrFMEG2.js","assets/square-arrow-down-left-CqX_QNzf.js","assets/square-arrow-down-right-8xJgNHEg.js","assets/square-arrow-down-LSLCLiUd.js","assets/square-arrow-left-3tHsVxgU.js","assets/square-arrow-out-down-left-B3hQ0tjP.js","assets/square-arrow-out-down-right-CUQgCv6k.js","assets/square-arrow-out-up-left-B9V0B1G6.js","assets/square-arrow-out-up-right-B29qUG4v.js","assets/square-arrow-right-DPObgVre.js","assets/square-arrow-up-left-1pivciRb.js","assets/square-arrow-up-right-BeqSRHC_.js","assets/square-arrow-up-DdOiaA9n.js","assets/square-asterisk-BVyrbWhp.js","assets/square-bottom-dashed-scissors-4ZJj5OAB.js","assets/square-chart-gantt-BBP5Rhul.js","assets/square-check-big-BcjoS5Rd.js","assets/square-check-PD_f3nl3.js","assets/square-chevron-down-BNxX5su0.js","assets/square-chevron-left-IvCoJagi.js","assets/square-chevron-right-C9uwPMis.js","assets/square-chevron-up-B4seHv3o.js","assets/square-code-BoYxP1b7.js","assets/square-dashed-bottom-code-Cd_8XsIn.js","assets/square-dashed-bottom-D5eln0Sk.js","assets/square-dashed-kanban-ytDzaWjh.js","assets/square-dashed-mouse-pointer-CouRobeI.js","assets/square-dashed-halOijye.js","assets/square-divide-WfspL_sg.js","assets/square-dot-Brraj-FF.js","assets/square-equal-Dl43Gfaf.js","assets/square-function-mTwROijF.js","assets/square-kanban-DVt6wgJz.js","assets/square-library-BwcIWdXt.js","assets/square-m-vTGwrS5I.js","assets/square-menu-DwadlW8m.js","assets/square-minus-BVaTU15E.js","assets/square-mouse-pointer-W-J6H1Hs.js","assets/square-parking-off-CiMYu51E.js","assets/square-parking-CUyYOhB3.js","assets/square-pen-ms0ex5sg.js","assets/square-percent-DtA4A_q1.js","assets/square-pi-hNmOG1DO.js","assets/square-pilcrow-rtk2griH.js","assets/square-play-CUsyL8_A.js","assets/square-plus-O2hJURg7.js","assets/square-power-BcCYkEPJ.js","assets/square-radical-DiRGELtg.js","assets/square-scissors-VIqVCk7z.js","assets/square-sigma-Dazz3gDW.js","assets/square-slash-CQ6P0hRD.js","assets/square-split-horizontal-CF6ZvRCl.js","assets/square-split-vertical-dBU1Yq0M.js","assets/square-square-jUm5w1ts.js","assets/square-stack-Ca3cmRAf.js","assets/square-terminal-DP9IOoNX.js","assets/square-user-round-CkWr3nhq.js","assets/square-user-B_ngBlXK.js","assets/square-x-B-NlhqVC.js","assets/square-G8fFihNl.js","assets/squircle-B6U555mv.js","assets/squirrel-BiLSLaBl.js","assets/stamp-DJWERhGd.js","assets/star-half-DsFGhZNb.js","assets/star-off-tU3cePsJ.js","assets/star-BAcvdD03.js","assets/step-back-C8-g-_HY.js","assets/step-forward-Cxo4PMlE.js","assets/stethoscope-BL-miX7j.js","assets/sticker-BgRsfVuB.js","assets/sticky-note-B9NcfQeT.js","assets/store-bYnhe7Ub.js","assets/stretch-horizontal-DByumVN8.js","assets/stretch-vertical-D1NvKFD_.js","assets/strikethrough-DayVcgTC.js","assets/subscript-eorZOsO7.js","assets/sun-dim-QMilXKPF.js","assets/sun-medium-Bc3zhD8I.js","assets/sun-moon-DvLzHA2J.js","assets/sun-snow-Bh8CqVQn.js","assets/sun-Dpnwh54B.js","assets/sunrise-DDyirxoi.js","assets/sunset-C8f8zKUi.js","assets/superscript-BWVgzB43.js","assets/swatch-book-BmVq5xZd.js","assets/swiss-franc-D8_WJ3AM.js","assets/switch-camera-Bw6bJOKZ.js","assets/sword-qGVJ95yX.js","assets/swords-DAHQYO2-.js","assets/syringe-CTNloseQ.js","assets/table-2-BVJYuouX.js","assets/table-cells-merge-DjPJqNQJ.js","assets/table-cells-split-CNPhkLIb.js","assets/table-columns-split-Cl99oK4F.js","assets/table-of-contents-BoxEFAQk.js","assets/table-properties-B3Jb8Pxh.js","assets/table-rows-split-BC1hYEl4.js","assets/table-CpUKu_ZV.js","assets/tablet-smartphone-BERKrMi_.js","assets/tablet-DclAe-mA.js","assets/tablets-C6n8Y-GV.js","assets/tag-BnzxZzwA.js","assets/tags-6ZV3g9qj.js","assets/tally-1-YoN-C1Ma.js","assets/tally-2-rUyUar-U.js","assets/tally-3-CiOIP_t8.js","assets/tally-4-DlmrZLE-.js","assets/tally-5-Bt64oB0U.js","assets/tangent-BLonAN9-.js","assets/target-Jf3uYRGs.js","assets/telescope-CJwDOiY0.js","assets/tent-tree-L8pfNomW.js","assets/tent-CLtoLZ-6.js","assets/terminal-Bo9kGstL.js","assets/test-tube-diagonal-C9p-mmSV.js","assets/test-tube-DDwdbg2c.js","assets/test-tubes-Cfl6txr8.js","assets/text-cursor-input-fy5a8JWd.js","assets/text-cursor-C5OSW_L3.js","assets/text-quote-B3nJNErB.js","assets/text-search-rwkPTprc.js","assets/text-select-29ByFtUV.js","assets/text-B1FQCLuI.js","assets/theater-BrxuhhjM.js","assets/thermometer-snowflake-Bwd_8kQT.js","assets/thermometer-sun-BD3zPKXo.js","assets/thermometer-DhbnTF6n.js","assets/thumbs-down-jRkSeQm9.js","assets/thumbs-up-DVTbRajO.js","assets/ticket-check-C-MjABMK.js","assets/ticket-minus-vcqRym4-.js","assets/ticket-percent-Bg9eOTqU.js","assets/ticket-plus-C58-AMeL.js","assets/ticket-slash-Df_doMx-.js","assets/ticket-x-qAhrnLSH.js","assets/ticket-BtCHRW1w.js","assets/tickets-plane-De4l0_uI.js","assets/tickets-yzCd45O8.js","assets/timer-off-BUsGbyMo.js","assets/timer-reset-BHBEc7hj.js","assets/timer-B8pL80RV.js","assets/toggle-left-BGyezpc-.js","assets/toggle-right-DkPeQ00_.js","assets/toilet-BczNxC4Z.js","assets/tornado-DgL9vji6.js","assets/torus-C6dFsrxg.js","assets/touchpad-off-DVnSu-1i.js","assets/touchpad-CmEgzXdi.js","assets/tower-control-BNa5ze1a.js","assets/toy-brick-LhQMD0_A.js","assets/tractor-CUtgmh0N.js","assets/traffic-cone-Cnfs4CcE.js","assets/train-front-tunnel-C9-MTYmD.js","assets/train-front-duwwm5fz.js","assets/train-track-DkLNqi3s.js","assets/tram-front-DDQe4Dhg.js","assets/trash-2-Cvu3sV6U.js","assets/trash-e4-QBa2z.js","assets/tree-deciduous-CLX5h-Cv.js","assets/tree-palm-j9m5JhgC.js","assets/tree-pine-RHn7apto.js","assets/trees-BJ4CkeCy.js","assets/trello-Cqton4wv.js","assets/trending-down-CKIg3Wno.js","assets/trending-up-down-B17Mx2ZH.js","assets/trending-up-CqBnXqTO.js","assets/triangle-alert-DR_raFRV.js","assets/triangle-right-rQ0glFJk.js","assets/triangle-D-iRNhVN.js","assets/trophy-B_ASxF7d.js","assets/truck-DW4IyorY.js","assets/turtle-BheWkSbY.js","assets/tv-minimal-play-D-qicCwZ.js","assets/tv-minimal-2SvfjCob.js","assets/tv-D9xjmg3O.js","assets/twitch-CDWHw0qr.js","assets/twitter-DFiVOVu1.js","assets/type-outline-mbSDdi4F.js","assets/type-CvCBk2rb.js","assets/umbrella-off-B5VEGPVv.js","assets/umbrella-CYhxF-Bu.js","assets/underline-C12XtC3U.js","assets/undo-2-BSR3H55E.js","assets/undo-dot-BjoV30fa.js","assets/undo-CuiHjOqa.js","assets/unfold-horizontal-SjSsnkKJ.js","assets/unfold-vertical-DAGkSXNL.js","assets/ungroup-Cc2lnAQx.js","assets/university-B-Jli3Ga.js","assets/unlink-2-CBsSprBZ.js","assets/unlink-BqoFfo6j.js","assets/unplug-CZ9F2oKK.js","assets/upload-Btei5SEA.js","assets/usb-lbvJNxwo.js","assets/user-check-6PnI1oKk.js","assets/user-cog-CiZvd9xV.js","assets/user-minus-BMrAogZh.js","assets/user-pen-BQaEZm-h.js","assets/user-plus-05fy-C9Y.js","assets/user-round-check-Cl94LywT.js","assets/user-round-cog-rQwPRRmX.js","assets/user-round-minus-DiQE4fS8.js","assets/user-round-pen-CspK29T0.js","assets/user-round-plus-st4nLwut.js","assets/user-round-search-Dt_Qpr2n.js","assets/user-round-x-BTPfAqGG.js","assets/user-round-BKQWP867.js","assets/user-search-BJqomA0R.js","assets/user-x-B3aP4xsk.js","assets/user-CZm0kHBK.js","assets/users-round--AULh7IM.js","assets/users-CsRK1ZaG.js","assets/utensils-crossed-DkuYptKL.js","assets/utensils-m7cfiRaL.js","assets/utility-pole-G6MZ2ulr.js","assets/variable-Bf9udoCS.js","assets/vault-CNyyJA7p.js","assets/vegan-Da79SCMx.js","assets/venetian-mask-1sodC9_E.js","assets/vibrate-off-DHUttMQt.js","assets/vibrate-B_9YZsD6.js","assets/video-off-BXdPdNsp.js","assets/video-7V9IXk4u.js","assets/videotape-x1vyU6Fp.js","assets/view-BB2hBPyO.js","assets/voicemail-4PooibCq.js","assets/volleyball-D6C7uOHJ.js","assets/volume-1-H4P7qhQu.js","assets/volume-2-D2EG3p1s.js","assets/volume-off-BQfcdhR7.js","assets/volume-x-DOeRKjW1.js","assets/volume-fv4l2Qd_.js","assets/vote-B8WDowtd.js","assets/wallet-cards-C_S9qYPN.js","assets/wallet-minimal-D92_zg1C.js","assets/wallet-C-ck9prm.js","assets/wallpaper-C1r7Zu5w.js","assets/wand-sparkles-DmZmKIYm.js","assets/wand-Dr-McKPX.js","assets/warehouse-iEC0fxDV.js","assets/washing-machine-B4steotW.js","assets/watch-DMUv1Sdj.js","assets/waves-CmS-cDVc.js","assets/waypoints-DL9Zv1Ol.js","assets/webcam-CmU33Xt8.js","assets/webhook-off-DsXGBzON.js","assets/webhook-BrrVY4Bs.js","assets/weight-Cem0A-oF.js","assets/wheat-off-Bdv4XxRq.js","assets/wheat-D7c-ZIkJ.js","assets/whole-word-DUS7kskI.js","assets/wifi-high-CN7GvJBc.js","assets/wifi-low-B4WUuUDe.js","assets/wifi-off-D4QD5vHd.js","assets/wifi-zero-DCuMfwPs.js","assets/wifi-BrxwAONm.js","assets/wind-arrow-down-Bdc7E47C.js","assets/wind-6gOxg9iZ.js","assets/wine-off-DBpsHj3N.js","assets/wine-COxcOhiK.js","assets/workflow-D8crtUHD.js","assets/worm-CiLCDPPz.js","assets/wrap-text-2NHP2xqH.js","assets/wrench-CHNreDPo.js","assets/x-wv-8XEYv.js","assets/youtube-Befkd-ol.js","assets/zap-off-Bazciml2.js","assets/zap-B4nJlPfh.js","assets/zoom-in-C5Boot0Q.js","assets/zoom-out-C82_dzLS.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let useLocalLLMState, composeRefs, dispatchDiscreteCustomEvent, SessionTypeEnum, DismissableLayer, DefaultLoader, logDebug, useConstant, motionValue, useIsomorphicLayoutEffect, cancelFrame, frame, LazyIcon, MotionConfigContext, interpolate, collectMotionValues, Primitive, isMotionValue, React$1, Slot, frameData, animateValue, create, subscribeWithSelector, devtools, FlowNodeTypeEnum, VisuallyHidden, __vitePreload, ReactDOM$1, customAlphabet, React, toast, encodeCSVData, logWarn, encodeSplitter, VectorDatabaseTypeEnum, VectorDatabaseStorageEnum, VectorDatabaseProviderEnum, flowNodeTypeToEntity, process$1, DEFAULT_EMBEDDING_MODEL, ReactDOM, twMerge, cx, getAugmentedNamespace, commonjsRequire, require$$5, __viteBrowserExternal$1, SessionStatusEnum, logError, Runnable, HumanMessage, Serializable, AIMessage, decodeCSVData, SystemMessage, useLocalEmbeddingState, getStorageDataSource, textToSpeech, getDefaultExportFromCjs$1, clsx, dayjs, decodeLine, decodeSplitter, Document, MotionValue, nanoid, isDev, PresenceContext, LayoutGroupContext, commonjsGlobal, Buffer$1, require$$0, Buffer2, useControllableState, createContextScope, composeEventHandlers, Presence, useComposedRefs, cn, cva, useCallbackRef, jsxRuntimeExports, createContext2, Portal, reactDomExports, Slottable, Root, useTranslation, motion, reactExports, useSessionState, useAppState, useLayoutEffect2, create$1, useModal, useToast, getRepository, createCollection;
let __tla = (async () => {
  function _mergeNamespaces(n2, m2) {
    for (var i2 = 0; i2 < m2.length; i2++) {
      const e = m2[i2];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k2 in e) {
          if (k2 !== "default" && !(k2 in n2)) {
            const d = Object.getOwnPropertyDescriptor(e, k2);
            if (d) {
              Object.defineProperty(n2, k2, d.get ? d : {
                enumerable: true,
                get: () => e[k2]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, {
      value: "Module"
    }));
  }
  (function polyfill() {
    const relList = document.createElement("link").relList;
    if (relList && relList.supports && relList.supports("modulepreload")) {
      return;
    }
    for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
      processPreload(link);
    }
    new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type !== "childList") {
          continue;
        }
        for (const node of mutation.addedNodes) {
          if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
        }
      }
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function getFetchOpts(link) {
      const fetchOpts = {};
      if (link.integrity) fetchOpts.integrity = link.integrity;
      if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
      if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
      else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
      else fetchOpts.credentials = "same-origin";
      return fetchOpts;
    }
    function processPreload(link) {
      if (link.ep) return;
      link.ep = true;
      const fetchOpts = getFetchOpts(link);
      fetch(link.href, fetchOpts);
    }
  })();
  commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  getDefaultExportFromCjs$1 = function(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  };
  getAugmentedNamespace = function(n2) {
    if (n2.__esModule) return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a.prototype = f2.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", {
      value: true
    });
    Object.keys(n2).forEach(function(k2) {
      var d = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a, k2, d.get ? d : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a;
  };
  var jsxRuntime = {
    exports: {}
  };
  var reactJsxRuntime_production_min = {};
  var react = {
    exports: {}
  };
  var react_production_min = {};
  var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
  function A$1(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z$2 && a[z$2] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B$1 = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, C$1 = Object.assign, D$1 = {};
  function E$1(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D$1;
    this.updater = e || B$1;
  }
  E$1.prototype.isReactComponent = {};
  E$1.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E$1.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E$1.prototype;
  function G$1(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D$1;
    this.updater = e || B$1;
  }
  var H$1 = G$1.prototype = new F();
  H$1.constructor = G$1;
  C$1(H$1, E$1.prototype);
  H$1.isPureReactComponent = true;
  var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = {
    current: null
  }, L$1 = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function M$1(a, b, e) {
    var d, c = {}, k2 = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J.call(b, d) && !L$1.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f2 = Array(g), m2 = 0; m2 < g; m2++) f2[m2] = arguments[m2 + 2];
      c.children = f2;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return {
      $$typeof: l$1,
      type: a,
      key: k2,
      ref: h,
      props: c,
      _owner: K$1.current
    };
  }
  function N$1(a, b) {
    return {
      $$typeof: l$1,
      type: a.type,
      key: b,
      ref: a.ref,
      props: a.props,
      _owner: a._owner
    };
  }
  function O$1(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l$1;
  }
  function escape$1(a) {
    var b = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P$1 = /\/+/g;
  function Q$1(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape$1("" + a.key) : b.toString(36);
  }
  function R$1(a, b, e, d, c) {
    var k2 = typeof a;
    if ("undefined" === k2 || "boolean" === k2) a = null;
    var h = false;
    if (null === a) h = true;
    else switch (k2) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$1:
          case n$1:
            h = true;
        }
    }
    if (h) return h = a, c = c(h), a = "" === d ? "." + Q$1(h, 0) : d, I$1(c) ? (e = "", null != a && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O$1(c) && (c = N$1(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I$1(a)) for (var g = 0; g < a.length; g++) {
      k2 = a[g];
      var f2 = d + Q$1(k2, g);
      h += R$1(k2, b, e, f2, c);
    }
    else if (f2 = A$1(a), "function" === typeof f2) for (a = f2.call(a), g = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d + Q$1(k2, g++), h += R$1(k2, b, e, f2, c);
    else if ("object" === k2) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S$1(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R$1(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T$1(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U$1 = {
    current: null
  }, V$1 = {
    transition: null
  }, W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1
  };
  function X$1() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = {
    map: S$1,
    forEach: function(a, b, e) {
      S$1(a, function() {
        b.apply(this, arguments);
      }, e);
    },
    count: function(a) {
      var b = 0;
      S$1(a, function() {
        b++;
      });
      return b;
    },
    toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    },
    only: function(a) {
      if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    }
  };
  react_production_min.Component = E$1;
  react_production_min.Fragment = p$2;
  react_production_min.Profiler = r$1;
  react_production_min.PureComponent = G$1;
  react_production_min.StrictMode = q$1;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
  react_production_min.act = X$1;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C$1({}, a.props), c = a.key, k2 = a.ref, h = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k2 = b.ref, h = K$1.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f2 in b) J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d.children = e;
    else if (1 < f2) {
      g = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g[m2] = arguments[m2 + 2];
      d.children = g;
    }
    return {
      $$typeof: l$1,
      type: a.type,
      key: c,
      ref: k2,
      props: d,
      _owner: h
    };
  };
  react_production_min.createContext = function(a) {
    a = {
      $$typeof: u,
      _currentValue: a,
      _currentValue2: a,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    };
    a.Provider = {
      $$typeof: t$2,
      _context: a
    };
    return a.Consumer = a;
  };
  react_production_min.createElement = M$1;
  react_production_min.createFactory = function(a) {
    var b = M$1.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return {
      current: null
    };
  };
  react_production_min.forwardRef = function(a) {
    return {
      $$typeof: v$1,
      render: a
    };
  };
  react_production_min.isValidElement = O$1;
  react_production_min.lazy = function(a) {
    return {
      $$typeof: y,
      _payload: {
        _status: -1,
        _result: a
      },
      _init: T$1
    };
  };
  react_production_min.memo = function(a, b) {
    return {
      $$typeof: x,
      type: a,
      compare: void 0 === b ? null : b
    };
  };
  react_production_min.startTransition = function(a) {
    var b = V$1.transition;
    V$1.transition = {};
    try {
      a();
    } finally {
      V$1.transition = b;
    }
  };
  react_production_min.unstable_act = X$1;
  react_production_min.useCallback = function(a, b) {
    return U$1.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U$1.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U$1.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U$1.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U$1.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U$1.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U$1.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U$1.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U$1.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U$1.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U$1.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U$1.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U$1.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U$1.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  {
    react.exports = react_production_min;
  }
  reactExports = react.exports;
  React = getDefaultExportFromCjs$1(reactExports);
  React$1 = _mergeNamespaces({
    __proto__: null,
    default: React
  }, [
    reactExports
  ]);
  var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m$1.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return {
      $$typeof: k,
      type: c,
      key: e,
      ref: h,
      props: d,
      _owner: n.current
    };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  jsxRuntimeExports = jsxRuntime.exports;
  var reactDom = {
    exports: {}
  };
  var reactDom_production_min = {};
  var scheduler = {
    exports: {}
  };
  var scheduler_production_min = {};
  (function(exports) {
    function f2(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k2(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g(C2, c)) n2 < e && 0 > g(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n2 < e && 0 > g(x2, c)) a[d] = x2, a[n2] = c, d = n2;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a) {
      for (var b = h(t2); null !== b; ) {
        if (null === b.callback) k2(t2);
        else if (b.startTime <= a) k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
        else break;
        b = h(t2);
      }
    }
    function H2(a) {
      B2 = false;
      G2(a);
      if (!A2) if (null !== h(r2)) A2 = true, I2(J2);
      else {
        var b = h(t2);
        null !== b && K2(H2, b.startTime - a);
      }
    }
    function J2(a, b) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c = y2;
      try {
        G2(b);
        for (v2 = h(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
          var d = v2.callback;
          if ("function" === typeof d) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e = d(v2.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v2.callback = e : v2 === h(r2) && k2(r2);
            G2(b);
          } else k2(r2);
          v2 = h(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m2 = h(t2);
          null !== m2 && K2(H2, m2.startTime - b);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c, z2 = false;
      }
    }
    var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a = exports.unstable_now();
        Q2 = a;
        var b = true;
        try {
          b = O2(true, a);
        } finally {
          b ? S2() : (N2 = false, O2 = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F2) S2 = function() {
      F2(R2);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R2, 0);
    };
    function I2(a) {
      O2 = a;
      N2 || (N2 = true, S2());
    }
    function K2(a, b) {
      L2 = D2(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r2);
    };
    exports.unstable_next = function(a) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y2;
      }
      var c = y2;
      y2 = b;
      try {
        return a();
      } finally {
        y2 = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y2;
      y2 = a;
      try {
        return b();
      } finally {
        y2 = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = {
        id: u2++,
        callback: b,
        priorityLevel: a,
        startTime: c,
        expirationTime: e,
        sortIndex: -1
      };
      c > d ? (a.sortIndex = c, f2(t2, a), null === h(r2) && a === h(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
      return a;
    };
    exports.unstable_shouldYield = M2;
    exports.unstable_wrapCallback = function(a) {
      var b = y2;
      return function() {
        var c = y2;
        y2 = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y2 = c;
        }
      };
    };
  })(scheduler_production_min);
  {
    scheduler.exports = scheduler_production_min;
  }
  var schedulerExports = scheduler.exports;
  var aa = reactExports, ca = schedulerExports;
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
    if (d) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d, e, f2, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f2;
    this.removeEmptyString = g;
  }
  var z$1 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z$1[a] = new v(a, 0, false, a, null, false, false);
  });
  [
    [
      "acceptCharset",
      "accept-charset"
    ],
    [
      "className",
      "class"
    ],
    [
      "htmlFor",
      "for"
    ],
    [
      "httpEquiv",
      "http-equiv"
    ]
  ].forEach(function(a) {
    var b = a[0];
    z$1[b] = new v(b, 1, false, a[1], null, false, false);
  });
  [
    "contentEditable",
    "draggable",
    "spellCheck",
    "value"
  ].forEach(function(a) {
    z$1[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  [
    "autoReverse",
    "externalResourcesRequired",
    "focusable",
    "preserveAlpha"
  ].forEach(function(a) {
    z$1[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z$1[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  [
    "checked",
    "multiple",
    "muted",
    "selected"
  ].forEach(function(a) {
    z$1[a] = new v(a, 3, true, a, null, false, false);
  });
  [
    "capture",
    "download"
  ].forEach(function(a) {
    z$1[a] = new v(a, 4, false, a, null, false, false);
  });
  [
    "cols",
    "rows",
    "size",
    "span"
  ].forEach(function(a) {
    z$1[a] = new v(a, 6, false, a, null, false, false);
  });
  [
    "rowSpan",
    "start"
  ].forEach(function(a) {
    z$1[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z$1[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z$1[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  [
    "xml:base",
    "xml:lang",
    "xml:space"
  ].forEach(function(a) {
    var b = a.replace(ra, sa);
    z$1[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  [
    "tabIndex",
    "crossOrigin"
  ].forEach(function(a) {
    z$1[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z$1.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  [
    "src",
    "href",
    "action",
    "formAction"
  ].forEach(function(a) {
    z$1[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b, c, d) {
    var e = z$1.hasOwnProperty(b) ? z$1[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", {
        set: function() {
          throw Error();
        }
      }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l2) {
          d = l2;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d = l2;
        }
        a();
      }
    } catch (l2) {
      if (l2 && d && "string" === typeof l2.stack) {
        for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e.length - 1, h = f2.length - 1; 1 <= g && 0 <= h && e[g] !== f2[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f2[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f2[h]) {
                var k2 = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f2 = c.set;
      Object.defineProperty(a, b, {
        configurable: true,
        get: function() {
          return e.call(this);
        },
        set: function(a2) {
          d = "" + a2;
          f2.call(this, a2);
        }
      });
      Object.defineProperty(a, b, {
        enumerable: c.enumerable
      });
      return {
        getValue: function() {
          return d;
        },
        setValue: function(a2) {
          d = "" + a2;
        },
        stopTracking: function() {
          a._valueTracker = null;
          delete a[b];
        }
      };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: null != c ? c : a._wrapperState.initialChecked
    });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = {
      initialChecked: d,
      initialValue: c,
      controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
    };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (null != c) if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, {
      value: void 0,
      defaultValue: void 0,
      children: "" + a._wrapperState.initialValue
    });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = {
      initialValue: Sa(c)
    };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  }(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = [
    "Webkit",
    "ms",
    "Moz",
    "O"
  ];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({
    menuitem: true
  }, {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
  });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [
      a
    ] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", {
      get: function() {
        Lb = true;
      }
    });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d, e, f2, g, h, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = {
    onError: function(a) {
      Ob = true;
      Pb = a;
    }
  };
  function Tb(a, b, c, d, e, f2, g, h, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f2, g, h, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f2 = e.alternate;
      if (null === f2) {
        d = e.return;
        if (null !== d) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f2.child) {
        for (f2 = e.child; f2; ) {
          if (f2 === c) return Xb(e), a;
          if (f2 === d) return Xb(e), b;
          f2 = f2.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f2;
      else {
        for (var g = false, h = e.child; h; ) {
          if (h === c) {
            g = true;
            c = e;
            d = f2;
            break;
          }
          if (h === d) {
            g = true;
            d = e;
            c = f2;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f2.child; h; ) {
            if (h === c) {
              g = true;
              c = f2;
              d = e;
              break;
            }
            if (h === d) {
              g = true;
              d = f2;
              c = e;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d = tc(h) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
    } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240))) return b;
    0 !== (d & 4) && (d |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
      var g = 31 - oc(f2), h = 1 << g, k2 = e[g];
      if (-1 === k2) {
        if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
      } else k2 <= b && (a.expiredLanes |= h);
      f2 &= ~h;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f2 = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a[e] = -1;
      c &= ~f2;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f2) {
    if (null === a || a.nativeEvent !== f2) return a = {
      blockedOn: b,
      domEventName: c,
      eventSystemFlags: d,
      nativeEvent: f2,
      targetContainers: [
        e
      ]
    }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), true;
      case "pointerover":
        var f2 = e.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d, e));
        return true;
      case "gotpointercapture":
        return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d;
        c.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d) {
    var e = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f2;
    }
  }
  function gd(a, b, c, d) {
    var e = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f2;
    }
  }
  function fd(a, b, c, d) {
    if (dd) {
      var e = Yc(a, b, c, d);
      if (null === e) hd(a, b, d, id$2, c), Sc(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f2 = Cb(e);
          null !== f2 && Ec(f2);
          f2 = Yc(a, b, c, d);
          null === f2 && hd(a, b, d, id$2, c);
          if (f2 === e) break;
          e = f2;
        }
        null !== e && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id$2 = null;
  function Yc(a, b, c, d) {
    id$2 = null;
    a = xb(d);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id$2 = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d = 1; d <= g && b[c - d] === e[f2 - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d, e, f2, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f2;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      },
      stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      },
      persist: function() {
      },
      isPersistent: pd
    });
    return b;
  }
  var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, td = rd(sd), ud = A({}, sd, {
    view: 0,
    detail: 0
  }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function(a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    },
    movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    }
  }), Bd = rd(Ad), Cd = A({}, Ad, {
    dataTransfer: 0
  }), Dd = rd(Cd), Ed = A({}, ud, {
    relatedTarget: 0
  }), Fd = rd(Ed), Gd = A({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Hd = rd(Gd), Id = A({}, sd, {
    clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }), Jd = rd(Id), Kd = A({}, sd, {
    data: 0
  }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, {
    key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    },
    keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    },
    which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }
  }), Rd = rd(Qd), Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Td = rd(Sd), Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
  }), Vd = rd(Ud), Wd = A({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [
    9,
    13,
    27,
    32
  ], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
      event: c,
      listeners: b
    }));
  }
  var pe = null, qe = null;
  function re$3(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re$3, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d; c; ) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return {
          node: c,
          offset: b - a
        };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f2 = Math.min(d.start, e);
          d = void 0 === d.end ? f2 : Math.min(d.end, e);
          !a.extend && f2 > d && (e = d, d = f2, f2 = e);
          e = Ke(c, f2);
          var g = Ke(c, d);
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({
        element: a,
        left: a.scrollLeft,
        top: a.scrollTop
      });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = {
      start: d.selectionStart,
      end: d.selectionEnd
    } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
      anchorNode: d.anchorNode,
      anchorOffset: d.anchorOffset,
      focusNode: d.focusNode,
      focusOffset: d.focusOffset
    }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
      event: b,
      listeners: d
    }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
  }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [
      a
    ]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", [
    "mouseout",
    "mouseover"
  ]);
  ha("onMouseLeave", [
    "mouseout",
    "mouseover"
  ]);
  ha("onPointerEnter", [
    "pointerout",
    "pointerover"
  ]);
  ha("onPointerLeave", [
    "pointerout",
    "pointerover"
  ]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f2 = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k2 = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h, l2);
          f2 = k2;
        }
        else for (g = 0; g < d.length; g++) {
          h = d[g];
          k2 = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, false), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4);
    pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a.addEventListener(b, c, {
      capture: true,
      passive: e
    }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, {
      passive: e
    }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d, e) {
    var f2 = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k2 = g.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k2 = g.tag;
          if (5 === k2 || 6 === k2) {
            d = f2 = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f2, e2 = xb(c), g2 = [];
      a: {
        var h2 = df.get(a);
        if (void 0 !== h2) {
          var k3 = td, n2 = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
          t2 = [];
          for (var w2 = d2, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
            if (J2) break;
            w2 = w2.return;
          }
          0 < t2.length && (h2 = new k3(h2, n2, null, c, e2), g2.push({
            event: h2,
            listeners: t2
          }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a || "pointerover" === a;
          k3 = "mouseout" === a || "pointerout" === a;
          if (h2 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k3 || h2) {
            h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k3) {
              if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k3 = null, n2 = d2;
            if (k3 !== n2) {
              t2 = Bd;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h2 : ue(k3);
              u2 = null == n2 ? h2 : ue(n2);
              h2 = new t2(F2, w2 + "leave", k3, c, e2);
              h2.target = J2;
              h2.relatedTarget = u2;
              F2 = null;
              Wc(e2) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e2), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
              J2 = F2;
              if (k3 && n2) b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf(g2, h2, k3, t2, false);
              null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
            }
          }
        }
        a: {
          h2 = d2 ? ue(d2) : window;
          k3 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k3 = h2.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a, d2))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h2, d2);
          "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({
          event: ba,
          listeners: xa
        }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({
          event: e2,
          listeners: d2
        }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a, b, c) {
    return {
      instance: a,
      listener: b,
      currentTarget: c
    };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a; ) {
      var e = a, f2 = e.stateNode;
      5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e)), f2 = Kb(a, b), null != f2 && d.push(tf(a, f2, e)));
      a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d, e) {
    for (var f2 = b._reactName, g = []; null !== c && c !== d; ) {
      var h = c, k2 = h.alternate, l2 = h.stateNode;
      if (null !== k2 && k2 === d) break;
      5 === h.tag && null !== l2 && (h = l2, e ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h))) : e || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h))));
      c = c.return;
    }
    0 !== g.length && a.push({
      event: b,
      listeners: g
    });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return {
      current: a
    };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f2;
    for (f2 in c) e[f2] = b[f2];
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [
      a
    ] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var f2 = 32 - oc(b) + e;
    if (30 < f2) {
      var g = e - e % 5;
      f2 = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc(b) + e | c << e | d;
      sg = f2 + a;
    } else rg = 1 << f2 | c << e | d, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [
      c
    ], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? {
          id: rg,
          overflow: sg
        } : null, a.memoizedState = {
          dehydrated: b,
          treeContext: c,
          retryLane: 1073741824
        }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [
      a
    ] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f2 = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f2] : b2[f2] = a2;
        };
        b._stringRef = f2;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [
          c2
        ], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a) return null;
      for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f2(b2, c2, d2) {
      b2.index = d2;
      if (!a) return b2.flags |= 1048576, c2;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
      b2.flags |= 2;
      return c2;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a2, b2, c2, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function k2(a2, b2, c2, d2) {
      var f3 = c2.type;
      if (f3 === ya) return m2(a2, b2, c2.props.children, d2, c2.key);
      if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
      d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
      d2.ref = Lg(a2, b2, c2);
      d2.return = a2;
      return d2;
    }
    function l2(a2, b2, c2, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a2;
      return b2;
    }
    function m2(a2, b2, c2, d2, f3) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f3), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function q2(a2, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q2(a2, d2(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r2(a2, b2, c2, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k2(a2, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
          case Ha:
            return e2 = c2._init, r2(a2, b2, e2(c2._payload), d2);
        }
        if (eb(c2) || Ka(c2)) return null !== e2 ? null : m2(a2, b2, c2, d2, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y2(a2, b2, c2, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
          case Ha:
            var f3 = d2._init;
            return y2(a2, b2, c2, f3(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n2(e2, g2, h2, k3) {
      for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h2.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e2, u2, h2[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a && u2 && null === n3.alternate && b(e2, u2);
        g2 = f2(n3, g2, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h2.length) return c(e2, u2), I && tg(e2, w2), l3;
      if (null === u2) {
        for (; w2 < h2.length; w2++) u2 = q2(e2, h2[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I && tg(e2, w2);
        return l3;
      }
      for (u2 = d(e2, u2); w2 < h2.length; w2++) x2 = y2(u2, e2, w2, h2[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a && u2.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w2);
      return l3;
    }
    function t2(e2, g2, h2, k3) {
      var l3 = Ka(h2);
      if ("function" !== typeof l3) throw Error(p(150));
      h2 = l3.call(h2);
      if (null == h2) throw Error(p(151));
      for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h2.next(); null !== m3 && !n3.done; w2++, n3 = h2.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e2, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a && m3 && null === t3.alternate && b(e2, m3);
        g2 = f2(t3, g2, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done) return c(e2, m3), I && tg(e2, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h2.next()) n3 = q2(e2, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I && tg(e2, w2);
        return l3;
      }
      for (m3 = d(e2, m3); !n3.done; w2++, n3 = h2.next()) n3 = y2(m3, e2, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a && m3.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w2);
      return l3;
    }
    function J2(a2, d2, f3, h2) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d2; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c(a2, l3.sibling);
                      d2 = e(l3, f3.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c(a2, l3.sibling);
                    d2 = e(l3, f3.props);
                    d2.ref = Lg(a2, l3, f3);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                  c(a2, l3);
                  break;
                } else b(a2, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d2 = Tg(f3.props.children, a2.mode, h2, f3.key), d2.return = a2, a2 = d2) : (h2 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f3), h2.return = a2, a2 = h2);
            }
            return g(a2);
          case wa:
            a: {
              for (l3 = f3.key; null !== d2; ) {
                if (d2.key === l3) if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f3, a2.mode, h2);
              d2.return = a2;
              a2 = d2;
            }
            return g(a2);
          case Ha:
            return l3 = f3._init, J2(a2, d2, l3(f3._payload), h2);
        }
        if (eb(f3)) return n2(a2, d2, f3, h2);
        if (Ka(f3)) return t2(a2, d2, f3, h2);
        Mg(a2, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f3, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
    }
    return J2;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = {
      context: a,
      memoizedValue: b,
      next: null
    }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = {
        lanes: 0,
        firstContext: a
      };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [
      a
    ] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        interleaved: null,
        lanes: 0
      },
      effects: null
    };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = {
      baseState: a.baseState,
      firstBaseUpdate: a.firstBaseUpdate,
      lastBaseUpdate: a.lastBaseUpdate,
      shared: a.shared,
      effects: a.effects
    });
  }
  function mh(a, b) {
    return {
      eventTime: a,
      lane: b,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a, c);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null, f2 = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = {
            eventTime: c.eventTime,
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: c.callback,
            next: null
          };
          null === f2 ? e = f2 = g : f2 = f2.next = g;
          c = c.next;
        } while (null !== c);
        null === f2 ? e = f2 = b : f2 = f2.next = b;
      } else e = f2 = b;
      c = {
        baseState: d.baseState,
        firstBaseUpdate: e,
        lastBaseUpdate: f2,
        shared: d.shared,
        effects: d.effects
      };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = false;
    var f2 = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k2 = h, l2 = k2.next;
      k2.next = null;
      null === g ? f2 = l2 : g.next = l2;
      g = k2;
      var m2 = a.alternate;
      null !== m2 && (m2 = m2.updateQueue, h = m2.lastBaseUpdate, h !== g && (null === h ? m2.firstBaseUpdate = l2 : h.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e.baseState;
      g = 0;
      m2 = l2 = k2 = null;
      h = f2;
      do {
        var r2 = h.lane, y2 = h.eventTime;
        if ((d & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n2 = a, t2 = h;
            r2 = b;
            y2 = c;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q2 = A({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [
            h
          ] : r2.push(h));
        } else y2 = {
          eventTime: y2,
          lane: r2,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null
        }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
        h = h.next;
        if (null === h) if (h = e.shared.pending, null === h) break;
        else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e.baseState = k2;
      e.firstBaseUpdate = l2;
      e.lastBaseUpdate = m2;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f2 && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q2;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh$1 = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh$1, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh$1);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh$1, a), G(uh, c));
  }
  function Bh(a) {
    vh$1.current === a && (E(uh), E(vh$1));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d, e, f2) {
    Hh = f2;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d, e);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p(301));
        f2 += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = {
        memoizedState: N.memoizedState,
        baseState: N.baseState,
        baseQueue: N.baseQueue,
        queue: N.queue,
        next: null
      };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N, e = d.baseQueue, f2 = c.pending;
    if (null !== f2) {
      if (null !== e) {
        var g = e.next;
        e.next = f2.next;
        f2.next = g;
      }
      d.baseQueue = e = f2;
      c.pending = null;
    }
    if (null !== e) {
      f2 = e.next;
      d = d.baseState;
      var h = g = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = {
          lane: 0,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h = k2 = q2, g = d) : k2 = k2.next = q2;
          M.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g = d : k2.next = h;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k2;
      c.lastRenderedState = d;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f2 = e.lane, M.lanes |= f2, rh |= f2, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [
      b.memoizedState,
      c.dispatch
    ];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f2 = a(f2, g.action), g = g.next;
      while (g !== e);
      He(f2, b.memoizedState) || (dh = true);
      b.memoizedState = f2;
      null === b.baseQueue && (b.baseState = f2);
      c.lastRenderedState = f2;
    }
    return [
      f2,
      d
    ];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d = Uh(), e = b(), f2 = !He(d.memoizedState, e);
    f2 && (d.memoizedState = e, dh = true);
    d = d.queue;
    $h(ai.bind(null, c, d, a), [
      a
    ]);
    if (d.getSnapshot !== b || f2 || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = {
      getSnapshot: b,
      value: c
    };
    b = M.updateQueue;
    null === b ? (b = {
      lastEffect: null,
      stores: null
    }, M.updateQueue = b, b.stores = [
      a
    ]) : (c = b.stores, null === c ? b.stores = [
      a
    ] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c;
    b.getSnapshot = d;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Vh,
      lastRenderedState: a
    };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [
      b.memoizedState,
      a
    ];
  }
  function bi(a, b, c, d) {
    a = {
      tag: a,
      create: b,
      destroy: c,
      deps: d,
      next: null
    };
    b = M.updateQueue;
    null === b ? (b = {
      lastEffect: null,
      stores: null
    }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f2 = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f2 = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c, f2, d);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f2, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([
      a
    ]) : null;
    return li(4, 4, pi.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c.memoizedState = [
      a,
      b
    ];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [
      a,
      b
    ];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d = yi(a);
    c = {
      lane: d,
      action: c,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), null !== c) {
      var e = R();
      gi(c, a, d, e);
      Bi(c, b, d);
    }
  }
  function ii(a, b, c) {
    var d = yi(a), e = {
      lane: d,
      action: c,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (zi(a)) Ai(b, e);
    else {
      var f2 = a.alternate;
      if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2)) try {
        var g = b.lastRenderedState, h = f2(g, c);
        e.hasEagerState = true;
        e.eagerState = h;
        if (He(h, g)) {
          var k2 = b.interleaved;
          null === k2 ? (e.next = e, gh(b)) : (e.next = k2.next, k2.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c = hh(a, b, e, d);
      null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = {
    readContext: eh,
    useCallback: P,
    useContext: P,
    useEffect: P,
    useImperativeHandle: P,
    useInsertionEffect: P,
    useLayoutEffect: P,
    useMemo: P,
    useReducer: P,
    useRef: P,
    useState: P,
    useDebugValue: P,
    useDeferredValue: P,
    useTransition: P,
    useMutableSource: P,
    useSyncExternalStore: P,
    useId: P,
    unstable_isNewReconciler: false
  }, Oh = {
    readContext: eh,
    useCallback: function(a, b) {
      Th().memoizedState = [
        a,
        void 0 === b ? null : b
      ];
      return a;
    },
    useContext: eh,
    useEffect: mi,
    useImperativeHandle: function(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([
        a
      ]) : null;
      return ki(4194308, 4, pi.bind(null, b, a), c);
    },
    useLayoutEffect: function(a, b) {
      return ki(4194308, 4, a, b);
    },
    useInsertionEffect: function(a, b) {
      return ki(4, 2, a, b);
    },
    useMemo: function(a, b) {
      var c = Th();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [
        a,
        b
      ];
      return a;
    },
    useReducer: function(a, b, c) {
      var d = Th();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: b
      };
      d.queue = a;
      a = a.dispatch = xi.bind(null, M, a);
      return [
        d.memoizedState,
        a
      ];
    },
    useRef: function(a) {
      var b = Th();
      a = {
        current: a
      };
      return b.memoizedState = a;
    },
    useState: hi,
    useDebugValue: ri,
    useDeferredValue: function(a) {
      return Th().memoizedState = a;
    },
    useTransition: function() {
      var a = hi(false), b = a[0];
      a = vi.bind(null, a[1]);
      Th().memoizedState = a;
      return [
        b,
        a
      ];
    },
    useMutableSource: function() {
    },
    useSyncExternalStore: function(a, b, c) {
      var d = M, e = Th();
      if (I) {
        if (void 0 === c) throw Error(p(407));
        c = c();
      } else {
        c = b();
        if (null === Q) throw Error(p(349));
        0 !== (Hh & 30) || di(d, b, c);
      }
      e.memoizedState = c;
      var f2 = {
        value: c,
        getSnapshot: b
      };
      e.queue = f2;
      mi(ai.bind(null, d, f2, a), [
        a
      ]);
      d.flags |= 2048;
      bi(9, ci.bind(null, d, f2, c, b), void 0, null);
      return c;
    },
    useId: function() {
      var a = Th(), b = Q.identifierPrefix;
      if (I) {
        var c = sg;
        var d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
        b = ":" + b + "R" + c;
        c = Kh++;
        0 < c && (b += "H" + c.toString(32));
        b += ":";
      } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    },
    unstable_isNewReconciler: false
  }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [
        a,
        b
      ];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function() {
      return Xh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Xh(Vh)[0], b = Uh().memoizedState;
      return [
        a,
        b
      ];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = {
    isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    },
    enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f2 = mh(d, e);
      f2.payload = b;
      void 0 !== c && null !== c && (f2.callback = c);
      b = nh(a, f2, e);
      null !== b && (gi(b, a, e, d), oh(b, a, e));
    },
    enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f2 = mh(d, e);
      f2.tag = 1;
      f2.payload = b;
      void 0 !== c && null !== c && (f2.callback = c);
      b = nh(a, f2, e);
      null !== b && (gi(b, a, e, d), oh(b, a, e));
    },
    enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = R(), d = yi(a), e = mh(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      b = nh(a, e, d);
      null !== b && (gi(b, a, d, c), oh(b, a, d));
    }
  };
  function Fi(a, b, c, d, e, f2, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f2) : true;
  }
  function Gi(a, b, c) {
    var d = false, e = Vf;
    var f2 = b.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
    b = new b(c, f2);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
    return b;
  }
  function Hi(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f2 = b.contextType;
    "object" === typeof f2 && null !== f2 ? e.context = eh(f2) : (f2 = Zf(b) ? Xf : H.current, e.context = Yf(a, f2));
    e.state = a.memoizedState;
    f2 = b.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a, b, f2, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f2) {
      e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return {
      value: a,
      source: b,
      stack: e,
      digest: null
    };
  }
  function Ki(a, b, c) {
    return {
      value: a,
      source: null,
      stack: null != c ? c : null,
      digest: null != b ? b : null
    };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = {
      element: null
    };
    var d = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f2 = a.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([
        this
      ]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, {
        componentStack: null !== c2 ? c2 : ""
      });
    });
    return c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (null === d) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b, c, d) {
    b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f2 = b.ref;
    ch(b, e);
    d = Nh(a, b, c, d, f2, e);
    c = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d, e);
    return b.child;
  }
  function $i(a, b, c, d, e) {
    if (null === a) {
      var f2 = c.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f2, bj(a, b, f2, d, e);
      a = Rg(c.type, null, d, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f2 = a.child;
    if (0 === (a.lanes & e)) {
      var g = f2.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f2, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (null !== a) {
      var f2 = a.memoizedProps;
      if (Ie(f2, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f2, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f2 = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
        baseLanes: a,
        cachePool: null,
        transitions: null
      }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      };
      d = null !== f2 ? f2.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
    else null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d, e) {
    var f2 = Zf(c) ? Xf : H.current;
    f2 = Yf(b, f2);
    ch(b, e);
    c = Nh(a, b, c, d, f2, e);
    d = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f2 = true;
      cg(b);
    } else f2 = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
    else if (null === a) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k2 = g.context, l2 = c.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b, l2));
      var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k2 !== l2) && Hi(b, g, d, l2);
      jh = false;
      var r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e);
      k2 = b.memoizedState;
      h !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c, m2, d), k2 = b.memoizedState), (h = jh || Fi(b, c, h, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h = b.memoizedProps;
      l2 = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l2;
      q2 = b.pendingProps;
      r2 = g.context;
      k2 = c.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b, k2));
      var y2 = c.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q2 || r2 !== k2) && Hi(b, g, d, k2);
      jh = false;
      r2 = b.memoizedState;
      g.state = r2;
      qh(b, d, g, e);
      var n2 = b.memoizedState;
      h !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c, y2, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a, b, c, d, f2, e);
  }
  function jj(a, b, c, d, e, f2) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c, false), Zi(a, b, f2);
    d = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f2), b.child = Ug(b, null, h, f2)) : Xi(a, b, h, f2);
    b.memoizedState = d.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d);
    return b.child;
  }
  var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
  };
  function nj(a) {
    return {
      baseLanes: a,
      cachePool: null,
      transitions: null
    };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L.current, f2 = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h) f2 = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a = d.fallback;
      return f2 ? (d = b.mode, f2 = b.child, g = {
        mode: "hidden",
        children: g
      }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = pj(g, d, 0, null), a = Tg(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
    if (f2) {
      f2 = d.fallback;
      g = b.mode;
      e = a.child;
      h = e.sibling;
      var k2 = {
        mode: "hidden",
        children: d.children
      };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h ? f2 = Pg(h, f2) : (f2 = Tg(f2, g, c, null), f2.flags |= 2);
      f2.return = b;
      d.return = b;
      d.sibling = f2;
      b.child = d;
      d = f2;
      f2 = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : {
        baseLanes: g.baseLanes | c,
        cachePool: null,
        transitions: g.transitions
      };
      f2.memoizedState = g;
      f2.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d;
    }
    f2 = a.child;
    a = f2.sibling;
    d = Pg(f2, {
      mode: "visible",
      children: d.children
    });
    0 === (b.mode & 1) && (d.lanes = c);
    d.return = b;
    d.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [
      a
    ], b.flags |= 16) : c.push(a));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a, b) {
    b = pj({
      mode: "visible",
      children: b
    }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d) {
    null !== d && Jg(d);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d, e, f2, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f2 = d.fallback;
      e = b.mode;
      d = pj({
        mode: "visible",
        children: d.children
      }, e, 0, null);
      f2 = Tg(f2, e, g, null);
      f2.flags |= 2;
      d.return = b;
      f2.return = b;
      d.sibling = f2;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f2;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h = d.dgst;
      d = h;
      f2 = Error(p(419));
      d = Ki(f2, d, void 0);
      return sj(a, b, g, d);
    }
    h = 0 !== (g & a.childLanes);
    if (dh || h) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f2.retryLane && (f2.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f2.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    null !== d && (d.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f2 = a.memoizedState;
    null === f2 ? a.memoizedState = {
      isBackwards: b,
      rendering: null,
      renderingStartTime: 0,
      last: d,
      tail: c,
      tailMode: e
    } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
    Xi(a, b, d.children, c);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f2);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f2);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f2 = [];
          break;
        case "select":
          e = A({}, e, {
            value: void 0
          });
          d = A({}, d, {
            value: void 0
          });
          f2 = [];
          break;
        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f2 = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
      }
      ub(c, d);
      var g;
      c = null;
      for (l2 in e) if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2]) if ("style" === l2) {
        var h = e[l2];
        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d) {
        var k2 = d[l2];
        h = null != e ? e[l2] : void 0;
        if (d.hasOwnProperty(l2) && k2 !== h && (null != k2 || null != h)) if ("style" === l2) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k2) k2.hasOwnProperty(g) && h[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
        } else c || (f2 || (f2 = []), f2.push(l2, c)), c = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h = h ? h.__html : void 0, null != k2 && h !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c && (f2 = f2 || []).push("style", c);
      var l2 = f2;
      if (b.updateQueue = l2) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.type;
            var f2 = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f2;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D("error", d);
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f2);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = {
                  wasMultiple: !!f2.multiple
                };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f2), D("invalid", d);
            }
            ub(c, f2);
            e = null;
            for (var g in f2) if (f2.hasOwnProperty(g)) {
              var h = f2[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f2.suppressHydrationWarning && Af(d.textContent, h, a), e = [
                "children",
                h
              ]) : "number" === typeof h && d.textContent !== "" + h && (true !== f2.suppressHydrationWarning && Af(d.textContent, h, a), e = [
                "children",
                "" + h
              ]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d);
                db(d, f2, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
              is: d.is
            }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D("error", a);
                  D("load", a);
                  e = d;
                  break;
                case "details":
                  D("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  D("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = {
                    wasMultiple: !!d.multiple
                  };
                  e = A({}, d, {
                    value: void 0
                  });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  D("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e);
              h = e;
              for (f2 in h) if (h.hasOwnProperty(f2)) {
                var k2 = h[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f2 = d.value;
                  null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.memoizedProps;
            d[Of] = b;
            if (f2 = d.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f2 && (b.flags |= 4);
          } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f2 = false;
          else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a) {
              if (!f2) throw Error(p(318));
              f2 = b.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p(317));
              f2[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f2 = false;
          } else null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d = null !== d;
        d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f2 = b.memoizedState;
        if (null === f2) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f2.rendering;
        if (null === g) if (d) Dj(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f2, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c; ) f2 = c, a = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : {
                lanes: a.lanes,
                firstContext: a.firstContext
              }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f2.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
          f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f2.last, null !== c ? c.sibling = g : b.child = g, f2.last = g);
        }
        if (null !== f2.tail) return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d) {
      W(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W(a, b, d);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = {
        start: a.selectionStart,
        end: a.selectionEnd
      };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f2 = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (F2) {
            c = null;
            break a;
          }
          var g = 0, h = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q2 !== c || 0 !== e && 3 !== q2.nodeType || (h = g + e);
              q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
              3 === q2.nodeType && (g += q2.nodeValue.length);
              if (null === (y2 = q2.firstChild)) break;
              r2 = q2;
              q2 = y2;
            }
            for (; ; ) {
              if (q2 === a) break b;
              r2 === c && ++l2 === e && (h = g);
              r2 === f2 && ++m2 === d && (k2 = g);
              if (null !== (y2 = q2.nextSibling)) break;
              q2 = r2;
              r2 = q2.parentNode;
            }
            q2 = y2;
          }
          c = -1 === h || -1 === k2 ? null : {
            start: h,
            end: k2
          };
        } else c = null;
      }
      c = c || {
        start: 0,
        end: 0
      };
    } else c = null;
    Df = {
      focusedElem: a,
      selectionRange: c
    };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
    else for (; null !== V; ) {
      b = V;
      try {
        var n2 = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F2) {
        W(b, b.return, F2);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }
      V = b.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f2 = e.destroy;
          e.destroy = void 0;
          void 0 !== f2 && Mj(b, c, f2);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d = X, e = Xj;
        X = null;
        Yj(a, b, c);
        X = d;
        Xj = e;
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
        break;
      case 4:
        d = X;
        e = Xj;
        X = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f2 = e, g = f2.destroy;
            f2 = f2.tag;
            void 0 !== g && (0 !== (f2 & 2) ? Mj(c, b, g) : 0 !== (f2 & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h) {
          W(c, b, h);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f2 = a, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f2, g, e);
        X = null;
        Xj = false;
        var k2 = e.alternate;
        null !== k2 && (k2.return = null);
        e.return = null;
      } catch (l2) {
        W(e, b, l2);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t2) {
            W(a, a.return, t2);
          }
          try {
            Pj(5, a, a.return);
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        if (d & 4 && (e = a.stateNode, null != e)) {
          var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h = a.type, k2 = a.updateQueue;
          a.updateQueue = null;
          if (null !== k2) try {
            "input" === h && "radio" === f2.type && null != f2.name && ab(e, f2);
            vb(h, g);
            var l2 = vb(h, f2);
            for (g = 0; g < k2.length; g += 2) {
              var m2 = k2[g], q2 = k2[g + 1];
              "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
            }
            switch (h) {
              case "input":
                bb(e, f2);
                break;
              case "textarea":
                ib(e, f2);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(e, !!f2.multiple, f2.defaultValue, true) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f2 = a.memoizedProps;
          try {
            e.nodeValue = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a);
        break;
      case 22:
        m2 = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l2 = U) || m2, ck(b, a), U = l2) : ck(b, a);
        ek(a);
        if (d & 8192) {
          l2 = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d = r2;
                    c = r2.return;
                    try {
                      b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d, c, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h.style.display = rb("display", g));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2) try {
                q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
              } catch (t2) {
                W(a, a.return, t2);
              }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a) break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a) break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(b, a), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f2 = Uj(a);
            Wj(a, f2, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h = Uj(a);
            Vj(a, h, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k2) {
        W(a, a.return, k2);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d = 0 !== (a.mode & 1); null !== V; ) {
      var e = V, f2 = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h = e.alternate, k2 = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l2 = U;
          Jj = g;
          if ((U = k2) && !l2) for (V = e; null !== V; ) g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k2 ? (k2.return = g, V = k2) : jk(e);
          for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
          V = e;
          Jj = h;
          U = l2;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b.updateQueue;
              null !== f2 && sh(b, f2, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h;
                var k2 = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l2 = b.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r2) {
          W(b, b.return, r2);
        }
      }
      if (b === a) {
        V = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b = V;
      if (b === a) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k2) {
              W(b, c, k2);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k2) {
                W(b, e, k2);
              }
            }
            var f2 = b.return;
            try {
              Rj(b);
            } catch (k2) {
              W(b, f2, k2);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k2) {
              W(b, g, k2);
            }
        }
      } catch (k2) {
        W(b, b.return, k2);
      }
      if (b === a) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V = h;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f2 = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a, h);
        }
      while (1);
      $g();
      mk.current = f2;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      if (6 === b) Ck(a, d);
      else {
        e = a.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f2 = xc(a), 0 !== f2 && (d = f2, b = Nk(a, f2))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d);
            if ((d & 4194240) === d) break;
            b = a.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f2 = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f2;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk, tk = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f2 = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f2(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d = xc(a);
      0 !== d && (b = d, c = Nk(a, d));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f2 = c.pending;
        if (null !== f2) {
          var g = f2.next;
          f2.next = e;
          d.next = g;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f2 = a, g = c.return, h = c, k2 = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g, h, f2, b);
              y2.mode & 1 && Si(f2, l2, b);
              b = y2;
              k2 = l2;
              var n2 = b.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b.updateQueue = t2;
              } else n2.add(k2);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f2, l2, b);
                tj();
                break a;
              }
              k2 = Error(p(426));
            }
          } else if (I && h.mode & 1) {
            var J2 = Ui(g);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi(J2, g, h, f2, b);
              Jg(Ji(k2, h));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h);
          4 !== T && (T = 2);
          null === sk ? sk = [
            f2
          ] : sk.push(f2);
          f2 = g;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var x2 = Ni(f2, k2, b);
                ph(f2, x2);
                break a;
              case 1:
                h = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b &= -b;
                  f2.lanes |= b;
                  var F2 = Qi(f2, h, b);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b, c, d);
    } finally {
      ok.transition = e, C = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f2 = c.lanes | c.childLanes;
    Bc(a, f2);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h;
      C = g;
      ok.transition = f2;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f2 = a.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, {
      componentStack: e.stack,
      digest: e.digest
    });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f2 = a.pendingLanes;
    0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f2 = V, g = f2.child;
            if (0 !== (V.flags & 16)) {
              var h = f2.deletions;
              if (null !== h) {
                for (var k2 = 0; k2 < h.length; k2++) {
                  var l2 = h[k2];
                  for (V = l2; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2) q2.return = m2, V = q2;
                    else for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g) g.return = f2, V = g;
            else b: for (; null !== V; ) {
              f2 = V;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V = x2;
                break b;
              }
              V = f2.return;
            }
          }
          var w2 = a.current;
          for (V = w2; null !== V; ) {
            g = V;
            var u2 = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u2) u2.return = g, V = u2;
            else b: for (g = w2; null !== V; ) {
              h = V;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V = null;
                break b;
              }
              var F2 = h.sibling;
              if (null !== F2) {
                F2.return = h.return;
                V = F2;
                break b;
              }
              V = h.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d, a, e, c);
        var f2 = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f2, c)) : (b.tag = 0, I && f2 && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a = Ci(d, a);
          switch (e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(306, d, ""));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d = b.pendingProps;
          f2 = b.memoizedState;
          e = f2.element;
          lh(a, b);
          qh(b, d, null, c);
          var g = b.memoizedState;
          d = g.element;
          if (f2.isDehydrated) if (f2 = {
            element: d,
            isDehydrated: false,
            cache: g.cache,
            pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
            transitions: g.transitions
          }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f2 = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f2) if (He(f2.value, g)) {
            if (f2.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
            var h = f2.dependencies;
            if (null !== h) {
              g = f2.child;
              for (var k2 = h.firstContext; null !== k2; ) {
                if (k2.context === d) {
                  if (1 === f2.tag) {
                    k2 = mh(-1, c & -c);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c);
                  bh(f2.return, c, b);
                  h.lanes |= c;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g = f2.type === b.type ? null : f2.child;
            else if (18 === f2.tag) {
              g = f2.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h = g.alternate;
              null !== h && (h.lanes |= c);
              bh(g, c, b);
              g = f2.sibling;
            } else g = f2.child;
            if (null !== g) g.return = f2;
            else for (g = f2; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f2 = g.sibling;
              if (null !== f2) {
                f2.return = g.return;
                g = f2;
                break;
              }
              g = g.return;
            }
            f2 = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : {
      lanes: b.lanes,
      firstContext: b.firstContext
    };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d, e, f2) {
    var g = 2;
    d = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f2, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f2, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f2, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f2, a;
      case Ia:
        return pj(c, e, f2, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f2;
    return b;
  }
  function Tg(a, b, c, d) {
    a = Bg(7, a, d, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d) {
    a = Bg(22, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = {
      isHidden: false
    };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    };
    return b;
  }
  function al(a, b, c, d, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f2, g, h, k2) {
    a = new al(a, b, c, h, k2);
    1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
    f2 = Bg(3, null, null, b);
    a.current = f2;
    f2.stateNode = a;
    f2.memoizedState = {
      element: d,
      isDehydrated: c,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    };
    kh(f2);
    return a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: wa,
      key: null == d ? null : "" + d,
      children: a,
      containerInfo: b,
      implementation: c
    };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el(a, b, c, d, e, f2, g, h, k2) {
    a = bl(c, d, true, a, e, f2, g, h, k2);
    a.context = dl(null);
    c = a.current;
    d = R();
    e = yi(c);
    f2 = mh(d, e);
    f2.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f2, e);
    a.current.lanes = e;
    Ac(a, e, d);
    Dk(a, d);
    return a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f2 = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f2, g);
    b.payload = {
      element: a
    };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f2), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = {
        blockedOn: null,
        target: a,
        priority: b
      };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f2 = d;
        d = function() {
          var a2 = gl(g);
          f2.call(a2);
        };
      }
      var g = el(b, d, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d) {
      var h = d;
      d = function() {
        var a2 = gl(k2);
        h.call(a2);
      };
    }
    var k2 = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k2;
    a[uf] = k2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k2, c, d);
    });
    return k2;
  }
  function rl(a, b, c, d, e) {
    var f2 = c._reactRootContainer;
    if (f2) {
      var g = f2;
      if ("function" === typeof e) {
        var h = e;
        e = function() {
          var a2 = gl(g);
          h.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c2 = R();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d = R();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b) {
    var c = C;
    try {
      return C = a, b();
    } finally {
      C = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = {
    usingClientEntryPoint: false,
    Events: [
      Cb,
      ue,
      Db,
      Eb,
      Fb,
      Qk
    ]
  }, tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
  };
  var ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
  };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f2 = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el(b, null, a, 1, null != c ? c : null, e, false, f2, g);
    a[uf] = b.current;
    sf(a);
    if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [
      c,
      e
    ] : b.mutableSourceEagerHydrationData.push(c, e);
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }
  reactDomExports = reactDom.exports;
  ReactDOM = getDefaultExportFromCjs$1(reactDomExports);
  ReactDOM$1 = _mergeNamespaces({
    __proto__: null,
    default: ReactDOM
  }, [
    reactDomExports
  ]);
  var createRoot;
  var m = reactDomExports;
  {
    createRoot = m.createRoot;
    m.hydrateRoot;
  }
  const scriptRel = "modulepreload";
  const assetsURL = function(dep) {
    return "/NoLLMChat/" + dep;
  };
  const seen = {};
  __vitePreload = function preload(baseModule, deps, importerUrl) {
    let promise = Promise.resolve();
    if (deps && deps.length > 0) {
      document.getElementsByTagName("link");
      const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
      const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
      promise = Promise.all(deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
          link.crossOrigin = "";
        }
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
          });
        }
      }));
    }
    return promise.then(() => baseModule()).catch((err) => {
      const e = new Event("vite:preloadError", {
        cancelable: true
      });
      e.payload = err;
      window.dispatchEvent(e);
      if (!e.defaultPrevented) {
        throw err;
      }
    });
  };
  const consoleLogger = {
    type: "logger",
    log(args) {
      this.output("log", args);
    },
    warn(args) {
      this.output("warn", args);
    },
    error(args) {
      this.output("error", args);
    },
    output(type, args) {
      if (console && console[type]) console[type].apply(console, args);
    }
  };
  class Logger {
    constructor(concreteLogger) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.init(concreteLogger, options);
    }
    init(concreteLogger) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
    log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
    warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
    error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
    deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
    forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === "string") args[0] = `${prefix}${this.prefix} ${args[0]}`;
      return this.logger[lvl](args);
    }
    create(moduleName) {
      return new Logger(this.logger, {
        ...{
          prefix: `${this.prefix}:${moduleName}:`
        },
        ...this.options
      });
    }
    clone(options) {
      options = options || this.options;
      options.prefix = options.prefix || this.prefix;
      return new Logger(this.logger, options);
    }
  }
  var baseLogger = new Logger();
  let EventEmitter$1 = class EventEmitter {
    constructor() {
      this.observers = {};
    }
    on(events, listener) {
      events.split(" ").forEach((event) => {
        if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
        const numListeners = this.observers[event].get(listener) || 0;
        this.observers[event].set(listener, numListeners + 1);
      });
      return this;
    }
    off(event, listener) {
      if (!this.observers[event]) return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event].delete(listener);
    }
    emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        const cloned = Array.from(this.observers[event].entries());
        cloned.forEach((_ref) => {
          let [observer, numTimesAdded] = _ref;
          for (let i2 = 0; i2 < numTimesAdded; i2++) {
            observer(...args);
          }
        });
      }
      if (this.observers["*"]) {
        const cloned = Array.from(this.observers["*"].entries());
        cloned.forEach((_ref2) => {
          let [observer, numTimesAdded] = _ref2;
          for (let i2 = 0; i2 < numTimesAdded; i2++) {
            observer.apply(observer, [
              event,
              ...args
            ]);
          }
        });
      }
    }
  };
  const defer = () => {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    promise.resolve = res;
    promise.reject = rej;
    return promise;
  };
  const makeString = (object) => {
    if (object == null) return "";
    return "" + object;
  };
  const copy = (a, s, t2) => {
    a.forEach((m2) => {
      if (s[m2]) t2[m2] = s[m2];
    });
  };
  const lastOfPathSeparatorRegExp = /###/g;
  const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
  const canNotTraverseDeeper = (object) => !object || typeof object === "string";
  const getLastOfPath = (object, path, Empty) => {
    const stack = typeof path !== "string" ? path : path.split(".");
    let stackIndex = 0;
    while (stackIndex < stack.length - 1) {
      if (canNotTraverseDeeper(object)) return {};
      const key = cleanKey(stack[stackIndex]);
      if (!object[key] && Empty) object[key] = new Empty();
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        object = object[key];
      } else {
        object = {};
      }
      ++stackIndex;
    }
    if (canNotTraverseDeeper(object)) return {};
    return {
      obj: object,
      k: cleanKey(stack[stackIndex])
    };
  };
  const setPath = (object, path, newValue) => {
    const { obj, k: k2 } = getLastOfPath(object, path, Object);
    if (obj !== void 0 || path.length === 1) {
      obj[k2] = newValue;
      return;
    }
    let e = path[path.length - 1];
    let p2 = path.slice(0, path.length - 1);
    let last = getLastOfPath(object, p2, Object);
    while (last.obj === void 0 && p2.length) {
      e = `${p2[p2.length - 1]}.${e}`;
      p2 = p2.slice(0, p2.length - 1);
      last = getLastOfPath(object, p2, Object);
      if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
        last.obj = void 0;
      }
    }
    last.obj[`${last.k}.${e}`] = newValue;
  };
  const pushPath = (object, path, newValue, concat2) => {
    const { obj, k: k2 } = getLastOfPath(object, path, Object);
    obj[k2] = obj[k2] || [];
    obj[k2].push(newValue);
  };
  const getPath = (object, path) => {
    const { obj, k: k2 } = getLastOfPath(object, path);
    if (!obj) return void 0;
    return obj[k2];
  };
  const getPathWithDefaults = (data, defaultData, key) => {
    const value = getPath(data, key);
    if (value !== void 0) {
      return value;
    }
    return getPath(defaultData, key);
  };
  const deepExtend = (target, source, overwrite) => {
    for (const prop in source) {
      if (prop !== "__proto__" && prop !== "constructor") {
        if (prop in target) {
          if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
            if (overwrite) target[prop] = source[prop];
          } else {
            deepExtend(target[prop], source[prop], overwrite);
          }
        } else {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  };
  const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
  };
  const escape = (data) => {
    if (typeof data === "string") {
      return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
    }
    return data;
  };
  class RegExpCache {
    constructor(capacity) {
      this.capacity = capacity;
      this.regExpMap = /* @__PURE__ */ new Map();
      this.regExpQueue = [];
    }
    getRegExp(pattern) {
      const regExpFromCache = this.regExpMap.get(pattern);
      if (regExpFromCache !== void 0) {
        return regExpFromCache;
      }
      const regExpNew = new RegExp(pattern);
      if (this.regExpQueue.length === this.capacity) {
        this.regExpMap.delete(this.regExpQueue.shift());
      }
      this.regExpMap.set(pattern, regExpNew);
      this.regExpQueue.push(pattern);
      return regExpNew;
    }
  }
  const chars = [
    " ",
    ",",
    "?",
    "!",
    ";"
  ];
  const looksLikeObjectPathRegExpCache = new RegExpCache(20);
  const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
    nsSeparator = nsSeparator || "";
    keySeparator = keySeparator || "";
    const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
    if (possibleChars.length === 0) return true;
    const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
    let matched = !r2.test(key);
    if (!matched) {
      const ki2 = key.indexOf(keySeparator);
      if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
        matched = true;
      }
    }
    return matched;
  };
  const deepFind = function(obj, path) {
    let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (!obj) return void 0;
    if (obj[path]) return obj[path];
    const tokens = path.split(keySeparator);
    let current = obj;
    for (let i2 = 0; i2 < tokens.length; ) {
      if (!current || typeof current !== "object") {
        return void 0;
      }
      let next;
      let nextPath = "";
      for (let j = i2; j < tokens.length; ++j) {
        if (j !== i2) {
          nextPath += keySeparator;
        }
        nextPath += tokens[j];
        next = current[nextPath];
        if (next !== void 0) {
          if ([
            "string",
            "number",
            "boolean"
          ].indexOf(typeof next) > -1 && j < tokens.length - 1) {
            continue;
          }
          i2 += j - i2 + 1;
          break;
        }
      }
      current = next;
    }
    return current;
  };
  const getCleanedCode = (code2) => {
    if (code2 && code2.indexOf("_") > 0) return code2.replace("_", "-");
    return code2;
  };
  class ResourceStore extends EventEmitter$1 {
    constructor(data) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        ns: [
          "translation"
        ],
        defaultNS: "translation"
      };
      super();
      this.data = data || {};
      this.options = options;
      if (this.options.keySeparator === void 0) {
        this.options.keySeparator = ".";
      }
      if (this.options.ignoreJSONStructure === void 0) {
        this.options.ignoreJSONStructure = true;
      }
    }
    addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
    removeNamespaces(ns) {
      const index2 = this.options.ns.indexOf(ns);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
    getResource(lng, ns, key) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      let path;
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      } else {
        path = [
          lng,
          ns
        ];
        if (key) {
          if (Array.isArray(key)) {
            path.push(...key);
          } else if (typeof key === "string" && keySeparator) {
            path.push(...key.split(keySeparator));
          } else {
            path.push(key);
          }
        }
      }
      const result = getPath(this.data, path);
      if (!result && !ns && !key && lng.indexOf(".") > -1) {
        lng = path[0];
        ns = path[1];
        key = path.slice(2).join(".");
      }
      if (result || !ignoreJSONStructure || typeof key !== "string") return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
    addResource(lng, ns, key, value) {
      let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      let path = [
        lng,
        ns
      ];
      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent) this.emit("added", lng, ns, key, value);
    }
    addResources(lng, ns, resources2) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (const m2 in resources2) {
        if (typeof resources2[m2] === "string" || Array.isArray(resources2[m2])) this.addResource(lng, ns, m2, resources2[m2], {
          silent: true
        });
      }
      if (!options.silent) this.emit("added", lng, ns, resources2);
    }
    addResourceBundle(lng, ns, resources2, deep, overwrite) {
      let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false,
        skipCopy: false
      };
      let path = [
        lng,
        ns
      ];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources2;
        resources2 = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      let pack = getPath(this.data, path) || {};
      if (!options.skipCopy) resources2 = JSON.parse(JSON.stringify(resources2));
      if (deep) {
        deepExtend(pack, resources2, overwrite);
      } else {
        pack = {
          ...pack,
          ...resources2
        };
      }
      setPath(this.data, path, pack);
      if (!options.silent) this.emit("added", lng, ns, resources2);
    }
    removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
    hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
    getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1") return {
        ...{},
        ...this.getResource(lng, ns)
      };
      return this.getResource(lng, ns);
    }
    getDataByLanguage(lng) {
      return this.data[lng];
    }
    hasLanguageSomeTranslations(lng) {
      const data = this.getDataByLanguage(lng);
      const n2 = data && Object.keys(data) || [];
      return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
    }
    toJSON() {
      return this.data;
    }
  }
  var postProcessor = {
    processors: {},
    addPostProcessor(module2) {
      this.processors[module2.name] = module2;
    },
    handle(processors, value, key, options, translator) {
      processors.forEach((processor) => {
        if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);
      });
      return value;
    }
  };
  const checkedLoadedFor = {};
  class Translator extends EventEmitter$1 {
    constructor(services) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super();
      copy([
        "resourceStore",
        "languageUtils",
        "pluralResolver",
        "interpolator",
        "backendConnector",
        "i18nFormat",
        "utils"
      ], services, this);
      this.options = options;
      if (this.options.keySeparator === void 0) {
        this.options.keySeparator = ".";
      }
      this.logger = baseLogger.create("translator");
    }
    changeLanguage(lng) {
      if (lng) this.language = lng;
    }
    exists(key) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      const resolved = this.resolve(key, options);
      return resolved && resolved.res !== void 0;
    }
    extractFromKey(key, options) {
      let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0) nsSeparator = ":";
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      let namespaces = options.ns || this.options.defaultNS || [];
      const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        const m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        const parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string") namespaces = [
        namespaces
      ];
      return {
        key,
        namespaces
      };
    }
    translate(keys, options, lastKey) {
      if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (typeof options === "object") options = {
        ...options
      };
      if (!options) options = {};
      if (keys === void 0 || keys === null) return "";
      if (!Array.isArray(keys)) keys = [
        String(keys)
      ];
      const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
      const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
      const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);
      const namespace = namespaces[namespaces.length - 1];
      const lng = options.lng || this.language;
      const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          const nsSeparator = options.nsSeparator || this.options.nsSeparator;
          if (returnDetails) {
            return {
              res: `${namespace}${nsSeparator}${key}`,
              usedKey: key,
              exactUsedKey: key,
              usedLng: lng,
              usedNS: namespace,
              usedParams: this.getUsedParamsDetails(options)
            };
          }
          return `${namespace}${nsSeparator}${key}`;
        }
        if (returnDetails) {
          return {
            res: key,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return key;
      }
      const resolved = this.resolve(keys, options);
      let res = resolved && resolved.res;
      const resUsedKey = resolved && resolved.usedKey || key;
      const resExactUsedKey = resolved && resolved.exactUsedKey || key;
      const resType = Object.prototype.toString.apply(res);
      const noObject = [
        "[object Number]",
        "[object Function]",
        "[object RegExp]"
      ];
      const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
      const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && Array.isArray(res))) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
            ...options,
            ns: namespaces
          }) : `key '${key} (${this.language})' returned an object instead of string.`;
          if (returnDetails) {
            resolved.res = r2;
            resolved.usedParams = this.getUsedParamsDetails(options);
            return resolved;
          }
          return r2;
        }
        if (keySeparator) {
          const resTypeIsArray = Array.isArray(res);
          const copy2 = resTypeIsArray ? [] : {};
          const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (const m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
              copy2[m2] = this.translate(deepKey, {
                ...options,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
              if (copy2[m2] === deepKey) copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && Array.isArray(res)) {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        let usedDefault = false;
        let usedKey = false;
        const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        const hasDefaultValue = Translator.hasDefaultValue(options);
        const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
        const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
          ordinal: false
        }) : "";
        const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
        const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            const fk2 = this.resolve(key, {
              ...options,
              keySeparator: false
            });
            if (fk2 && fk2.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          let lngs = [];
          const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
              lngs.push(fallbackLngs[i2]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }
          const send = (l2, k2, specificDefaultValue) => {
            const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (this.options.missingKeyHandler) {
              this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
            } else if (this.backendConnector && this.backendConnector.saveMissing) {
              this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
            }
            this.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach((language) => {
                const suffixes = this.pluralResolver.getSuffixes(language, options);
                if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                  suffixes.push(`${this.options.pluralSeparator}zero`);
                }
                suffixes.forEach((suffix) => {
                  send([
                    language
                  ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      if (returnDetails) {
        resolved.res = res;
        resolved.usedParams = this.getUsedParamsDetails(options);
        return resolved;
      }
      return res;
    }
    extendTranslation(res, key, options, resolved, lastKey) {
      var _this = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, {
          ...this.options.interpolation.defaultVariables,
          ...options
        }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation) this.interpolator.init({
          ...options,
          ...{
            interpolation: {
              ...this.options.interpolation,
              ...options.interpolation
            }
          }
        });
        const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        let nestBef;
        if (skipOnVariables) {
          const nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
        res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
        if (skipOnVariables) {
          const na = res.match(this.interpolator.nestingRegexp);
          const nestAft = na && na.length;
          if (nestBef < nestAft) options.nest = false;
        }
        if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
        if (options.nest !== false) res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
            return null;
          }
          return _this.translate(...args, key);
        }, options);
        if (options.interpolation) this.interpolator.reset();
      }
      const postProcess2 = options.postProcess || this.options.postProcess;
      const postProcessorNames = typeof postProcess2 === "string" ? [
        postProcess2
      ] : postProcess2;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
          i18nResolved: {
            ...resolved,
            usedParams: this.getUsedParamsDetails(options)
          },
          ...options
        } : options, this);
      }
      return res;
    }
    resolve(keys) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let found;
      let usedKey;
      let exactUsedKey;
      let usedLng;
      let usedNS;
      if (typeof keys === "string") keys = [
        keys
      ];
      keys.forEach((k2) => {
        if (this.isValidLookup(found)) return;
        const extracted = this.extractFromKey(k2, options);
        const key = extracted.key;
        usedKey = key;
        let namespaces = extracted.namespaces;
        if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
        const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
        const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
        const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
        const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
        namespaces.forEach((ns) => {
          if (this.isValidLookup(found)) return;
          usedNS = ns;
          if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor[`${codes[0]}-${ns}`] = true;
            this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach((code2) => {
            if (this.isValidLookup(found)) return;
            usedLng = code2;
            const finalKeys = [
              key
            ];
            if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
              this.i18nFormat.addLookupKeys(finalKeys, key, code2, ns, options);
            } else {
              let pluralSuffix;
              if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code2, options.count, options);
              const zeroSuffix = `${this.options.pluralSeparator}zero`;
              const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                  }
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            let possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!this.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = this.getResource(code2, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
    isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
    getResource(code2, ns, key) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code2, ns, key, options);
      return this.resourceStore.getResource(code2, ns, key, options);
    }
    getUsedParamsDetails() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const optionsKeys = [
        "defaultValue",
        "ordinal",
        "context",
        "replace",
        "lng",
        "lngs",
        "fallbackLng",
        "ns",
        "keySeparator",
        "nsSeparator",
        "returnObjects",
        "returnDetails",
        "joinArrays",
        "postProcess",
        "interpolation"
      ];
      const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
      let data = useOptionsReplaceForData ? options.replace : options;
      if (useOptionsReplaceForData && typeof options.count !== "undefined") {
        data.count = options.count;
      }
      if (this.options.interpolation.defaultVariables) {
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      }
      if (!useOptionsReplaceForData) {
        data = {
          ...data
        };
        for (const key of optionsKeys) {
          delete data[key];
        }
      }
      return data;
    }
    static hasDefaultValue(options) {
      const prefix = "defaultValue";
      for (const option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
          return true;
        }
      }
      return false;
    }
  }
  const capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
  class LanguageUtil {
    constructor(options) {
      this.options = options;
      this.supportedLngs = this.options.supportedLngs || false;
      this.logger = baseLogger.create("languageUtils");
    }
    getScriptPartFromCode(code2) {
      code2 = getCleanedCode(code2);
      if (!code2 || code2.indexOf("-") < 0) return null;
      const p2 = code2.split("-");
      if (p2.length === 2) return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x") return null;
      return this.formatLanguageCode(p2.join("-"));
    }
    getLanguagePartFromCode(code2) {
      code2 = getCleanedCode(code2);
      if (!code2 || code2.indexOf("-") < 0) return code2;
      const p2 = code2.split("-");
      return this.formatLanguageCode(p2[0]);
    }
    formatLanguageCode(code2) {
      if (typeof code2 === "string" && code2.indexOf("-") > -1) {
        const specialCases = [
          "hans",
          "hant",
          "latn",
          "cyrl",
          "cans",
          "mong",
          "arab"
        ];
        let p2 = code2.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map((part) => part.toLowerCase());
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2) p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2) p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1) p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code2.toLowerCase() : code2;
    }
    isSupportedCode(code2) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code2 = this.getLanguagePartFromCode(code2);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code2) > -1;
    }
    getBestMatchFromCodes(codes) {
      if (!codes) return null;
      let found;
      codes.forEach((code2) => {
        if (found) return;
        const cleanedLng = this.formatLanguageCode(code2);
        if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach((code2) => {
          if (found) return;
          const lngOnly = this.getLanguagePartFromCode(code2);
          if (this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = this.options.supportedLngs.find((supportedLng) => {
            if (supportedLng === lngOnly) return supportedLng;
            if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
            if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
            if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
          });
        });
      }
      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
    getFallbackCodes(fallbacks, code2) {
      if (!fallbacks) return [];
      if (typeof fallbacks === "function") fallbacks = fallbacks(code2);
      if (typeof fallbacks === "string") fallbacks = [
        fallbacks
      ];
      if (Array.isArray(fallbacks)) return fallbacks;
      if (!code2) return fallbacks.default || [];
      let found = fallbacks[code2];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code2)];
      if (!found) found = fallbacks[this.formatLanguageCode(code2)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code2)];
      if (!found) found = fallbacks.default;
      return found || [];
    }
    toResolveHierarchy(code2, fallbackCode) {
      const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code2);
      const codes = [];
      const addCode = (c) => {
        if (!c) return;
        if (this.isSupportedCode(c)) {
          codes.push(c);
        } else {
          this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
        }
      };
      if (typeof code2 === "string" && (code2.indexOf("-") > -1 || code2.indexOf("_") > -1)) {
        if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code2));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code2));
        if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code2));
      } else if (typeof code2 === "string") {
        addCode(this.formatLanguageCode(code2));
      }
      fallbackCodes.forEach((fc2) => {
        if (codes.indexOf(fc2) < 0) addCode(this.formatLanguageCode(fc2));
      });
      return codes;
    }
  }
  let sets = [
    {
      lngs: [
        "ach",
        "ak",
        "am",
        "arn",
        "br",
        "fil",
        "gun",
        "ln",
        "mfe",
        "mg",
        "mi",
        "oc",
        "pt",
        "pt-BR",
        "tg",
        "tl",
        "ti",
        "tr",
        "uz",
        "wa"
      ],
      nr: [
        1,
        2
      ],
      fc: 1
    },
    {
      lngs: [
        "af",
        "an",
        "ast",
        "az",
        "bg",
        "bn",
        "ca",
        "da",
        "de",
        "dev",
        "el",
        "en",
        "eo",
        "es",
        "et",
        "eu",
        "fi",
        "fo",
        "fur",
        "fy",
        "gl",
        "gu",
        "ha",
        "hi",
        "hu",
        "hy",
        "ia",
        "it",
        "kk",
        "kn",
        "ku",
        "lb",
        "mai",
        "ml",
        "mn",
        "mr",
        "nah",
        "nap",
        "nb",
        "ne",
        "nl",
        "nn",
        "no",
        "nso",
        "pa",
        "pap",
        "pms",
        "ps",
        "pt-PT",
        "rm",
        "sco",
        "se",
        "si",
        "so",
        "son",
        "sq",
        "sv",
        "sw",
        "ta",
        "te",
        "tk",
        "ur",
        "yo"
      ],
      nr: [
        1,
        2
      ],
      fc: 2
    },
    {
      lngs: [
        "ay",
        "bo",
        "cgg",
        "fa",
        "ht",
        "id",
        "ja",
        "jbo",
        "ka",
        "km",
        "ko",
        "ky",
        "lo",
        "ms",
        "sah",
        "su",
        "th",
        "tt",
        "ug",
        "vi",
        "wo",
        "zh"
      ],
      nr: [
        1
      ],
      fc: 3
    },
    {
      lngs: [
        "be",
        "bs",
        "cnr",
        "dz",
        "hr",
        "ru",
        "sr",
        "uk"
      ],
      nr: [
        1,
        2,
        5
      ],
      fc: 4
    },
    {
      lngs: [
        "ar"
      ],
      nr: [
        0,
        1,
        2,
        3,
        11,
        100
      ],
      fc: 5
    },
    {
      lngs: [
        "cs",
        "sk"
      ],
      nr: [
        1,
        2,
        5
      ],
      fc: 6
    },
    {
      lngs: [
        "csb",
        "pl"
      ],
      nr: [
        1,
        2,
        5
      ],
      fc: 7
    },
    {
      lngs: [
        "cy"
      ],
      nr: [
        1,
        2,
        3,
        8
      ],
      fc: 8
    },
    {
      lngs: [
        "fr"
      ],
      nr: [
        1,
        2
      ],
      fc: 9
    },
    {
      lngs: [
        "ga"
      ],
      nr: [
        1,
        2,
        3,
        7,
        11
      ],
      fc: 10
    },
    {
      lngs: [
        "gd"
      ],
      nr: [
        1,
        2,
        3,
        20
      ],
      fc: 11
    },
    {
      lngs: [
        "is"
      ],
      nr: [
        1,
        2
      ],
      fc: 12
    },
    {
      lngs: [
        "jv"
      ],
      nr: [
        0,
        1
      ],
      fc: 13
    },
    {
      lngs: [
        "kw"
      ],
      nr: [
        1,
        2,
        3,
        4
      ],
      fc: 14
    },
    {
      lngs: [
        "lt"
      ],
      nr: [
        1,
        2,
        10
      ],
      fc: 15
    },
    {
      lngs: [
        "lv"
      ],
      nr: [
        1,
        2,
        0
      ],
      fc: 16
    },
    {
      lngs: [
        "mk"
      ],
      nr: [
        1,
        2
      ],
      fc: 17
    },
    {
      lngs: [
        "mnk"
      ],
      nr: [
        0,
        1,
        2
      ],
      fc: 18
    },
    {
      lngs: [
        "mt"
      ],
      nr: [
        1,
        2,
        11,
        20
      ],
      fc: 19
    },
    {
      lngs: [
        "or"
      ],
      nr: [
        2,
        1
      ],
      fc: 2
    },
    {
      lngs: [
        "ro"
      ],
      nr: [
        1,
        2,
        20
      ],
      fc: 20
    },
    {
      lngs: [
        "sl"
      ],
      nr: [
        5,
        1,
        2,
        3
      ],
      fc: 21
    },
    {
      lngs: [
        "he",
        "iw"
      ],
      nr: [
        1,
        2,
        20,
        21
      ],
      fc: 22
    }
  ];
  let _rulesPluralsTypes = {
    1: (n2) => Number(n2 > 1),
    2: (n2) => Number(n2 != 1),
    3: (n2) => 0,
    4: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
    5: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5),
    6: (n2) => Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2),
    7: (n2) => Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
    8: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3),
    9: (n2) => Number(n2 >= 2),
    10: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4),
    11: (n2) => Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3),
    12: (n2) => Number(n2 % 10 != 1 || n2 % 100 == 11),
    13: (n2) => Number(n2 !== 0),
    14: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3),
    15: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2),
    16: (n2) => Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2),
    17: (n2) => Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1),
    18: (n2) => Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2),
    19: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3),
    20: (n2) => Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2),
    21: (n2) => Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0),
    22: (n2) => Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3)
  };
  const nonIntlVersions = [
    "v1",
    "v2",
    "v3"
  ];
  const intlVersions = [
    "v4"
  ];
  const suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
  };
  const createRules = () => {
    const rules = {};
    sets.forEach((set) => {
      set.lngs.forEach((l2) => {
        rules[l2] = {
          numbers: set.nr,
          plurals: _rulesPluralsTypes[set.fc]
        };
      });
    });
    return rules;
  };
  class PluralResolver {
    constructor(languageUtils) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.languageUtils = languageUtils;
      this.options = options;
      this.logger = baseLogger.create("pluralResolver");
      if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
        this.options.compatibilityJSON = "v3";
        this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
      }
      this.rules = createRules();
      this.pluralRulesCache = {};
    }
    addRule(lng, obj) {
      this.rules[lng] = obj;
    }
    clearCache() {
      this.pluralRulesCache = {};
    }
    getRule(code2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          const cleanedCode = getCleanedCode(code2 === "dev" ? "en" : code2);
          const type = options.ordinal ? "ordinal" : "cardinal";
          const cacheKey = JSON.stringify({
            cleanedCode,
            type
          });
          if (cacheKey in this.pluralRulesCache) {
            return this.pluralRulesCache[cacheKey];
          }
          const rule = new Intl.PluralRules(cleanedCode, {
            type
          });
          this.pluralRulesCache[cacheKey] = rule;
          return rule;
        } catch (err) {
          return;
        }
      }
      return this.rules[code2] || this.rules[this.languageUtils.getLanguagePartFromCode(code2)];
    }
    needsPlural(code2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const rule = this.getRule(code2, options);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
    getPluralFormsOfKey(code2, key) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code2, options).map((suffix) => `${key}${suffix}`);
    }
    getSuffixes(code2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const rule = this.getRule(code2, options);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
      }
      return rule.numbers.map((number2) => this.getSuffix(code2, number2, options));
    }
    getSuffix(code2, count2) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const rule = this.getRule(code2, options);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
        }
        return this.getSuffixRetroCompatible(rule, count2);
      }
      this.logger.warn(`no plural rule found for: ${code2}`);
      return "";
    }
    getSuffixRetroCompatible(rule, count2) {
      const idx = rule.noAbs ? rule.plurals(count2) : rule.plurals(Math.abs(count2));
      let suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1) return "";
        if (typeof suffix === "number") return `_plural_${suffix.toString()}`;
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
    shouldUseIntlApi() {
      return !nonIntlVersions.includes(this.options.compatibilityJSON);
    }
  }
  const deepFindWithDefaults = function(data, defaultData, key) {
    let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    let path = getPathWithDefaults(data, defaultData, key);
    if (!path && ignoreJSONStructure && typeof key === "string") {
      path = deepFind(data, key, keySeparator);
      if (path === void 0) path = deepFind(defaultData, key, keySeparator);
    }
    return path;
  };
  const regexSafe = (val) => val.replace(/\$/g, "$$$$");
  class Interpolator {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.logger = baseLogger.create("interpolator");
      this.options = options;
      this.format = options.interpolation && options.interpolation.format || ((value) => value);
      this.init(options);
    }
    init() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      const { escape: escape$12, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options.interpolation;
      this.escape = escape$12 !== void 0 ? escape$12 : escape;
      this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
      this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
      this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
      this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
      this.formatSeparator = formatSeparator || ",";
      this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
      this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
      this.maxReplaces = maxReplaces || 1e3;
      this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
      this.resetRegExp();
    }
    reset() {
      if (this.options) this.init(this.options);
    }
    resetRegExp() {
      const getOrResetRegExp = (existingRegExp, pattern) => {
        if (existingRegExp && existingRegExp.source === pattern) {
          existingRegExp.lastIndex = 0;
          return existingRegExp;
        }
        return new RegExp(pattern, "g");
      };
      this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
      this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
      this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
    }
    interpolate(str, data, lng, options) {
      let match;
      let value;
      let replaces;
      const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      const handleFormat = (key) => {
        if (key.indexOf(this.formatSeparator) < 0) {
          const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
          return this.alwaysFormat ? this.format(path, void 0, lng, {
            ...options,
            ...data,
            interpolationkey: key
          }) : path;
        }
        const p2 = key.split(this.formatSeparator);
        const k2 = p2.shift().trim();
        const f2 = p2.join(this.formatSeparator).trim();
        return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
          ...options,
          ...data,
          interpolationkey: k2
        });
      };
      this.resetRegExp();
      const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      const todos = [
        {
          regex: this.regexpUnescape,
          safeValue: (val) => regexSafe(val)
        },
        {
          regex: this.regexp,
          safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
        }
      ];
      todos.forEach((todo) => {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          const matchedVar = match[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              const temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === "string" ? temp : "";
            } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
              value = "";
            }
          } else if (typeof value !== "string" && !this.useRawValueToEscape) {
            value = makeString(value);
          }
          const safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
    nest(str, fc2) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let match;
      let value;
      let clonedOptions;
      const handleHasOptions = (key, inheritedOptions) => {
        const sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        const c = key.split(new RegExp(`${sep}[ ]*{`));
        let optionsString = `{${c[1]}`;
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        const matchedSingleQuotes = optionsString.match(/'/g);
        const matchedDoubleQuotes = optionsString.match(/"/g);
        if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
          optionsString = optionsString.replace(/'/g, '"');
        }
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = {
            ...inheritedOptions,
            ...clonedOptions
          };
        } catch (e) {
          this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
          return `${key}${sep}${optionsString}`;
        }
        if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
        return key;
      };
      while (match = this.nestingRegexp.exec(str)) {
        let formatters = [];
        clonedOptions = {
          ...options
        };
        clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
        clonedOptions.applyPostProcessor = false;
        delete clonedOptions.defaultValue;
        let doReduce = false;
        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
          match[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string") return value;
        if (typeof value !== "string") value = makeString(value);
        if (!value) {
          this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
            ...options,
            interpolationkey: match[1].trim()
          }), value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }
  const parseFormatStr = (formatStr) => {
    let formatName = formatStr.toLowerCase().trim();
    const formatOptions = {};
    if (formatStr.indexOf("(") > -1) {
      const p2 = formatStr.split("(");
      formatName = p2[0].toLowerCase().trim();
      const optStr = p2[1].substring(0, p2[1].length - 1);
      if (formatName === "currency" && optStr.indexOf(":") < 0) {
        if (!formatOptions.currency) formatOptions.currency = optStr.trim();
      } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
        if (!formatOptions.range) formatOptions.range = optStr.trim();
      } else {
        const opts = optStr.split(";");
        opts.forEach((opt) => {
          if (opt) {
            const [key, ...rest] = opt.split(":");
            const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
            const trimmedKey = key.trim();
            if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
            if (val === "false") formatOptions[trimmedKey] = false;
            if (val === "true") formatOptions[trimmedKey] = true;
            if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
          }
        });
      }
    }
    return {
      formatName,
      formatOptions
    };
  };
  const createCachedFormatter = (fn) => {
    const cache2 = {};
    return (val, lng, options) => {
      let optForCache = options;
      if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
        optForCache = {
          ...optForCache,
          [options.interpolationkey]: void 0
        };
      }
      const key = lng + JSON.stringify(optForCache);
      let formatter = cache2[key];
      if (!formatter) {
        formatter = fn(getCleanedCode(lng), options);
        cache2[key] = formatter;
      }
      return formatter(val);
    };
  };
  class Formatter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.logger = baseLogger.create("formatter");
      this.options = options;
      this.formats = {
        number: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.NumberFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val);
        }),
        currency: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.NumberFormat(lng, {
            ...opt,
            style: "currency"
          });
          return (val) => formatter.format(val);
        }),
        datetime: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.DateTimeFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val);
        }),
        relativetime: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.RelativeTimeFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val, opt.range || "day");
        }),
        list: createCachedFormatter((lng, opt) => {
          const formatter = new Intl.ListFormat(lng, {
            ...opt
          });
          return (val) => formatter.format(val);
        })
      };
      this.init(options);
    }
    init(services) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      const iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
    add(name, fc2) {
      this.formats[name.toLowerCase().trim()] = fc2;
    }
    addCached(name, fc2) {
      this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc2);
    }
    format(value, format, lng) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const formats = format.split(this.formatSeparator);
      if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
        const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
        formats[0] = [
          formats[0],
          ...formats.splice(1, lastIndex)
        ].join(this.formatSeparator);
      }
      const result = formats.reduce((mem, f2) => {
        const { formatName, formatOptions } = parseFormatStr(f2);
        if (this.formats[formatName]) {
          let formatted = mem;
          try {
            const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = this.formats[formatName](mem, l2, {
              ...formatOptions,
              ...options,
              ...valOptions
            });
          } catch (error) {
            this.logger.warn(error);
          }
          return formatted;
        } else {
          this.logger.warn(`there was no format function for ${formatName}`);
        }
        return mem;
      }, value);
      return result;
    }
  }
  const removePending = (q2, name) => {
    if (q2.pending[name] !== void 0) {
      delete q2.pending[name];
      q2.pendingCount--;
    }
  };
  class Connector extends EventEmitter$1 {
    constructor(backend, store, services) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      super();
      this.backend = backend;
      this.store = store;
      this.services = services;
      this.languageUtils = services.languageUtils;
      this.options = options;
      this.logger = baseLogger.create("backendConnector");
      this.waitingReads = [];
      this.maxParallelReads = options.maxParallelReads || 10;
      this.readingCalls = 0;
      this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
      this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
      this.state = {};
      this.queue = [];
      if (this.backend && this.backend.init) {
        this.backend.init(services, options.backend, options);
      }
    }
    queueLoad(languages, namespaces, options, callback) {
      const toLoad = {};
      const pending = {};
      const toLoadLanguages = {};
      const toLoadNamespaces = {};
      languages.forEach((lng) => {
        let hasAllNamespaces = true;
        namespaces.forEach((ns) => {
          const name = `${lng}|${ns}`;
          if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
            this.state[name] = 2;
          } else if (this.state[name] < 0) ;
          else if (this.state[name] === 1) {
            if (pending[name] === void 0) pending[name] = true;
          } else {
            this.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === void 0) pending[name] = true;
            if (toLoad[name] === void 0) toLoad[name] = true;
            if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces) toLoadLanguages[lng] = true;
      });
      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
    loaded(name, err, data) {
      const s = name.split("|");
      const lng = s[0];
      const ns = s[1];
      if (err) this.emit("failedLoading", lng, ns, err);
      if (!err && data) {
        this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
          skipCopy: true
        });
      }
      this.state[name] = err ? -1 : 2;
      if (err && data) this.state[name] = 0;
      const loaded = {};
      this.queue.forEach((q2) => {
        pushPath(q2.loaded, [
          lng
        ], ns);
        removePending(q2, name);
        if (err) q2.errors.push(err);
        if (q2.pendingCount === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach((l2) => {
            if (!loaded[l2]) loaded[l2] = {};
            const loadedKeys = q2.loaded[l2];
            if (loadedKeys.length) {
              loadedKeys.forEach((n2) => {
                if (loaded[l2][n2] === void 0) loaded[l2][n2] = true;
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded);
      this.queue = this.queue.filter((q2) => !q2.done);
    }
    read(lng, ns, fcName) {
      let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
      let callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length) return callback(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng,
          ns,
          fcName,
          tried,
          wait,
          callback
        });
        return;
      }
      this.readingCalls++;
      const resolver = (err, data) => {
        this.readingCalls--;
        if (this.waitingReads.length > 0) {
          const next = this.waitingReads.shift();
          this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }
        if (err && data && tried < this.maxRetries) {
          setTimeout(() => {
            this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      };
      const fc2 = this.backend[fcName].bind(this.backend);
      if (fc2.length === 2) {
        try {
          const r2 = fc2(lng, ns);
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => resolver(null, data)).catch(resolver);
          } else {
            resolver(null, r2);
          }
        } catch (err) {
          resolver(err);
        }
        return;
      }
      return fc2(lng, ns, resolver);
    }
    prepareLoading(languages, namespaces) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      let callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string") languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string") namespaces = [
        namespaces
      ];
      const toLoad = this.queueLoad(languages, namespaces, options, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }
      toLoad.toLoad.forEach((name) => {
        this.loadOne(name);
      });
    }
    load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
    reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
    loadOne(name) {
      let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const s = name.split("|");
      const lng = s[0];
      const ns = s[1];
      this.read(lng, ns, "read", void 0, void 0, (err, data) => {
        if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
        if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
        this.loaded(name, err, data);
      });
    }
    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
      };
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "") return;
      if (this.backend && this.backend.create) {
        const opts = {
          ...options,
          isUpdate
        };
        const fc2 = this.backend.create.bind(this.backend);
        if (fc2.length < 6) {
          try {
            let r2;
            if (fc2.length === 5) {
              r2 = fc2(languages, namespace, key, fallbackValue, opts);
            } else {
              r2 = fc2(languages, namespace, key, fallbackValue);
            }
            if (r2 && typeof r2.then === "function") {
              r2.then((data) => clb(null, data)).catch(clb);
            } else {
              clb(null, r2);
            }
          } catch (err) {
            clb(err);
          }
        } else {
          fc2(languages, namespace, key, fallbackValue, clb, opts);
        }
      }
      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }
  const get = () => ({
    debug: false,
    initImmediate: true,
    ns: [
      "translation"
    ],
    defaultNS: [
      "translation"
    ],
    fallbackLng: [
      "dev"
    ],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: (args) => {
      let ret = {};
      if (typeof args[1] === "object") ret = args[1];
      if (typeof args[1] === "string") ret.defaultValue = args[1];
      if (typeof args[2] === "string") ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  });
  const transformOptions = (options) => {
    if (typeof options.ns === "string") options.ns = [
      options.ns
    ];
    if (typeof options.fallbackLng === "string") options.fallbackLng = [
      options.fallbackLng
    ];
    if (typeof options.fallbackNS === "string") options.fallbackNS = [
      options.fallbackNS
    ];
    if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
      options.supportedLngs = options.supportedLngs.concat([
        "cimode"
      ]);
    }
    return options;
  };
  const noop$2 = () => {
  };
  const bindMemberFunctions = (inst) => {
    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
    mems.forEach((mem) => {
      if (typeof inst[mem] === "function") {
        inst[mem] = inst[mem].bind(inst);
      }
    });
  };
  class I18n extends EventEmitter$1 {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      super();
      this.options = transformOptions(options);
      this.services = {};
      this.logger = baseLogger;
      this.modules = {
        external: []
      };
      bindMemberFunctions(this);
      if (callback && !this.isInitialized && !options.isClone) {
        if (!this.options.initImmediate) {
          this.init(options, callback);
          return this;
        }
        setTimeout(() => {
          this.init(options, callback);
        }, 0);
      }
    }
    init() {
      var _this = this;
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      this.isInitializing = true;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === "string") {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf("translation") < 0) {
          options.defaultNS = options.ns[0];
        }
      }
      const defOpts = get();
      this.options = {
        ...defOpts,
        ...this.options,
        ...transformOptions(options)
      };
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = {
          ...defOpts.interpolation,
          ...this.options.interpolation
        };
      }
      if (options.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }
      if (options.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }
      const createClassOnDemand = (ClassOrObject) => {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === "function") return new ClassOrObject();
        return ClassOrObject;
      };
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        let formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        const lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        const s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this.emit(event, ...args);
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this.emit(event, ...args);
        });
        this.modules.external.forEach((m2) => {
          if (m2.init) m2.init(this);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop$2;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      const storeApi = [
        "getResource",
        "hasResourceBundle",
        "getResourceBundle",
        "getDataByLanguage"
      ];
      storeApi.forEach((fcName) => {
        this[fcName] = function() {
          return _this.store[fcName](...arguments);
        };
      });
      const storeApiChained = [
        "addResource",
        "addResources",
        "addResourceBundle",
        "removeResourceBundle"
      ];
      storeApiChained.forEach((fcName) => {
        this[fcName] = function() {
          _this.store[fcName](...arguments);
          return _this;
        };
      });
      const deferred = defer();
      const load2 = () => {
        const finish = (err, t2) => {
          this.isInitializing = false;
          if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
          this.isInitialized = true;
          if (!this.options.isClone) this.logger.log("initialized", this.options);
          this.emit("initialized", this.options);
          deferred.resolve(t2);
          callback(err, t2);
        };
        if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return finish(null, this.t.bind(this));
        this.changeLanguage(this.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load2();
      } else {
        setTimeout(load2, 0);
      }
      return deferred;
    }
    loadResources(language) {
      let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$2;
      let usedCallback = callback;
      const usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function") usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
        const toLoad = [];
        const append = (lng) => {
          if (!lng) return;
          if (lng === "cimode") return;
          const lngs = this.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach((l2) => {
            if (l2 === "cimode") return;
            if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
          });
        };
        if (!usedLng) {
          const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach((l2) => append(l2));
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach((l2) => append(l2));
        }
        this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
          if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
    reloadResources(lngs, ns, callback) {
      const deferred = defer();
      if (typeof lngs === "function") {
        callback = lngs;
        lngs = void 0;
      }
      if (typeof ns === "function") {
        callback = ns;
        ns = void 0;
      }
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop$2;
      this.services.backendConnector.reload(lngs, ns, (err) => {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
    use(module2) {
      if (!module2) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module2.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module2.type === "backend") {
        this.modules.backend = module2;
      }
      if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
        this.modules.logger = module2;
      }
      if (module2.type === "languageDetector") {
        this.modules.languageDetector = module2;
      }
      if (module2.type === "i18nFormat") {
        this.modules.i18nFormat = module2;
      }
      if (module2.type === "postProcessor") {
        postProcessor.addPostProcessor(module2);
      }
      if (module2.type === "formatter") {
        this.modules.formatter = module2;
      }
      if (module2.type === "3rdParty") {
        this.modules.external.push(module2);
      }
      return this;
    }
    setResolvedLanguage(l2) {
      if (!l2 || !this.languages) return;
      if ([
        "cimode",
        "dev"
      ].indexOf(l2) > -1) return;
      for (let li2 = 0; li2 < this.languages.length; li2++) {
        const lngInLngs = this.languages[li2];
        if ([
          "cimode",
          "dev"
        ].indexOf(lngInLngs) > -1) continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
    changeLanguage(lng, callback) {
      var _this2 = this;
      this.isLanguageChangingTo = lng;
      const deferred = defer();
      this.emit("languageChanging", lng);
      const setLngProps = (l2) => {
        this.language = l2;
        this.languages = this.services.languageUtils.toResolveHierarchy(l2);
        this.resolvedLanguage = void 0;
        this.setResolvedLanguage(l2);
      };
      const done = (err, l2) => {
        if (l2) {
          setLngProps(l2);
          this.translator.changeLanguage(l2);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l2);
          this.logger.log("languageChanged", l2);
        } else {
          this.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this2.t(...arguments);
        });
        if (callback) callback(err, function() {
          return _this2.t(...arguments);
        });
      };
      const setLng = (lngs) => {
        if (!lng && !lngs && this.services.languageDetector) lngs = [];
        const l2 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!this.language) {
            setLngProps(l2);
          }
          if (!this.translator.language) this.translator.changeLanguage(l2);
          if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l2);
        }
        this.loadResources(l2, (err) => {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        if (this.services.languageDetector.detect.length === 0) {
          this.services.languageDetector.detect().then(setLng);
        } else {
          this.services.languageDetector.detect(setLng);
        }
      } else {
        setLng(lng);
      }
      return deferred;
    }
    getFixedT(lng, ns, keyPrefix) {
      var _this3 = this;
      const fixedT = function(key, opts) {
        let options;
        if (typeof opts !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options = _this3.options.overloadTranslationOptionHandler([
            key,
            opts
          ].concat(rest));
        } else {
          options = {
            ...opts
          };
        }
        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
        const keySeparator = _this3.options.keySeparator || ".";
        let resultKey;
        if (options.keyPrefix && Array.isArray(key)) {
          resultKey = key.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
        } else {
          resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
        }
        return _this3.t(resultKey, options);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
    t() {
      return this.translator && this.translator.translate(...arguments);
    }
    exists() {
      return this.translator && this.translator.exists(...arguments);
    }
    setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
    hasLoadedNamespace(ns) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      const lng = options.lng || this.resolvedLanguage || this.languages[0];
      const fallbackLng = this.options ? this.options.fallbackLng : false;
      const lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode") return true;
      const loadNotPending = (l2, n2) => {
        const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
        return loadState === -1 || loadState === 0 || loadState === 2;
      };
      if (options.precheck) {
        const preResult = options.precheck(this, loadNotPending);
        if (preResult !== void 0) return preResult;
      }
      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
    loadNamespaces(ns, callback) {
      const deferred = defer();
      if (!this.options.ns) {
        if (callback) callback();
        return Promise.resolve();
      }
      if (typeof ns === "string") ns = [
        ns
      ];
      ns.forEach((n2) => {
        if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
      });
      this.loadResources((err) => {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
    loadLanguages(lngs, callback) {
      const deferred = defer();
      if (typeof lngs === "string") lngs = [
        lngs
      ];
      const preloaded = this.options.preload || [];
      const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources((err) => {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
    dir(lng) {
      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng) return "rtl";
      const rtlLngs = [
        "ar",
        "shu",
        "sqr",
        "ssh",
        "xaa",
        "yhd",
        "yud",
        "aao",
        "abh",
        "abv",
        "acm",
        "acq",
        "acw",
        "acx",
        "acy",
        "adf",
        "ads",
        "aeb",
        "aec",
        "afb",
        "ajp",
        "apc",
        "apd",
        "arb",
        "arq",
        "ars",
        "ary",
        "arz",
        "auz",
        "avl",
        "ayh",
        "ayl",
        "ayn",
        "ayp",
        "bbz",
        "pga",
        "he",
        "iw",
        "ps",
        "pbt",
        "pbu",
        "pst",
        "prp",
        "prd",
        "ug",
        "ur",
        "ydd",
        "yds",
        "yih",
        "ji",
        "yi",
        "hbo",
        "men",
        "xmn",
        "fa",
        "jpr",
        "peo",
        "pes",
        "prs",
        "dv",
        "sam",
        "ckb"
      ];
      const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
      return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
    static createInstance() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n(options, callback);
    }
    cloneInstance() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$2;
      const forkResourceStore = options.forkResourceStore;
      if (forkResourceStore) delete options.forkResourceStore;
      const mergedOptions = {
        ...this.options,
        ...options,
        ...{
          isClone: true
        }
      };
      const clone = new I18n(mergedOptions);
      if (options.debug !== void 0 || options.prefix !== void 0) {
        clone.logger = clone.logger.clone(options);
      }
      const membersToCopy = [
        "store",
        "services",
        "language"
      ];
      membersToCopy.forEach((m2) => {
        clone[m2] = this[m2];
      });
      clone.services = {
        ...this.services
      };
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      if (forkResourceStore) {
        clone.store = new ResourceStore(this.store.data, mergedOptions);
        clone.services.resourceStore = clone.store;
      }
      clone.translator = new Translator(clone.services, mergedOptions);
      clone.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit(event, ...args);
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = mergedOptions;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
    toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }
  const instance = I18n.createInstance();
  instance.createInstance = I18n.createInstance;
  instance.createInstance;
  instance.dir;
  instance.init;
  instance.loadResources;
  instance.reloadResources;
  instance.use;
  instance.changeLanguage;
  instance.getFixedT;
  instance.t;
  instance.exists;
  instance.setDefaultNamespace;
  instance.hasLoadedNamespace;
  instance.loadNamespaces;
  instance.loadLanguages;
  const warn = (...args) => {
    if (console == null ? void 0 : console.warn) {
      if (isString(args[0])) args[0] = `react-i18next:: ${args[0]}`;
      console.warn(...args);
    }
  };
  const alreadyWarned = {};
  const warnOnce$1 = (...args) => {
    if (isString(args[0]) && alreadyWarned[args[0]]) return;
    if (isString(args[0])) alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
    warn(...args);
  };
  const loadedClb = (i18n, cb2) => () => {
    if (i18n.isInitialized) {
      cb2();
    } else {
      const initialized = () => {
        setTimeout(() => {
          i18n.off("initialized", initialized);
        }, 0);
        cb2();
      };
      i18n.on("initialized", initialized);
    }
  };
  const loadNamespaces = (i18n, ns, cb2) => {
    i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
  };
  const loadLanguages = (i18n, lng, ns, cb2) => {
    if (isString(ns)) ns = [
      ns
    ];
    ns.forEach((n2) => {
      if (i18n.options.ns.indexOf(n2) < 0) i18n.options.ns.push(n2);
    });
    i18n.loadLanguages(lng, loadedClb(i18n, cb2));
  };
  const hasLoadedNamespace = (ns, i18n, options = {}) => {
    if (!i18n.languages || !i18n.languages.length) {
      warnOnce$1("i18n.languages were undefined or empty", i18n.languages);
      return true;
    }
    return i18n.hasLoadedNamespace(ns, {
      lng: options.lng,
      precheck: (i18nInstance2, loadNotPending) => {
        var _a;
        if (((_a = options.bindI18n) == null ? void 0 : _a.indexOf("languageChanging")) > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
      }
    });
  };
  const isString = (obj) => typeof obj === "string";
  const isObject = (obj) => typeof obj === "object" && obj !== null;
  const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
  const htmlEntities = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "\xA9",
    "&#169;": "\xA9",
    "&reg;": "\xAE",
    "&#174;": "\xAE",
    "&hellip;": "\u2026",
    "&#8230;": "\u2026",
    "&#x2F;": "/",
    "&#47;": "/"
  };
  const unescapeHtmlEntity = (m2) => htmlEntities[m2];
  const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
  let defaultOptions$2 = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: true,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: [
      "br",
      "strong",
      "i",
      "p"
    ],
    useSuspense: true,
    unescape
  };
  const setDefaults = (options = {}) => {
    defaultOptions$2 = {
      ...defaultOptions$2,
      ...options
    };
  };
  const getDefaults = () => defaultOptions$2;
  let i18nInstance;
  const setI18n = (instance2) => {
    i18nInstance = instance2;
  };
  const getI18n = () => i18nInstance;
  const initReactI18next = {
    type: "3rdParty",
    init(instance2) {
      setDefaults(instance2.options.react);
      setI18n(instance2);
    }
  };
  const I18nContext = reactExports.createContext();
  class ReportNamespaces {
    constructor() {
      this.usedNamespaces = {};
    }
    addUsedNamespaces(namespaces) {
      namespaces.forEach((ns) => {
        var _a;
        (_a = this.usedNamespaces)[ns] ?? (_a[ns] = true);
      });
    }
    getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }
  const usePrevious = (value, ignore) => {
    const ref = reactExports.useRef();
    reactExports.useEffect(() => {
      ref.current = value;
    }, [
      value,
      ignore
    ]);
    return ref.current;
  };
  const alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);
  const useMemoizedT = (i18n, language, namespace, keyPrefix) => reactExports.useCallback(alwaysNewT(i18n, language, namespace, keyPrefix), [
    i18n,
    language,
    namespace,
    keyPrefix
  ]);
  useTranslation = (ns, props = {}) => {
    var _a, _b, _c, _d;
    const { i18n: i18nFromProps } = props;
    const { i18n: i18nFromContext, defaultNS: defaultNSFromContext } = reactExports.useContext(I18nContext) || {};
    const i18n = i18nFromProps || i18nFromContext || getI18n();
    if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
    if (!i18n) {
      warnOnce$1("You will need to pass in an i18next instance by using initReactI18next");
      const notReadyT = (k2, optsOrDefaultValue) => {
        if (isString(optsOrDefaultValue)) return optsOrDefaultValue;
        if (isObject(optsOrDefaultValue) && isString(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
        return Array.isArray(k2) ? k2[k2.length - 1] : k2;
      };
      const retNotReady = [
        notReadyT,
        {},
        false
      ];
      retNotReady.t = notReadyT;
      retNotReady.i18n = {};
      retNotReady.ready = false;
      return retNotReady;
    }
    if ((_a = i18n.options.react) == null ? void 0 : _a.wait) warnOnce$1("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const i18nOptions = {
      ...getDefaults(),
      ...i18n.options.react,
      ...props
    };
    const { useSuspense, keyPrefix } = i18nOptions;
    let namespaces = ns || defaultNSFromContext || ((_b = i18n.options) == null ? void 0 : _b.defaultNS);
    namespaces = isString(namespaces) ? [
      namespaces
    ] : namespaces || [
      "translation"
    ];
    (_d = (_c = i18n.reportNamespaces).addUsedNamespaces) == null ? void 0 : _d.call(_c, namespaces);
    const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
    const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
    const getT = () => memoGetT;
    const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
    const [t2, setT] = reactExports.useState(getT);
    let joinedNS = namespaces.join();
    if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
    const previousJoinedNS = usePrevious(joinedNS);
    const isMounted = reactExports.useRef(true);
    reactExports.useEffect(() => {
      const { bindI18n, bindI18nStore } = i18nOptions;
      isMounted.current = true;
      if (!ready && !useSuspense) {
        if (props.lng) {
          loadLanguages(i18n, props.lng, namespaces, () => {
            if (isMounted.current) setT(getNewT);
          });
        } else {
          loadNamespaces(i18n, namespaces, () => {
            if (isMounted.current) setT(getNewT);
          });
        }
      }
      if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
        setT(getNewT);
      }
      const boundReset = () => {
        if (isMounted.current) setT(getNewT);
      };
      if (bindI18n) i18n == null ? void 0 : i18n.on(bindI18n, boundReset);
      if (bindI18nStore) i18n == null ? void 0 : i18n.store.on(bindI18nStore, boundReset);
      return () => {
        isMounted.current = false;
        if (i18n) bindI18n == null ? void 0 : bindI18n.split(" ").forEach((e) => i18n.off(e, boundReset));
        if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e) => i18n.store.off(e, boundReset));
      };
    }, [
      i18n,
      joinedNS
    ]);
    reactExports.useEffect(() => {
      if (isMounted.current && ready) {
        setT(getT);
      }
    }, [
      i18n,
      keyPrefix,
      ready
    ]);
    const ret = [
      t2,
      i18n,
      ready
    ];
    ret.t = t2;
    ret.i18n = i18n;
    ret.ready = ready;
    if (ready) return ret;
    if (!ready && !useSuspense) return ret;
    throw new Promise((resolve) => {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => resolve());
      } else {
        loadNamespaces(i18n, namespaces, () => resolve());
      }
    });
  };
  const common = {
    loading: "Loading...",
    something_went_wrong: "Something went wrong",
    copied: "Copied",
    deleted: "Deleted",
    whiteboard: "Whiteboard",
    errors: {
      delete_failed: "Delete node failed.",
      create_standalone_session_failed: "Failed to create standalone session."
    },
    standalone_session_created: "Standalone session created."
  };
  const errors = {
    speech_is_not_supported: "Speech is not supported in this browser."
  };
  const sidebar = {
    user: "User",
    contact: "Contact",
    sessions: "Sessions",
    new_session: "New Session",
    more_session: "More",
    applications: "Applications",
    application_types: {
      chat: "Chat"
    }
  };
  const documents = {
    title: "Documents",
    playground: {
      title: "Playground",
      drag_and_drop: "Drag and Drop",
      node_connections: "Node Connections",
      delete_nodes: "Delete Nodes"
    },
    model: {
      title: "Models",
      llm: "LLM",
      embedding: "Embedding"
    },
    tutorial: {
      title: "Tutorial",
      get_started: "Get Started",
      chat_with_llm: "Chat with LLM",
      ai_structured_output: "AI Structured Output",
      tool_calling: "Tool Calling",
      few_shot_example: "Few Shot Example",
      vector_database: "Vector Database"
    },
    application: {
      title: "Application",
      changelog: "Changelog"
    }
  };
  const create_new_message = {
    initial_ai_message: "I'm thinking...",
    errors: {
      ai_message_content_failed: "Failed to create message."
    }
  };
  const flows = {
    supported_nodes: {
      add_llm: "LLM",
      add_prompt: "Prompt",
      add_tool_definition: "Tool",
      add_schema: "Schema",
      add_few_shot_example: "Few Shot Example",
      add_vector_database: "Vector Database",
      add_text_data: "Text Data",
      more: "...More"
    },
    toolbar_node: {
      title: "Toolbar",
      add_node: ""
    },
    llm_node: {
      create_thread_button: "Create Thread",
      load_model_button: "Load Model",
      download_model_button: "Download and Load Model",
      errors: {
        loading_model: "Failed to load model."
      }
    },
    thread_node: {
      title: "Thread",
      structured_output: "Structured Output",
      prompts: {
        human: "Human Prompt",
        ai: "AI Prompt",
        system: "System Prompt",
        tool: "Tool Prompt",
        few_shot_example: "Few Shot Example Prompt"
      },
      errors: {
        llm_not_loaded_yet: "LLM not loaded yet."
      },
      clone: "Clone",
      hide: "Hide",
      vector_database_retriever: "Vector Database Retriever"
    },
    message_node: {
      message_roles: {
        ai: "AI",
        human: "Human",
        system: "System",
        assistant: "Assistant"
      },
      errors: {
        llm_not_found: "LLM not found.",
        llm_not_loaded: "Model '{{name}}' not loaded yet.",
        llm_not_loaded_yet: "LLM not loaded yet.",
        create_message: "Failed to create message."
      },
      tool_call: "{{name}} ({{args}})",
      new_thread: "Thread",
      hide_thread: "Hide"
    },
    session_info_node: {
      entities: {
        nodes: "Nodes",
        edges: "Edges",
        threads: "Threads",
        llms: "LLMs",
        message: "Message",
        prompts: "Prompts",
        schemas: "Schemas",
        tools: "Tools",
        emmbeding: "Embedding",
        vector_databases: "Vector Databases",
        jsonl_data: "JSON Data",
        csv_data: "CSV Data"
      },
      title: "Session",
      disk_size: "Disk Size",
      reload: "Reload",
      cached_llms: "Cached LLM",
      used_bytes: "Used {{used}} out of {{total}}.",
      count_info: {
        nodes: "Number of Nodes: {{count}}",
        threads: "Number of Threads: {{count}}",
        messages: "Number of Messages: {{count}}",
        llms: "Number of LLMs: {{count}}",
        edges: "Number of Edges: {{count}}",
        prompts: "Number of Prompts: {{count}}",
        title: "Current Session Count"
      }
    },
    schema_node: {
      typescript: "TypeScript",
      zod: "zod"
    },
    vector_database_node: {
      k_select_placeholder: "Select a k value",
      similarity_search_placeholder: "Search similar ...",
      similarity_search_result: "Similarity Search Result",
      score: "Score",
      content: "Content",
      errors: {
        similarity_search_failed: "Failed to search similar text.",
        vector_database_not_found: "Vector database not found.",
        data_node_not_found: "Data node not found.",
        content_not_found: "Must provide content or documents."
      },
      storage_type: "Storage Type",
      storage_types: {
        datanode: "DataNode",
        indexeddb: "IndexedDB"
      },
      search: "Search",
      text: "Text",
      file: "File",
      create_prompt: "Create Prompt",
      add_text: {
        id: "ID",
        id_placeholder: "Input ID here...",
        content: "Content",
        content_placeholder: "Input content here...",
        add: "Add"
      },
      add_file: {
        index: "Index File"
      },
      to_retriever: "To Retriever"
    },
    application_bar: {
      note: "Add Note",
      square: "Add Square",
      circle: "Add Circle",
      triangle: "Add Triangle",
      errors: {
        add_node_failed: "Failed to add node."
      },
      code_editor: "Code Container Editor",
      vslite: "VS Lite"
    },
    editor_node: {
      errors: {
        llm_not_found: "LLM not found.",
        llm_not_loaded_yet: "LLM not loaded yet.",
        stream_message_failed: "Failed to stream message."
      }
    },
    placeholder_node: {
      vector_database_retriever: "Vector Database Retriever"
    },
    code_container_app: {}
  };
  const components = {
    add_llm_card: {
      title: "LLM",
      button_add: "Create",
      button_download_and_add: "Create",
      model_name: "Model",
      select_model_placeholder: "Select a model",
      search_placeholder: "Search model...",
      no_model: "No model found",
      providers: {
        webllm: "WebLLM",
        openai: "OpenAI"
      },
      provider: "Provider",
      provider_select_placeholder: "Select a provider",
      has_model_cache: "Has Model Cache",
      model_lib_url: "Library URL:",
      low_resource_required: "Low resource required",
      model_url: "URL:",
      metadata: "Metadata: ",
      errors: {
        failed_to_create: "Failed to create LLM."
      }
    },
    add_tool_card: {
      title: "Tool",
      tool_name: "Name",
      name_placeholder: "Input tool name...",
      button: "Create",
      tool_description: "Description",
      description_placeholder: "Input tool description...",
      tool_schema: "Schema",
      create: "Create"
    },
    add_schema_card: {
      title: "Schema",
      no_data: "No fields.",
      add: "Create",
      field: {
        required: "Required",
        type: "Type",
        type_placeholder: "Select a filed data type",
        description: "Description",
        description_placeholder: "Input filed description",
        name: "Name",
        name_placeholder: "Input filed name",
        actions: "Actions",
        add_field: "Add Field",
        "enum": "Enum"
      },
      types: {
        string: "String",
        number: "Number",
        boolean: "Boolean",
        object: "Object",
        array: "Array"
      },
      create: "Create",
      children: "Children"
    },
    add_message_card: {
      title: "Send Message",
      button: "Send",
      placeholder: "Type your message here..."
    },
    add_prompt_card: {
      prompt_content: "Content",
      prompt_prefix: "Prefix",
      prompt_type: "Type",
      prompt_role: "Role",
      type_select_placeholder: "Select prompt type",
      role_select_placeholder: "Select prompt role",
      prompt_types: {
        chat: "Chat",
        few_shot_example: "Few Shot Example"
      },
      prompt_roles: {
        system: "System",
        human: "Human",
        ai: "AI",
        few_shot_example: "Few Shot Example"
      },
      title: "Prompt",
      placeholder: "Type your prompt here...",
      button: "Create",
      few_shot_example_note: "Use {input} to represent the input in the prompt. And use {output} to represent the output. For example, Question: {input}\nAnswer: {output}"
    },
    add_few_shot_example_card: {
      title: "Few Shot Example",
      input: "Input",
      input_placeholder: "Type example input here...",
      output: "Output",
      output_placeholder: "Type example output here...",
      add: "Add",
      create: "Create"
    },
    create_vector_database_card: {
      title: "Vector Database",
      create: "Create",
      provider: "Provider",
      provider_select_placeholder: "Select a provider",
      providers: {
        memory: "Memory",
        voy: "Voy"
      },
      text_splitter: "Text Splitter",
      text_splitter_select_placeholder: "Select a text splitter...",
      text_splitters: {
        tokentextsplitter: "Token Text Splitter",
        charactertextsplitter: "Character Text Splitter",
        recursivecharactertextsplitter: "Recursive Character Text Splitter"
      },
      name: "Name",
      text_splitter_configuration: "Text Splitter Configuration",
      text_splitter_chunksize: "Chunk Size",
      text_splitter_chunksize_placeholder: "Input chunk size...",
      text_splitter_chunkoverlap: "Chunk Overlap",
      text_splitter_chunkoverlap_placeholder: "Input chunk overlap...",
      errors: {
        create_failed: "Failed to create vector database."
      }
    },
    add_text_data: {
      title: "Text Data",
      id: "ID",
      id_placeholder: "Input ID here...",
      text: "Content",
      text_placeholder: "Input text here...",
      add: "Add",
      create: "Create"
    },
    add_source_base: {
      title: "Source Base",
      source_base_select_placeholder: "Select a source base",
      sourcebases: {
        "vite-vue": "Vite + Vue",
        "shadcn-react-vite": "React + Vite + Shadcn UI"
      },
      update_source: "Update Source"
    },
    vslite: {
      load_app_container: "Load Container"
    }
  };
  const dialogs = {
    create_session: {
      title: "Create Session",
      description: "Create a new session to start building your own AI flow.",
      name: "Name",
      name_placeholder: "Input session name...",
      create: "Create",
      errors: {
        create_failed: "Failed to create session."
      }
    },
    create_standalone_application: {
      title: "Create Application",
      description: "Create a standalone application from current node.",
      name: "Name",
      name_placeholder: "Input application name...",
      create: "Create",
      errors: {
        create_failed: "Failed to create application."
      }
    },
    delete_session: {
      title: "Are you sure to delete this session?",
      description: "Deleting this session will remove all the data in this session.",
      cancel: "Cancel",
      "delete": "Delete",
      errors: {
        delete_failed: "Failed to delete session."
      }
    },
    create_vector_database_prompt: {
      title: "Create prompt from search result",
      fill_content_note: "Use {content} as similarity result placeholder in the prompt.",
      errors: {
        fill_context: "prompt content is required and must contain '{context}' as placeholder.",
        create_failed: "Failed to create prompt."
      }
    },
    create_vector_database_retriever: {
      title: "Create Vector Database Retriever",
      fill_content_note: "Use '{context}' as similarity result placeholder in the prompt.",
      errors: {
        fill_context: "prompt content is required and must contain '{context}' as placeholder.",
        create_failed: "Failed to create vector database retriever."
      },
      retriever_settings: "Retriever Settings",
      retriever_k: "K (Expected number of results)",
      retriever_k_placeholder: "Input K value...",
      retriever_minimum_score: "Minimum Score (0-100)",
      retriever_minimum_score_placeholder: "Input minimum score..."
    }
  };
  const atoms = {
    file_upload_input: {
      drop_file: "Drag and drop or click to upload",
      errors: {
        max_size: "File size must be less than {{maxSize}}MB. Your file {{fileSize}}MB.",
        accept: "File type must be {{accept}}"
      }
    },
    pagination: {
      previous: "Previous",
      next: "Next",
      more_pages: "More pages"
    },
    llm_info: {
      function_calling: "Function Calling",
      low_resource_required: "Low resource required",
      cached: "Cached",
      recommended: "Recommended",
      model_types: {
        llm: "LLM",
        embedding: "Embedding",
        vlm: "Vision"
      }
    }
  };
  const en = {
    common,
    errors,
    sidebar,
    documents,
    create_new_message,
    flows,
    components,
    dialogs,
    atoms
  };
  const resources = {
    en
  };
  instance.use(initReactI18next).init({
    resources,
    lng: "en",
    interpolation: {
      escapeValue: false
    }
  });
  var dayjs_min = {
    exports: {}
  };
  (function(module2, exports) {
    !function(t2, e) {
      module2.exports = e();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s = "minute", u2 = "hour", a = "day", o = "week", c = "month", f2 = "quarter", h = "year", d = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function(t3) {
          var e2 = [
            "th",
            "st",
            "nd",
            "rd"
          ], n3 = t3 % 100;
          return "[" + t3 + (e2[(n3 - 20) % 10] || e2[n3] || e2[0]) + "]";
        }
      }, m2 = function(t3, e2, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e2 ? t3 : "" + Array(e2 + 1 - r3.length).join(n3) + t3;
      }, v2 = {
        s: m2,
        z: function(t3) {
          var e2 = -t3.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
          return (e2 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
        },
        m: function t3(e2, n3) {
          if (e2.date() < n3.date()) return -t3(n3, e2);
          var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, c), s2 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s2 ? -1 : 1), c);
          return +(-(r3 + (n3 - i3) / (s2 ? i3 - u3 : u3 - i3)) || 0);
        },
        a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        },
        p: function(t3) {
          return {
            M: c,
            y: h,
            w: o,
            d: a,
            D: d,
            h: u2,
            m: s,
            s: i2,
            ms: r2,
            Q: f2
          }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        },
        u: function(t3) {
          return void 0 === t3;
        }
      }, g = "en", D2 = {};
      D2[g] = M2;
      var p2 = "$isDayjsObject", S2 = function(t3) {
        return t3 instanceof _ || !(!t3 || !t3[p2]);
      }, w2 = function t3(e2, n3, r3) {
        var i3;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D2[s2] && (i3 = s2), n3 && (D2[s2] = n3, i3 = s2);
          var u3 = e2.split("-");
          if (!i3 && u3.length > 1) return t3(u3[0]);
        } else {
          var a2 = e2.name;
          D2[a2] = e2, i3 = a2;
        }
        return !r3 && i3 && (g = i3), i3 || !r3 && g;
      }, O2 = function(t3, e2) {
        if (S2(t3)) return t3.clone();
        var n3 = "object" == typeof e2 ? e2 : {};
        return n3.date = t3, n3.args = arguments, new _(n3);
      }, b = v2;
      b.l = w2, b.i = S2, b.w = function(t3, e2) {
        return O2(t3, {
          locale: e2.$L,
          utc: e2.$u,
          x: e2.$x,
          $offset: e2.$offset
        });
      };
      var _ = function() {
        function M3(t3) {
          this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
        }
        var m3 = M3.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e2 = t4.date, n3 = t4.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r3 = e2.match($);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e2) {
          var n3 = O2(t3);
          return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
        }, m3.isAfter = function(t3, e2) {
          return O2(t3) < this.startOf(e2);
        }, m3.isBefore = function(t3, e2) {
          return this.endOf(e2) < O2(t3);
        }, m3.$g = function(t3, e2, n3) {
          return b.u(t3) ? this[e2] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e2) {
          var n3 = this, r3 = !!b.u(e2) || e2, f3 = b.p(t3), l3 = function(t4, e3) {
            var i3 = b.w(n3.$u ? Date.UTC(n3.$y, e3, t4) : new Date(n3.$y, e3, t4), n3);
            return r3 ? i3 : i3.endOf(a);
          }, $2 = function(t4, e3) {
            return b.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [
              0,
              0,
              0,
              0
            ] : [
              23,
              59,
              59,
              999
            ]).slice(e3)), n3);
          }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c:
              return r3 ? l3(1, M4) : l3(0, M4 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D3 = (y3 < g2 ? y3 + 7 : y3) - g2;
              return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
            case a:
            case d:
              return $2(v3 + "Hours", 0);
            case u2:
              return $2(v3 + "Minutes", 1);
            case s:
              return $2(v3 + "Seconds", 2);
            case i2:
              return $2(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e2) {
          var n3, o2 = b.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d] = f3 + "Date", n3[c] = f3 + "Month", n3[h] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y3 = this.clone().set(d, 1);
            y3.$d[l3]($2), y3.init(), this.$d = y3.set(d, Math.min(this.$D, y3.daysInMonth())).$d;
          } else l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m3.set = function(t3, e2) {
          return this.clone().$set(t3, e2);
        }, m3.get = function(t3) {
          return this[b.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d2, l3 = this;
          r3 = Number(r3);
          var $2 = b.p(f3), y3 = function(t3) {
            var e2 = O2(l3);
            return b.w(e2.date(e2.date() + Math.round(t3 * r3)), l3);
          };
          if ($2 === c) return this.set(c, this.$M + r3);
          if ($2 === h) return this.set(h, this.$y + r3);
          if ($2 === a) return y3(1);
          if ($2 === o) return y3(7);
          var M4 = (d2 = {}, d2[s] = e, d2[u2] = n2, d2[i2] = t2, d2)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
          return b.w(m4, this);
        }, m3.subtract = function(t3, e2) {
          return this.add(-1 * t3, e2);
        }, m3.format = function(t3) {
          var e2 = this, n3 = this.$locale();
          if (!this.isValid()) return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o2 = n3.weekdays, c2 = n3.months, f3 = n3.meridiem, h2 = function(t4, n4, i4, s3) {
            return t4 && (t4[n4] || t4(e2, r3)) || i4[n4].slice(0, s3);
          }, d2 = function(t4) {
            return b.s(s2 % 12 || 12, t4, "0");
          }, $2 = f3 || function(t4, e3, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y2, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n3.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n3.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n3.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u3, true);
                case "A":
                  return $2(s2, u3, false);
                case "m":
                  return String(u3);
                case "mm":
                  return b.s(u3, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d2, l3) {
          var $2, y3 = this, M4 = b.p(d2), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e, g2 = this - m4, D3 = function() {
            return b.m(y3, m4);
          };
          switch (M4) {
            case h:
              $2 = D3() / 12;
              break;
            case c:
              $2 = D3();
              break;
            case f2:
              $2 = D3() / 3;
              break;
            case o:
              $2 = (g2 - v3) / 6048e5;
              break;
            case a:
              $2 = (g2 - v3) / 864e5;
              break;
            case u2:
              $2 = g2 / n2;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i2:
              $2 = g2 / t2;
              break;
            default:
              $2 = g2;
          }
          return l3 ? $2 : b.a($2);
        }, m3.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m3.$locale = function() {
          return D2[this.$L];
        }, m3.locale = function(t3, e2) {
          if (!t3) return this.$L;
          var n3 = this.clone(), r3 = w2(t3, e2, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k2 = _.prototype;
      return O2.prototype = k2, [
        [
          "$ms",
          r2
        ],
        [
          "$s",
          i2
        ],
        [
          "$m",
          s
        ],
        [
          "$H",
          u2
        ],
        [
          "$W",
          a
        ],
        [
          "$M",
          c
        ],
        [
          "$y",
          h
        ],
        [
          "$D",
          d
        ]
      ].forEach(function(t3) {
        k2[t3[1]] = function(e2) {
          return this.$g(e2, t3[0], t3[1]);
        };
      }), O2.extend = function(t3, e2) {
        return t3.$i || (t3(e2, _, O2), t3.$i = true), O2;
      }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
        return O2(1e3 * t3);
      }, O2.en = D2[g], O2.Ls = D2, O2.p = {}, O2;
    });
  })(dayjs_min);
  var dayjs_minExports = dayjs_min.exports;
  dayjs = getDefaultExportFromCjs$1(dayjs_minExports);
  var relativeTime = {
    exports: {}
  };
  (function(module2, exports) {
    !function(r2, e) {
      module2.exports = e();
    }(commonjsGlobal, function() {
      return function(r2, e, t2) {
        r2 = r2 || {};
        var n2 = e.prototype, o = {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        };
        function i2(r3, e2, t3, o2) {
          return n2.fromToBase(r3, e2, t3, o2);
        }
        t2.en.relativeTime = o, n2.fromToBase = function(e2, n3, i3, d2, u2) {
          for (var f2, a, s, l2 = i3.$locale().relativeTime || o, h = r2.thresholds || [
            {
              l: "s",
              r: 44,
              d: "second"
            },
            {
              l: "m",
              r: 89
            },
            {
              l: "mm",
              r: 44,
              d: "minute"
            },
            {
              l: "h",
              r: 89
            },
            {
              l: "hh",
              r: 21,
              d: "hour"
            },
            {
              l: "d",
              r: 35
            },
            {
              l: "dd",
              r: 25,
              d: "day"
            },
            {
              l: "M",
              r: 45
            },
            {
              l: "MM",
              r: 10,
              d: "month"
            },
            {
              l: "y",
              r: 17
            },
            {
              l: "yy",
              d: "year"
            }
          ], m2 = h.length, c = 0; c < m2; c += 1) {
            var y2 = h[c];
            y2.d && (f2 = d2 ? t2(e2).diff(i3, y2.d, true) : i3.diff(e2, y2.d, true));
            var p2 = (r2.rounding || Math.round)(Math.abs(f2));
            if (s = f2 > 0, p2 <= y2.r || !y2.r) {
              p2 <= 1 && c > 0 && (y2 = h[c - 1]);
              var v2 = l2[y2.l];
              u2 && (p2 = u2("" + p2)), a = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n3, y2.l, s);
              break;
            }
          }
          if (n3) return a;
          var M2 = s ? l2.future : l2.past;
          return "function" == typeof M2 ? M2(a) : M2.replace("%s", a);
        }, n2.to = function(r3, e2) {
          return i2(r3, e2, this, true);
        }, n2.from = function(r3, e2) {
          return i2(r3, e2, this);
        };
        var d = function(r3) {
          return r3.$u ? t2.utc() : t2();
        };
        n2.toNow = function(r3) {
          return this.to(d(this), r3);
        }, n2.fromNow = function(r3) {
          return this.from(d(this), r3);
        };
      };
    });
  })(relativeTime);
  var relativeTimeExports = relativeTime.exports;
  const relatedTime = getDefaultExportFromCjs$1(relativeTimeExports);
  const ErrorBoundaryContext = reactExports.createContext(null);
  const initialState$1 = {
    didCatch: false,
    error: null
  };
  class ErrorBoundary extends reactExports.Component {
    constructor(props) {
      super(props);
      this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
      this.state = initialState$1;
    }
    static getDerivedStateFromError(error) {
      return {
        didCatch: true,
        error
      };
    }
    resetErrorBoundary() {
      const { error } = this.state;
      if (error !== null) {
        var _this$props$onReset, _this$props;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
          args,
          reason: "imperative-api"
        });
        this.setState(initialState$1);
      }
    }
    componentDidCatch(error, info) {
      var _this$props$onError, _this$props2;
      (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
    }
    componentDidUpdate(prevProps, prevState) {
      const { didCatch } = this.state;
      const { resetKeys } = this.props;
      if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
        var _this$props$onReset2, _this$props3;
        (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
          next: resetKeys,
          prev: prevProps.resetKeys,
          reason: "keys"
        });
        this.setState(initialState$1);
      }
    }
    render() {
      const { children, fallbackRender, FallbackComponent, fallback } = this.props;
      const { didCatch, error } = this.state;
      let childToRender = children;
      if (didCatch) {
        const props = {
          error,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (typeof fallbackRender === "function") {
          childToRender = fallbackRender(props);
        } else if (FallbackComponent) {
          childToRender = reactExports.createElement(FallbackComponent, props);
        } else if (fallback === null || reactExports.isValidElement(fallback)) {
          childToRender = fallback;
        } else {
          throw error;
        }
      }
      return reactExports.createElement(ErrorBoundaryContext.Provider, {
        value: {
          didCatch,
          error,
          resetErrorBoundary: this.resetErrorBoundary
        }
      }, childToRender);
    }
  }
  function hasArrayChanged() {
    let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return a.length !== b.length || a.some((item, index2) => !Object.is(item, b[index2]));
  }
  const TOAST_LIMIT = 1;
  const TOAST_REMOVE_DELAY = 1e6;
  let count = 0;
  function genId() {
    count = (count + 1) % Number.MAX_SAFE_INTEGER;
    return count.toString();
  }
  const toastTimeouts = /* @__PURE__ */ new Map();
  const addToRemoveQueue = (toastId) => {
    if (toastTimeouts.has(toastId)) {
      return;
    }
    const timeout = setTimeout(() => {
      toastTimeouts.delete(toastId);
      dispatch$1({
        type: "REMOVE_TOAST",
        toastId
      });
    }, TOAST_REMOVE_DELAY);
    toastTimeouts.set(toastId, timeout);
  };
  const reducer$1 = (state, action) => {
    switch (action.type) {
      case "ADD_TOAST":
        return {
          ...state,
          toasts: [
            action.toast,
            ...state.toasts
          ].slice(0, TOAST_LIMIT)
        };
      case "UPDATE_TOAST":
        return {
          ...state,
          toasts: state.toasts.map((t2) => t2.id === action.toast.id ? {
            ...t2,
            ...action.toast
          } : t2)
        };
      case "DISMISS_TOAST": {
        const { toastId } = action;
        if (toastId) {
          addToRemoveQueue(toastId);
        } else {
          state.toasts.forEach((toast2) => {
            addToRemoveQueue(toast2.id);
          });
        }
        return {
          ...state,
          toasts: state.toasts.map((t2) => t2.id === toastId || toastId === void 0 ? {
            ...t2,
            open: false
          } : t2)
        };
      }
      case "REMOVE_TOAST":
        if (action.toastId === void 0) {
          return {
            ...state,
            toasts: []
          };
        }
        return {
          ...state,
          toasts: state.toasts.filter((t2) => t2.id !== action.toastId)
        };
    }
  };
  const listeners = [];
  let memoryState = {
    toasts: []
  };
  function dispatch$1(action) {
    memoryState = reducer$1(memoryState, action);
    listeners.forEach((listener) => {
      listener(memoryState);
    });
  }
  toast = function({ ...props }) {
    const id2 = genId();
    const update = (props2) => dispatch$1({
      type: "UPDATE_TOAST",
      toast: {
        ...props2,
        id: id2
      }
    });
    const dismiss = () => dispatch$1({
      type: "DISMISS_TOAST",
      toastId: id2
    });
    dispatch$1({
      type: "ADD_TOAST",
      toast: {
        ...props,
        id: id2,
        open: true,
        onOpenChange: (open) => {
          if (!open) dismiss();
        }
      }
    });
    return {
      id: id2,
      dismiss,
      update
    };
  };
  useToast = function() {
    const [state, setState] = reactExports.useState(memoryState);
    reactExports.useEffect(() => {
      listeners.push(setState);
      return () => {
        const index2 = listeners.indexOf(setState);
        if (index2 > -1) {
          listeners.splice(index2, 1);
        }
      };
    }, [
      state
    ]);
    return {
      ...state,
      toast,
      dismiss: (toastId) => dispatch$1({
        type: "DISMISS_TOAST",
        toastId
      })
    };
  };
  composeEventHandlers = function(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler == null ? void 0 : originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented) {
        return ourEventHandler == null ? void 0 : ourEventHandler(event);
      }
    };
  };
  function setRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  composeRefs = function(...refs) {
    return (node) => refs.forEach((ref) => setRef(ref, node));
  };
  useComposedRefs = function(...refs) {
    return reactExports.useCallback(composeRefs(...refs), refs);
  };
  function createContextScope$1(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      const BaseContext = reactExports.createContext(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider2(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 == null ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = reactExports.useMemo(() => context, Object.values(context));
        return jsxRuntimeExports.jsx(Context.Provider, {
          value,
          children
        });
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 == null ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = reactExports.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider2.displayName = rootComponentName + "Provider";
      return [
        Provider2,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return reactExports.createContext(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 == null ? void 0 : scope2[scopeName]) || scopeContexts;
        return reactExports.useMemo(() => ({
          [`__scope${scopeName}`]: {
            ...scope2,
            [scopeName]: contexts
          }
        }), [
          scope2,
          contexts
        ]);
      };
    };
    createScope.scopeName = scopeName;
    return [
      createContext3,
      composeContextScopes$1(createScope, ...createContextScopeDeps)
    ];
  }
  function composeContextScopes$1(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes2,
            ...currentScope
          };
        }, {});
        return reactExports.useMemo(() => ({
          [`__scope${baseScope.scopeName}`]: nextScopes
        }), [
          nextScopes
        ]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }
  Slot = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return jsxRuntimeExports.jsx(SlotClone, {
        ...slotProps,
        ref: forwardedRef,
        children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null
      });
    }
    return jsxRuntimeExports.jsx(SlotClone, {
      ...slotProps,
      ref: forwardedRef,
      children
    });
  });
  Slot.displayName = "Slot";
  var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      return reactExports.cloneElement(children, {
        ...mergeProps(slotProps, children.props),
        ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
      });
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = "SlotClone";
  Slottable = ({ children }) => {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children
    });
  };
  function isSlottable(child) {
    return reactExports.isValidElement(child) && child.type === Slottable;
  }
  function mergeProps(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue) {
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        } else if (slotPropValue) {
          overrideProps[propName] = slotPropValue;
        }
      } else if (propName === "style") {
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      } else if (propName === "className") {
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
      }
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }
  function getElementRef$1(element) {
    var _a, _b;
    let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
  createCollection = function(name) {
    const PROVIDER_NAME2 = name + "CollectionProvider";
    const [createCollectionContext, createCollectionScope2] = createContextScope$1(PROVIDER_NAME2);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME2, {
      collectionRef: {
        current: null
      },
      itemMap: /* @__PURE__ */ new Map()
    });
    const CollectionProvider = (props) => {
      const { scope: scope2, children } = props;
      const ref = React.useRef(null);
      const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
      return jsxRuntimeExports.jsx(CollectionProviderImpl, {
        scope: scope2,
        itemMap,
        collectionRef: ref,
        children
      });
    };
    CollectionProvider.displayName = PROVIDER_NAME2;
    const COLLECTION_SLOT_NAME = name + "CollectionSlot";
    const CollectionSlot = React.forwardRef((props, forwardedRef) => {
      const { scope: scope2, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope2);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return jsxRuntimeExports.jsx(Slot, {
        ref: composedRefs,
        children
      });
    });
    CollectionSlot.displayName = COLLECTION_SLOT_NAME;
    const ITEM_SLOT_NAME = name + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlot = React.forwardRef((props, forwardedRef) => {
      const { scope: scope2, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope2);
      React.useEffect(() => {
        context.itemMap.set(ref, {
          ref,
          ...itemData
        });
        return () => void context.itemMap.delete(ref);
      });
      return jsxRuntimeExports.jsx(Slot, {
        ...{
          [ITEM_DATA_ATTR]: ""
        },
        ref: composedRefs,
        children
      });
    });
    CollectionItemSlot.displayName = ITEM_SLOT_NAME;
    function useCollection2(scope2) {
      const context = useCollectionContext(name + "CollectionConsumer", scope2);
      const getItems = React.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode) return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current));
        return orderedItems;
      }, [
        context.collectionRef,
        context.itemMap
      ]);
      return getItems;
    }
    return [
      {
        Provider: CollectionProvider,
        Slot: CollectionSlot,
        ItemSlot: CollectionItemSlot
      },
      useCollection2,
      createCollectionScope2
    ];
  };
  createContext2 = function(rootComponentName, defaultContext) {
    const Context = reactExports.createContext(defaultContext);
    const Provider2 = (props) => {
      const { children, ...context } = props;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return jsxRuntimeExports.jsx(Context.Provider, {
        value,
        children
      });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName) {
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [
      Provider2,
      useContext2
    ];
  };
  createContextScope = function(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function createContext3(rootComponentName, defaultContext) {
      const BaseContext = reactExports.createContext(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      const Provider2 = (props) => {
        var _a;
        const { scope: scope2, children, ...context } = props;
        const Context = ((_a = scope2 == null ? void 0 : scope2[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
        const value = reactExports.useMemo(() => context, Object.values(context));
        return jsxRuntimeExports.jsx(Context.Provider, {
          value,
          children
        });
      };
      Provider2.displayName = rootComponentName + "Provider";
      function useContext2(consumerName, scope2) {
        var _a;
        const Context = ((_a = scope2 == null ? void 0 : scope2[scopeName]) == null ? void 0 : _a[index2]) || BaseContext;
        const context = reactExports.useContext(Context);
        if (context) return context;
        if (defaultContext !== void 0) return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      return [
        Provider2,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return reactExports.createContext(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 == null ? void 0 : scope2[scopeName]) || scopeContexts;
        return reactExports.useMemo(() => ({
          [`__scope${scopeName}`]: {
            ...scope2,
            [scopeName]: contexts
          }
        }), [
          scope2,
          contexts
        ]);
      };
    };
    createScope.scopeName = scopeName;
    return [
      createContext3,
      composeContextScopes(createScope, ...createContextScopeDeps)
    ];
  };
  function composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1) return baseScope;
    const createScope = () => {
      const scopeHooks = scopes.map((createScope2) => ({
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      }));
      return function useComposedScopes(overrideScopes) {
        const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes2,
            ...currentScope
          };
        }, {});
        return reactExports.useMemo(() => ({
          [`__scope${baseScope.scopeName}`]: nextScopes
        }), [
          nextScopes
        ]);
      };
    };
    createScope.scopeName = baseScope.scopeName;
    return createScope;
  }
  var NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  Primitive = NODES.reduce((primitive, node) => {
    const Node = reactExports.forwardRef((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? Slot : node;
      if (typeof window !== "undefined") {
        window[Symbol.for("radix-ui")] = true;
      }
      return jsxRuntimeExports.jsx(Comp, {
        ...primitiveProps,
        ref: forwardedRef
      });
    });
    Node.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node
    };
  }, {});
  dispatchDiscreteCustomEvent = function(target, event) {
    if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
  };
  useCallbackRef = function(callback) {
    const callbackRef = reactExports.useRef(callback);
    reactExports.useEffect(() => {
      callbackRef.current = callback;
    });
    return reactExports.useMemo(() => (...args) => {
      var _a;
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    }, []);
  };
  function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape") {
          onEscapeKeyDown(event);
        }
      };
      ownerDocument.addEventListener("keydown", handleKeyDown, {
        capture: true
      });
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown, {
        capture: true
      });
    }, [
      onEscapeKeyDown,
      ownerDocument
    ]);
  }
  var DISMISSABLE_LAYER_NAME = "DismissableLayer";
  var CONTEXT_UPDATE = "dismissableLayer.update";
  var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var originalBodyPointerEvents;
  var DismissableLayerContext = reactExports.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  DismissableLayer = reactExports.forwardRef((props, forwardedRef) => {
    const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = (node == null ? void 0 : node.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
      ...context.layersWithOutsidePointerEventsDisabled
    ].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [
        ...context.branches
      ].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside == null ? void 0 : onPointerDownOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [
        ...context.branches
      ].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside == null ? void 0 : onFocusOutside(event);
      onInteractOutside == null ? void 0 : onInteractOutside(event);
      if (!event.defaultPrevented) onDismiss == null ? void 0 : onDismiss();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [
      node,
      ownerDocument,
      disableOutsidePointerEvents,
      context
    ]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [
      node,
      context
    ]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return jsxRuntimeExports.jsx(Primitive.div, {
      ...layerProps,
      ref: composedRefs,
      style: {
        pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
        ...props.style
      },
      onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
      onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
      onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
    });
  });
  DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
  var BRANCH_NAME = "DismissableLayerBranch";
  var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
    const context = reactExports.useContext(DismissableLayerContext);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      const node = ref.current;
      if (node) {
        context.branches.add(node);
        return () => {
          context.branches.delete(node);
        };
      }
    }, [
      context.branches
    ]);
    return jsxRuntimeExports.jsx(Primitive.div, {
      ...props,
      ref: composedRefs
    });
  });
  DismissableLayerBranch.displayName = BRANCH_NAME;
  function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
    const isPointerInsideReactTreeRef = reactExports.useRef(false);
    const handleClickRef = reactExports.useRef(() => {
    });
    reactExports.useEffect(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent2 = function() {
            handleAndDispatchCustomEvent$1(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
              discrete: true
            });
          };
          const eventDetail = {
            originalEvent: event
          };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
            ownerDocument.addEventListener("click", handleClickRef.current, {
              once: true
            });
          } else {
            handleAndDispatchPointerDownOutsideEvent2();
          }
        } else {
          ownerDocument.removeEventListener("click", handleClickRef.current);
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [
      ownerDocument,
      handlePointerDownOutside
    ]);
    return {
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function useFocusOutside(onFocusOutside, ownerDocument = globalThis == null ? void 0 : globalThis.document) {
    const handleFocusOutside = useCallbackRef(onFocusOutside);
    const isFocusInsideReactTreeRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = {
            originalEvent: event
          };
          handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [
      ownerDocument,
      handleFocusOutside
    ]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function dispatchUpdate() {
    const event = new CustomEvent(CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function handleAndDispatchCustomEvent$1(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, {
      bubbles: false,
      cancelable: true,
      detail
    });
    if (handler) target.addEventListener(name, handler, {
      once: true
    });
    if (discrete) {
      dispatchDiscreteCustomEvent(target, event);
    } else {
      target.dispatchEvent(event);
    }
  }
  var Root$1 = DismissableLayer;
  var Branch = DismissableLayerBranch;
  useLayoutEffect2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
  };
  var PORTAL_NAME = "Portal";
  Portal = reactExports.forwardRef((props, forwardedRef) => {
    var _a;
    const { container: containerProp, ...portalProps } = props;
    const [mounted, setMounted] = reactExports.useState(false);
    useLayoutEffect2(() => setMounted(true), []);
    const container = containerProp || mounted && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body);
    return container ? ReactDOM.createPortal(jsxRuntimeExports.jsx(Primitive.div, {
      ...portalProps,
      ref: forwardedRef
    }), container) : null;
  });
  Portal.displayName = PORTAL_NAME;
  function useStateMachine(initialState2, machine) {
    return reactExports.useReducer((state, event) => {
      const nextState = machine[state][event];
      return nextState ?? state;
    }, initialState2);
  }
  Presence = (props) => {
    const { present, children } = props;
    const presence = usePresence$1(present);
    const child = typeof children === "function" ? children({
      present: presence.isPresent
    }) : reactExports.Children.only(children);
    const ref = useComposedRefs(presence.ref, getElementRef(child));
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? reactExports.cloneElement(child, {
      ref
    }) : null;
  };
  Presence.displayName = "Presence";
  function usePresence$1(present) {
    const [node, setNode] = reactExports.useState();
    const stylesRef = reactExports.useRef({});
    const prevPresentRef = reactExports.useRef(present);
    const prevAnimationNameRef = reactExports.useRef("none");
    const initialState2 = present ? "mounted" : "unmounted";
    const [state, send] = useStateMachine(initialState2, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    reactExports.useEffect(() => {
      const currentAnimationName = getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [
      state
    ]);
    useLayoutEffect2(() => {
      const styles2 = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = getAnimationName(styles2);
        if (present) {
          send("MOUNT");
        } else if (currentAnimationName === "none" || (styles2 == null ? void 0 : styles2.display) === "none") {
          send("UNMOUNT");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating) {
            send("ANIMATION_OUT");
          } else {
            send("UNMOUNT");
          }
        }
        prevPresentRef.current = present;
      }
    }, [
      present,
      send
    ]);
    useLayoutEffect2(() => {
      if (node) {
        let timeoutId;
        const ownerWindow = node.ownerDocument.defaultView ?? window;
        const handleAnimationEnd = (event) => {
          const currentAnimationName = getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node && isCurrentAnimation) {
            send("ANIMATION_END");
            if (!prevPresentRef.current) {
              const currentFillMode = node.style.animationFillMode;
              node.style.animationFillMode = "forwards";
              timeoutId = ownerWindow.setTimeout(() => {
                if (node.style.animationFillMode === "forwards") {
                  node.style.animationFillMode = currentFillMode;
                }
              });
            }
          }
        };
        const handleAnimationStart = (event) => {
          if (event.target === node) {
            prevAnimationNameRef.current = getAnimationName(stylesRef.current);
          }
        };
        node.addEventListener("animationstart", handleAnimationStart);
        node.addEventListener("animationcancel", handleAnimationEnd);
        node.addEventListener("animationend", handleAnimationEnd);
        return () => {
          ownerWindow.clearTimeout(timeoutId);
          node.removeEventListener("animationstart", handleAnimationStart);
          node.removeEventListener("animationcancel", handleAnimationEnd);
          node.removeEventListener("animationend", handleAnimationEnd);
        };
      } else {
        send("ANIMATION_END");
      }
    }, [
      node,
      send
    ]);
    return {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(state),
      ref: reactExports.useCallback((node2) => {
        if (node2) stylesRef.current = getComputedStyle(node2);
        setNode(node2);
      }, [])
    };
  }
  function getAnimationName(styles2) {
    return (styles2 == null ? void 0 : styles2.animationName) || "none";
  }
  function getElementRef(element) {
    var _a, _b;
    let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
  useControllableState = function({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value = isControlled ? prop : uncontrolledProp;
    const handleChange = useCallbackRef(onChange);
    const setValue = reactExports.useCallback((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value,
      setValue
    ];
  };
  function useUncontrolledState({ defaultProp, onChange }) {
    const uncontrolledState = reactExports.useState(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = reactExports.useRef(value);
    const handleChange = useCallbackRef(onChange);
    reactExports.useEffect(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }
  var NAME = "VisuallyHidden";
  VisuallyHidden = reactExports.forwardRef((props, forwardedRef) => {
    return jsxRuntimeExports.jsx(Primitive.span, {
      ...props,
      ref: forwardedRef,
      style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...props.style
      }
    });
  });
  VisuallyHidden.displayName = NAME;
  Root = VisuallyHidden;
  var PROVIDER_NAME = "ToastProvider";
  var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
  var [createToastContext, createToastScope] = createContextScope("Toast", [
    createCollectionScope
  ]);
  var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
  var ToastProvider$1 = (props) => {
    const { __scopeToast, label = "Notification", duration = 5e3, swipeDirection = "right", swipeThreshold = 50, children } = props;
    const [viewport, setViewport] = reactExports.useState(null);
    const [toastCount, setToastCount] = reactExports.useState(0);
    const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
    const isClosePausedRef = reactExports.useRef(false);
    if (!label.trim()) {
      console.error(`Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`);
    }
    return jsxRuntimeExports.jsx(Collection.Provider, {
      scope: __scopeToast,
      children: jsxRuntimeExports.jsx(ToastProviderProvider, {
        scope: __scopeToast,
        label,
        duration,
        swipeDirection,
        swipeThreshold,
        toastCount,
        viewport,
        onViewportChange: setViewport,
        onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
        onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
        isFocusedToastEscapeKeyDownRef,
        isClosePausedRef,
        children
      })
    });
  };
  ToastProvider$1.displayName = PROVIDER_NAME;
  var VIEWPORT_NAME = "ToastViewport";
  var VIEWPORT_DEFAULT_HOTKEY = [
    "F8"
  ];
  var VIEWPORT_PAUSE = "toast.viewportPause";
  var VIEWPORT_RESUME = "toast.viewportResume";
  var ToastViewport$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, hotkey = VIEWPORT_DEFAULT_HOTKEY, label = "Notifications ({hotkey})", ...viewportProps } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        var _a;
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) (_a = ref.current) == null ? void 0 : _a.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [
      hotkey
    ]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [
      hasToasts,
      context.isClosePausedRef
    ]);
    const getSortedTabbableCandidates = reactExports.useCallback(({ tabbingDirection }) => {
      const toastItems = getItems();
      const tabbableCandidates = toastItems.map((toastItem) => {
        const toastNode = toastItem.ref.current;
        const toastTabbableCandidates = [
          toastNode,
          ...getTabbableCandidates(toastNode)
        ];
        return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
      });
      return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
    }, [
      getItems
    ]);
    reactExports.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          var _a, _b, _c;
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              (_a = headFocusProxyRef.current) == null ? void 0 : _a.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({
              tabbingDirection
            });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? (_b = headFocusProxyRef.current) == null ? void 0 : _b.focus() : (_c = tailFocusProxyRef.current) == null ? void 0 : _c.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [
      getItems,
      getSortedTabbableCandidates
    ]);
    return jsxRuntimeExports.jsxs(Branch, {
      ref: wrapperRef,
      role: "region",
      "aria-label": label.replace("{hotkey}", hotkeyLabel),
      tabIndex: -1,
      style: {
        pointerEvents: hasToasts ? void 0 : "none"
      },
      children: [
        hasToasts && jsxRuntimeExports.jsx(FocusProxy, {
          ref: headFocusProxyRef,
          onFocusFromOutsideViewport: () => {
            const tabbableCandidates = getSortedTabbableCandidates({
              tabbingDirection: "forwards"
            });
            focusFirst(tabbableCandidates);
          }
        }),
        jsxRuntimeExports.jsx(Collection.Slot, {
          scope: __scopeToast,
          children: jsxRuntimeExports.jsx(Primitive.ol, {
            tabIndex: -1,
            ...viewportProps,
            ref: composedRefs
          })
        }),
        hasToasts && jsxRuntimeExports.jsx(FocusProxy, {
          ref: tailFocusProxyRef,
          onFocusFromOutsideViewport: () => {
            const tabbableCandidates = getSortedTabbableCandidates({
              tabbingDirection: "backwards"
            });
            focusFirst(tabbableCandidates);
          }
        })
      ]
    });
  });
  ToastViewport$1.displayName = VIEWPORT_NAME;
  var FOCUS_PROXY_NAME = "ToastFocusProxy";
  var FocusProxy = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return jsxRuntimeExports.jsx(VisuallyHidden, {
      "aria-hidden": true,
      tabIndex: 0,
      ...proxyProps,
      ref: forwardedRef,
      style: {
        position: "fixed"
      },
      onFocus: (event) => {
        var _a;
        const prevFocusedElement = event.relatedTarget;
        const isFocusFromOutsideViewport = !((_a = context.viewport) == null ? void 0 : _a.contains(prevFocusedElement));
        if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
      }
    });
  });
  FocusProxy.displayName = FOCUS_PROXY_NAME;
  var TOAST_NAME = "Toast";
  var TOAST_SWIPE_START = "toast.swipeStart";
  var TOAST_SWIPE_MOVE = "toast.swipeMove";
  var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
  var TOAST_SWIPE_END = "toast.swipeEnd";
  var Toast$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open = true, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return jsxRuntimeExports.jsx(Presence, {
      present: forceMount || open,
      children: jsxRuntimeExports.jsx(ToastImpl, {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef(props.onPause),
        onResume: useCallbackRef(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y2}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x: x2, y: y2 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x2}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y2}px`);
          setOpen(false);
        })
      })
    });
  });
  Toast$1.displayName = TOAST_NAME;
  var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
    onClose() {
    }
  });
  var ToastImpl = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, type = "foreground", duration: durationProp, open, onClose, onEscapeKeyDown, onPause, onResume, onSwipeStart, onSwipeMove, onSwipeCancel, onSwipeEnd, ...toastProps } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef(() => {
      var _a;
      const isFocusInToast = node == null ? void 0 : node.contains(document.activeElement);
      if (isFocusInToast) (_a = context.viewport) == null ? void 0 : _a.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback((duration2) => {
      if (!duration2 || duration2 === Infinity) return;
      window.clearTimeout(closeTimerRef.current);
      closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
      closeTimerRef.current = window.setTimeout(handleClose, duration2);
    }, [
      handleClose
    ]);
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume == null ? void 0 : onResume();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause == null ? void 0 : onPause();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [
      context.viewport,
      duration,
      onPause,
      onResume,
      startTimer
    ]);
    reactExports.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [
      open,
      duration,
      context.isClosePausedRef,
      startTimer
    ]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [
      onToastAdd,
      onToastRemove
    ]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [
      node
    ]);
    if (!context.viewport) return null;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        announceTextContent && jsxRuntimeExports.jsx(ToastAnnounce, {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }),
        jsxRuntimeExports.jsx(ToastInteractiveProvider, {
          scope: __scopeToast,
          onClose: handleClose,
          children: reactDomExports.createPortal(jsxRuntimeExports.jsx(Collection.ItemSlot, {
            scope: __scopeToast,
            children: jsxRuntimeExports.jsx(Root$1, {
              asChild: true,
              onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
                if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
                context.isFocusedToastEscapeKeyDownRef.current = false;
              }),
              children: jsxRuntimeExports.jsx(Primitive.li, {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: {
                  userSelect: "none",
                  touchAction: "none",
                  ...props.style
                },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown == null ? void 0 : onEscapeKeyDown(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = {
                    x: event.clientX,
                    y: event.clientY
                  };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x2 = event.clientX - pointerStartRef.current.x;
                  const y2 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = [
                    "left",
                    "right"
                  ].includes(context.swipeDirection);
                  const clamp2 = [
                    "left",
                    "up"
                  ].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x2) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y2) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = {
                    x: clampedX,
                    y: clampedY
                  };
                  const eventDetail = {
                    originalEvent: event,
                    delta
                  };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x2) > moveStartBuffer || Math.abs(y2) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = {
                      originalEvent: event,
                      delta
                    };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {
                        discrete: true
                      });
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              })
            })
          }), context.viewport)
        })
      ]
    });
  });
  var ToastAnnounce = (props) => {
    const { __scopeToast, children, ...announceProps } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
    const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
    useNextFrame(() => setRenderAnnounceText(true));
    reactExports.useEffect(() => {
      const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
      return () => window.clearTimeout(timer);
    }, []);
    return isAnnounced ? null : jsxRuntimeExports.jsx(Portal, {
      asChild: true,
      children: jsxRuntimeExports.jsx(VisuallyHidden, {
        ...announceProps,
        children: renderAnnounceText && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            context.label,
            " ",
            children
          ]
        })
      })
    });
  };
  var TITLE_NAME = "ToastTitle";
  var ToastTitle$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return jsxRuntimeExports.jsx(Primitive.div, {
      ...titleProps,
      ref: forwardedRef
    });
  });
  ToastTitle$1.displayName = TITLE_NAME;
  var DESCRIPTION_NAME = "ToastDescription";
  var ToastDescription$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return jsxRuntimeExports.jsx(Primitive.div, {
      ...descriptionProps,
      ref: forwardedRef
    });
  });
  ToastDescription$1.displayName = DESCRIPTION_NAME;
  var ACTION_NAME = "ToastAction";
  var ToastAction$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(`Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`);
      return null;
    }
    return jsxRuntimeExports.jsx(ToastAnnounceExclude, {
      altText,
      asChild: true,
      children: jsxRuntimeExports.jsx(ToastClose$1, {
        ...actionProps,
        ref: forwardedRef
      })
    });
  });
  ToastAction$1.displayName = ACTION_NAME;
  var CLOSE_NAME = "ToastClose";
  var ToastClose$1 = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return jsxRuntimeExports.jsx(ToastAnnounceExclude, {
      asChild: true,
      children: jsxRuntimeExports.jsx(Primitive.button, {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      })
    });
  });
  ToastClose$1.displayName = CLOSE_NAME;
  var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
    const { __scopeToast, altText, ...announceExcludeProps } = props;
    return jsxRuntimeExports.jsx(Primitive.div, {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    });
  });
  function getAnnounceTextContent(container) {
    const textContent = [];
    const childNodes = Array.from(container.childNodes);
    childNodes.forEach((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
      if (isHTMLElement(node)) {
        const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
        const isExcluded = node.dataset.radixToastAnnounceExclude === "";
        if (!isHidden) {
          if (isExcluded) {
            const altText = node.dataset.radixToastAnnounceAlt;
            if (altText) textContent.push(altText);
          } else {
            textContent.push(...getAnnounceTextContent(node));
          }
        }
      }
    });
    return textContent;
  }
  function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const currentTarget = detail.originalEvent.currentTarget;
    const event = new CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail
    });
    if (handler) currentTarget.addEventListener(name, handler, {
      once: true
    });
    if (discrete) {
      dispatchDiscreteCustomEvent(currentTarget, event);
    } else {
      currentTarget.dispatchEvent(event);
    }
  }
  var isDeltaInDirection = (delta, direction, threshold = 0) => {
    const deltaX = Math.abs(delta.x);
    const deltaY = Math.abs(delta.y);
    const isDeltaX = deltaX > deltaY;
    if (direction === "left" || direction === "right") {
      return isDeltaX && deltaX > threshold;
    } else {
      return !isDeltaX && deltaY > threshold;
    }
  };
  function useNextFrame(callback = () => {
  }) {
    const fn = useCallbackRef(callback);
    useLayoutEffect2(() => {
      let raf1 = 0;
      let raf2 = 0;
      raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
      return () => {
        window.cancelAnimationFrame(raf1);
        window.cancelAnimationFrame(raf2);
      };
    }, [
      fn
    ]);
  }
  function isHTMLElement(node) {
    return node.nodeType === node.ELEMENT_NODE;
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function focusFirst(candidates) {
    const previouslyFocusedElement = document.activeElement;
    return candidates.some((candidate) => {
      if (candidate === previouslyFocusedElement) return true;
      candidate.focus();
      return document.activeElement !== previouslyFocusedElement;
    });
  }
  var Provider$1 = ToastProvider$1;
  var Viewport = ToastViewport$1;
  var Root2 = Toast$1;
  var Title = ToastTitle$1;
  var Description = ToastDescription$1;
  var Action = ToastAction$1;
  var Close = ToastClose$1;
  function r(e) {
    var t2, f2, n2 = "";
    if ("string" == typeof e || "number" == typeof e) n2 += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t2 = 0; t2 < o; t2++) e[t2] && (f2 = r(e[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else for (f2 in e) e[f2] && (n2 && (n2 += " "), n2 += f2);
    return n2;
  }
  clsx = function() {
    for (var e, t2, f2 = 0, n2 = "", o = arguments.length; f2 < o; f2++) (e = arguments[f2]) && (t2 = r(e)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  };
  const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
  cx = clsx;
  cva = (base, config) => (props) => {
    var _config_compoundVariants;
    if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    const { variants, defaultVariants } = config;
    const getVariantClassNames = Object.keys(variants).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null) return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants[variant][variantKey];
    });
    const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
    const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
      let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
      return Object.entries(compoundVariantOptions).every((param2) => {
        let [key, value] = param2;
        return Array.isArray(value) ? value.includes({
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key]) : {
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key] === value;
      }) ? [
        ...acc,
        cvClass,
        cvClassName
      ] : acc;
    }, []);
    return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  };
  const dynamicIconImports = {
    "a-arrow-down": () => __vitePreload(() => import("./a-arrow-down-CNgTFKiX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([0,1]) : void 0),
    "a-arrow-up": () => __vitePreload(() => import("./a-arrow-up-B9wQ0n5y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([2,1]) : void 0),
    "a-large-small": () => __vitePreload(() => import("./a-large-small-DpE3uMLX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([3,1]) : void 0),
    "accessibility": () => __vitePreload(() => import("./accessibility-BTnojjqo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([4,1]) : void 0),
    "activity": () => __vitePreload(() => import("./activity-BV5dJOSn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([5,1]) : void 0),
    "air-vent": () => __vitePreload(() => import("./air-vent-C3OeElxE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([6,1]) : void 0),
    "airplay": () => __vitePreload(() => import("./airplay-MA6h-mv3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([7,1]) : void 0),
    "alarm-clock-check": () => __vitePreload(() => import("./alarm-clock-check-Bi7lI1D6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([8,1]) : void 0),
    "alarm-clock-minus": () => __vitePreload(() => import("./alarm-clock-minus-BA893cAT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([9,1]) : void 0),
    "alarm-clock-off": () => __vitePreload(() => import("./alarm-clock-off-B8Ovf6Wj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([10,1]) : void 0),
    "alarm-clock-plus": () => __vitePreload(() => import("./alarm-clock-plus-B7fIEiK2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([11,1]) : void 0),
    "alarm-clock": () => __vitePreload(() => import("./alarm-clock-D2QfusPH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([12,1]) : void 0),
    "alarm-smoke": () => __vitePreload(() => import("./alarm-smoke-BYMc0iqM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([13,1]) : void 0),
    "album": () => __vitePreload(() => import("./album-DyEsDi0I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([14,1]) : void 0),
    "align-center-horizontal": () => __vitePreload(() => import("./align-center-horizontal-DJpnp8xS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([15,1]) : void 0),
    "align-center-vertical": () => __vitePreload(() => import("./align-center-vertical-2D_xmb3-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([16,1]) : void 0),
    "align-center": () => __vitePreload(() => import("./align-center-DxV665v9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([17,1]) : void 0),
    "align-end-horizontal": () => __vitePreload(() => import("./align-end-horizontal-B9otDtbj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([18,1]) : void 0),
    "align-end-vertical": () => __vitePreload(() => import("./align-end-vertical-B59f6FdD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([19,1]) : void 0),
    "align-horizontal-distribute-center": () => __vitePreload(() => import("./align-horizontal-distribute-center-D75mlCsq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([20,1]) : void 0),
    "align-horizontal-distribute-end": () => __vitePreload(() => import("./align-horizontal-distribute-end-C-IiQVg5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([21,1]) : void 0),
    "align-horizontal-distribute-start": () => __vitePreload(() => import("./align-horizontal-distribute-start-DguOdxAh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([22,1]) : void 0),
    "align-horizontal-justify-center": () => __vitePreload(() => import("./align-horizontal-justify-center-0PimLbwH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([23,1]) : void 0),
    "align-horizontal-justify-end": () => __vitePreload(() => import("./align-horizontal-justify-end-NCrF7X5b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([24,1]) : void 0),
    "align-horizontal-justify-start": () => __vitePreload(() => import("./align-horizontal-justify-start-iElZuQ3I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([25,1]) : void 0),
    "align-horizontal-space-around": () => __vitePreload(() => import("./align-horizontal-space-around-D6HtsJnu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([26,1]) : void 0),
    "align-horizontal-space-between": () => __vitePreload(() => import("./align-horizontal-space-between-BjiR_3i2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([27,1]) : void 0),
    "align-justify": () => __vitePreload(() => import("./align-justify-4pvDMUCh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([28,1]) : void 0),
    "align-left": () => __vitePreload(() => import("./align-left-Cqzr8iGo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([29,1]) : void 0),
    "align-right": () => __vitePreload(() => import("./align-right-1KImZF6n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([30,1]) : void 0),
    "align-start-horizontal": () => __vitePreload(() => import("./align-start-horizontal-BA_2L9Fu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([31,1]) : void 0),
    "align-start-vertical": () => __vitePreload(() => import("./align-start-vertical-CiBHjYBk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([32,1]) : void 0),
    "align-vertical-distribute-center": () => __vitePreload(() => import("./align-vertical-distribute-center-CYrYJdDL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([33,1]) : void 0),
    "align-vertical-distribute-end": () => __vitePreload(() => import("./align-vertical-distribute-end-C2fuEiYb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([34,1]) : void 0),
    "align-vertical-distribute-start": () => __vitePreload(() => import("./align-vertical-distribute-start-mBapIGxY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([35,1]) : void 0),
    "align-vertical-justify-center": () => __vitePreload(() => import("./align-vertical-justify-center-DeKXBHHZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([36,1]) : void 0),
    "align-vertical-justify-end": () => __vitePreload(() => import("./align-vertical-justify-end-CkgLpEFM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([37,1]) : void 0),
    "align-vertical-justify-start": () => __vitePreload(() => import("./align-vertical-justify-start-BEE-h20u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([38,1]) : void 0),
    "align-vertical-space-around": () => __vitePreload(() => import("./align-vertical-space-around-Cdn9z6YT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([39,1]) : void 0),
    "align-vertical-space-between": () => __vitePreload(() => import("./align-vertical-space-between-1JopZKn6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([40,1]) : void 0),
    "ambulance": () => __vitePreload(() => import("./ambulance-DA26gD6Q.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([41,1]) : void 0),
    "ampersand": () => __vitePreload(() => import("./ampersand-DkdtRtHb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([42,1]) : void 0),
    "ampersands": () => __vitePreload(() => import("./ampersands-Z0JkED6b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([43,1]) : void 0),
    "amphora": () => __vitePreload(() => import("./amphora-CQ7Mbpz7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([44,1]) : void 0),
    "anchor": () => __vitePreload(() => import("./anchor-CZKyLhSd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([45,1]) : void 0),
    "angry": () => __vitePreload(() => import("./angry-C0i7P0_7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([46,1]) : void 0),
    "annoyed": () => __vitePreload(() => import("./annoyed-C6euMJ7n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([47,1]) : void 0),
    "antenna": () => __vitePreload(() => import("./antenna-mTjXFUAh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([48,1]) : void 0),
    "anvil": () => __vitePreload(() => import("./anvil-DBREkQn0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([49,1]) : void 0),
    "aperture": () => __vitePreload(() => import("./aperture-DL1SAQKG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([50,1]) : void 0),
    "app-window-mac": () => __vitePreload(() => import("./app-window-mac-C8vU1k03.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([51,1]) : void 0),
    "app-window": () => __vitePreload(() => import("./app-window-BhQRaU_L.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([52,1]) : void 0),
    "apple": () => __vitePreload(() => import("./apple-Dy-ujZyW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([53,1]) : void 0),
    "archive-restore": () => __vitePreload(() => import("./archive-restore-C0zvuQuh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([54,1]) : void 0),
    "archive-x": () => __vitePreload(() => import("./archive-x-DQ3qt71s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([55,1]) : void 0),
    "archive": () => __vitePreload(() => import("./archive-DD3cO-ED.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([56,1]) : void 0),
    "armchair": () => __vitePreload(() => import("./armchair-DLPm7n7K.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([57,1]) : void 0),
    "arrow-big-down-dash": () => __vitePreload(() => import("./arrow-big-down-dash-D2604AgH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([58,1]) : void 0),
    "arrow-big-down": () => __vitePreload(() => import("./arrow-big-down-TsHZQBLv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([59,1]) : void 0),
    "arrow-big-left-dash": () => __vitePreload(() => import("./arrow-big-left-dash-CEZ_1a-T.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([60,1]) : void 0),
    "arrow-big-left": () => __vitePreload(() => import("./arrow-big-left-BRZ4iTqA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([61,1]) : void 0),
    "arrow-big-right-dash": () => __vitePreload(() => import("./arrow-big-right-dash-CbP6UW9b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([62,1]) : void 0),
    "arrow-big-right": () => __vitePreload(() => import("./arrow-big-right-Cjlsn9kY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([63,1]) : void 0),
    "arrow-big-up-dash": () => __vitePreload(() => import("./arrow-big-up-dash-DddDY_ia.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([64,1]) : void 0),
    "arrow-big-up": () => __vitePreload(() => import("./arrow-big-up-BKq5KqZa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([65,1]) : void 0),
    "arrow-down-0-1": () => __vitePreload(() => import("./arrow-down-0-1-BihVD2pC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([66,1]) : void 0),
    "arrow-down-1-0": () => __vitePreload(() => import("./arrow-down-1-0-WgTiZYXI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([67,1]) : void 0),
    "arrow-down-a-z": () => __vitePreload(() => import("./arrow-down-a-z-YcLnJAQD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([68,1]) : void 0),
    "arrow-down-from-line": () => __vitePreload(() => import("./arrow-down-from-line-CBRB6ENT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([69,1]) : void 0),
    "arrow-down-left": () => __vitePreload(() => import("./arrow-down-left-CWCjk_Is.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([70,1]) : void 0),
    "arrow-down-narrow-wide": () => __vitePreload(() => import("./arrow-down-narrow-wide-elowrhZ9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([71,1]) : void 0),
    "arrow-down-right": () => __vitePreload(() => import("./arrow-down-right-CNGB1kiu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([72,1]) : void 0),
    "arrow-down-to-dot": () => __vitePreload(() => import("./arrow-down-to-dot-BeQ4HObF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([73,1]) : void 0),
    "arrow-down-to-line": () => __vitePreload(() => import("./arrow-down-to-line-DgeYuGZs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([74,1]) : void 0),
    "arrow-down-up": () => __vitePreload(() => import("./arrow-down-up-BGNOUW_e.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([75,1]) : void 0),
    "arrow-down-wide-narrow": () => __vitePreload(() => import("./arrow-down-wide-narrow-LRJvG0g8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([76,1]) : void 0),
    "arrow-down-z-a": () => __vitePreload(() => import("./arrow-down-z-a-CpfCvc1m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([77,1]) : void 0),
    "arrow-down": () => __vitePreload(() => import("./arrow-down-DFxVDlwy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([78,1]) : void 0),
    "arrow-left-from-line": () => __vitePreload(() => import("./arrow-left-from-line-DJRIk_AK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([79,1]) : void 0),
    "arrow-left-right": () => __vitePreload(() => import("./arrow-left-right-BrxXkcXK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([80,1]) : void 0),
    "arrow-left-to-line": () => __vitePreload(() => import("./arrow-left-to-line-DZrtFKNw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([81,1]) : void 0),
    "arrow-left": () => __vitePreload(() => import("./arrow-left-DLeWS8Mb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([82,1]) : void 0),
    "arrow-right-from-line": () => __vitePreload(() => import("./arrow-right-from-line-CjwKsOVk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([83,1]) : void 0),
    "arrow-right-left": () => __vitePreload(() => import("./arrow-right-left-BQP6JFyz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([84,1]) : void 0),
    "arrow-right-to-line": () => __vitePreload(() => import("./arrow-right-to-line-Dk8uewpk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([85,1]) : void 0),
    "arrow-right": () => __vitePreload(() => import("./arrow-right-CIkThkMt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([86,1]) : void 0),
    "arrow-up-0-1": () => __vitePreload(() => import("./arrow-up-0-1-DL-9Bije.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([87,1]) : void 0),
    "arrow-up-1-0": () => __vitePreload(() => import("./arrow-up-1-0-pTpHHl1N.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([88,1]) : void 0),
    "arrow-up-a-z": () => __vitePreload(() => import("./arrow-up-a-z-DNMYkfgn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([89,1]) : void 0),
    "arrow-up-down": () => __vitePreload(() => import("./arrow-up-down-DcqsP6NQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([90,1]) : void 0),
    "arrow-up-from-dot": () => __vitePreload(() => import("./arrow-up-from-dot-bjqq3Cwq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([91,1]) : void 0),
    "arrow-up-from-line": () => __vitePreload(() => import("./arrow-up-from-line-KMGVj1eM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([92,1]) : void 0),
    "arrow-up-left": () => __vitePreload(() => import("./arrow-up-left-LGmeazzA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([93,1]) : void 0),
    "arrow-up-narrow-wide": () => __vitePreload(() => import("./arrow-up-narrow-wide-Ctxu26v8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([94,1]) : void 0),
    "arrow-up-right": () => __vitePreload(() => import("./arrow-up-right-Dpw8RRdp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([95,1]) : void 0),
    "arrow-up-to-line": () => __vitePreload(() => import("./arrow-up-to-line-D6BbUIFG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([96,1]) : void 0),
    "arrow-up-wide-narrow": () => __vitePreload(() => import("./arrow-up-wide-narrow-Bit2ffto.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([97,1]) : void 0),
    "arrow-up-z-a": () => __vitePreload(() => import("./arrow-up-z-a-DXZ2MUzZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([98,1]) : void 0),
    "arrow-up": () => __vitePreload(() => import("./arrow-up-D1U8y_Tl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([99,1]) : void 0),
    "arrows-up-from-line": () => __vitePreload(() => import("./arrows-up-from-line-ULCd1pNm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([100,1]) : void 0),
    "asterisk": () => __vitePreload(() => import("./asterisk-BlmzvwMw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([101,1]) : void 0),
    "at-sign": () => __vitePreload(() => import("./at-sign-4V4ivrJA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([102,1]) : void 0),
    "atom": () => __vitePreload(() => import("./atom-Bj0BKS8N.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([103,1]) : void 0),
    "audio-lines": () => __vitePreload(() => import("./audio-lines-BsvzexBK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([104,1]) : void 0),
    "audio-waveform": () => __vitePreload(() => import("./audio-waveform-BJsZ3B2r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([105,1]) : void 0),
    "award": () => __vitePreload(() => import("./award-BoKcpalN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([106,1]) : void 0),
    "axe": () => __vitePreload(() => import("./axe-B_SQj5op.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([107,1]) : void 0),
    "axis-3d": () => __vitePreload(() => import("./axis-3d-CxykbP2x.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([108,1]) : void 0),
    "baby": () => __vitePreload(() => import("./baby-DEZOlzPs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([109,1]) : void 0),
    "backpack": () => __vitePreload(() => import("./backpack-3rwM3fwE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([110,1]) : void 0),
    "badge-alert": () => __vitePreload(() => import("./badge-alert-BcfUpkIy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([111,1]) : void 0),
    "badge-cent": () => __vitePreload(() => import("./badge-cent-BuGODZYc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([112,1]) : void 0),
    "badge-check": () => __vitePreload(() => import("./badge-check-CfuuyCBE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([113,1]) : void 0),
    "badge-dollar-sign": () => __vitePreload(() => import("./badge-dollar-sign-CvzR4o1F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([114,1]) : void 0),
    "badge-euro": () => __vitePreload(() => import("./badge-euro-Cky69N-t.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([115,1]) : void 0),
    "badge-help": () => __vitePreload(() => import("./badge-help-C2tWL6Tx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([116,1]) : void 0),
    "badge-indian-rupee": () => __vitePreload(() => import("./badge-indian-rupee-FcLp71lG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([117,1]) : void 0),
    "badge-info": () => __vitePreload(() => import("./badge-info-DZxfp_KF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([118,1]) : void 0),
    "badge-japanese-yen": () => __vitePreload(() => import("./badge-japanese-yen-B1tW21Me.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([119,1]) : void 0),
    "badge-minus": () => __vitePreload(() => import("./badge-minus-BVhxm7m7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([120,1]) : void 0),
    "badge-percent": () => __vitePreload(() => import("./badge-percent-C9m8KyvJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([121,1]) : void 0),
    "badge-plus": () => __vitePreload(() => import("./badge-plus-yugNfxm4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([122,1]) : void 0),
    "badge-pound-sterling": () => __vitePreload(() => import("./badge-pound-sterling-CXHhelo_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([123,1]) : void 0),
    "badge-russian-ruble": () => __vitePreload(() => import("./badge-russian-ruble-DTR2Y1m4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([124,1]) : void 0),
    "badge-swiss-franc": () => __vitePreload(() => import("./badge-swiss-franc-Bq43hpml.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([125,1]) : void 0),
    "badge-x": () => __vitePreload(() => import("./badge-x-CQRpD5V9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([126,1]) : void 0),
    "badge": () => __vitePreload(() => import("./badge-Dmz7ZAjw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([127,1]) : void 0),
    "baggage-claim": () => __vitePreload(() => import("./baggage-claim-y2NtKY_7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([128,1]) : void 0),
    "ban": () => __vitePreload(() => import("./ban-D-xNyWx4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([129,1]) : void 0),
    "banana": () => __vitePreload(() => import("./banana-RCegBd1Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([130,1]) : void 0),
    "bandage": () => __vitePreload(() => import("./bandage-DBJPJ8fq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([131,1]) : void 0),
    "banknote": () => __vitePreload(() => import("./banknote-DyZECi_p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([132,1]) : void 0),
    "barcode": () => __vitePreload(() => import("./barcode-DWNqC0La.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([133,1]) : void 0),
    "baseline": () => __vitePreload(() => import("./baseline-qmQD8jHC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([134,1]) : void 0),
    "bath": () => __vitePreload(() => import("./bath-BWSFd-Qa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([135,1]) : void 0),
    "battery-charging": () => __vitePreload(() => import("./battery-charging-VJeaEvFV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([136,1]) : void 0),
    "battery-full": () => __vitePreload(() => import("./battery-full-D-CIQ6M6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([137,1]) : void 0),
    "battery-low": () => __vitePreload(() => import("./battery-low-DDIjF3AJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([138,1]) : void 0),
    "battery-medium": () => __vitePreload(() => import("./battery-medium-BL2CQWq0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([139,1]) : void 0),
    "battery-warning": () => __vitePreload(() => import("./battery-warning-Dqw5-0jg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([140,1]) : void 0),
    "battery": () => __vitePreload(() => import("./battery-B5KZOXt_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([141,1]) : void 0),
    "beaker": () => __vitePreload(() => import("./beaker-CE6tGKp8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([142,1]) : void 0),
    "bean-off": () => __vitePreload(() => import("./bean-off-Bkvxoul5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([143,1]) : void 0),
    "bean": () => __vitePreload(() => import("./bean-CeWxl3NJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([144,1]) : void 0),
    "bed-double": () => __vitePreload(() => import("./bed-double-ZEqgfqiZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([145,1]) : void 0),
    "bed-single": () => __vitePreload(() => import("./bed-single-DfDBO4Gu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([146,1]) : void 0),
    "bed": () => __vitePreload(() => import("./bed-CibShMzY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([147,1]) : void 0),
    "beef": () => __vitePreload(() => import("./beef-BIfWEQbY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([148,1]) : void 0),
    "beer-off": () => __vitePreload(() => import("./beer-off-CSMSNoI8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([149,1]) : void 0),
    "beer": () => __vitePreload(() => import("./beer-vq2b1q8p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([150,1]) : void 0),
    "bell-dot": () => __vitePreload(() => import("./bell-dot-DtPrHq9Z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([151,1]) : void 0),
    "bell-electric": () => __vitePreload(() => import("./bell-electric-BPwUP_--.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([152,1]) : void 0),
    "bell-minus": () => __vitePreload(() => import("./bell-minus-BWePvRho.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([153,1]) : void 0),
    "bell-off": () => __vitePreload(() => import("./bell-off-BYLs5wFg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([154,1]) : void 0),
    "bell-plus": () => __vitePreload(() => import("./bell-plus-Bd8JJos_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([155,1]) : void 0),
    "bell-ring": () => __vitePreload(() => import("./bell-ring-BtiPCCH_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([156,1]) : void 0),
    "bell": () => __vitePreload(() => import("./bell-DI45p5tm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([157,1]) : void 0),
    "between-horizontal-end": () => __vitePreload(() => import("./between-horizontal-end-ChnJUp7d.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([158,1]) : void 0),
    "between-horizontal-start": () => __vitePreload(() => import("./between-horizontal-start-Bsh4DQFm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([159,1]) : void 0),
    "between-vertical-end": () => __vitePreload(() => import("./between-vertical-end-Vp_2HsW8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([160,1]) : void 0),
    "between-vertical-start": () => __vitePreload(() => import("./between-vertical-start-Dmf91WuT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([161,1]) : void 0),
    "biceps-flexed": () => __vitePreload(() => import("./biceps-flexed-D0oT7V2L.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([162,1]) : void 0),
    "bike": () => __vitePreload(() => import("./bike-B0ULIHvG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([163,1]) : void 0),
    "binary": () => __vitePreload(() => import("./binary-F8m93qvh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([164,1]) : void 0),
    "binoculars": () => __vitePreload(() => import("./binoculars-Bejd4-29.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([165,1]) : void 0),
    "biohazard": () => __vitePreload(() => import("./biohazard-BGeR5Mf0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([166,1]) : void 0),
    "bird": () => __vitePreload(() => import("./bird-C3G1fusS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([167,1]) : void 0),
    "bitcoin": () => __vitePreload(() => import("./bitcoin-DlrSbdIw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([168,1]) : void 0),
    "blend": () => __vitePreload(() => import("./blend-DV42QTku.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([169,1]) : void 0),
    "blinds": () => __vitePreload(() => import("./blinds-Utpn-bT-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([170,1]) : void 0),
    "blocks": () => __vitePreload(() => import("./blocks-BRezn43_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([171,1]) : void 0),
    "bluetooth-connected": () => __vitePreload(() => import("./bluetooth-connected-Bfjam4tx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([172,1]) : void 0),
    "bluetooth-off": () => __vitePreload(() => import("./bluetooth-off-BV6nQhL6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([173,1]) : void 0),
    "bluetooth-searching": () => __vitePreload(() => import("./bluetooth-searching-BXvFFLQ1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([174,1]) : void 0),
    "bluetooth": () => __vitePreload(() => import("./bluetooth-CAluXsSq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([175,1]) : void 0),
    "bold": () => __vitePreload(() => import("./bold-FnAWDcX0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([176,1]) : void 0),
    "bolt": () => __vitePreload(() => import("./bolt-CdPzDJ5b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([177,1]) : void 0),
    "bomb": () => __vitePreload(() => import("./bomb-B9w7pbH8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([178,1]) : void 0),
    "bone": () => __vitePreload(() => import("./bone-7AQ4GnhW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([179,1]) : void 0),
    "book-a": () => __vitePreload(() => import("./book-a-8z1upIeF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([180,1]) : void 0),
    "book-audio": () => __vitePreload(() => import("./book-audio-Cad0hetH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([181,1]) : void 0),
    "book-check": () => __vitePreload(() => import("./book-check-Dq-LlNJn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([182,1]) : void 0),
    "book-copy": () => __vitePreload(() => import("./book-copy-Ds1aGlg7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([183,1]) : void 0),
    "book-dashed": () => __vitePreload(() => import("./book-dashed-DHwoltPA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([184,1]) : void 0),
    "book-down": () => __vitePreload(() => import("./book-down-B0MAOnit.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([185,1]) : void 0),
    "book-headphones": () => __vitePreload(() => import("./book-headphones-Bw3bUiVe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([186,1]) : void 0),
    "book-heart": () => __vitePreload(() => import("./book-heart-BAA4yG2a.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([187,1]) : void 0),
    "book-image": () => __vitePreload(() => import("./book-image-BA78VVCu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([188,1]) : void 0),
    "book-key": () => __vitePreload(() => import("./book-key-BbBcM2Rz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([189,1]) : void 0),
    "book-lock": () => __vitePreload(() => import("./book-lock-BqMTGTxi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([190,1]) : void 0),
    "book-marked": () => __vitePreload(() => import("./book-marked-kTMOppyN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([191,1]) : void 0),
    "book-minus": () => __vitePreload(() => import("./book-minus-C1iEdc6u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([192,1]) : void 0),
    "book-open-check": () => __vitePreload(() => import("./book-open-check-BzqTO65n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([193,1]) : void 0),
    "book-open-text": () => __vitePreload(() => import("./book-open-text-Ctp_ymdr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([194,1]) : void 0),
    "book-open": () => __vitePreload(() => import("./book-open-exPuCE-B.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([195,1]) : void 0),
    "book-plus": () => __vitePreload(() => import("./book-plus-BaJj6Q8C.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([196,1]) : void 0),
    "book-text": () => __vitePreload(() => import("./book-text-C6b4Lz6I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([197,1]) : void 0),
    "book-type": () => __vitePreload(() => import("./book-type-CY_90Tc6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([198,1]) : void 0),
    "book-up-2": () => __vitePreload(() => import("./book-up-2-BjYhUBt6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([199,1]) : void 0),
    "book-up": () => __vitePreload(() => import("./book-up-dINznO0P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([200,1]) : void 0),
    "book-user": () => __vitePreload(() => import("./book-user-Dl_rQLIA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([201,1]) : void 0),
    "book-x": () => __vitePreload(() => import("./book-x-C9Q8z1l4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([202,1]) : void 0),
    "book": () => __vitePreload(() => import("./book-DaA8Gwwp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([203,1]) : void 0),
    "bookmark-check": () => __vitePreload(() => import("./bookmark-check-Dq-JPpNK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([204,1]) : void 0),
    "bookmark-minus": () => __vitePreload(() => import("./bookmark-minus-CTTlpTLN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([205,1]) : void 0),
    "bookmark-plus": () => __vitePreload(() => import("./bookmark-plus-2QEyp_Ru.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([206,1]) : void 0),
    "bookmark-x": () => __vitePreload(() => import("./bookmark-x-mCUSLQzg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([207,1]) : void 0),
    "bookmark": () => __vitePreload(() => import("./bookmark-Do-4AbzQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([208,1]) : void 0),
    "boom-box": () => __vitePreload(() => import("./boom-box-xtx1YFxh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([209,1]) : void 0),
    "bot-message-square": () => __vitePreload(() => import("./bot-message-square-BxtYpfq0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([210,1]) : void 0),
    "bot-off": () => __vitePreload(() => import("./bot-off-C1tqkT3z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([211,1]) : void 0),
    "bot": () => __vitePreload(() => import("./bot-dn3ByO8f.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([212,1]) : void 0),
    "box": () => __vitePreload(() => import("./box-DD7nA-Fb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([213,1]) : void 0),
    "boxes": () => __vitePreload(() => import("./boxes-UTBkxpqD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([214,1]) : void 0),
    "braces": () => __vitePreload(() => import("./braces-B6Rz8iBP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([215,1]) : void 0),
    "brackets": () => __vitePreload(() => import("./brackets-snZdZLEi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([216,1]) : void 0),
    "brain-circuit": () => __vitePreload(() => import("./brain-circuit-CxqnWimR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([217,1]) : void 0),
    "brain-cog": () => __vitePreload(() => import("./brain-cog-BDRE6Qyd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([218,1]) : void 0),
    "brain": () => __vitePreload(() => import("./brain-D_zwc5uP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([219,1]) : void 0),
    "brick-wall": () => __vitePreload(() => import("./brick-wall-DOVgBje0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([220,1]) : void 0),
    "briefcase-business": () => __vitePreload(() => import("./briefcase-business-Dp4uwtwN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([221,1]) : void 0),
    "briefcase-conveyor-belt": () => __vitePreload(() => import("./briefcase-conveyor-belt-DH7uZLyk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([222,1]) : void 0),
    "briefcase-medical": () => __vitePreload(() => import("./briefcase-medical-DEdebRen.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([223,1]) : void 0),
    "briefcase": () => __vitePreload(() => import("./briefcase-DdK5_k-B.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([224,1]) : void 0),
    "bring-to-front": () => __vitePreload(() => import("./bring-to-front-DGHzytgz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([225,1]) : void 0),
    "brush": () => __vitePreload(() => import("./brush-QdE_5cqO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([226,1]) : void 0),
    "bug-off": () => __vitePreload(() => import("./bug-off-CNS65E6j.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([227,1]) : void 0),
    "bug-play": () => __vitePreload(() => import("./bug-play-Czf5TG-P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([228,1]) : void 0),
    "bug": () => __vitePreload(() => import("./bug-CZ04fsbS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([229,1]) : void 0),
    "building-2": () => __vitePreload(() => import("./building-2-D5UiovxX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([230,1]) : void 0),
    "building": () => __vitePreload(() => import("./building-a8RUYBD0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([231,1]) : void 0),
    "bus-front": () => __vitePreload(() => import("./bus-front-CwKNEH4e.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([232,1]) : void 0),
    "bus": () => __vitePreload(() => import("./bus-CAawFz-r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([233,1]) : void 0),
    "cable-car": () => __vitePreload(() => import("./cable-car-BsW5NeUM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([234,1]) : void 0),
    "cable": () => __vitePreload(() => import("./cable-Bh7-5O2W.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([235,1]) : void 0),
    "cake-slice": () => __vitePreload(() => import("./cake-slice-CYXisVP-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([236,1]) : void 0),
    "cake": () => __vitePreload(() => import("./cake-B3hU4_6z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([237,1]) : void 0),
    "calculator": () => __vitePreload(() => import("./calculator-BJqCaAda.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([238,1]) : void 0),
    "calendar-1": () => __vitePreload(() => import("./calendar-1-BHZAxDLw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([239,1]) : void 0),
    "calendar-arrow-down": () => __vitePreload(() => import("./calendar-arrow-down-HRmUVz_7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([240,1]) : void 0),
    "calendar-arrow-up": () => __vitePreload(() => import("./calendar-arrow-up-BkWwQokX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([241,1]) : void 0),
    "calendar-check-2": () => __vitePreload(() => import("./calendar-check-2-Dmogfini.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([242,1]) : void 0),
    "calendar-check": () => __vitePreload(() => import("./calendar-check-O8XG7PB1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([243,1]) : void 0),
    "calendar-clock": () => __vitePreload(() => import("./calendar-clock-CVdpziL9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([244,1]) : void 0),
    "calendar-cog": () => __vitePreload(() => import("./calendar-cog-QF7-2jbl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([245,1]) : void 0),
    "calendar-days": () => __vitePreload(() => import("./calendar-days-D8KoiZSC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([246,1]) : void 0),
    "calendar-fold": () => __vitePreload(() => import("./calendar-fold-DTRAHpID.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([247,1]) : void 0),
    "calendar-heart": () => __vitePreload(() => import("./calendar-heart-D0cLBSOM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([248,1]) : void 0),
    "calendar-minus-2": () => __vitePreload(() => import("./calendar-minus-2-wWtVKytY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([249,1]) : void 0),
    "calendar-minus": () => __vitePreload(() => import("./calendar-minus-CsUOTuXs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([250,1]) : void 0),
    "calendar-off": () => __vitePreload(() => import("./calendar-off-BRks4HI1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([251,1]) : void 0),
    "calendar-plus-2": () => __vitePreload(() => import("./calendar-plus-2-Cvyjw0-k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([252,1]) : void 0),
    "calendar-plus": () => __vitePreload(() => import("./calendar-plus-CJVfKZqg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([253,1]) : void 0),
    "calendar-range": () => __vitePreload(() => import("./calendar-range-B36JW6yG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([254,1]) : void 0),
    "calendar-search": () => __vitePreload(() => import("./calendar-search-BZqBBS8_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([255,1]) : void 0),
    "calendar-sync": () => __vitePreload(() => import("./calendar-sync-Ci0_otk7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([256,1]) : void 0),
    "calendar-x-2": () => __vitePreload(() => import("./calendar-x-2-DLNRWKv4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([257,1]) : void 0),
    "calendar-x": () => __vitePreload(() => import("./calendar-x-t7FgZ6So.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([258,1]) : void 0),
    "calendar": () => __vitePreload(() => import("./calendar-BWv0HE5b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([259,1]) : void 0),
    "camera-off": () => __vitePreload(() => import("./camera-off-hfH0lhs7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([260,1]) : void 0),
    "camera": () => __vitePreload(() => import("./camera-DMa_dwkr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([261,1]) : void 0),
    "candy-cane": () => __vitePreload(() => import("./candy-cane-DQEoG8EI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([262,1]) : void 0),
    "candy-off": () => __vitePreload(() => import("./candy-off-DaR3wMkf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([263,1]) : void 0),
    "candy": () => __vitePreload(() => import("./candy-D6P5HLzq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([264,1]) : void 0),
    "cannabis": () => __vitePreload(() => import("./cannabis-C-lhRUSR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([265,1]) : void 0),
    "captions-off": () => __vitePreload(() => import("./captions-off-CYhJiY-P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([266,1]) : void 0),
    "captions": () => __vitePreload(() => import("./captions-D4UOIQAi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([267,1]) : void 0),
    "car-front": () => __vitePreload(() => import("./car-front-CFncvNJI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([268,1]) : void 0),
    "car-taxi-front": () => __vitePreload(() => import("./car-taxi-front-Bqm8F-hW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([269,1]) : void 0),
    "car": () => __vitePreload(() => import("./car--LuoYZni.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([270,1]) : void 0),
    "caravan": () => __vitePreload(() => import("./caravan-BXCX22i4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([271,1]) : void 0),
    "carrot": () => __vitePreload(() => import("./carrot-DXNZ1Yuf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([272,1]) : void 0),
    "case-lower": () => __vitePreload(() => import("./case-lower-1xbuIgIF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([273,1]) : void 0),
    "case-sensitive": () => __vitePreload(() => import("./case-sensitive-OgcSuAHc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([274,1]) : void 0),
    "case-upper": () => __vitePreload(() => import("./case-upper-TkVUcIEI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([275,1]) : void 0),
    "cassette-tape": () => __vitePreload(() => import("./cassette-tape-Df-EoJq5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([276,1]) : void 0),
    "cast": () => __vitePreload(() => import("./cast-DTKl0MC_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([277,1]) : void 0),
    "castle": () => __vitePreload(() => import("./castle-CzIwmuJy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([278,1]) : void 0),
    "cat": () => __vitePreload(() => import("./cat-CpRWYaw-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([279,1]) : void 0),
    "cctv": () => __vitePreload(() => import("./cctv-Aw5cimi-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([280,1]) : void 0),
    "chart-area": () => __vitePreload(() => import("./chart-area-D8qPS1x8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([281,1]) : void 0),
    "chart-bar-big": () => __vitePreload(() => import("./chart-bar-big-EbyrrK0E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([282,1]) : void 0),
    "chart-bar-decreasing": () => __vitePreload(() => import("./chart-bar-decreasing-PZHG7-gp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([283,1]) : void 0),
    "chart-bar-increasing": () => __vitePreload(() => import("./chart-bar-increasing-CoaASwK0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([284,1]) : void 0),
    "chart-bar-stacked": () => __vitePreload(() => import("./chart-bar-stacked-BAmkK5hX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([285,1]) : void 0),
    "chart-bar": () => __vitePreload(() => import("./chart-bar-Dpjih5lp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([286,1]) : void 0),
    "chart-candlestick": () => __vitePreload(() => import("./chart-candlestick-Cz02SZWS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([287,1]) : void 0),
    "chart-column-big": () => __vitePreload(() => import("./chart-column-big-DtPvDuul.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([288,1]) : void 0),
    "chart-column-decreasing": () => __vitePreload(() => import("./chart-column-decreasing-CkAmV0Y0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([289,1]) : void 0),
    "chart-column-increasing": () => __vitePreload(() => import("./chart-column-increasing-CchC2HgR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([290,1]) : void 0),
    "chart-column-stacked": () => __vitePreload(() => import("./chart-column-stacked-CdXl7fqV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([291,1]) : void 0),
    "chart-column": () => __vitePreload(() => import("./chart-column-CNVUaQK8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([292,1]) : void 0),
    "chart-gantt": () => __vitePreload(() => import("./chart-gantt-BwZ8T9fL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([293,1]) : void 0),
    "chart-line": () => __vitePreload(() => import("./chart-line-IQ9bIChM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([294,1]) : void 0),
    "chart-network": () => __vitePreload(() => import("./chart-network-CNuTC2qC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([295,1]) : void 0),
    "chart-no-axes-column-decreasing": () => __vitePreload(() => import("./chart-no-axes-column-decreasing-CvjZt9vS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([296,1]) : void 0),
    "chart-no-axes-column-increasing": () => __vitePreload(() => import("./chart-no-axes-column-increasing-CoV_pko3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([297,1]) : void 0),
    "chart-no-axes-column": () => __vitePreload(() => import("./chart-no-axes-column-DqM0IITS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([298,1]) : void 0),
    "chart-no-axes-combined": () => __vitePreload(() => import("./chart-no-axes-combined-CGWPMdIe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([299,1]) : void 0),
    "chart-no-axes-gantt": () => __vitePreload(() => import("./chart-no-axes-gantt-CUcxUqe1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([300,1]) : void 0),
    "chart-pie": () => __vitePreload(() => import("./chart-pie-CbebJP6G.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([301,1]) : void 0),
    "chart-scatter": () => __vitePreload(() => import("./chart-scatter-BifbikuY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([302,1]) : void 0),
    "chart-spline": () => __vitePreload(() => import("./chart-spline-Bq_xDId3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([303,1]) : void 0),
    "check-check": () => __vitePreload(() => import("./check-check-6VWZjV6r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([304,1]) : void 0),
    "check": () => __vitePreload(() => import("./check-CPckYtjn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([305,1]) : void 0),
    "chef-hat": () => __vitePreload(() => import("./chef-hat-DONYNtc3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([306,1]) : void 0),
    "cherry": () => __vitePreload(() => import("./cherry-CIzMzjAf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([307,1]) : void 0),
    "chevron-down": () => __vitePreload(() => import("./chevron-down-C2fRMLBZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([308,1]) : void 0),
    "chevron-first": () => __vitePreload(() => import("./chevron-first-BcGyV6tV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([309,1]) : void 0),
    "chevron-last": () => __vitePreload(() => import("./chevron-last-C0Krzyoe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([310,1]) : void 0),
    "chevron-left": () => __vitePreload(() => import("./chevron-left-BNfsxm0Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([311,1]) : void 0),
    "chevron-right": () => __vitePreload(() => import("./chevron-right-CwUZymH_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([312,1]) : void 0),
    "chevron-up": () => __vitePreload(() => import("./chevron-up-RPiEHaJX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([313,1]) : void 0),
    "chevrons-down-up": () => __vitePreload(() => import("./chevrons-down-up-BGNr779D.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([314,1]) : void 0),
    "chevrons-down": () => __vitePreload(() => import("./chevrons-down-d9ri72d9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([315,1]) : void 0),
    "chevrons-left-right-ellipsis": () => __vitePreload(() => import("./chevrons-left-right-ellipsis-CKgw5gba.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([316,1]) : void 0),
    "chevrons-left-right": () => __vitePreload(() => import("./chevrons-left-right-DAgwACXJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([317,1]) : void 0),
    "chevrons-left": () => __vitePreload(() => import("./chevrons-left-CBjCvM5j.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([318,1]) : void 0),
    "chevrons-right-left": () => __vitePreload(() => import("./chevrons-right-left-Cl8xjMHl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([319,1]) : void 0),
    "chevrons-right": () => __vitePreload(() => import("./chevrons-right-DF1Arxz_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([320,1]) : void 0),
    "chevrons-up-down": () => __vitePreload(() => import("./chevrons-up-down-Ot1-6qFg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([321,1]) : void 0),
    "chevrons-up": () => __vitePreload(() => import("./chevrons-up-DBsGVBaR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([322,1]) : void 0),
    "chrome": () => __vitePreload(() => import("./chrome-CSJf2Ix5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([323,1]) : void 0),
    "church": () => __vitePreload(() => import("./church-DuOPvZwI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([324,1]) : void 0),
    "cigarette-off": () => __vitePreload(() => import("./cigarette-off-BFnBdYef.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([325,1]) : void 0),
    "cigarette": () => __vitePreload(() => import("./cigarette-DkJ-309E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([326,1]) : void 0),
    "circle-alert": () => __vitePreload(() => import("./circle-alert-b0mAlR-t.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([327,1]) : void 0),
    "circle-arrow-down": () => __vitePreload(() => import("./circle-arrow-down-CPrRJslw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([328,1]) : void 0),
    "circle-arrow-left": () => __vitePreload(() => import("./circle-arrow-left-DSlmo6km.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([329,1]) : void 0),
    "circle-arrow-out-down-left": () => __vitePreload(() => import("./circle-arrow-out-down-left-DC_7eRC5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([330,1]) : void 0),
    "circle-arrow-out-down-right": () => __vitePreload(() => import("./circle-arrow-out-down-right-BccoPRKj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([331,1]) : void 0),
    "circle-arrow-out-up-left": () => __vitePreload(() => import("./circle-arrow-out-up-left-Bi9zehYX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([332,1]) : void 0),
    "circle-arrow-out-up-right": () => __vitePreload(() => import("./circle-arrow-out-up-right-BIy4wm6D.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([333,1]) : void 0),
    "circle-arrow-right": () => __vitePreload(() => import("./circle-arrow-right-Cn-yXKXq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([334,1]) : void 0),
    "circle-arrow-up": () => __vitePreload(() => import("./circle-arrow-up-C6Qp3f37.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([335,1]) : void 0),
    "circle-check-big": () => __vitePreload(() => import("./circle-check-big-CTKrCgJH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([336,1]) : void 0),
    "circle-check": () => __vitePreload(() => import("./circle-check-CJCb06ho.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([337,1]) : void 0),
    "circle-chevron-down": () => __vitePreload(() => import("./circle-chevron-down-CjL6vH1m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([338,1]) : void 0),
    "circle-chevron-left": () => __vitePreload(() => import("./circle-chevron-left-D9CSzwa1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([339,1]) : void 0),
    "circle-chevron-right": () => __vitePreload(() => import("./circle-chevron-right-fHwaQO4p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([340,1]) : void 0),
    "circle-chevron-up": () => __vitePreload(() => import("./circle-chevron-up-BU2Og7x6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([341,1]) : void 0),
    "circle-dashed": () => __vitePreload(() => import("./circle-dashed-C4Ab2Fbk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([342,1]) : void 0),
    "circle-divide": () => __vitePreload(() => import("./circle-divide-D9qejqwt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([343,1]) : void 0),
    "circle-dollar-sign": () => __vitePreload(() => import("./circle-dollar-sign-DxganEpg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([344,1]) : void 0),
    "circle-dot-dashed": () => __vitePreload(() => import("./circle-dot-dashed-BA-_5KIT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([345,1]) : void 0),
    "circle-dot": () => __vitePreload(() => import("./circle-dot-4P8oD9wS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([346,1]) : void 0),
    "circle-ellipsis": () => __vitePreload(() => import("./circle-ellipsis-Bn6NX4-S.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([347,1]) : void 0),
    "circle-equal": () => __vitePreload(() => import("./circle-equal-CdNcPDrF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([348,1]) : void 0),
    "circle-fading-arrow-up": () => __vitePreload(() => import("./circle-fading-arrow-up-B1PlP5Dw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([349,1]) : void 0),
    "circle-fading-plus": () => __vitePreload(() => import("./circle-fading-plus-BY3l23Pc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([350,1]) : void 0),
    "circle-gauge": () => __vitePreload(() => import("./circle-gauge-Bm9yogCI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([351,1]) : void 0),
    "circle-help": () => __vitePreload(() => import("./circle-help-D_aIlF8k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([352,1]) : void 0),
    "circle-minus": () => __vitePreload(() => import("./circle-minus-8KAADzGn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([353,1]) : void 0),
    "circle-off": () => __vitePreload(() => import("./circle-off-BdTsy2B_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([354,1]) : void 0),
    "circle-parking-off": () => __vitePreload(() => import("./circle-parking-off-U15oeXe4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([355,1]) : void 0),
    "circle-parking": () => __vitePreload(() => import("./circle-parking-C9D4P0bO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([356,1]) : void 0),
    "circle-pause": () => __vitePreload(() => import("./circle-pause-DSZdDIN8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([357,1]) : void 0),
    "circle-percent": () => __vitePreload(() => import("./circle-percent-CE2epsJj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([358,1]) : void 0),
    "circle-play": () => __vitePreload(() => import("./circle-play-C4z7vtxq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([359,1]) : void 0),
    "circle-plus": () => __vitePreload(() => import("./circle-plus-BPoY3o2h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([360,1]) : void 0),
    "circle-power": () => __vitePreload(() => import("./circle-power-DjnCjAdX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([361,1]) : void 0),
    "circle-slash-2": () => __vitePreload(() => import("./circle-slash-2-BoxurmkJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([362,1]) : void 0),
    "circle-slash": () => __vitePreload(() => import("./circle-slash-B1Yo0nYY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([363,1]) : void 0),
    "circle-stop": () => __vitePreload(() => import("./circle-stop-DLZLqldk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([364,1]) : void 0),
    "circle-user-round": () => __vitePreload(() => import("./circle-user-round-DT2N1vPY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([365,1]) : void 0),
    "circle-user": () => __vitePreload(() => import("./circle-user-DPFij0A2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([366,1]) : void 0),
    "circle-x": () => __vitePreload(() => import("./circle-x-B-I8uv7m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([367,1]) : void 0),
    "circle": () => __vitePreload(() => import("./circle-DvxVmImz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([368,1]) : void 0),
    "circuit-board": () => __vitePreload(() => import("./circuit-board-9qZfVJ8e.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([369,1]) : void 0),
    "citrus": () => __vitePreload(() => import("./citrus-CVZ4eS0n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([370,1]) : void 0),
    "clapperboard": () => __vitePreload(() => import("./clapperboard-BQBJ6IfV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([371,1]) : void 0),
    "clipboard-check": () => __vitePreload(() => import("./clipboard-check-C-FQue5C.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([372,1]) : void 0),
    "clipboard-copy": () => __vitePreload(() => import("./clipboard-copy-DCR1NQhJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([373,1]) : void 0),
    "clipboard-list": () => __vitePreload(() => import("./clipboard-list-Bs_qQXbA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([374,1]) : void 0),
    "clipboard-minus": () => __vitePreload(() => import("./clipboard-minus-kocRP6Nt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([375,1]) : void 0),
    "clipboard-paste": () => __vitePreload(() => import("./clipboard-paste-co0vpJ9s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([376,1]) : void 0),
    "clipboard-pen-line": () => __vitePreload(() => import("./clipboard-pen-line-BhzikuEt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([377,1]) : void 0),
    "clipboard-pen": () => __vitePreload(() => import("./clipboard-pen-CdpgEUOy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([378,1]) : void 0),
    "clipboard-plus": () => __vitePreload(() => import("./clipboard-plus-DtXkvhyH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([379,1]) : void 0),
    "clipboard-type": () => __vitePreload(() => import("./clipboard-type-BzPaKUfn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([380,1]) : void 0),
    "clipboard-x": () => __vitePreload(() => import("./clipboard-x-CwO_DQQJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([381,1]) : void 0),
    "clipboard": () => __vitePreload(() => import("./clipboard-CHNM15QN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([382,1]) : void 0),
    "clock-1": () => __vitePreload(() => import("./clock-1-CVPOZmwx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([383,1]) : void 0),
    "clock-10": () => __vitePreload(() => import("./clock-10-DuiKOJr6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([384,1]) : void 0),
    "clock-11": () => __vitePreload(() => import("./clock-11-BSAM5KpW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([385,1]) : void 0),
    "clock-12": () => __vitePreload(() => import("./clock-12-CNCrGVms.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([386,1]) : void 0),
    "clock-2": () => __vitePreload(() => import("./clock-2-DaQeXY6H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([387,1]) : void 0),
    "clock-3": () => __vitePreload(() => import("./clock-3-bFAH1nr1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([388,1]) : void 0),
    "clock-4": () => __vitePreload(() => import("./clock-4-DsFuAqMB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([389,1]) : void 0),
    "clock-5": () => __vitePreload(() => import("./clock-5-8dFuQmor.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([390,1]) : void 0),
    "clock-6": () => __vitePreload(() => import("./clock-6-DFf85dsx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([391,1]) : void 0),
    "clock-7": () => __vitePreload(() => import("./clock-7-CH18bWH6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([392,1]) : void 0),
    "clock-8": () => __vitePreload(() => import("./clock-8-wwMWqk10.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([393,1]) : void 0),
    "clock-9": () => __vitePreload(() => import("./clock-9-BtiAslNv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([394,1]) : void 0),
    "clock-alert": () => __vitePreload(() => import("./clock-alert-z5rPU87V.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([395,1]) : void 0),
    "clock-arrow-down": () => __vitePreload(() => import("./clock-arrow-down-GgrCVDaG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([396,1]) : void 0),
    "clock-arrow-up": () => __vitePreload(() => import("./clock-arrow-up-BBVsOhNW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([397,1]) : void 0),
    "clock": () => __vitePreload(() => import("./clock-_3ygTBWJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([398,1]) : void 0),
    "cloud-alert": () => __vitePreload(() => import("./cloud-alert-DNyjV0ki.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([399,1]) : void 0),
    "cloud-cog": () => __vitePreload(() => import("./cloud-cog-DrDex3Vw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([400,1]) : void 0),
    "cloud-download": () => __vitePreload(() => import("./cloud-download-CDVo9ZxQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([401,1]) : void 0),
    "cloud-drizzle": () => __vitePreload(() => import("./cloud-drizzle-DshlseGs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([402,1]) : void 0),
    "cloud-fog": () => __vitePreload(() => import("./cloud-fog-B-49gfwL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([403,1]) : void 0),
    "cloud-hail": () => __vitePreload(() => import("./cloud-hail-2_KmvWAG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([404,1]) : void 0),
    "cloud-lightning": () => __vitePreload(() => import("./cloud-lightning-CnDz1mY0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([405,1]) : void 0),
    "cloud-moon-rain": () => __vitePreload(() => import("./cloud-moon-rain-BbS5FPWL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([406,1]) : void 0),
    "cloud-moon": () => __vitePreload(() => import("./cloud-moon-BzOmy06X.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([407,1]) : void 0),
    "cloud-off": () => __vitePreload(() => import("./cloud-off-DoHien0c.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([408,1]) : void 0),
    "cloud-rain-wind": () => __vitePreload(() => import("./cloud-rain-wind-BKSSDZXS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([409,1]) : void 0),
    "cloud-rain": () => __vitePreload(() => import("./cloud-rain-6GiFcjEk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([410,1]) : void 0),
    "cloud-snow": () => __vitePreload(() => import("./cloud-snow-DZZgr0v1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([411,1]) : void 0),
    "cloud-sun-rain": () => __vitePreload(() => import("./cloud-sun-rain-DIaF8dzO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([412,1]) : void 0),
    "cloud-sun": () => __vitePreload(() => import("./cloud-sun-B0dePQlH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([413,1]) : void 0),
    "cloud-upload": () => __vitePreload(() => import("./cloud-upload-Cumo_iRR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([414,1]) : void 0),
    "cloud": () => __vitePreload(() => import("./cloud-tKmdkj2z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([415,1]) : void 0),
    "cloudy": () => __vitePreload(() => import("./cloudy-au2bvBXD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([416,1]) : void 0),
    "clover": () => __vitePreload(() => import("./clover-SII4acey.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([417,1]) : void 0),
    "club": () => __vitePreload(() => import("./club-hHRo-182.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([418,1]) : void 0),
    "code-xml": () => __vitePreload(() => import("./code-xml-Bnweu91j.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([419,1]) : void 0),
    "code": () => __vitePreload(() => import("./code-DBSjMocy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([420,1]) : void 0),
    "codepen": () => __vitePreload(() => import("./codepen-Bdu6WKGs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([421,1]) : void 0),
    "codesandbox": () => __vitePreload(() => import("./codesandbox-DTR2kC42.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([422,1]) : void 0),
    "coffee": () => __vitePreload(() => import("./coffee-CL2F77fr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([423,1]) : void 0),
    "cog": () => __vitePreload(() => import("./cog-AmR-J1JP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([424,1]) : void 0),
    "coins": () => __vitePreload(() => import("./coins-B86gEVs3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([425,1]) : void 0),
    "columns-2": () => __vitePreload(() => import("./columns-2-Sjl9Dt9z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([426,1]) : void 0),
    "columns-3": () => __vitePreload(() => import("./columns-3-CAXm5b1i.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([427,1]) : void 0),
    "columns-4": () => __vitePreload(() => import("./columns-4-Re2uofFz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([428,1]) : void 0),
    "combine": () => __vitePreload(() => import("./combine-DNBKGv7K.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([429,1]) : void 0),
    "command": () => __vitePreload(() => import("./command-BxtJdNGV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([430,1]) : void 0),
    "compass": () => __vitePreload(() => import("./compass-BUtgqjrT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([431,1]) : void 0),
    "component": () => __vitePreload(() => import("./component-BSdIVhkg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([432,1]) : void 0),
    "computer": () => __vitePreload(() => import("./computer-DxzHOa3-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([433,1]) : void 0),
    "concierge-bell": () => __vitePreload(() => import("./concierge-bell-ChjcXyrk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([434,1]) : void 0),
    "cone": () => __vitePreload(() => import("./cone-CwKNDygv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([435,1]) : void 0),
    "construction": () => __vitePreload(() => import("./construction-BA2IrPEV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([436,1]) : void 0),
    "contact-round": () => __vitePreload(() => import("./contact-round-VOiL36nM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([437,1]) : void 0),
    "contact": () => __vitePreload(() => import("./contact-Dzat8syf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([438,1]) : void 0),
    "container": () => __vitePreload(() => import("./container-VZlHej8r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([439,1]) : void 0),
    "contrast": () => __vitePreload(() => import("./contrast-c4wDClX0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([440,1]) : void 0),
    "cookie": () => __vitePreload(() => import("./cookie-DTjfrSZ1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([441,1]) : void 0),
    "cooking-pot": () => __vitePreload(() => import("./cooking-pot-DBdeBUQS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([442,1]) : void 0),
    "copy-check": () => __vitePreload(() => import("./copy-check-8FRSgrzQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([443,1]) : void 0),
    "copy-minus": () => __vitePreload(() => import("./copy-minus-Ch_CgxeX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([444,1]) : void 0),
    "copy-plus": () => __vitePreload(() => import("./copy-plus-CA_G-2Ny.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([445,1]) : void 0),
    "copy-slash": () => __vitePreload(() => import("./copy-slash-DpEicipx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([446,1]) : void 0),
    "copy-x": () => __vitePreload(() => import("./copy-x-DPeF6_yU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([447,1]) : void 0),
    "copy": () => __vitePreload(() => import("./copy-ALodIprG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([448,1]) : void 0),
    "copyleft": () => __vitePreload(() => import("./copyleft-ByPmNnCq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([449,1]) : void 0),
    "copyright": () => __vitePreload(() => import("./copyright-Gsz3a-OB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([450,1]) : void 0),
    "corner-down-left": () => __vitePreload(() => import("./corner-down-left-DG5L0yOQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([451,1]) : void 0),
    "corner-down-right": () => __vitePreload(() => import("./corner-down-right-H4Jiff4L.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([452,1]) : void 0),
    "corner-left-down": () => __vitePreload(() => import("./corner-left-down-Cr091f01.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([453,1]) : void 0),
    "corner-left-up": () => __vitePreload(() => import("./corner-left-up-XRINktEE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([454,1]) : void 0),
    "corner-right-down": () => __vitePreload(() => import("./corner-right-down-DSRQPYkT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([455,1]) : void 0),
    "corner-right-up": () => __vitePreload(() => import("./corner-right-up-WUTl4hxN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([456,1]) : void 0),
    "corner-up-left": () => __vitePreload(() => import("./corner-up-left-DrueFrBR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([457,1]) : void 0),
    "corner-up-right": () => __vitePreload(() => import("./corner-up-right-27NXpavZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([458,1]) : void 0),
    "cpu": () => __vitePreload(() => import("./cpu-Br1Fz7L6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([459,1]) : void 0),
    "creative-commons": () => __vitePreload(() => import("./creative-commons-BVy_loTN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([460,1]) : void 0),
    "credit-card": () => __vitePreload(() => import("./credit-card-OOWKVQux.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([461,1]) : void 0),
    "croissant": () => __vitePreload(() => import("./croissant-BlDVGEky.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([462,1]) : void 0),
    "crop": () => __vitePreload(() => import("./crop-CAKe7iNq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([463,1]) : void 0),
    "cross": () => __vitePreload(() => import("./cross-CIZ6svUC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([464,1]) : void 0),
    "crosshair": () => __vitePreload(() => import("./crosshair-D17BQ_bu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([465,1]) : void 0),
    "crown": () => __vitePreload(() => import("./crown-22QFwKj9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([466,1]) : void 0),
    "cuboid": () => __vitePreload(() => import("./cuboid-DOWVnwLZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([467,1]) : void 0),
    "cup-soda": () => __vitePreload(() => import("./cup-soda-iQOVEyMz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([468,1]) : void 0),
    "currency": () => __vitePreload(() => import("./currency-3rgN8-wI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([469,1]) : void 0),
    "cylinder": () => __vitePreload(() => import("./cylinder-BRo-RYzy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([470,1]) : void 0),
    "dam": () => __vitePreload(() => import("./dam-CyTj6ylN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([471,1]) : void 0),
    "database-backup": () => __vitePreload(() => import("./database-backup-D5ZjDfy3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([472,1]) : void 0),
    "database-zap": () => __vitePreload(() => import("./database-zap-L4VA1lYL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([473,1]) : void 0),
    "database": () => __vitePreload(() => import("./database-C0xVpXri.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([474,1]) : void 0),
    "delete": () => __vitePreload(() => import("./delete-Cm0BJsA1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([475,1]) : void 0),
    "dessert": () => __vitePreload(() => import("./dessert-DehgdjJo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([476,1]) : void 0),
    "diameter": () => __vitePreload(() => import("./diameter-BgvRPTgJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([477,1]) : void 0),
    "diamond-minus": () => __vitePreload(() => import("./diamond-minus-BUOILXuB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([478,1]) : void 0),
    "diamond-percent": () => __vitePreload(() => import("./diamond-percent-CzbWfju_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([479,1]) : void 0),
    "diamond-plus": () => __vitePreload(() => import("./diamond-plus-C53V5483.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([480,1]) : void 0),
    "diamond": () => __vitePreload(() => import("./diamond-DgZPsO--.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([481,1]) : void 0),
    "dice-1": () => __vitePreload(() => import("./dice-1-DCGONojd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([482,1]) : void 0),
    "dice-2": () => __vitePreload(() => import("./dice-2-DzjFfZxr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([483,1]) : void 0),
    "dice-3": () => __vitePreload(() => import("./dice-3-Cslb52pU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([484,1]) : void 0),
    "dice-4": () => __vitePreload(() => import("./dice-4-BFk6zNPV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([485,1]) : void 0),
    "dice-5": () => __vitePreload(() => import("./dice-5-NRGQ2V8h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([486,1]) : void 0),
    "dice-6": () => __vitePreload(() => import("./dice-6-2mgfo5Qk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([487,1]) : void 0),
    "dices": () => __vitePreload(() => import("./dices-COiGX6dd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([488,1]) : void 0),
    "diff": () => __vitePreload(() => import("./diff-BawOTqHr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([489,1]) : void 0),
    "disc-2": () => __vitePreload(() => import("./disc-2-DbmansM9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([490,1]) : void 0),
    "disc-3": () => __vitePreload(() => import("./disc-3-ClqhPTwL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([491,1]) : void 0),
    "disc-album": () => __vitePreload(() => import("./disc-album-CfWkOC2U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([492,1]) : void 0),
    "disc": () => __vitePreload(() => import("./disc-BpNQIa5m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([493,1]) : void 0),
    "divide": () => __vitePreload(() => import("./divide-CdwMN9XU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([494,1]) : void 0),
    "dna-off": () => __vitePreload(() => import("./dna-off-D8yrN4rj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([495,1]) : void 0),
    "dna": () => __vitePreload(() => import("./dna-p2ScuGXe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([496,1]) : void 0),
    "dock": () => __vitePreload(() => import("./dock--V3m7mBx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([497,1]) : void 0),
    "dog": () => __vitePreload(() => import("./dog-BbvufOBz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([498,1]) : void 0),
    "dollar-sign": () => __vitePreload(() => import("./dollar-sign-DEkbCkKt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([499,1]) : void 0),
    "donut": () => __vitePreload(() => import("./donut-Du9z4tkM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([500,1]) : void 0),
    "door-closed": () => __vitePreload(() => import("./door-closed-_oNJrMLb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([501,1]) : void 0),
    "door-open": () => __vitePreload(() => import("./door-open-xYgoCiIV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([502,1]) : void 0),
    "dot": () => __vitePreload(() => import("./dot-BaevGMZ5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([503,1]) : void 0),
    "download": () => __vitePreload(() => import("./download-C1yPNiwc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([504,1]) : void 0),
    "drafting-compass": () => __vitePreload(() => import("./drafting-compass-BIRIUOGu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([505,1]) : void 0),
    "drama": () => __vitePreload(() => import("./drama-BwE-vxXe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([506,1]) : void 0),
    "dribbble": () => __vitePreload(() => import("./dribbble-DI0Y0-6r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([507,1]) : void 0),
    "drill": () => __vitePreload(() => import("./drill-D4qMzmUc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([508,1]) : void 0),
    "droplet": () => __vitePreload(() => import("./droplet-ClydckDo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([509,1]) : void 0),
    "droplets": () => __vitePreload(() => import("./droplets-B27XyqlJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([510,1]) : void 0),
    "drum": () => __vitePreload(() => import("./drum-DU3Np5u1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([511,1]) : void 0),
    "drumstick": () => __vitePreload(() => import("./drumstick-8fFBJKts.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([512,1]) : void 0),
    "dumbbell": () => __vitePreload(() => import("./dumbbell-jmGGzeh5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([513,1]) : void 0),
    "ear-off": () => __vitePreload(() => import("./ear-off-HFSvUmjy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([514,1]) : void 0),
    "ear": () => __vitePreload(() => import("./ear-B361V_NG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([515,1]) : void 0),
    "earth-lock": () => __vitePreload(() => import("./earth-lock-Di3uJtDM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([516,1]) : void 0),
    "earth": () => __vitePreload(() => import("./earth-5RgtO9-h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([517,1]) : void 0),
    "eclipse": () => __vitePreload(() => import("./eclipse-K4zmlEzJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([518,1]) : void 0),
    "egg-fried": () => __vitePreload(() => import("./egg-fried-DMV1nlLP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([519,1]) : void 0),
    "egg-off": () => __vitePreload(() => import("./egg-off-8YcxtNR2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([520,1]) : void 0),
    "egg": () => __vitePreload(() => import("./egg-C72zXt8d.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([521,1]) : void 0),
    "ellipsis-vertical": () => __vitePreload(() => import("./ellipsis-vertical-D8hmFrmQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([522,1]) : void 0),
    "ellipsis": () => __vitePreload(() => import("./ellipsis-COcYJXxW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([523,1]) : void 0),
    "equal-approximately": () => __vitePreload(() => import("./equal-approximately-DPByTU4u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([524,1]) : void 0),
    "equal-not": () => __vitePreload(() => import("./equal-not-JfGO7p1a.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([525,1]) : void 0),
    "equal": () => __vitePreload(() => import("./equal-CqllXzB7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([526,1]) : void 0),
    "eraser": () => __vitePreload(() => import("./eraser-pDSTAyjr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([527,1]) : void 0),
    "ethernet-port": () => __vitePreload(() => import("./ethernet-port-ro1gGPBK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([528,1]) : void 0),
    "euro": () => __vitePreload(() => import("./euro-CNK7R8O6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([529,1]) : void 0),
    "expand": () => __vitePreload(() => import("./expand-DZUsp3mV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([530,1]) : void 0),
    "external-link": () => __vitePreload(() => import("./external-link-VIERdOxn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([531,1]) : void 0),
    "eye-closed": () => __vitePreload(() => import("./eye-closed-DznUOff0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([532,1]) : void 0),
    "eye-off": () => __vitePreload(() => import("./eye-off-Y-ZRqGUc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([533,1]) : void 0),
    "eye": () => __vitePreload(() => import("./eye-C4XtbrYp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([534,1]) : void 0),
    "facebook": () => __vitePreload(() => import("./facebook-DjNukR1A.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([535,1]) : void 0),
    "factory": () => __vitePreload(() => import("./factory-BqE7rhXg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([536,1]) : void 0),
    "fan": () => __vitePreload(() => import("./fan-BeRcsRiy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([537,1]) : void 0),
    "fast-forward": () => __vitePreload(() => import("./fast-forward--JekP9FH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([538,1]) : void 0),
    "feather": () => __vitePreload(() => import("./feather-6srbvdQe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([539,1]) : void 0),
    "fence": () => __vitePreload(() => import("./fence-B79FgCwg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([540,1]) : void 0),
    "ferris-wheel": () => __vitePreload(() => import("./ferris-wheel-CzvstotA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([541,1]) : void 0),
    "figma": () => __vitePreload(() => import("./figma-CmCdt3Uo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([542,1]) : void 0),
    "file-archive": () => __vitePreload(() => import("./file-archive-BYzQkTeu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([543,1]) : void 0),
    "file-audio-2": () => __vitePreload(() => import("./file-audio-2-DyF5FKqJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([544,1]) : void 0),
    "file-audio": () => __vitePreload(() => import("./file-audio-DdjBe7MQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([545,1]) : void 0),
    "file-axis-3d": () => __vitePreload(() => import("./file-axis-3d-DYPGeTLS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([546,1]) : void 0),
    "file-badge-2": () => __vitePreload(() => import("./file-badge-2-B2SYqIQQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([547,1]) : void 0),
    "file-badge": () => __vitePreload(() => import("./file-badge-WYI8kFZY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([548,1]) : void 0),
    "file-box": () => __vitePreload(() => import("./file-box-DwJlfo25.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([549,1]) : void 0),
    "file-chart-column-increasing": () => __vitePreload(() => import("./file-chart-column-increasing-B51PyJkl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([550,1]) : void 0),
    "file-chart-column": () => __vitePreload(() => import("./file-chart-column-UnfykTuh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([551,1]) : void 0),
    "file-chart-line": () => __vitePreload(() => import("./file-chart-line-s9fQR7tA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([552,1]) : void 0),
    "file-chart-pie": () => __vitePreload(() => import("./file-chart-pie-D2q3URIY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([553,1]) : void 0),
    "file-check-2": () => __vitePreload(() => import("./file-check-2-ldwIaQ7s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([554,1]) : void 0),
    "file-check": () => __vitePreload(() => import("./file-check-DJivRSOg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([555,1]) : void 0),
    "file-clock": () => __vitePreload(() => import("./file-clock-p_MuxKnC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([556,1]) : void 0),
    "file-code-2": () => __vitePreload(() => import("./file-code-2-CKzZFGgV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([557,1]) : void 0),
    "file-code": () => __vitePreload(() => import("./file-code-lXOJi3bD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([558,1]) : void 0),
    "file-cog": () => __vitePreload(() => import("./file-cog-CWsc-qY8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([559,1]) : void 0),
    "file-diff": () => __vitePreload(() => import("./file-diff-BqVcdH0d.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([560,1]) : void 0),
    "file-digit": () => __vitePreload(() => import("./file-digit-4XWs2yeh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([561,1]) : void 0),
    "file-down": () => __vitePreload(() => import("./file-down-DH8l3vnd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([562,1]) : void 0),
    "file-heart": () => __vitePreload(() => import("./file-heart-B8Yjs8AY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([563,1]) : void 0),
    "file-image": () => __vitePreload(() => import("./file-image-iQ4VEC1H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([564,1]) : void 0),
    "file-input": () => __vitePreload(() => import("./file-input-eSlwQKsk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([565,1]) : void 0),
    "file-json-2": () => __vitePreload(() => import("./file-json-2-B97miwWT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([566,1]) : void 0),
    "file-json": () => __vitePreload(() => import("./file-json-BY_Y07o7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([567,1]) : void 0),
    "file-key-2": () => __vitePreload(() => import("./file-key-2-1fbXIkQi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([568,1]) : void 0),
    "file-key": () => __vitePreload(() => import("./file-key-Bv9fgqw0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([569,1]) : void 0),
    "file-lock-2": () => __vitePreload(() => import("./file-lock-2-BKodZbc3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([570,1]) : void 0),
    "file-lock": () => __vitePreload(() => import("./file-lock-DgLaIajE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([571,1]) : void 0),
    "file-minus-2": () => __vitePreload(() => import("./file-minus-2-3iCEs4CB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([572,1]) : void 0),
    "file-minus": () => __vitePreload(() => import("./file-minus-DlD4J6FC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([573,1]) : void 0),
    "file-music": () => __vitePreload(() => import("./file-music-B-tEnrTF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([574,1]) : void 0),
    "file-output": () => __vitePreload(() => import("./file-output-BWAnUEm5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([575,1]) : void 0),
    "file-pen-line": () => __vitePreload(() => import("./file-pen-line-D6_fcdYM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([576,1]) : void 0),
    "file-pen": () => __vitePreload(() => import("./file-pen-CLxzxJUv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([577,1]) : void 0),
    "file-plus-2": () => __vitePreload(() => import("./file-plus-2-C-SzOcNJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([578,1]) : void 0),
    "file-plus": () => __vitePreload(() => import("./file-plus-FeVQIC8Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([579,1]) : void 0),
    "file-question": () => __vitePreload(() => import("./file-question-DyLQczCY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([580,1]) : void 0),
    "file-scan": () => __vitePreload(() => import("./file-scan-D0I0fcoe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([581,1]) : void 0),
    "file-search-2": () => __vitePreload(() => import("./file-search-2-DcHAWKrl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([582,1]) : void 0),
    "file-search": () => __vitePreload(() => import("./file-search-DdKIlelM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([583,1]) : void 0),
    "file-sliders": () => __vitePreload(() => import("./file-sliders-i1MXjxlH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([584,1]) : void 0),
    "file-spreadsheet": () => __vitePreload(() => import("./file-spreadsheet-CJrbQ4Pm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([585,1]) : void 0),
    "file-stack": () => __vitePreload(() => import("./file-stack-CGW3mCIs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([586,1]) : void 0),
    "file-symlink": () => __vitePreload(() => import("./file-symlink-DULBkQLN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([587,1]) : void 0),
    "file-terminal": () => __vitePreload(() => import("./file-terminal-DZwlrPsS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([588,1]) : void 0),
    "file-text": () => __vitePreload(() => import("./file-text-DdIPdENM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([589,1]) : void 0),
    "file-type-2": () => __vitePreload(() => import("./file-type-2-DRpLym11.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([590,1]) : void 0),
    "file-type": () => __vitePreload(() => import("./file-type-DuUEhY_a.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([591,1]) : void 0),
    "file-up": () => __vitePreload(() => import("./file-up-BVwId72b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([592,1]) : void 0),
    "file-user": () => __vitePreload(() => import("./file-user-Bk9iAwYd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([593,1]) : void 0),
    "file-video-2": () => __vitePreload(() => import("./file-video-2-BSauLPRA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([594,1]) : void 0),
    "file-video": () => __vitePreload(() => import("./file-video-DPY-IHtH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([595,1]) : void 0),
    "file-volume-2": () => __vitePreload(() => import("./file-volume-2-5j8Uzn8Q.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([596,1]) : void 0),
    "file-volume": () => __vitePreload(() => import("./file-volume-DPeAGIR3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([597,1]) : void 0),
    "file-warning": () => __vitePreload(() => import("./file-warning-D7UGYFef.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([598,1]) : void 0),
    "file-x-2": () => __vitePreload(() => import("./file-x-2-lekOmOj7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([599,1]) : void 0),
    "file-x": () => __vitePreload(() => import("./file-x-CqZV7npW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([600,1]) : void 0),
    "file": () => __vitePreload(() => import("./file-Cu_wxXYl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([601,1]) : void 0),
    "files": () => __vitePreload(() => import("./files-CJux2Tj-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([602,1]) : void 0),
    "film": () => __vitePreload(() => import("./film-eL_Rsw7v.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([603,1]) : void 0),
    "filter-x": () => __vitePreload(() => import("./filter-x-CmeTILLI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([604,1]) : void 0),
    "filter": () => __vitePreload(() => import("./filter-Bs0n9QGS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([605,1]) : void 0),
    "fingerprint": () => __vitePreload(() => import("./fingerprint-B2QO6BLU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([606,1]) : void 0),
    "fire-extinguisher": () => __vitePreload(() => import("./fire-extinguisher-CQrpVBWm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([607,1]) : void 0),
    "fish-off": () => __vitePreload(() => import("./fish-off-D3ESZj-4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([608,1]) : void 0),
    "fish-symbol": () => __vitePreload(() => import("./fish-symbol-BvmdhVMD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([609,1]) : void 0),
    "fish": () => __vitePreload(() => import("./fish-DOt1ZYGV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([610,1]) : void 0),
    "flag-off": () => __vitePreload(() => import("./flag-off-LHMVKh7p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([611,1]) : void 0),
    "flag-triangle-left": () => __vitePreload(() => import("./flag-triangle-left-9fJGWkfs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([612,1]) : void 0),
    "flag-triangle-right": () => __vitePreload(() => import("./flag-triangle-right-BHGMp2dq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([613,1]) : void 0),
    "flag": () => __vitePreload(() => import("./flag-HgutDrm0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([614,1]) : void 0),
    "flame-kindling": () => __vitePreload(() => import("./flame-kindling-DWmv4t30.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([615,1]) : void 0),
    "flame": () => __vitePreload(() => import("./flame-N15Sdz2_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([616,1]) : void 0),
    "flashlight-off": () => __vitePreload(() => import("./flashlight-off-Qc5aZE_g.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([617,1]) : void 0),
    "flashlight": () => __vitePreload(() => import("./flashlight-DWUuzkKC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([618,1]) : void 0),
    "flask-conical-off": () => __vitePreload(() => import("./flask-conical-off-ij3IJ_ly.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([619,1]) : void 0),
    "flask-conical": () => __vitePreload(() => import("./flask-conical-IOnnNJEQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([620,1]) : void 0),
    "flask-round": () => __vitePreload(() => import("./flask-round-D2w58WO1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([621,1]) : void 0),
    "flip-horizontal-2": () => __vitePreload(() => import("./flip-horizontal-2-DUXOoSbA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([622,1]) : void 0),
    "flip-horizontal": () => __vitePreload(() => import("./flip-horizontal-DzpJLAEi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([623,1]) : void 0),
    "flip-vertical-2": () => __vitePreload(() => import("./flip-vertical-2-DOlBQngj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([624,1]) : void 0),
    "flip-vertical": () => __vitePreload(() => import("./flip-vertical-CYPdFufq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([625,1]) : void 0),
    "flower-2": () => __vitePreload(() => import("./flower-2-CGuSJyYt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([626,1]) : void 0),
    "flower": () => __vitePreload(() => import("./flower-DL-Lfocn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([627,1]) : void 0),
    "focus": () => __vitePreload(() => import("./focus-BdmvRuKx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([628,1]) : void 0),
    "fold-horizontal": () => __vitePreload(() => import("./fold-horizontal-DFodSdmp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([629,1]) : void 0),
    "fold-vertical": () => __vitePreload(() => import("./fold-vertical-Dvto7KeK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([630,1]) : void 0),
    "folder-archive": () => __vitePreload(() => import("./folder-archive-BYnCNLHW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([631,1]) : void 0),
    "folder-check": () => __vitePreload(() => import("./folder-check-DGzRodlu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([632,1]) : void 0),
    "folder-clock": () => __vitePreload(() => import("./folder-clock-BVtsZ9a7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([633,1]) : void 0),
    "folder-closed": () => __vitePreload(() => import("./folder-closed-Dkmh7ykV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([634,1]) : void 0),
    "folder-code": () => __vitePreload(() => import("./folder-code-CquK7_dR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([635,1]) : void 0),
    "folder-cog": () => __vitePreload(() => import("./folder-cog-Bfzk3ADX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([636,1]) : void 0),
    "folder-dot": () => __vitePreload(() => import("./folder-dot-DjXxVX1i.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([637,1]) : void 0),
    "folder-down": () => __vitePreload(() => import("./folder-down-43Vj-1f_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([638,1]) : void 0),
    "folder-git-2": () => __vitePreload(() => import("./folder-git-2-DQ-VdXM5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([639,1]) : void 0),
    "folder-git": () => __vitePreload(() => import("./folder-git-BKDF3C7V.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([640,1]) : void 0),
    "folder-heart": () => __vitePreload(() => import("./folder-heart-DlRys5Wx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([641,1]) : void 0),
    "folder-input": () => __vitePreload(() => import("./folder-input-BmE5bnka.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([642,1]) : void 0),
    "folder-kanban": () => __vitePreload(() => import("./folder-kanban-DEydVrMi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([643,1]) : void 0),
    "folder-key": () => __vitePreload(() => import("./folder-key-CDBC1W_r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([644,1]) : void 0),
    "folder-lock": () => __vitePreload(() => import("./folder-lock-Zu-fRHdh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([645,1]) : void 0),
    "folder-minus": () => __vitePreload(() => import("./folder-minus-BwfgwMk-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([646,1]) : void 0),
    "folder-open-dot": () => __vitePreload(() => import("./folder-open-dot-ChklAteg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([647,1]) : void 0),
    "folder-open": () => __vitePreload(() => import("./folder-open-dIe9OhV5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([648,1]) : void 0),
    "folder-output": () => __vitePreload(() => import("./folder-output-WO5TqpFl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([649,1]) : void 0),
    "folder-pen": () => __vitePreload(() => import("./folder-pen-BXOuGWUO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([650,1]) : void 0),
    "folder-plus": () => __vitePreload(() => import("./folder-plus-DvFPOHns.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([651,1]) : void 0),
    "folder-root": () => __vitePreload(() => import("./folder-root-9KqnzvI8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([652,1]) : void 0),
    "folder-search-2": () => __vitePreload(() => import("./folder-search-2-CyDgtpNg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([653,1]) : void 0),
    "folder-search": () => __vitePreload(() => import("./folder-search-DQ8COQsr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([654,1]) : void 0),
    "folder-symlink": () => __vitePreload(() => import("./folder-symlink-BpyZfyNN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([655,1]) : void 0),
    "folder-sync": () => __vitePreload(() => import("./folder-sync-Cv-qewKR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([656,1]) : void 0),
    "folder-tree": () => __vitePreload(() => import("./folder-tree-cOe1nVqj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([657,1]) : void 0),
    "folder-up": () => __vitePreload(() => import("./folder-up-BAL5whnz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([658,1]) : void 0),
    "folder-x": () => __vitePreload(() => import("./folder-x-DlK37-Lz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([659,1]) : void 0),
    "folder": () => __vitePreload(() => import("./folder-Dbc0RVEZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([660,1]) : void 0),
    "folders": () => __vitePreload(() => import("./folders-DmFCYl45.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([661,1]) : void 0),
    "footprints": () => __vitePreload(() => import("./footprints-tgLmDYeA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([662,1]) : void 0),
    "forklift": () => __vitePreload(() => import("./forklift-oUhsGGLu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([663,1]) : void 0),
    "forward": () => __vitePreload(() => import("./forward-BIlFUz9S.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([664,1]) : void 0),
    "frame": () => __vitePreload(() => import("./frame-KdJurEs1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([665,1]) : void 0),
    "framer": () => __vitePreload(() => import("./framer-BSAx1pOy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([666,1]) : void 0),
    "frown": () => __vitePreload(() => import("./frown-BNXjdP6h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([667,1]) : void 0),
    "fuel": () => __vitePreload(() => import("./fuel-H9fueOcb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([668,1]) : void 0),
    "fullscreen": () => __vitePreload(() => import("./fullscreen-CMMxgps6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([669,1]) : void 0),
    "gallery-horizontal-end": () => __vitePreload(() => import("./gallery-horizontal-end-BvIHg_FM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([670,1]) : void 0),
    "gallery-horizontal": () => __vitePreload(() => import("./gallery-horizontal-BCBMVwA6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([671,1]) : void 0),
    "gallery-thumbnails": () => __vitePreload(() => import("./gallery-thumbnails-C9SUqVLZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([672,1]) : void 0),
    "gallery-vertical-end": () => __vitePreload(() => import("./gallery-vertical-end-BVm-l-ZV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([673,1]) : void 0),
    "gallery-vertical": () => __vitePreload(() => import("./gallery-vertical-FDtQSzbm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([674,1]) : void 0),
    "gamepad-2": () => __vitePreload(() => import("./gamepad-2-BNUFujqL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([675,1]) : void 0),
    "gamepad": () => __vitePreload(() => import("./gamepad-V8eKDHmH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([676,1]) : void 0),
    "gauge": () => __vitePreload(() => import("./gauge-7K9mtUsZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([677,1]) : void 0),
    "gavel": () => __vitePreload(() => import("./gavel-BxEKYog1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([678,1]) : void 0),
    "gem": () => __vitePreload(() => import("./gem-6qug6Zdz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([679,1]) : void 0),
    "ghost": () => __vitePreload(() => import("./ghost-Brz2FcPb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([680,1]) : void 0),
    "gift": () => __vitePreload(() => import("./gift-BkQ663EA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([681,1]) : void 0),
    "git-branch-plus": () => __vitePreload(() => import("./git-branch-plus-DjozWHvt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([682,1]) : void 0),
    "git-branch": () => __vitePreload(() => import("./git-branch-BLMboX0D.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([683,1]) : void 0),
    "git-commit-horizontal": () => __vitePreload(() => import("./git-commit-horizontal-LfHozc0p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([684,1]) : void 0),
    "git-commit-vertical": () => __vitePreload(() => import("./git-commit-vertical-rExEMeG6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([685,1]) : void 0),
    "git-compare-arrows": () => __vitePreload(() => import("./git-compare-arrows-CysL1z0P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([686,1]) : void 0),
    "git-compare": () => __vitePreload(() => import("./git-compare-UEy-Hhlr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([687,1]) : void 0),
    "git-fork": () => __vitePreload(() => import("./git-fork-CkdE2Z6H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([688,1]) : void 0),
    "git-graph": () => __vitePreload(() => import("./git-graph-BG-stPv6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([689,1]) : void 0),
    "git-merge": () => __vitePreload(() => import("./git-merge-czpaqJX2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([690,1]) : void 0),
    "git-pull-request-arrow": () => __vitePreload(() => import("./git-pull-request-arrow-B64dDBXT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([691,1]) : void 0),
    "git-pull-request-closed": () => __vitePreload(() => import("./git-pull-request-closed-DUDp-nsq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([692,1]) : void 0),
    "git-pull-request-create-arrow": () => __vitePreload(() => import("./git-pull-request-create-arrow-vfGm9yCJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([693,1]) : void 0),
    "git-pull-request-create": () => __vitePreload(() => import("./git-pull-request-create-fXOb9vAu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([694,1]) : void 0),
    "git-pull-request-draft": () => __vitePreload(() => import("./git-pull-request-draft-DPqJG2BL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([695,1]) : void 0),
    "git-pull-request": () => __vitePreload(() => import("./git-pull-request-CwWKXsfo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([696,1]) : void 0),
    "github": () => __vitePreload(() => import("./github-BUIHmzij.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([697,1]) : void 0),
    "gitlab": () => __vitePreload(() => import("./gitlab-2h4b_GLE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([698,1]) : void 0),
    "glass-water": () => __vitePreload(() => import("./glass-water-ZhkHNt9E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([699,1]) : void 0),
    "glasses": () => __vitePreload(() => import("./glasses-CKpD9BDt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([700,1]) : void 0),
    "globe-lock": () => __vitePreload(() => import("./globe-lock-DJg6jj3f.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([701,1]) : void 0),
    "globe": () => __vitePreload(() => import("./globe-C6URFmcD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([702,1]) : void 0),
    "goal": () => __vitePreload(() => import("./goal-Cl0uK3A-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([703,1]) : void 0),
    "grab": () => __vitePreload(() => import("./grab-CRirJ3QI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([704,1]) : void 0),
    "graduation-cap": () => __vitePreload(() => import("./graduation-cap-5YvoOu27.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([705,1]) : void 0),
    "grape": () => __vitePreload(() => import("./grape-iRxIXnwJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([706,1]) : void 0),
    "grid-2x2-check": () => __vitePreload(() => import("./grid-2x2-check-B5CrWXhe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([707,1]) : void 0),
    "grid-2x2-plus": () => __vitePreload(() => import("./grid-2x2-plus-Dd-xZWW1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([708,1]) : void 0),
    "grid-2x2-x": () => __vitePreload(() => import("./grid-2x2-x-BNqEmhMe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([709,1]) : void 0),
    "grid-2x2": () => __vitePreload(() => import("./grid-2x2-CIiHKHxU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([710,1]) : void 0),
    "grid-3x3": () => __vitePreload(() => import("./grid-3x3-C04nVtGa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([711,1]) : void 0),
    "grip-horizontal": () => __vitePreload(() => import("./grip-horizontal-BRuGzazd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([712,1]) : void 0),
    "grip-vertical": () => __vitePreload(() => import("./grip-vertical-RdR8DjMM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([713,1]) : void 0),
    "grip": () => __vitePreload(() => import("./grip-Dmx326So.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([714,1]) : void 0),
    "group": () => __vitePreload(() => import("./group-BMQoB3kG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([715,1]) : void 0),
    "guitar": () => __vitePreload(() => import("./guitar-D3qOoMYy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([716,1]) : void 0),
    "ham": () => __vitePreload(() => import("./ham-C2WfYl21.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([717,1]) : void 0),
    "hammer": () => __vitePreload(() => import("./hammer--UY98v81.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([718,1]) : void 0),
    "hand-coins": () => __vitePreload(() => import("./hand-coins-Co9_qnM4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([719,1]) : void 0),
    "hand-heart": () => __vitePreload(() => import("./hand-heart-DQtNFjnz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([720,1]) : void 0),
    "hand-helping": () => __vitePreload(() => import("./hand-helping-DIpf50KX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([721,1]) : void 0),
    "hand-metal": () => __vitePreload(() => import("./hand-metal-B8YktXyq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([722,1]) : void 0),
    "hand-platter": () => __vitePreload(() => import("./hand-platter-CQOn896H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([723,1]) : void 0),
    "hand": () => __vitePreload(() => import("./hand-BJ4oVcYT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([724,1]) : void 0),
    "handshake": () => __vitePreload(() => import("./handshake-0HiSdyC4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([725,1]) : void 0),
    "hard-drive-download": () => __vitePreload(() => import("./hard-drive-download-CGFHrtu-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([726,1]) : void 0),
    "hard-drive-upload": () => __vitePreload(() => import("./hard-drive-upload-C4pYpCwI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([727,1]) : void 0),
    "hard-drive": () => __vitePreload(() => import("./hard-drive-CN5SQUbY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([728,1]) : void 0),
    "hard-hat": () => __vitePreload(() => import("./hard-hat-kYmwPkAl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([729,1]) : void 0),
    "hash": () => __vitePreload(() => import("./hash-pJzgCwMe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([730,1]) : void 0),
    "haze": () => __vitePreload(() => import("./haze-F-yjVPlz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([731,1]) : void 0),
    "hdmi-port": () => __vitePreload(() => import("./hdmi-port-CmEptjJU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([732,1]) : void 0),
    "heading-1": () => __vitePreload(() => import("./heading-1-Cszmf0Cv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([733,1]) : void 0),
    "heading-2": () => __vitePreload(() => import("./heading-2-whJmJX3i.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([734,1]) : void 0),
    "heading-3": () => __vitePreload(() => import("./heading-3-CoqdyJic.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([735,1]) : void 0),
    "heading-4": () => __vitePreload(() => import("./heading-4-73W48Kbb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([736,1]) : void 0),
    "heading-5": () => __vitePreload(() => import("./heading-5-gAU1e5u3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([737,1]) : void 0),
    "heading-6": () => __vitePreload(() => import("./heading-6-DXg8lvIj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([738,1]) : void 0),
    "heading": () => __vitePreload(() => import("./heading-DiIb6Viz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([739,1]) : void 0),
    "headphone-off": () => __vitePreload(() => import("./headphone-off-BBUz12Qx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([740,1]) : void 0),
    "headphones": () => __vitePreload(() => import("./headphones-chKf6I-l.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([741,1]) : void 0),
    "headset": () => __vitePreload(() => import("./headset-DqjFGBP1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([742,1]) : void 0),
    "heart-crack": () => __vitePreload(() => import("./heart-crack-BGxBCM2R.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([743,1]) : void 0),
    "heart-handshake": () => __vitePreload(() => import("./heart-handshake-CptQ3Y3H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([744,1]) : void 0),
    "heart-off": () => __vitePreload(() => import("./heart-off-BCXNhLS6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([745,1]) : void 0),
    "heart-pulse": () => __vitePreload(() => import("./heart-pulse-C7jcreP5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([746,1]) : void 0),
    "heart": () => __vitePreload(() => import("./heart-z64Rry_O.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([747,1]) : void 0),
    "heater": () => __vitePreload(() => import("./heater-CIL56VUr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([748,1]) : void 0),
    "hexagon": () => __vitePreload(() => import("./hexagon-C3Aa5cvj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([749,1]) : void 0),
    "highlighter": () => __vitePreload(() => import("./highlighter-DPBZrIaM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([750,1]) : void 0),
    "history": () => __vitePreload(() => import("./history-BRhxCEwK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([751,1]) : void 0),
    "hop-off": () => __vitePreload(() => import("./hop-off-CjDbT42F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([752,1]) : void 0),
    "hop": () => __vitePreload(() => import("./hop-BdZsdLvJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([753,1]) : void 0),
    "hospital": () => __vitePreload(() => import("./hospital-CbNcjmeo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([754,1]) : void 0),
    "hotel": () => __vitePreload(() => import("./hotel-DVdG0D_Q.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([755,1]) : void 0),
    "hourglass": () => __vitePreload(() => import("./hourglass-DTxy3Qxg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([756,1]) : void 0),
    "house-plug": () => __vitePreload(() => import("./house-plug-Cg9zDZde.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([757,1]) : void 0),
    "house-plus": () => __vitePreload(() => import("./house-plus-CvZ_I0uG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([758,1]) : void 0),
    "house": () => __vitePreload(() => import("./house-DAP4hey1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([759,1]) : void 0),
    "ice-cream-bowl": () => __vitePreload(() => import("./ice-cream-bowl-CNHAN7V2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([760,1]) : void 0),
    "ice-cream-cone": () => __vitePreload(() => import("./ice-cream-cone-C9P8xOc8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([761,1]) : void 0),
    "id-card": () => __vitePreload(() => import("./id-card-BmJSgM-p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([762,1]) : void 0),
    "image-down": () => __vitePreload(() => import("./image-down-DBU6zyCz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([763,1]) : void 0),
    "image-minus": () => __vitePreload(() => import("./image-minus-BZ0Z5lta.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([764,1]) : void 0),
    "image-off": () => __vitePreload(() => import("./image-off-BJB6Gno-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([765,1]) : void 0),
    "image-play": () => __vitePreload(() => import("./image-play-BnurUCoQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([766,1]) : void 0),
    "image-plus": () => __vitePreload(() => import("./image-plus-BiGF5RMx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([767,1]) : void 0),
    "image-up": () => __vitePreload(() => import("./image-up-DCoOD52F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([768,1]) : void 0),
    "image-upscale": () => __vitePreload(() => import("./image-upscale-mv9bue4I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([769,1]) : void 0),
    "image": () => __vitePreload(() => import("./image-D8TYY2B5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([770,1]) : void 0),
    "images": () => __vitePreload(() => import("./images-D0xXufz4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([771,1]) : void 0),
    "import": () => __vitePreload(() => import("./import-CmLLob3U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([772,1]) : void 0),
    "inbox": () => __vitePreload(() => import("./inbox-D79nCtE_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([773,1]) : void 0),
    "indent-decrease": () => __vitePreload(() => import("./indent-decrease-D0cNPHwt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([774,1]) : void 0),
    "indent-increase": () => __vitePreload(() => import("./indent-increase-CmjYEhgs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([775,1]) : void 0),
    "indian-rupee": () => __vitePreload(() => import("./indian-rupee-DcAguhtv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([776,1]) : void 0),
    "infinity": () => __vitePreload(() => import("./infinity-B3ZvpxMk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([777,1]) : void 0),
    "info": () => __vitePreload(() => import("./info-h8vJgs86.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([778,1]) : void 0),
    "inspection-panel": () => __vitePreload(() => import("./inspection-panel-DlTQr1Ti.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([779,1]) : void 0),
    "instagram": () => __vitePreload(() => import("./instagram-B93Xj182.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([780,1]) : void 0),
    "italic": () => __vitePreload(() => import("./italic-CRRIvtav.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([781,1]) : void 0),
    "iteration-ccw": () => __vitePreload(() => import("./iteration-ccw-D7xF4-u6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([782,1]) : void 0),
    "iteration-cw": () => __vitePreload(() => import("./iteration-cw-Bk241U2r.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([783,1]) : void 0),
    "japanese-yen": () => __vitePreload(() => import("./japanese-yen-mZ9l81hm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([784,1]) : void 0),
    "joystick": () => __vitePreload(() => import("./joystick-C_DU3Dqn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([785,1]) : void 0),
    "kanban": () => __vitePreload(() => import("./kanban-D8y2PCYw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([786,1]) : void 0),
    "key-round": () => __vitePreload(() => import("./key-round-CbiL4vXg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([787,1]) : void 0),
    "key-square": () => __vitePreload(() => import("./key-square-DsNGLLWc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([788,1]) : void 0),
    "key": () => __vitePreload(() => import("./key-Dus8xFFg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([789,1]) : void 0),
    "keyboard-music": () => __vitePreload(() => import("./keyboard-music-u1hIMk0C.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([790,1]) : void 0),
    "keyboard-off": () => __vitePreload(() => import("./keyboard-off-D_MTg_Xm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([791,1]) : void 0),
    "keyboard": () => __vitePreload(() => import("./keyboard-TwlyQStD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([792,1]) : void 0),
    "lamp-ceiling": () => __vitePreload(() => import("./lamp-ceiling-BNc5V7zY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([793,1]) : void 0),
    "lamp-desk": () => __vitePreload(() => import("./lamp-desk-DywckqNc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([794,1]) : void 0),
    "lamp-floor": () => __vitePreload(() => import("./lamp-floor-C5ulkcr4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([795,1]) : void 0),
    "lamp-wall-down": () => __vitePreload(() => import("./lamp-wall-down-DwFOBp4U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([796,1]) : void 0),
    "lamp-wall-up": () => __vitePreload(() => import("./lamp-wall-up-Dk5fTn7P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([797,1]) : void 0),
    "lamp": () => __vitePreload(() => import("./lamp-Z-FeWWkO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([798,1]) : void 0),
    "land-plot": () => __vitePreload(() => import("./land-plot-qufbVe5P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([799,1]) : void 0),
    "landmark": () => __vitePreload(() => import("./landmark-D3ufVarT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([800,1]) : void 0),
    "languages": () => __vitePreload(() => import("./languages-C44K1QEo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([801,1]) : void 0),
    "laptop-minimal-check": () => __vitePreload(() => import("./laptop-minimal-check-DGKmQ-3Q.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([802,1]) : void 0),
    "laptop-minimal": () => __vitePreload(() => import("./laptop-minimal-qqbY6nKw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([803,1]) : void 0),
    "laptop": () => __vitePreload(() => import("./laptop-CpXOA6Jq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([804,1]) : void 0),
    "lasso-select": () => __vitePreload(() => import("./lasso-select-VPQK6u8t.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([805,1]) : void 0),
    "lasso": () => __vitePreload(() => import("./lasso-VYBAvXhf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([806,1]) : void 0),
    "laugh": () => __vitePreload(() => import("./laugh-CZVTyO2G.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([807,1]) : void 0),
    "layers-2": () => __vitePreload(() => import("./layers-2-DiVQ1axR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([808,1]) : void 0),
    "layers-3": () => __vitePreload(() => import("./layers-3-Cij7gzDD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([809,1]) : void 0),
    "layers": () => __vitePreload(() => import("./layers-CSiETsWi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([810,1]) : void 0),
    "layout-dashboard": () => __vitePreload(() => import("./layout-dashboard-ClZKAXRs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([811,1]) : void 0),
    "layout-grid": () => __vitePreload(() => import("./layout-grid-DpEI0rbf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([812,1]) : void 0),
    "layout-list": () => __vitePreload(() => import("./layout-list-DX72k6kd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([813,1]) : void 0),
    "layout-panel-left": () => __vitePreload(() => import("./layout-panel-left-BYukh-Cv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([814,1]) : void 0),
    "layout-panel-top": () => __vitePreload(() => import("./layout-panel-top-C_mkKuk7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([815,1]) : void 0),
    "layout-template": () => __vitePreload(() => import("./layout-template-u7Q6cvXP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([816,1]) : void 0),
    "leaf": () => __vitePreload(() => import("./leaf-Dp9L_g55.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([817,1]) : void 0),
    "leafy-green": () => __vitePreload(() => import("./leafy-green-DQuSuiyQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([818,1]) : void 0),
    "lectern": () => __vitePreload(() => import("./lectern-ScdRULAn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([819,1]) : void 0),
    "letter-text": () => __vitePreload(() => import("./letter-text-DePKyvjw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([820,1]) : void 0),
    "library-big": () => __vitePreload(() => import("./library-big-N07NaA9n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([821,1]) : void 0),
    "library": () => __vitePreload(() => import("./library-YLdvCUN9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([822,1]) : void 0),
    "life-buoy": () => __vitePreload(() => import("./life-buoy-SuDW6l9u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([823,1]) : void 0),
    "ligature": () => __vitePreload(() => import("./ligature-D94o63sl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([824,1]) : void 0),
    "lightbulb-off": () => __vitePreload(() => import("./lightbulb-off-BUvJqJw6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([825,1]) : void 0),
    "lightbulb": () => __vitePreload(() => import("./lightbulb-Cez3EIYi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([826,1]) : void 0),
    "link-2-off": () => __vitePreload(() => import("./link-2-off-DncVXL-o.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([827,1]) : void 0),
    "link-2": () => __vitePreload(() => import("./link-2-CJaA6n6k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([828,1]) : void 0),
    "link": () => __vitePreload(() => import("./link-1rrFhL5n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([829,1]) : void 0),
    "linkedin": () => __vitePreload(() => import("./linkedin-C5a0Rf2Z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([830,1]) : void 0),
    "list-check": () => __vitePreload(() => import("./list-check-BYuV6scQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([831,1]) : void 0),
    "list-checks": () => __vitePreload(() => import("./list-checks-fcoo-cJc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([832,1]) : void 0),
    "list-collapse": () => __vitePreload(() => import("./list-collapse-Bac3vufw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([833,1]) : void 0),
    "list-end": () => __vitePreload(() => import("./list-end-BAkgFyej.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([834,1]) : void 0),
    "list-filter": () => __vitePreload(() => import("./list-filter-CdNBKCtB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([835,1]) : void 0),
    "list-minus": () => __vitePreload(() => import("./list-minus-CiRGdabl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([836,1]) : void 0),
    "list-music": () => __vitePreload(() => import("./list-music-DDjnPdlD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([837,1]) : void 0),
    "list-ordered": () => __vitePreload(() => import("./list-ordered-CU5N6fJc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([838,1]) : void 0),
    "list-plus": () => __vitePreload(() => import("./list-plus-DwTupgTd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([839,1]) : void 0),
    "list-restart": () => __vitePreload(() => import("./list-restart-pjS246il.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([840,1]) : void 0),
    "list-start": () => __vitePreload(() => import("./list-start-BPgUDmUN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([841,1]) : void 0),
    "list-todo": () => __vitePreload(() => import("./list-todo-efH1_AQm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([842,1]) : void 0),
    "list-tree": () => __vitePreload(() => import("./list-tree-CRktdGJV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([843,1]) : void 0),
    "list-video": () => __vitePreload(() => import("./list-video-BeFsqvrI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([844,1]) : void 0),
    "list-x": () => __vitePreload(() => import("./list-x-nroYKNzt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([845,1]) : void 0),
    "list": () => __vitePreload(() => import("./list-BB7Nay6y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([846,1]) : void 0),
    "loader-circle": () => __vitePreload(() => import("./loader-circle-Dbm6Dzit.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([847,1]) : void 0),
    "loader-pinwheel": () => __vitePreload(() => import("./loader-pinwheel-D2NcbIIL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([848,1]) : void 0),
    "loader": () => __vitePreload(() => import("./loader-Cxfgy6If.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([849,1]) : void 0),
    "locate-fixed": () => __vitePreload(() => import("./locate-fixed-meXTmoRw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([850,1]) : void 0),
    "locate-off": () => __vitePreload(() => import("./locate-off-aTf9QMQO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([851,1]) : void 0),
    "locate": () => __vitePreload(() => import("./locate-BSlb_idg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([852,1]) : void 0),
    "lock-keyhole-open": () => __vitePreload(() => import("./lock-keyhole-open-Bd9auBkf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([853,1]) : void 0),
    "lock-keyhole": () => __vitePreload(() => import("./lock-keyhole-5vb7BKDM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([854,1]) : void 0),
    "lock-open": () => __vitePreload(() => import("./lock-open-opTqjhkk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([855,1]) : void 0),
    "lock": () => __vitePreload(() => import("./lock-D6iJjZz2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([856,1]) : void 0),
    "log-in": () => __vitePreload(() => import("./log-in-DQRh49_w.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([857,1]) : void 0),
    "log-out": () => __vitePreload(() => import("./log-out-Cka8piFl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([858,1]) : void 0),
    "logs": () => __vitePreload(() => import("./logs-BTWLC5Bw.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([859,1]) : void 0),
    "lollipop": () => __vitePreload(() => import("./lollipop-CxGy1X8F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([860,1]) : void 0),
    "luggage": () => __vitePreload(() => import("./luggage-CCUUro4I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([861,1]) : void 0),
    "magnet": () => __vitePreload(() => import("./magnet-Bu1B5Qgh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([862,1]) : void 0),
    "mail-check": () => __vitePreload(() => import("./mail-check-Cqc-tXHc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([863,1]) : void 0),
    "mail-minus": () => __vitePreload(() => import("./mail-minus-DhdztvdJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([864,1]) : void 0),
    "mail-open": () => __vitePreload(() => import("./mail-open-BRcnj0gX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([865,1]) : void 0),
    "mail-plus": () => __vitePreload(() => import("./mail-plus-CHjsnGss.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([866,1]) : void 0),
    "mail-question": () => __vitePreload(() => import("./mail-question-esfAi8Z_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([867,1]) : void 0),
    "mail-search": () => __vitePreload(() => import("./mail-search-BD8-DAee.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([868,1]) : void 0),
    "mail-warning": () => __vitePreload(() => import("./mail-warning-DygFAavs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([869,1]) : void 0),
    "mail-x": () => __vitePreload(() => import("./mail-x-B3MH_fKo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([870,1]) : void 0),
    "mail": () => __vitePreload(() => import("./mail-CshXiMxD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([871,1]) : void 0),
    "mailbox": () => __vitePreload(() => import("./mailbox-BUDfkX4u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([872,1]) : void 0),
    "mails": () => __vitePreload(() => import("./mails-iKqzBZfi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([873,1]) : void 0),
    "map-pin-check-inside": () => __vitePreload(() => import("./map-pin-check-inside-DTL8tYCt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([874,1]) : void 0),
    "map-pin-check": () => __vitePreload(() => import("./map-pin-check-_SM7Vnf5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([875,1]) : void 0),
    "map-pin-house": () => __vitePreload(() => import("./map-pin-house-BfNVmTy9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([876,1]) : void 0),
    "map-pin-minus-inside": () => __vitePreload(() => import("./map-pin-minus-inside-Cw4n1wSh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([877,1]) : void 0),
    "map-pin-minus": () => __vitePreload(() => import("./map-pin-minus-B-qkPGTE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([878,1]) : void 0),
    "map-pin-off": () => __vitePreload(() => import("./map-pin-off-CFnDDuaN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([879,1]) : void 0),
    "map-pin-plus-inside": () => __vitePreload(() => import("./map-pin-plus-inside-DFF71zDy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([880,1]) : void 0),
    "map-pin-plus": () => __vitePreload(() => import("./map-pin-plus-JE3lmZtU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([881,1]) : void 0),
    "map-pin-x-inside": () => __vitePreload(() => import("./map-pin-x-inside-DE3WIi4f.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([882,1]) : void 0),
    "map-pin-x": () => __vitePreload(() => import("./map-pin-x-Ccov6lQ0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([883,1]) : void 0),
    "map-pin": () => __vitePreload(() => import("./map-pin-DZy8kSdq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([884,1]) : void 0),
    "map-pinned": () => __vitePreload(() => import("./map-pinned-Dy40J_4E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([885,1]) : void 0),
    "map": () => __vitePreload(() => import("./map-C5jv-Por.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([886,1]) : void 0),
    "martini": () => __vitePreload(() => import("./martini-C9Yc4ixl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([887,1]) : void 0),
    "maximize-2": () => __vitePreload(() => import("./maximize-2-DuyZOozx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([888,1]) : void 0),
    "maximize": () => __vitePreload(() => import("./maximize-CN2oHIgM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([889,1]) : void 0),
    "medal": () => __vitePreload(() => import("./medal-Bd4R30Oz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([890,1]) : void 0),
    "megaphone-off": () => __vitePreload(() => import("./megaphone-off-B1nRDGAX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([891,1]) : void 0),
    "megaphone": () => __vitePreload(() => import("./megaphone-DP0aNPhK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([892,1]) : void 0),
    "meh": () => __vitePreload(() => import("./meh-Bz2xhAXI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([893,1]) : void 0),
    "memory-stick": () => __vitePreload(() => import("./memory-stick-CpGBcfyG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([894,1]) : void 0),
    "menu": () => __vitePreload(() => import("./menu-CJz4PFqb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([895,1]) : void 0),
    "merge": () => __vitePreload(() => import("./merge-DzxJLbnp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([896,1]) : void 0),
    "message-circle-code": () => __vitePreload(() => import("./message-circle-code-D86Wt10d.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([897,1]) : void 0),
    "message-circle-dashed": () => __vitePreload(() => import("./message-circle-dashed-i1sZSNyA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([898,1]) : void 0),
    "message-circle-heart": () => __vitePreload(() => import("./message-circle-heart-yqglnhFL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([899,1]) : void 0),
    "message-circle-more": () => __vitePreload(() => import("./message-circle-more-DYvVgOE-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([900,1]) : void 0),
    "message-circle-off": () => __vitePreload(() => import("./message-circle-off-CQqQaXqF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([901,1]) : void 0),
    "message-circle-plus": () => __vitePreload(() => import("./message-circle-plus-Dm3F1H6i.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([902,1]) : void 0),
    "message-circle-question": () => __vitePreload(() => import("./message-circle-question-BanRYOA8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([903,1]) : void 0),
    "message-circle-reply": () => __vitePreload(() => import("./message-circle-reply-Ck2z7CzE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([904,1]) : void 0),
    "message-circle-warning": () => __vitePreload(() => import("./message-circle-warning-BfBuZKTY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([905,1]) : void 0),
    "message-circle-x": () => __vitePreload(() => import("./message-circle-x-DPyRpOzX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([906,1]) : void 0),
    "message-circle": () => __vitePreload(() => import("./message-circle-D2Z7irgD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([907,1]) : void 0),
    "message-square-code": () => __vitePreload(() => import("./message-square-code-o-m-9TKC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([908,1]) : void 0),
    "message-square-dashed": () => __vitePreload(() => import("./message-square-dashed-fflvV7lZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([909,1]) : void 0),
    "message-square-diff": () => __vitePreload(() => import("./message-square-diff-DX-zFE2h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([910,1]) : void 0),
    "message-square-dot": () => __vitePreload(() => import("./message-square-dot-Cgp9X3Yf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([911,1]) : void 0),
    "message-square-heart": () => __vitePreload(() => import("./message-square-heart-CuaVIN9a.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([912,1]) : void 0),
    "message-square-lock": () => __vitePreload(() => import("./message-square-lock-CbTgVrHr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([913,1]) : void 0),
    "message-square-more": () => __vitePreload(() => import("./message-square-more-DTzTjgs-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([914,1]) : void 0),
    "message-square-off": () => __vitePreload(() => import("./message-square-off-CNj9eeRB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([915,1]) : void 0),
    "message-square-plus": () => __vitePreload(() => import("./message-square-plus-C8rBpeSi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([916,1]) : void 0),
    "message-square-quote": () => __vitePreload(() => import("./message-square-quote-TKvqjvOb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([917,1]) : void 0),
    "message-square-reply": () => __vitePreload(() => import("./message-square-reply-PjRI5xnl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([918,1]) : void 0),
    "message-square-share": () => __vitePreload(() => import("./message-square-share-DGs8YU6H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([919,1]) : void 0),
    "message-square-text": () => __vitePreload(() => import("./message-square-text-DfUhWnyN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([920,1]) : void 0),
    "message-square-warning": () => __vitePreload(() => import("./message-square-warning-Ci4F3F4M.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([921,1]) : void 0),
    "message-square-x": () => __vitePreload(() => import("./message-square-x-AeP7m__2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([922,1]) : void 0),
    "message-square": () => __vitePreload(() => import("./message-square-CgIrJ6RD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([923,1]) : void 0),
    "messages-square": () => __vitePreload(() => import("./messages-square-5Cv1tGvZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([924,1]) : void 0),
    "mic-off": () => __vitePreload(() => import("./mic-off-COxD8jwo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([925,1]) : void 0),
    "mic-vocal": () => __vitePreload(() => import("./mic-vocal-Cv6_gWc0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([926,1]) : void 0),
    "mic": () => __vitePreload(() => import("./mic-De8fcxlJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([927,1]) : void 0),
    "microchip": () => __vitePreload(() => import("./microchip-Mn0VyVoS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([928,1]) : void 0),
    "microscope": () => __vitePreload(() => import("./microscope-GrXqLA7H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([929,1]) : void 0),
    "microwave": () => __vitePreload(() => import("./microwave-49Ppbl26.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([930,1]) : void 0),
    "milestone": () => __vitePreload(() => import("./milestone-Cu93GL3_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([931,1]) : void 0),
    "milk-off": () => __vitePreload(() => import("./milk-off-BwljurOk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([932,1]) : void 0),
    "milk": () => __vitePreload(() => import("./milk-Cxaf0W8K.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([933,1]) : void 0),
    "minimize-2": () => __vitePreload(() => import("./minimize-2-DqU3tP4M.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([934,1]) : void 0),
    "minimize": () => __vitePreload(() => import("./minimize-DfCcmDN-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([935,1]) : void 0),
    "minus": () => __vitePreload(() => import("./minus-Ccxh3YCz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([936,1]) : void 0),
    "monitor-check": () => __vitePreload(() => import("./monitor-check-CYtd_uTU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([937,1]) : void 0),
    "monitor-cog": () => __vitePreload(() => import("./monitor-cog-CCtksGYF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([938,1]) : void 0),
    "monitor-dot": () => __vitePreload(() => import("./monitor-dot-CVNBS52k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([939,1]) : void 0),
    "monitor-down": () => __vitePreload(() => import("./monitor-down-ozj1QdGE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([940,1]) : void 0),
    "monitor-off": () => __vitePreload(() => import("./monitor-off-BYV1DHcZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([941,1]) : void 0),
    "monitor-pause": () => __vitePreload(() => import("./monitor-pause-ChmkWbL4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([942,1]) : void 0),
    "monitor-play": () => __vitePreload(() => import("./monitor-play-CAshM8xz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([943,1]) : void 0),
    "monitor-smartphone": () => __vitePreload(() => import("./monitor-smartphone-Bt9Ys_aU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([944,1]) : void 0),
    "monitor-speaker": () => __vitePreload(() => import("./monitor-speaker-DPOJLSxE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([945,1]) : void 0),
    "monitor-stop": () => __vitePreload(() => import("./monitor-stop-CInllMFy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([946,1]) : void 0),
    "monitor-up": () => __vitePreload(() => import("./monitor-up-C_GS7DWb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([947,1]) : void 0),
    "monitor-x": () => __vitePreload(() => import("./monitor-x-C1yPE3gW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([948,1]) : void 0),
    "monitor": () => __vitePreload(() => import("./monitor-B4d3ERzI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([949,1]) : void 0),
    "moon-star": () => __vitePreload(() => import("./moon-star-DyX3RHF7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([950,1]) : void 0),
    "moon": () => __vitePreload(() => import("./moon-sgy_arMg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([951,1]) : void 0),
    "mountain-snow": () => __vitePreload(() => import("./mountain-snow-lKrym0VU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([952,1]) : void 0),
    "mountain": () => __vitePreload(() => import("./mountain-C6ZwoRGG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([953,1]) : void 0),
    "mouse-off": () => __vitePreload(() => import("./mouse-off-CPdKoa4n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([954,1]) : void 0),
    "mouse-pointer-2": () => __vitePreload(() => import("./mouse-pointer-2-whBnHKlP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([955,1]) : void 0),
    "mouse-pointer-ban": () => __vitePreload(() => import("./mouse-pointer-ban-BnB2dCII.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([956,1]) : void 0),
    "mouse-pointer-click": () => __vitePreload(() => import("./mouse-pointer-click-Co_GuJrp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([957,1]) : void 0),
    "mouse-pointer": () => __vitePreload(() => import("./mouse-pointer-DU-epVho.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([958,1]) : void 0),
    "mouse": () => __vitePreload(() => import("./mouse-BK4ey5cv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([959,1]) : void 0),
    "move-3d": () => __vitePreload(() => import("./move-3d-De2Bqpl1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([960,1]) : void 0),
    "move-diagonal-2": () => __vitePreload(() => import("./move-diagonal-2-DAcyzdEf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([961,1]) : void 0),
    "move-diagonal": () => __vitePreload(() => import("./move-diagonal-DRebUNSX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([962,1]) : void 0),
    "move-down-left": () => __vitePreload(() => import("./move-down-left-De5aleAs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([963,1]) : void 0),
    "move-down-right": () => __vitePreload(() => import("./move-down-right-OOEN9x6Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([964,1]) : void 0),
    "move-down": () => __vitePreload(() => import("./move-down-CZ7XhOsM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([965,1]) : void 0),
    "move-horizontal": () => __vitePreload(() => import("./move-horizontal-Dn7gzJkn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([966,1]) : void 0),
    "move-left": () => __vitePreload(() => import("./move-left-DJgICMIe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([967,1]) : void 0),
    "move-right": () => __vitePreload(() => import("./move-right-CDx1T7r0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([968,1]) : void 0),
    "move-up-left": () => __vitePreload(() => import("./move-up-left-qMfS2myB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([969,1]) : void 0),
    "move-up-right": () => __vitePreload(() => import("./move-up-right-DkBHPFAh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([970,1]) : void 0),
    "move-up": () => __vitePreload(() => import("./move-up-DsAfig7k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([971,1]) : void 0),
    "move-vertical": () => __vitePreload(() => import("./move-vertical-tj3LOdvp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([972,1]) : void 0),
    "move": () => __vitePreload(() => import("./move-DHt0ziIN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([973,1]) : void 0),
    "music-2": () => __vitePreload(() => import("./music-2-CJTEfpH0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([974,1]) : void 0),
    "music-3": () => __vitePreload(() => import("./music-3-js26bEOe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([975,1]) : void 0),
    "music-4": () => __vitePreload(() => import("./music-4-Da0ek3C2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([976,1]) : void 0),
    "music": () => __vitePreload(() => import("./music-CajUk8Sn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([977,1]) : void 0),
    "navigation-2-off": () => __vitePreload(() => import("./navigation-2-off-jT1Pomho.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([978,1]) : void 0),
    "navigation-2": () => __vitePreload(() => import("./navigation-2-4YqN1HVB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([979,1]) : void 0),
    "navigation-off": () => __vitePreload(() => import("./navigation-off-DECPLUU_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([980,1]) : void 0),
    "navigation": () => __vitePreload(() => import("./navigation-DiKo9BW7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([981,1]) : void 0),
    "network": () => __vitePreload(() => import("./network-CoVrDhj6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([982,1]) : void 0),
    "newspaper": () => __vitePreload(() => import("./newspaper-BBvv2FS5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([983,1]) : void 0),
    "nfc": () => __vitePreload(() => import("./nfc-DPKak7fb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([984,1]) : void 0),
    "notebook-pen": () => __vitePreload(() => import("./notebook-pen-CfOifqYd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([985,1]) : void 0),
    "notebook-tabs": () => __vitePreload(() => import("./notebook-tabs-Dh2UnFJE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([986,1]) : void 0),
    "notebook-text": () => __vitePreload(() => import("./notebook-text-BO76-Lln.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([987,1]) : void 0),
    "notebook": () => __vitePreload(() => import("./notebook-w0g4P_4d.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([988,1]) : void 0),
    "notepad-text-dashed": () => __vitePreload(() => import("./notepad-text-dashed-VoQBfGHE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([989,1]) : void 0),
    "notepad-text": () => __vitePreload(() => import("./notepad-text-DExTfkNe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([990,1]) : void 0),
    "nut-off": () => __vitePreload(() => import("./nut-off-BZDLISFG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([991,1]) : void 0),
    "nut": () => __vitePreload(() => import("./nut-DWf4YH75.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([992,1]) : void 0),
    "octagon-alert": () => __vitePreload(() => import("./octagon-alert-3jASwgbh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([993,1]) : void 0),
    "octagon-minus": () => __vitePreload(() => import("./octagon-minus-xwRBDvwe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([994,1]) : void 0),
    "octagon-pause": () => __vitePreload(() => import("./octagon-pause-B4gj59W1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([995,1]) : void 0),
    "octagon-x": () => __vitePreload(() => import("./octagon-x-CIMLIk7F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([996,1]) : void 0),
    "octagon": () => __vitePreload(() => import("./octagon-DAzerjpi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([997,1]) : void 0),
    "omega": () => __vitePreload(() => import("./omega-BeNJUY5_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([998,1]) : void 0),
    "option": () => __vitePreload(() => import("./option-CURQ2rLU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([999,1]) : void 0),
    "orbit": () => __vitePreload(() => import("./orbit-CU76gnWA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1000,1]) : void 0),
    "origami": () => __vitePreload(() => import("./origami-AtKW2ceJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1001,1]) : void 0),
    "package-2": () => __vitePreload(() => import("./package-2-DIHkJm1n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1002,1]) : void 0),
    "package-check": () => __vitePreload(() => import("./package-check-qEH7axoU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1003,1]) : void 0),
    "package-minus": () => __vitePreload(() => import("./package-minus-DO-uimoe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1004,1]) : void 0),
    "package-open": () => __vitePreload(() => import("./package-open-DTdGIXoO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1005,1]) : void 0),
    "package-plus": () => __vitePreload(() => import("./package-plus-BtTdXrry.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1006,1]) : void 0),
    "package-search": () => __vitePreload(() => import("./package-search-CjX5B37h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1007,1]) : void 0),
    "package-x": () => __vitePreload(() => import("./package-x-ByCaae86.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1008,1]) : void 0),
    "package": () => __vitePreload(() => import("./package-B23X1pqr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1009,1]) : void 0),
    "paint-bucket": () => __vitePreload(() => import("./paint-bucket-B_ORouV0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1010,1]) : void 0),
    "paint-roller": () => __vitePreload(() => import("./paint-roller-CAj2TAXd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1011,1]) : void 0),
    "paintbrush-vertical": () => __vitePreload(() => import("./paintbrush-vertical-B6PHr8F9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1012,1]) : void 0),
    "paintbrush": () => __vitePreload(() => import("./paintbrush-D5h8VB6T.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1013,1]) : void 0),
    "palette": () => __vitePreload(() => import("./palette-B6ad8QQx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1014,1]) : void 0),
    "panel-bottom-close": () => __vitePreload(() => import("./panel-bottom-close-xFGVFeSJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1015,1]) : void 0),
    "panel-bottom-dashed": () => __vitePreload(() => import("./panel-bottom-dashed-B7EPFkVK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1016,1]) : void 0),
    "panel-bottom-open": () => __vitePreload(() => import("./panel-bottom-open-CO6JfQda.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1017,1]) : void 0),
    "panel-bottom": () => __vitePreload(() => import("./panel-bottom-BO4_Xyon.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1018,1]) : void 0),
    "panel-left-close": () => __vitePreload(() => import("./panel-left-close-DwPT2lCx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1019,1]) : void 0),
    "panel-left-dashed": () => __vitePreload(() => import("./panel-left-dashed-DLir9UTb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1020,1]) : void 0),
    "panel-left-open": () => __vitePreload(() => import("./panel-left-open-DJSbSPLo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1021,1]) : void 0),
    "panel-left": () => __vitePreload(() => import("./panel-left-loUv7Vd6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1022,1]) : void 0),
    "panel-right-close": () => __vitePreload(() => import("./panel-right-close-CWQbCFzP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1023,1]) : void 0),
    "panel-right-dashed": () => __vitePreload(() => import("./panel-right-dashed-BWdV10G5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1024,1]) : void 0),
    "panel-right-open": () => __vitePreload(() => import("./panel-right-open-Cbn6BCeY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1025,1]) : void 0),
    "panel-right": () => __vitePreload(() => import("./panel-right-DyzdYwhU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1026,1]) : void 0),
    "panel-top-close": () => __vitePreload(() => import("./panel-top-close-CQvukO6H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1027,1]) : void 0),
    "panel-top-dashed": () => __vitePreload(() => import("./panel-top-dashed-Dv3tKlr7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1028,1]) : void 0),
    "panel-top-open": () => __vitePreload(() => import("./panel-top-open-DCt8duqA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1029,1]) : void 0),
    "panel-top": () => __vitePreload(() => import("./panel-top-DdlYn9q2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1030,1]) : void 0),
    "panels-left-bottom": () => __vitePreload(() => import("./panels-left-bottom-bvphh8Gv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1031,1]) : void 0),
    "panels-right-bottom": () => __vitePreload(() => import("./panels-right-bottom-kSo32rfl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1032,1]) : void 0),
    "panels-top-left": () => __vitePreload(() => import("./panels-top-left-BmRp2hoA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1033,1]) : void 0),
    "paperclip": () => __vitePreload(() => import("./paperclip-DTrwIVa5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1034,1]) : void 0),
    "parentheses": () => __vitePreload(() => import("./parentheses-EYq3N4R2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1035,1]) : void 0),
    "parking-meter": () => __vitePreload(() => import("./parking-meter-B0ix1MKr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1036,1]) : void 0),
    "party-popper": () => __vitePreload(() => import("./party-popper-DdK7f71h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1037,1]) : void 0),
    "pause": () => __vitePreload(() => import("./pause-C4MN17wa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1038,1]) : void 0),
    "paw-print": () => __vitePreload(() => import("./paw-print-fp31Thu_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1039,1]) : void 0),
    "pc-case": () => __vitePreload(() => import("./pc-case-CEJp-fy8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1040,1]) : void 0),
    "pen-line": () => __vitePreload(() => import("./pen-line-BD7ohWoN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1041,1]) : void 0),
    "pen-off": () => __vitePreload(() => import("./pen-off-Du145n-Z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1042,1]) : void 0),
    "pen-tool": () => __vitePreload(() => import("./pen-tool-BEoq8Fmc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1043,1]) : void 0),
    "pen": () => __vitePreload(() => import("./pen-DyLZYDtG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1044,1]) : void 0),
    "pencil-line": () => __vitePreload(() => import("./pencil-line-DEr_fcMI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1045,1]) : void 0),
    "pencil-off": () => __vitePreload(() => import("./pencil-off-BX2Ga3mO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1046,1]) : void 0),
    "pencil-ruler": () => __vitePreload(() => import("./pencil-ruler-BGygN75R.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1047,1]) : void 0),
    "pencil": () => __vitePreload(() => import("./pencil-mNw5-cto.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1048,1]) : void 0),
    "pentagon": () => __vitePreload(() => import("./pentagon-D7VacO7s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1049,1]) : void 0),
    "percent": () => __vitePreload(() => import("./percent-Cs5Mx4D7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1050,1]) : void 0),
    "person-standing": () => __vitePreload(() => import("./person-standing-DiFOuDw4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1051,1]) : void 0),
    "philippine-peso": () => __vitePreload(() => import("./philippine-peso-De9Fc_nb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1052,1]) : void 0),
    "phone-call": () => __vitePreload(() => import("./phone-call-CUZcXul5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1053,1]) : void 0),
    "phone-forwarded": () => __vitePreload(() => import("./phone-forwarded-BPTER9Kj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1054,1]) : void 0),
    "phone-incoming": () => __vitePreload(() => import("./phone-incoming-Dt73X6Ro.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1055,1]) : void 0),
    "phone-missed": () => __vitePreload(() => import("./phone-missed-DpmoWUXc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1056,1]) : void 0),
    "phone-off": () => __vitePreload(() => import("./phone-off-CTCTWzhd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1057,1]) : void 0),
    "phone-outgoing": () => __vitePreload(() => import("./phone-outgoing-CV7XHRJa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1058,1]) : void 0),
    "phone": () => __vitePreload(() => import("./phone-BBktAOZk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1059,1]) : void 0),
    "pi": () => __vitePreload(() => import("./pi-BFZw3Ta7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1060,1]) : void 0),
    "piano": () => __vitePreload(() => import("./piano-B3iwXZ86.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1061,1]) : void 0),
    "pickaxe": () => __vitePreload(() => import("./pickaxe-BsYYRGKS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1062,1]) : void 0),
    "picture-in-picture-2": () => __vitePreload(() => import("./picture-in-picture-2-CgzAH1TL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1063,1]) : void 0),
    "picture-in-picture": () => __vitePreload(() => import("./picture-in-picture-aTIXojGe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1064,1]) : void 0),
    "piggy-bank": () => __vitePreload(() => import("./piggy-bank-7hBufohM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1065,1]) : void 0),
    "pilcrow-left": () => __vitePreload(() => import("./pilcrow-left-0SUEvJ-5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1066,1]) : void 0),
    "pilcrow-right": () => __vitePreload(() => import("./pilcrow-right-Dlx1eeq6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1067,1]) : void 0),
    "pilcrow": () => __vitePreload(() => import("./pilcrow-kPd6D4Ed.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1068,1]) : void 0),
    "pill-bottle": () => __vitePreload(() => import("./pill-bottle-Cmg8Oyok.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1069,1]) : void 0),
    "pill": () => __vitePreload(() => import("./pill-DCZU1IQ7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1070,1]) : void 0),
    "pin-off": () => __vitePreload(() => import("./pin-off-cShDVekk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1071,1]) : void 0),
    "pin": () => __vitePreload(() => import("./pin-CR8nHAd7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1072,1]) : void 0),
    "pipette": () => __vitePreload(() => import("./pipette--kucMh3_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1073,1]) : void 0),
    "pizza": () => __vitePreload(() => import("./pizza-08-bm5Ze.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1074,1]) : void 0),
    "plane-landing": () => __vitePreload(() => import("./plane-landing-COFJdI_1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1075,1]) : void 0),
    "plane-takeoff": () => __vitePreload(() => import("./plane-takeoff-DbOyu5ZP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1076,1]) : void 0),
    "plane": () => __vitePreload(() => import("./plane-DKHhxME8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1077,1]) : void 0),
    "play": () => __vitePreload(() => import("./play-D_NhYIlD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1078,1]) : void 0),
    "plug-2": () => __vitePreload(() => import("./plug-2-B4qZfvCY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1079,1]) : void 0),
    "plug-zap": () => __vitePreload(() => import("./plug-zap-C7Ex6xsf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1080,1]) : void 0),
    "plug": () => __vitePreload(() => import("./plug-CM1g-vIF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1081,1]) : void 0),
    "plus": () => __vitePreload(() => import("./plus-DdseC9r5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1082,1]) : void 0),
    "pocket-knife": () => __vitePreload(() => import("./pocket-knife-S1p-1HJI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1083,1]) : void 0),
    "pocket": () => __vitePreload(() => import("./pocket-DTzAVvHn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1084,1]) : void 0),
    "podcast": () => __vitePreload(() => import("./podcast-CIGU_kOy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1085,1]) : void 0),
    "pointer-off": () => __vitePreload(() => import("./pointer-off-BcVPcgCZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1086,1]) : void 0),
    "pointer": () => __vitePreload(() => import("./pointer-C2yg_2MO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1087,1]) : void 0),
    "popcorn": () => __vitePreload(() => import("./popcorn-BBhfI42E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1088,1]) : void 0),
    "popsicle": () => __vitePreload(() => import("./popsicle-C-7P5p2m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1089,1]) : void 0),
    "pound-sterling": () => __vitePreload(() => import("./pound-sterling-DSwWW3MW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1090,1]) : void 0),
    "power-off": () => __vitePreload(() => import("./power-off-PIzIxR8y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1091,1]) : void 0),
    "power": () => __vitePreload(() => import("./power-SoPH6jGM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1092,1]) : void 0),
    "presentation": () => __vitePreload(() => import("./presentation-DiBafRCu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1093,1]) : void 0),
    "printer-check": () => __vitePreload(() => import("./printer-check-BUo7-q96.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1094,1]) : void 0),
    "printer": () => __vitePreload(() => import("./printer-I6rGxyj5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1095,1]) : void 0),
    "projector": () => __vitePreload(() => import("./projector-DOX5ya_Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1096,1]) : void 0),
    "proportions": () => __vitePreload(() => import("./proportions-DKBGEGxm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1097,1]) : void 0),
    "puzzle": () => __vitePreload(() => import("./puzzle-DfKEzeGe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1098,1]) : void 0),
    "pyramid": () => __vitePreload(() => import("./pyramid-Dif-fsvN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1099,1]) : void 0),
    "qr-code": () => __vitePreload(() => import("./qr-code-BQw69i46.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1100,1]) : void 0),
    "quote": () => __vitePreload(() => import("./quote-ClRi4mcN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1101,1]) : void 0),
    "rabbit": () => __vitePreload(() => import("./rabbit-fR2eVFqu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1102,1]) : void 0),
    "radar": () => __vitePreload(() => import("./radar-BfDQ7VLq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1103,1]) : void 0),
    "radiation": () => __vitePreload(() => import("./radiation-d_SV23a6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1104,1]) : void 0),
    "radical": () => __vitePreload(() => import("./radical-DhEWwG69.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1105,1]) : void 0),
    "radio-receiver": () => __vitePreload(() => import("./radio-receiver-C0OMzSkb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1106,1]) : void 0),
    "radio-tower": () => __vitePreload(() => import("./radio-tower-BUomHJOX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1107,1]) : void 0),
    "radio": () => __vitePreload(() => import("./radio-Cg8IMAd0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1108,1]) : void 0),
    "radius": () => __vitePreload(() => import("./radius-JHpnhlNH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1109,1]) : void 0),
    "rail-symbol": () => __vitePreload(() => import("./rail-symbol-CWvdZ5-Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1110,1]) : void 0),
    "rainbow": () => __vitePreload(() => import("./rainbow-4rsuNdH9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1111,1]) : void 0),
    "rat": () => __vitePreload(() => import("./rat-Dkld-KTM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1112,1]) : void 0),
    "ratio": () => __vitePreload(() => import("./ratio-BUJ8wjNY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1113,1]) : void 0),
    "receipt-cent": () => __vitePreload(() => import("./receipt-cent-Dph2tbE5.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1114,1]) : void 0),
    "receipt-euro": () => __vitePreload(() => import("./receipt-euro-C0IwpLkt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1115,1]) : void 0),
    "receipt-indian-rupee": () => __vitePreload(() => import("./receipt-indian-rupee-Bl8pw0vU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1116,1]) : void 0),
    "receipt-japanese-yen": () => __vitePreload(() => import("./receipt-japanese-yen-BfS89qEg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1117,1]) : void 0),
    "receipt-pound-sterling": () => __vitePreload(() => import("./receipt-pound-sterling-CiBIBOUe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1118,1]) : void 0),
    "receipt-russian-ruble": () => __vitePreload(() => import("./receipt-russian-ruble-BlDAiyFf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1119,1]) : void 0),
    "receipt-swiss-franc": () => __vitePreload(() => import("./receipt-swiss-franc-CjhYzp8H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1120,1]) : void 0),
    "receipt-text": () => __vitePreload(() => import("./receipt-text-buK2KDmS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1121,1]) : void 0),
    "receipt": () => __vitePreload(() => import("./receipt-BnHuE4bU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1122,1]) : void 0),
    "rectangle-ellipsis": () => __vitePreload(() => import("./rectangle-ellipsis-DFlwkpEa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1123,1]) : void 0),
    "rectangle-horizontal": () => __vitePreload(() => import("./rectangle-horizontal-DzRXuK8l.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1124,1]) : void 0),
    "rectangle-vertical": () => __vitePreload(() => import("./rectangle-vertical-BXCWDtEA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1125,1]) : void 0),
    "recycle": () => __vitePreload(() => import("./recycle-BR1JdXwE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1126,1]) : void 0),
    "redo-2": () => __vitePreload(() => import("./redo-2-CqxerChX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1127,1]) : void 0),
    "redo-dot": () => __vitePreload(() => import("./redo-dot-CJ3Jo1xQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1128,1]) : void 0),
    "redo": () => __vitePreload(() => import("./redo-DlwdCVfl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1129,1]) : void 0),
    "refresh-ccw-dot": () => __vitePreload(() => import("./refresh-ccw-dot-BDOwumzo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1130,1]) : void 0),
    "refresh-ccw": () => __vitePreload(() => import("./refresh-ccw-m-iSj44n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1131,1]) : void 0),
    "refresh-cw-off": () => __vitePreload(() => import("./refresh-cw-off-DaPPzhwQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1132,1]) : void 0),
    "refresh-cw": () => __vitePreload(() => import("./refresh-cw-DcoCnemg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1133,1]) : void 0),
    "refrigerator": () => __vitePreload(() => import("./refrigerator-MrxcQW3Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1134,1]) : void 0),
    "regex": () => __vitePreload(() => import("./regex-DjdIAFzO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1135,1]) : void 0),
    "remove-formatting": () => __vitePreload(() => import("./remove-formatting-BwrNAjeG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1136,1]) : void 0),
    "repeat-1": () => __vitePreload(() => import("./repeat-1-BqGhH8X_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1137,1]) : void 0),
    "repeat-2": () => __vitePreload(() => import("./repeat-2-CKmA8z6-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1138,1]) : void 0),
    "repeat": () => __vitePreload(() => import("./repeat-DgzCzclY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1139,1]) : void 0),
    "replace-all": () => __vitePreload(() => import("./replace-all-BHGqvSSQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1140,1]) : void 0),
    "replace": () => __vitePreload(() => import("./replace-CDr8_n98.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1141,1]) : void 0),
    "reply-all": () => __vitePreload(() => import("./reply-all-BO2Og2YK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1142,1]) : void 0),
    "reply": () => __vitePreload(() => import("./reply-ZqIESeto.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1143,1]) : void 0),
    "rewind": () => __vitePreload(() => import("./rewind-DfNr5M-P.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1144,1]) : void 0),
    "ribbon": () => __vitePreload(() => import("./ribbon-CDBtDSS3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1145,1]) : void 0),
    "rocket": () => __vitePreload(() => import("./rocket-CfH-1Pdv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1146,1]) : void 0),
    "rocking-chair": () => __vitePreload(() => import("./rocking-chair-C1XMWFHk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1147,1]) : void 0),
    "roller-coaster": () => __vitePreload(() => import("./roller-coaster-BttcDROq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1148,1]) : void 0),
    "rotate-3d": () => __vitePreload(() => import("./rotate-3d-gNIQemtN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1149,1]) : void 0),
    "rotate-ccw-square": () => __vitePreload(() => import("./rotate-ccw-square-BCVyZvmp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1150,1]) : void 0),
    "rotate-ccw": () => __vitePreload(() => import("./rotate-ccw-dlLNXhoE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1151,1]) : void 0),
    "rotate-cw-square": () => __vitePreload(() => import("./rotate-cw-square-DOlRKlj3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1152,1]) : void 0),
    "rotate-cw": () => __vitePreload(() => import("./rotate-cw-BGT2m2PK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1153,1]) : void 0),
    "route-off": () => __vitePreload(() => import("./route-off-uZqL7aqb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1154,1]) : void 0),
    "route": () => __vitePreload(() => import("./route-Bha1ydGC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1155,1]) : void 0),
    "router": () => __vitePreload(() => import("./router-B-ah6UNW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1156,1]) : void 0),
    "rows-2": () => __vitePreload(() => import("./rows-2-Gb7LyExn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1157,1]) : void 0),
    "rows-3": () => __vitePreload(() => import("./rows-3-DCq-h-3o.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1158,1]) : void 0),
    "rows-4": () => __vitePreload(() => import("./rows-4-DQr9t05I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1159,1]) : void 0),
    "rss": () => __vitePreload(() => import("./rss-CgYj3RbE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1160,1]) : void 0),
    "ruler": () => __vitePreload(() => import("./ruler-ckbz8_sd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1161,1]) : void 0),
    "russian-ruble": () => __vitePreload(() => import("./russian-ruble-Bmb98CW_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1162,1]) : void 0),
    "sailboat": () => __vitePreload(() => import("./sailboat-CzlpzFxb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1163,1]) : void 0),
    "salad": () => __vitePreload(() => import("./salad-D9FsYhRj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1164,1]) : void 0),
    "sandwich": () => __vitePreload(() => import("./sandwich-D7UvkHlN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1165,1]) : void 0),
    "satellite-dish": () => __vitePreload(() => import("./satellite-dish-Cz3DEYfg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1166,1]) : void 0),
    "satellite": () => __vitePreload(() => import("./satellite-DOYutYf3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1167,1]) : void 0),
    "save-all": () => __vitePreload(() => import("./save-all-CgWKrGvP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1168,1]) : void 0),
    "save-off": () => __vitePreload(() => import("./save-off-CXI1vqEk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1169,1]) : void 0),
    "save": () => __vitePreload(() => import("./save-CQmp2_y9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1170,1]) : void 0),
    "scale-3d": () => __vitePreload(() => import("./scale-3d-BcL4wqCe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1171,1]) : void 0),
    "scale": () => __vitePreload(() => import("./scale-ChlwlE_u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1172,1]) : void 0),
    "scaling": () => __vitePreload(() => import("./scaling-BJGY6hZ_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1173,1]) : void 0),
    "scan-barcode": () => __vitePreload(() => import("./scan-barcode-CRF7suI2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1174,1]) : void 0),
    "scan-eye": () => __vitePreload(() => import("./scan-eye-Btm_rTkN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1175,1]) : void 0),
    "scan-face": () => __vitePreload(() => import("./scan-face-DUTFib9B.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1176,1]) : void 0),
    "scan-line": () => __vitePreload(() => import("./scan-line-BRDDiAWJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1177,1]) : void 0),
    "scan-qr-code": () => __vitePreload(() => import("./scan-qr-code-CuOQt2JT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1178,1]) : void 0),
    "scan-search": () => __vitePreload(() => import("./scan-search-n6k4Vj3s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1179,1]) : void 0),
    "scan-text": () => __vitePreload(() => import("./scan-text-ClPXusip.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1180,1]) : void 0),
    "scan": () => __vitePreload(() => import("./scan-a_3coLTF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1181,1]) : void 0),
    "school": () => __vitePreload(() => import("./school-Cwy27akY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1182,1]) : void 0),
    "scissors-line-dashed": () => __vitePreload(() => import("./scissors-line-dashed-DknQhmHn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1183,1]) : void 0),
    "scissors": () => __vitePreload(() => import("./scissors-BP1zqW-v.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1184,1]) : void 0),
    "screen-share-off": () => __vitePreload(() => import("./screen-share-off-VX-Yxil8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1185,1]) : void 0),
    "screen-share": () => __vitePreload(() => import("./screen-share-4M0uPEog.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1186,1]) : void 0),
    "scroll-text": () => __vitePreload(() => import("./scroll-text-DLBbOjQt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1187,1]) : void 0),
    "scroll": () => __vitePreload(() => import("./scroll-BA7q5dKi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1188,1]) : void 0),
    "search-check": () => __vitePreload(() => import("./search-check-u0fwMgrS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1189,1]) : void 0),
    "search-code": () => __vitePreload(() => import("./search-code-xbGLOexC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1190,1]) : void 0),
    "search-slash": () => __vitePreload(() => import("./search-slash-DH4Qe4Mu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1191,1]) : void 0),
    "search-x": () => __vitePreload(() => import("./search-x-dTEhVEJz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1192,1]) : void 0),
    "search": () => __vitePreload(() => import("./search-D7kIVwe-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1193,1]) : void 0),
    "section": () => __vitePreload(() => import("./section-B_T-AgzR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1194,1]) : void 0),
    "send-horizontal": () => __vitePreload(() => import("./send-horizontal-DHhkqEfh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1195,1]) : void 0),
    "send-to-back": () => __vitePreload(() => import("./send-to-back-CSNcgYfK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1196,1]) : void 0),
    "send": () => __vitePreload(() => import("./send-D_NN200H.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1197,1]) : void 0),
    "separator-horizontal": () => __vitePreload(() => import("./separator-horizontal-gRpYracC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1198,1]) : void 0),
    "separator-vertical": () => __vitePreload(() => import("./separator-vertical-CTV85Vld.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1199,1]) : void 0),
    "server-cog": () => __vitePreload(() => import("./server-cog-DrN-050Z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1200,1]) : void 0),
    "server-crash": () => __vitePreload(() => import("./server-crash-BzEZ--D2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1201,1]) : void 0),
    "server-off": () => __vitePreload(() => import("./server-off-CHZSjDHB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1202,1]) : void 0),
    "server": () => __vitePreload(() => import("./server-C39xl1us.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1203,1]) : void 0),
    "settings-2": () => __vitePreload(() => import("./settings-2-CyFNhmUK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1204,1]) : void 0),
    "settings": () => __vitePreload(() => import("./settings-Igo5nVNu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1205,1]) : void 0),
    "shapes": () => __vitePreload(() => import("./shapes-Rnu6oGyW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1206,1]) : void 0),
    "share-2": () => __vitePreload(() => import("./share-2-DTpQ1v0V.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1207,1]) : void 0),
    "share": () => __vitePreload(() => import("./share-D7aLU9h_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1208,1]) : void 0),
    "sheet": () => __vitePreload(() => import("./sheet-CIea-_0m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1209,1]) : void 0),
    "shell": () => __vitePreload(() => import("./shell-y36qaomb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1210,1]) : void 0),
    "shield-alert": () => __vitePreload(() => import("./shield-alert-BvjCtV-3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1211,1]) : void 0),
    "shield-ban": () => __vitePreload(() => import("./shield-ban-DaTUzHSj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1212,1]) : void 0),
    "shield-check": () => __vitePreload(() => import("./shield-check-CIwmwzhP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1213,1]) : void 0),
    "shield-ellipsis": () => __vitePreload(() => import("./shield-ellipsis-CooR3ETR.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1214,1]) : void 0),
    "shield-half": () => __vitePreload(() => import("./shield-half-D7nNtye0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1215,1]) : void 0),
    "shield-minus": () => __vitePreload(() => import("./shield-minus-HnBpDVRS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1216,1]) : void 0),
    "shield-off": () => __vitePreload(() => import("./shield-off-BD2awVfF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1217,1]) : void 0),
    "shield-plus": () => __vitePreload(() => import("./shield-plus-eb2mQ7gD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1218,1]) : void 0),
    "shield-question": () => __vitePreload(() => import("./shield-question-BC89YmtW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1219,1]) : void 0),
    "shield-x": () => __vitePreload(() => import("./shield-x-DaXcARRg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1220,1]) : void 0),
    "shield": () => __vitePreload(() => import("./shield-MWSYE9vy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1221,1]) : void 0),
    "ship-wheel": () => __vitePreload(() => import("./ship-wheel-D6VgGPjj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1222,1]) : void 0),
    "ship": () => __vitePreload(() => import("./ship-D6M-QmgW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1223,1]) : void 0),
    "shirt": () => __vitePreload(() => import("./shirt-EUG1z6Ds.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1224,1]) : void 0),
    "shopping-bag": () => __vitePreload(() => import("./shopping-bag-BQxhT18V.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1225,1]) : void 0),
    "shopping-basket": () => __vitePreload(() => import("./shopping-basket-DlUvCqzu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1226,1]) : void 0),
    "shopping-cart": () => __vitePreload(() => import("./shopping-cart-DaNr8Jpj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1227,1]) : void 0),
    "shovel": () => __vitePreload(() => import("./shovel-CP8luLfc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1228,1]) : void 0),
    "shower-head": () => __vitePreload(() => import("./shower-head-DWxfzGNX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1229,1]) : void 0),
    "shrink": () => __vitePreload(() => import("./shrink-DKiJRirJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1230,1]) : void 0),
    "shrub": () => __vitePreload(() => import("./shrub-a7Ugbo1n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1231,1]) : void 0),
    "shuffle": () => __vitePreload(() => import("./shuffle-WasQYWHk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1232,1]) : void 0),
    "sigma": () => __vitePreload(() => import("./sigma-B6HPCbDK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1233,1]) : void 0),
    "signal-high": () => __vitePreload(() => import("./signal-high-CQBhrN7w.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1234,1]) : void 0),
    "signal-low": () => __vitePreload(() => import("./signal-low-d7YXFVH8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1235,1]) : void 0),
    "signal-medium": () => __vitePreload(() => import("./signal-medium-B0YyHXY9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1236,1]) : void 0),
    "signal-zero": () => __vitePreload(() => import("./signal-zero-DEdolONL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1237,1]) : void 0),
    "signal": () => __vitePreload(() => import("./signal-CyyObhgV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1238,1]) : void 0),
    "signature": () => __vitePreload(() => import("./signature-RU8DJd5b.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1239,1]) : void 0),
    "signpost-big": () => __vitePreload(() => import("./signpost-big-CyNP0Pui.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1240,1]) : void 0),
    "signpost": () => __vitePreload(() => import("./signpost-B_7Nnsm3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1241,1]) : void 0),
    "siren": () => __vitePreload(() => import("./siren-Bc76eztt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1242,1]) : void 0),
    "skip-back": () => __vitePreload(() => import("./skip-back-BmWAFLrx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1243,1]) : void 0),
    "skip-forward": () => __vitePreload(() => import("./skip-forward-0iAwImod.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1244,1]) : void 0),
    "skull": () => __vitePreload(() => import("./skull-_Hp61ud-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1245,1]) : void 0),
    "slack": () => __vitePreload(() => import("./slack-BdmnCi1c.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1246,1]) : void 0),
    "slash": () => __vitePreload(() => import("./slash-DI57qHyh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1247,1]) : void 0),
    "slice": () => __vitePreload(() => import("./slice--Q7XcU0g.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1248,1]) : void 0),
    "sliders-horizontal": () => __vitePreload(() => import("./sliders-horizontal-CClgq_H8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1249,1]) : void 0),
    "sliders-vertical": () => __vitePreload(() => import("./sliders-vertical-D9SzdZRU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1250,1]) : void 0),
    "smartphone-charging": () => __vitePreload(() => import("./smartphone-charging-UmBc35R6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1251,1]) : void 0),
    "smartphone-nfc": () => __vitePreload(() => import("./smartphone-nfc-DUl95Pi9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1252,1]) : void 0),
    "smartphone": () => __vitePreload(() => import("./smartphone-DIa2EHTr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1253,1]) : void 0),
    "smile-plus": () => __vitePreload(() => import("./smile-plus-DneNZl4k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1254,1]) : void 0),
    "smile": () => __vitePreload(() => import("./smile-B_vUcJ7Z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1255,1]) : void 0),
    "snail": () => __vitePreload(() => import("./snail-CrtHsjGE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1256,1]) : void 0),
    "snowflake": () => __vitePreload(() => import("./snowflake-XCqQ3KtC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1257,1]) : void 0),
    "sofa": () => __vitePreload(() => import("./sofa-BQWDMmhz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1258,1]) : void 0),
    "soup": () => __vitePreload(() => import("./soup-Ddk2N7g3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1259,1]) : void 0),
    "space": () => __vitePreload(() => import("./space-DgiPm8Oa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1260,1]) : void 0),
    "spade": () => __vitePreload(() => import("./spade-L2bFjZqI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1261,1]) : void 0),
    "sparkle": () => __vitePreload(() => import("./sparkle-BMFZMYYT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1262,1]) : void 0),
    "sparkles": () => __vitePreload(() => import("./sparkles-eoNyNVVU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1263,1]) : void 0),
    "speaker": () => __vitePreload(() => import("./speaker-2oagIJaQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1264,1]) : void 0),
    "speech": () => __vitePreload(() => import("./speech-DDc28of2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1265,1]) : void 0),
    "spell-check-2": () => __vitePreload(() => import("./spell-check-2-_ObA9_kC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1266,1]) : void 0),
    "spell-check": () => __vitePreload(() => import("./spell-check-DNiHoAgH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1267,1]) : void 0),
    "spline": () => __vitePreload(() => import("./spline-DiJmrV3J.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1268,1]) : void 0),
    "split": () => __vitePreload(() => import("./split-7aAkzmHE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1269,1]) : void 0),
    "spray-can": () => __vitePreload(() => import("./spray-can-CWOey69j.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1270,1]) : void 0),
    "sprout": () => __vitePreload(() => import("./sprout-DBNvP83W.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1271,1]) : void 0),
    "square-activity": () => __vitePreload(() => import("./square-activity-gQrFMEG2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1272,1]) : void 0),
    "square-arrow-down-left": () => __vitePreload(() => import("./square-arrow-down-left-CqX_QNzf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1273,1]) : void 0),
    "square-arrow-down-right": () => __vitePreload(() => import("./square-arrow-down-right-8xJgNHEg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1274,1]) : void 0),
    "square-arrow-down": () => __vitePreload(() => import("./square-arrow-down-LSLCLiUd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1275,1]) : void 0),
    "square-arrow-left": () => __vitePreload(() => import("./square-arrow-left-3tHsVxgU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1276,1]) : void 0),
    "square-arrow-out-down-left": () => __vitePreload(() => import("./square-arrow-out-down-left-B3hQ0tjP.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1277,1]) : void 0),
    "square-arrow-out-down-right": () => __vitePreload(() => import("./square-arrow-out-down-right-CUQgCv6k.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1278,1]) : void 0),
    "square-arrow-out-up-left": () => __vitePreload(() => import("./square-arrow-out-up-left-B9V0B1G6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1279,1]) : void 0),
    "square-arrow-out-up-right": () => __vitePreload(() => import("./square-arrow-out-up-right-B29qUG4v.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1280,1]) : void 0),
    "square-arrow-right": () => __vitePreload(() => import("./square-arrow-right-DPObgVre.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1281,1]) : void 0),
    "square-arrow-up-left": () => __vitePreload(() => import("./square-arrow-up-left-1pivciRb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1282,1]) : void 0),
    "square-arrow-up-right": () => __vitePreload(() => import("./square-arrow-up-right-BeqSRHC_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1283,1]) : void 0),
    "square-arrow-up": () => __vitePreload(() => import("./square-arrow-up-DdOiaA9n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1284,1]) : void 0),
    "square-asterisk": () => __vitePreload(() => import("./square-asterisk-BVyrbWhp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1285,1]) : void 0),
    "square-bottom-dashed-scissors": () => __vitePreload(() => import("./square-bottom-dashed-scissors-4ZJj5OAB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1286,1]) : void 0),
    "square-chart-gantt": () => __vitePreload(() => import("./square-chart-gantt-BBP5Rhul.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1287,1]) : void 0),
    "square-check-big": () => __vitePreload(() => import("./square-check-big-BcjoS5Rd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1288,1]) : void 0),
    "square-check": () => __vitePreload(() => import("./square-check-PD_f3nl3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1289,1]) : void 0),
    "square-chevron-down": () => __vitePreload(() => import("./square-chevron-down-BNxX5su0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1290,1]) : void 0),
    "square-chevron-left": () => __vitePreload(() => import("./square-chevron-left-IvCoJagi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1291,1]) : void 0),
    "square-chevron-right": () => __vitePreload(() => import("./square-chevron-right-C9uwPMis.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1292,1]) : void 0),
    "square-chevron-up": () => __vitePreload(() => import("./square-chevron-up-B4seHv3o.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1293,1]) : void 0),
    "square-code": () => __vitePreload(() => import("./square-code-BoYxP1b7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1294,1]) : void 0),
    "square-dashed-bottom-code": () => __vitePreload(() => import("./square-dashed-bottom-code-Cd_8XsIn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1295,1]) : void 0),
    "square-dashed-bottom": () => __vitePreload(() => import("./square-dashed-bottom-D5eln0Sk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1296,1]) : void 0),
    "square-dashed-kanban": () => __vitePreload(() => import("./square-dashed-kanban-ytDzaWjh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1297,1]) : void 0),
    "square-dashed-mouse-pointer": () => __vitePreload(() => import("./square-dashed-mouse-pointer-CouRobeI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1298,1]) : void 0),
    "square-dashed": () => __vitePreload(() => import("./square-dashed-halOijye.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1299,1]) : void 0),
    "square-divide": () => __vitePreload(() => import("./square-divide-WfspL_sg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1300,1]) : void 0),
    "square-dot": () => __vitePreload(() => import("./square-dot-Brraj-FF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1301,1]) : void 0),
    "square-equal": () => __vitePreload(() => import("./square-equal-Dl43Gfaf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1302,1]) : void 0),
    "square-function": () => __vitePreload(() => import("./square-function-mTwROijF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1303,1]) : void 0),
    "square-kanban": () => __vitePreload(() => import("./square-kanban-DVt6wgJz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1304,1]) : void 0),
    "square-library": () => __vitePreload(() => import("./square-library-BwcIWdXt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1305,1]) : void 0),
    "square-m": () => __vitePreload(() => import("./square-m-vTGwrS5I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1306,1]) : void 0),
    "square-menu": () => __vitePreload(() => import("./square-menu-DwadlW8m.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1307,1]) : void 0),
    "square-minus": () => __vitePreload(() => import("./square-minus-BVaTU15E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1308,1]) : void 0),
    "square-mouse-pointer": () => __vitePreload(() => import("./square-mouse-pointer-W-J6H1Hs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1309,1]) : void 0),
    "square-parking-off": () => __vitePreload(() => import("./square-parking-off-CiMYu51E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1310,1]) : void 0),
    "square-parking": () => __vitePreload(() => import("./square-parking-CUyYOhB3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1311,1]) : void 0),
    "square-pen": () => __vitePreload(() => import("./square-pen-ms0ex5sg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1312,1]) : void 0),
    "square-percent": () => __vitePreload(() => import("./square-percent-DtA4A_q1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1313,1]) : void 0),
    "square-pi": () => __vitePreload(() => import("./square-pi-hNmOG1DO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1314,1]) : void 0),
    "square-pilcrow": () => __vitePreload(() => import("./square-pilcrow-rtk2griH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1315,1]) : void 0),
    "square-play": () => __vitePreload(() => import("./square-play-CUsyL8_A.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1316,1]) : void 0),
    "square-plus": () => __vitePreload(() => import("./square-plus-O2hJURg7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1317,1]) : void 0),
    "square-power": () => __vitePreload(() => import("./square-power-BcCYkEPJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1318,1]) : void 0),
    "square-radical": () => __vitePreload(() => import("./square-radical-DiRGELtg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1319,1]) : void 0),
    "square-scissors": () => __vitePreload(() => import("./square-scissors-VIqVCk7z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1320,1]) : void 0),
    "square-sigma": () => __vitePreload(() => import("./square-sigma-Dazz3gDW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1321,1]) : void 0),
    "square-slash": () => __vitePreload(() => import("./square-slash-CQ6P0hRD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1322,1]) : void 0),
    "square-split-horizontal": () => __vitePreload(() => import("./square-split-horizontal-CF6ZvRCl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1323,1]) : void 0),
    "square-split-vertical": () => __vitePreload(() => import("./square-split-vertical-dBU1Yq0M.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1324,1]) : void 0),
    "square-square": () => __vitePreload(() => import("./square-square-jUm5w1ts.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1325,1]) : void 0),
    "square-stack": () => __vitePreload(() => import("./square-stack-Ca3cmRAf.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1326,1]) : void 0),
    "square-terminal": () => __vitePreload(() => import("./square-terminal-DP9IOoNX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1327,1]) : void 0),
    "square-user-round": () => __vitePreload(() => import("./square-user-round-CkWr3nhq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1328,1]) : void 0),
    "square-user": () => __vitePreload(() => import("./square-user-B_ngBlXK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1329,1]) : void 0),
    "square-x": () => __vitePreload(() => import("./square-x-B-NlhqVC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1330,1]) : void 0),
    "square": () => __vitePreload(() => import("./square-G8fFihNl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1331,1]) : void 0),
    "squircle": () => __vitePreload(() => import("./squircle-B6U555mv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1332,1]) : void 0),
    "squirrel": () => __vitePreload(() => import("./squirrel-BiLSLaBl.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1333,1]) : void 0),
    "stamp": () => __vitePreload(() => import("./stamp-DJWERhGd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1334,1]) : void 0),
    "star-half": () => __vitePreload(() => import("./star-half-DsFGhZNb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1335,1]) : void 0),
    "star-off": () => __vitePreload(() => import("./star-off-tU3cePsJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1336,1]) : void 0),
    "star": () => __vitePreload(() => import("./star-BAcvdD03.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1337,1]) : void 0),
    "step-back": () => __vitePreload(() => import("./step-back-C8-g-_HY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1338,1]) : void 0),
    "step-forward": () => __vitePreload(() => import("./step-forward-Cxo4PMlE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1339,1]) : void 0),
    "stethoscope": () => __vitePreload(() => import("./stethoscope-BL-miX7j.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1340,1]) : void 0),
    "sticker": () => __vitePreload(() => import("./sticker-BgRsfVuB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1341,1]) : void 0),
    "sticky-note": () => __vitePreload(() => import("./sticky-note-B9NcfQeT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1342,1]) : void 0),
    "store": () => __vitePreload(() => import("./store-bYnhe7Ub.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1343,1]) : void 0),
    "stretch-horizontal": () => __vitePreload(() => import("./stretch-horizontal-DByumVN8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1344,1]) : void 0),
    "stretch-vertical": () => __vitePreload(() => import("./stretch-vertical-D1NvKFD_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1345,1]) : void 0),
    "strikethrough": () => __vitePreload(() => import("./strikethrough-DayVcgTC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1346,1]) : void 0),
    "subscript": () => __vitePreload(() => import("./subscript-eorZOsO7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1347,1]) : void 0),
    "sun-dim": () => __vitePreload(() => import("./sun-dim-QMilXKPF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1348,1]) : void 0),
    "sun-medium": () => __vitePreload(() => import("./sun-medium-Bc3zhD8I.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1349,1]) : void 0),
    "sun-moon": () => __vitePreload(() => import("./sun-moon-DvLzHA2J.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1350,1]) : void 0),
    "sun-snow": () => __vitePreload(() => import("./sun-snow-Bh8CqVQn.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1351,1]) : void 0),
    "sun": () => __vitePreload(() => import("./sun-Dpnwh54B.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1352,1]) : void 0),
    "sunrise": () => __vitePreload(() => import("./sunrise-DDyirxoi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1353,1]) : void 0),
    "sunset": () => __vitePreload(() => import("./sunset-C8f8zKUi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1354,1]) : void 0),
    "superscript": () => __vitePreload(() => import("./superscript-BWVgzB43.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1355,1]) : void 0),
    "swatch-book": () => __vitePreload(() => import("./swatch-book-BmVq5xZd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1356,1]) : void 0),
    "swiss-franc": () => __vitePreload(() => import("./swiss-franc-D8_WJ3AM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1357,1]) : void 0),
    "switch-camera": () => __vitePreload(() => import("./switch-camera-Bw6bJOKZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1358,1]) : void 0),
    "sword": () => __vitePreload(() => import("./sword-qGVJ95yX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1359,1]) : void 0),
    "swords": () => __vitePreload(() => import("./swords-DAHQYO2-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1360,1]) : void 0),
    "syringe": () => __vitePreload(() => import("./syringe-CTNloseQ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1361,1]) : void 0),
    "table-2": () => __vitePreload(() => import("./table-2-BVJYuouX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1362,1]) : void 0),
    "table-cells-merge": () => __vitePreload(() => import("./table-cells-merge-DjPJqNQJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1363,1]) : void 0),
    "table-cells-split": () => __vitePreload(() => import("./table-cells-split-CNPhkLIb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1364,1]) : void 0),
    "table-columns-split": () => __vitePreload(() => import("./table-columns-split-Cl99oK4F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1365,1]) : void 0),
    "table-of-contents": () => __vitePreload(() => import("./table-of-contents-BoxEFAQk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1366,1]) : void 0),
    "table-properties": () => __vitePreload(() => import("./table-properties-B3Jb8Pxh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1367,1]) : void 0),
    "table-rows-split": () => __vitePreload(() => import("./table-rows-split-BC1hYEl4.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1368,1]) : void 0),
    "table": () => __vitePreload(() => import("./table-CpUKu_ZV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1369,1]) : void 0),
    "tablet-smartphone": () => __vitePreload(() => import("./tablet-smartphone-BERKrMi_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1370,1]) : void 0),
    "tablet": () => __vitePreload(() => import("./tablet-DclAe-mA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1371,1]) : void 0),
    "tablets": () => __vitePreload(() => import("./tablets-C6n8Y-GV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1372,1]) : void 0),
    "tag": () => __vitePreload(() => import("./tag-BnzxZzwA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1373,1]) : void 0),
    "tags": () => __vitePreload(() => import("./tags-6ZV3g9qj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1374,1]) : void 0),
    "tally-1": () => __vitePreload(() => import("./tally-1-YoN-C1Ma.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1375,1]) : void 0),
    "tally-2": () => __vitePreload(() => import("./tally-2-rUyUar-U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1376,1]) : void 0),
    "tally-3": () => __vitePreload(() => import("./tally-3-CiOIP_t8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1377,1]) : void 0),
    "tally-4": () => __vitePreload(() => import("./tally-4-DlmrZLE-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1378,1]) : void 0),
    "tally-5": () => __vitePreload(() => import("./tally-5-Bt64oB0U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1379,1]) : void 0),
    "tangent": () => __vitePreload(() => import("./tangent-BLonAN9-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1380,1]) : void 0),
    "target": () => __vitePreload(() => import("./target-Jf3uYRGs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1381,1]) : void 0),
    "telescope": () => __vitePreload(() => import("./telescope-CJwDOiY0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1382,1]) : void 0),
    "tent-tree": () => __vitePreload(() => import("./tent-tree-L8pfNomW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1383,1]) : void 0),
    "tent": () => __vitePreload(() => import("./tent-CLtoLZ-6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1384,1]) : void 0),
    "terminal": () => __vitePreload(() => import("./terminal-Bo9kGstL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1385,1]) : void 0),
    "test-tube-diagonal": () => __vitePreload(() => import("./test-tube-diagonal-C9p-mmSV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1386,1]) : void 0),
    "test-tube": () => __vitePreload(() => import("./test-tube-DDwdbg2c.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1387,1]) : void 0),
    "test-tubes": () => __vitePreload(() => import("./test-tubes-Cfl6txr8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1388,1]) : void 0),
    "text-cursor-input": () => __vitePreload(() => import("./text-cursor-input-fy5a8JWd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1389,1]) : void 0),
    "text-cursor": () => __vitePreload(() => import("./text-cursor-C5OSW_L3.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1390,1]) : void 0),
    "text-quote": () => __vitePreload(() => import("./text-quote-B3nJNErB.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1391,1]) : void 0),
    "text-search": () => __vitePreload(() => import("./text-search-rwkPTprc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1392,1]) : void 0),
    "text-select": () => __vitePreload(() => import("./text-select-29ByFtUV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1393,1]) : void 0),
    "text": () => __vitePreload(() => import("./text-B1FQCLuI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1394,1]) : void 0),
    "theater": () => __vitePreload(() => import("./theater-BrxuhhjM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1395,1]) : void 0),
    "thermometer-snowflake": () => __vitePreload(() => import("./thermometer-snowflake-Bwd_8kQT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1396,1]) : void 0),
    "thermometer-sun": () => __vitePreload(() => import("./thermometer-sun-BD3zPKXo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1397,1]) : void 0),
    "thermometer": () => __vitePreload(() => import("./thermometer-DhbnTF6n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1398,1]) : void 0),
    "thumbs-down": () => __vitePreload(() => import("./thumbs-down-jRkSeQm9.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1399,1]) : void 0),
    "thumbs-up": () => __vitePreload(() => import("./thumbs-up-DVTbRajO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1400,1]) : void 0),
    "ticket-check": () => __vitePreload(() => import("./ticket-check-C-MjABMK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1401,1]) : void 0),
    "ticket-minus": () => __vitePreload(() => import("./ticket-minus-vcqRym4-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1402,1]) : void 0),
    "ticket-percent": () => __vitePreload(() => import("./ticket-percent-Bg9eOTqU.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1403,1]) : void 0),
    "ticket-plus": () => __vitePreload(() => import("./ticket-plus-C58-AMeL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1404,1]) : void 0),
    "ticket-slash": () => __vitePreload(() => import("./ticket-slash-Df_doMx-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1405,1]) : void 0),
    "ticket-x": () => __vitePreload(() => import("./ticket-x-qAhrnLSH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1406,1]) : void 0),
    "ticket": () => __vitePreload(() => import("./ticket-BtCHRW1w.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1407,1]) : void 0),
    "tickets-plane": () => __vitePreload(() => import("./tickets-plane-De4l0_uI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1408,1]) : void 0),
    "tickets": () => __vitePreload(() => import("./tickets-yzCd45O8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1409,1]) : void 0),
    "timer-off": () => __vitePreload(() => import("./timer-off-BUsGbyMo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1410,1]) : void 0),
    "timer-reset": () => __vitePreload(() => import("./timer-reset-BHBEc7hj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1411,1]) : void 0),
    "timer": () => __vitePreload(() => import("./timer-B8pL80RV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1412,1]) : void 0),
    "toggle-left": () => __vitePreload(() => import("./toggle-left-BGyezpc-.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1413,1]) : void 0),
    "toggle-right": () => __vitePreload(() => import("./toggle-right-DkPeQ00_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1414,1]) : void 0),
    "toilet": () => __vitePreload(() => import("./toilet-BczNxC4Z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1415,1]) : void 0),
    "tornado": () => __vitePreload(() => import("./tornado-DgL9vji6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1416,1]) : void 0),
    "torus": () => __vitePreload(() => import("./torus-C6dFsrxg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1417,1]) : void 0),
    "touchpad-off": () => __vitePreload(() => import("./touchpad-off-DVnSu-1i.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1418,1]) : void 0),
    "touchpad": () => __vitePreload(() => import("./touchpad-CmEgzXdi.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1419,1]) : void 0),
    "tower-control": () => __vitePreload(() => import("./tower-control-BNa5ze1a.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1420,1]) : void 0),
    "toy-brick": () => __vitePreload(() => import("./toy-brick-LhQMD0_A.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1421,1]) : void 0),
    "tractor": () => __vitePreload(() => import("./tractor-CUtgmh0N.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1422,1]) : void 0),
    "traffic-cone": () => __vitePreload(() => import("./traffic-cone-Cnfs4CcE.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1423,1]) : void 0),
    "train-front-tunnel": () => __vitePreload(() => import("./train-front-tunnel-C9-MTYmD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1424,1]) : void 0),
    "train-front": () => __vitePreload(() => import("./train-front-duwwm5fz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1425,1]) : void 0),
    "train-track": () => __vitePreload(() => import("./train-track-DkLNqi3s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1426,1]) : void 0),
    "tram-front": () => __vitePreload(() => import("./tram-front-DDQe4Dhg.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1427,1]) : void 0),
    "trash-2": () => __vitePreload(() => import("./trash-2-Cvu3sV6U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1428,1]) : void 0),
    "trash": () => __vitePreload(() => import("./trash-e4-QBa2z.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1429,1]) : void 0),
    "tree-deciduous": () => __vitePreload(() => import("./tree-deciduous-CLX5h-Cv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1430,1]) : void 0),
    "tree-palm": () => __vitePreload(() => import("./tree-palm-j9m5JhgC.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1431,1]) : void 0),
    "tree-pine": () => __vitePreload(() => import("./tree-pine-RHn7apto.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1432,1]) : void 0),
    "trees": () => __vitePreload(() => import("./trees-BJ4CkeCy.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1433,1]) : void 0),
    "trello": () => __vitePreload(() => import("./trello-Cqton4wv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1434,1]) : void 0),
    "trending-down": () => __vitePreload(() => import("./trending-down-CKIg3Wno.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1435,1]) : void 0),
    "trending-up-down": () => __vitePreload(() => import("./trending-up-down-B17Mx2ZH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1436,1]) : void 0),
    "trending-up": () => __vitePreload(() => import("./trending-up-CqBnXqTO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1437,1]) : void 0),
    "triangle-alert": () => __vitePreload(() => import("./triangle-alert-DR_raFRV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1438,1]) : void 0),
    "triangle-right": () => __vitePreload(() => import("./triangle-right-rQ0glFJk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1439,1]) : void 0),
    "triangle": () => __vitePreload(() => import("./triangle-D-iRNhVN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1440,1]) : void 0),
    "trophy": () => __vitePreload(() => import("./trophy-B_ASxF7d.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1441,1]) : void 0),
    "truck": () => __vitePreload(() => import("./truck-DW4IyorY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1442,1]) : void 0),
    "turtle": () => __vitePreload(() => import("./turtle-BheWkSbY.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1443,1]) : void 0),
    "tv-minimal-play": () => __vitePreload(() => import("./tv-minimal-play-D-qicCwZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1444,1]) : void 0),
    "tv-minimal": () => __vitePreload(() => import("./tv-minimal-2SvfjCob.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1445,1]) : void 0),
    "tv": () => __vitePreload(() => import("./tv-D9xjmg3O.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1446,1]) : void 0),
    "twitch": () => __vitePreload(() => import("./twitch-CDWHw0qr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1447,1]) : void 0),
    "twitter": () => __vitePreload(() => import("./twitter-DFiVOVu1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1448,1]) : void 0),
    "type-outline": () => __vitePreload(() => import("./type-outline-mbSDdi4F.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1449,1]) : void 0),
    "type": () => __vitePreload(() => import("./type-CvCBk2rb.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1450,1]) : void 0),
    "umbrella-off": () => __vitePreload(() => import("./umbrella-off-B5VEGPVv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1451,1]) : void 0),
    "umbrella": () => __vitePreload(() => import("./umbrella-CYhxF-Bu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1452,1]) : void 0),
    "underline": () => __vitePreload(() => import("./underline-C12XtC3U.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1453,1]) : void 0),
    "undo-2": () => __vitePreload(() => import("./undo-2-BSR3H55E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1454,1]) : void 0),
    "undo-dot": () => __vitePreload(() => import("./undo-dot-BjoV30fa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1455,1]) : void 0),
    "undo": () => __vitePreload(() => import("./undo-CuiHjOqa.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1456,1]) : void 0),
    "unfold-horizontal": () => __vitePreload(() => import("./unfold-horizontal-SjSsnkKJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1457,1]) : void 0),
    "unfold-vertical": () => __vitePreload(() => import("./unfold-vertical-DAGkSXNL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1458,1]) : void 0),
    "ungroup": () => __vitePreload(() => import("./ungroup-Cc2lnAQx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1459,1]) : void 0),
    "university": () => __vitePreload(() => import("./university-B-Jli3Ga.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1460,1]) : void 0),
    "unlink-2": () => __vitePreload(() => import("./unlink-2-CBsSprBZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1461,1]) : void 0),
    "unlink": () => __vitePreload(() => import("./unlink-BqoFfo6j.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1462,1]) : void 0),
    "unplug": () => __vitePreload(() => import("./unplug-CZ9F2oKK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1463,1]) : void 0),
    "upload": () => __vitePreload(() => import("./upload-Btei5SEA.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1464,1]) : void 0),
    "usb": () => __vitePreload(() => import("./usb-lbvJNxwo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1465,1]) : void 0),
    "user-check": () => __vitePreload(() => import("./user-check-6PnI1oKk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1466,1]) : void 0),
    "user-cog": () => __vitePreload(() => import("./user-cog-CiZvd9xV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1467,1]) : void 0),
    "user-minus": () => __vitePreload(() => import("./user-minus-BMrAogZh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1468,1]) : void 0),
    "user-pen": () => __vitePreload(() => import("./user-pen-BQaEZm-h.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1469,1]) : void 0),
    "user-plus": () => __vitePreload(() => import("./user-plus-05fy-C9Y.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1470,1]) : void 0),
    "user-round-check": () => __vitePreload(() => import("./user-round-check-Cl94LywT.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1471,1]) : void 0),
    "user-round-cog": () => __vitePreload(() => import("./user-round-cog-rQwPRRmX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1472,1]) : void 0),
    "user-round-minus": () => __vitePreload(() => import("./user-round-minus-DiQE4fS8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1473,1]) : void 0),
    "user-round-pen": () => __vitePreload(() => import("./user-round-pen-CspK29T0.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1474,1]) : void 0),
    "user-round-plus": () => __vitePreload(() => import("./user-round-plus-st4nLwut.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1475,1]) : void 0),
    "user-round-search": () => __vitePreload(() => import("./user-round-search-Dt_Qpr2n.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1476,1]) : void 0),
    "user-round-x": () => __vitePreload(() => import("./user-round-x-BTPfAqGG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1477,1]) : void 0),
    "user-round": () => __vitePreload(() => import("./user-round-BKQWP867.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1478,1]) : void 0),
    "user-search": () => __vitePreload(() => import("./user-search-BJqomA0R.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1479,1]) : void 0),
    "user-x": () => __vitePreload(() => import("./user-x-B3aP4xsk.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1480,1]) : void 0),
    "user": () => __vitePreload(() => import("./user-CZm0kHBK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1481,1]) : void 0),
    "users-round": () => __vitePreload(() => import("./users-round--AULh7IM.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1482,1]) : void 0),
    "users": () => __vitePreload(() => import("./users-CsRK1ZaG.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1483,1]) : void 0),
    "utensils-crossed": () => __vitePreload(() => import("./utensils-crossed-DkuYptKL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1484,1]) : void 0),
    "utensils": () => __vitePreload(() => import("./utensils-m7cfiRaL.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1485,1]) : void 0),
    "utility-pole": () => __vitePreload(() => import("./utility-pole-G6MZ2ulr.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1486,1]) : void 0),
    "variable": () => __vitePreload(() => import("./variable-Bf9udoCS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1487,1]) : void 0),
    "vault": () => __vitePreload(() => import("./vault-CNyyJA7p.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1488,1]) : void 0),
    "vegan": () => __vitePreload(() => import("./vegan-Da79SCMx.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1489,1]) : void 0),
    "venetian-mask": () => __vitePreload(() => import("./venetian-mask-1sodC9_E.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1490,1]) : void 0),
    "vibrate-off": () => __vitePreload(() => import("./vibrate-off-DHUttMQt.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1491,1]) : void 0),
    "vibrate": () => __vitePreload(() => import("./vibrate-B_9YZsD6.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1492,1]) : void 0),
    "video-off": () => __vitePreload(() => import("./video-off-BXdPdNsp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1493,1]) : void 0),
    "video": () => __vitePreload(() => import("./video-7V9IXk4u.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1494,1]) : void 0),
    "videotape": () => __vitePreload(() => import("./videotape-x1vyU6Fp.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1495,1]) : void 0),
    "view": () => __vitePreload(() => import("./view-BB2hBPyO.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1496,1]) : void 0),
    "voicemail": () => __vitePreload(() => import("./voicemail-4PooibCq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1497,1]) : void 0),
    "volleyball": () => __vitePreload(() => import("./volleyball-D6C7uOHJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1498,1]) : void 0),
    "volume-1": () => __vitePreload(() => import("./volume-1-H4P7qhQu.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1499,1]) : void 0),
    "volume-2": () => __vitePreload(() => import("./volume-2-D2EG3p1s.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1500,1]) : void 0),
    "volume-off": () => __vitePreload(() => import("./volume-off-BQfcdhR7.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1501,1]) : void 0),
    "volume-x": () => __vitePreload(() => import("./volume-x-DOeRKjW1.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1502,1]) : void 0),
    "volume": () => __vitePreload(() => import("./volume-fv4l2Qd_.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1503,1]) : void 0),
    "vote": () => __vitePreload(() => import("./vote-B8WDowtd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1504,1]) : void 0),
    "wallet-cards": () => __vitePreload(() => import("./wallet-cards-C_S9qYPN.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1505,1]) : void 0),
    "wallet-minimal": () => __vitePreload(() => import("./wallet-minimal-D92_zg1C.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1506,1]) : void 0),
    "wallet": () => __vitePreload(() => import("./wallet-C-ck9prm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1507,1]) : void 0),
    "wallpaper": () => __vitePreload(() => import("./wallpaper-C1r7Zu5w.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1508,1]) : void 0),
    "wand-sparkles": () => __vitePreload(() => import("./wand-sparkles-DmZmKIYm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1509,1]) : void 0),
    "wand": () => __vitePreload(() => import("./wand-Dr-McKPX.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1510,1]) : void 0),
    "warehouse": () => __vitePreload(() => import("./warehouse-iEC0fxDV.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1511,1]) : void 0),
    "washing-machine": () => __vitePreload(() => import("./washing-machine-B4steotW.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1512,1]) : void 0),
    "watch": () => __vitePreload(() => import("./watch-DMUv1Sdj.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1513,1]) : void 0),
    "waves": () => __vitePreload(() => import("./waves-CmS-cDVc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1514,1]) : void 0),
    "waypoints": () => __vitePreload(() => import("./waypoints-DL9Zv1Ol.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1515,1]) : void 0),
    "webcam": () => __vitePreload(() => import("./webcam-CmU33Xt8.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1516,1]) : void 0),
    "webhook-off": () => __vitePreload(() => import("./webhook-off-DsXGBzON.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1517,1]) : void 0),
    "webhook": () => __vitePreload(() => import("./webhook-BrrVY4Bs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1518,1]) : void 0),
    "weight": () => __vitePreload(() => import("./weight-Cem0A-oF.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1519,1]) : void 0),
    "wheat-off": () => __vitePreload(() => import("./wheat-off-Bdv4XxRq.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1520,1]) : void 0),
    "wheat": () => __vitePreload(() => import("./wheat-D7c-ZIkJ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1521,1]) : void 0),
    "whole-word": () => __vitePreload(() => import("./whole-word-DUS7kskI.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1522,1]) : void 0),
    "wifi-high": () => __vitePreload(() => import("./wifi-high-CN7GvJBc.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1523,1]) : void 0),
    "wifi-low": () => __vitePreload(() => import("./wifi-low-B4WUuUDe.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1524,1]) : void 0),
    "wifi-off": () => __vitePreload(() => import("./wifi-off-D4QD5vHd.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1525,1]) : void 0),
    "wifi-zero": () => __vitePreload(() => import("./wifi-zero-DCuMfwPs.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1526,1]) : void 0),
    "wifi": () => __vitePreload(() => import("./wifi-BrxwAONm.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1527,1]) : void 0),
    "wind-arrow-down": () => __vitePreload(() => import("./wind-arrow-down-Bdc7E47C.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1528,1]) : void 0),
    "wind": () => __vitePreload(() => import("./wind-6gOxg9iZ.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1529,1]) : void 0),
    "wine-off": () => __vitePreload(() => import("./wine-off-DBpsHj3N.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1530,1]) : void 0),
    "wine": () => __vitePreload(() => import("./wine-COxcOhiK.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1531,1]) : void 0),
    "workflow": () => __vitePreload(() => import("./workflow-D8crtUHD.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1532,1]) : void 0),
    "worm": () => __vitePreload(() => import("./worm-CiLCDPPz.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1533,1]) : void 0),
    "wrap-text": () => __vitePreload(() => import("./wrap-text-2NHP2xqH.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1534,1]) : void 0),
    "wrench": () => __vitePreload(() => import("./wrench-CHNreDPo.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1535,1]) : void 0),
    "x": () => __vitePreload(() => import("./x-wv-8XEYv.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1536,1]) : void 0),
    "youtube": () => __vitePreload(() => import("./youtube-Befkd-ol.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1537,1]) : void 0),
    "zap-off": () => __vitePreload(() => import("./zap-off-Bazciml2.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1538,1]) : void 0),
    "zap": () => __vitePreload(() => import("./zap-B4nJlPfh.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1539,1]) : void 0),
    "zoom-in": () => __vitePreload(() => import("./zoom-in-C5Boot0Q.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1540,1]) : void 0),
    "zoom-out": () => __vitePreload(() => import("./zoom-out-C82_dzLS.js").then(async (m2) => {
      await m2.__tla;
      return m2;
    }), true ? __vite__mapDeps([1541,1]) : void 0)
  };
  const iconCache = {};
  LazyIcon = reactExports.memo(({ name, ...props }) => {
    const iconName = name;
    if (!dynamicIconImports[iconName]) {
      throw new Error(`No icon found for ${iconName}`);
    }
    if (!iconCache[iconName]) {
      iconCache[iconName] = reactExports.lazy(dynamicIconImports[iconName]);
    }
    const LucideIcon = iconCache[iconName];
    return jsxRuntimeExports.jsx(reactExports.Suspense, {
      fallback: jsxRuntimeExports.jsx("div", {
        className: props.className
      }),
      children: jsxRuntimeExports.jsx(LucideIcon, {
        ...props
      })
    });
  });
  const CLASS_PART_SEPARATOR = "-";
  const createClassGroupUtils = (config) => {
    const classMap = createClassMap(config);
    const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
    const getClassGroupId = (className) => {
      const classParts = className.split(CLASS_PART_SEPARATOR);
      if (classParts[0] === "" && classParts.length !== 1) {
        classParts.shift();
      }
      return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
      const conflicts = conflictingClassGroups[classGroupId] || [];
      if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
        return [
          ...conflicts,
          ...conflictingClassGroupModifiers[classGroupId]
        ];
      }
      return conflicts;
    };
    return {
      getClassGroupId,
      getConflictingClassGroupIds
    };
  };
  const getGroupRecursive = (classParts, classPartObject) => {
    var _a;
    if (classParts.length === 0) {
      return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
    if (classGroupFromNextClassPart) {
      return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
      return void 0;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return (_a = classPartObject.validators.find(({ validator: validator2 }) => validator2(classRest))) == null ? void 0 : _a.classGroupId;
  };
  const arbitraryPropertyRegex = /^\[(.+)\]$/;
  const getGroupIdForArbitraryProperty = (className) => {
    if (arbitraryPropertyRegex.test(className)) {
      const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
      const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
      if (property) {
        return "arbitrary.." + property;
      }
    }
  };
  const createClassMap = (config) => {
    const { theme, prefix } = config;
    const classMap = {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    };
    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
      processClassesRecursively(classGroup, classMap, classGroupId, theme);
    });
    return classMap;
  };
  const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
    classGroup.forEach((classDefinition) => {
      if (typeof classDefinition === "string") {
        const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
        classPartObjectToEdit.classGroupId = classGroupId;
        return;
      }
      if (typeof classDefinition === "function") {
        if (isThemeGetter(classDefinition)) {
          processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
          return;
        }
        classPartObject.validators.push({
          validator: classDefinition,
          classGroupId
        });
        return;
      }
      Object.entries(classDefinition).forEach(([key, classGroup2]) => {
        processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
      });
    });
  };
  const getPart = (classPartObject, path) => {
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
      if (!currentClassPartObject.nextPart.has(pathPart)) {
        currentClassPartObject.nextPart.set(pathPart, {
          nextPart: /* @__PURE__ */ new Map(),
          validators: []
        });
      }
      currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
  };
  const isThemeGetter = (func) => func.isThemeGetter;
  const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
    if (!prefix) {
      return classGroupEntries;
    }
    return classGroupEntries.map(([classGroupId, classGroup]) => {
      const prefixedClassGroup = classGroup.map((classDefinition) => {
        if (typeof classDefinition === "string") {
          return prefix + classDefinition;
        }
        if (typeof classDefinition === "object") {
          return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [
            prefix + key,
            value
          ]));
        }
        return classDefinition;
      });
      return [
        classGroupId,
        prefixedClassGroup
      ];
    });
  };
  const createLruCache = (maxCacheSize) => {
    if (maxCacheSize < 1) {
      return {
        get: () => void 0,
        set: () => {
        }
      };
    }
    let cacheSize = 0;
    let cache2 = /* @__PURE__ */ new Map();
    let previousCache = /* @__PURE__ */ new Map();
    const update = (key, value) => {
      cache2.set(key, value);
      cacheSize++;
      if (cacheSize > maxCacheSize) {
        cacheSize = 0;
        previousCache = cache2;
        cache2 = /* @__PURE__ */ new Map();
      }
    };
    return {
      get(key) {
        let value = cache2.get(key);
        if (value !== void 0) {
          return value;
        }
        if ((value = previousCache.get(key)) !== void 0) {
          update(key, value);
          return value;
        }
      },
      set(key, value) {
        if (cache2.has(key)) {
          cache2.set(key, value);
        } else {
          update(key, value);
        }
      }
    };
  };
  const IMPORTANT_MODIFIER = "!";
  const createParseClassName = (config) => {
    const { separator, experimentalParseClassName } = config;
    const isSeparatorSingleCharacter = separator.length === 1;
    const firstSeparatorCharacter = separator[0];
    const separatorLength = separator.length;
    const parseClassName = (className) => {
      const modifiers = [];
      let bracketDepth = 0;
      let modifierStart = 0;
      let postfixModifierPosition;
      for (let index2 = 0; index2 < className.length; index2++) {
        let currentCharacter = className[index2];
        if (bracketDepth === 0) {
          if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
            modifiers.push(className.slice(modifierStart, index2));
            modifierStart = index2 + separatorLength;
            continue;
          }
          if (currentCharacter === "/") {
            postfixModifierPosition = index2;
            continue;
          }
        }
        if (currentCharacter === "[") {
          bracketDepth++;
        } else if (currentCharacter === "]") {
          bracketDepth--;
        }
      }
      const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
      const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
      const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
      const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
      return {
        modifiers,
        hasImportantModifier,
        baseClassName,
        maybePostfixModifierPosition
      };
    };
    if (experimentalParseClassName) {
      return (className) => experimentalParseClassName({
        className,
        parseClassName
      });
    }
    return parseClassName;
  };
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isArbitraryVariant = modifier[0] === "[";
      if (isArbitraryVariant) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  const createConfigUtils = (config) => ({
    cache: createLruCache(config.cacheSize),
    parseClassName: createParseClassName(config),
    ...createClassGroupUtils(config)
  });
  const SPLIT_CLASSES_REGEX = /\s+/;
  const mergeClassList = (classList, configUtils) => {
    const { parseClassName, getClassGroupId, getConflictingClassGroupIds } = configUtils;
    const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = "";
    for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
      const originalClassName = classNames[index2];
      const { modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition } = parseClassName(originalClassName);
      let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
      let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
      if (!classGroupId) {
        if (!hasPostfixModifier) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        classGroupId = getClassGroupId(baseClassName);
        if (!classGroupId) {
          result = originalClassName + (result.length > 0 ? " " + result : result);
          continue;
        }
        hasPostfixModifier = false;
      }
      const variantModifier = sortModifiers(modifiers).join(":");
      const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
      const classId = modifierId + classGroupId;
      if (classGroupsInConflict.includes(classId)) {
        continue;
      }
      classGroupsInConflict.push(classId);
      const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
      for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
        const group = conflictGroups[i2];
        classGroupsInConflict.push(modifierId + group);
      }
      result = originalClassName + (result.length > 0 ? " " + result : result);
    }
    return result;
  };
  function twJoin() {
    let index2 = 0;
    let argument;
    let resolvedValue;
    let string = "";
    while (index2 < arguments.length) {
      if (argument = arguments[index2++]) {
        if (resolvedValue = toValue(argument)) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  }
  const toValue = (mix2) => {
    if (typeof mix2 === "string") {
      return mix2;
    }
    let resolvedValue;
    let string = "";
    for (let k2 = 0; k2 < mix2.length; k2++) {
      if (mix2[k2]) {
        if (resolvedValue = toValue(mix2[k2])) {
          string && (string += " ");
          string += resolvedValue;
        }
      }
    }
    return string;
  };
  function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
      const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
      configUtils = createConfigUtils(config);
      cacheGet = configUtils.cache.get;
      cacheSet = configUtils.cache.set;
      functionToCall = tailwindMerge;
      return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
      const cachedResult = cacheGet(classList);
      if (cachedResult) {
        return cachedResult;
      }
      const result = mergeClassList(classList, configUtils);
      cacheSet(classList, result);
      return result;
    }
    return function callTailwindMerge() {
      return functionToCall(twJoin.apply(null, arguments));
    };
  }
  const fromTheme = (key) => {
    const themeGetter = (theme) => theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
  };
  const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
  const fractionRegex = /^\d+\/\d+$/;
  const stringLengths = /* @__PURE__ */ new Set([
    "px",
    "full",
    "screen"
  ]);
  const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
  const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
  const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
  const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
  const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
  const isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
  const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
  const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
  const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
  const isInteger$1 = (value) => Boolean(value) && Number.isInteger(Number(value));
  const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
  const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
  const isTshirtSize = (value) => tshirtUnitRegex.test(value);
  const sizeLabels = /* @__PURE__ */ new Set([
    "length",
    "size",
    "percentage"
  ]);
  const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
  const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
  const imageLabels = /* @__PURE__ */ new Set([
    "image",
    "url"
  ]);
  const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
  const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
  const isAny = () => true;
  const getIsArbitraryValue = (value, label, testValue) => {
    const result = arbitraryValueRegex.exec(value);
    if (result) {
      if (result[1]) {
        return typeof label === "string" ? result[1] === label : label.has(result[1]);
      }
      return testValue(result[2]);
    }
    return false;
  };
  const isLengthOnly = (value) => lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
  const isNever = () => false;
  const isShadow = (value) => shadowRegex.test(value);
  const isImage = (value) => imageRegex.test(value);
  const getDefaultConfig = () => {
    const colors = fromTheme("colors");
    const spacing = fromTheme("spacing");
    const blur = fromTheme("blur");
    const brightness = fromTheme("brightness");
    const borderColor = fromTheme("borderColor");
    const borderRadius = fromTheme("borderRadius");
    const borderSpacing = fromTheme("borderSpacing");
    const borderWidth = fromTheme("borderWidth");
    const contrast = fromTheme("contrast");
    const grayscale = fromTheme("grayscale");
    const hueRotate = fromTheme("hueRotate");
    const invert = fromTheme("invert");
    const gap = fromTheme("gap");
    const gradientColorStops = fromTheme("gradientColorStops");
    const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
    const inset = fromTheme("inset");
    const margin = fromTheme("margin");
    const opacity = fromTheme("opacity");
    const padding = fromTheme("padding");
    const saturate = fromTheme("saturate");
    const scale2 = fromTheme("scale");
    const sepia = fromTheme("sepia");
    const skew = fromTheme("skew");
    const space = fromTheme("space");
    const translate = fromTheme("translate");
    const getOverscroll = () => [
      "auto",
      "contain",
      "none"
    ];
    const getOverflow = () => [
      "auto",
      "hidden",
      "clip",
      "visible",
      "scroll"
    ];
    const getSpacingWithAutoAndArbitrary = () => [
      "auto",
      isArbitraryValue,
      spacing
    ];
    const getSpacingWithArbitrary = () => [
      isArbitraryValue,
      spacing
    ];
    const getLengthWithEmptyAndArbitrary = () => [
      "",
      isLength,
      isArbitraryLength
    ];
    const getNumberWithAutoAndArbitrary = () => [
      "auto",
      isNumber,
      isArbitraryValue
    ];
    const getPositions = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ];
    const getLineStyles = () => [
      "solid",
      "dashed",
      "dotted",
      "double",
      "none"
    ];
    const getBlendModes = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity"
    ];
    const getAlign = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch"
    ];
    const getZeroAndEmpty = () => [
      "",
      "0",
      isArbitraryValue
    ];
    const getBreaks = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ];
    const getNumberAndArbitrary = () => [
      isNumber,
      isArbitraryValue
    ];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [
          isAny
        ],
        spacing: [
          isLength,
          isArbitraryLength
        ],
        blur: [
          "none",
          "",
          isTshirtSize,
          isArbitraryValue
        ],
        brightness: getNumberAndArbitrary(),
        borderColor: [
          colors
        ],
        borderRadius: [
          "none",
          "",
          "full",
          isTshirtSize,
          isArbitraryValue
        ],
        borderSpacing: getSpacingWithArbitrary(),
        borderWidth: getLengthWithEmptyAndArbitrary(),
        contrast: getNumberAndArbitrary(),
        grayscale: getZeroAndEmpty(),
        hueRotate: getNumberAndArbitrary(),
        invert: getZeroAndEmpty(),
        gap: getSpacingWithArbitrary(),
        gradientColorStops: [
          colors
        ],
        gradientColorStopPositions: [
          isPercent,
          isArbitraryLength
        ],
        inset: getSpacingWithAutoAndArbitrary(),
        margin: getSpacingWithAutoAndArbitrary(),
        opacity: getNumberAndArbitrary(),
        padding: getSpacingWithArbitrary(),
        saturate: getNumberAndArbitrary(),
        scale: getNumberAndArbitrary(),
        sepia: getZeroAndEmpty(),
        skew: getNumberAndArbitrary(),
        space: getSpacingWithArbitrary(),
        translate: getSpacingWithArbitrary()
      },
      classGroups: {
        aspect: [
          {
            aspect: [
              "auto",
              "square",
              "video",
              isArbitraryValue
            ]
          }
        ],
        container: [
          "container"
        ],
        columns: [
          {
            columns: [
              isTshirtSize
            ]
          }
        ],
        "break-after": [
          {
            "break-after": getBreaks()
          }
        ],
        "break-before": [
          {
            "break-before": getBreaks()
          }
        ],
        "break-inside": [
          {
            "break-inside": [
              "auto",
              "avoid",
              "avoid-page",
              "avoid-column"
            ]
          }
        ],
        "box-decoration": [
          {
            "box-decoration": [
              "slice",
              "clone"
            ]
          }
        ],
        box: [
          {
            box: [
              "border",
              "content"
            ]
          }
        ],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        float: [
          {
            float: [
              "right",
              "left",
              "none",
              "start",
              "end"
            ]
          }
        ],
        clear: [
          {
            clear: [
              "left",
              "right",
              "both",
              "none",
              "start",
              "end"
            ]
          }
        ],
        isolation: [
          "isolate",
          "isolation-auto"
        ],
        "object-fit": [
          {
            object: [
              "contain",
              "cover",
              "fill",
              "none",
              "scale-down"
            ]
          }
        ],
        "object-position": [
          {
            object: [
              ...getPositions(),
              isArbitraryValue
            ]
          }
        ],
        overflow: [
          {
            overflow: getOverflow()
          }
        ],
        "overflow-x": [
          {
            "overflow-x": getOverflow()
          }
        ],
        "overflow-y": [
          {
            "overflow-y": getOverflow()
          }
        ],
        overscroll: [
          {
            overscroll: getOverscroll()
          }
        ],
        "overscroll-x": [
          {
            "overscroll-x": getOverscroll()
          }
        ],
        "overscroll-y": [
          {
            "overscroll-y": getOverscroll()
          }
        ],
        position: [
          "static",
          "fixed",
          "absolute",
          "relative",
          "sticky"
        ],
        inset: [
          {
            inset: [
              inset
            ]
          }
        ],
        "inset-x": [
          {
            "inset-x": [
              inset
            ]
          }
        ],
        "inset-y": [
          {
            "inset-y": [
              inset
            ]
          }
        ],
        start: [
          {
            start: [
              inset
            ]
          }
        ],
        end: [
          {
            end: [
              inset
            ]
          }
        ],
        top: [
          {
            top: [
              inset
            ]
          }
        ],
        right: [
          {
            right: [
              inset
            ]
          }
        ],
        bottom: [
          {
            bottom: [
              inset
            ]
          }
        ],
        left: [
          {
            left: [
              inset
            ]
          }
        ],
        visibility: [
          "visible",
          "invisible",
          "collapse"
        ],
        z: [
          {
            z: [
              "auto",
              isInteger$1,
              isArbitraryValue
            ]
          }
        ],
        basis: [
          {
            basis: getSpacingWithAutoAndArbitrary()
          }
        ],
        "flex-direction": [
          {
            flex: [
              "row",
              "row-reverse",
              "col",
              "col-reverse"
            ]
          }
        ],
        "flex-wrap": [
          {
            flex: [
              "wrap",
              "wrap-reverse",
              "nowrap"
            ]
          }
        ],
        flex: [
          {
            flex: [
              "1",
              "auto",
              "initial",
              "none",
              isArbitraryValue
            ]
          }
        ],
        grow: [
          {
            grow: getZeroAndEmpty()
          }
        ],
        shrink: [
          {
            shrink: getZeroAndEmpty()
          }
        ],
        order: [
          {
            order: [
              "first",
              "last",
              "none",
              isInteger$1,
              isArbitraryValue
            ]
          }
        ],
        "grid-cols": [
          {
            "grid-cols": [
              isAny
            ]
          }
        ],
        "col-start-end": [
          {
            col: [
              "auto",
              {
                span: [
                  "full",
                  isInteger$1,
                  isArbitraryValue
                ]
              },
              isArbitraryValue
            ]
          }
        ],
        "col-start": [
          {
            "col-start": getNumberWithAutoAndArbitrary()
          }
        ],
        "col-end": [
          {
            "col-end": getNumberWithAutoAndArbitrary()
          }
        ],
        "grid-rows": [
          {
            "grid-rows": [
              isAny
            ]
          }
        ],
        "row-start-end": [
          {
            row: [
              "auto",
              {
                span: [
                  isInteger$1,
                  isArbitraryValue
                ]
              },
              isArbitraryValue
            ]
          }
        ],
        "row-start": [
          {
            "row-start": getNumberWithAutoAndArbitrary()
          }
        ],
        "row-end": [
          {
            "row-end": getNumberWithAutoAndArbitrary()
          }
        ],
        "grid-flow": [
          {
            "grid-flow": [
              "row",
              "col",
              "dense",
              "row-dense",
              "col-dense"
            ]
          }
        ],
        "auto-cols": [
          {
            "auto-cols": [
              "auto",
              "min",
              "max",
              "fr",
              isArbitraryValue
            ]
          }
        ],
        "auto-rows": [
          {
            "auto-rows": [
              "auto",
              "min",
              "max",
              "fr",
              isArbitraryValue
            ]
          }
        ],
        gap: [
          {
            gap: [
              gap
            ]
          }
        ],
        "gap-x": [
          {
            "gap-x": [
              gap
            ]
          }
        ],
        "gap-y": [
          {
            "gap-y": [
              gap
            ]
          }
        ],
        "justify-content": [
          {
            justify: [
              "normal",
              ...getAlign()
            ]
          }
        ],
        "justify-items": [
          {
            "justify-items": [
              "start",
              "end",
              "center",
              "stretch"
            ]
          }
        ],
        "justify-self": [
          {
            "justify-self": [
              "auto",
              "start",
              "end",
              "center",
              "stretch"
            ]
          }
        ],
        "align-content": [
          {
            content: [
              "normal",
              ...getAlign(),
              "baseline"
            ]
          }
        ],
        "align-items": [
          {
            items: [
              "start",
              "end",
              "center",
              "baseline",
              "stretch"
            ]
          }
        ],
        "align-self": [
          {
            self: [
              "auto",
              "start",
              "end",
              "center",
              "stretch",
              "baseline"
            ]
          }
        ],
        "place-content": [
          {
            "place-content": [
              ...getAlign(),
              "baseline"
            ]
          }
        ],
        "place-items": [
          {
            "place-items": [
              "start",
              "end",
              "center",
              "baseline",
              "stretch"
            ]
          }
        ],
        "place-self": [
          {
            "place-self": [
              "auto",
              "start",
              "end",
              "center",
              "stretch"
            ]
          }
        ],
        p: [
          {
            p: [
              padding
            ]
          }
        ],
        px: [
          {
            px: [
              padding
            ]
          }
        ],
        py: [
          {
            py: [
              padding
            ]
          }
        ],
        ps: [
          {
            ps: [
              padding
            ]
          }
        ],
        pe: [
          {
            pe: [
              padding
            ]
          }
        ],
        pt: [
          {
            pt: [
              padding
            ]
          }
        ],
        pr: [
          {
            pr: [
              padding
            ]
          }
        ],
        pb: [
          {
            pb: [
              padding
            ]
          }
        ],
        pl: [
          {
            pl: [
              padding
            ]
          }
        ],
        m: [
          {
            m: [
              margin
            ]
          }
        ],
        mx: [
          {
            mx: [
              margin
            ]
          }
        ],
        my: [
          {
            my: [
              margin
            ]
          }
        ],
        ms: [
          {
            ms: [
              margin
            ]
          }
        ],
        me: [
          {
            me: [
              margin
            ]
          }
        ],
        mt: [
          {
            mt: [
              margin
            ]
          }
        ],
        mr: [
          {
            mr: [
              margin
            ]
          }
        ],
        mb: [
          {
            mb: [
              margin
            ]
          }
        ],
        ml: [
          {
            ml: [
              margin
            ]
          }
        ],
        "space-x": [
          {
            "space-x": [
              space
            ]
          }
        ],
        "space-x-reverse": [
          "space-x-reverse"
        ],
        "space-y": [
          {
            "space-y": [
              space
            ]
          }
        ],
        "space-y-reverse": [
          "space-y-reverse"
        ],
        w: [
          {
            w: [
              "auto",
              "min",
              "max",
              "fit",
              "svw",
              "lvw",
              "dvw",
              isArbitraryValue,
              spacing
            ]
          }
        ],
        "min-w": [
          {
            "min-w": [
              isArbitraryValue,
              spacing,
              "min",
              "max",
              "fit"
            ]
          }
        ],
        "max-w": [
          {
            "max-w": [
              isArbitraryValue,
              spacing,
              "none",
              "full",
              "min",
              "max",
              "fit",
              "prose",
              {
                screen: [
                  isTshirtSize
                ]
              },
              isTshirtSize
            ]
          }
        ],
        h: [
          {
            h: [
              isArbitraryValue,
              spacing,
              "auto",
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh"
            ]
          }
        ],
        "min-h": [
          {
            "min-h": [
              isArbitraryValue,
              spacing,
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh"
            ]
          }
        ],
        "max-h": [
          {
            "max-h": [
              isArbitraryValue,
              spacing,
              "min",
              "max",
              "fit",
              "svh",
              "lvh",
              "dvh"
            ]
          }
        ],
        size: [
          {
            size: [
              isArbitraryValue,
              spacing,
              "auto",
              "min",
              "max",
              "fit"
            ]
          }
        ],
        "font-size": [
          {
            text: [
              "base",
              isTshirtSize,
              isArbitraryLength
            ]
          }
        ],
        "font-smoothing": [
          "antialiased",
          "subpixel-antialiased"
        ],
        "font-style": [
          "italic",
          "not-italic"
        ],
        "font-weight": [
          {
            font: [
              "thin",
              "extralight",
              "light",
              "normal",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
              isArbitraryNumber
            ]
          }
        ],
        "font-family": [
          {
            font: [
              isAny
            ]
          }
        ],
        "fvn-normal": [
          "normal-nums"
        ],
        "fvn-ordinal": [
          "ordinal"
        ],
        "fvn-slashed-zero": [
          "slashed-zero"
        ],
        "fvn-figure": [
          "lining-nums",
          "oldstyle-nums"
        ],
        "fvn-spacing": [
          "proportional-nums",
          "tabular-nums"
        ],
        "fvn-fraction": [
          "diagonal-fractions",
          "stacked-fractons"
        ],
        tracking: [
          {
            tracking: [
              "tighter",
              "tight",
              "normal",
              "wide",
              "wider",
              "widest",
              isArbitraryValue
            ]
          }
        ],
        "line-clamp": [
          {
            "line-clamp": [
              "none",
              isNumber,
              isArbitraryNumber
            ]
          }
        ],
        leading: [
          {
            leading: [
              "none",
              "tight",
              "snug",
              "normal",
              "relaxed",
              "loose",
              isLength,
              isArbitraryValue
            ]
          }
        ],
        "list-image": [
          {
            "list-image": [
              "none",
              isArbitraryValue
            ]
          }
        ],
        "list-style-type": [
          {
            list: [
              "none",
              "disc",
              "decimal",
              isArbitraryValue
            ]
          }
        ],
        "list-style-position": [
          {
            list: [
              "inside",
              "outside"
            ]
          }
        ],
        "placeholder-color": [
          {
            placeholder: [
              colors
            ]
          }
        ],
        "placeholder-opacity": [
          {
            "placeholder-opacity": [
              opacity
            ]
          }
        ],
        "text-alignment": [
          {
            text: [
              "left",
              "center",
              "right",
              "justify",
              "start",
              "end"
            ]
          }
        ],
        "text-color": [
          {
            text: [
              colors
            ]
          }
        ],
        "text-opacity": [
          {
            "text-opacity": [
              opacity
            ]
          }
        ],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline"
        ],
        "text-decoration-style": [
          {
            decoration: [
              ...getLineStyles(),
              "wavy"
            ]
          }
        ],
        "text-decoration-thickness": [
          {
            decoration: [
              "auto",
              "from-font",
              isLength,
              isArbitraryLength
            ]
          }
        ],
        "underline-offset": [
          {
            "underline-offset": [
              "auto",
              isLength,
              isArbitraryValue
            ]
          }
        ],
        "text-decoration-color": [
          {
            decoration: [
              colors
            ]
          }
        ],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case"
        ],
        "text-overflow": [
          "truncate",
          "text-ellipsis",
          "text-clip"
        ],
        "text-wrap": [
          {
            text: [
              "wrap",
              "nowrap",
              "balance",
              "pretty"
            ]
          }
        ],
        indent: [
          {
            indent: getSpacingWithArbitrary()
          }
        ],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              isArbitraryValue
            ]
          }
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces"
            ]
          }
        ],
        break: [
          {
            break: [
              "normal",
              "words",
              "all",
              "keep"
            ]
          }
        ],
        hyphens: [
          {
            hyphens: [
              "none",
              "manual",
              "auto"
            ]
          }
        ],
        content: [
          {
            content: [
              "none",
              isArbitraryValue
            ]
          }
        ],
        "bg-attachment": [
          {
            bg: [
              "fixed",
              "local",
              "scroll"
            ]
          }
        ],
        "bg-clip": [
          {
            "bg-clip": [
              "border",
              "padding",
              "content",
              "text"
            ]
          }
        ],
        "bg-opacity": [
          {
            "bg-opacity": [
              opacity
            ]
          }
        ],
        "bg-origin": [
          {
            "bg-origin": [
              "border",
              "padding",
              "content"
            ]
          }
        ],
        "bg-position": [
          {
            bg: [
              ...getPositions(),
              isArbitraryPosition
            ]
          }
        ],
        "bg-repeat": [
          {
            bg: [
              "no-repeat",
              {
                repeat: [
                  "",
                  "x",
                  "y",
                  "round",
                  "space"
                ]
              }
            ]
          }
        ],
        "bg-size": [
          {
            bg: [
              "auto",
              "cover",
              "contain",
              isArbitrarySize
            ]
          }
        ],
        "bg-image": [
          {
            bg: [
              "none",
              {
                "gradient-to": [
                  "t",
                  "tr",
                  "r",
                  "br",
                  "b",
                  "bl",
                  "l",
                  "tl"
                ]
              },
              isArbitraryImage
            ]
          }
        ],
        "bg-color": [
          {
            bg: [
              colors
            ]
          }
        ],
        "gradient-from-pos": [
          {
            from: [
              gradientColorStopPositions
            ]
          }
        ],
        "gradient-via-pos": [
          {
            via: [
              gradientColorStopPositions
            ]
          }
        ],
        "gradient-to-pos": [
          {
            to: [
              gradientColorStopPositions
            ]
          }
        ],
        "gradient-from": [
          {
            from: [
              gradientColorStops
            ]
          }
        ],
        "gradient-via": [
          {
            via: [
              gradientColorStops
            ]
          }
        ],
        "gradient-to": [
          {
            to: [
              gradientColorStops
            ]
          }
        ],
        rounded: [
          {
            rounded: [
              borderRadius
            ]
          }
        ],
        "rounded-s": [
          {
            "rounded-s": [
              borderRadius
            ]
          }
        ],
        "rounded-e": [
          {
            "rounded-e": [
              borderRadius
            ]
          }
        ],
        "rounded-t": [
          {
            "rounded-t": [
              borderRadius
            ]
          }
        ],
        "rounded-r": [
          {
            "rounded-r": [
              borderRadius
            ]
          }
        ],
        "rounded-b": [
          {
            "rounded-b": [
              borderRadius
            ]
          }
        ],
        "rounded-l": [
          {
            "rounded-l": [
              borderRadius
            ]
          }
        ],
        "rounded-ss": [
          {
            "rounded-ss": [
              borderRadius
            ]
          }
        ],
        "rounded-se": [
          {
            "rounded-se": [
              borderRadius
            ]
          }
        ],
        "rounded-ee": [
          {
            "rounded-ee": [
              borderRadius
            ]
          }
        ],
        "rounded-es": [
          {
            "rounded-es": [
              borderRadius
            ]
          }
        ],
        "rounded-tl": [
          {
            "rounded-tl": [
              borderRadius
            ]
          }
        ],
        "rounded-tr": [
          {
            "rounded-tr": [
              borderRadius
            ]
          }
        ],
        "rounded-br": [
          {
            "rounded-br": [
              borderRadius
            ]
          }
        ],
        "rounded-bl": [
          {
            "rounded-bl": [
              borderRadius
            ]
          }
        ],
        "border-w": [
          {
            border: [
              borderWidth
            ]
          }
        ],
        "border-w-x": [
          {
            "border-x": [
              borderWidth
            ]
          }
        ],
        "border-w-y": [
          {
            "border-y": [
              borderWidth
            ]
          }
        ],
        "border-w-s": [
          {
            "border-s": [
              borderWidth
            ]
          }
        ],
        "border-w-e": [
          {
            "border-e": [
              borderWidth
            ]
          }
        ],
        "border-w-t": [
          {
            "border-t": [
              borderWidth
            ]
          }
        ],
        "border-w-r": [
          {
            "border-r": [
              borderWidth
            ]
          }
        ],
        "border-w-b": [
          {
            "border-b": [
              borderWidth
            ]
          }
        ],
        "border-w-l": [
          {
            "border-l": [
              borderWidth
            ]
          }
        ],
        "border-opacity": [
          {
            "border-opacity": [
              opacity
            ]
          }
        ],
        "border-style": [
          {
            border: [
              ...getLineStyles(),
              "hidden"
            ]
          }
        ],
        "divide-x": [
          {
            "divide-x": [
              borderWidth
            ]
          }
        ],
        "divide-x-reverse": [
          "divide-x-reverse"
        ],
        "divide-y": [
          {
            "divide-y": [
              borderWidth
            ]
          }
        ],
        "divide-y-reverse": [
          "divide-y-reverse"
        ],
        "divide-opacity": [
          {
            "divide-opacity": [
              opacity
            ]
          }
        ],
        "divide-style": [
          {
            divide: getLineStyles()
          }
        ],
        "border-color": [
          {
            border: [
              borderColor
            ]
          }
        ],
        "border-color-x": [
          {
            "border-x": [
              borderColor
            ]
          }
        ],
        "border-color-y": [
          {
            "border-y": [
              borderColor
            ]
          }
        ],
        "border-color-s": [
          {
            "border-s": [
              borderColor
            ]
          }
        ],
        "border-color-e": [
          {
            "border-e": [
              borderColor
            ]
          }
        ],
        "border-color-t": [
          {
            "border-t": [
              borderColor
            ]
          }
        ],
        "border-color-r": [
          {
            "border-r": [
              borderColor
            ]
          }
        ],
        "border-color-b": [
          {
            "border-b": [
              borderColor
            ]
          }
        ],
        "border-color-l": [
          {
            "border-l": [
              borderColor
            ]
          }
        ],
        "divide-color": [
          {
            divide: [
              borderColor
            ]
          }
        ],
        "outline-style": [
          {
            outline: [
              "",
              ...getLineStyles()
            ]
          }
        ],
        "outline-offset": [
          {
            "outline-offset": [
              isLength,
              isArbitraryValue
            ]
          }
        ],
        "outline-w": [
          {
            outline: [
              isLength,
              isArbitraryLength
            ]
          }
        ],
        "outline-color": [
          {
            outline: [
              colors
            ]
          }
        ],
        "ring-w": [
          {
            ring: getLengthWithEmptyAndArbitrary()
          }
        ],
        "ring-w-inset": [
          "ring-inset"
        ],
        "ring-color": [
          {
            ring: [
              colors
            ]
          }
        ],
        "ring-opacity": [
          {
            "ring-opacity": [
              opacity
            ]
          }
        ],
        "ring-offset-w": [
          {
            "ring-offset": [
              isLength,
              isArbitraryLength
            ]
          }
        ],
        "ring-offset-color": [
          {
            "ring-offset": [
              colors
            ]
          }
        ],
        shadow: [
          {
            shadow: [
              "",
              "inner",
              "none",
              isTshirtSize,
              isArbitraryShadow
            ]
          }
        ],
        "shadow-color": [
          {
            shadow: [
              isAny
            ]
          }
        ],
        opacity: [
          {
            opacity: [
              opacity
            ]
          }
        ],
        "mix-blend": [
          {
            "mix-blend": [
              ...getBlendModes(),
              "plus-lighter",
              "plus-darker"
            ]
          }
        ],
        "bg-blend": [
          {
            "bg-blend": getBlendModes()
          }
        ],
        filter: [
          {
            filter: [
              "",
              "none"
            ]
          }
        ],
        blur: [
          {
            blur: [
              blur
            ]
          }
        ],
        brightness: [
          {
            brightness: [
              brightness
            ]
          }
        ],
        contrast: [
          {
            contrast: [
              contrast
            ]
          }
        ],
        "drop-shadow": [
          {
            "drop-shadow": [
              "",
              "none",
              isTshirtSize,
              isArbitraryValue
            ]
          }
        ],
        grayscale: [
          {
            grayscale: [
              grayscale
            ]
          }
        ],
        "hue-rotate": [
          {
            "hue-rotate": [
              hueRotate
            ]
          }
        ],
        invert: [
          {
            invert: [
              invert
            ]
          }
        ],
        saturate: [
          {
            saturate: [
              saturate
            ]
          }
        ],
        sepia: [
          {
            sepia: [
              sepia
            ]
          }
        ],
        "backdrop-filter": [
          {
            "backdrop-filter": [
              "",
              "none"
            ]
          }
        ],
        "backdrop-blur": [
          {
            "backdrop-blur": [
              blur
            ]
          }
        ],
        "backdrop-brightness": [
          {
            "backdrop-brightness": [
              brightness
            ]
          }
        ],
        "backdrop-contrast": [
          {
            "backdrop-contrast": [
              contrast
            ]
          }
        ],
        "backdrop-grayscale": [
          {
            "backdrop-grayscale": [
              grayscale
            ]
          }
        ],
        "backdrop-hue-rotate": [
          {
            "backdrop-hue-rotate": [
              hueRotate
            ]
          }
        ],
        "backdrop-invert": [
          {
            "backdrop-invert": [
              invert
            ]
          }
        ],
        "backdrop-opacity": [
          {
            "backdrop-opacity": [
              opacity
            ]
          }
        ],
        "backdrop-saturate": [
          {
            "backdrop-saturate": [
              saturate
            ]
          }
        ],
        "backdrop-sepia": [
          {
            "backdrop-sepia": [
              sepia
            ]
          }
        ],
        "border-collapse": [
          {
            border: [
              "collapse",
              "separate"
            ]
          }
        ],
        "border-spacing": [
          {
            "border-spacing": [
              borderSpacing
            ]
          }
        ],
        "border-spacing-x": [
          {
            "border-spacing-x": [
              borderSpacing
            ]
          }
        ],
        "border-spacing-y": [
          {
            "border-spacing-y": [
              borderSpacing
            ]
          }
        ],
        "table-layout": [
          {
            table: [
              "auto",
              "fixed"
            ]
          }
        ],
        caption: [
          {
            caption: [
              "top",
              "bottom"
            ]
          }
        ],
        transition: [
          {
            transition: [
              "none",
              "all",
              "",
              "colors",
              "opacity",
              "shadow",
              "transform",
              isArbitraryValue
            ]
          }
        ],
        duration: [
          {
            duration: getNumberAndArbitrary()
          }
        ],
        ease: [
          {
            ease: [
              "linear",
              "in",
              "out",
              "in-out",
              isArbitraryValue
            ]
          }
        ],
        delay: [
          {
            delay: getNumberAndArbitrary()
          }
        ],
        animate: [
          {
            animate: [
              "none",
              "spin",
              "ping",
              "pulse",
              "bounce",
              isArbitraryValue
            ]
          }
        ],
        transform: [
          {
            transform: [
              "",
              "gpu",
              "none"
            ]
          }
        ],
        scale: [
          {
            scale: [
              scale2
            ]
          }
        ],
        "scale-x": [
          {
            "scale-x": [
              scale2
            ]
          }
        ],
        "scale-y": [
          {
            "scale-y": [
              scale2
            ]
          }
        ],
        rotate: [
          {
            rotate: [
              isInteger$1,
              isArbitraryValue
            ]
          }
        ],
        "translate-x": [
          {
            "translate-x": [
              translate
            ]
          }
        ],
        "translate-y": [
          {
            "translate-y": [
              translate
            ]
          }
        ],
        "skew-x": [
          {
            "skew-x": [
              skew
            ]
          }
        ],
        "skew-y": [
          {
            "skew-y": [
              skew
            ]
          }
        ],
        "transform-origin": [
          {
            origin: [
              "center",
              "top",
              "top-right",
              "right",
              "bottom-right",
              "bottom",
              "bottom-left",
              "left",
              "top-left",
              isArbitraryValue
            ]
          }
        ],
        accent: [
          {
            accent: [
              "auto",
              colors
            ]
          }
        ],
        appearance: [
          {
            appearance: [
              "none",
              "auto"
            ]
          }
        ],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              isArbitraryValue
            ]
          }
        ],
        "caret-color": [
          {
            caret: [
              colors
            ]
          }
        ],
        "pointer-events": [
          {
            "pointer-events": [
              "none",
              "auto"
            ]
          }
        ],
        resize: [
          {
            resize: [
              "none",
              "y",
              "x",
              ""
            ]
          }
        ],
        "scroll-behavior": [
          {
            scroll: [
              "auto",
              "smooth"
            ]
          }
        ],
        "scroll-m": [
          {
            "scroll-m": getSpacingWithArbitrary()
          }
        ],
        "scroll-mx": [
          {
            "scroll-mx": getSpacingWithArbitrary()
          }
        ],
        "scroll-my": [
          {
            "scroll-my": getSpacingWithArbitrary()
          }
        ],
        "scroll-ms": [
          {
            "scroll-ms": getSpacingWithArbitrary()
          }
        ],
        "scroll-me": [
          {
            "scroll-me": getSpacingWithArbitrary()
          }
        ],
        "scroll-mt": [
          {
            "scroll-mt": getSpacingWithArbitrary()
          }
        ],
        "scroll-mr": [
          {
            "scroll-mr": getSpacingWithArbitrary()
          }
        ],
        "scroll-mb": [
          {
            "scroll-mb": getSpacingWithArbitrary()
          }
        ],
        "scroll-ml": [
          {
            "scroll-ml": getSpacingWithArbitrary()
          }
        ],
        "scroll-p": [
          {
            "scroll-p": getSpacingWithArbitrary()
          }
        ],
        "scroll-px": [
          {
            "scroll-px": getSpacingWithArbitrary()
          }
        ],
        "scroll-py": [
          {
            "scroll-py": getSpacingWithArbitrary()
          }
        ],
        "scroll-ps": [
          {
            "scroll-ps": getSpacingWithArbitrary()
          }
        ],
        "scroll-pe": [
          {
            "scroll-pe": getSpacingWithArbitrary()
          }
        ],
        "scroll-pt": [
          {
            "scroll-pt": getSpacingWithArbitrary()
          }
        ],
        "scroll-pr": [
          {
            "scroll-pr": getSpacingWithArbitrary()
          }
        ],
        "scroll-pb": [
          {
            "scroll-pb": getSpacingWithArbitrary()
          }
        ],
        "scroll-pl": [
          {
            "scroll-pl": getSpacingWithArbitrary()
          }
        ],
        "snap-align": [
          {
            snap: [
              "start",
              "end",
              "center",
              "align-none"
            ]
          }
        ],
        "snap-stop": [
          {
            snap: [
              "normal",
              "always"
            ]
          }
        ],
        "snap-type": [
          {
            snap: [
              "none",
              "x",
              "y",
              "both"
            ]
          }
        ],
        "snap-strictness": [
          {
            snap: [
              "mandatory",
              "proximity"
            ]
          }
        ],
        touch: [
          {
            touch: [
              "auto",
              "none",
              "manipulation"
            ]
          }
        ],
        "touch-x": [
          {
            "touch-pan": [
              "x",
              "left",
              "right"
            ]
          }
        ],
        "touch-y": [
          {
            "touch-pan": [
              "y",
              "up",
              "down"
            ]
          }
        ],
        "touch-pz": [
          "touch-pinch-zoom"
        ],
        select: [
          {
            select: [
              "none",
              "text",
              "all",
              "auto"
            ]
          }
        ],
        "will-change": [
          {
            "will-change": [
              "auto",
              "scroll",
              "contents",
              "transform",
              isArbitraryValue
            ]
          }
        ],
        fill: [
          {
            fill: [
              colors,
              "none"
            ]
          }
        ],
        "stroke-w": [
          {
            stroke: [
              isLength,
              isArbitraryLength,
              isArbitraryNumber
            ]
          }
        ],
        stroke: [
          {
            stroke: [
              colors,
              "none"
            ]
          }
        ],
        sr: [
          "sr-only",
          "not-sr-only"
        ],
        "forced-color-adjust": [
          {
            "forced-color-adjust": [
              "auto",
              "none"
            ]
          }
        ]
      },
      conflictingClassGroups: {
        overflow: [
          "overflow-x",
          "overflow-y"
        ],
        overscroll: [
          "overscroll-x",
          "overscroll-y"
        ],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left"
        ],
        "inset-x": [
          "right",
          "left"
        ],
        "inset-y": [
          "top",
          "bottom"
        ],
        flex: [
          "basis",
          "grow",
          "shrink"
        ],
        gap: [
          "gap-x",
          "gap-y"
        ],
        p: [
          "px",
          "py",
          "ps",
          "pe",
          "pt",
          "pr",
          "pb",
          "pl"
        ],
        px: [
          "pr",
          "pl"
        ],
        py: [
          "pt",
          "pb"
        ],
        m: [
          "mx",
          "my",
          "ms",
          "me",
          "mt",
          "mr",
          "mb",
          "ml"
        ],
        mx: [
          "mr",
          "ml"
        ],
        my: [
          "mt",
          "mb"
        ],
        size: [
          "w",
          "h"
        ],
        "font-size": [
          "leading"
        ],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction"
        ],
        "fvn-ordinal": [
          "fvn-normal"
        ],
        "fvn-slashed-zero": [
          "fvn-normal"
        ],
        "fvn-figure": [
          "fvn-normal"
        ],
        "fvn-spacing": [
          "fvn-normal"
        ],
        "fvn-fraction": [
          "fvn-normal"
        ],
        "line-clamp": [
          "display",
          "overflow"
        ],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-s": [
          "rounded-ss",
          "rounded-es"
        ],
        "rounded-e": [
          "rounded-se",
          "rounded-ee"
        ],
        "rounded-t": [
          "rounded-tl",
          "rounded-tr"
        ],
        "rounded-r": [
          "rounded-tr",
          "rounded-br"
        ],
        "rounded-b": [
          "rounded-br",
          "rounded-bl"
        ],
        "rounded-l": [
          "rounded-tl",
          "rounded-bl"
        ],
        "border-spacing": [
          "border-spacing-x",
          "border-spacing-y"
        ],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l"
        ],
        "border-w-x": [
          "border-w-r",
          "border-w-l"
        ],
        "border-w-y": [
          "border-w-t",
          "border-w-b"
        ],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l"
        ],
        "border-color-x": [
          "border-color-r",
          "border-color-l"
        ],
        "border-color-y": [
          "border-color-t",
          "border-color-b"
        ],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml"
        ],
        "scroll-mx": [
          "scroll-mr",
          "scroll-ml"
        ],
        "scroll-my": [
          "scroll-mt",
          "scroll-mb"
        ],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl"
        ],
        "scroll-px": [
          "scroll-pr",
          "scroll-pl"
        ],
        "scroll-py": [
          "scroll-pt",
          "scroll-pb"
        ],
        touch: [
          "touch-x",
          "touch-y",
          "touch-pz"
        ],
        "touch-x": [
          "touch"
        ],
        "touch-y": [
          "touch"
        ],
        "touch-pz": [
          "touch"
        ]
      },
      conflictingClassGroupModifiers: {
        "font-size": [
          "leading"
        ]
      }
    };
  };
  twMerge = createTailwindMerge(getDefaultConfig);
  cn = function(...inputs) {
    return twMerge(clsx(inputs));
  };
  const ToastProvider = Provider$1;
  const ToastViewport = reactExports.forwardRef(({ className, ...props }, ref) => jsxRuntimeExports.jsx(Viewport, {
    ref,
    className: cn("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", className),
    ...props
  }));
  ToastViewport.displayName = Viewport.displayName;
  const toastVariants = cva("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  });
  const Toast = reactExports.forwardRef(({ className, variant, ...props }, ref) => {
    return jsxRuntimeExports.jsx(Root2, {
      ref,
      className: cn(toastVariants({
        variant
      }), className),
      ...props
    });
  });
  Toast.displayName = Root2.displayName;
  const ToastAction = reactExports.forwardRef(({ className, ...props }, ref) => jsxRuntimeExports.jsx(Action, {
    ref,
    className: cn("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive", className),
    ...props
  }));
  ToastAction.displayName = Action.displayName;
  const ToastClose = reactExports.forwardRef(({ className, ...props }, ref) => jsxRuntimeExports.jsx(Close, {
    ref,
    className: cn("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", className),
    "toast-close": "",
    ...props,
    children: jsxRuntimeExports.jsx(LazyIcon, {
      name: "x",
      className: "h-4 w-4"
    })
  }));
  ToastClose.displayName = Close.displayName;
  const ToastTitle = reactExports.forwardRef(({ className, ...props }, ref) => jsxRuntimeExports.jsx(Title, {
    ref,
    className: cn("text-sm font-semibold", className),
    ...props
  }));
  ToastTitle.displayName = Title.displayName;
  const ToastDescription = reactExports.forwardRef(({ className, ...props }, ref) => jsxRuntimeExports.jsx(Description, {
    ref,
    className: cn("text-sm opacity-90", className),
    ...props
  }));
  ToastDescription.displayName = Description.displayName;
  function Toaster() {
    const { toasts } = useToast();
    return jsxRuntimeExports.jsxs(ToastProvider, {
      children: [
        toasts.map(function({ id: id2, title, description, action, ...props }) {
          return jsxRuntimeExports.jsxs(Toast, {
            ...props,
            children: [
              jsxRuntimeExports.jsxs("div", {
                className: "grid gap-1",
                children: [
                  title && jsxRuntimeExports.jsx(ToastTitle, {
                    children: title
                  }),
                  description && jsxRuntimeExports.jsx(ToastDescription, {
                    children: description
                  })
                ]
              }),
              action,
              jsxRuntimeExports.jsx(ToastClose, {})
            ]
          }, id2);
        }),
        jsxRuntimeExports.jsx(ToastViewport, {})
      ]
    });
  }
  var __assign = function() {
    __assign = Object.assign || function(t2) {
      for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s = arguments[i2];
        for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __rest = function(s, e) {
    var t2 = {};
    for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0) t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2])) t2[p2[i2]] = s[p2[i2]];
    }
    return t2;
  };
  var symModalId = Symbol("NiceModalId");
  var initialState = {};
  var NiceModalContext = React.createContext(initialState);
  var NiceModalIdContext = React.createContext(null);
  var MODAL_REGISTRY = {};
  var ALREADY_MOUNTED = {};
  var uidSeed = 0;
  var dispatch = function() {
    throw new Error("No dispatch method detected, did you embed your app with NiceModal.Provider?");
  };
  var getUid = function() {
    return "_nice_modal_" + uidSeed++;
  };
  var reducer = function(state, action) {
    var _a, _b, _c;
    if (state === void 0) {
      state = initialState;
    }
    switch (action.type) {
      case "nice-modal/show": {
        var _d = action.payload, modalId = _d.modalId, args = _d.args;
        return __assign(__assign({}, state), (_a = {}, _a[modalId] = __assign(__assign({}, state[modalId]), {
          id: modalId,
          args,
          visible: !!ALREADY_MOUNTED[modalId],
          delayVisible: !ALREADY_MOUNTED[modalId]
        }), _a));
      }
      case "nice-modal/hide": {
        var modalId = action.payload.modalId;
        if (!state[modalId]) return state;
        return __assign(__assign({}, state), (_b = {}, _b[modalId] = __assign(__assign({}, state[modalId]), {
          visible: false
        }), _b));
      }
      case "nice-modal/remove": {
        var modalId = action.payload.modalId;
        var newState = __assign({}, state);
        delete newState[modalId];
        return newState;
      }
      case "nice-modal/set-flags": {
        var _e = action.payload, modalId = _e.modalId, flags = _e.flags;
        return __assign(__assign({}, state), (_c = {}, _c[modalId] = __assign(__assign({}, state[modalId]), flags), _c));
      }
      default:
        return state;
    }
  };
  function getModal(modalId) {
    var _a;
    return (_a = MODAL_REGISTRY[modalId]) === null || _a === void 0 ? void 0 : _a.comp;
  }
  function showModal(modalId, args) {
    return {
      type: "nice-modal/show",
      payload: {
        modalId,
        args
      }
    };
  }
  function setModalFlags(modalId, flags) {
    return {
      type: "nice-modal/set-flags",
      payload: {
        modalId,
        flags
      }
    };
  }
  function hideModal(modalId) {
    return {
      type: "nice-modal/hide",
      payload: {
        modalId
      }
    };
  }
  function removeModal(modalId) {
    return {
      type: "nice-modal/remove",
      payload: {
        modalId
      }
    };
  }
  var modalCallbacks = {};
  var hideModalCallbacks = {};
  var getModalId = function(modal) {
    if (typeof modal === "string") return modal;
    if (!modal[symModalId]) {
      modal[symModalId] = getUid();
    }
    return modal[symModalId];
  };
  function show(modal, args) {
    var modalId = getModalId(modal);
    if (typeof modal !== "string" && !MODAL_REGISTRY[modalId]) {
      register(modalId, modal);
    }
    dispatch(showModal(modalId, args));
    if (!modalCallbacks[modalId]) {
      var theResolve_1;
      var theReject_1;
      var promise = new Promise(function(resolve, reject) {
        theResolve_1 = resolve;
        theReject_1 = reject;
      });
      modalCallbacks[modalId] = {
        resolve: theResolve_1,
        reject: theReject_1,
        promise
      };
    }
    return modalCallbacks[modalId].promise;
  }
  function hide(modal) {
    var modalId = getModalId(modal);
    dispatch(hideModal(modalId));
    delete modalCallbacks[modalId];
    if (!hideModalCallbacks[modalId]) {
      var theResolve_2;
      var theReject_2;
      var promise = new Promise(function(resolve, reject) {
        theResolve_2 = resolve;
        theReject_2 = reject;
      });
      hideModalCallbacks[modalId] = {
        resolve: theResolve_2,
        reject: theReject_2,
        promise
      };
    }
    return hideModalCallbacks[modalId].promise;
  }
  var remove$1 = function(modal) {
    var modalId = getModalId(modal);
    dispatch(removeModal(modalId));
    delete modalCallbacks[modalId];
    delete hideModalCallbacks[modalId];
  };
  var setFlags = function(modalId, flags) {
    dispatch(setModalFlags(modalId, flags));
  };
  useModal = function(modal, args) {
    var modals = reactExports.useContext(NiceModalContext);
    var contextModalId = reactExports.useContext(NiceModalIdContext);
    var modalId = null;
    var isUseComponent = modal && typeof modal !== "string";
    if (!modal) {
      modalId = contextModalId;
    } else {
      modalId = getModalId(modal);
    }
    if (!modalId) throw new Error("No modal id found in NiceModal.useModal.");
    var mid = modalId;
    reactExports.useEffect(function() {
      if (isUseComponent && !MODAL_REGISTRY[mid]) {
        register(mid, modal, args);
      }
    }, [
      isUseComponent,
      mid,
      modal,
      args
    ]);
    var modalInfo = modals[mid];
    var showCallback = reactExports.useCallback(function(args2) {
      return show(mid, args2);
    }, [
      mid
    ]);
    var hideCallback = reactExports.useCallback(function() {
      return hide(mid);
    }, [
      mid
    ]);
    var removeCallback = reactExports.useCallback(function() {
      return remove$1(mid);
    }, [
      mid
    ]);
    var resolveCallback = reactExports.useCallback(function(args2) {
      var _a;
      (_a = modalCallbacks[mid]) === null || _a === void 0 ? void 0 : _a.resolve(args2);
      delete modalCallbacks[mid];
    }, [
      mid
    ]);
    var rejectCallback = reactExports.useCallback(function(args2) {
      var _a;
      (_a = modalCallbacks[mid]) === null || _a === void 0 ? void 0 : _a.reject(args2);
      delete modalCallbacks[mid];
    }, [
      mid
    ]);
    var resolveHide = reactExports.useCallback(function(args2) {
      var _a;
      (_a = hideModalCallbacks[mid]) === null || _a === void 0 ? void 0 : _a.resolve(args2);
      delete hideModalCallbacks[mid];
    }, [
      mid
    ]);
    return reactExports.useMemo(function() {
      return {
        id: mid,
        args: modalInfo === null || modalInfo === void 0 ? void 0 : modalInfo.args,
        visible: !!(modalInfo === null || modalInfo === void 0 ? void 0 : modalInfo.visible),
        keepMounted: !!(modalInfo === null || modalInfo === void 0 ? void 0 : modalInfo.keepMounted),
        show: showCallback,
        hide: hideCallback,
        remove: removeCallback,
        resolve: resolveCallback,
        reject: rejectCallback,
        resolveHide
      };
    }, [
      mid,
      modalInfo === null || modalInfo === void 0 ? void 0 : modalInfo.args,
      modalInfo === null || modalInfo === void 0 ? void 0 : modalInfo.visible,
      modalInfo === null || modalInfo === void 0 ? void 0 : modalInfo.keepMounted,
      showCallback,
      hideCallback,
      removeCallback,
      resolveCallback,
      rejectCallback,
      resolveHide
    ]);
  };
  create$1 = function(Comp) {
    return function(_a) {
      var _b;
      var defaultVisible = _a.defaultVisible, keepMounted = _a.keepMounted, id2 = _a.id, props = __rest(_a, [
        "defaultVisible",
        "keepMounted",
        "id"
      ]);
      var _c = useModal(id2), args = _c.args, show2 = _c.show;
      var modals = reactExports.useContext(NiceModalContext);
      var shouldMount = !!modals[id2];
      reactExports.useEffect(function() {
        if (defaultVisible) {
          show2();
        }
        ALREADY_MOUNTED[id2] = true;
        return function() {
          delete ALREADY_MOUNTED[id2];
        };
      }, [
        id2,
        show2,
        defaultVisible
      ]);
      reactExports.useEffect(function() {
        if (keepMounted) setFlags(id2, {
          keepMounted: true
        });
      }, [
        id2,
        keepMounted
      ]);
      var delayVisible = (_b = modals[id2]) === null || _b === void 0 ? void 0 : _b.delayVisible;
      reactExports.useEffect(function() {
        if (delayVisible) {
          show2(args);
        }
      }, [
        delayVisible,
        args,
        show2
      ]);
      if (!shouldMount) return null;
      return React.createElement(NiceModalIdContext.Provider, {
        value: id2
      }, React.createElement(Comp, __assign({}, props, args)));
    };
  };
  var register = function(id2, comp, props) {
    if (!MODAL_REGISTRY[id2]) {
      MODAL_REGISTRY[id2] = {
        comp,
        props
      };
    } else {
      MODAL_REGISTRY[id2].props = props;
    }
  };
  var unregister = function(id2) {
    delete MODAL_REGISTRY[id2];
  };
  var NiceModalPlaceholder = function() {
    var modals = reactExports.useContext(NiceModalContext);
    var visibleModalIds = Object.keys(modals).filter(function(id2) {
      return !!modals[id2];
    });
    visibleModalIds.forEach(function(id2) {
      if (!MODAL_REGISTRY[id2] && !ALREADY_MOUNTED[id2]) {
        console.warn("No modal found for id: " + id2 + ". Please check the id or if it is registered or declared via JSX.");
        return;
      }
    });
    var toRender = visibleModalIds.filter(function(id2) {
      return MODAL_REGISTRY[id2];
    }).map(function(id2) {
      return __assign({
        id: id2
      }, MODAL_REGISTRY[id2]);
    });
    return React.createElement(React.Fragment, null, toRender.map(function(t2) {
      return React.createElement(t2.comp, __assign({
        key: t2.id,
        id: t2.id
      }, t2.props));
    }));
  };
  var InnerContextProvider = function(_a) {
    var children = _a.children;
    var arr2 = reactExports.useReducer(reducer, initialState);
    var modals = arr2[0];
    dispatch = arr2[1];
    return React.createElement(NiceModalContext.Provider, {
      value: modals
    }, children, React.createElement(NiceModalPlaceholder, null));
  };
  var Provider = function(_a) {
    var children = _a.children, givenDispatch = _a.dispatch, givenModals = _a.modals;
    if (!givenDispatch || !givenModals) {
      return React.createElement(InnerContextProvider, null, children);
    }
    dispatch = givenDispatch;
    return React.createElement(NiceModalContext.Provider, {
      value: givenModals
    }, children, React.createElement(NiceModalPlaceholder, null));
  };
  var ModalDef = function(_a) {
    var id2 = _a.id, component = _a.component;
    reactExports.useEffect(function() {
      register(id2, component);
      return function() {
        unregister(id2);
      };
    }, [
      id2,
      component
    ]);
    return null;
  };
  var ModalHolder = function(_a) {
    var _b;
    var modal = _a.modal, _c = _a.handler, handler = _c === void 0 ? {} : _c, restProps = __rest(_a, [
      "modal",
      "handler"
    ]);
    var mid = reactExports.useMemo(function() {
      return getUid();
    }, []);
    var ModalComp = typeof modal === "string" ? (_b = MODAL_REGISTRY[modal]) === null || _b === void 0 ? void 0 : _b.comp : modal;
    if (!handler) {
      throw new Error("No handler found in NiceModal.ModalHolder.");
    }
    if (!ModalComp) {
      throw new Error("No modal found for id: " + modal + " in NiceModal.ModalHolder.");
    }
    handler.show = reactExports.useCallback(function(args) {
      return show(mid, args);
    }, [
      mid
    ]);
    handler.hide = reactExports.useCallback(function() {
      return hide(mid);
    }, [
      mid
    ]);
    return React.createElement(ModalComp, __assign({
      id: mid
    }, restProps));
  };
  var antdModal = function(modal) {
    return {
      visible: modal.visible,
      onOk: function() {
        return modal.hide();
      },
      onCancel: function() {
        return modal.hide();
      },
      afterClose: function() {
        modal.resolveHide();
        if (!modal.keepMounted) modal.remove();
      }
    };
  };
  var antdDrawer = function(modal) {
    return {
      visible: modal.visible,
      onClose: function() {
        return modal.hide();
      },
      afterVisibleChange: function(v2) {
        if (!v2) {
          modal.resolveHide();
        }
        !v2 && !modal.keepMounted && modal.remove();
      }
    };
  };
  var muiDialog = function(modal) {
    return {
      open: modal.visible,
      onClose: function() {
        return modal.hide();
      },
      onExited: function() {
        modal.resolveHide();
        !modal.keepMounted && modal.remove();
      }
    };
  };
  var bootstrapDialog = function(modal) {
    return {
      show: modal.visible,
      onHide: function() {
        return modal.hide();
      },
      onExited: function() {
        modal.resolveHide();
        !modal.keepMounted && modal.remove();
      }
    };
  };
  var NiceModal = {
    Provider,
    ModalDef,
    ModalHolder,
    NiceModalContext,
    create: create$1,
    register,
    getModal,
    show,
    hide,
    remove: remove$1,
    useModal,
    reducer,
    antdModal,
    antdDrawer,
    muiDialog,
    bootstrapDialog
  };
  const ANSI_BACKGROUND_OFFSET = 10;
  const wrapAnsi16 = (offset = 0) => (code2) => `\x1B[${code2 + offset}m`;
  const wrapAnsi256 = (offset = 0) => (code2) => `\x1B[${38 + offset};5;${code2}m`;
  const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  const styles$2 = {
    modifier: {
      reset: [
        0,
        0
      ],
      bold: [
        1,
        22
      ],
      dim: [
        2,
        22
      ],
      italic: [
        3,
        23
      ],
      underline: [
        4,
        24
      ],
      overline: [
        53,
        55
      ],
      inverse: [
        7,
        27
      ],
      hidden: [
        8,
        28
      ],
      strikethrough: [
        9,
        29
      ]
    },
    color: {
      black: [
        30,
        39
      ],
      red: [
        31,
        39
      ],
      green: [
        32,
        39
      ],
      yellow: [
        33,
        39
      ],
      blue: [
        34,
        39
      ],
      magenta: [
        35,
        39
      ],
      cyan: [
        36,
        39
      ],
      white: [
        37,
        39
      ],
      blackBright: [
        90,
        39
      ],
      gray: [
        90,
        39
      ],
      grey: [
        90,
        39
      ],
      redBright: [
        91,
        39
      ],
      greenBright: [
        92,
        39
      ],
      yellowBright: [
        93,
        39
      ],
      blueBright: [
        94,
        39
      ],
      magentaBright: [
        95,
        39
      ],
      cyanBright: [
        96,
        39
      ],
      whiteBright: [
        97,
        39
      ]
    },
    bgColor: {
      bgBlack: [
        40,
        49
      ],
      bgRed: [
        41,
        49
      ],
      bgGreen: [
        42,
        49
      ],
      bgYellow: [
        43,
        49
      ],
      bgBlue: [
        44,
        49
      ],
      bgMagenta: [
        45,
        49
      ],
      bgCyan: [
        46,
        49
      ],
      bgWhite: [
        47,
        49
      ],
      bgBlackBright: [
        100,
        49
      ],
      bgGray: [
        100,
        49
      ],
      bgGrey: [
        100,
        49
      ],
      bgRedBright: [
        101,
        49
      ],
      bgGreenBright: [
        102,
        49
      ],
      bgYellowBright: [
        103,
        49
      ],
      bgBlueBright: [
        104,
        49
      ],
      bgMagentaBright: [
        105,
        49
      ],
      bgCyanBright: [
        106,
        49
      ],
      bgWhiteBright: [
        107,
        49
      ]
    }
  };
  Object.keys(styles$2.modifier);
  const foregroundColorNames = Object.keys(styles$2.color);
  const backgroundColorNames = Object.keys(styles$2.bgColor);
  [
    ...foregroundColorNames,
    ...backgroundColorNames
  ];
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    for (const [groupName, group] of Object.entries(styles$2)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles$2[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles$2[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles$2, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles$2, "codes", {
      value: codes,
      enumerable: false
    });
    styles$2.color.close = "\x1B[39m";
    styles$2.bgColor.close = "\x1B[49m";
    styles$2.color.ansi = wrapAnsi16();
    styles$2.color.ansi256 = wrapAnsi256();
    styles$2.color.ansi16m = wrapAnsi16m();
    styles$2.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles$2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles$2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    Object.defineProperties(styles$2, {
      rgbToAnsi256: {
        value(red, green, blue) {
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value(hex2) {
          const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex2.toString(16));
          if (!matches) {
            return [
              0,
              0,
              0
            ];
          }
          let [colorString] = matches;
          if (colorString.length === 3) {
            colorString = [
              ...colorString
            ].map((character) => character + character).join("");
          }
          const integer = Number.parseInt(colorString, 16);
          return [
            integer >> 16 & 255,
            integer >> 8 & 255,
            integer & 255
          ];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: (hex2) => styles$2.rgbToAnsi256(...styles$2.hexToRgb(hex2)),
        enumerable: false
      },
      ansi256ToAnsi: {
        value(code2) {
          if (code2 < 8) {
            return 30 + code2;
          }
          if (code2 < 16) {
            return 90 + (code2 - 8);
          }
          let red;
          let green;
          let blue;
          if (code2 >= 232) {
            red = ((code2 - 232) * 10 + 8) / 255;
            green = red;
            blue = red;
          } else {
            code2 -= 16;
            const remainder = code2 % 36;
            red = Math.floor(code2 / 36) / 5;
            green = Math.floor(remainder / 6) / 5;
            blue = remainder % 6 / 5;
          }
          const value = Math.max(red, green, blue) * 2;
          if (value === 0) {
            return 30;
          }
          let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
          if (value === 2) {
            result += 60;
          }
          return result;
        },
        enumerable: false
      },
      rgbToAnsi: {
        value: (red, green, blue) => styles$2.ansi256ToAnsi(styles$2.rgbToAnsi256(red, green, blue)),
        enumerable: false
      },
      hexToAnsi: {
        value: (hex2) => styles$2.ansi256ToAnsi(styles$2.hexToAnsi256(hex2)),
        enumerable: false
      }
    });
    return styles$2;
  }
  const ansiStyles$1 = assembleStyles();
  const level = (() => {
    if (navigator.userAgentData) {
      const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
      if (brand && brand.version > 93) {
        return 3;
      }
    }
    if (/\b(Chrome|Chromium)\//.test(navigator.userAgent)) {
      return 1;
    }
    return 0;
  })();
  const colorSupport = level !== 0 && {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
  const supportsColor = {
    stdout: colorSupport,
    stderr: colorSupport
  };
  function stringReplaceAll(string, substring, replacer) {
    let index2 = string.indexOf(substring);
    if (index2 === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.slice(endIndex, index2) + substring + replacer;
      endIndex = index2 + substringLength;
      index2 = string.indexOf(substring, endIndex);
    } while (index2 !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }
  function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index2) {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index2 - 1] === "\r";
      returnValue += string.slice(endIndex, gotCR ? index2 - 1 : index2) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index2 + 1;
      index2 = string.indexOf("\n", endIndex);
    } while (index2 !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }
  const { stdout: stdoutColor, stderr: stderrColor } = supportsColor;
  const GENERATOR = Symbol("GENERATOR");
  const STYLER = Symbol("STYLER");
  const IS_EMPTY = Symbol("IS_EMPTY");
  const levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  const styles$1 = /* @__PURE__ */ Object.create(null);
  const applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  const chalkFactory = (options) => {
    const chalk2 = (...strings) => strings.join(" ");
    applyOptions(chalk2, options);
    Object.setPrototypeOf(chalk2, createChalk.prototype);
    return chalk2;
  };
  function createChalk(options) {
    return chalkFactory(options);
  }
  Object.setPrototypeOf(createChalk.prototype, Function.prototype);
  for (const [styleName, style] of Object.entries(ansiStyles$1)) {
    styles$1[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        Object.defineProperty(this, styleName, {
          value: builder
        });
        return builder;
      }
    };
  }
  styles$1.visible = {
    get() {
      const builder = createBuilder(this, this[STYLER], true);
      Object.defineProperty(this, "visible", {
        value: builder
      });
      return builder;
    }
  };
  const getModelAnsi = (model, level2, type, ...arguments_) => {
    if (model === "rgb") {
      if (level2 === "ansi16m") {
        return ansiStyles$1[type].ansi16m(...arguments_);
      }
      if (level2 === "ansi256") {
        return ansiStyles$1[type].ansi256(ansiStyles$1.rgbToAnsi256(...arguments_));
      }
      return ansiStyles$1[type].ansi(ansiStyles$1.rgbToAnsi(...arguments_));
    }
    if (model === "hex") {
      return getModelAnsi("rgb", level2, type, ...ansiStyles$1.hexToRgb(...arguments_));
    }
    return ansiStyles$1[type][model](...arguments_);
  };
  const usedModels = [
    "rgb",
    "hex",
    "ansi256"
  ];
  for (const model of usedModels) {
    styles$1[model] = {
      get() {
        const { level: level2 } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level2], "color", ...arguments_), ansiStyles$1.color.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles$1[bgModel] = {
      get() {
        const { level: level2 } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level2], "bgColor", ...arguments_), ansiStyles$1.bgColor.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, {
    ...styles$1,
    level: {
      enumerable: true,
      get() {
        return this[GENERATOR].level;
      },
      set(level2) {
        this[GENERATOR].level = level2;
      }
    }
  });
  const createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  const createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self2;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
  };
  const applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2[IS_EMPTY] ? "" : string;
    }
    let styler = self2[STYLER];
    if (styler === void 0) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes("\x1B")) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  Object.defineProperties(createChalk.prototype, styles$1);
  const chalk = createChalk();
  createChalk({
    level: stderrColor ? stderrColor.level : 0
  });
  const __vite_import_meta_env__$1 = {
    "BASE_URL": "/NoLLMChat/",
    "DEV": false,
    "MODE": "production",
    "PROD": true,
    "SSR": false,
    "VITE_BASE_URL": "/NoLLMChat/"
  };
  isDev = (() => {
    if (typeof __vite_import_meta_env__$1 !== "undefined" && false) {
      return true;
    }
    if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
      return window.localStorage.getItem("__DEBUG__") === "true";
    }
    return false;
  })();
  const log = console.log;
  const stringify$1 = (...args) => args.map((arg) => typeof arg === "object" ? JSON.stringify(arg) : arg).join("\n");
  logError = (...args) => {
    log(chalk.redBright("ERROR:"));
    console.error(...args);
    log(chalk.redBright("-".repeat(10)));
  };
  logWarn = (...args) => {
    log(chalk.yellowBright("WARN:"));
    console.warn(...args);
    log(chalk.yellowBright("-".repeat(10)));
  };
  logDebug = (...args) => isDev ? log(chalk.greenBright(stringify$1(...args))) : void 0;
  let appFileSystem;
  let process$2;
  const FILE_SYSTEM_DB_NAME = "file_system";
  const initIndexedDb = () => {
    if (process$2) {
      return process$2;
    }
    process$2 = new Promise((resolve, reject) => {
      const request = indexedDB.open(FILE_SYSTEM_DB_NAME, 1);
      request.onerror = (event) => {
        var _a;
        if ((event == null ? void 0 : event.target) && "error" in event.target) {
          reject((_a = event.target) == null ? void 0 : _a.error);
        }
      };
      request.onsuccess = (event) => {
        if ((event == null ? void 0 : event.target) && "result" in event.target) {
          resolve(event.target.result);
        }
      };
      request.onupgradeneeded = (event) => {
        var _a;
        if ((event == null ? void 0 : event.target) && "result" in event.target) {
          const db2 = (_a = event.target) == null ? void 0 : _a.result;
          const objectStore = db2.createObjectStore("files", {
            keyPath: "path"
          });
          objectStore.createIndex("path", "path", {
            unique: true
          });
        }
      };
    }).then((db2) => {
      appFileSystem = db2;
      process$2 = void 0;
      return appFileSystem;
    });
    return process$2;
  };
  const FileSystemProvider = ({ children }) => {
    reactExports.useLayoutEffect(() => {
      const init = async () => {
        try {
          await initIndexedDb();
        } finally {
          window.removeEventListener("load", init);
        }
      };
      window.addEventListener("load", init);
      return () => {
        window.removeEventListener("load", init);
      };
    }, []);
    return children;
  };
  const createStoreImpl = (createState2) => {
    let state;
    const listeners2 = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners2.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState2;
    const subscribe = (listener) => {
      listeners2.add(listener);
      return () => listeners2.delete(listener);
    };
    const api = {
      setState,
      getState,
      getInitialState,
      subscribe
    };
    const initialState2 = state = createState2(setState, getState, api);
    return api;
  };
  const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
  const identity = (arg) => arg;
  function useStore(api, selector = identity) {
    const slice = React.useSyncExternalStore(api.subscribe, () => selector(api.getState()), () => selector(api.getInitialState()));
    React.useDebugValue(slice);
    return slice;
  }
  const createImpl = (createState2) => {
    const api = createStore(createState2);
    const useBoundStore = (selector) => useStore(api, selector);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  create = (createState2) => createImpl;
  const __vite_import_meta_env__ = {
    "BASE_URL": "/NoLLMChat/",
    "DEV": false,
    "MODE": "production",
    "PROD": true,
    "SSR": false,
    "VITE_BASE_URL": "/NoLLMChat/"
  };
  const trackedConnections = /* @__PURE__ */ new Map();
  const getTrackedConnectionState = (name) => {
    const api = trackedConnections.get(name);
    if (!api) return {};
    return Object.fromEntries(Object.entries(api.stores).map(([key, api2]) => [
      key,
      api2.getState()
    ]));
  };
  const extractConnectionInformation = (store, extensionConnector, options) => {
    if (store === void 0) {
      return {
        type: "untracked",
        connection: extensionConnector.connect(options)
      };
    }
    const existingConnection = trackedConnections.get(options.name);
    if (existingConnection) {
      return {
        type: "tracked",
        store,
        ...existingConnection
      };
    }
    const newConnection = {
      connection: extensionConnector.connect(options),
      stores: {}
    };
    trackedConnections.set(options.name, newConnection);
    return {
      type: "tracked",
      store,
      ...newConnection
    };
  };
  const devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get2, api) => {
    const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
    let extensionConnector;
    try {
      extensionConnector = (enabled != null ? enabled : (__vite_import_meta_env__ ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
    } catch (e) {
    }
    if (!extensionConnector) {
      return fn(set, get2, api);
    }
    const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
    let isRecording = true;
    api.setState = (state, replace, nameOrAction) => {
      const r2 = set(state, replace);
      if (!isRecording) return r2;
      const action = nameOrAction === void 0 ? {
        type: anonymousActionType || "anonymous"
      } : typeof nameOrAction === "string" ? {
        type: nameOrAction
      } : nameOrAction;
      if (store === void 0) {
        connection == null ? void 0 : connection.send(action, get2());
        return r2;
      }
      connection == null ? void 0 : connection.send({
        ...action,
        type: `${store}/${action.type}`
      }, {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      });
      return r2;
    };
    const setStateFromDevtools = (...a) => {
      const originalIsRecording = isRecording;
      isRecording = false;
      set(...a);
      isRecording = originalIsRecording;
    };
    const initialState2 = fn(api.setState, get2, api);
    if (connectionInformation.type === "untracked") {
      connection == null ? void 0 : connection.init(initialState2);
    } else {
      connectionInformation.stores[connectionInformation.store] = api;
      connection == null ? void 0 : connection.init(Object.fromEntries(Object.entries(connectionInformation.stores).map(([key, store2]) => [
        key,
        key === connectionInformation.store ? initialState2 : store2.getState()
      ])));
    }
    if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
      let didWarnAboutReservedActionType = false;
      const originalDispatch = api.dispatch;
      api.dispatch = (...a) => {
        if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
          console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
          didWarnAboutReservedActionType = true;
        }
        originalDispatch(...a);
      };
    }
    connection.subscribe((message) => {
      var _a;
      switch (message.type) {
        case "ACTION":
          if (typeof message.payload !== "string") {
            console.error("[zustand devtools middleware] Unsupported action format");
            return;
          }
          return parseJsonThen(message.payload, (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools) return;
            if (typeof api.dispatch !== "function") return;
            api.dispatch(action);
          });
        case "DISPATCH":
          switch (message.payload.type) {
            case "RESET":
              setStateFromDevtools(initialState2);
              if (store === void 0) {
                return connection == null ? void 0 : connection.init(api.getState());
              }
              return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            case "COMMIT":
              if (store === void 0) {
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            case "ROLLBACK":
              return parseJsonThen(message.state, (state) => {
                if (store === void 0) {
                  setStateFromDevtools(state);
                  connection == null ? void 0 : connection.init(api.getState());
                  return;
                }
                setStateFromDevtools(state[store]);
                connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              });
            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
              return parseJsonThen(message.state, (state) => {
                if (store === void 0) {
                  setStateFromDevtools(state);
                  return;
                }
                if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                  setStateFromDevtools(state[store]);
                }
              });
            case "IMPORT_STATE": {
              const { nextLiftedState } = message.payload;
              const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
              if (!lastComputedState) return;
              if (store === void 0) {
                setStateFromDevtools(lastComputedState);
              } else {
                setStateFromDevtools(lastComputedState[store]);
              }
              connection == null ? void 0 : connection.send(null, nextLiftedState);
              return;
            }
            case "PAUSE_RECORDING":
              return isRecording = !isRecording;
          }
          return;
      }
    });
    return initialState2;
  };
  devtools = devtoolsImpl;
  const parseJsonThen = (stringified, f2) => {
    let parsed;
    try {
      parsed = JSON.parse(stringified);
    } catch (e) {
      console.error("[zustand devtools middleware] Could not parse the received json", e);
    }
    if (parsed !== void 0) f2(parsed);
  };
  const subscribeWithSelectorImpl = (fn) => (set, get2, api) => {
    const origSubscribe = api.subscribe;
    api.subscribe = (selector, optListener, options) => {
      let listener = selector;
      if (optListener) {
        const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
        let currentSlice = selector(api.getState());
        listener = (state) => {
          const nextSlice = selector(state);
          if (!equalityFn(currentSlice, nextSlice)) {
            const previousSlice = currentSlice;
            optListener(currentSlice = nextSlice, previousSlice);
          }
        };
        if (options == null ? void 0 : options.fireImmediately) {
          optListener(currentSlice, currentSlice);
        }
      }
      return origSubscribe(listener);
    };
    const initialState2 = fn(set, get2, api);
    return initialState2;
  };
  subscribeWithSelector = subscribeWithSelectorImpl;
  function createJSONStorage(getStorage, options) {
    let storage;
    try {
      storage = getStorage();
    } catch (e) {
      return;
    }
    const persistStorage = {
      getItem: (name) => {
        var _a;
        const parse2 = (str2) => {
          if (str2 === null) {
            return null;
          }
          return JSON.parse(str2, void 0);
        };
        const str = (_a = storage.getItem(name)) != null ? _a : null;
        if (str instanceof Promise) {
          return str.then(parse2);
        }
        return parse2(str);
      },
      setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, void 0)),
      removeItem: (name) => storage.removeItem(name)
    };
    return persistStorage;
  }
  const toThenable = (fn) => (input) => {
    try {
      const result = fn(input);
      if (result instanceof Promise) {
        return result;
      }
      return {
        then(onFulfilled) {
          return toThenable(onFulfilled)(result);
        },
        catch(_onRejected) {
          return this;
        }
      };
    } catch (e) {
      return {
        then(_onFulfilled) {
          return this;
        },
        catch(onRejected) {
          return toThenable(onRejected)(e);
        }
      };
    }
  };
  const persistImpl = (config, baseOptions) => (set, get2, api) => {
    let options = {
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage = options.storage;
    if (!storage) {
      return config((...args) => {
        console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
        set(...args);
      }, get2, api);
    }
    const setItem = () => {
      const state = options.partialize({
        ...get2()
      });
      return storage.setItem(options.name, {
        state,
        version: options.version
      });
    };
    const savedSetState = api.setState;
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };
    const configResult = config((...args) => {
      set(...args);
      void setItem();
    }, get2, api);
    api.getInitialState = () => configResult;
    let stateFromStorage;
    const hydrate = () => {
      var _a, _b;
      if (!storage) return;
      hasHydrated = false;
      hydrationListeners.forEach((cb2) => {
        var _a2;
        return cb2((_a2 = get2()) != null ? _a2 : configResult);
      });
      const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get2()) != null ? _a : configResult)) || void 0;
      return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
            if (options.migrate) {
              return [
                true,
                options.migrate(deserializedStorageValue.state, deserializedStorageValue.version)
              ];
            }
            console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
          } else {
            return [
              false,
              deserializedStorageValue.state
            ];
          }
        }
        return [
          false,
          void 0
        ];
      }).then((migrationResult) => {
        var _a2;
        const [migrated, migratedState] = migrationResult;
        stateFromStorage = options.merge(migratedState, (_a2 = get2()) != null ? _a2 : configResult);
        set(stateFromStorage, true);
        if (migrated) {
          return setItem();
        }
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        stateFromStorage = get2();
        hasHydrated = true;
        finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
      }).catch((e) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options = {
          ...options,
          ...newOptions
        };
        if (newOptions.storage) {
          storage = newOptions.storage;
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options.name);
      },
      getOptions: () => options,
      rehydrate: () => hydrate(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb2) => {
        hydrationListeners.add(cb2);
        return () => {
          hydrationListeners.delete(cb2);
        };
      },
      onFinishHydration: (cb2) => {
        finishHydrationListeners.add(cb2);
        return () => {
          finishHydrationListeners.delete(cb2);
        };
      }
    };
    if (!options.skipHydration) {
      hydrate();
    }
    return stateFromStorage || configResult;
  };
  const persist = persistImpl;
  FlowNodeTypeEnum = ((FlowNodeTypeEnum2) => {
    FlowNodeTypeEnum2["Toolbox"] = "TOOLBOX";
    FlowNodeTypeEnum2["LLM"] = "LLM";
    FlowNodeTypeEnum2["NewMessage"] = "NEW_MESSAGE";
    FlowNodeTypeEnum2["Thread"] = "THREAD";
    FlowNodeTypeEnum2["Message"] = "MESSAGE";
    FlowNodeTypeEnum2["Prompt"] = "PROMPT";
    FlowNodeTypeEnum2["SessionInfo"] = "SESSION_INFO";
    FlowNodeTypeEnum2["Schema"] = "SCHEMA";
    FlowNodeTypeEnum2["ToolDefinition"] = "TOOL_DEFINITION";
    FlowNodeTypeEnum2["ToolHandler"] = "TOOL_HANDLER";
    FlowNodeTypeEnum2["FewShotExample"] = "FEW_SHOT_EXAMPLE";
    FlowNodeTypeEnum2["CSVData"] = "CSV_DATA";
    FlowNodeTypeEnum2["DefaultEmbeddingModel"] = "DEFAULT_EMBEDDING_MODEL";
    FlowNodeTypeEnum2["VectorDatabase"] = "VECTOR_DATABASE";
    FlowNodeTypeEnum2["JSONLData"] = "JSONL_DATA";
    FlowNodeTypeEnum2["ApplicationBar"] = "APPLICATION_BAR";
    FlowNodeTypeEnum2["Shape"] = "SHAPE";
    FlowNodeTypeEnum2["CircleShape"] = "CIRCLE_SHAPE";
    FlowNodeTypeEnum2["TriangleShape"] = "TRIANGLE_SHAPE";
    FlowNodeTypeEnum2["EditorApp"] = "EDITOR_APP";
    FlowNodeTypeEnum2["PlaceHolder"] = "PLACEHOLDER";
    FlowNodeTypeEnum2["CodeContainerApp"] = "CODE_CONTAINER_APP";
    FlowNodeTypeEnum2["VSLiteApp"] = "VSLITE_APP";
    FlowNodeTypeEnum2["JSONData"] = "JSON_DATA";
    return FlowNodeTypeEnum2;
  })(FlowNodeTypeEnum || {});
  SessionStatusEnum = ((SessionStatusEnum2) => {
    SessionStatusEnum2["Started"] = "started";
    SessionStatusEnum2["Done"] = "done";
    SessionStatusEnum2["Achieved"] = "Achieved";
    SessionStatusEnum2["Deleted"] = "deleted";
    return SessionStatusEnum2;
  })(SessionStatusEnum || {});
  SessionTypeEnum = ((SessionTypeEnum2) => {
    SessionTypeEnum2["Whiteboard"] = "Whiteboard";
    SessionTypeEnum2["StandaloneApp"] = "StandaloneApp";
    return SessionTypeEnum2;
  })(SessionTypeEnum || {});
  VectorDatabaseTypeEnum = ((VectorDatabaseTypeEnum2) => {
    VectorDatabaseTypeEnum2["Local"] = "local";
    VectorDatabaseTypeEnum2["Remote"] = "remote";
    return VectorDatabaseTypeEnum2;
  })(VectorDatabaseTypeEnum || {});
  VectorDatabaseProviderEnum = ((VectorDatabaseProviderEnum2) => {
    VectorDatabaseProviderEnum2["Voy"] = "voy";
    VectorDatabaseProviderEnum2["Memory"] = "memory";
    return VectorDatabaseProviderEnum2;
  })(VectorDatabaseProviderEnum || {});
  VectorDatabaseStorageEnum = ((VectorDatabaseStorageEnum2) => {
    VectorDatabaseStorageEnum2["DataNode"] = "DataNode";
    VectorDatabaseStorageEnum2["IndexedDB"] = "IndexedDB";
    return VectorDatabaseStorageEnum2;
  })(VectorDatabaseStorageEnum || {});
  flowNodeTypeToEntity = {
    [FlowNodeTypeEnum.Toolbox]: void 0,
    [FlowNodeTypeEnum.SessionInfo]: void 0,
    [FlowNodeTypeEnum.DefaultEmbeddingModel]: void 0,
    [FlowNodeTypeEnum.ApplicationBar]: void 0,
    [FlowNodeTypeEnum.Shape]: void 0,
    [FlowNodeTypeEnum.CircleShape]: void 0,
    [FlowNodeTypeEnum.TriangleShape]: void 0,
    [FlowNodeTypeEnum.EditorApp]: void 0,
    [FlowNodeTypeEnum.CodeContainerApp]: void 0,
    [FlowNodeTypeEnum.VSLiteApp]: void 0,
    [FlowNodeTypeEnum.NewMessage]: void 0,
    [FlowNodeTypeEnum.ToolHandler]: void 0,
    [FlowNodeTypeEnum.FewShotExample]: void 0,
    [FlowNodeTypeEnum.JSONData]: "JSONData",
    [FlowNodeTypeEnum.LLM]: "LLM",
    [FlowNodeTypeEnum.Thread]: "Thread",
    [FlowNodeTypeEnum.Message]: "Message",
    [FlowNodeTypeEnum.Prompt]: "Prompt",
    [FlowNodeTypeEnum.Schema]: "Schema",
    [FlowNodeTypeEnum.CSVData]: "CSVData",
    [FlowNodeTypeEnum.ToolDefinition]: "ToolDefinition",
    [FlowNodeTypeEnum.VectorDatabase]: "VectorDatabase",
    [FlowNodeTypeEnum.JSONLData]: "JSONLData",
    [FlowNodeTypeEnum.PlaceHolder]: "FlowNodePlaceholder"
  };
  const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  let random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
  let customRandom = (alphabet, defaultSize, getRandom) => {
    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size2 = defaultSize) => {
      let id2 = "";
      while (true) {
        let bytes = getRandom(step);
        let j = step;
        while (j--) {
          id2 += alphabet[bytes[j] & mask] || "";
          if (id2.length === size2) return id2;
        }
      }
    };
  };
  customAlphabet = (alphabet, size2 = 21) => customRandom(alphabet, size2, random);
  nanoid = (size2 = 21) => {
    let id2 = "";
    let bytes = crypto.getRandomValues(new Uint8Array(size2));
    while (size2--) {
      id2 += urlAlphabet[bytes[size2] & 63];
    }
    return id2;
  };
  const WOKER_INIT_MESSAGE_ID = "_WORKER_INIT_";
  async function sendToWorker(worker2, type, messageId, payload) {
    return worker2.postMessage({
      type,
      messageId,
      payload
    });
  }
  const workerMessagesHandler = (event, refProcesses2, callbacks) => {
    var _a, _b, _c, _d, _e;
    const messageId = event.data.messageId;
    if (!messageId) {
      return;
    }
    const { resolve, reject, processInfo } = (refProcesses2 == null ? void 0 : refProcesses2.get(messageId)) || {};
    if (messageId === WOKER_INIT_MESSAGE_ID) {
      (_a = callbacks == null ? void 0 : callbacks.onWorkerInit) == null ? void 0 : _a.call(callbacks, event);
    } else if ([
      "complete",
      "error"
    ].includes(event.data.type)) {
      if (event.data.type === "complete" && typeof resolve === "function") {
        resolve == null ? void 0 : resolve(event.data.payload);
        (_b = callbacks == null ? void 0 : callbacks.onComplete) == null ? void 0 : _b.call(callbacks, event);
      } else if (typeof reject === "function") {
        reject == null ? void 0 : reject(new Error(JSON.stringify(event.data.payload)));
        (_c = callbacks == null ? void 0 : callbacks.onError) == null ? void 0 : _c.call(callbacks, event);
      }
      refProcesses2.delete(messageId);
      (_d = callbacks == null ? void 0 : callbacks.onFinish) == null ? void 0 : _d.call(callbacks, event);
    } else if (event.data.type === "inprogress") {
      if (processInfo && typeof processInfo === "object" && "data" in processInfo && Array.isArray(processInfo == null ? void 0 : processInfo.data)) {
        processInfo.data.push(event.data.payload);
      }
      (_e = callbacks == null ? void 0 : callbacks.onProgress) == null ? void 0 : _e.call(callbacks, event);
    } else if (event.data.type === "started") ;
    else {
      logWarn("[Unknown message type]", event.data);
    }
  };
  const getEmptyPromise = (func) => {
    let result = {};
    const promise = new Promise((resolve, reject) => {
      result = {
        resolve,
        reject
      };
      if (func) {
        return func(resolve, reject);
      }
    });
    result.promise = promise;
    return result;
  };
  const isFindOperator = (value) => {
    return !!value && typeof value === "object" && "type" in value && "@instanceof" in value;
  };
  const transformQueryObjectToBridgeJSON = (data) => {
    if (data === void 0 || data === null || typeof data === "string" || typeof data === "number") {
      return data;
    }
    if (typeof data === "object") {
      if (Array.isArray(data)) {
        return data.map((item) => transformQueryObjectToBridgeJSON(item));
      }
      const transformed = {};
      Object.keys(data).forEach((key) => {
        const value = data[key];
        if (isFindOperator(value)) {
          transformed[key] = {
            "@instanceof": "FindOperator",
            type: value.type,
            value: value.value,
            useParameter: value.useParameter,
            multipleParameters: value.multipleParameters,
            getSql: typeof value.getSql === "function" ? value.getSql.toString() : void 0,
            objectLiteralParameters: value.objectLiteralParameters
          };
        } else if (value && typeof value === "object" && value !== null) {
          transformed[key] = transformQueryObjectToBridgeJSON(value);
        } else {
          transformed[key] = value;
        }
      });
      return transformed;
    }
    return data;
  };
  var WorkerExecutionType = ((WorkerExecutionType2) => {
    WorkerExecutionType2["INIT"] = "init";
    WorkerExecutionType2["REPOSITORY_EXECUTE"] = "repository-execute";
    WorkerExecutionType2["RAW_QUERY_EXECUTE"] = "raw-query-execute";
    return WorkerExecutionType2;
  })(WorkerExecutionType || {});
  const worker$2 = new Worker(new URL("/NoLLMChat/assets/database.worker-8jWyu_u9.js", import.meta.url), {
    type: "module"
  });
  const refProcesses = /* @__PURE__ */ new Map();
  const handleWorkerMessages = (event) => {
    return workerMessagesHandler(event, refProcesses, {
      onWorkerInit: () => {
      }
    });
  };
  const initDatabase = async () => {
    if (worker$2) {
      worker$2.removeEventListener("message", handleWorkerMessages);
    }
    worker$2.addEventListener("message", handleWorkerMessages);
  };
  const createProcessPromise = () => {
    const messageId = nanoid();
    const promiseInfo = getEmptyPromise();
    refProcesses.set(messageId, {
      promise: promiseInfo.promise,
      resolve: promiseInfo.resolve,
      reject: promiseInfo.reject
    });
    return {
      promise: promiseInfo.promise,
      messageId
    };
  };
  const repositoryExecute = async (entity, action, data) => {
    let messageId = "";
    try {
      if (!worker$2) {
        throw new Error("Worker not initialized");
      }
      const response = createProcessPromise();
      messageId = response.messageId;
      sendToWorker(worker$2, WorkerExecutionType.REPOSITORY_EXECUTE, messageId, [
        entity,
        action,
        data
      ]);
      return response.promise;
    } catch (err) {
      logWarn(`Error executing ${WorkerExecutionType.REPOSITORY_EXECUTE} action:`, err);
      if (messageId) {
        refProcesses.delete(messageId);
      }
      throw err;
    }
  };
  getRepository = (entity) => {
    return {
      find: (options) => {
        return repositoryExecute(entity, "find", transformQueryObjectToBridgeJSON(options));
      },
      findOne: (options) => {
        return repositoryExecute(entity, "findOne", transformQueryObjectToBridgeJSON(options));
      },
      count: (options) => {
        return repositoryExecute(entity, "count", transformQueryObjectToBridgeJSON(options));
      },
      delete: (id2) => {
        return repositoryExecute(entity, "delete", id2);
      },
      save: (data) => {
        return repositoryExecute(entity, "save", data);
      },
      update: (id2, update) => {
        return repositoryExecute(entity, "update", {
          id: id2,
          update
        });
      }
    };
  };
  initDatabase();
  const getAppStateActions = (set, get2) => {
    return {
      setLanguage: (language) => {
        const currentLanguage = get2().language;
        if (currentLanguage === language) return;
        set({
          language
        });
      },
      setTheme: (theme) => {
        const currentTheme = get2().theme;
        if (currentTheme === theme) return;
        set({
          theme
        });
      },
      setSelectedSessionId: (selectedSessionId) => {
        const currentSelectedSessionId = get2().selectedSessionId;
        if (currentSelectedSessionId === selectedSessionId) return;
        set({
          selectedSessionId
        });
      }
    };
  };
  const defaultAppState = {
    language: void 0,
    theme: "light",
    selectedSessionId: void 0
  };
  useAppState = create()(devtools(persist((set, get2) => ({
    ...defaultAppState,
    ...getAppStateActions(set, get2)
  }), {
    name: "app-storage",
    storage: createJSONStorage(() => localStorage)
  })));
  const getSessionStateActions = (set, get2) => {
    return {
      setCurrentSession: async (session) => {
        if (typeof session === "string" || !session) {
          session = session || useAppState.getState().selectedSessionId;
          let selectedSession = await getRepository("Session").findOne({
            where: {
              id: session
            }
          });
          if (!selectedSession) {
            selectedSession = await getRepository("Session").findOne({
              order: {
                updated_at: "DESC"
              }
            });
          }
          session = selectedSession;
        }
        useAppState.setState({
          selectedSessionId: session.id
        });
        let isExist = false;
        if (session.type === SessionTypeEnum.StandaloneApp) {
          const applications = get2().applications.map((item) => {
            if (item.id === session.id) {
              isExist = true;
              return session;
            }
            return item;
          });
          set({
            currentSession: session,
            applications: isExist ? applications : [
              session,
              ...get2().applications
            ]
          });
        } else {
          const sessions = get2().sessions.map((item) => {
            if (item.id === session.id) {
              isExist = true;
              return session;
            }
            return item;
          });
          set({
            currentSession: session,
            sessions: isExist ? sessions : [
              session,
              ...get2().sessions
            ]
          });
        }
        return session;
      },
      createSession: async (data) => {
        const session = await getRepository("Session").save({
          ...data,
          name: `${data.name}`,
          status: SessionStatusEnum.Started,
          type: SessionTypeEnum.Whiteboard
        });
        if (!session) {
          throw new Error("Failed create.");
        }
        set({
          sessions: [
            session,
            ...get2().sessions
          ]
        });
        return session;
      },
      deleteSession: async (id2) => {
        const session = await getRepository("Session").delete(id2);
        if (!session) {
          throw new Error("Failed delete.");
        }
        const currentSession = get2().currentSession;
        const sessions = get2().sessions;
        const applications = get2().applications;
        if ((currentSession == null ? void 0 : currentSession.type) === SessionTypeEnum.Whiteboard) {
          const newSessions = sessions.filter((s) => s.id !== id2);
          set({
            sessions: newSessions,
            ...(currentSession == null ? void 0 : currentSession.id) === id2 ? {
              currentSession: (newSessions == null ? void 0 : newSessions[0]) || (applications == null ? void 0 : applications[0])
            } : {}
          });
        } else {
          const newApplications = applications.filter((s) => s.id !== id2);
          set({
            applications: newApplications,
            ...(currentSession == null ? void 0 : currentSession.id) === id2 ? {
              currentSession: (newApplications == null ? void 0 : newApplications[0]) || (sessions == null ? void 0 : sessions[0])
            } : {}
          });
        }
      },
      init: () => {
        get2().getLatestApplications();
        get2().getLatestSessions();
      },
      getLatestApplications: async () => {
        try {
          const applications = await getRepository("Session").find({
            where: {
              type: SessionTypeEnum.StandaloneApp
            },
            order: {
              updated_at: "DESC"
            },
            take: 7
          });
          set({
            applications
          });
        } catch {
          set({
            error: "No application"
          });
        }
      },
      getLatestSessions: async () => {
        try {
          if (get2().ready) return;
          const sessions = await getRepository("Session").find({
            where: {
              status: SessionStatusEnum.Started,
              type: SessionTypeEnum.Whiteboard
            },
            order: {
              updated_at: "DESC"
            },
            take: 7
          });
          if (sessions == null ? void 0 : sessions.length) {
            set({
              sessions,
              ready: true
            });
          } else {
            const newSession = await getRepository("Session").save({
              name: "Default",
              status: SessionStatusEnum.Started,
              type: SessionTypeEnum.Whiteboard
            });
            if (newSession) {
              useAppState.setState({
                selectedSessionId: newSession.id
              });
              set({
                currentSession: newSession,
                sessions: [
                  newSession
                ],
                ready: true
              });
            } else {
              throw new Error("No session");
            }
          }
        } catch {
          set({
            error: "No session"
          });
        }
      }
    };
  };
  const defaultSessionState = {
    currentSession: void 0,
    ready: false,
    error: void 0,
    sessions: [],
    applications: []
  };
  useSessionState = create()(devtools((set, get2) => ({
    ...defaultSessionState,
    ...getSessionStateActions(set, get2)
  })));
  const DefaultError = reactExports.memo(({ error }) => {
    const { t: t2 } = useTranslation("common");
    return jsxRuntimeExports.jsxs("div", {
      className: "flex items-center justify-center h-screen",
      children: [
        jsxRuntimeExports.jsx(LazyIcon, {
          size: 30,
          name: "shield-alert"
        }),
        jsxRuntimeExports.jsx("div", {
          className: "ml-4 text-lg font-semibold text-center",
          children: error || t2("something_went_wrong")
        })
      ]
    });
  });
  function createDOMMotionComponentProxy(componentFactory) {
    if (typeof Proxy === "undefined") {
      return componentFactory;
    }
    const componentCache = /* @__PURE__ */ new Map();
    const deprecatedFactoryFunction = (...args) => {
      return componentFactory(...args);
    };
    return new Proxy(deprecatedFactoryFunction, {
      get: (_target, key) => {
        if (key === "create") return componentFactory;
        if (!componentCache.has(key)) {
          componentCache.set(key, componentFactory(key));
        }
        return componentCache.get(key);
      }
    });
  }
  function isAnimationControls(v2) {
    return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
  }
  const isKeyframesTarget = (v2) => {
    return Array.isArray(v2);
  };
  function shallowCompare(next, prev) {
    if (!Array.isArray(prev)) return false;
    const prevLength = prev.length;
    if (prevLength !== next.length) return false;
    for (let i2 = 0; i2 < prevLength; i2++) {
      if (prev[i2] !== next[i2]) return false;
    }
    return true;
  }
  function isVariantLabel(v2) {
    return typeof v2 === "string" || Array.isArray(v2);
  }
  function getValueState(visualElement) {
    const state = [
      {},
      {}
    ];
    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
      state[0][key] = value.get();
      state[1][key] = value.getVelocity();
    });
    return state;
  }
  function resolveVariantFromProps(props, definition, custom2, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom2 !== void 0 ? custom2 : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom2 !== void 0 ? custom2 : props.custom, current, velocity);
    }
    return definition;
  }
  function resolveVariant(visualElement, definition, custom2) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom2 !== void 0 ? custom2 : props.custom, visualElement);
  }
  const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  const variantProps = [
    "initial",
    ...variantPriorityOrder
  ];
  const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  const transformProps = new Set(transformPropOrder);
  const secondsToMilliseconds = (seconds) => seconds * 1e3;
  const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
  const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  const criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  const keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  const ease = {
    type: "keyframes",
    ease: [
      0.25,
      0.1,
      0.35,
      1
    ],
    duration: 0.3
  };
  const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };
  function getValueTransition(transition, key) {
    return transition ? transition[key] || transition["default"] || transition : void 0;
  }
  const MotionGlobalConfig = {
    skipAnimations: false,
    useManualTiming: false
  };
  const isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
  }
  const noop$1 = (any) => any;
  let invariant = noop$1;
  function createRenderStep(runNextFrame) {
    let thisFrame = /* @__PURE__ */ new Set();
    let nextFrame = /* @__PURE__ */ new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = /* @__PURE__ */ new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      callback(latestFrameData);
    }
    const step = {
      schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue2 = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive) toKeepAlive.add(callback);
        if (!queue2.has(callback)) queue2.add(callback);
        return callback;
      },
      cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
      process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [
          nextFrame,
          thisFrame
        ];
        nextFrame.clear();
        thisFrame.forEach(triggerCallback);
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }
  const stepsOrder = [
    "read",
    "resolveKeyframes",
    "update",
    "preRender",
    "render",
    "postRender"
  ];
  const maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame);
      return acc;
    }, {});
    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
    const processBatch = () => {
      const timestamp = performance.now();
      runNextFrame = false;
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
      state.timestamp = timestamp;
      state.isProcessing = true;
      read.process(state);
      resolveKeyframes.process(state);
      update.process(state);
      preRender.process(state);
      render.process(state);
      postRender.process(state);
      state.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame) wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i2 = 0; i2 < stepsOrder.length; i2++) {
        steps[stepsOrder[i2]].cancel(process2);
      }
    };
    return {
      schedule,
      cancel,
      state,
      steps
    };
  }
  let frameSteps;
  ({ schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$1, true));
  const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
  const subdivisionPrecision = 1e-7;
  const subdivisionMaxIterations = 12;
  function binarySubdivide(x2, lowerBound2, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i2 = 0;
    do {
      currentT = lowerBound2 + (upperBound - lowerBound2) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x2;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound2 = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2) return noop$1;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
  }
  const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
  const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
  const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
  const backIn = reverseEasing(backOut);
  const backInOut = mirrorEasing(backIn);
  const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
  const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
  const circOut = reverseEasing(circIn);
  const circInOut = mirrorEasing(circIn);
  const isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }
  const isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);
  const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
  const isCSSVariableName = checkStringStartsWith("--");
  const startsAsVariableToken = checkStringStartsWith("var(--");
  const isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken) return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  const splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
  function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match) return [
      ,
    ];
    const [, token1, token2, fallback] = match;
    return [
      `--${token1 !== null && token1 !== void 0 ? token1 : token2}`,
      fallback
    ];
  }
  function getVariableValue(current, element, depth = 1) {
    const [token, fallback] = parseCSSVariable(current);
    if (!token) return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
  }
  const clamp = (min, max, v2) => {
    if (v2 > max) return max;
    if (v2 < min) return min;
    return v2;
  };
  const number = {
    test: (v2) => typeof v2 === "number",
    parse: parseFloat,
    transform: (v2) => v2
  };
  const alpha = {
    ...number,
    transform: (v2) => clamp(0, 1, v2)
  };
  const scale = {
    ...number,
    default: 1
  };
  const createUnitType = (unit) => ({
    test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
    parse: parseFloat,
    transform: (v2) => `${v2}${unit}`
  });
  const degrees = createUnitType("deg");
  const percent = createUnitType("%");
  const px = createUnitType("px");
  const vh = createUnitType("vh");
  const vw = createUnitType("vw");
  const progressPercentage = {
    ...percent,
    parse: (v2) => percent.parse(v2) / 100,
    transform: (v2) => percent.transform(v2 * 100)
  };
  const positionalKeys = /* @__PURE__ */ new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY"
  ]);
  const isNumOrPxType = (v2) => v2 === number || v2 === px;
  const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
  const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
    if (transform === "none" || !transform) return 0;
    const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      const matrix = transform.match(/^matrix\((.+)\)$/u);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
  const transformKeys = /* @__PURE__ */ new Set([
    "x",
    "y",
    "z"
  ]);
  const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([
          key,
          value.get()
        ]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  const positionalValues = {
    width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
    right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;
  const testValueType = (v2) => (type) => type.test(v2);
  const auto = {
    test: (v2) => v2 === "auto",
    parse: (v2) => v2
  };
  const dimensionValueTypes = [
    number,
    px,
    percent,
    degrees,
    vw,
    vh,
    auto
  ];
  const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
  const toResolve = /* @__PURE__ */ new Set();
  let isScheduled = false;
  let anyNeedsMeasurement = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = /* @__PURE__ */ new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length) return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            var _a;
            (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete());
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    readAllKeyframes();
    measureAllKeyframes();
  }
  class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync2 = false) {
      this.isComplete = false;
      this.isAsync = false;
      this.needsMeasurement = false;
      this.isScheduled = false;
      this.unresolvedKeyframes = [
        ...unresolvedKeyframes
      ];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync2;
    }
    scheduleResolve() {
      this.isScheduled = true;
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        if (unresolvedKeyframes[i2] === null) {
          if (i2 === 0) {
            const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
            const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
            if (currentValue !== void 0) {
              unresolvedKeyframes[0] = currentValue;
            } else if (element && name) {
              const valueAsRead = element.readValue(name, finalKeyframe);
              if (valueAsRead !== void 0 && valueAsRead !== null) {
                unresolvedKeyframes[0] = valueAsRead;
              }
            }
            if (unresolvedKeyframes[0] === void 0) {
              unresolvedKeyframes[0] = finalKeyframe;
            }
            if (motionValue2 && currentValue === void 0) {
              motionValue2.set(unresolvedKeyframes[0]);
            }
          } else {
            unresolvedKeyframes[i2] = unresolvedKeyframes[i2 - 1];
          }
        }
      }
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete() {
      this.isComplete = true;
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
      toResolve.delete(this);
    }
    cancel() {
      if (!this.isComplete) {
        this.isScheduled = false;
        toResolve.delete(this);
      }
    }
    resume() {
      if (!this.isComplete) this.scheduleResolve();
    }
  }
  const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
  const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  function isNullish(v2) {
    return v2 == null;
  }
  const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
  const isColorString = (type, testProp) => (v2) => {
    return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
  };
  const splitColor = (aName, bName, cName) => (v2) => {
    if (typeof v2 !== "string") return v2;
    const [a, b, c, alpha2] = v2.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };
  const clampRgbUnit = (v2) => clamp(0, 255, v2);
  const rgbUnit = {
    ...number,
    transform: (v2) => Math.round(clampRgbUnit(v2))
  };
  const rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };
  function parseHex(v2) {
    let r2 = "";
    let g = "";
    let b = "";
    let a = "";
    if (v2.length > 5) {
      r2 = v2.substring(1, 3);
      g = v2.substring(3, 5);
      b = v2.substring(5, 7);
      a = v2.substring(7, 9);
    } else {
      r2 = v2.substring(1, 2);
      g = v2.substring(2, 3);
      b = v2.substring(3, 4);
      a = v2.substring(4, 5);
      r2 += r2;
      g += g;
      b += b;
      a += a;
    }
    return {
      red: parseInt(r2, 16),
      green: parseInt(g, 16),
      blue: parseInt(b, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };
  const hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };
  const color$1 = {
    test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
    parse: (v2) => {
      if (rgba.test(v2)) {
        return rgba.parse(v2);
      } else if (hsla.test(v2)) {
        return hsla.parse(v2);
      } else {
        return hex.parse(v2);
      }
    },
    transform: (v2) => {
      return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
    }
  };
  const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  function test(v2) {
    var _a, _b;
    return isNaN(v2) && typeof v2 === "string" && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
  }
  const NUMBER_TOKEN = "number";
  const COLOR_TOKEN = "color";
  const VAR_TOKEN = "var";
  const VAR_FUNCTION_TOKEN = "var(";
  const SPLIT_TOKEN = "${}";
  const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types = [];
    let i2 = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color$1.test(parsedValue)) {
        indexes.color.push(i2);
        types.push(COLOR_TOKEN);
        values.push(color$1.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i2);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i2);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i2;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return {
      values,
      split,
      indexes,
      types
    };
  }
  function parseComplexValue(v2) {
    return analyseComplexValue(v2).values;
  }
  function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v2) => {
      let output = "";
      for (let i2 = 0; i2 < numSections; i2++) {
        output += split[i2];
        if (v2[i2] !== void 0) {
          const type = types[i2];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v2[i2]);
          } else if (type === COLOR_TOKEN) {
            output += color$1.transform(v2[i2]);
          } else {
            output += v2[i2];
          }
        }
      }
      return output;
    };
  }
  const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
  function getAnimatableNone$1(v2) {
    const parsed = parseComplexValue(v2);
    const transformer = createTransformer(v2);
    return transformer(parsed.map(convertNumbersToZero));
  }
  const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
  };
  const maxDefaults = /* @__PURE__ */ new Set([
    "brightness",
    "contrast",
    "saturate",
    "opacity"
  ]);
  function applyDefaultFilter(v2) {
    const [name, value] = v2.slice(0, -1).split("(");
    if (name === "drop-shadow") return v2;
    const [number2] = value.match(floatRegex) || [];
    if (!number2) return v2;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number2 !== value) defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  const filter = {
    ...complex,
    getAnimatableNone: (v2) => {
      const functions = v2.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
    }
  };
  const browserNumberValueTypes = {
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    backgroundPositionX: px,
    backgroundPositionY: px
  };
  const transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };
  const int = {
    ...number,
    transform: Math.round
  };
  const numberValueTypes = {
    ...browserNumberValueTypes,
    ...transformValueTypes,
    zIndex: int,
    size: px,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };
  const defaultValueTypes = {
    ...numberValueTypes,
    color: color$1,
    backgroundColor: color$1,
    outlineColor: color$1,
    fill: color$1,
    stroke: color$1,
    borderColor: color$1,
    borderTopColor: color$1,
    borderRightColor: color$1,
    borderBottomColor: color$1,
    borderLeftColor: color$1,
    filter,
    WebkitFilter: filter
  };
  const getDefaultValueType = (key) => defaultValueTypes[key];
  function getAnimatableNone(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter) defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }
  const invalidTemplates = /* @__PURE__ */ new Set([
    "auto",
    "none",
    "0"
  ]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i2 = 0;
    let animatableTemplate = void 0;
    while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i2];
      }
      i2++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
      }
    }
  }
  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current) return;
      super.readKeyframes();
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        let keyframe = unresolvedKeyframes[i2];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i2] = resolved;
            }
            if (i2 === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      if (originType === targetType) return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
          const value = unresolvedKeyframes[i2];
          if (typeof value === "string") {
            unresolvedKeyframes[i2] = parseFloat(value);
          }
        }
      } else {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        if (isNone(unresolvedKeyframes[i2])) {
          noneKeyframeIndexes.push(i2);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current) return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      var _a;
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current) return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  }
  function isGenerator(type) {
    return typeof type === "function";
  }
  let now;
  function clearTime() {
    now = void 0;
  }
  const time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };
  const isAnimatable = (value, name) => {
    if (name === "zIndex") return false;
    if (typeof value === "number" || Array.isArray(value)) return true;
    if (typeof value === "string" && (complex.test(value) || value === "0") && !value.startsWith("url(")) {
      return true;
    }
    return false;
  };
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1) return true;
    for (let i2 = 0; i2 < keyframes2.length; i2++) {
      if (keyframes2[i2] !== current) return true;
    }
  }
  function canAnimate(keyframes2, name, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null) return false;
    if (name === "display" || name === "visibility") return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
  }
  const MAX_RESOLVE_DELAY = 40;
  class BaseAnimation {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
      this.isStopped = false;
      this.hasAttemptedResolve = false;
      this.createdAt = time.now();
      this.options = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        ...options
      };
      this.updateFinishedPromise();
    }
    calcStartTime() {
      if (!this.resolvedAt) return this.createdAt;
      return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
    }
    get resolved() {
      if (!this._resolved && !this.hasAttemptedResolve) {
        flushKeyframeResolvers();
      }
      return this._resolved;
    }
    onKeyframesResolved(keyframes2, finalKeyframe) {
      this.resolvedAt = time.now();
      this.hasAttemptedResolve = true;
      const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
      if (!isGenerator2 && !canAnimate(keyframes2, name, type, velocity)) {
        if (!delay2) {
          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
          onComplete === null || onComplete === void 0 ? void 0 : onComplete();
          this.resolveFinishedPromise();
          return;
        } else {
          this.options.duration = 0;
        }
      }
      const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
      if (resolvedAnimation === false) return;
      this._resolved = {
        keyframes: keyframes2,
        finalKeyframe,
        ...resolvedAnimation
      };
      this.onPostResolved();
    }
    onPostResolved() {
    }
    then(resolve, reject) {
      return this.currentFinishedPromise.then(resolve, reject);
    }
    flatten() {
      this.options.type = "keyframes";
      this.options.ease = "linear";
    }
    updateFinishedPromise() {
      this.currentFinishedPromise = new Promise((resolve) => {
        this.resolveFinishedPromise = resolve;
      });
    }
  }
  const progress = (from, to, value) => {
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
  };
  const generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i2 = 0; i2 < numPoints; i2++) {
      points += easing(progress(0, numPoints - 1, i2)) + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }
  const velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t2, current) {
    const prevT = Math.max(t2 - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
  }
  const springDefaults = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1
  };
  const safeMin = 1e-3;
  function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative;
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f2 = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e) * f2) / g;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b = (velocity - undampedFreq2) * (duration * duration);
        return a * b;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  const rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i2 = 1; i2 < rootIterations; i2++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }
  const maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }
  const durationKeys = [
    "duration",
    "bounce"
  ];
  const physicsKeys = [
    "stiffness",
    "damping",
    "mass"
  ];
  function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root * root;
        const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [
        0,
        1
      ],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    const state = {
      done: false,
      value: origin
    };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: -millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t2) => {
        const current = resolveSpring(t2);
        if (!isResolvedFromDuration) {
          let currentVelocity = 0;
          if (dampingRatio < 1) {
            currentVelocity = t2 === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state.done = t2 >= duration;
        }
        state.value = state.done ? target : current;
        return state;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      }
    };
    return generator;
  }
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max;
    const nearestBoundary = (v2) => {
      if (min === void 0) return max;
      if (max === void 0) return min;
      return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal) amplitude = target - origin;
    const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
    const calcLatest = (t2) => target + calcDelta(t2);
    const applyFriction = (t2) => {
      const delta = calcDelta(t2);
      const latest = calcLatest(t2);
      state.done = Math.abs(delta) <= restDelta;
      state.value = state.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t2) => {
      if (!isOutOfBounds(state.value)) return;
      timeReachedBoundary = t2;
      spring$1 = spring({
        keyframes: [
          state.value,
          nearestBoundary(state.value)
        ],
        velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
        damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t2) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t2);
          checkCatchBoundary(t2);
        }
        if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
          return spring$1.next(t2 - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t2);
          return state;
        }
      }
    };
  }
  const easeIn = cubicBezier(0.42, 0, 1, 1);
  const easeOut = cubicBezier(0, 0, 0.58, 1);
  const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
  const isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };
  const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
  const easingLookup = {
    linear: noop$1,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  const easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      invariant(definition.length === 4);
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (typeof definition === "string") {
      invariant(easingLookup[definition] !== void 0);
      return easingLookup[definition];
    }
    return definition;
  };
  const combineFunctions = (a, b) => (v2) => b(a(v2));
  const pipe = (...transformers) => transformers.reduce(combineFunctions);
  const mixNumber$1 = (from, to, progress2) => {
    return from + (to - from) * progress2;
  };
  function hueToRgb(p2, q2, t2) {
    if (t2 < 0) t2 += 1;
    if (t2 > 1) t2 -= 1;
    if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2) return q2;
    if (t2 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p2 = 2 * lightness - q2;
      red = hueToRgb(p2, q2, hue + 1 / 3);
      green = hueToRgb(p2, q2, hue);
      blue = hueToRgb(p2, q2, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }
  function mixImmediate(a, b) {
    return (p2) => p2 > 0 ? b : a;
  }
  const mixLinearColor = (from, to, v2) => {
    const fromExpo = from * from;
    const expo = v2 * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  const colorTypes = [
    hex,
    rgba,
    hsla
  ];
  const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
  function asRGBA(color2) {
    const type = getColorType(color2);
    if (!Boolean(type)) return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  const mixColor = (from, to) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from, to);
    }
    const blended = {
      ...fromRGBA
    };
    return (v2) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
      blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
      return rgba.transform(blended);
    };
  };
  const invisibleValues = /* @__PURE__ */ new Set([
    "none",
    "hidden"
  ]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p2) => p2 <= 0 ? origin : target;
    } else {
      return (p2) => p2 >= 1 ? target : origin;
    }
  }
  function mixNumber(a, b) {
    return (p2) => mixNumber$1(a, b, p2);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color$1.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color$1.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b) {
    const output = [
      ...a
    ];
    const numValues = output.length;
    const blendValue = a.map((v2, i2) => getMixer(v2)(v2, b[i2]));
    return (p2) => {
      for (let i2 = 0; i2 < numValues; i2++) {
        output[i2] = blendValue[i2](p2);
      }
      return output;
    };
  }
  function mixObject(a, b) {
    const output = {
      ...a,
      ...b
    };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b[key]);
      }
    }
    return (v2) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v2);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    var _a;
    const orderedOrigin = [];
    const pointers = {
      color: 0,
      var: 0,
      number: 0
    };
    for (let i2 = 0; i2 < target.values.length; i2++) {
      const type = target.types[i2];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
      orderedOrigin[i2] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  const mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      return mixImmediate(origin, target);
    }
  };
  function mix(from, to, p2) {
    if (typeof from === "number" && typeof to === "number" && typeof p2 === "number") {
      return mixNumber$1(from, to, p2);
    }
    const mixer = getMixer(from);
    return mixer(from, to);
  }
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || mix;
    const numMixers = output.length - 1;
    for (let i2 = 0; i2 < numMixers; i2++) {
      let mixer = mixerFactory(output[i2], output[i2 + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$1 : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  interpolate = function(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length);
    if (inputLength === 1) return () => output[0];
    if (inputLength === 2 && input[0] === input[1]) return () => output[1];
    if (input[0] > input[inputLength - 1]) {
      input = [
        ...input
      ].reverse();
      output = [
        ...output
      ].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v2) => {
      let i2 = 0;
      if (numMixers > 1) {
        for (; i2 < input.length - 2; i2++) {
          if (v2 < input[i2 + 1]) break;
        }
      }
      const progressInRange = progress(input[i2], input[i2 + 1], v2);
      return mixers[i2](progressInRange);
    };
    return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
  };
  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i2 = 1; i2 <= remaining; i2++) {
      const offsetProgress = progress(0, remaining, i2);
      offset.push(mixNumber$1(min, 1, offsetProgress));
    }
  }
  function defaultOffset(arr2) {
    const offset = [
      0
    ];
    fillOffset(offset, arr2.length - 1);
    return offset;
  }
  function convertOffsetToTimes(offset, duration) {
    return offset.map((o) => o * duration);
  }
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues), duration);
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t2) => {
        state.value = mapTimeToKeyframe(t2);
        state.done = t2 >= duration;
        return state;
      }
    };
  }
  const frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: () => frame.update(passTimestamp, true),
      stop: () => cancelFrame(passTimestamp),
      now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };
  const generators = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  const percentToProgress = (percent2) => percent2 / 100;
  class MainThreadAnimation extends BaseAnimation {
    constructor(options) {
      super(options);
      this.holdTime = null;
      this.cancelTime = null;
      this.currentTime = 0;
      this.playbackSpeed = 1;
      this.pendingPlayState = "running";
      this.startTime = null;
      this.state = "idle";
      this.stop = () => {
        this.resolver.cancel();
        this.isStopped = true;
        if (this.state === "idle") return;
        this.teardown();
        const { onStop } = this.options;
        onStop && onStop();
      };
      const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
      const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
      const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
      this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element);
      this.resolver.scheduleResolve();
    }
    flatten() {
      super.flatten();
      if (this._resolved) {
        Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
      }
    }
    initPlayback(keyframes$1) {
      const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
      const generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
      let mapPercentToKeyframes;
      let mirroredGenerator;
      if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
        mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
        keyframes$1 = [
          0,
          100
        ];
      }
      const generator = generatorFactory({
        ...this.options,
        keyframes: keyframes$1
      });
      if (repeatType === "mirror") {
        mirroredGenerator = generatorFactory({
          ...this.options,
          keyframes: [
            ...keyframes$1
          ].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      const resolvedDuration = calculatedDuration + repeatDelay;
      const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
      return {
        generator,
        mirroredGenerator,
        mapPercentToKeyframes,
        calculatedDuration,
        resolvedDuration,
        totalDuration
      };
    }
    onPostResolved() {
      const { autoplay = true } = this.options;
      this.play();
      if (this.pendingPlayState === "paused" || !autoplay) {
        this.pause();
      } else {
        this.state = this.pendingPlayState;
      }
    }
    tick(timestamp, sample = false) {
      const { resolved } = this;
      if (!resolved) {
        const { keyframes: keyframes3 } = this.options;
        return {
          done: true,
          value: keyframes3[keyframes3.length - 1]
        };
      }
      const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
      if (this.startTime === null) return generator.next(0);
      const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
      const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed2 = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed2 = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state = isInDelayPhase ? {
        done: false,
        value: keyframes2[0]
      } : frameGenerator.next(elapsed2);
      if (mapPercentToKeyframes) {
        state.value = mapPercentToKeyframes(state.value);
      }
      let { done } = state;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && finalKeyframe !== void 0) {
        state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
      }
      if (onUpdate) {
        onUpdate(state.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state;
    }
    get duration() {
      const { resolved } = this;
      return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.holdTime !== null || this.speed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.speed;
      }
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (!this.resolver.isScheduled) {
        this.resolver.resume();
      }
      if (!this._resolved) {
        this.pendingPlayState = "running";
        return;
      }
      if (this.isStopped) return;
      const { driver = frameloopDriver, onPlay, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      onPlay && onPlay();
      const now2 = this.driver.now();
      if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
      } else if (this.state === "finished") {
        this.startTime = now2;
      }
      if (this.state === "finished") {
        this.updateFinishedPromise();
      }
      this.cancelTime = this.startTime;
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      var _a;
      if (!this._resolved) {
        this.pendingPlayState = "paused";
        return;
      }
      this.state = "paused";
      this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.pendingPlayState = this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.teardown();
      this.state = "finished";
      const { onComplete } = this.options;
      onComplete && onComplete();
    }
    cancel() {
      if (this.cancelTime !== null) {
        this.tick(this.cancelTime);
      }
      this.teardown();
      this.updateFinishedPromise();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.resolveFinishedPromise();
      this.updateFinishedPromise();
      this.startTime = this.cancelTime = null;
      this.resolver.cancel();
    }
    stopDriver() {
      if (!this.driver) return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(time2) {
      this.startTime = 0;
      return this.tick(time2, true);
    }
  }
  animateValue = function(options) {
    return new MainThreadAnimation(options);
  };
  const acceleratedValues = /* @__PURE__ */ new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"
  ]);
  function memo(callback) {
    let result;
    return () => {
      if (result === void 0) result = callback();
      return result;
    };
  }
  const supportsFlags = {
    linearEasing: void 0
  };
  function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => {
      var _a;
      return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized();
    };
  }
  const supportsLinearEasing = memoSupports(() => {
    try {
      document.createElement("div").animate({
        opacity: 0
      }, {
        easing: "linear(0, 1)"
      });
    } catch (e) {
      return false;
    }
    return true;
  }, "linearEasing");
  function isWaapiSupportedEasing(easing) {
    return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
  }
  const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
  const supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([
      0,
      0.65,
      0.55,
      1
    ]),
    circOut: cubicBezierAsString([
      0.55,
      0,
      1,
      0.45
    ]),
    backIn: cubicBezierAsString([
      0.31,
      0.01,
      0.66,
      -0.59
    ]),
    backOut: cubicBezierAsString([
      0.33,
      1.53,
      0.69,
      0.99
    ])
  };
  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function" && supportsLinearEasing()) {
      return generateLinearEasing(easing, duration);
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }
  function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times) keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2, duration);
    if (Array.isArray(easing)) keyframeOptions.easing = easing;
    return element.animate(keyframeOptions, {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    });
  }
  function attachTimeline(animation, timeline) {
    animation.timeline = timeline;
    animation.onfinish = null;
  }
  const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  const sampleDelta = 10;
  const maxDuration = 2e4;
  function requiresPregeneratedKeyframes(options) {
    return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
  }
  function pregenerateKeyframes(keyframes2, options) {
    const sampleAnimation = new MainThreadAnimation({
      ...options,
      keyframes: keyframes2,
      repeat: 0,
      delay: 0,
      isGenerator: true
    });
    let state = {
      done: false,
      value: keyframes2[0]
    };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state.done && t2 < maxDuration) {
      state = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state.value);
      t2 += sampleDelta;
    }
    return {
      times: void 0,
      keyframes: pregeneratedKeyframes,
      duration: t2 - sampleDelta,
      ease: "linear"
    };
  }
  const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  class AcceleratedAnimation extends BaseAnimation {
    constructor(options) {
      super(options);
      const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
      this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element);
      this.resolver.scheduleResolve();
    }
    initPlayback(keyframes2, finalKeyframe) {
      var _a;
      let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name, startTime } = this.options;
      if (!((_a = motionValue2.owner) === null || _a === void 0 ? void 0 : _a.current)) {
        return false;
      }
      if (typeof ease2 === "string" && supportsLinearEasing() && isUnsupportedEase(ease2)) {
        ease2 = unsupportedEasingFunctions[ease2];
      }
      if (requiresPregeneratedKeyframes(this.options)) {
        const { onComplete, onUpdate, motionValue: motionValue3, element, ...options } = this.options;
        const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
        keyframes2 = pregeneratedAnimation.keyframes;
        if (keyframes2.length === 1) {
          keyframes2[1] = keyframes2[0];
        }
        duration = pregeneratedAnimation.duration;
        times = pregeneratedAnimation.times;
        ease2 = pregeneratedAnimation.ease;
        type = "keyframes";
      }
      const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, {
        ...this.options,
        duration,
        times,
        ease: ease2
      });
      animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
      if (this.pendingTimeline) {
        attachTimeline(animation, this.pendingTimeline);
        this.pendingTimeline = void 0;
      } else {
        animation.onfinish = () => {
          const { onComplete } = this.options;
          motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
          onComplete && onComplete();
          this.cancel();
          this.resolveFinishedPromise();
        };
      }
      return {
        animation,
        duration,
        times,
        type,
        ease: ease2,
        keyframes: keyframes2
      };
    }
    get duration() {
      const { resolved } = this;
      if (!resolved) return 0;
      const { duration } = resolved;
      return millisecondsToSeconds(duration);
    }
    get time() {
      const { resolved } = this;
      if (!resolved) return 0;
      const { animation } = resolved;
      return millisecondsToSeconds(animation.currentTime || 0);
    }
    set time(newTime) {
      const { resolved } = this;
      if (!resolved) return;
      const { animation } = resolved;
      animation.currentTime = secondsToMilliseconds(newTime);
    }
    get speed() {
      const { resolved } = this;
      if (!resolved) return 1;
      const { animation } = resolved;
      return animation.playbackRate;
    }
    set speed(newSpeed) {
      const { resolved } = this;
      if (!resolved) return;
      const { animation } = resolved;
      animation.playbackRate = newSpeed;
    }
    get state() {
      const { resolved } = this;
      if (!resolved) return "idle";
      const { animation } = resolved;
      return animation.playState;
    }
    get startTime() {
      const { resolved } = this;
      if (!resolved) return null;
      const { animation } = resolved;
      return animation.startTime;
    }
    attachTimeline(timeline) {
      if (!this._resolved) {
        this.pendingTimeline = timeline;
      } else {
        const { resolved } = this;
        if (!resolved) return noop$1;
        const { animation } = resolved;
        attachTimeline(animation, timeline);
      }
      return noop$1;
    }
    play() {
      if (this.isStopped) return;
      const { resolved } = this;
      if (!resolved) return;
      const { animation } = resolved;
      if (animation.playState === "finished") {
        this.updateFinishedPromise();
      }
      animation.play();
    }
    pause() {
      const { resolved } = this;
      if (!resolved) return;
      const { animation } = resolved;
      animation.pause();
    }
    stop() {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle") return;
      this.resolveFinishedPromise();
      this.updateFinishedPromise();
      const { resolved } = this;
      if (!resolved) return;
      const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
      if (animation.playState === "idle" || animation.playState === "finished") {
        return;
      }
      if (this.time) {
        const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
        const sampleAnimation = new MainThreadAnimation({
          ...options,
          keyframes: keyframes2,
          duration,
          type,
          ease: ease2,
          times,
          isGenerator: true
        });
        const sampleTime = secondsToMilliseconds(this.time);
        motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
      }
      const { onStop } = this.options;
      onStop && onStop();
      this.cancel();
    }
    complete() {
      const { resolved } = this;
      if (!resolved) return;
      resolved.animation.finish();
    }
    cancel() {
      const { resolved } = this;
      if (!resolved) return;
      resolved.animation.cancel();
    }
    static supports(options) {
      const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
      return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
    }
  }
  const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
  class GroupPlaybackControls {
    constructor(animations2) {
      this.stop = () => this.runAll("stop");
      this.animations = animations2.filter(Boolean);
    }
    then(onResolve, onReject) {
      return Promise.all(this.animations).then(onResolve).catch(onReject);
    }
    getAll(propName) {
      return this.animations[0][propName];
    }
    setAll(propName, newValue) {
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        this.animations[i2][propName] = newValue;
      }
    }
    attachTimeline(timeline, fallback) {
      const subscriptions = this.animations.map((animation) => {
        if (supportsScrollTimeline() && animation.attachTimeline) {
          return animation.attachTimeline(timeline);
        } else {
          return fallback(animation);
        }
      });
      return () => {
        subscriptions.forEach((cancel, i2) => {
          cancel && cancel();
          this.animations[i2].stop();
        });
      };
    }
    get time() {
      return this.getAll("time");
    }
    set time(time2) {
      this.setAll("time", time2);
    }
    get speed() {
      return this.getAll("speed");
    }
    set speed(speed) {
      this.setAll("speed", speed);
    }
    get startTime() {
      return this.getAll("startTime");
    }
    get duration() {
      let max = 0;
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        max = Math.max(max, this.animations[i2].duration);
      }
      return max;
    }
    runAll(methodName) {
      this.animations.forEach((controls) => controls[methodName]());
    }
    flatten() {
      this.runAll("flatten");
    }
    play() {
      this.runAll("play");
    }
    pause() {
      this.runAll("pause");
    }
    cancel() {
      this.runAll("cancel");
    }
    complete() {
      this.runAll("complete");
    }
  }
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed: elapsed2, ...transition }) {
    return !!Object.keys(transition).length;
  }
  const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed: elapsed2 = 0 } = transition;
    elapsed2 = elapsed2 - secondsToMilliseconds(delay2);
    let options = {
      keyframes: Array.isArray(target) ? target : [
        null,
        target
      ],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed2,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(name, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      options.duration = 0;
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return new GroupPlaybackControls([]);
      }
    }
    if (!isHandoff && AcceleratedAnimation.supports(options)) {
      return new AcceleratedAnimation(options);
    } else {
      return new MainThreadAnimation(options);
    }
  };
  const isCustomValue = (v2) => {
    return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
  };
  const resolveFinalValueInKeyframes = (v2) => {
    return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
  };
  function addUniqueItem(arr2, item) {
    if (arr2.indexOf(item) === -1) arr2.push(item);
  }
  function removeItem(arr2, item) {
    const index2 = arr2.indexOf(item);
    if (index2 > -1) arr2.splice(index2, 1);
  }
  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions) return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b, c);
      } else {
        for (let i2 = 0; i2 < numSubscriptions; i2++) {
          const handler = this.subscriptions[i2];
          handler && handler(a, b, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  const MAX_VELOCITY_DELTA = 30;
  const isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  collectMotionValues = {
    current: void 0
  };
  MotionValue = class {
    constructor(init, options = {}) {
      this.version = "11.13.3";
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v2, render = true) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v2);
        if (this.current !== this.prev && this.events.change) {
          this.events.change.notify(this.current);
        }
        if (render && this.events.renderRequest) {
          this.events.renderRequest.notify(this.current);
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
    onChange(subscription) {
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
    attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
    set(v2, render = true) {
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v2, render);
      } else {
        this.passiveEffect(v2, this.updateAndNotify);
      }
    }
    setWithVelocity(prev, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
    jump(v2, endAnimation = true) {
      this.updateAndNotify(v2);
      this.prev = v2;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect) this.stopPassiveEffect();
    }
    get() {
      if (collectMotionValues.current) {
        collectMotionValues.current.push(this);
      }
      return this.current;
    }
    getPrevious() {
      return this.prev;
    }
    getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
    start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
    stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    destroy() {
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  };
  motionValue = function(init, options) {
    return new MotionValue(init, options);
  };
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = {
      ...target,
      ...transitionEnd
    };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }
  const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
  const optimizedAppearDataId = "framerAppearId";
  const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }
  isMotionValue = (value) => Boolean(value && value.getVelocity);
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    }
  }
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    var _a;
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride) transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition(transition || {}, key)
      };
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {
        type: false
      } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }
  function animateVariant(visualElement, variant, options = {}) {
    var _a;
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first, last] = when === "beforeChildren" ? [
        getAnimation,
        getChildAnimations
      ] : [
        getChildAnimations,
        getAnimation
      ];
      return first().then(() => last());
    } else {
      return Promise.all([
        getAnimation(),
        getChildAnimations(options.delay)
      ]);
    }
  }
  function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
    const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
    Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delayChildren + generateStaggerDuration(i2)
      }).then(() => child.notify("AnimationComplete", variant)));
    });
    return Promise.all(animations2);
  }
  function sortByTreeOrder(a, b) {
    return a.sortNodePosition(b);
  }
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }
  const numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement) return void 0;
    if (!visualElement.isControllingVariants) {
      const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context2.initial = visualElement.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i2 = 0; i2 < numVariantProps; i2++) {
      const name = variantProps[i2];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  const reversePriorityOrder = [
    ...variantPriorityOrder
  ].reverse();
  const numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      var _a;
      const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = {
          ...acc,
          ...target,
          ...transitionEnd
        };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = /* @__PURE__ */ new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i2 = 0; i2 < numAnimationTypes; i2++) {
        const type = reversePriorityOrder[i2];
        const typeState = state[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false) removedVariantIndex = i2;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = {
          ...encounteredKeys
        };
        if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || isAnimationControls(prop) || typeof prop === "boolean") {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i2 > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [
          prop
        ];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false) resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2) motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next = resolvedValues[key];
          const prev = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key)) continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            valueHasChanged = !shallowCompare(next, prev);
          } else {
            valueHasChanged = next !== prev;
          }
          if (valueHasChanged) {
            if (next !== void 0 && next !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = {
            ...encounteredKeys,
            ...resolvedValues
          };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => ({
            animation,
            options: {
              type
            }
          })));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2) motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
        });
        animations2.push({
          animation: fallbackAnimation
        });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      var _a;
      if (state[type].isActive === isActive) return Promise.resolve();
      (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
        var _a2;
        return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
      });
      state[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state) {
        state[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state,
      reset: () => {
        state = createState();
        isInitialRender = true;
      }
    };
  }
  function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
      return next !== prev;
    } else if (Array.isArray(next)) {
      return !shallowCompare(next, prev);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }
  class Feature {
    constructor(node) {
      this.isMounted = false;
      this.node = node;
    }
    update() {
    }
  }
  class AnimationFeature extends Feature {
    constructor(node) {
      super(node);
      node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      var _a;
      this.node.animationState.reset();
      (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
    }
  }
  let id$1 = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments);
      this.id = id$1++;
    }
    update() {
      if (!this.node.presenceContext) return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => onExitComplete(this.id));
      }
    }
    mount() {
      const { register: register2 } = this.node.presenceContext || {};
      if (register2) {
        this.unmount = register2(this.id);
      }
    }
    unmount() {
    }
  }
  const animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };
  function resolveElements(elementOrSelector, scope2, selectorCache) {
    var _a;
    if (elementOrSelector instanceof Element) {
      return [
        elementOrSelector
      ];
    } else if (typeof elementOrSelector === "string") {
      let root = document;
      const elements = (_a = void 0) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  }
  const isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }
  function filterEvents(callback) {
    return (event) => {
      if (event.pointerType === "touch" || isDragActive()) return;
      callback(event);
    };
  }
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal
    };
    const onPointerEnter = filterEvents((enterEvent) => {
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(enterEvent);
      if (!onHoverEnd || !target) return;
      const onPointerLeave = filterEvents((leaveEvent) => {
        onHoverEnd(leaveEvent);
        target.removeEventListener("pointerleave", onPointerLeave);
      });
      target.addEventListener("pointerleave", onPointerLeave, eventOptions);
    });
    resolveElements(elementOrSelector).forEach((element) => {
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return () => gestureAbortController.abort();
  }
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }
  const isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  const addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };
  function addDomEvent(target, eventName, handler, options = {
    passive: true
  }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }
  const distance = (a, b) => Math.abs(a - b);
  function distance2D(a, b) {
    const xDelta = distance(a.x, b.x);
    const yDelta = distance(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  class PanSession {
    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, {
          x: 0,
          y: 0
        }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold) return;
        const { point: point2 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({
          ...point2,
          timestamp: timestamp2
        });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event)) return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point } = initialInfo;
      const { timestamp } = frameData;
      this.history = [
        {
          ...point,
          timestamp
        }
      ];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  }
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? {
      point: transformPagePoint(info.point)
    } : info;
  }
  function subtractPoint(a, b) {
    return {
      x: a.x - b.x,
      y: a.y - b.y
    };
  }
  function getPanInfo({ point }, history) {
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history)),
      offset: subtractPoint(point, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return {
        x: 0,
        y: 0
      };
    }
    let i2 = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i2 >= 0) {
      timestampedPoint = history[i2];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i2--;
    }
    if (!timestampedPoint) {
      return {
        x: 0,
        y: 0
      };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return {
        x: 0,
        y: 0
      };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }
  const SCALE_PRECISION = 1e-4;
  const SCALE_MIN = 1 - SCALE_PRECISION;
  const SCALE_MAX = 1 + SCALE_PRECISION;
  const TRANSLATE_PRECISION = 0.01;
  const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }
  function applyConstraints(point, { min, max }, elastic) {
    if (min !== void 0 && point < min) {
      point = elastic ? mixNumber$1(min, point, elastic.min) : Math.max(point, min);
    } else if (max !== void 0 && point > max) {
      point = elastic ? mixNumber$1(max, point, elastic.max) : Math.min(point, max);
    }
    return point;
  }
  function calcRelativeAxisConstraints(axis, min, max) {
    return {
      min: min !== void 0 ? axis.min + min : void 0,
      max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min, max] = [
        max,
        min
      ];
    }
    return {
      min,
      max
    };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin$1(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  const defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }
  const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  const createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  const createAxis = () => ({
    min: 0,
    max: 0
  });
  const createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });
  function eachAxis(callback) {
    return [
      callback("x"),
      callback("y")
    ];
  }
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: {
        min: left,
        max: right
      },
      y: {
        min: top,
        max: bottom
      }
    };
  }
  function convertBoxToBoundingBox({ x: x2, y: y2 }) {
    return {
      top: y2.min,
      right: x2.max,
      bottom: y2.max,
      left: x2.min
    };
  }
  function transformBoxPoints(point, transformPoint2) {
    if (!transformPoint2) return point;
    const topLeft = transformPoint2({
      x: point.left,
      y: point.top
    });
    const bottomRight = transformPoint2({
      x: point.right,
      y: point.bottom
    });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX, scaleY }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }
  function scalePoint(point, scale2, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x: x2, y: y2 }) {
    applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
    applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
  }
  const TREE_SCALE_SNAP_MIN = 0.999999999999;
  const TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength) return;
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i2 = 0; i2 < treeLength; i2++) {
      node = treePath[i2];
      delta = node.projectionDelta;
      const { visualElement } = node.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
        transformBox(box, {
          x: -node.scroll.offset.x,
          y: -node.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node.latestValues)) {
        transformBox(box, node.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  }
  function measureViewportBox(instance2, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance2.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode2;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  }
  const getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };
  const elementDragControls = /* @__PURE__ */ new WeakMap();
  class VisualElementDragControls {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = {
        x: 0,
        y: 0
      };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false) return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock) this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock) return;
        }
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length = calcLength(measuredAxis);
                current = length * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock) return;
        const { offset } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset);
        this.updateAxis("y", info.point, offset);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => this.stop(event, info);
      const resumeAnimation = () => eachAxis((axis) => {
        var _a;
        return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
      });
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
    stop(event, info) {
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2) return;
      const { velocity } = info;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(event, info));
      }
    }
    cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset) {
      const { drag: drag2 } = this.getProps();
      if (!offset || !shouldDrag(axis, drag2, this.currentDirection)) return;
      const axisValue = this.getAxisMotionValue(axis);
      let next = this.originPoint[axis] + offset[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    }
    resolveConstraints() {
      var _a;
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints)) return false;
      const constraintsElement = constraints.current;
      const { projection } = this.visualElement;
      if (!projection || !projection.layout) return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin) transition = {
          min: 0,
          max: 0
        };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => {
        var _a;
        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
      });
    }
    getAnimationState(axis) {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
    }
    getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection)) return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min, max } = projection.layout.layoutBox[axis];
          axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));
        }
      });
    }
    scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;
      this.stopAnimation();
      const boxProgress = {
        x: 0,
        y: 0
      };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin$1({
            min: latest,
            max: latest
          }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null)) return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min, max } = this.constraints[axis];
        axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current) return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2) return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      });
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  }
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }
  class DragGesture extends Feature {
    constructor(node) {
      super(node);
      this.removeGroupControls = noop$1;
      this.removeListeners = noop$1;
      this.controls = new VisualElementDragControls(node);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop$1;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  }
  const asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop$1;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  }
  PresenceContext = reactExports.createContext(null);
  function usePresence() {
    const context = reactExports.useContext(PresenceContext);
    if (context === null) return [
      true,
      null
    ];
    const { isPresent, onExitComplete, register: register2 } = context;
    const id2 = reactExports.useId();
    reactExports.useEffect(() => register2(id2), []);
    const safeToRemove = reactExports.useCallback(() => onExitComplete && onExitComplete(id2), [
      id2,
      onExitComplete
    ]);
    return !isPresent && onExitComplete ? [
      false,
      safeToRemove
    ] : [
      true
    ];
  }
  LayoutGroupContext = reactExports.createContext({});
  const SwitchLayoutGroupContext = reactExports.createContext({});
  const globalProjectionState = {
    hasAnimatedSinceResize: true,
    hasEverUpdated: false
  };
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min) return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  const correctBorderRadius = {
    correct: (latest, node) => {
      if (!node.target) return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x2 = pixelsToPercent(latest, node.target.x);
      const y2 = pixelsToPercent(latest, node.target.y);
      return `${x2}% ${y2}%`;
    }
  };
  const correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5) return original;
      const template = complex.createTransformer(latest);
      const offset = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset] /= xScale;
      shadow[1 + offset] /= yScale;
      const averageScale = mixNumber$1(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset] === "number") shadow[2 + offset] /= averageScale;
      if (typeof shadow[3 + offset] === "number") shadow[3 + offset] /= averageScale;
      return template(shadow);
    }
  };
  const scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    Object.assign(scaleCorrectors, correctors);
  }
  const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);
  class MeasureLayoutWithContext extends reactExports.Component {
    componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group) layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const projection = visualElement.projection;
      if (!projection) return null;
      projection.isPresent = isPresent;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  }
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
      ...props,
      layoutGroup,
      switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
      isPresent,
      safeToRemove
    });
  }
  const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };
  const borders = [
    "TopLeft",
    "TopRight",
    "BottomLeft",
    "BottomRight"
  ];
  const numBorders = borders.length;
  const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  const isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber$1(0, lead.opacity !== void 0 ? lead.opacity : 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
    }
    for (let i2 = 0; i2 < numBorders; i2++) {
      const borderLabel = `border${borders[i2]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0) continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  const easeCrossfadeIn = compress(0, 0.5, circOut);
  const easeCrossfadeOut = compress(0.5, 0.95, noop$1);
  function compress(min, max, easing) {
    return (p2) => {
      if (p2 < min) return 0;
      if (p2 > max) return 1;
      return easing(progress(min, max, p2));
    };
  }
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }
  function removePointDelta(point, translate, scale2, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number") return;
    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
    if (axis === originAxis) originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  const xKeys = [
    "x",
    "scaleX",
    "originX"
  ];
  const yKeys = [
    "y",
    "scaleY",
    "originY"
  ];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
  }
  function boxEquals(a, b) {
    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
  }
  function axisEqualsRounded(a, b) {
    return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
  }
  function boxEqualsRounded(a, b) {
    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b) {
    return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
  }
  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    }
    remove(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node) {
      const indexOfNode = this.members.findIndex((member) => node === member);
      if (indexOfNode === 0) return false;
      let prevLead;
      for (let i2 = indexOfNode; i2 >= 0; i2--) {
        const member = this.members[i2];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node === prevLead) return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
        const { crossfade } = node.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node) => {
        const { options, resumingFrom } = node;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node) => {
        node.instance && node.scheduleRender(false);
      });
    }
    removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  }
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate) transform += `rotate(${rotate}deg) `;
      if (rotateX) transform += `rotateX(${rotateX}deg) `;
      if (rotateY) transform += `rotateY(${rotateY}deg) `;
      if (skewX) transform += `skewX(${skewX}deg) `;
      if (skewY) transform += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
  }
  const compareByDepth = (a, b) => a.depth - b.depth;
  class FlatTree {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  }
  function resolveMotionValue(value) {
    const unwrappedValue = isMotionValue(value) ? value.get() : value;
    return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
  }
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed2 = timestamp - start;
      if (elapsed2 >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed2 - timeout);
      }
    };
    frame.read(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }
  function isSVGElement(element) {
    return element instanceof SVGElement && element.tagName !== "svg";
  }
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }
  const metrics = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
  };
  const isDebug = typeof window !== "undefined" && window.MotionDebug !== void 0;
  const transformAxes = [
    "",
    "X",
    "Y",
    "Z"
  ];
  const hiddenVisibility = {
    visibility: "hidden"
  };
  const animationTarget = 1e3;
  let id = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode) return;
    const { visualElement } = projectionNode.options;
    if (!visualElement) return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
        this.id = id++;
        this.animationId = 0;
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = {
          x: 1,
          y: 1
        };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.hasTreeAnimated = false;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          if (isDebug) {
            metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
          }
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
          if (isDebug) {
            window.MotionDebug.record(metrics);
          }
        };
        this.resolvedRelativeTargetAt = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [
          ...parent.path,
          parent
        ] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i2 = 0; i2 < this.path.length; i2++) {
          this.path[i2].shouldResetTransform = true;
        }
        if (this.root === this) this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
      mount(instance2, isLayoutDirty = this.root.hasTreeAnimated) {
        if (this.instance) return;
        this.isSVG = isSVGElement(instance2);
        this.instance = instance2;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance2);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (isLayoutDirty && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          attachResizeListener(instance2, () => {
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        cancelFrame(this.updateProjection);
      }
      blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
      startUpdate() {
        if (this.isUpdateBlocked()) return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty) return;
        this.isLayoutDirty = true;
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.shouldResetTransform = true;
          node.updateScroll("snapshot");
          if (node.options.layoutRoot) {
            node.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2) return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        }
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
      updateSnapshot() {
        if (this.snapshot || !this.instance) return;
        this.snapshot = this.measure();
      }
      updateLayout() {
        if (!this.instance) return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i2 = 0; i2 < this.path.length; i2++) {
            const node = this.path[i2];
            node.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform) return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        var _a;
        const { visualElement } = this.options;
        if (!visualElement) return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box.x, scroll.offset.x);
            translateAxis(box.y, scroll.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        var _a;
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          const { scroll, options } = node;
          if (node !== this.root && scroll && options.layoutScroll) {
            if (scroll.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y
            });
          }
          if (!hasTransform(node.latestValues)) continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          if (!node.instance) continue;
          if (!hasTransform(node.latestValues)) continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent) return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        var _a;
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip) return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId)) return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        if (!this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (!this.relativeTarget && !this.targetDelta) return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          const relativeParent = this.getClosestProjectingParent();
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.relativeParent = relativeParent;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
        if (isDebug) {
          metrics.resolvedTargetDeltas++;
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      calcProjection() {
        var _a;
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip) return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId)) return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
        if (isDebug) {
          metrics.recalculatedProjection++;
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll = true) {
        var _a;
        (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = {
          ...this.latestValues
        };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget) prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation && this.currentAnimation.stop();
        if (this.resumingFrom && this.resumingFrom.currentAnimation) {
          this.resumingFrom.currentAnimation.stop();
        }
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          this.currentAnimation = animateSingleValue(0, animationTarget, {
            ...options,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onComplete: () => {
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2) return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        const config = node.options.initialPromotionConfig;
        node.promote({
          transition: config ? config.transition : void 0,
          preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        var _a;
        const { layoutId } = this.options;
        return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
      }
      getPrevLead() {
        var _a;
        const { layoutId } = this.options;
        return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId) return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack) stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition) this.setOptions({
          transition
        });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement) return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform) return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i2 = 0; i2 < transformAxes.length; i2++) {
          resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      getProjectionStyles(styleProp) {
        var _a, _b;
        if (!this.instance || this.isSVG) return void 0;
        if (!this.isVisible) {
          return hiddenVisibility;
        }
        const styles2 = {
          visibility: ""
        };
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          styles2.opacity = "";
          styles2.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
          styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return styles2;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          const emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          styles2.transform = transformTemplate(valuesToRender, styles2.transform);
        }
        const { x: x2, y: y2 } = this.projectionDelta;
        styles2.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
        if (lead.animationValues) {
          styles2.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0) continue;
          const { correct, applyTo } = scaleCorrectors[key];
          const corrected = styles2.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i2 = 0; i2 < num; i2++) {
              styles2[applyTo[i2]] = corrected;
            }
          } else {
            styles2[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
        }
        return styles2;
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      resetTree() {
        this.root.nodes.forEach((node) => {
          var _a;
          return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node) {
    node.updateLayout();
  }
  function notifyLayoutUpdate(node) {
    var _a;
    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
    if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
      const { animationType } = node.options;
      const isShared = snapshot.source !== node.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length;
          if (node.relativeTarget && !node.currentAnimation) {
            node.isProjectionDirty = true;
            node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeTargetChanged = false;
      if (!node.resumeFrom) {
        const relativeParent = node.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeTargetChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node.relativeTarget = relativeLayout;
              node.relativeTargetOrigin = relativeSnapshot;
              node.relativeParent = relativeParent;
            }
          }
        }
      }
      node.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeTargetChanged
      });
    } else if (node.isLead()) {
      const { onExitComplete } = node.options;
      onExitComplete && onExitComplete();
    }
    node.options.transition = void 0;
  }
  function propagateDirtyNodes(node) {
    if (isDebug) {
      metrics.totalNodes++;
    }
    if (!node.parent) return;
    if (!node.isProjecting()) {
      node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node) {
    node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
  }
  function clearSnapshot(node) {
    node.clearSnapshot();
  }
  function clearMeasurements(node) {
    node.clearMeasurements();
  }
  function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
  }
  function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node.resetTransform();
  }
  function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = void 0;
    node.isProjectionDirty = true;
  }
  function resolveTargetDelta(node) {
    node.resolveTargetDelta();
  }
  function calcProjection(node) {
    node.calcProjection();
  }
  function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p2) {
    output.translate = mixNumber$1(delta.translate, 0, p2);
    output.scale = mixNumber$1(delta.scale, 1, p2);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from, to, p2) {
    output.min = mixNumber$1(from.min, to.min, p2);
    output.max = mixNumber$1(from.max, to.max, p2);
  }
  function mixBox(output, from, to, p2) {
    mixAxis(output.x, from.x, to.x, p2);
    mixAxis(output.y, from.y, to.y, p2);
  }
  function hasOpacityCrossfade(node) {
    return node.animationValues && node.animationValues.opacityExit !== void 0;
  }
  const defaultLayoutTransition = {
    duration: 0.45,
    ease: [
      0.4,
      0,
      0.1,
      1
    ]
  };
  const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node) {
    var _a;
    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
  }
  const DocumentProjectionNode = createProjectionNode$1({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });
  const rootProjectionNode = {
    current: void 0
  };
  const HTMLProjectionNode = createProjectionNode$1({
    measureScroll: (instance2) => ({
      x: instance2.scrollLeft,
      y: instance2.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({
          layoutScroll: true
        });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance2, value) => {
      instance2.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance2) => Boolean(window.getComputedStyle(instance2).position === "fixed")
  });
  const drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  function handleHoverEvent(node, event, lifecycle) {
    const { props } = node;
    if (node.animationState && props.whileHover) {
      node.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class HoverGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current) return;
      this.unmount = hover(current, (startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  }
  class FocusGesture extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible = false;
      try {
        isFocusVisible = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible = true;
      }
      if (!isFocusVisible || !this.node.animationState) return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState) return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  }
  const isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };
  function fireSyntheticPointerEvent(name, handler) {
    if (!handler) return;
    const syntheticPointerEvent = new PointerEvent("pointer" + name);
    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
  }
  class PressGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removeStartListeners = noop$1;
      this.removeEndListeners = noop$1;
      this.removeAccessibleListeners = noop$1;
      this.startPointerPress = (startEvent, startInfo) => {
        if (this.isPressing) return;
        this.removeEndListeners();
        const props = this.node.getProps();
        const endPointerPress = (endEvent, endInfo) => {
          if (!this.checkPressEnd()) return;
          const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
          const handler = !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel : onTap;
          if (handler) {
            frame.update(() => handler(endEvent, endInfo));
          }
        };
        const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
          passive: !(props.onTap || props["onPointerUp"])
        });
        const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
          passive: !(props.onTapCancel || props["onPointerCancel"])
        });
        this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
        this.startPress(startEvent, startInfo);
      };
      this.startAccessiblePress = () => {
        const handleKeydown = (keydownEvent) => {
          if (keydownEvent.key !== "Enter" || this.isPressing) return;
          const handleKeyup = (keyupEvent) => {
            if (keyupEvent.key !== "Enter" || !this.checkPressEnd()) return;
            fireSyntheticPointerEvent("up", (event, info) => {
              const { onTap } = this.node.getProps();
              if (onTap) {
                frame.postRender(() => onTap(event, info));
              }
            });
          };
          this.removeEndListeners();
          this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
          fireSyntheticPointerEvent("down", (event, info) => {
            this.startPress(event, info);
          });
        };
        const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
        const handleBlur = () => {
          if (!this.isPressing) return;
          fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
        };
        const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
        this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
      };
    }
    startPress(event, info) {
      this.isPressing = true;
      const { onTapStart, whileTap } = this.node.getProps();
      if (whileTap && this.node.animationState) {
        this.node.animationState.setActive("whileTap", true);
      }
      if (onTapStart) {
        frame.postRender(() => onTapStart(event, info));
      }
    }
    checkPressEnd() {
      this.removeEndListeners();
      this.isPressing = false;
      const props = this.node.getProps();
      if (props.whileTap && this.node.animationState) {
        this.node.animationState.setActive("whileTap", false);
      }
      return !isDragActive();
    }
    cancelPress(event, info) {
      if (!this.checkPressEnd()) return;
      const { onTapCancel } = this.node.getProps();
      if (onTapCancel) {
        frame.postRender(() => onTapCancel(event, info));
      }
    }
    mount() {
      const props = this.node.getProps();
      const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(props.onTapStart || props["onPointerStart"])
      });
      const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
      this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
    }
    unmount() {
      this.removeStartListeners();
      this.removeEndListeners();
      this.removeAccessibleListeners();
    }
  }
  const observerCallbacks = /* @__PURE__ */ new WeakMap();
  const observers = /* @__PURE__ */ new WeakMap();
  const fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  const fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root, ...options }) {
    const lookupRoot = root || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, {
        root,
        ...options
      });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }
  const thresholdNames = {
    some: 0,
    all: 1
  };
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root, margin: rootMargin, amount = "some", once } = viewport;
      const options = {
        root: root ? root.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting) return;
        this.isInView = isIntersecting;
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined") return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = [
        "amount",
        "margin",
        "root"
      ].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  }
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }
  const gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };
  const layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  MotionConfigContext = reactExports.createContext({
    transformPagePoint: (p2) => p2,
    isStatic: false,
    reducedMotion: "never"
  });
  const MotionContext = reactExports.createContext({});
  const isBrowser$2 = typeof window !== "undefined";
  useIsomorphicLayoutEffect = isBrowser$2 ? reactExports.useLayoutEffect : reactExports.useEffect;
  const LazyContext = reactExports.createContext({
    strict: false
  });
  function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    var _a, _b;
    const { visualElement: parent } = reactExports.useContext(MotionContext);
    const lazyContext = reactExports.useContext(LazyContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
    const visualElementRef = reactExports.useRef(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = reactExports.useRef(false);
    reactExports.useInsertionEffect(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
    useIsomorphicLayoutEffect(() => {
      if (!visualElement) return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      microtask.render(visualElement.render);
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    reactExports.useEffect(() => {
      if (!visualElement) return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          var _a2;
          (_a2 = window.MotionHandoffMarkAsComplete) === null || _a2 === void 0 ? void 0 : _a2.call(window, optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
    });
    return visualElement;
  }
  function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
      animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement) return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }
  function useMotionRef(visualState, visualElement, externalRef) {
    return reactExports.useCallback((instance2) => {
      instance2 && visualState.mount && visualState.mount(instance2);
      if (visualElement) {
        if (instance2) {
          visualElement.mount(instance2);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance2);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance2;
        }
      }
    }, [
      visualElement
    ]);
  }
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
    return reactExports.useMemo(() => ({
      initial,
      animate
    }), [
      variantLabelsAsDependency(initial),
      variantLabelsAsDependency(animate)
    ]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }
  const featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: [
      "exit"
    ],
    drag: [
      "drag",
      "dragControls"
    ],
    focus: [
      "whileFocus"
    ],
    hover: [
      "whileHover",
      "onHoverStart",
      "onHoverEnd"
    ],
    tap: [
      "whileTap",
      "onTap",
      "onTapStart",
      "onTapCancel"
    ],
    pan: [
      "onPan",
      "onPanStart",
      "onPanSessionStart",
      "onPanEnd"
    ],
    inView: [
      "whileInView",
      "onViewportEnter",
      "onViewportLeave"
    ],
    layout: [
      "layout",
      "layoutId"
    ]
  };
  const featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }
  const motionComponentSymbol = Symbol.for("motionComponentSymbol");
  function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    function MotionComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...reactExports.useContext(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser$2) {
        useStrictMode();
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return jsxRuntimeExports.jsxs(MotionContext.Provider, {
        value: context,
        children: [
          MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, {
            visualElement: context.visualElement,
            ...configAndProps
          }) : null,
          useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
        ]
      });
    }
    const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    reactExports.useContext(LazyContext).strict;
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2) return {};
    const combined = {
      ...drag2,
      ...layout2
    };
    return {
      MeasureLayout: (drag2 === null || drag2 === void 0 ? void 0 : drag2.isEnabled(props)) || (layout2 === null || layout2 === void 0 ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }
  const lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function isSVGComponent(Component) {
    if (typeof Component !== "string" || Component.includes("-")) {
      return false;
    } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/u.test(Component)) {
      return true;
    }
    return false;
  }
  function renderHTML(element, { style, vars }, styleProp, projection) {
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    for (const key in vars) {
      element.style.setProperty(key, vars[key]);
    }
  }
  const camelCaseAttributes = /* @__PURE__ */ new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }
  function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
    var _a;
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }
  useConstant = function(init) {
    const ref = reactExports.useRef(null);
    if (ref.current === null) {
      ref.current = init();
    }
    return ref.current;
  };
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
    const state = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
      renderState: createRenderState()
    };
    if (onMount) {
      state.mount = (instance2) => onMount(props, instance2, state);
    }
    return state;
  }
  const makeUseVisualState = (config) => (props, isStatic) => {
    const context = reactExports.useContext(MotionContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0) initial = context.initial;
      if (animate === void 0) animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [
        variantToSet
      ];
      for (let i2 = 0; i2 < list.length; i2++) {
        const resolved = resolveVariantFromProps(props, list[i2]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index2];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });
  const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });
  const getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };
  const translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  const numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i2 = 0; i2 < numTransforms; i2++) {
      const key = transformPropOrder[i2];
      const value = latestValues[key];
      if (value === void 0) continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }
  function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin } = state;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(latestValues, state.transform, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }
  function calcOrigin(origin, offset, size2) {
    return typeof origin === "string" ? origin : px.transform(offset + size2 * origin);
  }
  function calcSVGTransformOrigin(dimensions, originX, originY) {
    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
    return `${pxOriginX} ${pxOriginY}`;
  }
  const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  const camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys = useDashCase ? dashKeys : camelKeys;
    attrs[keys.offset] = px.transform(-offset);
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
  }
  function buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, ...latest }, isSVGTag2, transformTemplate) {
    buildHTMLStyles(state, latest, transformTemplate);
    if (isSVGTag2) {
      if (state.style.viewBox) {
        state.attrs.viewBox = state.style.viewBox;
      }
      return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style, dimensions } = state;
    if (attrs.transform) {
      if (dimensions) style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
      style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
    }
    if (attrX !== void 0) attrs.x = attrX;
    if (attrY !== void 0) attrs.y = attrY;
    if (attrScale !== void 0) attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }
  const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
  const svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createSvgRenderState,
      onMount: (props, instance2, { renderState, latestValues }) => {
        frame.read(() => {
          try {
            renderState.dimensions = typeof instance2.getBBox === "function" ? instance2.getBBox() : instance2.getBoundingClientRect();
          } catch (e) {
            renderState.dimensions = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          }
        });
        frame.render(() => {
          buildSVGAttrs(renderState, latestValues, isSVGTag(instance2.tagName), props.transformTemplate);
          renderSVG(instance2, renderState);
        });
      }
    })
  };
  const htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
      createRenderState: createHtmlRenderState
    })
  };
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return reactExports.useMemo(() => {
      const state = createHtmlRenderState();
      buildHTMLStyles(state, visualState, transformTemplate);
      return Object.assign({}, state.vars, state.style);
    }, [
      visualState
    ]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
  }
  const validMotionProps = /* @__PURE__ */ new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }
  let shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (!isValidProp) return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
  } catch (_a) {
  }
  function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object") continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }
  function useSVGProps(props, visualState, _isStatic, Component) {
    const visualProps = reactExports.useMemo(() => {
      const state = createSvgRenderState();
      buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
      return {
        ...state.attrs,
        style: {
          ...state.style
        }
      };
    }, [
      visualState
    ]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = {
        ...rawStyles,
        ...visualProps.style
      };
    }
    return visualProps;
  }
  function createUseRender(forwardMotionProps = false) {
    const useRender = (Component, props, ref, { latestValues }, isStatic) => {
      const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
      const visualProps = useVisualProps(props, latestValues, isStatic, Component);
      const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
      const elementProps = Component !== reactExports.Fragment ? {
        ...filteredProps,
        ...visualProps,
        ref
      } : {};
      const { children } = props;
      const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [
        children
      ]);
      return reactExports.createElement(Component, {
        ...elementProps,
        children: renderedChildren
      });
    };
    return useRender;
  }
  function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
    return function createMotionComponent2(Component, { forwardMotionProps } = {
      forwardMotionProps: false
    }) {
      const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
      const config = {
        ...baseConfig,
        preloadedFeatures,
        useRender: createUseRender(forwardMotionProps),
        createVisualElement,
        Component
      };
      return createRendererMotionComponent(config);
    };
  }
  const prefersReducedMotion = {
    current: null
  };
  const hasReducedMotionListener = {
    current: false
  };
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser$2) return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }
  function updateMotionValuesFromProps(element, next, prev) {
    for (const key in next) {
      const nextValue = next[key];
      const prevValue = prev[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, {
          owner: element
        }));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, {
            owner: element
          }));
        }
      }
    }
    for (const key in prev) {
      if (next[key] === void 0) element.removeValue(key);
    }
    return next;
  }
  const visualElementStore = /* @__PURE__ */ new WeakMap();
  const valueTypes = [
    ...dimensionValueTypes,
    color$1,
    complex
  ];
  const findValueType = (v2) => valueTypes.find(testValueType(v2));
  const propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  class VisualElement {
    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
      this.current = null;
      this.children = /* @__PURE__ */ new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = /* @__PURE__ */ new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = /* @__PURE__ */ new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current) return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now2 = time.now();
        if (this.renderScheduledAt < now2) {
          this.renderScheduledAt = now2;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = {
        ...latestValues
      };
      this.initialValues = props.initial ? {
        ...latestValues
      } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = /* @__PURE__ */ new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key], false);
        }
      }
    }
    mount(instance2) {
      this.current = instance2;
      visualElementStore.set(instance2, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance2);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      if (this.parent) this.parent.children.add(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      visualElementStore.delete(this.current);
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove2) => remove2());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent && this.parent.children.delete(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
      });
      const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        removeOnRenderRequest();
        if (removeSyncCheck) removeSyncCheck();
        if (value.owner) value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition) continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
    update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
        const key = propEventHandlers[i2];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
    getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
    addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
    addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue) this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
    removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
    hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, {
          owner: this
        });
        this.addValue(key, value);
      }
      return value;
    }
    readValue(key, target) {
      var _a;
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
    setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
    getBaseTarget(key) {
      var _a;
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target)) return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
  }
  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
      return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  }
  function getComputedStyle$1(element) {
    return window.getComputedStyle(element);
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance2, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      } else {
        const computedStyle = getComputedStyle$1(instance2);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance2, { transformPagePoint }) {
      return measureViewportBox(instance2, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    }
  }
  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance2, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance2.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
    }
    renderInstance(instance2, renderState, styleProp, projection) {
      renderSVG(instance2, renderState, styleProp, projection);
    }
    mount(instance2) {
      this.isSVGTag = isSVGTag(instance2.tagName);
      super.mount(instance2);
    }
  }
  const createDomVisualElement = (Component, options) => {
    return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
      allowProjection: Component !== reactExports.Fragment
    });
  };
  const createMotionComponent = createMotionComponentFactory({
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  }, createDomVisualElement);
  motion = createDOMMotionComponentProxy(createMotionComponent);
  function AnimatedGridPattern({ width = 40, height = 40, x: x2 = -1, y: y2 = -1, strokeDasharray = 0, numSquares = 50, className, maxOpacity = 0.5, duration = 4, ...props }) {
    const id2 = reactExports.useId();
    const containerRef = reactExports.useRef(null);
    const [dimensions, setDimensions] = reactExports.useState({
      width: 0,
      height: 0
    });
    const [squares, setSquares] = reactExports.useState(() => generateSquares(numSquares));
    function getPos() {
      return [
        Math.floor(Math.random() * dimensions.width / width),
        Math.floor(Math.random() * dimensions.height / height)
      ];
    }
    function generateSquares(count2) {
      return Array.from({
        length: count2
      }, (_, i2) => ({
        id: i2,
        pos: getPos()
      }));
    }
    const updateSquarePosition = (id22) => {
      setSquares((currentSquares) => currentSquares.map((sq) => sq.id === id22 ? {
        ...sq,
        pos: getPos()
      } : sq));
    };
    reactExports.useEffect(() => {
      if (dimensions.width && dimensions.height) {
        setSquares(generateSquares(numSquares));
      }
    }, [
      dimensions,
      numSquares
    ]);
    reactExports.useEffect(() => {
      const resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          setDimensions({
            width: entry.contentRect.width,
            height: entry.contentRect.height
          });
        }
      });
      if (containerRef.current) {
        resizeObserver.observe(containerRef.current);
      }
      return () => {
        if (containerRef.current) {
          resizeObserver.unobserve(containerRef.current);
        }
      };
    }, [
      containerRef
    ]);
    return jsxRuntimeExports.jsxs("svg", {
      ref: containerRef,
      "aria-hidden": "true",
      className: cn("pointer-events-none absolute inset-0 h-full w-full fill-gray-400/30 stroke-gray-400/30", className),
      ...props,
      children: [
        jsxRuntimeExports.jsx("defs", {
          children: jsxRuntimeExports.jsx("pattern", {
            id: id2,
            width,
            height,
            patternUnits: "userSpaceOnUse",
            x: x2,
            y: y2,
            children: jsxRuntimeExports.jsx("path", {
              d: `M.5 ${height}V.5H${width}`,
              fill: "none",
              strokeDasharray
            })
          })
        }),
        jsxRuntimeExports.jsx("rect", {
          width: "100%",
          height: "100%",
          fill: `url(#${id2})`
        }),
        jsxRuntimeExports.jsx("svg", {
          x: x2,
          y: y2,
          className: "overflow-visible",
          children: squares.map(({ pos: [x22, y22], id: id22 }, index2) => jsxRuntimeExports.jsx(motion.rect, {
            initial: {
              opacity: 0
            },
            animate: {
              opacity: maxOpacity
            },
            transition: {
              duration,
              repeat: 1,
              delay: index2 * 0.1,
              repeatType: "reverse"
            },
            onAnimationComplete: () => updateSquarePosition(id22),
            width: width - 1,
            height: height - 1,
            x: x22 * width + 1,
            y: y22 * height + 1,
            fill: "currentColor",
            strokeWidth: "0"
          }, `${x22}-${y22}-${index2}`))
        })
      ]
    });
  }
  const FlickeringGrid = ({ squareSize = 4, gridGap = 6, flickerChance = 0.3, color: color2 = "rgb(0, 0, 0)", width, height, className, maxOpacity = 0.3 }) => {
    const canvasRef = reactExports.useRef(null);
    const containerRef = reactExports.useRef(null);
    const [isInView, setIsInView] = reactExports.useState(false);
    const [canvasSize, setCanvasSize] = reactExports.useState({
      width: 0,
      height: 0
    });
    const memoizedColor = reactExports.useMemo(() => {
      const toRGBA = (color22) => {
        if (typeof window === "undefined") {
          return `rgba(0, 0, 0,`;
        }
        const canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        const ctx = canvas.getContext("2d");
        if (!ctx) return "rgba(255, 0, 0,";
        ctx.fillStyle = color22;
        ctx.fillRect(0, 0, 1, 1);
        const [r2, g, b] = Array.from(ctx.getImageData(0, 0, 1, 1).data);
        return `rgba(${r2}, ${g}, ${b},`;
      };
      return toRGBA(color2);
    }, [
      color2
    ]);
    const setupCanvas = reactExports.useCallback((canvas, width2, height2) => {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width2 * dpr;
      canvas.height = height2 * dpr;
      canvas.style.width = `${width2}px`;
      canvas.style.height = `${height2}px`;
      const cols = Math.floor(width2 / (squareSize + gridGap));
      const rows = Math.floor(height2 / (squareSize + gridGap));
      const squares = new Float32Array(cols * rows);
      for (let i2 = 0; i2 < squares.length; i2++) {
        squares[i2] = Math.random() * maxOpacity;
      }
      return {
        cols,
        rows,
        squares,
        dpr
      };
    }, [
      squareSize,
      gridGap,
      maxOpacity
    ]);
    const updateSquares = reactExports.useCallback((squares, deltaTime) => {
      for (let i2 = 0; i2 < squares.length; i2++) {
        if (Math.random() < flickerChance * deltaTime) {
          squares[i2] = Math.random() * maxOpacity;
        }
      }
    }, [
      flickerChance,
      maxOpacity
    ]);
    const drawGrid = reactExports.useCallback((ctx, width2, height2, cols, rows, squares, dpr) => {
      ctx.clearRect(0, 0, width2, height2);
      ctx.fillStyle = "transparent";
      ctx.fillRect(0, 0, width2, height2);
      for (let i2 = 0; i2 < cols; i2++) {
        for (let j = 0; j < rows; j++) {
          const opacity = squares[i2 * rows + j];
          ctx.fillStyle = `${memoizedColor}${opacity})`;
          ctx.fillRect(i2 * (squareSize + gridGap) * dpr, j * (squareSize + gridGap) * dpr, squareSize * dpr, squareSize * dpr);
        }
      }
    }, [
      memoizedColor,
      squareSize,
      gridGap
    ]);
    reactExports.useEffect(() => {
      const canvas = canvasRef.current;
      const container = containerRef.current;
      if (!canvas || !container) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      let animationFrameId;
      let gridParams;
      const updateCanvasSize = () => {
        const newWidth = width || container.clientWidth;
        const newHeight = height || container.clientHeight;
        setCanvasSize({
          width: newWidth,
          height: newHeight
        });
        gridParams = setupCanvas(canvas, newWidth, newHeight);
      };
      updateCanvasSize();
      let lastTime = 0;
      const animate = (time2) => {
        if (!isInView) return;
        const deltaTime = (time2 - lastTime) / 1e3;
        lastTime = time2;
        updateSquares(gridParams.squares, deltaTime);
        drawGrid(ctx, canvas.width, canvas.height, gridParams.cols, gridParams.rows, gridParams.squares, gridParams.dpr);
        animationFrameId = requestAnimationFrame(animate);
      };
      const resizeObserver = new ResizeObserver(() => {
        updateCanvasSize();
      });
      resizeObserver.observe(container);
      const intersectionObserver = new IntersectionObserver(([entry]) => {
        setIsInView(entry.isIntersecting);
      }, {
        threshold: 0
      });
      intersectionObserver.observe(canvas);
      if (isInView) {
        animationFrameId = requestAnimationFrame(animate);
      }
      return () => {
        cancelAnimationFrame(animationFrameId);
        resizeObserver.disconnect();
        intersectionObserver.disconnect();
      };
    }, [
      setupCanvas,
      updateSquares,
      drawGrid,
      width,
      height,
      isInView
    ]);
    return jsxRuntimeExports.jsx("div", {
      ref: containerRef,
      className: `w-full h-full ${className}`,
      children: jsxRuntimeExports.jsx("canvas", {
        ref: canvasRef,
        className: "pointer-events-none",
        style: {
          width: canvasSize.width,
          height: canvasSize.height
        }
      })
    });
  };
  const Meteors = ({ number: number2 = 20 }) => {
    const [meteorStyles, setMeteorStyles] = reactExports.useState([]);
    reactExports.useEffect(() => {
      const styles2 = [
        ...new Array(number2)
      ].map(() => ({
        top: -5,
        left: Math.floor(Math.random() * window.innerWidth) + "px",
        animationDelay: Math.random() * 1 + 0.2 + "s",
        animationDuration: Math.floor(Math.random() * 8 + 2) + "s"
      }));
      setMeteorStyles(styles2);
    }, [
      number2
    ]);
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: [
        ...meteorStyles
      ].map((style, idx) => jsxRuntimeExports.jsx("span", {
        className: cn("pointer-events-none absolute left-1/2 top-1/2 size-0.5 rotate-[215deg] animate-meteor rounded-full bg-slate-500 shadow-[0_0_0_1px_#ffffff10]"),
        style,
        children: jsxRuntimeExports.jsx("div", {
          className: "pointer-events-none absolute top-1/2 -z-10 h-px w-[50px] -translate-y-1/2 bg-gradient-to-r from-slate-500 to-transparent"
        })
      }, idx))
    });
  };
  function RetroGrid({ className, angle = 65 }) {
    return jsxRuntimeExports.jsxs("div", {
      className: cn("pointer-events-none absolute size-full overflow-hidden opacity-50 [perspective:200px]", className),
      style: {
        "--grid-angle": `${angle}deg`
      },
      children: [
        jsxRuntimeExports.jsx("div", {
          className: "absolute inset-0 [transform:rotateX(var(--grid-angle))]",
          children: jsxRuntimeExports.jsx("div", {
            className: cn("animate-grid", "[background-repeat:repeat] [background-size:60px_60px] [height:300vh] [inset:0%_0px] [margin-left:-50%] [transform-origin:100%_0_0] [width:600vw]", "[background-image:linear-gradient(to_right,rgba(0,0,0,0.3)_1px,transparent_0),linear-gradient(to_bottom,rgba(0,0,0,0.3)_1px,transparent_0)]", "dark:[background-image:linear-gradient(to_right,rgba(255,255,255,0.2)_1px,transparent_0),linear-gradient(to_bottom,rgba(255,255,255,0.2)_1px,transparent_0)]")
          })
        }),
        jsxRuntimeExports.jsx("div", {
          className: "absolute inset-0 bg-gradient-to-t from-white to-transparent to-90% dark:from-black"
        })
      ]
    });
  }
  function TypingAnimation({ text, duration = 200, className, repeat, repeatDelay }) {
    const [displayedText, setDisplayedText] = reactExports.useState("");
    const [i2, setI] = reactExports.useState(0);
    const isDelay = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const typingEffect = setInterval(() => {
        if (isDelay.current) {
          return;
        }
        if (i2 < text.length) {
          setDisplayedText(text.substring(0, i2 + 1));
          setI(i2 + 1);
        } else if (repeat) {
          isDelay.current = true;
          setTimeout(() => {
            setDisplayedText("");
            setI(0);
            isDelay.current = false;
          }, repeatDelay || 0);
        } else {
          clearInterval(typingEffect);
        }
      }, duration);
      return () => {
        clearInterval(typingEffect);
      };
    }, [
      duration,
      i2
    ]);
    return jsxRuntimeExports.jsx("h1", {
      className: cn("font-display text-center text-4xl font-bold leading-[5rem] tracking-[-0.02em] drop-shadow-sm", className),
      children: displayedText ? displayedText : text
    });
  }
  DefaultLoader = reactExports.memo(({ className, gridPattern, flickeringGrid, typing, text }) => {
    const { t: t2 } = useTranslation("common");
    const renderLoader = () => {
      if (gridPattern) {
        return jsxRuntimeExports.jsx(AnimatedGridPattern, {
          className: "absolute"
        });
      }
      if (flickeringGrid) {
        return jsxRuntimeExports.jsx(FlickeringGrid, {
          className: "absolute",
          gridGap: 30,
          squareSize: 2
        });
      }
      return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx(RetroGrid, {}),
          jsxRuntimeExports.jsx(Meteors, {
            number: 25
          })
        ]
      });
    };
    return jsxRuntimeExports.jsxs("div", {
      className: cn("relative flex h-full w-full flex-col items-center justify-center overflow-hidden rounded-lg border bg-background md:shadow-xl", className),
      children: [
        jsxRuntimeExports.jsx("div", {
          className: "flex flex-row items-center gap-2",
          children: typing ? jsxRuntimeExports.jsx(TypingAnimation, {
            className: "text-4xl font-bold text-black dark:text-white mb-32",
            text: text ?? t2("loading"),
            repeat: true,
            repeatDelay: 500
          }) : jsxRuntimeExports.jsx("div", {
            className: "text-4xl font-bold text-black dark:text-white mb-32",
            children: text ?? t2("loading")
          })
        }),
        renderLoader()
      ]
    });
  });
  const EasySpeech = {};
  const scope = typeof globalThis === "undefined" ? window : globalThis;
  const internal = {
    status: "created"
  };
  const patches = {};
  EasySpeech.debug = (fn) => {
    debug$2 = typeof fn === "function" ? fn : () => {
    };
  };
  let debug$2 = () => {
  };
  EasySpeech.detect = () => detectFeatures();
  const detectFeatures = () => {
    const features = {};
    [
      "speechSynthesis",
      "speechSynthesisUtterance",
      "speechSynthesisVoice",
      "speechSynthesisEvent",
      "speechSynthesisErrorEvent"
    ].forEach((feature) => {
      features[feature] = detect(feature);
    });
    features.onvoiceschanged = hasProperty(features.speechSynthesis, "onvoiceschanged");
    const hasUtterance = hasProperty(features.speechSynthesisUtterance, "prototype");
    utteranceEvents.forEach((event) => {
      const name = `on${event}`;
      features[name] = hasUtterance && hasProperty(features.speechSynthesisUtterance.prototype, name);
    });
    patches.isAndroid = isAndroid();
    patches.isFirefox = isFirefox() || isKaiOS();
    patches.isSafari = isSafari();
    debug$2(`is android: ${!!patches.isAndroid}`);
    debug$2(`is firefox: ${!!patches.isFirefox}`);
    debug$2(`is safari: ${!!patches.isSafari}`);
    return features;
  };
  const hasProperty = (target = {}, prop) => Object.hasOwnProperty.call(target, prop) || prop in target || !!target[prop];
  const getUA = () => (scope.navigator || {}).userAgent || "";
  const isAndroid = () => /android/i.test(getUA());
  const isKaiOS = () => /kaios/i.test(getUA());
  const isFirefox = () => {
    if (typeof scope.InstallTrigger !== "undefined") {
      return true;
    }
    return /firefox/i.test(getUA());
  };
  const isSafari = () => typeof scope.GestureEvent !== "undefined";
  const prefixes = [
    "webKit",
    "moz",
    "ms",
    "o"
  ];
  const capital = (s) => `${s.charAt(0).toUpperCase()}${s.slice(1)}`;
  const detect = (baseName) => {
    const capitalBaseName = capital(baseName);
    const baseNameWithPrefixes = prefixes.map((p2) => `${p2}${capitalBaseName}`);
    const found = [
      baseName,
      capitalBaseName
    ].concat(baseNameWithPrefixes).find(inGlobalScope);
    return scope[found];
  };
  const inGlobalScope = (name) => scope[name];
  EasySpeech.status = () => ({
    ...internal
  });
  EasySpeech.filterVoices = ({ name, language, localService, voiceURI }) => {
    const voices = internal.voices || [];
    const hasName = typeof name !== "undefined";
    const hasVoiceURI = typeof voiceURI !== "undefined";
    const hasLocalService = typeof localService !== "undefined";
    const hasLang = typeof language !== "undefined";
    const langCode = hasLang && language.split(/[-_]+/g)[0].toLocaleLowerCase();
    return voices.filter((v2) => {
      if (hasName && v2.name.includes(name) || hasVoiceURI && v2.voiceURI.includes(voiceURI) || hasLocalService && v2.localService === localService) {
        return true;
      }
      if (hasLang) {
        const compareLang = v2.lang && v2.lang.toLocaleLowerCase();
        return compareLang && (compareLang === langCode || compareLang.indexOf(`${langCode}-`) > -1 || compareLang.indexOf(`${langCode}_`) > -1);
      }
      return false;
    });
  };
  const status = (s) => {
    debug$2(s);
    internal.status = s;
  };
  EasySpeech.init = function({ maxTimeout = 5e3, interval = 250, quiet, maxLengthExceeded } = {}) {
    return new Promise((resolve, reject) => {
      if (internal.initialized) {
        return resolve(false);
      }
      EasySpeech.reset();
      status("init: start");
      let timer;
      let voicesChangedListener;
      let completeCalled = false;
      internal.maxLengthExceeded = maxLengthExceeded || "warn";
      const fail = (errorMessage) => {
        status(`init: failed (${errorMessage})`);
        clearInterval(timer);
        internal.initialized = false;
        return quiet ? resolve(false) : reject(new Error(`EasySpeech: ${errorMessage}`));
      };
      const complete = () => {
        if (completeCalled) {
          return;
        }
        status("init: complete");
        completeCalled = true;
        internal.initialized = true;
        clearInterval(timer);
        speechSynthesis.onvoiceschanged = null;
        if (voicesChangedListener) {
          speechSynthesis.removeEventListener("voiceschanged", voicesChangedListener);
        }
        return resolve(true);
      };
      const features = detectFeatures();
      const hasAllFeatures = !!features.speechSynthesis && !!features.speechSynthesisUtterance;
      if (!hasAllFeatures) {
        return fail("browser misses features");
      }
      Object.keys(features).forEach((feature) => {
        internal[feature] = features[feature];
      });
      const { speechSynthesis } = internal;
      const voicesLoaded = () => {
        const voices = speechSynthesis.getVoices() || [];
        if (voices.length > 0) {
          internal.voices = voices;
          status(`voices loaded: ${voices.length}`);
          internal.defaultVoice = voices.find((v2) => v2.default);
          if (!internal.defaultVoice) {
            const language = (scope.navigator || {}).language || "";
            const filtered = EasySpeech.filterVoices({
              language
            });
            if (filtered.length > 0) {
              internal.defaultVoice = filtered[0];
            }
          }
          if (!internal.defaultVoice) {
            internal.defaultVoice = voices[0];
          }
          return true;
        }
        return false;
      };
      status("init: voices");
      if (voicesLoaded()) {
        return complete();
      }
      const loadViaTimeout = () => {
        status("init: voices (timer)");
        let timeout = 0;
        timer = setInterval(() => {
          if (voicesLoaded()) {
            return complete();
          }
          if (timeout > maxTimeout) {
            return fail("browser has no voices (timeout)");
          }
          timeout += interval;
        }, interval);
      };
      if (features.onvoiceschanged) {
        status("init: voices (onvoiceschanged)");
        speechSynthesis.onvoiceschanged = () => {
          if (voicesLoaded()) {
            return complete();
          }
          return loadViaTimeout();
        };
        setTimeout(() => {
          if (voicesLoaded()) {
            return complete();
          }
          return fail("browser has no voices (timeout)");
        }, maxTimeout);
      } else {
        if (hasProperty(speechSynthesis, "addEventListener")) {
          status("init: voices (addEventListener)");
          voicesChangedListener = () => {
            if (voicesLoaded()) {
              return complete();
            }
          };
          speechSynthesis.addEventListener("voiceschanged", voicesChangedListener);
        }
        loadViaTimeout();
      }
    });
  };
  const ensureInit = ({ force } = {}) => {
    if (!force && !internal.initialized) {
      throw new Error("EasySpeech: not initialized. Run EasySpeech.init() first");
    }
  };
  EasySpeech.voices = () => {
    ensureInit();
    return internal.voices;
  };
  EasySpeech.on = (handlers) => {
    ensureInit();
    utteranceEvents.forEach((name) => {
      const handler = handlers[name];
      if (validate$2.handler(handler)) {
        internal.handlers[name] = handler;
      }
    });
    return {
      ...internal.handlers
    };
  };
  const utteranceEvents = [
    "boundary",
    "end",
    "error",
    "mark",
    "pause",
    "resume",
    "start"
  ];
  const validate$2 = {
    isNumber: (n2) => typeof n2 === "number" && !Number.isNaN(n2),
    pitch: (p2) => validate$2.isNumber(p2) && p2 >= 0 && p2 <= 2,
    volume: (v2) => validate$2.isNumber(v2) && v2 >= 0 && v2 <= 1,
    rate: (r2) => validate$2.isNumber(r2) && r2 >= 0.1 && r2 <= 10,
    text: (t2) => typeof t2 === "string",
    handler: (h) => typeof h === "function",
    voice: (v2) => v2 && v2.lang && v2.name && v2.voiceURI
  };
  EasySpeech.defaults = (options) => {
    ensureInit();
    if (options) {
      internal.defaults = internal.defaults || {};
      [
        "voice",
        "pitch",
        "rate",
        "volume"
      ].forEach((name) => {
        const value = options[name];
        const isValid2 = validate$2[name];
        if (isValid2(value)) {
          internal.defaults[name] = value;
        }
      });
    }
    return {
      ...internal.defaults
    };
  };
  const getCurrentVoice = (voice) => {
    var _a, _b;
    return voice || ((_a = internal.defaults) == null ? void 0 : _a.voice) || internal.defaultVoice || ((_b = internal.voices) == null ? void 0 : _b[0]);
  };
  const createUtterance = (text) => {
    const UtteranceClass = internal.speechSynthesisUtterance;
    return new UtteranceClass(text);
  };
  EasySpeech.speak = ({ text, voice, pitch, rate, volume, force, infiniteResume, noStop, ...handlers }) => {
    ensureInit({
      force
    });
    if (!validate$2.text(text)) {
      throw new Error("EasySpeech: at least some valid text is required to speak");
    }
    if (new TextEncoder().encode(text).length > 4096) {
      const message = "EasySpeech: text exceeds max length of 4096 bytes, which will not work with some voices.";
      switch (internal.maxLengthExceeded) {
        case "none":
          break;
        case "error":
          throw new Error(message);
        case "warn":
        default:
          console.warn(message);
      }
    }
    const getValue = (options) => {
      var _a;
      const [name, value] = Object.entries(options)[0];
      if (validate$2[name](value)) {
        return value;
      }
      return (_a = internal.defaults) == null ? void 0 : _a[name];
    };
    return new Promise((resolve, reject) => {
      status("init speak");
      const utterance = createUtterance(text);
      const currentVoice = getCurrentVoice(voice);
      if (currentVoice) {
        utterance.voice = currentVoice;
        utterance.lang = currentVoice.lang;
        utterance.voiceURI = currentVoice.voiceURI;
      }
      utterance.text = text;
      utterance.pitch = getValue({
        pitch
      });
      utterance.rate = getValue({
        rate
      });
      utterance.volume = getValue({
        volume
      });
      const isMsNatural = utterance.voice && utterance.voice.name && utterance.voice.name.toLocaleLowerCase().includes("(natural)");
      debugUtterance(utterance, {
        isMsNatural
      });
      utteranceEvents.forEach((name) => {
        var _a;
        const fn = handlers[name];
        if (validate$2.handler(fn)) {
          utterance.addEventListener(name, fn);
        }
        if ((_a = internal.handlers) == null ? void 0 : _a[name]) {
          utterance.addEventListener(name, internal.handlers[name]);
        }
      });
      utterance.addEventListener("start", () => {
        patches.paused = false;
        patches.speaking = true;
        const defaultResumeInfinity = !isMsNatural && !patches.isFirefox && !patches.isSafari && patches.isAndroid !== true;
        const useResumeInfinity = typeof infiniteResume === "boolean" ? infiniteResume : defaultResumeInfinity;
        if (useResumeInfinity) {
          resumeInfinity(utterance);
        }
      });
      utterance.addEventListener("end", (endEvent) => {
        status("speak complete");
        patches.paused = false;
        patches.speaking = false;
        clearTimeout(timeoutResumeInfinity);
        resolve(endEvent);
      });
      utterance.addEventListener("error", (errorEvent = {}) => {
        status(`speak failed: ${errorEvent.message}`);
        patches.paused = false;
        patches.speaking = false;
        clearTimeout(timeoutResumeInfinity);
        reject(errorEvent);
      });
      clearTimeout(timeoutResumeInfinity);
      if (!(noStop === true)) {
        internal.speechSynthesis.cancel();
      }
      setTimeout(() => internal.speechSynthesis.speak(utterance), 10);
    });
  };
  const debugUtterance = ({ voice, pitch, rate, volume }, { isMsNatural = false } = {}) => {
    debug$2(`utterance: voice=${voice == null ? void 0 : voice.name} volume=${volume} rate=${rate} pitch=${pitch} isMsNatural=${isMsNatural}`);
  };
  let timeoutResumeInfinity;
  function resumeInfinity(target) {
    if (!target && timeoutResumeInfinity) {
      debug$2("force-clear timeout");
      return scope.clearTimeout(timeoutResumeInfinity);
    }
    const { paused, speaking } = internal.speechSynthesis;
    const isSpeaking = speaking || patches.speaking;
    const isPaused = paused || patches.paused;
    debug$2(`resumeInfinity isSpeaking=${isSpeaking} isPaused=${isPaused}`);
    if (isSpeaking && !isPaused) {
      internal.speechSynthesis.pause();
      internal.speechSynthesis.resume();
    }
    timeoutResumeInfinity = scope.setTimeout(function() {
      resumeInfinity(target);
    }, 5e3);
  }
  EasySpeech.cancel = () => {
    ensureInit();
    status("cancelling");
    internal.speechSynthesis.cancel();
    patches.paused = false;
    patches.speaking = false;
  };
  EasySpeech.resume = () => {
    ensureInit();
    status("resuming");
    patches.paused = false;
    patches.speaking = true;
    internal.speechSynthesis.resume();
  };
  EasySpeech.pause = () => {
    ensureInit();
    status("pausing");
    if (patches.isAndroid) {
      debug$2("patch pause on Android with cancel");
      return internal.speechSynthesis.cancel();
    }
    internal.speechSynthesis.pause();
    patches.paused = true;
    patches.speaking = false;
  };
  EasySpeech.reset = () => {
    Object.assign(internal, {
      status: "reset",
      initialized: false,
      speechSynthesis: null,
      speechSynthesisUtterance: null,
      speechSynthesisVoice: null,
      speechSynthesisEvent: null,
      speechSynthesisErrorEvent: null,
      voices: null,
      defaultVoice: null,
      defaults: {
        pitch: 1,
        rate: 1,
        volume: 1,
        voice: null
      },
      handlers: {}
    });
  };
  class TextToSpeech {
    constructor() {
    }
    static getInstance() {
      if (!TextToSpeech.instance) {
        TextToSpeech.instance = new TextToSpeech();
      }
      return TextToSpeech.instance;
    }
    static async init() {
      try {
        TextToSpeech.promise = EasySpeech.init({
          maxTimeout: 5e3,
          interval: 100
        });
        await TextToSpeech.promise;
      } catch (error) {
        logWarn("Error during speech synthesis initialization", error);
      } finally {
        TextToSpeech.promise = void 0;
      }
    }
    async speak(text) {
      try {
        if (TextToSpeech.promise) {
          await TextToSpeech.promise;
        }
        const status2 = EasySpeech.status();
        if (!("initialized" in status2) || !status2.initialized) {
          throw new Error("EasySpeech is not ready");
        }
        return EasySpeech.speak({
          text,
          pitch: 1,
          rate: 1,
          volume: 1,
          voice: EasySpeech.voices()[0]
        }).catch((error) => {
          logWarn("Error during speech synthesis:", error);
        });
      } catch (error) {
        logWarn("Error during speech synthesis:", error);
      }
    }
    async stop() {
      try {
        return EasySpeech == null ? void 0 : EasySpeech.cancel();
      } catch (error) {
        logWarn("Error during speech synthesis:", error);
      }
    }
  }
  textToSpeech = TextToSpeech.getInstance();
  async function* fakeStreaming(promise, itemKey, refProcesses2, options) {
    while (true) {
      const process2 = refProcesses2.get(itemKey);
      if (process2) {
        const { processInfo } = process2;
        if (processInfo && typeof processInfo === "object" && "data" in processInfo && "lastIndex" in processInfo && Array.isArray(processInfo.data)) {
          const newData = (options == null ? void 0 : options.lastChunkOnly) ? processInfo.data[processInfo.data.length - 1] : processInfo.data.slice(+`${processInfo.lastIndex}`);
          if (newData && (!Array.isArray(newData) || (newData == null ? void 0 : newData.length))) {
            processInfo.lastIndex = (options == null ? void 0 : options.lastChunkOnly) ? processInfo.data.length - 1 : processInfo.data.length > 0 ? processInfo.data.length : 0;
            yield newData;
          }
        }
        await new Promise((resolve) => setTimeout(resolve, (options == null ? void 0 : options.interval) || 150));
      } else {
        break;
      }
    }
    const response = await promise;
    yield response;
    return response;
  }
  const worker$1 = new Worker(new URL("/NoLLMChat/assets/local-llm.worker-lE2Q3hb2.js", import.meta.url), {
    type: "module"
  });
  const getHandleMessages = (get2, set) => {
    return (event) => {
      workerMessagesHandler(event, get2().refProcesses, {
        onWorkerInit: () => set({
          ready: true
        })
      });
    };
  };
  async function load(options, ...args) {
    const worker2 = options.worker;
    const refProcesses2 = options.refProcesses;
    if (!worker2) {
      throw new Error("Worker not initialized");
    }
    const promiseInfo = getEmptyPromise(() => {
      sendToWorker(worker2, "load", options.messageId, args);
    });
    refProcesses2.set(options.messageId, {
      promise: promiseInfo.promise,
      resolve: promiseInfo.resolve,
      reject: promiseInfo.reject,
      processInfo: {
        type: "load",
        data: [],
        lastIndex: 0
      }
    });
    return fakeStreaming(promiseInfo.promise, options.messageId, refProcesses2, {
      lastChunkOnly: true
    });
  }
  const getLocalLLMStateActions = (set, get2) => {
    return {
      setInitializing: (initializing) => {
        const currentInitializing = get2().initializing;
        set({
          initializing: {
            ...currentInitializing,
            ...initializing
          }
        });
      },
      setSelectedModel: (selectedModel) => {
        set({
          selectedModel
        });
      },
      init: () => {
        try {
          const oldHandler = get2().handler;
          if (worker$1 && oldHandler) {
            worker$1.removeEventListener("message", oldHandler);
          }
          const handler = getHandleMessages(get2, set);
          set({
            handler
          });
          worker$1.addEventListener("message", handler);
        } catch (error) {
          logWarn("Failed to init", error);
        }
      },
      syncCachedLLMURLs: async () => {
        return caches.open("webllm/config").then(async (cache2) => {
          return cache2.keys();
        }).then((requests) => {
          const urls = requests.map((request) => request.url);
          set({
            cachedLLMURLs: urls
          });
          return urls;
        });
      },
      loadModel: async (modelName, callback) => {
        let currentLoadModelMessageId = get2().currentLoadModelMessageId;
        const initProgressCallbacks = get2().initProgressCallbacks;
        const initializing = get2().initializing;
        const refProcesses2 = get2().refProcesses;
        if (currentLoadModelMessageId) {
          const process2 = refProcesses2.get(currentLoadModelMessageId);
          if (process2) {
            const { reject } = process2;
            reject == null ? void 0 : reject("stop");
            refProcesses2.delete(currentLoadModelMessageId);
          }
        }
        currentLoadModelMessageId = nanoid();
        set({
          currentLoadModelMessageId: nanoid(),
          selectedModel: modelName,
          initializing: {
            ...initializing,
            loading: true
          }
        });
        const generator = await load({
          messageId: currentLoadModelMessageId,
          worker: worker$1,
          refProcesses: refProcesses2
        }, {
          model: modelName
        });
        for await (const data of generator) {
          if (data) {
            initProgressCallbacks.forEach((callback2) => callback2(data));
            callback == null ? void 0 : callback(data);
          }
        }
        setTimeout(() => {
          initProgressCallbacks.forEach((callback2) => callback2({
            progress: 100,
            timeElapsed: 1,
            text: `Model ${modelName} loaded.`
          }));
          set({
            initializing: {
              ...get2().initializing,
              loading: false
            }
          });
        }, 100);
      },
      setInitProgressCallback: (callback) => {
        const data = get2().initProgressCallbacks;
        data.push(callback);
        set({
          initProgressCallbacks: data
        });
        return () => {
          set({
            initProgressCallbacks: get2().initProgressCallbacks.filter((item) => item !== callback)
          });
        };
      },
      invoke: (...args) => {
        const refProcesses2 = get2().refProcesses;
        if (!worker$1) {
          throw new Error("Worker not initialized");
        }
        const messageId = nanoid();
        const promiseInfo = getEmptyPromise(() => {
          sendToWorker(worker$1, "invoke", messageId, args);
        });
        refProcesses2.set(messageId, {
          promise: promiseInfo.promise,
          resolve: promiseInfo.resolve,
          reject: promiseInfo.reject,
          processInfo: {
            type: "invoke",
            data: [],
            lastIndex: 0
          }
        });
        return promiseInfo.promise;
      },
      stream: (...args) => {
        const refProcesses2 = get2().refProcesses;
        if (!worker$1) {
          throw new Error("Worker not initialized");
        }
        const messageId = nanoid();
        const [input, ...rest] = args;
        const promiseInfo = getEmptyPromise(() => {
          sendToWorker(worker$1, "stream", messageId, [
            parseLLMInputToBridgeJSON(input),
            ...rest
          ]);
        });
        refProcesses2.set(messageId, {
          promise: promiseInfo.promise,
          resolve: promiseInfo.resolve,
          reject: promiseInfo.reject,
          processInfo: {
            type: "invoke",
            data: [],
            lastIndex: 0
          }
        });
        const promise = promiseInfo.promise;
        return fakeStreaming(promise, messageId, refProcesses2);
      },
      structuredStream: (schemaItems, ...args) => {
        const refProcesses2 = get2().refProcesses;
        if (!worker$1) {
          throw new Error("Worker not initialized");
        }
        const messageId = nanoid();
        const [input, ...rest] = args;
        const promiseInfo = getEmptyPromise(() => {
          sendToWorker(worker$1, "structured-stream", messageId, [
            schemaItems,
            parseLLMInputToBridgeJSON(input),
            ...rest
          ]);
        });
        refProcesses2.set(messageId, {
          promise: promiseInfo.promise,
          resolve: promiseInfo.resolve,
          reject: promiseInfo.reject,
          processInfo: {
            type: "invoke",
            data: [],
            lastIndex: 0
          }
        });
        const promise = promiseInfo.promise;
        return fakeStreaming(promise, messageId, refProcesses2);
      },
      toolsCallingStream: (tools, ...args) => {
        const refProcesses2 = get2().refProcesses;
        if (!worker$1) {
          throw new Error("Worker not initialized");
        }
        const messageId = nanoid();
        const [input, ...rest] = args;
        const promiseInfo = getEmptyPromise(() => {
          sendToWorker(worker$1, "tools-calling-stream", messageId, [
            tools,
            parseLLMInputToBridgeJSON(input),
            ...rest
          ]);
        });
        refProcesses2.set(messageId, {
          promise: promiseInfo.promise,
          resolve: promiseInfo.resolve,
          reject: promiseInfo.reject,
          processInfo: {
            type: "invoke",
            data: [],
            lastIndex: 0
          }
        });
        const promise = promiseInfo.promise;
        return fakeStreaming(promise, messageId, refProcesses2);
      },
      getCurrentModelInfo: async () => {
        const refProcesses2 = get2().refProcesses;
        if (!worker$1) {
          throw new Error("Worker not initialized");
        }
        const messageId = nanoid();
        const promiseInfo = getEmptyPromise(() => {
          sendToWorker(worker$1, "get-current-model-info", messageId, []);
        });
        refProcesses2.set(messageId, {
          promise: promiseInfo.promise,
          resolve: promiseInfo.resolve,
          reject: promiseInfo.reject,
          processInfo: {
            type: "get-current-model-info",
            data: [],
            lastIndex: 0
          }
        });
        return promiseInfo.promise;
      }
    };
  };
  const defaultLocalLLMState = {
    cachedLLMURLs: [],
    ready: false,
    initializing: {
      worker: true,
      init: true,
      loading: false
    },
    selectedModel: "",
    refProcesses: /* @__PURE__ */ new Map(),
    currentLoadModelMessageId: void 0,
    handler: void 0,
    initProgressCallbacks: []
  };
  useLocalLLMState = create()(devtools((set, get2) => ({
    ...defaultLocalLLMState,
    ...getLocalLLMStateActions(set, get2)
  })));
  function parsePartialJson(s) {
    if (typeof s === "undefined") {
      return null;
    }
    try {
      return JSON.parse(s);
    } catch (error) {
    }
    let new_s = "";
    const stack = [];
    let isInsideString = false;
    let escaped = false;
    for (let char of s) {
      if (isInsideString) {
        if (char === '"' && !escaped) {
          isInsideString = false;
        } else if (char === "\n" && !escaped) {
          char = "\\n";
        } else if (char === "\\") {
          escaped = !escaped;
        } else {
          escaped = false;
        }
      } else {
        if (char === '"') {
          isInsideString = true;
          escaped = false;
        } else if (char === "{") {
          stack.push("}");
        } else if (char === "[") {
          stack.push("]");
        } else if (char === "}" || char === "]") {
          if (stack && stack[stack.length - 1] === char) {
            stack.pop();
          } else {
            return null;
          }
        }
      }
      new_s += char;
    }
    if (isInsideString) {
      new_s += '"';
    }
    for (let i2 = stack.length - 1; i2 >= 0; i2 -= 1) {
      new_s += stack[i2];
    }
    try {
      return JSON.parse(new_s);
    } catch (error) {
      return null;
    }
  }
  var decamelize = function(str, sep) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    sep = typeof sep === "undefined" ? "_" : sep;
    return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
  };
  const snakeCase = getDefaultExportFromCjs$1(decamelize);
  var camelcase = {
    exports: {}
  };
  const UPPERCASE = /[\p{Lu}]/u;
  const LOWERCASE = /[\p{Ll}]/u;
  const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
  const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
  const SEPARATORS = /[_.\- ]+/;
  const LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
  const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
  const NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
  const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    for (let i2 = 0; i2 < string.length; i2++) {
      const character = string[i2];
      if (isLastCharLower && UPPERCASE.test(character)) {
        string = string.slice(0, i2) + "-" + string.slice(i2);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        i2++;
      } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
        string = string.slice(0, i2 - 1) + "-" + string.slice(i2 - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
      }
    }
    return string;
  };
  const preserveConsecutiveUppercase = (input, toLowerCase) => {
    LEADING_CAPITAL.lastIndex = 0;
    return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
  };
  const postProcess = (input, toUpperCase) => {
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m2) => toUpperCase(m2));
  };
  const camelCase = (input, options) => {
    if (!(typeof input === "string" || Array.isArray(input))) {
      throw new TypeError("Expected the input to be `string | string[]`");
    }
    options = {
      pascalCase: false,
      preserveConsecutiveUppercase: false,
      ...options
    };
    if (Array.isArray(input)) {
      input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
    } else {
      input = input.trim();
    }
    if (input.length === 0) {
      return "";
    }
    const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
    const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
    if (input.length === 1) {
      return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    const hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
      input = preserveCamelCase(input, toLowerCase, toUpperCase);
    }
    input = input.replace(LEADING_SEPARATORS, "");
    if (options.preserveConsecutiveUppercase) {
      input = preserveConsecutiveUppercase(input, toLowerCase);
    } else {
      input = toLowerCase(input);
    }
    if (options.pascalCase) {
      input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
  };
  camelcase.exports = camelCase;
  camelcase.exports.default = camelCase;
  function keyToJson(key, map) {
    return (map == null ? void 0 : map[key]) || snakeCase(key);
  }
  function mapKeys(fields, mapper, map) {
    const mapped = {};
    for (const key in fields) {
      if (Object.hasOwn(fields, key)) {
        mapped[mapper(key, map)] = fields[key];
      }
    }
    return mapped;
  }
  function shallowCopy(obj) {
    return Array.isArray(obj) ? [
      ...obj
    ] : {
      ...obj
    };
  }
  function replaceSecrets(root, secretsMap) {
    const result = shallowCopy(root);
    for (const [path, secretId] of Object.entries(secretsMap)) {
      const [last, ...partsReverse] = path.split(".").reverse();
      let current = result;
      for (const part of partsReverse.reverse()) {
        if (current[part] === void 0) {
          break;
        }
        current[part] = shallowCopy(current[part]);
        current = current[part];
      }
      if (current[last] !== void 0) {
        current[last] = {
          lc: 1,
          type: "secret",
          id: [
            secretId
          ]
        };
      }
    }
    return result;
  }
  function get_lc_unique_name(serializableClass) {
    const parentClass = Object.getPrototypeOf(serializableClass);
    const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
    if (lcNameIsSubclassed) {
      return serializableClass.lc_name();
    } else {
      return serializableClass.name;
    }
  }
  Serializable = class {
    static lc_name() {
      return this.name;
    }
    get lc_id() {
      return [
        ...this.lc_namespace,
        get_lc_unique_name(this.constructor)
      ];
    }
    get lc_secrets() {
      return void 0;
    }
    get lc_attributes() {
      return void 0;
    }
    get lc_aliases() {
      return void 0;
    }
    constructor(kwargs, ..._args) {
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.lc_kwargs = kwargs || {};
    }
    toJSON() {
      if (!this.lc_serializable) {
        return this.toJSONNotImplemented();
      }
      if (this.lc_kwargs instanceof Serializable || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)) {
        return this.toJSONNotImplemented();
      }
      const aliases = {};
      const secrets = {};
      const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
        acc[key] = key in this ? this[key] : this.lc_kwargs[key];
        return acc;
      }, {});
      for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
        Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
        Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
        Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
      }
      Object.keys(secrets).forEach((keyPath) => {
        let read = this;
        let write = kwargs;
        const [last, ...partsReverse] = keyPath.split(".").reverse();
        for (const key of partsReverse.reverse()) {
          if (!(key in read) || read[key] === void 0) return;
          if (!(key in write) || write[key] === void 0) {
            if (typeof read[key] === "object" && read[key] != null) {
              write[key] = {};
            } else if (Array.isArray(read[key])) {
              write[key] = [];
            }
          }
          read = read[key];
          write = write[key];
        }
        if (last in read && read[last] !== void 0) {
          write[last] = write[last] || read[last];
        }
      });
      return {
        lc: 1,
        type: "constructor",
        id: this.lc_id,
        kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
      };
    }
    toJSONNotImplemented() {
      return {
        lc: 1,
        type: "not_implemented",
        id: this.lc_id
      };
    }
  };
  function mergeContent(firstContent, secondContent) {
    if (typeof firstContent === "string") {
      if (typeof secondContent === "string") {
        return firstContent + secondContent;
      } else {
        return [
          {
            type: "text",
            text: firstContent
          },
          ...secondContent
        ];
      }
    } else if (Array.isArray(secondContent)) {
      return _mergeLists(firstContent, secondContent) ?? [
        ...firstContent,
        ...secondContent
      ];
    } else {
      return [
        ...firstContent,
        {
          type: "text",
          text: secondContent
        }
      ];
    }
  }
  function stringifyWithDepthLimit(obj, depthLimit) {
    function helper(obj2, currentDepth) {
      if (typeof obj2 !== "object" || obj2 === null || obj2 === void 0) {
        return obj2;
      }
      if (currentDepth >= depthLimit) {
        if (Array.isArray(obj2)) {
          return "[Array]";
        }
        return "[Object]";
      }
      if (Array.isArray(obj2)) {
        return obj2.map((item) => helper(item, currentDepth + 1));
      }
      const result = {};
      for (const key of Object.keys(obj2)) {
        result[key] = helper(obj2[key], currentDepth + 1);
      }
      return result;
    }
    return JSON.stringify(helper(obj, 0), null, 2);
  }
  class BaseMessage extends Serializable {
    get lc_aliases() {
      return {
        additional_kwargs: "additional_kwargs",
        response_metadata: "response_metadata"
      };
    }
    get text() {
      return typeof this.content === "string" ? this.content : "";
    }
    constructor(fields, kwargs) {
      if (typeof fields === "string") {
        fields = {
          content: fields,
          additional_kwargs: kwargs,
          response_metadata: {}
        };
      }
      if (!fields.additional_kwargs) {
        fields.additional_kwargs = {};
      }
      if (!fields.response_metadata) {
        fields.response_metadata = {};
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "messages"
        ]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "content", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "additional_kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "response_metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.name = fields.name;
      this.content = fields.content;
      this.additional_kwargs = fields.additional_kwargs;
      this.response_metadata = fields.response_metadata;
      this.id = fields.id;
    }
    toDict() {
      return {
        type: this._getType(),
        data: this.toJSON().kwargs
      };
    }
    static lc_name() {
      return "BaseMessage";
    }
    get _printableFields() {
      return {
        id: this.id,
        content: this.content,
        name: this.name,
        additional_kwargs: this.additional_kwargs,
        response_metadata: this.response_metadata
      };
    }
    _updateId(value) {
      this.id = value;
      this.lc_kwargs.id = value;
    }
    get [Symbol.toStringTag]() {
      return this.constructor.lc_name();
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth) {
      if (depth === null) {
        return this;
      }
      const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
      return `${this.constructor.lc_name()} ${printable}`;
    }
  }
  function _mergeDicts(left, right) {
    const merged = {
      ...left
    };
    for (const [key, value] of Object.entries(right)) {
      if (merged[key] == null) {
        merged[key] = value;
      } else if (value == null) {
        continue;
      } else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) {
        throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
      } else if (typeof merged[key] === "string") {
        if (key === "type") {
          continue;
        }
        merged[key] += value;
      } else if (typeof merged[key] === "object" && !Array.isArray(merged[key])) {
        merged[key] = _mergeDicts(merged[key], value);
      } else if (Array.isArray(merged[key])) {
        merged[key] = _mergeLists(merged[key], value);
      } else if (merged[key] === value) {
        continue;
      } else {
        console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
      }
    }
    return merged;
  }
  function _mergeLists(left, right) {
    if (left === void 0 && right === void 0) {
      return void 0;
    } else if (left === void 0 || right === void 0) {
      return left || right;
    } else {
      const merged = [
        ...left
      ];
      for (const item of right) {
        if (typeof item === "object" && "index" in item && typeof item.index === "number") {
          const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);
          if (toMerge !== -1) {
            merged[toMerge] = _mergeDicts(merged[toMerge], item);
          } else {
            merged.push(item);
          }
        } else if (typeof item === "object" && "text" in item && item.text === "") {
          continue;
        } else {
          merged.push(item);
        }
      }
      return merged;
    }
  }
  class BaseMessageChunk extends BaseMessage {
  }
  function defaultToolCallParser(rawToolCalls) {
    const toolCalls = [];
    const invalidToolCalls = [];
    for (const toolCall of rawToolCalls) {
      if (!toolCall.function) {
        continue;
      } else {
        const functionName = toolCall.function.name;
        try {
          const functionArgs = JSON.parse(toolCall.function.arguments);
          const parsed = {
            name: functionName || "",
            args: functionArgs || {},
            id: toolCall.id
          };
          toolCalls.push(parsed);
        } catch (error) {
          invalidToolCalls.push({
            name: functionName,
            args: toolCall.function.arguments,
            id: toolCall.id,
            error: "Malformed args."
          });
        }
      }
    }
    return [
      toolCalls,
      invalidToolCalls
    ];
  }
  AIMessage = class extends BaseMessage {
    get lc_aliases() {
      return {
        ...super.lc_aliases,
        tool_calls: "tool_calls",
        invalid_tool_calls: "invalid_tool_calls"
      };
    }
    constructor(fields, kwargs) {
      var _a;
      let initParams;
      if (typeof fields === "string") {
        initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          additional_kwargs: kwargs ?? {}
        };
      } else {
        initParams = fields;
        const rawToolCalls = (_a = initParams.additional_kwargs) == null ? void 0 : _a.tool_calls;
        const toolCalls = initParams.tool_calls;
        if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === void 0 || toolCalls.length === 0)) {
          console.warn([
            "New LangChain packages are available that more efficiently handle",
            "tool calling.\n\nPlease upgrade your packages to versions that set",
            "message tool calls. e.g., `yarn add @langchain/anthropic`,",
            "yarn add @langchain/openai`, etc."
          ].join(" "));
        }
        try {
          if (!(rawToolCalls == null) && toolCalls === void 0) {
            const [toolCalls2, invalidToolCalls] = defaultToolCallParser(rawToolCalls);
            initParams.tool_calls = toolCalls2 ?? [];
            initParams.invalid_tool_calls = invalidToolCalls ?? [];
          } else {
            initParams.tool_calls = initParams.tool_calls ?? [];
            initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];
          }
        } catch (e) {
          initParams.tool_calls = [];
          initParams.invalid_tool_calls = [];
        }
      }
      super(initParams);
      Object.defineProperty(this, "tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "invalid_tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "usage_metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (typeof initParams !== "string") {
        this.tool_calls = initParams.tool_calls ?? this.tool_calls;
        this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
      }
      this.usage_metadata = initParams.usage_metadata;
    }
    static lc_name() {
      return "AIMessage";
    }
    _getType() {
      return "ai";
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        tool_calls: this.tool_calls,
        invalid_tool_calls: this.invalid_tool_calls,
        usage_metadata: this.usage_metadata
      };
    }
  };
  class AIMessageChunk extends BaseMessageChunk {
    constructor(fields) {
      let initParams;
      if (typeof fields === "string") {
        initParams = {
          content: fields,
          tool_calls: [],
          invalid_tool_calls: [],
          tool_call_chunks: []
        };
      } else if (fields.tool_call_chunks === void 0) {
        initParams = {
          ...fields,
          tool_calls: fields.tool_calls ?? [],
          invalid_tool_calls: [],
          tool_call_chunks: []
        };
      } else {
        const toolCalls = [];
        const invalidToolCalls = [];
        for (const toolCallChunk of fields.tool_call_chunks) {
          let parsedArgs = {};
          try {
            parsedArgs = parsePartialJson(toolCallChunk.args || "{}");
            if (parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs)) {
              throw new Error("Malformed tool call chunk args.");
            }
            toolCalls.push({
              name: toolCallChunk.name ?? "",
              args: parsedArgs,
              id: toolCallChunk.id,
              type: "tool_call"
            });
          } catch (e) {
            invalidToolCalls.push({
              name: toolCallChunk.name,
              args: toolCallChunk.args,
              id: toolCallChunk.id,
              error: "Malformed args.",
              type: "invalid_tool_call"
            });
          }
        }
        initParams = {
          ...fields,
          tool_calls: toolCalls,
          invalid_tool_calls: invalidToolCalls
        };
      }
      super(initParams);
      Object.defineProperty(this, "tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "invalid_tool_calls", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "tool_call_chunks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "usage_metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;
      this.tool_calls = initParams.tool_calls ?? this.tool_calls;
      this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;
      this.usage_metadata = initParams.usage_metadata;
    }
    get lc_aliases() {
      return {
        ...super.lc_aliases,
        tool_calls: "tool_calls",
        invalid_tool_calls: "invalid_tool_calls",
        tool_call_chunks: "tool_call_chunks"
      };
    }
    static lc_name() {
      return "AIMessageChunk";
    }
    _getType() {
      return "ai";
    }
    get _printableFields() {
      return {
        ...super._printableFields,
        tool_calls: this.tool_calls,
        tool_call_chunks: this.tool_call_chunks,
        invalid_tool_calls: this.invalid_tool_calls,
        usage_metadata: this.usage_metadata
      };
    }
    concat(chunk) {
      const combinedFields = {
        content: mergeContent(this.content, chunk.content),
        additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
        response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
        tool_call_chunks: [],
        id: this.id ?? chunk.id
      };
      if (this.tool_call_chunks !== void 0 || chunk.tool_call_chunks !== void 0) {
        const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
        if (rawToolCalls !== void 0 && rawToolCalls.length > 0) {
          combinedFields.tool_call_chunks = rawToolCalls;
        }
      }
      if (this.usage_metadata !== void 0 || chunk.usage_metadata !== void 0) {
        const left = this.usage_metadata ?? {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        };
        const right = chunk.usage_metadata ?? {
          input_tokens: 0,
          output_tokens: 0,
          total_tokens: 0
        };
        const usage_metadata = {
          input_tokens: left.input_tokens + right.input_tokens,
          output_tokens: left.output_tokens + right.output_tokens,
          total_tokens: left.total_tokens + right.total_tokens
        };
        combinedFields.usage_metadata = usage_metadata;
      }
      return new AIMessageChunk(combinedFields);
    }
  }
  HumanMessage = class extends BaseMessage {
    static lc_name() {
      return "HumanMessage";
    }
    _getType() {
      return "human";
    }
  };
  SystemMessage = class extends BaseMessage {
    static lc_name() {
      return "SystemMessage";
    }
    _getType() {
      return "system";
    }
  };
  function _isToolCall(toolCall) {
    return !!(toolCall && typeof toolCall === "object" && "type" in toolCall && toolCall.type === "tool_call");
  }
  class ToolInputParsingException extends Error {
    constructor(message, output) {
      super(message);
      Object.defineProperty(this, "output", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.output = output;
    }
  }
  function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
    const string_messages = [];
    for (const m2 of messages) {
      let role;
      if (m2._getType() === "human") {
        role = humanPrefix;
      } else if (m2._getType() === "ai") {
        role = aiPrefix;
      } else if (m2._getType() === "system") {
        role = "System";
      } else if (m2._getType() === "function") {
        role = "Function";
      } else if (m2._getType() === "tool") {
        role = "Tool";
      } else if (m2._getType() === "generic") {
        role = m2.role;
      } else {
        throw new Error(`Got unsupported message type: ${m2._getType()}`);
      }
      const nameStr = m2.name ? `${m2.name}, ` : "";
      const readableContent = typeof m2.content === "string" ? m2.content : JSON.stringify(m2.content, null, 2);
      string_messages.push(`${role}: ${nameStr}${readableContent}`);
    }
    return string_messages.join("\n");
  }
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
      const filtered = {};
      for (const k2 of validKeys) {
        filtered[k2] = obj[k2];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr2, checker) => {
      for (const item of arr2) {
        if (checker(item)) return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [
          ...this.issues,
          sub
        ];
      };
      this.addIssues = (subs = []) => {
        this.issues = [
          ...this.issues,
          ...subs
        ];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = {
        _errors: []
      };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el2 = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el2] = curr[el2] || {
                  _errors: []
                };
              } else {
                curr[el2] = curr[el2] || {
                  _errors: []
                };
                curr[el2]._errors.push(mapper(issue));
              }
              curr = curr[el2];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return {
        formErrors,
        fieldErrors
      };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return {
      message
    };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
      ...path,
      ...issueData.path || []
    ];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, {
        data,
        defaultError: errorMessage
      }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        overrideMap,
        overrideMap === errorMap ? void 0 : errorMap
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid") this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status2, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted") return INVALID;
        if (s.status === "dirty") status2.dirty();
        arrayValue.push(s.value);
      }
      return {
        status: status2.value,
        value: arrayValue
      };
    }
    static async mergeObjectAsync(status2, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return ParseStatus.mergeObjectSync(status2, syncPairs);
    }
    static mergeObjectSync(status2, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted") return INVALID;
        if (value.status === "aborted") return INVALID;
        if (key.status === "dirty") status2.dirty();
        if (value.status === "dirty") status2.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return {
        status: status2.value,
        value: finalObject
      };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({
    status: "dirty",
    value
  });
  const OK = (value) => ({
    status: "valid",
    value
  });
  const isAborted = (x2) => x2.status === "aborted";
  const isDirty = (x2) => x2.status === "dirty";
  const isValid = (x2) => x2.status === "valid";
  const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
  function __classPrivateFieldGet(receiver, state, kind, f2) {
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f2) {
    if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return state.set(receiver, value), value;
  }
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? {
      message
    } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var _ZodEnum_cache, _ZodNativeEnum_cache;
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result) => {
    if (isValid(result)) {
      return {
        success: true,
        data: result.value
      };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error) return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params) return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2) return {
      errorMap: errorMap2,
      description
    };
    const customMap = (iss, ctx) => {
      var _a, _b;
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return {
          message: message !== null && message !== void 0 ? message : ctx.defaultError
        };
      }
      if (typeof ctx.data === "undefined") {
        return {
          message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError
        };
      }
      if (iss.code !== "invalid_type") return {
        message: ctx.defaultError
      };
      return {
        message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError
      };
    };
    return {
      errorMap: customMap,
      description
    };
  }
  class ZodType {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success) return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({
        data,
        path: ctx.path,
        parent: ctx
      });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success) return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return {
            message
          };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: {
          type: "refinement",
          refinement
        }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([
        this,
        option
      ], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: {
          type: "transform",
          transform
        }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[0-9a-z]+$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const nanoidRegex = /^[a-z0-9_-]{21}$/i;
  const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex$1;
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  const dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
      regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status2 = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status2.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex$1) {
            emojiRegex$1 = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex$1.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: {
                includes: check.value,
                position: check.position
              },
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: {
                startsWith: check.value
              },
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: {
                endsWith: check.value
              },
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status2.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status2.value,
        value: input.data
      };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [
          ...this._def.checks,
          check
        ]
      });
    }
    email(message) {
      return this._addCheck({
        kind: "email",
        ...errorUtil.errToObj(message)
      });
    }
    url(message) {
      return this._addCheck({
        kind: "url",
        ...errorUtil.errToObj(message)
      });
    }
    emoji(message) {
      return this._addCheck({
        kind: "emoji",
        ...errorUtil.errToObj(message)
      });
    }
    uuid(message) {
      return this._addCheck({
        kind: "uuid",
        ...errorUtil.errToObj(message)
      });
    }
    nanoid(message) {
      return this._addCheck({
        kind: "nanoid",
        ...errorUtil.errToObj(message)
      });
    }
    cuid(message) {
      return this._addCheck({
        kind: "cuid",
        ...errorUtil.errToObj(message)
      });
    }
    cuid2(message) {
      return this._addCheck({
        kind: "cuid2",
        ...errorUtil.errToObj(message)
      });
    }
    ulid(message) {
      return this._addCheck({
        kind: "ulid",
        ...errorUtil.errToObj(message)
      });
    }
    base64(message) {
      return this._addCheck({
        kind: "base64",
        ...errorUtil.errToObj(message)
      });
    }
    ip(options) {
      return this._addCheck({
        kind: "ip",
        ...errorUtil.errToObj(options)
      });
    }
    datetime(options) {
      var _a, _b;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    date(message) {
      return this._addCheck({
        kind: "date",
        message
      });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    duration(message) {
      return this._addCheck({
        kind: "duration",
        ...errorUtil.errToObj(message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len2, message) {
      return this._addCheck({
        kind: "length",
        value: len2,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: "trim"
          }
        ]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: "toLowerCase"
          }
        ]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: "toUpperCase"
          }
        ]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch2) => ch2.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch2) => ch2.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch2) => ch2.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch2) => ch2.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch2) => ch2.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch2) => ch2.kind === "ip");
    }
    get isBase64() {
      return !!this._def.checks.find((ch2) => ch2.kind === "base64");
    }
    get minLength() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min) min = ch2.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max) max = ch2.value;
        }
      }
      return max;
    }
  }
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status2 = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status2.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status2.value,
        value: input.data
      };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          check
        ]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min) min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max) max = ch2.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
          return true;
        } else if (ch2.kind === "min") {
          if (min === null || ch2.value > min) min = ch2.value;
        } else if (ch2.kind === "max") {
          if (max === null || ch2.value < max) max = ch2.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status2 = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status2.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status2.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status2.value,
        value: input.data
      };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          check
        ]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min) min = ch2.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max) max = ch2.value;
        }
      }
      return max;
    }
  }
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status2 = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status2.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status2.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status2.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [
          ...this._def.checks,
          check
        ]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "min") {
          if (min === null || ch2.value > min) min = ch2.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch2 of this._def.checks) {
        if (ch2.kind === "max") {
          if (max === null || ch2.value < max) max = ch2.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status: status2 } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status2.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status2.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status2.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([
          ...ctx.data
        ].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result2) => {
          return ParseStatus.mergeArray(status2, result2);
        });
      }
      const result = [
        ...ctx.data
      ].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status2, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: {
          value: minLength,
          message: errorUtil.toString(message)
        }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: {
          value: maxLength,
          message: errorUtil.toString(message)
        }
      });
    }
    length(len2, message) {
      return new ZodArray({
        ...this._def,
        exactLength: {
          value: len2,
          message: errorUtil.toString(message)
        }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null) return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = {
        shape,
        keys
      };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status: status2, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: {
            status: "valid",
            value: key
          },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: {
                status: "valid",
                value: key
              },
              value: {
                status: "valid",
                value: ctx.data[key]
              }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status2.dirty();
          }
        } else if (unknownKeys === "strip") ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: {
              status: "valid",
              value: key
            },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status2, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status2, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys") return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({
        [key]: schema
      });
    }
    catchall(index2) {
      return new ZodObject({
        ...this._def,
        catchall: index2
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = {
              result,
              ctx: childCtx
            };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [
        type.value
      ];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [
        void 0
      ];
    } else if (type instanceof ZodNull) {
      return [
        null
      ];
    } else if (type instanceof ZodOptional) {
      return [
        void 0,
        ...getDiscriminator(type.unwrap())
      ];
    } else if (type instanceof ZodNullable) {
      return [
        null,
        ...getDiscriminator(type.unwrap())
      ];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [
            discriminator
          ]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return {
        valid: true,
        data: a
      };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = {
        ...a,
        ...b
      };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return {
            valid: false
          };
        }
        newObj[key] = sharedValue.data;
      }
      return {
        valid: true,
        data: newObj
      };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return {
          valid: false
        };
      }
      const newArray = [];
      for (let index2 = 0; index2 < a.length; index2++) {
        const itemA = a[index2];
        const itemB = b[index2];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return {
            valid: false
          };
        }
        newArray.push(sharedValue.data);
      }
      return {
        valid: true,
        data: newArray
      };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return {
        valid: true,
        data: a
      };
    } else {
      return {
        valid: false
      };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status2.dirty();
        }
        return {
          status: status2.value,
          value: merged.data
        };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status2.dirty();
      }
      const items = [
        ...ctx.data
      ].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema) return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status2, results);
        });
      } else {
        return ParseStatus.mergeArray(status2, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status2, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status2, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [
        ...ctx.data.entries()
      ].map(([key, value], index2) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
            index2,
            "key"
          ])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
            index2,
            "value"
          ]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status2.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return {
            status: status2.value,
            value: finalMap
          };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status2.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return {
          status: status2.value,
          value: finalMap
        };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status2.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status2.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted") return INVALID;
          if (element.status === "dirty") status2.dirty();
          parsedSet.add(element.value);
        }
        return {
          status: status2.value,
          value: parsedSet
        };
      }
      const elements = [
        ...ctx.data.values()
      ].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: {
          value: minSize,
          message: errorUtil.toString(message)
        }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: {
          value: maxSize,
          message: errorUtil.toString(message)
        }
      });
    }
    size(size2, message) {
      return this.min(size2, message).max(size2, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = {
        errorMap: ctx.common.contextualErrorMap
      };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me2 = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me2 = this;
        return OK(function(...args) {
          const parsedArgs = me2._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([
              makeArgsIssue(args, parsedArgs.error)
            ]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me2._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([
              makeReturnsIssue(result, parsedReturns.error)
            ]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return {
        status: "valid",
        value: input.data
      };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
      }
      if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  }
  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    constructor() {
      super(...arguments);
      _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
      }
      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status2.abort();
          } else {
            status2.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status2.value === "aborted") return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted") return INVALID;
            if (result.status === "dirty") return DIRTY(result.value);
            if (status2.value === "dirty") return DIRTY(result.value);
            return result;
          });
        } else {
          if (status2.value === "aborted") return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted") return INVALID;
          if (result.status === "dirty") return DIRTY(result.value);
          if (status2.value === "dirty") return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted") return INVALID;
          if (inner.status === "dirty") status2.dirty();
          executeRefinement(inner.value);
          return {
            status: status2.value,
            value: inner.value
          };
        } else {
          return this._def.schema._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }).then((inner) => {
            if (inner.status === "aborted") return INVALID;
            if (inner.status === "dirty") status2.dirty();
            return executeRefinement(inner.value).then(() => {
              return {
                status: status2.value,
                value: inner.value
              };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base)) return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return {
            status: status2.value,
            value: result
          };
        } else {
          return this._def.schema._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }).then((base) => {
            if (!isValid(base)) return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status2.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: {
        type: "preprocess",
        transform: preprocess
      },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return {
        status: "valid",
        value: input.data
      };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status: status2, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted") return INVALID;
          if (inResult.status === "dirty") {
            status2.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted") return INVALID;
        if (inResult.status === "dirty") {
          status2.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function custom(check, params = {}, fatal) {
    if (check) return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? {
          message: params
        } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? {
          message: p2
        } : p2;
        ctx.addIssue({
          code: "custom",
          ...p22,
          fatal: _fatal
        });
      }
    });
    return ZodAny.create();
  }
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce$2 = {
    string: (arg) => ZodString.create({
      ...arg,
      coerce: true
    }),
    number: (arg) => ZodNumber.create({
      ...arg,
      coerce: true
    }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({
      ...arg,
      coerce: true
    }),
    date: (arg) => ZodDate.create({
      ...arg,
      coerce: true
    })
  };
  const NEVER = INVALID;
  var z = Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    datetimeRegex,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce: coerce$2,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  var pRetry$2 = {
    exports: {}
  };
  var retry$2 = {};
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = {
        forever: options
      };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  var retry_operation = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (this._timer) {
      clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = (/* @__PURE__ */ new Date()).getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.push(err);
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(0, this._errors.length - 1);
        timeout = this._cachedTimeouts.slice(-1);
      } else {
        return false;
      }
    }
    var self2 = this;
    this._timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      this._timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = (/* @__PURE__ */ new Date()).getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i2 = 0; i2 < this._errors.length; i2++) {
      var error = this._errors[i2];
      var message = error.message;
      var count2 = (counts[message] || 0) + 1;
      counts[message] = count2;
      if (count2 >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count2;
      }
    }
    return mainError;
  };
  (function(exports) {
    var RetryOperation2 = retry_operation;
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation2(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i2 = 0; i2 < opts.retries; i2++) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i2, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i2 = 0; i2 < methods.length; i2++) {
        var method = methods[i2];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  })(retry$2);
  var retry$1 = retry$2;
  const retry = retry$1;
  const networkErrorMsgs = [
    "Failed to fetch",
    "NetworkError when attempting to fetch resource.",
    "The Internet connection appears to be offline.",
    "Network request failed"
  ];
  class AbortError extends Error {
    constructor(message) {
      super();
      if (message instanceof Error) {
        this.originalError = message;
        ({ message } = message);
      } else {
        this.originalError = new Error(message);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message;
    }
  }
  const decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  const isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
  const pRetry = (input, options) => new Promise((resolve, reject) => {
    options = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...options
    };
    const operation = retry.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && !isNetworkError(error.message)) {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options);
          try {
            await options.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
  });
  pRetry$2.exports = pRetry;
  pRetry$2.exports.default = pRetry;
  pRetry$2.exports.AbortError = AbortError;
  var pRetryExports = pRetry$2.exports;
  const pRetry$1 = getDefaultExportFromCjs$1(pRetryExports);
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  function validate$1(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i$2 = 0; i$2 < 256; ++i$2) {
    byteToHex.push((i$2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr2, offset = 0) {
    return (byteToHex[arr2[offset + 0]] + byteToHex[arr2[offset + 1]] + byteToHex[arr2[offset + 2]] + byteToHex[arr2[offset + 3]] + "-" + byteToHex[arr2[offset + 4]] + byteToHex[arr2[offset + 5]] + "-" + byteToHex[arr2[offset + 6]] + byteToHex[arr2[offset + 7]] + "-" + byteToHex[arr2[offset + 8]] + byteToHex[arr2[offset + 9]] + "-" + byteToHex[arr2[offset + 10]] + byteToHex[arr2[offset + 11]] + byteToHex[arr2[offset + 12]] + byteToHex[arr2[offset + 13]] + byteToHex[arr2[offset + 14]] + byteToHex[arr2[offset + 15]]).toLowerCase();
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  const native = {
    randomUUID
  };
  function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
  }
  let MockAsyncLocalStorage$1 = class MockAsyncLocalStorage {
    getStore() {
      return void 0;
    }
    run(_, callback) {
      return callback();
    }
  };
  const TRACING_ALS_KEY$1 = Symbol.for("ls:tracing_async_local_storage");
  const mockAsyncLocalStorage$1 = new MockAsyncLocalStorage$1();
  let AsyncLocalStorageProvider$1 = class AsyncLocalStorageProvider {
    getInstance() {
      return globalThis[TRACING_ALS_KEY$1] ?? mockAsyncLocalStorage$1;
    }
    initializeGlobalInstance(instance2) {
      if (globalThis[TRACING_ALS_KEY$1] === void 0) {
        globalThis[TRACING_ALS_KEY$1] = instance2;
      }
    }
  };
  const AsyncLocalStorageProviderSingleton$1 = new AsyncLocalStorageProvider$1();
  const getCurrentRunTree = () => {
    const runTree = AsyncLocalStorageProviderSingleton$1.getInstance().getStore();
    if (runTree === void 0) {
      throw new Error([
        "Could not get the current run tree.",
        "",
        "Please make sure you are calling this method within a traceable function or the tracing is enabled."
      ].join("\n"));
    }
    return runTree;
  };
  function isTraceableFunction(x2) {
    return typeof x2 === "function" && "langsmith:traceable" in x2;
  }
  const _hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwnProperty(obj, key) {
    return _hasOwnProperty.call(obj, key);
  }
  function _objectKeys(obj) {
    if (Array.isArray(obj)) {
      const keys2 = new Array(obj.length);
      for (let k2 = 0; k2 < keys2.length; k2++) {
        keys2[k2] = "" + k2;
      }
      return keys2;
    }
    if (Object.keys) {
      return Object.keys(obj);
    }
    let keys = [];
    for (let i2 in obj) {
      if (hasOwnProperty(obj, i2)) {
        keys.push(i2);
      }
    }
    return keys;
  }
  function _deepClone(obj) {
    switch (typeof obj) {
      case "object":
        return JSON.parse(JSON.stringify(obj));
      case "undefined":
        return null;
      default:
        return obj;
    }
  }
  function isInteger(str) {
    let i2 = 0;
    const len2 = str.length;
    let charCode;
    while (i2 < len2) {
      charCode = str.charCodeAt(i2);
      if (charCode >= 48 && charCode <= 57) {
        i2++;
        continue;
      }
      return false;
    }
    return true;
  }
  function unescapePathComponent(path) {
    return path.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function hasUndefined(obj) {
    if (obj === void 0) {
      return true;
    }
    if (obj) {
      if (Array.isArray(obj)) {
        for (let i3 = 0, len2 = obj.length; i3 < len2; i3++) {
          if (hasUndefined(obj[i3])) {
            return true;
          }
        }
      } else if (typeof obj === "object") {
        const objKeys = _objectKeys(obj);
        const objKeysLength = objKeys.length;
        for (var i2 = 0; i2 < objKeysLength; i2++) {
          if (hasUndefined(obj[objKeys[i2]])) {
            return true;
          }
        }
      }
    }
    return false;
  }
  function patchErrorMessageFormatter(message, args) {
    const messageParts = [
      message
    ];
    for (const key in args) {
      const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
      if (typeof value !== "undefined") {
        messageParts.push(`${key}: ${value}`);
      }
    }
    return messageParts.join("\n");
  }
  class PatchError extends Error {
    constructor(message, name, index2, operation, tree) {
      super(patchErrorMessageFormatter(message, {
        name,
        index: index2,
        operation,
        tree
      }));
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: name
      });
      Object.defineProperty(this, "index", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: index2
      });
      Object.defineProperty(this, "operation", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: operation
      });
      Object.defineProperty(this, "tree", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: tree
      });
      Object.setPrototypeOf(this, new.target.prototype);
      this.message = patchErrorMessageFormatter(message, {
        name,
        index: index2,
        operation,
        tree
      });
    }
  }
  const JsonPatchError = PatchError;
  const objOps = {
    add: function(obj, key, document2) {
      obj[key] = this.value;
      return {
        newDocument: document2
      };
    },
    remove: function(obj, key, document2) {
      var removed = obj[key];
      delete obj[key];
      return {
        newDocument: document2,
        removed
      };
    },
    replace: function(obj, key, document2) {
      var removed = obj[key];
      obj[key] = this.value;
      return {
        newDocument: document2,
        removed
      };
    },
    move: function(obj, key, document2) {
      let removed = getValueByPointer(document2, this.path);
      if (removed) {
        removed = _deepClone(removed);
      }
      const originalValue = applyOperation(document2, {
        op: "remove",
        path: this.from
      }).removed;
      applyOperation(document2, {
        op: "add",
        path: this.path,
        value: originalValue
      });
      return {
        newDocument: document2,
        removed
      };
    },
    copy: function(obj, key, document2) {
      const valueToCopy = getValueByPointer(document2, this.from);
      applyOperation(document2, {
        op: "add",
        path: this.path,
        value: _deepClone(valueToCopy)
      });
      return {
        newDocument: document2
      };
    },
    test: function(obj, key, document2) {
      return {
        newDocument: document2,
        test: _areEquals(obj[key], this.value)
      };
    },
    _get: function(obj, key, document2) {
      this.value = obj[key];
      return {
        newDocument: document2
      };
    }
  };
  var arrOps = {
    add: function(arr2, i2, document2) {
      if (isInteger(i2)) {
        arr2.splice(i2, 0, this.value);
      } else {
        arr2[i2] = this.value;
      }
      return {
        newDocument: document2,
        index: i2
      };
    },
    remove: function(arr2, i2, document2) {
      var removedList = arr2.splice(i2, 1);
      return {
        newDocument: document2,
        removed: removedList[0]
      };
    },
    replace: function(arr2, i2, document2) {
      var removed = arr2[i2];
      arr2[i2] = this.value;
      return {
        newDocument: document2,
        removed
      };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
  };
  function getValueByPointer(document2, pointer) {
    if (pointer == "") {
      return document2;
    }
    var getOriginalDestination = {
      op: "_get",
      path: pointer
    };
    applyOperation(document2, getOriginalDestination);
    return getOriginalDestination.value;
  }
  function applyOperation(document2, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index2 = 0) {
    if (validateOperation) {
      if (typeof validateOperation == "function") {
        validateOperation(operation, 0, document2, operation.path);
      } else {
        validator(operation, 0);
      }
    }
    if (operation.path === "") {
      let returnValue = {
        newDocument: document2
      };
      if (operation.op === "add") {
        returnValue.newDocument = operation.value;
        return returnValue;
      } else if (operation.op === "replace") {
        returnValue.newDocument = operation.value;
        returnValue.removed = document2;
        return returnValue;
      } else if (operation.op === "move" || operation.op === "copy") {
        returnValue.newDocument = getValueByPointer(document2, operation.from);
        if (operation.op === "move") {
          returnValue.removed = document2;
        }
        return returnValue;
      } else if (operation.op === "test") {
        returnValue.test = _areEquals(document2, operation.value);
        if (returnValue.test === false) {
          throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
        }
        returnValue.newDocument = document2;
        return returnValue;
      } else if (operation.op === "remove") {
        returnValue.removed = document2;
        returnValue.newDocument = null;
        return returnValue;
      } else if (operation.op === "_get") {
        operation.value = document2;
        return returnValue;
      } else {
        if (validateOperation) {
          throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
        } else {
          return returnValue;
        }
      }
    } else {
      if (!mutateDocument) {
        document2 = _deepClone(document2);
      }
      const path = operation.path || "";
      const keys = path.split("/");
      let obj = document2;
      let t2 = 1;
      let len2 = keys.length;
      let existingPathFragment = void 0;
      let key;
      let validateFunction;
      if (typeof validateOperation == "function") {
        validateFunction = validateOperation;
      } else {
        validateFunction = validator;
      }
      while (true) {
        key = keys[t2];
        if (key && key.indexOf("~") != -1) {
          key = unescapePathComponent(key);
        }
        if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t2 > 0 && keys[t2 - 1] == "constructor")) {
          throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
        }
        if (validateOperation) {
          if (existingPathFragment === void 0) {
            if (obj[key] === void 0) {
              existingPathFragment = keys.slice(0, t2).join("/");
            } else if (t2 == len2 - 1) {
              existingPathFragment = operation.path;
            }
            if (existingPathFragment !== void 0) {
              validateFunction(operation, 0, document2, existingPathFragment);
            }
          }
        }
        t2++;
        if (Array.isArray(obj)) {
          if (key === "-") {
            key = obj.length;
          } else {
            if (validateOperation && !isInteger(key)) {
              throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index2, operation, document2);
            } else if (isInteger(key)) {
              key = ~~key;
            }
          }
          if (t2 >= len2) {
            if (validateOperation && operation.op === "add" && key > obj.length) {
              throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index2, operation, document2);
            }
            const returnValue = arrOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
            }
            return returnValue;
          }
        } else {
          if (t2 >= len2) {
            const returnValue = objOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
            }
            return returnValue;
          }
        }
        obj = obj[key];
        if (validateOperation && t2 < len2 && (!obj || typeof obj !== "object")) {
          throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
        }
      }
    }
  }
  function applyPatch(document2, patch2, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
    if (validateOperation) {
      if (!Array.isArray(patch2)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
    }
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    const results = new Array(patch2.length);
    for (let i2 = 0, length = patch2.length; i2 < length; i2++) {
      results[i2] = applyOperation(document2, patch2[i2], validateOperation, true, banPrototypeModifications, i2);
      document2 = results[i2].newDocument;
    }
    results.newDocument = document2;
    return results;
  }
  function validator(operation, index2, document2, existingPathFragment) {
    if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
      throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, document2);
    } else if (!objOps[operation.op]) {
      throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
    } else if (typeof operation.path !== "string") {
      throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, document2);
    } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
      throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index2, operation, document2);
    } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
      throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, document2);
    } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
      throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, document2);
    } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
      throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, document2);
    } else if (document2) {
      if (operation.op == "add") {
        var pathLen = operation.path.split("/").length;
        var existingPathLen = existingPathFragment.split("/").length;
        if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
          throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, document2);
        }
      } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
        if (operation.path !== existingPathFragment) {
          throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
        }
      } else if (operation.op === "move" || operation.op === "copy") {
        var existingValue = {
          op: "_get",
          path: operation.from,
          value: void 0
        };
        var error = validate([
          existingValue
        ], document2);
        if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
          throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, document2);
        }
      }
    }
  }
  function validate(sequence, document2, externalValidator) {
    try {
      if (!Array.isArray(sequence)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
      if (document2) {
        applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
      } else {
        externalValidator = externalValidator || validator;
        for (var i2 = 0; i2 < sequence.length; i2++) {
          externalValidator(sequence[i2], i2, document2, void 0);
        }
      }
    } catch (e) {
      if (e instanceof JsonPatchError) {
        return e;
      } else {
        throw e;
      }
    }
  }
  function _areEquals(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      var arrA = Array.isArray(a), arrB = Array.isArray(b), i2, length, key;
      if (arrA && arrB) {
        length = a.length;
        if (length != b.length) return false;
        for (i2 = length; i2-- !== 0; ) if (!_areEquals(a[i2], b[i2])) return false;
        return true;
      }
      if (arrA != arrB) return false;
      var keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i2 = length; i2-- !== 0; ) if (!b.hasOwnProperty(keys[i2])) return false;
      for (i2 = length; i2-- !== 0; ) {
        key = keys[i2];
        if (!_areEquals(a[key], b[key])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var browser = {
    exports: {}
  };
  var process = browser.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue$1 = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue$1 = currentQueue.concat(queue$1);
    } else {
      queueIndex = -1;
    }
    if (queue$1.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len2 = queue$1.length;
    while (len2) {
      currentQueue = queue$1;
      queue$1 = [];
      while (++queueIndex < len2) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len2 = queue$1.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue$1.push(new Item(fun, args));
    if (queue$1.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = "browser";
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = "";
  process.versions = {};
  function noop() {
  }
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  process.listeners = function(name) {
    return [];
  };
  process.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process.cwd = function() {
    return "/";
  };
  process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process.umask = function() {
    return 0;
  };
  var browserExports = browser.exports;
  process$1 = getDefaultExportFromCjs(browserExports);
  var define_process_env_default$2 = {};
  const isBrowser$1 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
  const isWebWorker$1 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
  const isJsDom$1 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
  const isDeno$1 = () => typeof Deno !== "undefined";
  const isNode$1 = () => typeof process$1 !== "undefined" && typeof process$1.versions !== "undefined" && typeof process$1.versions.node !== "undefined" && !isDeno$1();
  const getEnv$1 = () => {
    let env;
    if (isBrowser$1()) {
      env = "browser";
    } else if (isNode$1()) {
      env = "node";
    } else if (isWebWorker$1()) {
      env = "webworker";
    } else if (isJsDom$1()) {
      env = "jsdom";
    } else if (isDeno$1()) {
      env = "deno";
    } else {
      env = "other";
    }
    return env;
  };
  let runtimeEnvironment$1;
  async function getRuntimeEnvironment$1() {
    if (runtimeEnvironment$1 === void 0) {
      const env = getEnv$1();
      runtimeEnvironment$1 = {
        library: "langchain-js",
        runtime: env
      };
    }
    return runtimeEnvironment$1;
  }
  function getEnvironmentVariable$1(name) {
    try {
      return typeof process$1 !== "undefined" ? define_process_env_default$2 == null ? void 0 : define_process_env_default$2[name] : void 0;
    } catch (e) {
      return void 0;
    }
  }
  class BaseCallbackHandlerMethodsClass {
  }
  class BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {
    get lc_namespace() {
      return [
        "langchain_core",
        "callbacks",
        this.name
      ];
    }
    get lc_secrets() {
      return void 0;
    }
    get lc_attributes() {
      return void 0;
    }
    get lc_aliases() {
      return void 0;
    }
    static lc_name() {
      return this.name;
    }
    get lc_id() {
      return [
        ...this.lc_namespace,
        get_lc_unique_name(this.constructor)
      ];
    }
    constructor(input) {
      super();
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "ignoreLLM", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreChain", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreAgent", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreRetriever", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "ignoreCustomEvent", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "raiseError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "awaitHandlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: getEnvironmentVariable$1("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
      });
      this.lc_kwargs = input || {};
      if (input) {
        this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;
        this.ignoreChain = input.ignoreChain ?? this.ignoreChain;
        this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;
        this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;
        this.ignoreCustomEvent = input.ignoreCustomEvent ?? this.ignoreCustomEvent;
        this.raiseError = input.raiseError ?? this.raiseError;
        this.awaitHandlers = this.raiseError || (input._awaitHandler ?? this.awaitHandlers);
      }
    }
    copy() {
      return new this.constructor(this);
    }
    toJSON() {
      return Serializable.prototype.toJSON.call(this);
    }
    toJSONNotImplemented() {
      return Serializable.prototype.toJSONNotImplemented.call(this);
    }
    static fromMethods(methods) {
      class Handler extends BaseCallbackHandler {
        constructor() {
          super();
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: v4()
          });
          Object.assign(this, methods);
        }
      }
      return new Handler();
    }
  }
  function _coerceToDict$1(value, defaultKey) {
    return value && !Array.isArray(value) && typeof value === "object" ? value : {
      [defaultKey]: value
    };
  }
  function stripNonAlphanumeric$1(input) {
    return input.replace(/[-:.]/g, "");
  }
  function convertToDottedOrderFormat$1(epoch, runId, executionOrder) {
    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
    return stripNonAlphanumeric$1(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
  }
  function isBaseTracer(x2) {
    return typeof x2._addRunToRunMap === "function";
  }
  class BaseTracer extends BaseCallbackHandler {
    constructor(_fields) {
      super(...arguments);
      Object.defineProperty(this, "runMap", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
    }
    copy() {
      return this;
    }
    stringifyError(error) {
      if (error instanceof Error) {
        return error.message + ((error == null ? void 0 : error.stack) ? `

${error.stack}` : "");
      }
      if (typeof error === "string") {
        return error;
      }
      return `${error}`;
    }
    _addChildRun(parentRun, childRun) {
      parentRun.child_runs.push(childRun);
    }
    _addRunToRunMap(run) {
      const currentDottedOrder = convertToDottedOrderFormat$1(run.start_time, run.id, run.execution_order);
      const storedRun = {
        ...run
      };
      if (storedRun.parent_run_id !== void 0) {
        const parentRun = this.runMap.get(storedRun.parent_run_id);
        if (parentRun) {
          this._addChildRun(parentRun, storedRun);
          parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
          storedRun.trace_id = parentRun.trace_id;
          if (parentRun.dotted_order !== void 0) {
            storedRun.dotted_order = [
              parentRun.dotted_order,
              currentDottedOrder
            ].join(".");
          }
        }
      } else {
        storedRun.trace_id = storedRun.id;
        storedRun.dotted_order = currentDottedOrder;
      }
      this.runMap.set(storedRun.id, storedRun);
      return storedRun;
    }
    async _endTrace(run) {
      var _a;
      const parentRun = run.parent_run_id !== void 0 && this.runMap.get(run.parent_run_id);
      if (parentRun) {
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
      } else {
        await this.persistRun(run);
      }
      this.runMap.delete(run.id);
      await ((_a = this.onRunUpdate) == null ? void 0 : _a.call(this, run));
    }
    _getExecutionOrder(parentRunId) {
      const parentRun = parentRunId !== void 0 && this.runMap.get(parentRunId);
      if (!parentRun) {
        return 1;
      }
      return parentRun.child_execution_order + 1;
    }
    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const finalExtraParams = metadata ? {
        ...extraParams,
        metadata
      } : extraParams;
      const run = {
        id: runId,
        name: name ?? llm.id[llm.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: llm,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: {
          prompts
        },
        execution_order,
        child_runs: [],
        child_execution_order: execution_order,
        run_type: "llm",
        extra: finalExtraParams ?? {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
      var _a, _b;
      const run = this.runMap.get(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
      await ((_a = this.onRunCreate) == null ? void 0 : _a.call(this, run));
      await ((_b = this.onLLMStart) == null ? void 0 : _b.call(this, run));
      return run;
    }
    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const finalExtraParams = metadata ? {
        ...extraParams,
        metadata
      } : extraParams;
      const run = {
        id: runId,
        name: name ?? llm.id[llm.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: llm,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: {
          messages
        },
        execution_order,
        child_runs: [],
        child_execution_order: execution_order,
        run_type: "llm",
        extra: finalExtraParams ?? {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
      var _a, _b;
      const run = this.runMap.get(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
      await ((_a = this.onRunCreate) == null ? void 0 : _a.call(this, run));
      await ((_b = this.onLLMStart) == null ? void 0 : _b.call(this, run));
      return run;
    }
    async handleLLMEnd(output, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
        throw new Error("No LLM run to end.");
      }
      run.end_time = Date.now();
      run.outputs = output;
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a = this.onLLMEnd) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleLLMError(error, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
        throw new Error("No LLM run to end.");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a = this.onLLMError) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const run = {
        id: runId,
        name: name ?? chain.id[chain.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: chain,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs,
        execution_order,
        child_execution_order: execution_order,
        run_type: runType ?? "chain",
        child_runs: [],
        extra: metadata ? {
          metadata
        } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
      var _a, _b;
      const run = this.runMap.get(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
      await ((_a = this.onRunCreate) == null ? void 0 : _a.call(this, run));
      await ((_b = this.onChainStart) == null ? void 0 : _b.call(this, run));
      return run;
    }
    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run) {
        throw new Error("No chain run to end.");
      }
      run.end_time = Date.now();
      run.outputs = _coerceToDict$1(outputs, "output");
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
        run.inputs = _coerceToDict$1(kwargs.inputs, "input");
      }
      await ((_a = this.onChainEnd) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run) {
        throw new Error("No chain run to end.");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
        run.inputs = _coerceToDict$1(kwargs.inputs, "input");
      }
      await ((_a = this.onChainError) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const run = {
        id: runId,
        name: name ?? tool.id[tool.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: tool,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: {
          input
        },
        execution_order,
        child_execution_order: execution_order,
        run_type: "tool",
        child_runs: [],
        extra: metadata ? {
          metadata
        } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
      var _a, _b;
      const run = this.runMap.get(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
      await ((_a = this.onRunCreate) == null ? void 0 : _a.call(this, run));
      await ((_b = this.onToolStart) == null ? void 0 : _b.call(this, run));
      return run;
    }
    async handleToolEnd(output, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
        throw new Error("No tool run to end");
      }
      run.end_time = Date.now();
      run.outputs = {
        output
      };
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a = this.onToolEnd) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleToolError(error, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
        throw new Error("No tool run to end");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a = this.onToolError) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleAgentAction(action, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
        return;
      }
      const agentRun = run;
      agentRun.actions = agentRun.actions || [];
      agentRun.actions.push(action);
      agentRun.events.push({
        name: "agent_action",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: {
          action
        }
      });
      await ((_a = this.onAgentAction) == null ? void 0 : _a.call(this, run));
    }
    async handleAgentEnd(action, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
        return;
      }
      run.events.push({
        name: "agent_end",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: {
          action
        }
      });
      await ((_a = this.onAgentEnd) == null ? void 0 : _a.call(this, run));
    }
    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
      const execution_order = this._getExecutionOrder(parentRunId);
      const start_time = Date.now();
      const run = {
        id: runId,
        name: name ?? retriever.id[retriever.id.length - 1],
        parent_run_id: parentRunId,
        start_time,
        serialized: retriever,
        events: [
          {
            name: "start",
            time: new Date(start_time).toISOString()
          }
        ],
        inputs: {
          query
        },
        execution_order,
        child_execution_order: execution_order,
        run_type: "retriever",
        child_runs: [],
        extra: metadata ? {
          metadata
        } : {},
        tags: tags || []
      };
      return this._addRunToRunMap(run);
    }
    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
      var _a, _b;
      const run = this.runMap.get(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
      await ((_a = this.onRunCreate) == null ? void 0 : _a.call(this, run));
      await ((_b = this.onRetrieverStart) == null ? void 0 : _b.call(this, run));
      return run;
    }
    async handleRetrieverEnd(documents2, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
        throw new Error("No retriever run to end");
      }
      run.end_time = Date.now();
      run.outputs = {
        documents: documents2
      };
      run.events.push({
        name: "end",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a = this.onRetrieverEnd) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleRetrieverError(error, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
        throw new Error("No retriever run to end");
      }
      run.end_time = Date.now();
      run.error = this.stringifyError(error);
      run.events.push({
        name: "error",
        time: new Date(run.end_time).toISOString()
      });
      await ((_a = this.onRetrieverError) == null ? void 0 : _a.call(this, run));
      await this._endTrace(run);
      return run;
    }
    async handleText(text, runId) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
        return;
      }
      run.events.push({
        name: "text",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: {
          text
        }
      });
      await ((_a = this.onText) == null ? void 0 : _a.call(this, run));
    }
    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
      var _a;
      const run = this.runMap.get(runId);
      if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
        throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
      }
      run.events.push({
        name: "new_token",
        time: (/* @__PURE__ */ new Date()).toISOString(),
        kwargs: {
          token,
          idx,
          chunk: fields == null ? void 0 : fields.chunk
        }
      });
      await ((_a = this.onLLMNewToken) == null ? void 0 : _a.call(this, run, token, {
        chunk: fields == null ? void 0 : fields.chunk
      }));
      return run;
    }
  }
  var dist$1 = {};
  var eventemitter3 = {
    exports: {}
  };
  (function(module2) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [
        emitter._events[evt],
        listener
      ];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [
        handlers.fn
      ];
      for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
        ee2[i2] = handlers[i2].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len2 = arguments.length, args, i2;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len2) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a2), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length = listeners2.length, j;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners2[i2].once) this.removeListener(event, listeners2[i2].fn, void 0, true);
          switch (len2) {
            case 1:
              listeners2[i2].fn.call(listeners2[i2].context);
              break;
            case 2:
              listeners2[i2].fn.call(listeners2[i2].context, a1);
              break;
            case 3:
              listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
              break;
            case 4:
              listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
                args[j - 1] = arguments[j];
              }
              listeners2[i2].fn.apply(listeners2[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners2.length; i2 < length; i2++) {
          if (listeners2[i2].fn !== fn || once && !listeners2[i2].once || context && listeners2[i2].context !== context) {
            events.push(listeners2[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module2.exports = EventEmitter2;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var pTimeout$1 = {
    exports: {}
  };
  var pFinally$1 = (promise, onFinally) => {
    onFinally = onFinally || (() => {
    });
    return promise.then((val) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => val), (err) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => {
      throw err;
    }));
  };
  const pFinally = pFinally$1;
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  const pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || milliseconds < 0) {
      throw new TypeError("Expected `milliseconds` to be a positive number");
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    const timer = setTimeout(() => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    pFinally(promise.then(resolve, reject), () => {
      clearTimeout(timer);
    });
  });
  pTimeout$1.exports = pTimeout;
  pTimeout$1.exports.default = pTimeout;
  pTimeout$1.exports.TimeoutError = TimeoutError;
  var pTimeoutExports = pTimeout$1.exports;
  var priorityQueue = {};
  var lowerBound$1 = {};
  Object.defineProperty(lowerBound$1, "__esModule", {
    value: true
  });
  function lowerBound(array, value, comparator2) {
    let first = 0;
    let count2 = array.length;
    while (count2 > 0) {
      const step = count2 / 2 | 0;
      let it = first + step;
      if (comparator2(array[it], value) <= 0) {
        first = ++it;
        count2 -= step + 1;
      } else {
        count2 = step;
      }
    }
    return first;
  }
  lowerBound$1.default = lowerBound;
  Object.defineProperty(priorityQueue, "__esModule", {
    value: true
  });
  const lower_bound_1 = lowerBound$1;
  class PriorityQueue {
    constructor() {
      this._queue = [];
    }
    enqueue(run, options) {
      options = Object.assign({
        priority: 0
      }, options);
      const element = {
        priority: options.priority,
        run
      };
      if (this.size && this._queue[this.size - 1].priority >= options.priority) {
        this._queue.push(element);
        return;
      }
      const index2 = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
      this._queue.splice(index2, 0, element);
    }
    dequeue() {
      const item = this._queue.shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
    filter(options) {
      return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return this._queue.length;
    }
  }
  priorityQueue.default = PriorityQueue;
  Object.defineProperty(dist$1, "__esModule", {
    value: true
  });
  const EventEmitter = eventemitter3Exports;
  const p_timeout_1 = pTimeoutExports;
  const priority_queue_1 = priorityQueue;
  const empty = () => {
  };
  const timeoutError = new p_timeout_1.TimeoutError();
  class PQueue extends EventEmitter {
    constructor(options) {
      var _a, _b, _c, _d;
      super();
      this._intervalCount = 0;
      this._intervalEnd = 0;
      this._pendingCount = 0;
      this._resolveEmpty = empty;
      this._resolveIdle = empty;
      options = Object.assign({
        carryoverConcurrencyCount: false,
        intervalCap: Infinity,
        interval: 0,
        concurrency: Infinity,
        autoStart: true,
        queueClass: priority_queue_1.default
      }, options);
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
      }
      this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
      this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
      this._intervalCap = options.intervalCap;
      this._interval = options.interval;
      this._queue = new options.queueClass();
      this._queueClass = options.queueClass;
      this.concurrency = options.concurrency;
      this._timeout = options.timeout;
      this._throwOnTimeout = options.throwOnTimeout === true;
      this._isPaused = options.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty;
        this.emit("idle");
      }
    }
    _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const now2 = Date.now();
      if (this._intervalId === void 0) {
        const delay2 = this._intervalEnd - now2;
        if (delay2 < 0) {
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          if (this._timeoutId === void 0) {
            this._timeoutId = setTimeout(() => {
              this._onResumeInterval();
            }, delay2);
          }
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = void 0;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        const canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== void 0) {
        return;
      }
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = void 0;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    _processQueue() {
      while (this._tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    async add(fn, options = {}) {
      return new Promise((resolve, reject) => {
        const run = async () => {
          this._pendingCount++;
          this._intervalCount++;
          try {
            const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
              if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                reject(timeoutError);
              }
              return void 0;
            });
            resolve(await operation);
          } catch (error) {
            reject(error);
          }
          this._next();
        };
        this._queue.enqueue(run, options);
        this._tryToStartAnother();
        this.emit("add");
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    pause() {
      this._isPaused = true;
    }
    clear() {
      this._queue = new this._queueClass();
    }
    async onEmpty() {
      if (this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveEmpty;
        this._resolveEmpty = () => {
          existingResolve();
          resolve();
        };
      });
    }
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveIdle;
        this._resolveIdle = () => {
          existingResolve();
          resolve();
        };
      });
    }
    get size() {
      return this._queue.size;
    }
    sizeBy(options) {
      return this._queue.filter(options).length;
    }
    get pending() {
      return this._pendingCount;
    }
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    set timeout(milliseconds) {
      this._timeout = milliseconds;
    }
  }
  var _default = dist$1.default = PQueue;
  const DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
  const LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
  const _getFetchImplementation = () => {
    return globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION;
  };
  const STATUS_NO_RETRY$1 = [
    400,
    401,
    403,
    404,
    405,
    406,
    407,
    408
  ];
  const STATUS_IGNORE = [
    409
  ];
  let AsyncCaller$1 = class AsyncCaller {
    constructor(params) {
      Object.defineProperty(this, "maxConcurrency", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "maxRetries", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "queue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "onFailedResponseHook", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.maxConcurrency = params.maxConcurrency ?? Infinity;
      this.maxRetries = params.maxRetries ?? 6;
      if ("default" in _default) {
        this.queue = new _default.default({
          concurrency: this.maxConcurrency
        });
      } else {
        this.queue = new _default({
          concurrency: this.maxConcurrency
        });
      }
      this.onFailedResponseHook = params == null ? void 0 : params.onFailedResponseHook;
    }
    call(callable, ...args) {
      const onFailedResponseHook = this.onFailedResponseHook;
      return this.queue.add(() => pRetry$1(() => callable(...args).catch((error) => {
        if (error instanceof Error) {
          throw error;
        } else {
          throw new Error(error);
        }
      }), {
        async onFailedAttempt(error) {
          if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError")) {
            throw error;
          }
          if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
            throw error;
          }
          const response = error == null ? void 0 : error.response;
          const status2 = response == null ? void 0 : response.status;
          if (status2) {
            if (STATUS_NO_RETRY$1.includes(+status2)) {
              throw error;
            } else if (STATUS_IGNORE.includes(+status2)) {
              return;
            }
            if (onFailedResponseHook) {
              await onFailedResponseHook(response);
            }
          }
        },
        retries: this.maxRetries,
        randomize: true
      }), {
        throwOnTimeout: true
      });
    }
    callWithOptions(options, callable, ...args) {
      if (options.signal) {
        return Promise.race([
          this.call(callable, ...args),
          new Promise((_, reject) => {
            var _a;
            (_a = options.signal) == null ? void 0 : _a.addEventListener("abort", () => {
              reject(new Error("AbortError"));
            });
          })
        ]);
      }
      return this.call(callable, ...args);
    }
    fetch(...args) {
      return this.call(() => _getFetchImplementation()(...args).then((res) => res.ok ? res : Promise.reject(res)));
    }
  };
  function isLangChainMessage(message) {
    return typeof (message == null ? void 0 : message._getType) === "function";
  }
  function convertLangChainMessageToExample(message) {
    const converted = {
      type: message._getType(),
      data: {
        content: message.content
      }
    };
    if ((message == null ? void 0 : message.additional_kwargs) && Object.keys(message.additional_kwargs).length > 0) {
      converted.data.additional_kwargs = {
        ...message.additional_kwargs
      };
    }
    return converted;
  }
  var define_process_env_default$1 = {};
  let globalEnv;
  const isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
  const isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
  const isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
  const isDeno = () => typeof Deno !== "undefined";
  const isNode = () => typeof process$1 !== "undefined" && typeof process$1.versions !== "undefined" && typeof process$1.versions.node !== "undefined" && !isDeno();
  const getEnv = () => {
    if (globalEnv) {
      return globalEnv;
    }
    if (isBrowser()) {
      globalEnv = "browser";
    } else if (isNode()) {
      globalEnv = "node";
    } else if (isWebWorker()) {
      globalEnv = "webworker";
    } else if (isJsDom()) {
      globalEnv = "jsdom";
    } else if (isDeno()) {
      globalEnv = "deno";
    } else {
      globalEnv = "other";
    }
    return globalEnv;
  };
  let runtimeEnvironment;
  async function getRuntimeEnvironment() {
    if (runtimeEnvironment === void 0) {
      const env = getEnv();
      const releaseEnv = getShas();
      runtimeEnvironment = {
        library: "langsmith",
        runtime: env,
        sdk: "langsmith-js",
        sdk_version: __version__,
        ...releaseEnv
      };
    }
    return runtimeEnvironment;
  }
  function getLangChainEnvVarsMetadata() {
    const allEnvVars = getEnvironmentVariables() || {};
    const envVars = {};
    const excluded = [
      "LANGCHAIN_API_KEY",
      "LANGCHAIN_ENDPOINT",
      "LANGCHAIN_TRACING_V2",
      "LANGCHAIN_PROJECT",
      "LANGCHAIN_SESSION"
    ];
    for (const [key, value] of Object.entries(allEnvVars)) {
      if (key.startsWith("LANGCHAIN_") && typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
        if (key === "LANGCHAIN_REVISION_ID") {
          envVars["revision_id"] = value;
        } else {
          envVars[key] = value;
        }
      }
    }
    return envVars;
  }
  function getEnvironmentVariables() {
    try {
      if (typeof process$1 !== "undefined" && define_process_env_default$1) {
        return Object.entries(define_process_env_default$1).reduce((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {});
      }
      return void 0;
    } catch (e) {
      return void 0;
    }
  }
  function getEnvironmentVariable(name) {
    try {
      return typeof process$1 !== "undefined" ? define_process_env_default$1 == null ? void 0 : define_process_env_default$1[name] : void 0;
    } catch (e) {
      return void 0;
    }
  }
  function getLangSmithEnvironmentVariable(name) {
    return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);
  }
  let cachedCommitSHAs;
  function getShas() {
    if (cachedCommitSHAs !== void 0) {
      return cachedCommitSHAs;
    }
    const common_release_envs = [
      "VERCEL_GIT_COMMIT_SHA",
      "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
      "COMMIT_REF",
      "RENDER_GIT_COMMIT",
      "CI_COMMIT_SHA",
      "CIRCLE_SHA1",
      "CF_PAGES_COMMIT_SHA",
      "REACT_APP_GIT_SHA",
      "SOURCE_VERSION",
      "GITHUB_SHA",
      "TRAVIS_COMMIT",
      "GIT_COMMIT",
      "BUILD_VCS_NUMBER",
      "bamboo_planRepository_revision",
      "Build.SourceVersion",
      "BITBUCKET_COMMIT",
      "DRONE_COMMIT_SHA",
      "SEMAPHORE_GIT_SHA",
      "BUILDKITE_COMMIT"
    ];
    const shas = {};
    for (const env of common_release_envs) {
      const envVar = getEnvironmentVariable(env);
      if (envVar !== void 0) {
        shas[env] = envVar;
      }
    }
    cachedCommitSHAs = shas;
    return shas;
  }
  function assertUuid(str, which) {
    if (!validate$1(str)) {
      const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;
      throw new Error(msg);
    }
    return str;
  }
  const warnedMessages = {};
  function warnOnce(message) {
    if (!warnedMessages[message]) {
      console.warn(message);
      warnedMessages[message] = true;
    }
  }
  var re$2 = {
    exports: {}
  };
  const SEMVER_SPEC_VERSION = "2.0.0";
  const MAX_LENGTH$1 = 256;
  const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  const MAX_SAFE_COMPONENT_LENGTH = 16;
  const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
  const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  var constants$2 = {
    MAX_LENGTH: MAX_LENGTH$1,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
  var define_process_env_default = {};
  const debug$1 = typeof process$1 === "object" && define_process_env_default && define_process_env_default.NODE_DEBUG && /\bsemver\b/i.test(define_process_env_default.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  var debug_1 = debug$1;
  (function(module2, exports) {
    const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2, MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2, MAX_LENGTH: MAX_LENGTH2 } = constants$2;
    const debug2 = debug_1;
    exports = module2.exports = {};
    const re2 = exports.re = [];
    const safeRe = exports.safeRe = [];
    const src = exports.src = [];
    const t2 = exports.t = {};
    let R2 = 0;
    const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    const safeRegexReplacements = [
      [
        "\\s",
        1
      ],
      [
        "\\d",
        MAX_LENGTH2
      ],
      [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH2
      ]
    ];
    const makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    const createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index2 = R2++;
      debug2(name, index2, value);
      t2[name] = index2;
      src[index2] = value;
      re2[index2] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index2] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
    createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
    createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
    createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?(?:${src[t2.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t2.COERCE], true);
    createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  })(re$2, re$2.exports);
  var reExports = re$2.exports;
  const looseOption = Object.freeze({
    loose: true
  });
  const emptyOpts = Object.freeze({});
  const parseOptions$1 = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  var parseOptions_1 = parseOptions$1;
  const numeric = /^[0-9]+$/;
  const compareIdentifiers$1 = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
  var identifiers$1 = {
    compareIdentifiers: compareIdentifiers$1,
    rcompareIdentifiers
  };
  const debug = debug_1;
  const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$2;
  const { safeRe: re$1, t: t$1 } = reExports;
  const parseOptions = parseOptions_1;
  const { compareIdentifiers } = identifiers$1;
  let SemVer$d = class SemVer2 {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer2) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m2 = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id2) => {
          if (/^[0-9]+$/.test(id2)) {
            const num = +id2;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id2;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer2)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer2(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i2 = 0;
      do {
        const a = this.prerelease[i2];
        const b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer2)) {
        other = new SemVer2(other, this.options);
      }
      let i2 = 0;
      do {
        const a = this.build[i2];
        const b = other.build[i2];
        debug("build compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [
              base
            ];
          } else {
            let i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease2 = [
              identifier,
              base
            ];
            if (identifierBase === false) {
              prerelease2 = [
                identifier
              ];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease2;
              }
            } else {
              this.prerelease = prerelease2;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  };
  var semver$1 = SemVer$d;
  const SemVer$c = semver$1;
  const parse$6 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer$c) {
      return version;
    }
    try {
      return new SemVer$c(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  var parse_1 = parse$6;
  const parse$5 = parse_1;
  const valid$2 = (version, options) => {
    const v2 = parse$5(version, options);
    return v2 ? v2.version : null;
  };
  var valid_1 = valid$2;
  const parse$4 = parse_1;
  const clean$1 = (version, options) => {
    const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  };
  var clean_1 = clean$1;
  const SemVer$b = semver$1;
  const inc$1 = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = void 0;
    }
    try {
      return new SemVer$b(version instanceof SemVer$b ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  var inc_1 = inc$1;
  const parse$3 = parse_1;
  const diff$1 = (version1, version2) => {
    const v1 = parse$3(version1, null, true);
    const v2 = parse$3(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  var diff_1 = diff$1;
  const SemVer$a = semver$1;
  const major$1 = (a, loose) => new SemVer$a(a, loose).major;
  var major_1 = major$1;
  const SemVer$9 = semver$1;
  const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
  var minor_1 = minor$1;
  const SemVer$8 = semver$1;
  const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
  var patch_1 = patch$1;
  const parse$2 = parse_1;
  const prerelease$1 = (version, options) => {
    const parsed = parse$2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  var prerelease_1 = prerelease$1;
  const SemVer$7 = semver$1;
  const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
  var compare_1 = compare$b;
  const compare$a = compare_1;
  const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
  var rcompare_1 = rcompare$1;
  const compare$9 = compare_1;
  const compareLoose$1 = (a, b) => compare$9(a, b, true);
  var compareLoose_1 = compareLoose$1;
  const SemVer$6 = semver$1;
  const compareBuild$3 = (a, b, loose) => {
    const versionA = new SemVer$6(a, loose);
    const versionB = new SemVer$6(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  var compareBuild_1 = compareBuild$3;
  const compareBuild$2 = compareBuild_1;
  const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
  var sort_1 = sort$1;
  const compareBuild$1 = compareBuild_1;
  const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
  var rsort_1 = rsort$1;
  const compare$8 = compare_1;
  const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
  var gt_1 = gt$4;
  const compare$7 = compare_1;
  const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
  var lt_1 = lt$3;
  const compare$6 = compare_1;
  const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
  var eq_1 = eq$2;
  const compare$5 = compare_1;
  const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
  var neq_1 = neq$2;
  const compare$4 = compare_1;
  const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
  var gte_1 = gte$3;
  const compare$3 = compare_1;
  const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
  var lte_1 = lte$3;
  const eq$1 = eq_1;
  const neq$1 = neq_1;
  const gt$3 = gt_1;
  const gte$2 = gte_1;
  const lt$2 = lt_1;
  const lte$2 = lte_1;
  const cmp$1 = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq$1(a, b, loose);
      case "!=":
        return neq$1(a, b, loose);
      case ">":
        return gt$3(a, b, loose);
      case ">=":
        return gte$2(a, b, loose);
      case "<":
        return lt$2(a, b, loose);
      case "<=":
        return lte$2(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  var cmp_1 = cmp$1;
  const SemVer$5 = semver$1;
  const parse$1 = parse_1;
  const { safeRe: re, t } = reExports;
  const coerce$1 = (version, options) => {
    if (version instanceof SemVer$5) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major2 = match[2];
    const minor2 = match[3] || "0";
    const patch2 = match[4] || "0";
    const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
  };
  var coerce_1 = coerce$1;
  class LRUCache {
    constructor() {
      this.max = 1e3;
      this.map = /* @__PURE__ */ new Map();
    }
    get(key) {
      const value = this.map.get(key);
      if (value === void 0) {
        return void 0;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== void 0) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  var lrucache = LRUCache;
  var range;
  var hasRequiredRange;
  function requireRange() {
    if (hasRequiredRange) return range;
    hasRequiredRange = 1;
    const SPACE_CHARACTERS = /\s+/g;
    class Range2 {
      constructor(range2, options) {
        options = parseOptions2(options);
        if (range2 instanceof Range2) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new Range2(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator2) {
          this.raw = range2.value;
          this.set = [
            [
              range2
            ]
          ];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [
              first
            ];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny2(c[0])) {
                this.set = [
                  c
                ];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i2 = 0; i2 < this.set.length; i2++) {
            if (i2 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i2];
            for (let k2 = 0; k2 < comps.length; k2++) {
              if (k2 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k2].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range2);
        range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range2);
        range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
        debug2("tilde trim", range2);
        range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
        debug2("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug2("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t2.COMPARATORLOOSE]);
          });
        }
        debug2("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [
              comp
            ];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [
          ...rangeMap.values()
        ];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof Range2)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer2(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i2 = 0; i2 < this.set.length; i2++) {
          if (testSet(this.set[i2], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    }
    range = Range2;
    const LRU = lrucache;
    const cache2 = new LRU();
    const parseOptions2 = parseOptions_1;
    const Comparator2 = requireComparator();
    const debug2 = debug_1;
    const SemVer2 = semver$1;
    const { safeRe: re2, t: t2, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = reExports;
    const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$2;
    const isNullSet = (c) => c.value === "<0.0.0-0";
    const isAny2 = (c) => c.value === "";
    const isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    const parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    const replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    const replaceTilde = (comp, options) => {
      const r2 = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
      return comp.replace(r2, (_, M2, m2, p2, pr) => {
        debug2("tilde", comp, _, M2, m2, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M2}.0.0 <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M2}.${m2}.0 <${M2}.${+m2 + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M2}.${m2}.${p2} <${M2}.${+m2 + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    const replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    const replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r2 = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r2, (_, M2, m2, p2, pr) => {
        debug2("caret", comp, _, M2, m2, p2, pr);
        let ret;
        if (isX(M2)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M2}.0.0${z2} <${+M2 + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M2 === "0") {
            ret = `>=${M2}.${m2}.0${z2} <${M2}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M2}.${m2}.0${z2} <${+M2 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M2 === "0") {
            if (m2 === "0") {
              ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m2}.${p2}-${pr} <${M2}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m2}.${p2}-${pr} <${+M2 + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M2 === "0") {
            if (m2 === "0") {
              ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M2}.${m2}.${p2}${z2} <${M2}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M2}.${m2}.${p2} <${+M2 + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    const replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    const replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r2 = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
      return comp.replace(r2, (ret, gtlt, M2, m2, p2, pr) => {
        debug2("xRange", comp, ret, gtlt, M2, m2, p2, pr);
        const xM = isX(M2);
        const xm = xM || isX(m2);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M2 = +M2 + 1;
              m2 = 0;
              p2 = 0;
            } else {
              m2 = +m2 + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M2 = +M2 + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M2}.${m2}.${p2}${pr}`;
        } else if (xm) {
          ret = `>=${M2}.0.0${pr} <${+M2 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M2}.${m2}.0${pr} <${M2}.${+m2 + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    const replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re2[t2.STAR], "");
    };
    const replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
    };
    const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb2, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    const testSet = (set, version, options) => {
      for (let i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i2 = 0; i2 < set.length; i2++) {
          debug2(set[i2].semver);
          if (set[i2].semver === Comparator2.ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            const allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
    return range;
  }
  var comparator;
  var hasRequiredComparator;
  function requireComparator() {
    if (hasRequiredComparator) return comparator;
    hasRequiredComparator = 1;
    const ANY2 = Symbol("SemVer ANY");
    class Comparator2 {
      static get ANY() {
        return ANY2;
      }
      constructor(comp, options) {
        options = parseOptions2(options);
        if (comp instanceof Comparator2) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY2) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r2 = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
        const m2 = comp.match(r2);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY2;
        } else {
          this.semver = new SemVer2(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug2("Comparator.test", version, this.options.loose);
        if (this.semver === ANY2 || version === ANY2) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer2(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp2(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator2)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range2(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range2(this.value, options).test(comp.semver);
        }
        options = parseOptions2(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    }
    comparator = Comparator2;
    const parseOptions2 = parseOptions_1;
    const { safeRe: re2, t: t2 } = reExports;
    const cmp2 = cmp_1;
    const debug2 = debug_1;
    const SemVer2 = semver$1;
    const Range2 = requireRange();
    return comparator;
  }
  const Range$9 = requireRange();
  const satisfies$4 = (version, range2, options) => {
    try {
      range2 = new Range$9(range2, options);
    } catch (er) {
      return false;
    }
    return range2.test(version);
  };
  var satisfies_1 = satisfies$4;
  const Range$8 = requireRange();
  const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  var toComparators_1 = toComparators$1;
  const SemVer$4 = semver$1;
  const Range$7 = requireRange();
  const maxSatisfying$1 = (versions, range2, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range$7(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!max || maxSV.compare(v2) === -1) {
          max = v2;
          maxSV = new SemVer$4(max, options);
        }
      }
    });
    return max;
  };
  var maxSatisfying_1 = maxSatisfying$1;
  const SemVer$3 = semver$1;
  const Range$6 = requireRange();
  const minSatisfying$1 = (versions, range2, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range$6(range2, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!min || minSV.compare(v2) === 1) {
          min = v2;
          minSV = new SemVer$3(min, options);
        }
      }
    });
    return min;
  };
  var minSatisfying_1 = minSatisfying$1;
  const SemVer$2 = semver$1;
  const Range$5 = requireRange();
  const gt$2 = gt_1;
  const minVersion$1 = (range2, loose) => {
    range2 = new Range$5(range2, loose);
    let minver = new SemVer$2("0.0.0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = new SemVer$2("0.0.0-0");
    if (range2.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i2 = 0; i2 < range2.set.length; ++i2) {
      const comparators = range2.set[i2];
      let setMin = null;
      comparators.forEach((comparator2) => {
        const compver = new SemVer$2(comparator2.semver.version);
        switch (comparator2.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt$2(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator2.operator}`);
        }
      });
      if (setMin && (!minver || gt$2(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range2.test(minver)) {
      return minver;
    }
    return null;
  };
  var minVersion_1 = minVersion$1;
  const Range$4 = requireRange();
  const validRange$1 = (range2, options) => {
    try {
      return new Range$4(range2, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  var valid$1 = validRange$1;
  const SemVer$1 = semver$1;
  const Comparator$2 = requireComparator();
  const { ANY: ANY$1 } = Comparator$2;
  const Range$3 = requireRange();
  const satisfies$3 = satisfies_1;
  const gt$1 = gt_1;
  const lt$1 = lt_1;
  const lte$1 = lte_1;
  const gte$1 = gte_1;
  const outside$3 = (version, range2, hilo, options) => {
    version = new SemVer$1(version, options);
    range2 = new Range$3(range2, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt$1;
        ltefn = lte$1;
        ltfn = lt$1;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt$1;
        ltefn = gte$1;
        ltfn = gt$1;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies$3(version, range2, options)) {
      return false;
    }
    for (let i2 = 0; i2 < range2.set.length; ++i2) {
      const comparators = range2.set[i2];
      let high = null;
      let low = null;
      comparators.forEach((comparator2) => {
        if (comparator2.semver === ANY$1) {
          comparator2 = new Comparator$2(">=0.0.0");
        }
        high = high || comparator2;
        low = low || comparator2;
        if (gtfn(comparator2.semver, high.semver, options)) {
          high = comparator2;
        } else if (ltfn(comparator2.semver, low.semver, options)) {
          low = comparator2;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  var outside_1 = outside$3;
  const outside$2 = outside_1;
  const gtr$1 = (version, range2, options) => outside$2(version, range2, ">", options);
  var gtr_1 = gtr$1;
  const outside$1 = outside_1;
  const ltr$1 = (version, range2, options) => outside$1(version, range2, "<", options);
  var ltr_1 = ltr$1;
  const Range$2 = requireRange();
  const intersects$1 = (r1, r2, options) => {
    r1 = new Range$2(r1, options);
    r2 = new Range$2(r2, options);
    return r1.intersects(r2, options);
  };
  var intersects_1 = intersects$1;
  const satisfies$2 = satisfies_1;
  const compare$2 = compare_1;
  var simplify = (versions, range2, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v2 = versions.sort((a, b) => compare$2(a, b, options));
    for (const version of v2) {
      const included = satisfies$2(version, range2, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([
            first,
            prev
          ]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([
        first,
        null
      ]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v2[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v2[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range2.raw === "string" ? range2.raw : String(range2);
    return simplified.length < original.length ? simplified : range2;
  };
  const Range$1 = requireRange();
  const Comparator$1 = requireComparator();
  const { ANY } = Comparator$1;
  const satisfies$1 = satisfies_1;
  const compare$1 = compare_1;
  const subset$1 = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range$1(sub, options);
    dom = new Range$1(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) {
          continue OUTER;
        }
      }
      if (sawNonNull) {
        return false;
      }
    }
    return true;
  };
  const minimumVersionWithPreRelease = [
    new Comparator$1(">=0.0.0-0")
  ];
  const minimumVersion = [
    new Comparator$1(">=0.0.0")
  ];
  const simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = /* @__PURE__ */ new Set();
    let gt2, lt2;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt2 = higherGT(gt2, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt2 = lowerLT(lt2, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt2 && lt2) {
      gtltComp = compare$1(gt2.semver, lt2.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
        return null;
      }
    }
    for (const eq2 of eqSet) {
      if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
        return null;
      }
      if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies$1(eq2, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
    let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt2) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt2, c, options);
          if (higher === c && higher !== gt2) {
            return false;
          }
        } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
          return false;
        }
      }
      if (lt2) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower = lowerLT(lt2, c, options);
          if (lower === c && lower !== lt2) {
            return false;
          }
        } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
      return false;
    }
    if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  const higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare$1(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  const lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare$1(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  var subset_1 = subset$1;
  const internalRe = reExports;
  const constants$1 = constants$2;
  const SemVer = semver$1;
  const identifiers = identifiers$1;
  const parse = parse_1;
  const valid = valid_1;
  const clean = clean_1;
  const inc = inc_1;
  const diff = diff_1;
  const major = major_1;
  const minor = minor_1;
  const patch = patch_1;
  const prerelease = prerelease_1;
  const compare = compare_1;
  const rcompare = rcompare_1;
  const compareLoose = compareLoose_1;
  const compareBuild = compareBuild_1;
  const sort = sort_1;
  const rsort = rsort_1;
  const gt = gt_1;
  const lt = lt_1;
  const eq = eq_1;
  const neq = neq_1;
  const gte = gte_1;
  const lte = lte_1;
  const cmp = cmp_1;
  const coerce = coerce_1;
  const Comparator = requireComparator();
  const Range = requireRange();
  const satisfies = satisfies_1;
  const toComparators = toComparators_1;
  const maxSatisfying = maxSatisfying_1;
  const minSatisfying = minSatisfying_1;
  const minVersion = minVersion_1;
  const validRange = valid$1;
  const outside = outside_1;
  const gtr = gtr_1;
  const ltr = ltr_1;
  const intersects = intersects_1;
  const simplifyRange = simplify;
  const subset = subset_1;
  var semver = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants$1.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
  function isVersionGreaterOrEqual(current_version, target_version) {
    const current = semver.parse(current_version);
    const target = semver.parse(target_version);
    if (!current || !target) {
      throw new Error("Invalid version format.");
    }
    return current.compare(target) >= 0;
  }
  function parsePromptIdentifier(identifier) {
    if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    const [ownerNamePart, commitPart] = identifier.split(":");
    const commit = commitPart || "latest";
    if (ownerNamePart.includes("/")) {
      const [owner, name] = ownerNamePart.split("/", 2);
      if (!owner || !name) {
        throw new Error(`Invalid identifier format: ${identifier}`);
      }
      return [
        owner,
        name,
        commit
      ];
    } else {
      if (!ownerNamePart) {
        throw new Error(`Invalid identifier format: ${identifier}`);
      }
      return [
        "-",
        ownerNamePart,
        commit
      ];
    }
  }
  class LangSmithConflictError extends Error {
    constructor(message) {
      super(message);
      this.name = "LangSmithConflictError";
    }
  }
  async function raiseForStatus(response, context, consume) {
    let errorBody;
    if (response.ok) {
      if (consume) {
        errorBody = await response.text();
      }
      return;
    }
    errorBody = await response.text();
    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;
    if (response.status === 409) {
      throw new LangSmithConflictError(fullMessage);
    }
    throw new Error(fullMessage);
  }
  var LIMIT_REPLACE_NODE = "[...]";
  var CIRCULAR_REPLACE_NODE = {
    result: "[Circular]"
  };
  var arr = [];
  var replacerStack = [];
  function defaultOptions$1() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function stringify(obj, replacer, spacer, options) {
    if (typeof options === "undefined") {
      options = defaultOptions$1();
    }
    decirc(obj, "", 0, [], void 0, 0, options);
    var res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        var part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return res;
  }
  function setReplace(replace, val, k2, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k2);
    if (propertyDescriptor.get !== void 0) {
      if (propertyDescriptor.configurable) {
        Object.defineProperty(parent, k2, {
          value: replace
        });
        arr.push([
          parent,
          k2,
          val,
          propertyDescriptor
        ]);
      } else {
        replacerStack.push([
          val,
          k2,
          replace
        ]);
      }
    } else {
      parent[k2] = replace;
      arr.push([
        parent,
        k2,
        val
      ]);
    }
  }
  function decirc(val, k2, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i2;
    if (typeof val === "object" && val !== null) {
      for (i2 = 0; i2 < stack.length; i2++) {
        if (stack[i2] === val) {
          setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
          return;
        }
      }
      if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
        return;
      }
      if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
        setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
        return;
      }
      stack.push(val);
      if (Array.isArray(val)) {
        for (i2 = 0; i2 < val.length; i2++) {
          decirc(val[i2], i2, i2, stack, val, depth, options);
        }
      } else {
        var keys = Object.keys(val);
        for (i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          decirc(val[key], key, i2, stack, val, depth, options);
        }
      }
      stack.pop();
    }
  }
  function replaceGetterValues(replacer) {
    replacer = typeof replacer !== "undefined" ? replacer : function(k2, v2) {
      return v2;
    };
    return function(key, val) {
      if (replacerStack.length > 0) {
        for (var i2 = 0; i2 < replacerStack.length; i2++) {
          var part = replacerStack[i2];
          if (part[1] === key && part[0] === val) {
            val = part[2];
            replacerStack.splice(i2, 1);
            break;
          }
        }
      }
      return replacer.call(this, key, val);
    };
  }
  async function mergeRuntimeEnvIntoRunCreates(runs) {
    const runtimeEnv = await getRuntimeEnvironment();
    const envVars = getLangChainEnvVarsMetadata();
    return runs.map((run) => {
      const extra = run.extra ?? {};
      const metadata = extra.metadata;
      run.extra = {
        ...extra,
        runtime: {
          ...runtimeEnv,
          ...extra == null ? void 0 : extra.runtime
        },
        metadata: {
          ...envVars,
          ...envVars.revision_id || run.revision_id ? {
            revision_id: run.revision_id ?? envVars.revision_id
          } : {},
          ...metadata
        }
      };
      return run;
    });
  }
  const getTracingSamplingRate = () => {
    const samplingRateStr = getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
    if (samplingRateStr === void 0) {
      return void 0;
    }
    const samplingRate = parseFloat(samplingRateStr);
    if (samplingRate < 0 || samplingRate > 1) {
      throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
    }
    return samplingRate;
  };
  const isLocalhost = (url) => {
    const strippedUrl = url.replace("http://", "").replace("https://", "");
    const hostname = strippedUrl.split("/")[0].split(":")[0];
    return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
  };
  async function toArray(iterable) {
    const result = [];
    for await (const item of iterable) {
      result.push(item);
    }
    return result;
  }
  function trimQuotes(str) {
    if (str === void 0) {
      return void 0;
    }
    return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
  }
  const handle429 = async (response) => {
    if ((response == null ? void 0 : response.status) === 429) {
      const retryAfter = parseInt(response.headers.get("retry-after") ?? "30", 10) * 1e3;
      if (retryAfter > 0) {
        await new Promise((resolve) => setTimeout(resolve, retryAfter));
        return true;
      }
    }
    return false;
  };
  class Queue {
    constructor() {
      Object.defineProperty(this, "items", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
    }
    get size() {
      return this.items.length;
    }
    push(item) {
      return new Promise((resolve) => {
        this.items.push([
          item,
          resolve
        ]);
      });
    }
    pop(upToN) {
      if (upToN < 1) {
        throw new Error("Number of items to pop off may not be less than 1.");
      }
      const popped = [];
      while (popped.length < upToN && this.items.length) {
        const item = this.items.shift();
        if (item) {
          popped.push(item);
        } else {
          break;
        }
      }
      return [
        popped.map((it) => it[0]),
        () => popped.forEach((it) => it[1]())
      ];
    }
  }
  const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
  class Client {
    constructor(config = {}) {
      var _a;
      Object.defineProperty(this, "apiKey", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "apiUrl", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "webUrl", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "caller", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "batchIngestCaller", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "timeout_ms", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "_tenantId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: null
      });
      Object.defineProperty(this, "hideInputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "hideOutputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tracingSampleRate", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "filteredPostUuids", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Set()
      });
      Object.defineProperty(this, "autoBatchTracing", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "batchEndpointSupported", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "autoBatchQueue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Queue()
      });
      Object.defineProperty(this, "pendingAutoBatchedRunLimit", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 100
      });
      Object.defineProperty(this, "autoBatchTimeout", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "autoBatchInitialDelayMs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 250
      });
      Object.defineProperty(this, "autoBatchAggregationDelayMs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 50
      });
      Object.defineProperty(this, "serverInfo", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "fetchOptions", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "settings", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      const defaultConfig = Client.getDefaultClientConfig();
      this.tracingSampleRate = getTracingSamplingRate();
      this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? "";
      if (this.apiUrl.endsWith("/")) {
        this.apiUrl = this.apiUrl.slice(0, -1);
      }
      this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);
      this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);
      if ((_a = this.webUrl) == null ? void 0 : _a.endsWith("/")) {
        this.webUrl = this.webUrl.slice(0, -1);
      }
      this.timeout_ms = config.timeout_ms ?? 12e3;
      this.caller = new AsyncCaller$1(config.callerOptions ?? {});
      this.batchIngestCaller = new AsyncCaller$1({
        ...config.callerOptions ?? {},
        onFailedResponseHook: handle429
      });
      this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;
      this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;
      this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;
      this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;
      this.fetchOptions = config.fetchOptions || {};
    }
    static getDefaultClientConfig() {
      const apiKey = getLangSmithEnvironmentVariable("API_KEY");
      const apiUrl = getLangSmithEnvironmentVariable("ENDPOINT") ?? "https://api.smith.langchain.com";
      const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
      const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
      return {
        apiUrl,
        apiKey,
        webUrl: void 0,
        hideInputs,
        hideOutputs
      };
    }
    getHostUrl() {
      if (this.webUrl) {
        return this.webUrl;
      } else if (isLocalhost(this.apiUrl)) {
        this.webUrl = "http://localhost:3000";
        return this.webUrl;
      } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
        this.webUrl = this.apiUrl.replace("/api", "");
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
        this.webUrl = "https://dev.smith.langchain.com";
        return this.webUrl;
      } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
        this.webUrl = "https://eu.smith.langchain.com";
        return this.webUrl;
      } else {
        this.webUrl = "https://smith.langchain.com";
        return this.webUrl;
      }
    }
    get headers() {
      const headers = {
        "User-Agent": `langsmith-js/${__version__}`
      };
      if (this.apiKey) {
        headers["x-api-key"] = `${this.apiKey}`;
      }
      return headers;
    }
    processInputs(inputs) {
      if (this.hideInputs === false) {
        return inputs;
      }
      if (this.hideInputs === true) {
        return {};
      }
      if (typeof this.hideInputs === "function") {
        return this.hideInputs(inputs);
      }
      return inputs;
    }
    processOutputs(outputs) {
      if (this.hideOutputs === false) {
        return outputs;
      }
      if (this.hideOutputs === true) {
        return {};
      }
      if (typeof this.hideOutputs === "function") {
        return this.hideOutputs(outputs);
      }
      return outputs;
    }
    prepareRunCreateOrUpdateInputs(run) {
      const runParams = {
        ...run
      };
      if (runParams.inputs !== void 0) {
        runParams.inputs = this.processInputs(runParams.inputs);
      }
      if (runParams.outputs !== void 0) {
        runParams.outputs = this.processOutputs(runParams.outputs);
      }
      return runParams;
    }
    async _getResponse(path, queryParams) {
      const paramsString = (queryParams == null ? void 0 : queryParams.toString()) ?? "";
      const url = `${this.apiUrl}${path}?${paramsString}`;
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `Failed to fetch ${path}`);
      return response;
    }
    async _get(path, queryParams) {
      const response = await this._getResponse(path, queryParams);
      return response.json();
    }
    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {
      let offset = Number(queryParams.get("offset")) || 0;
      const limit = Number(queryParams.get("limit")) || 100;
      while (true) {
        queryParams.set("offset", String(offset));
        queryParams.set("limit", String(limit));
        const url = `${this.apiUrl}${path}?${queryParams}`;
        const response = await this.caller.call(_getFetchImplementation(), url, {
          method: "GET",
          headers: this.headers,
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions
        });
        await raiseForStatus(response, `Failed to fetch ${path}`);
        const items = transform ? transform(await response.json()) : await response.json();
        if (items.length === 0) {
          break;
        }
        yield items;
        if (items.length < limit) {
          break;
        }
        offset += items.length;
      }
    }
    async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
      const bodyParams = body ? {
        ...body
      } : {};
      while (true) {
        const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${path}`, {
          method: requestMethod,
          headers: {
            ...this.headers,
            "Content-Type": "application/json"
          },
          signal: AbortSignal.timeout(this.timeout_ms),
          ...this.fetchOptions,
          body: JSON.stringify(bodyParams)
        });
        const responseBody = await response.json();
        if (!responseBody) {
          break;
        }
        if (!responseBody[dataKey]) {
          break;
        }
        yield responseBody[dataKey];
        const cursors = responseBody.cursors;
        if (!cursors) {
          break;
        }
        if (!cursors.next) {
          break;
        }
        bodyParams.cursor = cursors.next;
      }
    }
    _filterForSampling(runs, patch2 = false) {
      if (this.tracingSampleRate === void 0) {
        return runs;
      }
      if (patch2) {
        const sampled = [];
        for (const run of runs) {
          if (!this.filteredPostUuids.has(run.id)) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.delete(run.id);
          }
        }
        return sampled;
      } else {
        const sampled = [];
        for (const run of runs) {
          if (run.id !== run.trace_id && !this.filteredPostUuids.has(run.trace_id) || Math.random() < this.tracingSampleRate) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.add(run.id);
          }
        }
        return sampled;
      }
    }
    async drainAutoBatchQueue() {
      while (this.autoBatchQueue.size >= 0) {
        const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);
        if (!batch.length) {
          done();
          return;
        }
        try {
          await this.batchIngestRuns({
            runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
            runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
          });
        } finally {
          done();
        }
      }
    }
    async processRunOperation(item, immediatelyTriggerBatch) {
      const oldTimeout = this.autoBatchTimeout;
      clearTimeout(this.autoBatchTimeout);
      this.autoBatchTimeout = void 0;
      const itemPromise = this.autoBatchQueue.push(item);
      if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {
        await this.drainAutoBatchQueue().catch(console.error);
      }
      if (this.autoBatchQueue.size > 0) {
        this.autoBatchTimeout = setTimeout(() => {
          this.autoBatchTimeout = void 0;
          void this.drainAutoBatchQueue().catch(console.error);
        }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);
      }
      return itemPromise;
    }
    async _getServerInfo() {
      const response = await _getFetchImplementation()(`${this.apiUrl}/info`, {
        method: "GET",
        headers: {
          Accept: "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "get server info");
      return response.json();
    }
    async batchEndpointIsSupported() {
      try {
        this.serverInfo = await this._getServerInfo();
      } catch (e) {
        return false;
      }
      return true;
    }
    async _getSettings() {
      if (!this.settings) {
        this.settings = this._get("/settings");
      }
      return await this.settings;
    }
    async createRun(run) {
      if (!this._filterForSampling([
        run
      ]).length) {
        return;
      }
      const headers = {
        ...this.headers,
        "Content-Type": "application/json"
      };
      const session_name = run.project_name;
      delete run.project_name;
      const runCreate = this.prepareRunCreateOrUpdateInputs({
        session_name,
        ...run,
        start_time: run.start_time ?? Date.now()
      });
      if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
        void this.processRunOperation({
          action: "create",
          item: runCreate
        }).catch(console.error);
        return;
      }
      const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([
        runCreate
      ]);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs`, {
        method: "POST",
        headers,
        body: stringify(mergedRunCreateParams[0]),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create run", true);
    }
    async batchIngestRuns({ runCreates, runUpdates }) {
      var _a, _b;
      if (runCreates === void 0 && runUpdates === void 0) {
        return;
      }
      let preparedCreateParams = (runCreates == null ? void 0 : runCreates.map((create2) => this.prepareRunCreateOrUpdateInputs(create2))) ?? [];
      let preparedUpdateParams = (runUpdates == null ? void 0 : runUpdates.map((update) => this.prepareRunCreateOrUpdateInputs(update))) ?? [];
      if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
        const createById = preparedCreateParams.reduce((params, run) => {
          if (!run.id) {
            return params;
          }
          params[run.id] = run;
          return params;
        }, {});
        const standaloneUpdates = [];
        for (const updateParam of preparedUpdateParams) {
          if (updateParam.id !== void 0 && createById[updateParam.id]) {
            createById[updateParam.id] = {
              ...createById[updateParam.id],
              ...updateParam
            };
          } else {
            standaloneUpdates.push(updateParam);
          }
        }
        preparedCreateParams = Object.values(createById);
        preparedUpdateParams = standaloneUpdates;
      }
      const rawBatch = {
        post: this._filterForSampling(preparedCreateParams),
        patch: this._filterForSampling(preparedUpdateParams, true)
      };
      if (!rawBatch.post.length && !rawBatch.patch.length) {
        return;
      }
      preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);
      if (this.batchEndpointSupported === void 0) {
        this.batchEndpointSupported = await this.batchEndpointIsSupported();
      }
      if (!this.batchEndpointSupported) {
        this.autoBatchTracing = false;
        for (const preparedCreateParam of rawBatch.post) {
          await this.createRun(preparedCreateParam);
        }
        for (const preparedUpdateParam of rawBatch.patch) {
          if (preparedUpdateParam.id !== void 0) {
            await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);
          }
        }
        return;
      }
      const sizeLimitBytes = ((_b = (_a = this.serverInfo) == null ? void 0 : _a.batch_ingest_config) == null ? void 0 : _b.size_limit_bytes) ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;
      const batchChunks = {
        post: [],
        patch: []
      };
      let currentBatchSizeBytes = 0;
      for (const k2 of [
        "post",
        "patch"
      ]) {
        const key = k2;
        const batchItems = rawBatch[key].reverse();
        let batchItem = batchItems.pop();
        while (batchItem !== void 0) {
          const stringifiedBatchItem = stringify(batchItem);
          if (currentBatchSizeBytes > 0 && currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {
            await this._postBatchIngestRuns(stringify(batchChunks));
            currentBatchSizeBytes = 0;
            batchChunks.post = [];
            batchChunks.patch = [];
          }
          currentBatchSizeBytes += stringifiedBatchItem.length;
          batchChunks[key].push(batchItem);
          batchItem = batchItems.pop();
        }
      }
      if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
        await this._postBatchIngestRuns(stringify(batchChunks));
      }
    }
    async _postBatchIngestRuns(body) {
      const headers = {
        ...this.headers,
        "Content-Type": "application/json",
        Accept: "application/json"
      };
      const response = await this.batchIngestCaller.call(_getFetchImplementation(), `${this.apiUrl}/runs/batch`, {
        method: "POST",
        headers,
        body,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "batch create run", true);
    }
    async updateRun(runId, run) {
      assertUuid(runId);
      if (run.inputs) {
        run.inputs = this.processInputs(run.inputs);
      }
      if (run.outputs) {
        run.outputs = this.processOutputs(run.outputs);
      }
      const data = {
        ...run,
        id: runId
      };
      if (!this._filterForSampling([
        data
      ], true).length) {
        return;
      }
      if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
        if (run.end_time !== void 0 && data.parent_run_id === void 0) {
          await this.processRunOperation({
            action: "update",
            item: data
          }, true);
          return;
        } else {
          void this.processRunOperation({
            action: "update",
            item: data
          }).catch(console.error);
        }
        return;
      }
      const headers = {
        ...this.headers,
        "Content-Type": "application/json"
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}`, {
        method: "PATCH",
        headers,
        body: stringify(run),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update run", true);
    }
    async readRun(runId, { loadChildRuns } = {
      loadChildRuns: false
    }) {
      assertUuid(runId);
      let run = await this._get(`/runs/${runId}`);
      if (loadChildRuns && run.child_run_ids) {
        run = await this._loadChildRuns(run);
      }
      return run;
    }
    async getRunUrl({ runId, run, projectOpts }) {
      if (run !== void 0) {
        let sessionId;
        if (run.session_id) {
          sessionId = run.session_id;
        } else if (projectOpts == null ? void 0 : projectOpts.projectName) {
          sessionId = (await this.readProject({
            projectName: projectOpts == null ? void 0 : projectOpts.projectName
          })).id;
        } else if (projectOpts == null ? void 0 : projectOpts.projectId) {
          sessionId = projectOpts == null ? void 0 : projectOpts.projectId;
        } else {
          const project = await this.readProject({
            projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
          });
          sessionId = project.id;
        }
        const tenantId = await this._getTenantId();
        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
      } else if (runId !== void 0) {
        const run_ = await this.readRun(runId);
        if (!run_.app_path) {
          throw new Error(`Run ${runId} has no app_path`);
        }
        const baseUrl = this.getHostUrl();
        return `${baseUrl}${run_.app_path}`;
      } else {
        throw new Error("Must provide either runId or run");
      }
    }
    async _loadChildRuns(run) {
      const childRuns = await toArray(this.listRuns({
        id: run.child_run_ids
      }));
      const treemap = {};
      const runs = {};
      childRuns.sort((a, b) => ((a == null ? void 0 : a.dotted_order) ?? "").localeCompare((b == null ? void 0 : b.dotted_order) ?? ""));
      for (const childRun of childRuns) {
        if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
          throw new Error(`Child run ${childRun.id} has no parent`);
        }
        if (!(childRun.parent_run_id in treemap)) {
          treemap[childRun.parent_run_id] = [];
        }
        treemap[childRun.parent_run_id].push(childRun);
        runs[childRun.id] = childRun;
      }
      run.child_runs = treemap[run.id] || [];
      for (const runId in treemap) {
        if (runId !== run.id) {
          runs[runId].child_runs = treemap[runId];
        }
      }
      return run;
    }
    async *listRuns(props) {
      const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id: id2, query, filter: filter2, traceFilter, treeFilter, limit, select } = props;
      let projectIds = [];
      if (projectId) {
        projectIds = Array.isArray(projectId) ? projectId : [
          projectId
        ];
      }
      if (projectName) {
        const projectNames = Array.isArray(projectName) ? projectName : [
          projectName
        ];
        const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({
          projectName: name
        }).then((project) => project.id)));
        projectIds.push(...projectIds_);
      }
      const default_select = [
        "app_path",
        "child_run_ids",
        "completion_cost",
        "completion_tokens",
        "dotted_order",
        "end_time",
        "error",
        "events",
        "extra",
        "feedback_stats",
        "first_token_time",
        "id",
        "inputs",
        "name",
        "outputs",
        "parent_run_id",
        "parent_run_ids",
        "prompt_cost",
        "prompt_tokens",
        "reference_example_id",
        "run_type",
        "session_id",
        "start_time",
        "status",
        "tags",
        "total_cost",
        "total_tokens",
        "trace_id"
      ];
      const body = {
        session: projectIds.length ? projectIds : null,
        run_type: runType,
        reference_example: referenceExampleId,
        query,
        filter: filter2,
        trace_filter: traceFilter,
        tree_filter: treeFilter,
        execution_order: executionOrder,
        parent_run: parentRunId,
        start_time: startTime ? startTime.toISOString() : null,
        error,
        id: id2,
        limit,
        trace: traceId,
        select: select ? select : default_select,
        is_root: isRoot
      };
      let runsYielded = 0;
      for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
        if (limit) {
          if (runsYielded >= limit) {
            break;
          }
          if (runs.length + runsYielded > limit) {
            const newRuns = runs.slice(0, limit - runsYielded);
            yield* newRuns;
            break;
          }
          runsYielded += runs.length;
          yield* runs;
        } else {
          yield* runs;
        }
      }
    }
    async getRunStats({ id: id2, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter: filter2, traceFilter, treeFilter, isRoot, dataSourceType }) {
      let projectIds_ = projectIds || [];
      if (projectNames) {
        projectIds_ = [
          ...projectIds || [],
          ...await Promise.all(projectNames.map((name) => this.readProject({
            projectName: name
          }).then((project) => project.id)))
        ];
      }
      const payload = {
        id: id2,
        trace,
        parent_run: parentRun,
        run_type: runType,
        session: projectIds_,
        reference_example: referenceExampleIds,
        start_time: startTime,
        end_time: endTime,
        error,
        query,
        filter: filter2,
        trace_filter: traceFilter,
        tree_filter: treeFilter,
        is_root: isRoot,
        data_source_type: dataSourceType
      };
      const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/stats`, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(filteredPayload),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      return result;
    }
    async shareRun(runId, { shareId } = {}) {
      const data = {
        run_id: runId,
        share_token: shareId || v4()
      };
      assertUuid(runId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      if (result === null || !("share_token" in result)) {
        throw new Error("Invalid response from server");
      }
      return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
    }
    async unshareRun(runId) {
      assertUuid(runId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "unshare run", true);
    }
    async readRunSharedLink(runId) {
      assertUuid(runId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/runs/${runId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      if (result === null || !("share_token" in result)) {
        return void 0;
      }
      return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
    }
    async listSharedRuns(shareToken, { runIds } = {}) {
      const queryParams = new URLSearchParams({
        share_token: shareToken
      });
      if (runIds !== void 0) {
        for (const runId of runIds) {
          queryParams.append("id", runId);
        }
      }
      assertUuid(shareToken);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const runs = await response.json();
      return runs;
    }
    async readDatasetSharedSchema(datasetId, datasetName) {
      if (!datasetId && !datasetName) {
        throw new Error("Either datasetId or datasetName must be given");
      }
      if (!datasetId) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId = dataset.id;
      }
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const shareSchema = await response.json();
      shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
      return shareSchema;
    }
    async shareDataset(datasetId, datasetName) {
      if (!datasetId && !datasetName) {
        throw new Error("Either datasetId or datasetName must be given");
      }
      if (!datasetId) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId = dataset.id;
      }
      const data = {
        dataset_id: datasetId
      };
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "PUT",
        headers: this.headers,
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const shareSchema = await response.json();
      shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
      return shareSchema;
    }
    async unshareDataset(datasetId) {
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/share`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "unshare dataset", true);
    }
    async readSharedDataset(shareToken) {
      assertUuid(shareToken);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/datasets`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const dataset = await response.json();
      return dataset;
    }
    async listSharedExamples(shareToken, options) {
      const params = {};
      if (options == null ? void 0 : options.exampleIds) {
        params.id = options.exampleIds;
      }
      const urlParams = new URLSearchParams();
      Object.entries(params).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          value.forEach((v2) => urlParams.append(key, v2));
        } else {
          urlParams.append(key, value);
        }
      });
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      if (!response.ok) {
        if ("detail" in result) {
          throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${result.detail.join("\n")}`);
        }
        throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
      }
      return result.map((example) => ({
        ...example,
        _hostUrl: this.getHostUrl()
      }));
    }
    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
      const upsert_ = upsert ? `?upsert=true` : "";
      const endpoint = `${this.apiUrl}/sessions${upsert_}`;
      const extra = projectExtra || {};
      if (metadata) {
        extra["metadata"] = metadata;
      }
      const body = {
        name: projectName,
        extra,
        description
      };
      if (referenceDatasetId !== null) {
        body["reference_dataset_id"] = referenceDatasetId;
      }
      const response = await this.caller.call(_getFetchImplementation(), endpoint, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create project");
      const result = await response.json();
      return result;
    }
    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
      const endpoint = `${this.apiUrl}/sessions/${projectId}`;
      let extra = projectExtra;
      if (metadata) {
        extra = {
          ...extra || {},
          metadata
        };
      }
      const body = {
        name,
        extra,
        description,
        end_time: endTime ? new Date(endTime).toISOString() : null
      };
      const response = await this.caller.call(_getFetchImplementation(), endpoint, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update project");
      const result = await response.json();
      return result;
    }
    async hasProject({ projectId, projectName }) {
      let path = "/sessions";
      const params = new URLSearchParams();
      if (projectId !== void 0 && projectName !== void 0) {
        throw new Error("Must provide either projectName or projectId, not both");
      } else if (projectId !== void 0) {
        assertUuid(projectId);
        path += `/${projectId}`;
      } else if (projectName !== void 0) {
        params.append("name", projectName);
      } else {
        throw new Error("Must provide projectName or projectId");
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${path}?${params}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      try {
        const result = await response.json();
        if (!response.ok) {
          return false;
        }
        if (Array.isArray(result)) {
          return result.length > 0;
        }
        return true;
      } catch (e) {
        return false;
      }
    }
    async readProject({ projectId, projectName, includeStats }) {
      let path = "/sessions";
      const params = new URLSearchParams();
      if (projectId !== void 0 && projectName !== void 0) {
        throw new Error("Must provide either projectName or projectId, not both");
      } else if (projectId !== void 0) {
        assertUuid(projectId);
        path += `/${projectId}`;
      } else if (projectName !== void 0) {
        params.append("name", projectName);
      } else {
        throw new Error("Must provide projectName or projectId");
      }
      if (includeStats !== void 0) {
        params.append("include_stats", includeStats.toString());
      }
      const response = await this._get(path, params);
      let result;
      if (Array.isArray(response)) {
        if (response.length === 0) {
          throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
        }
        result = response[0];
      } else {
        result = response;
      }
      return result;
    }
    async getProjectUrl({ projectId, projectName }) {
      if (projectId === void 0 && projectName === void 0) {
        throw new Error("Must provide either projectName or projectId");
      }
      const project = await this.readProject({
        projectId,
        projectName
      });
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
    }
    async getDatasetUrl({ datasetId, datasetName }) {
      if (datasetId === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      }
      const dataset = await this.readDataset({
        datasetId,
        datasetName
      });
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
    }
    async _getTenantId() {
      if (this._tenantId !== null) {
        return this._tenantId;
      }
      const queryParams = new URLSearchParams({
        limit: "1"
      });
      for await (const projects of this._getPaginated("/sessions", queryParams)) {
        this._tenantId = projects[0].tenant_id;
        return projects[0].tenant_id;
      }
      throw new Error("No projects found to resolve tenant.");
    }
    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {
      const params = new URLSearchParams();
      if (projectIds !== void 0) {
        for (const projectId of projectIds) {
          params.append("id", projectId);
        }
      }
      if (name !== void 0) {
        params.append("name", name);
      }
      if (nameContains !== void 0) {
        params.append("name_contains", nameContains);
      }
      if (referenceDatasetId !== void 0) {
        params.append("reference_dataset", referenceDatasetId);
      } else if (referenceDatasetName !== void 0) {
        const dataset = await this.readDataset({
          datasetName: referenceDatasetName
        });
        params.append("reference_dataset", dataset.id);
      }
      if (referenceFree !== void 0) {
        params.append("reference_free", referenceFree.toString());
      }
      if (metadata !== void 0) {
        params.append("metadata", JSON.stringify(metadata));
      }
      for await (const projects of this._getPaginated("/sessions", params)) {
        yield* projects;
      }
    }
    async deleteProject({ projectId, projectName }) {
      let projectId_;
      if (projectId === void 0 && projectName === void 0) {
        throw new Error("Must provide projectName or projectId");
      } else if (projectId !== void 0 && projectName !== void 0) {
        throw new Error("Must provide either projectName or projectId, not both");
      } else if (projectId === void 0) {
        projectId_ = (await this.readProject({
          projectName
        })).id;
      } else {
        projectId_ = projectId;
      }
      assertUuid(projectId_);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/sessions/${projectId_}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);
    }
    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
      const url = `${this.apiUrl}/datasets/upload`;
      const formData = new FormData();
      formData.append("file", csvFile, fileName);
      inputKeys.forEach((key) => {
        formData.append("input_keys", key);
      });
      outputKeys.forEach((key) => {
        formData.append("output_keys", key);
      });
      if (description) {
        formData.append("description", description);
      }
      if (dataType) {
        formData.append("data_type", dataType);
      }
      if (name) {
        formData.append("name", name);
      }
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "POST",
        headers: this.headers,
        body: formData,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "upload CSV");
      const result = await response.json();
      return result;
    }
    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
      const body = {
        name,
        description,
        extra: metadata ? {
          metadata
        } : void 0
      };
      if (dataType) {
        body.data_type = dataType;
      }
      if (inputsSchema) {
        body.inputs_schema_definition = inputsSchema;
      }
      if (outputsSchema) {
        body.outputs_schema_definition = outputsSchema;
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create dataset");
      const result = await response.json();
      return result;
    }
    async readDataset({ datasetId, datasetName }) {
      let path = "/datasets";
      const params = new URLSearchParams({
        limit: "1"
      });
      if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId !== void 0) {
        assertUuid(datasetId);
        path += `/${datasetId}`;
      } else if (datasetName !== void 0) {
        params.append("name", datasetName);
      } else {
        throw new Error("Must provide datasetName or datasetId");
      }
      const response = await this._get(path, params);
      let result;
      if (Array.isArray(response)) {
        if (response.length === 0) {
          throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
        }
        result = response[0];
      } else {
        result = response;
      }
      return result;
    }
    async hasDataset({ datasetId, datasetName }) {
      try {
        await this.readDataset({
          datasetId,
          datasetName
        });
        return true;
      } catch (e) {
        if (e instanceof Error && e.message.toLocaleLowerCase().includes("not found")) {
          return false;
        }
        throw e;
      }
    }
    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
      let datasetId_ = datasetId;
      if (datasetId_ === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_ === void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      }
      const urlParams = new URLSearchParams({
        from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
        to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
      });
      const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
      return response;
    }
    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
      const path = "/datasets";
      if (datasetId !== void 0) ;
      else if (datasetName !== void 0) {
        datasetId = (await this.readDataset({
          datasetName
        })).id;
      } else {
        throw new Error("Must provide datasetName or datasetId");
      }
      const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
      const datasetText = await response.text();
      const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
      return dataset;
    }
    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
      const path = "/datasets";
      const params = new URLSearchParams({
        limit: limit.toString(),
        offset: offset.toString()
      });
      if (datasetIds !== void 0) {
        for (const id_ of datasetIds) {
          params.append("id", id_);
        }
      }
      if (datasetName !== void 0) {
        params.append("name", datasetName);
      }
      if (datasetNameContains !== void 0) {
        params.append("name_contains", datasetNameContains);
      }
      if (metadata !== void 0) {
        params.append("metadata", JSON.stringify(metadata));
      }
      for await (const datasets of this._getPaginated(path, params)) {
        yield* datasets;
      }
    }
    async updateDataset(props) {
      const { datasetId, datasetName, ...update } = props;
      if (!datasetId && !datasetName) {
        throw new Error("Must provide either datasetName or datasetId");
      }
      const _datasetId = datasetId ?? (await this.readDataset({
        datasetName
      })).id;
      assertUuid(_datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${_datasetId}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update dataset");
      return await response.json();
    }
    async deleteDataset({ datasetId, datasetName }) {
      let path = "/datasets";
      let datasetId_ = datasetId;
      if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetName !== void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      }
      if (datasetId_ !== void 0) {
        assertUuid(datasetId_);
        path += `/${datasetId_}`;
      } else {
        throw new Error("Must provide datasetName or datasetId");
      }
      const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete ${path}`);
      await response.json();
    }
    async indexDataset({ datasetId, datasetName, tag }) {
      let datasetId_ = datasetId;
      if (!datasetId_ && !datasetName) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ && datasetName) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (!datasetId_) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      }
      assertUuid(datasetId_);
      const data = {
        tag
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId_}/index`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "index dataset");
      await response.json();
    }
    async similarExamples(inputs, datasetId, limit, { filter: filter2 } = {}) {
      const data = {
        limit,
        inputs
      };
      if (filter2 !== void 0) {
        data["filter"] = filter2;
      }
      assertUuid(datasetId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId}/search`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "fetch similar examples");
      const result = await response.json();
      return result["examples"];
    }
    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId, metadata, split, sourceRunId }) {
      let datasetId_ = datasetId;
      if (datasetId_ === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_ === void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      }
      const createdAt_ = createdAt || /* @__PURE__ */ new Date();
      const data = {
        dataset_id: datasetId_,
        inputs,
        outputs,
        created_at: createdAt_ == null ? void 0 : createdAt_.toISOString(),
        id: exampleId,
        metadata,
        split,
        source_run_id: sourceRunId
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create example");
      const result = await response.json();
      return result;
    }
    async createExamples(props) {
      const { inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName } = props;
      let datasetId_ = datasetId;
      if (datasetId_ === void 0 && datasetName === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_ !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_ === void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      }
      const formattedExamples = inputs.map((input, idx) => {
        return {
          dataset_id: datasetId_,
          inputs: input,
          outputs: outputs ? outputs[idx] : void 0,
          metadata: metadata ? metadata[idx] : void 0,
          split: props.splits ? props.splits[idx] : void 0,
          id: exampleIds ? exampleIds[idx] : void 0,
          source_run_id: sourceRunIds ? sourceRunIds[idx] : void 0
        };
      });
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples/bulk`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(formattedExamples),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create examples");
      const result = await response.json();
      return result;
    }
    async createLLMExample(input, generation, options) {
      return this.createExample({
        input
      }, {
        output: generation
      }, options);
    }
    async createChatExample(input, generations, options) {
      const finalInput = input.map((message) => {
        if (isLangChainMessage(message)) {
          return convertLangChainMessageToExample(message);
        }
        return message;
      });
      const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
      return this.createExample({
        input: finalInput
      }, {
        output: finalOutput
      }, options);
    }
    async readExample(exampleId) {
      assertUuid(exampleId);
      const path = `/examples/${exampleId}`;
      return await this._get(path);
    }
    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter: filter2 } = {}) {
      let datasetId_;
      if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId !== void 0) {
        datasetId_ = datasetId;
      } else if (datasetName !== void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      } else {
        throw new Error("Must provide a datasetName or datasetId");
      }
      const params = new URLSearchParams({
        dataset: datasetId_
      });
      const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
      if (dataset_version) {
        params.append("as_of", dataset_version);
      }
      const inlineS3Urls_ = inlineS3Urls ?? true;
      params.append("inline_s3_urls", inlineS3Urls_.toString());
      if (exampleIds !== void 0) {
        for (const id_ of exampleIds) {
          params.append("id", id_);
        }
      }
      if (splits !== void 0) {
        for (const split of splits) {
          params.append("splits", split);
        }
      }
      if (metadata !== void 0) {
        const serializedMetadata = JSON.stringify(metadata);
        params.append("metadata", serializedMetadata);
      }
      if (limit !== void 0) {
        params.append("limit", limit.toString());
      }
      if (offset !== void 0) {
        params.append("offset", offset.toString());
      }
      if (filter2 !== void 0) {
        params.append("filter", filter2);
      }
      let i2 = 0;
      for await (const examples of this._getPaginated("/examples", params)) {
        for (const example of examples) {
          yield example;
          i2++;
        }
        if (limit !== void 0 && i2 >= limit) {
          break;
        }
      }
    }
    async deleteExample(exampleId) {
      assertUuid(exampleId);
      const path = `/examples/${exampleId}`;
      const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete ${path}`);
      await response.json();
    }
    async updateExample(exampleId, update) {
      assertUuid(exampleId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples/${exampleId}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update example");
      const result = await response.json();
      return result;
    }
    async updateExamples(update) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/examples/bulk`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(update),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update examples");
      const result = await response.json();
      return result;
    }
    async listDatasetSplits({ datasetId, datasetName, asOf }) {
      let datasetId_;
      if (datasetId === void 0 && datasetName === void 0) {
        throw new Error("Must provide dataset name or ID");
      } else if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId === void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      } else {
        datasetId_ = datasetId;
      }
      assertUuid(datasetId_);
      const params = new URLSearchParams();
      const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
      if (dataset_version) {
        params.append("as_of", dataset_version);
      }
      const response = await this._get(`/datasets/${datasetId_}/splits`, params);
      return response;
    }
    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove: remove2 = false }) {
      let datasetId_;
      if (datasetId === void 0 && datasetName === void 0) {
        throw new Error("Must provide dataset name or ID");
      } else if (datasetId !== void 0 && datasetName !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId === void 0) {
        const dataset = await this.readDataset({
          datasetName
        });
        datasetId_ = dataset.id;
      } else {
        datasetId_ = datasetId;
      }
      assertUuid(datasetId_);
      const data = {
        split_name: splitName,
        examples: exampleIds.map((id2) => {
          assertUuid(id2);
          return id2;
        }),
        remove: remove2
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {
        method: "PUT",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update dataset splits", true);
    }
    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {
      loadChildRuns: false
    }) {
      warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
      let run_;
      if (typeof run === "string") {
        run_ = await this.readRun(run, {
          loadChildRuns
        });
      } else if (typeof run === "object" && "id" in run) {
        run_ = run;
      } else {
        throw new Error(`Invalid run type: ${typeof run}`);
      }
      if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
        referenceExample = await this.readExample(run_.reference_example_id);
      }
      const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
      const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
      return feedbacks[0];
    }
    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
      var _a;
      if (!runId && !projectId) {
        throw new Error("One of runId or projectId must be provided");
      }
      if (runId && projectId) {
        throw new Error("Only one of runId or projectId can be provided");
      }
      const feedback_source = {
        type: feedbackSourceType ?? "api",
        metadata: sourceInfo ?? {}
      };
      if (sourceRunId !== void 0 && (feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && !feedback_source.metadata["__run"]) {
        feedback_source.metadata["__run"] = {
          run_id: sourceRunId
        };
      }
      if ((feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && ((_a = feedback_source.metadata["__run"]) == null ? void 0 : _a.run_id) !== void 0) {
        assertUuid(feedback_source.metadata["__run"].run_id);
      }
      const feedback = {
        id: feedbackId ?? v4(),
        run_id: runId,
        key,
        score,
        value,
        correction,
        comment,
        feedback_source,
        comparative_experiment_id: comparativeExperimentId,
        feedbackConfig,
        session_id: projectId
      };
      const url = `${this.apiUrl}/feedback`;
      const response = await this.caller.call(_getFetchImplementation(), url, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(feedback),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create feedback", true);
      return feedback;
    }
    async updateFeedback(feedbackId, { score, value, correction, comment }) {
      const feedbackUpdate = {};
      if (score !== void 0 && score !== null) {
        feedbackUpdate["score"] = score;
      }
      if (value !== void 0 && value !== null) {
        feedbackUpdate["value"] = value;
      }
      if (correction !== void 0 && correction !== null) {
        feedbackUpdate["correction"] = correction;
      }
      if (comment !== void 0 && comment !== null) {
        feedbackUpdate["comment"] = comment;
      }
      assertUuid(feedbackId);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/feedback/${feedbackId}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(feedbackUpdate),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update feedback", true);
    }
    async readFeedback(feedbackId) {
      assertUuid(feedbackId);
      const path = `/feedback/${feedbackId}`;
      const response = await this._get(path);
      return response;
    }
    async deleteFeedback(feedbackId) {
      assertUuid(feedbackId);
      const path = `/feedback/${feedbackId}`;
      const response = await this.caller.call(_getFetchImplementation(), this.apiUrl + path, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `delete ${path}`);
      await response.json();
    }
    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
      const queryParams = new URLSearchParams();
      if (runIds) {
        queryParams.append("run", runIds.join(","));
      }
      if (feedbackKeys) {
        for (const key of feedbackKeys) {
          queryParams.append("key", key);
        }
      }
      if (feedbackSourceTypes) {
        for (const type of feedbackSourceTypes) {
          queryParams.append("source", type);
        }
      }
      for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
        yield* feedbacks;
      }
    }
    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
      const body = {
        run_id: runId,
        feedback_key: feedbackKey,
        feedback_config: feedbackConfig
      };
      if (expiration) {
        if (typeof expiration === "string") {
          body["expires_at"] = expiration;
        } else if ((expiration == null ? void 0 : expiration.hours) || (expiration == null ? void 0 : expiration.minutes) || (expiration == null ? void 0 : expiration.days)) {
          body["expires_in"] = expiration;
        }
      } else {
        body["expires_in"] = {
          hours: 3
        };
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/feedback/tokens`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const result = await response.json();
      return result;
    }
    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id: id2 }) {
      var _a;
      if (experimentIds.length === 0) {
        throw new Error("At least one experiment is required");
      }
      if (!referenceDatasetId) {
        referenceDatasetId = (await this.readProject({
          projectId: experimentIds[0]
        })).reference_dataset_id;
      }
      if (!referenceDatasetId == null) {
        throw new Error("A reference dataset is required");
      }
      const body = {
        id: id2,
        name,
        experiment_ids: experimentIds,
        reference_dataset_id: referenceDatasetId,
        description,
        created_at: (_a = createdAt ?? /* @__PURE__ */ new Date()) == null ? void 0 : _a.toISOString(),
        extra: {}
      };
      if (metadata) body.extra["metadata"] = metadata;
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/datasets/comparative`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await response.json();
    }
    async *listPresignedFeedbackTokens(runId) {
      assertUuid(runId);
      const params = new URLSearchParams({
        run_id: runId
      });
      for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
        yield* tokens;
      }
    }
    _selectEvalResults(results) {
      let results_;
      if ("results" in results) {
        results_ = results.results;
      } else {
        results_ = [
          results
        ];
      }
      return results_;
    }
    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
      const evalResults = this._selectEvalResults(evaluatorResponse);
      const feedbacks = [];
      for (const res of evalResults) {
        let sourceInfo_ = sourceInfo || {};
        if (res.evaluatorInfo) {
          sourceInfo_ = {
            ...res.evaluatorInfo,
            ...sourceInfo_
          };
        }
        let runId_ = null;
        if (res.targetRunId) {
          runId_ = res.targetRunId;
        } else if (run) {
          runId_ = run.id;
        }
        feedbacks.push(await this.createFeedback(runId_, res.key, {
          score: res.score,
          value: res.value,
          comment: res.comment,
          correction: res.correction,
          sourceInfo: sourceInfo_,
          sourceRunId: res.sourceRunId,
          feedbackConfig: res.feedbackConfig,
          feedbackSourceType: "model"
        }));
      }
      return [
        evalResults,
        feedbacks
      ];
    }
    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
      const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
      return results;
    }
    async *listAnnotationQueues(options = {}) {
      const { queueIds, name, nameContains, limit } = options;
      const params = new URLSearchParams();
      if (queueIds) {
        queueIds.forEach((id2, i2) => {
          assertUuid(id2, `queueIds[${i2}]`);
          params.append("ids", id2);
        });
      }
      if (name) params.append("name", name);
      if (nameContains) params.append("name_contains", nameContains);
      params.append("limit", (limit !== void 0 ? Math.min(limit, 100) : 100).toString());
      let count2 = 0;
      for await (const queues of this._getPaginated("/annotation-queues", params)) {
        yield* queues;
        count2++;
        if (limit !== void 0 && count2 >= limit) break;
      }
    }
    async createAnnotationQueue(options) {
      const { name, description, queueId } = options;
      const body = {
        name,
        description,
        id: queueId || v4()
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v2]) => v2 !== void 0))),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create annotation queue");
      const data = await response.json();
      return data;
    }
    async readAnnotationQueue(queueId) {
      const queueIteratorResult = await this.listAnnotationQueues({
        queueIds: [
          queueId
        ]
      }).next();
      if (queueIteratorResult.done) {
        throw new Error(`Annotation queue with ID ${queueId} not found`);
      }
      return queueIteratorResult.value;
    }
    async updateAnnotationQueue(queueId, options) {
      const { name, description } = options;
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "PATCH",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          name,
          description
        }),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update annotation queue");
    }
    async deleteAnnotationQueue(queueId) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
        method: "DELETE",
        headers: {
          ...this.headers,
          Accept: "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "delete annotation queue");
    }
    async addRunsToAnnotationQueue(queueId, runIds) {
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(runIds.map((id2, i2) => assertUuid(id2, `runIds[${i2}]`).toString())),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "add runs to annotation queue");
    }
    async getRunFromAnnotationQueue(queueId, index2) {
      const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}${baseUrl}/${index2}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "get run from annotation queue");
      return await response.json();
    }
    async _currentTenantIsOwner(owner) {
      const settings = await this._getSettings();
      return owner == "-" || settings.tenant_handle === owner;
    }
    async _ownerConflictError(action, owner) {
      const settings = await this._getSettings();
      return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
    }
    async _getLatestCommitHash(promptOwnerAndName) {
      const res = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      const json = await res.json();
      if (!res.ok) {
        const detail = typeof json.detail === "string" ? json.detail : JSON.stringify(json.detail);
        const error = new Error(`Error ${res.status}: ${res.statusText}
${detail}`);
        error.statusCode = res.status;
        throw error;
      }
      if (json.commits.length === 0) {
        return void 0;
      }
      return json.commits[0].commit_hash;
    }
    async _likeOrUnlikePrompt(promptIdentifier, like) {
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/likes/${owner}/${promptName}`, {
        method: "POST",
        body: JSON.stringify({
          like
        }),
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `${like ? "like" : "unlike"} prompt`);
      return await response.json();
    }
    async _getPromptUrl(promptIdentifier) {
      const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        if (commitHash !== "latest") {
          return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
        } else {
          return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
        }
      } else {
        const settings = await this._getSettings();
        if (commitHash !== "latest") {
          return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
        } else {
          return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
        }
      }
    }
    async promptExists(promptIdentifier) {
      const prompt = await this.getPrompt(promptIdentifier);
      return !!prompt;
    }
    async likePrompt(promptIdentifier) {
      return this._likeOrUnlikePrompt(promptIdentifier, true);
    }
    async unlikePrompt(promptIdentifier) {
      return this._likeOrUnlikePrompt(promptIdentifier, false);
    }
    async *listCommits(promptOwnerAndName) {
      for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
        yield* commits;
      }
    }
    async *listPrompts(options) {
      const params = new URLSearchParams();
      params.append("sort_field", (options == null ? void 0 : options.sortField) ?? "updated_at");
      params.append("sort_direction", "desc");
      params.append("is_archived", (!!(options == null ? void 0 : options.isArchived)).toString());
      if ((options == null ? void 0 : options.isPublic) !== void 0) {
        params.append("is_public", options.isPublic.toString());
      }
      if (options == null ? void 0 : options.query) {
        params.append("query", options.query);
      }
      for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
        yield* prompts;
      }
    }
    async getPrompt(promptIdentifier) {
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      if (response.status === 404) {
        return null;
      }
      await raiseForStatus(response, "get prompt");
      const result = await response.json();
      if (result.repo) {
        return result.repo;
      } else {
        return null;
      }
    }
    async createPrompt(promptIdentifier, options) {
      const settings = await this._getSettings();
      if ((options == null ? void 0 : options.isPublic) && !settings.tenant_handle) {
        throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
      }
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        throw await this._ownerConflictError("create a prompt", owner);
      }
      const data = {
        repo_handle: promptName,
        ...(options == null ? void 0 : options.description) && {
          description: options.description
        },
        ...(options == null ? void 0 : options.readme) && {
          readme: options.readme
        },
        ...(options == null ? void 0 : options.tags) && {
          tags: options.tags
        },
        is_public: !!(options == null ? void 0 : options.isPublic)
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create prompt");
      const { repo } = await response.json();
      return repo;
    }
    async createCommit(promptIdentifier, object, options) {
      if (!await this.promptExists(promptIdentifier)) {
        throw new Error("Prompt does not exist, you must create it first.");
      }
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      const resolvedParentCommitHash = (options == null ? void 0 : options.parentCommitHash) === "latest" || !(options == null ? void 0 : options.parentCommitHash) ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options == null ? void 0 : options.parentCommitHash;
      const payload = {
        manifest: JSON.parse(JSON.stringify(object)),
        parent_commit: resolvedParentCommitHash
      };
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${owner}/${promptName}`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "create commit");
      const result = await response.json();
      return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
    }
    async updatePrompt(promptIdentifier, options) {
      if (!await this.promptExists(promptIdentifier)) {
        throw new Error("Prompt does not exist, you must create it first.");
      }
      const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        throw await this._ownerConflictError("update a prompt", owner);
      }
      const payload = {};
      if ((options == null ? void 0 : options.description) !== void 0) payload.description = options.description;
      if ((options == null ? void 0 : options.readme) !== void 0) payload.readme = options.readme;
      if ((options == null ? void 0 : options.tags) !== void 0) payload.tags = options.tags;
      if ((options == null ? void 0 : options.isPublic) !== void 0) payload.is_public = options.isPublic;
      if ((options == null ? void 0 : options.isArchived) !== void 0) payload.is_archived = options.isArchived;
      if (Object.keys(payload).length === 0) {
        throw new Error("No valid update options provided");
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "PATCH",
        body: JSON.stringify(payload),
        headers: {
          ...this.headers,
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "update prompt");
      return response.json();
    }
    async deletePrompt(promptIdentifier) {
      if (!await this.promptExists(promptIdentifier)) {
        throw new Error("Prompt does not exist, you must create it first.");
      }
      const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
      if (!await this._currentTenantIsOwner(owner)) {
        throw await this._ownerConflictError("delete a prompt", owner);
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/repos/${owner}/${promptName}`, {
        method: "DELETE",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      return await response.json();
    }
    async pullPromptCommit(promptIdentifier, options) {
      const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
      const serverInfo = await this._getServerInfo();
      const useOptimization = isVersionGreaterOrEqual(serverInfo.version, "0.5.23");
      let passedCommitHash = commitHash;
      if (!useOptimization && commitHash === "latest") {
        const latestCommitHash = await this._getLatestCommitHash(`${owner}/${promptName}`);
        if (!latestCommitHash) {
          throw new Error("No commits found");
        } else {
          passedCommitHash = latestCommitHash;
        }
      }
      const response = await this.caller.call(_getFetchImplementation(), `${this.apiUrl}/commits/${owner}/${promptName}/${passedCommitHash}${(options == null ? void 0 : options.includeModel) ? "?include_model=true" : ""}`, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, "pull prompt commit");
      const result = await response.json();
      return {
        owner,
        repo: promptName,
        commit_hash: result.commit_hash,
        manifest: result.manifest,
        examples: result.examples
      };
    }
    async _pullPrompt(promptIdentifier, options) {
      const promptObject = await this.pullPromptCommit(promptIdentifier, {
        includeModel: options == null ? void 0 : options.includeModel
      });
      const prompt = JSON.stringify(promptObject.manifest);
      return prompt;
    }
    async pushPrompt(promptIdentifier, options) {
      if (await this.promptExists(promptIdentifier)) {
        if (options && Object.keys(options).some((key) => key !== "object")) {
          await this.updatePrompt(promptIdentifier, {
            description: options == null ? void 0 : options.description,
            readme: options == null ? void 0 : options.readme,
            tags: options == null ? void 0 : options.tags,
            isPublic: options == null ? void 0 : options.isPublic
          });
        }
      } else {
        await this.createPrompt(promptIdentifier, {
          description: options == null ? void 0 : options.description,
          readme: options == null ? void 0 : options.readme,
          tags: options == null ? void 0 : options.tags,
          isPublic: options == null ? void 0 : options.isPublic
        });
      }
      if (!(options == null ? void 0 : options.object)) {
        return await this._getPromptUrl(promptIdentifier);
      }
      const url = await this.createCommit(promptIdentifier, options == null ? void 0 : options.object, {
        parentCommitHash: options == null ? void 0 : options.parentCommitHash
      });
      return url;
    }
    async clonePublicDataset(tokenOrUrl, options = {}) {
      const { sourceApiUrl = this.apiUrl, datasetName } = options;
      const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
      const sourceClient = new Client({
        apiUrl: parsedApiUrl,
        apiKey: "placeholder"
      });
      const ds = await sourceClient.readSharedDataset(tokenUuid);
      const finalDatasetName = datasetName || ds.name;
      try {
        if (await this.hasDataset({
          datasetId: finalDatasetName
        })) {
          console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
          return;
        }
      } catch (_) {
      }
      const examples = await sourceClient.listSharedExamples(tokenUuid);
      const dataset = await this.createDataset(finalDatasetName, {
        description: ds.description,
        dataType: ds.data_type || "kv",
        inputsSchema: ds.inputs_schema_definition ?? void 0,
        outputsSchema: ds.outputs_schema_definition ?? void 0
      });
      try {
        await this.createExamples({
          inputs: examples.map((e) => e.inputs),
          outputs: examples.flatMap((e) => e.outputs ? [
            e.outputs
          ] : []),
          datasetId: dataset.id
        });
      } catch (e) {
        console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
        throw e;
      }
    }
    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
      try {
        assertUuid(urlOrToken);
        return [
          apiUrl,
          urlOrToken
        ];
      } catch (_) {
      }
      try {
        const parsedUrl = new URL(urlOrToken);
        const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
        if (pathParts.length >= numParts) {
          const tokenUuid = pathParts[pathParts.length - numParts];
          return [
            apiUrl,
            tokenUuid
          ];
        } else {
          throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
        }
      } catch (error) {
        throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
      }
    }
  }
  const isTracingEnabled$1 = (tracingEnabled) => {
    const envVars = [
      "TRACING_V2",
      "TRACING"
    ];
    return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
  };
  function stripNonAlphanumeric(input) {
    return input.replace(/[-:.]/g, "");
  }
  function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
  }
  class Baggage {
    constructor(metadata, tags) {
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.metadata = metadata;
      this.tags = tags;
    }
    static fromHeader(value) {
      const items = value.split(",");
      let metadata = {};
      let tags = [];
      for (const item of items) {
        const [key, uriValue] = item.split("=");
        const value2 = decodeURIComponent(uriValue);
        if (key === "langsmith-metadata") {
          metadata = JSON.parse(value2);
        } else if (key === "langsmith-tags") {
          tags = value2.split(",");
        }
      }
      return new Baggage(metadata, tags);
    }
    toHeader() {
      const items = [];
      if (this.metadata && Object.keys(this.metadata).length > 0) {
        items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
      }
      if (this.tags && this.tags.length > 0) {
        items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
      }
      return items.join(",");
    }
  }
  class RunTree {
    constructor(originalConfig) {
      var _a;
      Object.defineProperty(this, "id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "run_type", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "project_name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "parent_run", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "child_runs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "start_time", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "end_time", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "extra", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "error", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "serialized", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "inputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "outputs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "reference_example_id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "events", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "trace_id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "dotted_order", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tracingEnabled", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "execution_order", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "child_execution_order", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      const defaultConfig = RunTree.getDefaultConfig();
      const { metadata, ...config } = originalConfig;
      const client = config.client ?? RunTree.getSharedClient();
      const dedupedMetadata = {
        ...metadata,
        ...(_a = config == null ? void 0 : config.extra) == null ? void 0 : _a.metadata
      };
      config.extra = {
        ...config.extra,
        metadata: dedupedMetadata
      };
      Object.assign(this, {
        ...defaultConfig,
        ...config,
        client
      });
      if (!this.trace_id) {
        if (this.parent_run) {
          this.trace_id = this.parent_run.trace_id ?? this.id;
        } else {
          this.trace_id = this.id;
        }
      }
      this.execution_order ?? (this.execution_order = 1);
      this.child_execution_order ?? (this.child_execution_order = 1);
      if (!this.dotted_order) {
        const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
        if (this.parent_run) {
          this.dotted_order = this.parent_run.dotted_order + "." + currentDottedOrder;
        } else {
          this.dotted_order = currentDottedOrder;
        }
      }
    }
    static getDefaultConfig() {
      return {
        id: v4(),
        run_type: "chain",
        project_name: getEnvironmentVariable("LANGCHAIN_PROJECT") ?? getEnvironmentVariable("LANGCHAIN_SESSION") ?? "default",
        child_runs: [],
        api_url: getEnvironmentVariable("LANGCHAIN_ENDPOINT") ?? "http://localhost:1984",
        api_key: getEnvironmentVariable("LANGCHAIN_API_KEY"),
        caller_options: {},
        start_time: Date.now(),
        serialized: {},
        inputs: {},
        extra: {}
      };
    }
    static getSharedClient() {
      if (!RunTree.sharedClient) {
        RunTree.sharedClient = new Client();
      }
      return RunTree.sharedClient;
    }
    createChild(config) {
      var _a, _b, _c, _d, _e, _f;
      const child_execution_order = this.child_execution_order + 1;
      const child = new RunTree({
        ...config,
        parent_run: this,
        project_name: this.project_name,
        client: this.client,
        tracingEnabled: this.tracingEnabled,
        execution_order: child_execution_order,
        child_execution_order
      });
      const LC_CHILD = Symbol.for("lc:child_config");
      const presentConfig = ((_a = config.extra) == null ? void 0 : _a[LC_CHILD]) ?? this.extra[LC_CHILD];
      if (isRunnableConfigLike(presentConfig)) {
        const newConfig = {
          ...presentConfig
        };
        const callbacks = isCallbackManagerLike(newConfig.callbacks) ? (_c = (_b = newConfig.callbacks).copy) == null ? void 0 : _c.call(_b) : void 0;
        if (callbacks) {
          Object.assign(callbacks, {
            _parentRunId: child.id
          });
          (_f = (_e = (_d = callbacks.handlers) == null ? void 0 : _d.find(isLangChainTracerLike)) == null ? void 0 : _e.updateFromRunTree) == null ? void 0 : _f.call(_e, child);
          newConfig.callbacks = callbacks;
        }
        child.extra[LC_CHILD] = newConfig;
      }
      const visited = /* @__PURE__ */ new Set();
      let current = this;
      while (current != null && !visited.has(current.id)) {
        visited.add(current.id);
        current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
        current = current.parent_run;
      }
      this.child_runs.push(child);
      return child;
    }
    async end(outputs, error, endTime = Date.now()) {
      this.outputs = this.outputs ?? outputs;
      this.error = this.error ?? error;
      this.end_time = this.end_time ?? endTime;
    }
    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
      var _a;
      const runExtra = run.extra ?? {};
      if (!runExtra.runtime) {
        runExtra.runtime = {};
      }
      if (runtimeEnv) {
        for (const [k2, v2] of Object.entries(runtimeEnv)) {
          if (!runExtra.runtime[k2]) {
            runExtra.runtime[k2] = v2;
          }
        }
      }
      let child_runs;
      let parent_run_id;
      if (!excludeChildRuns) {
        child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
        parent_run_id = void 0;
      } else {
        parent_run_id = (_a = run.parent_run) == null ? void 0 : _a.id;
        child_runs = [];
      }
      const persistedRun = {
        id: run.id,
        name: run.name,
        start_time: run.start_time,
        end_time: run.end_time,
        run_type: run.run_type,
        reference_example_id: run.reference_example_id,
        extra: runExtra,
        serialized: run.serialized,
        error: run.error,
        inputs: run.inputs,
        outputs: run.outputs,
        session_name: run.project_name,
        child_runs,
        parent_run_id,
        trace_id: run.trace_id,
        dotted_order: run.dotted_order,
        tags: run.tags
      };
      return persistedRun;
    }
    async postRun(excludeChildRuns = true) {
      try {
        const runtimeEnv = await getRuntimeEnvironment();
        const runCreate = await this._convertToCreate(this, runtimeEnv, true);
        await this.client.createRun(runCreate);
        if (!excludeChildRuns) {
          warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
          for (const childRun of this.child_runs) {
            await childRun.postRun(false);
          }
        }
      } catch (error) {
        console.error(`Error in postRun for run ${this.id}:`, error);
      }
    }
    async patchRun() {
      var _a;
      try {
        const runUpdate = {
          end_time: this.end_time,
          error: this.error,
          inputs: this.inputs,
          outputs: this.outputs,
          parent_run_id: (_a = this.parent_run) == null ? void 0 : _a.id,
          reference_example_id: this.reference_example_id,
          extra: this.extra,
          events: this.events,
          dotted_order: this.dotted_order,
          trace_id: this.trace_id,
          tags: this.tags
        };
        await this.client.updateRun(this.id, runUpdate);
      } catch (error) {
        console.error(`Error in patchRun for run ${this.id}`, error);
      }
    }
    toJSON() {
      return this._convertToCreate(this, void 0, false);
    }
    static fromRunnableConfig(parentConfig, props) {
      var _a, _b, _c, _d;
      const callbackManager = parentConfig == null ? void 0 : parentConfig.callbacks;
      let parentRun;
      let projectName;
      let client;
      let tracingEnabled = isTracingEnabled$1();
      if (callbackManager) {
        const parentRunId = ((_a = callbackManager == null ? void 0 : callbackManager.getParentRunId) == null ? void 0 : _a.call(callbackManager)) ?? "";
        const langChainTracer = (_b = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _b.find((handler) => (handler == null ? void 0 : handler.name) == "langchain_tracer");
        parentRun = (_c = langChainTracer == null ? void 0 : langChainTracer.getRun) == null ? void 0 : _c.call(langChainTracer, parentRunId);
        projectName = langChainTracer == null ? void 0 : langChainTracer.projectName;
        client = langChainTracer == null ? void 0 : langChainTracer.client;
        tracingEnabled = tracingEnabled || !!langChainTracer;
      }
      if (!parentRun) {
        return new RunTree({
          ...props,
          client,
          tracingEnabled,
          project_name: projectName
        });
      }
      const parentRunTree = new RunTree({
        name: parentRun.name,
        id: parentRun.id,
        trace_id: parentRun.trace_id,
        dotted_order: parentRun.dotted_order,
        client,
        tracingEnabled,
        project_name: projectName,
        tags: [
          ...new Set(((parentRun == null ? void 0 : parentRun.tags) ?? []).concat((parentConfig == null ? void 0 : parentConfig.tags) ?? []))
        ],
        extra: {
          metadata: {
            ...(_d = parentRun == null ? void 0 : parentRun.extra) == null ? void 0 : _d.metadata,
            ...parentConfig == null ? void 0 : parentConfig.metadata
          }
        }
      });
      return parentRunTree.createChild(props);
    }
    static fromDottedOrder(dottedOrder) {
      return this.fromHeaders({
        "langsmith-trace": dottedOrder
      });
    }
    static fromHeaders(headers, inheritArgs) {
      var _a;
      const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
        "langsmith-trace": headers.get("langsmith-trace"),
        baggage: headers.get("baggage")
      } : headers;
      const headerTrace = rawHeaders["langsmith-trace"];
      if (!headerTrace || typeof headerTrace !== "string") return void 0;
      const parentDottedOrder = headerTrace.trim();
      const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
        const [strTime, uuid] = part.split("Z");
        return {
          strTime,
          time: Date.parse(strTime + "Z"),
          uuid
        };
      });
      const traceId = parsedDottedOrder[0].uuid;
      const config = {
        ...inheritArgs,
        name: (inheritArgs == null ? void 0 : inheritArgs["name"]) ?? "parent",
        run_type: (inheritArgs == null ? void 0 : inheritArgs["run_type"]) ?? "chain",
        start_time: (inheritArgs == null ? void 0 : inheritArgs["start_time"]) ?? Date.now(),
        id: (_a = parsedDottedOrder.at(-1)) == null ? void 0 : _a.uuid,
        trace_id: traceId,
        dotted_order: parentDottedOrder
      };
      if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
        const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
        config.metadata = baggage.metadata;
        config.tags = baggage.tags;
      }
      return new RunTree(config);
    }
    toHeaders(headers) {
      var _a;
      const result = {
        "langsmith-trace": this.dotted_order,
        baggage: new Baggage((_a = this.extra) == null ? void 0 : _a.metadata, this.tags).toHeader()
      };
      if (headers) {
        for (const [key, value] of Object.entries(result)) {
          headers.set(key, value);
        }
      }
      return result;
    }
  }
  Object.defineProperty(RunTree, "sharedClient", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: null
  });
  function isLangChainTracerLike(x2) {
    return typeof x2 === "object" && x2 != null && typeof x2.name === "string" && x2.name === "langchain_tracer";
  }
  function containsLangChainTracerLike(x2) {
    return Array.isArray(x2) && x2.some((callback) => isLangChainTracerLike(callback));
  }
  function isCallbackManagerLike(x2) {
    return typeof x2 === "object" && x2 != null && Array.isArray(x2.handlers);
  }
  function isRunnableConfigLike(x2) {
    var _a;
    return x2 !== void 0 && typeof x2.callbacks === "object" && (containsLangChainTracerLike((_a = x2.callbacks) == null ? void 0 : _a.handlers) || containsLangChainTracerLike(x2.callbacks));
  }
  const __version__ = "0.1.61";
  var ansiStyles = {
    exports: {}
  };
  ansiStyles.exports;
  (function(module2) {
    const ANSI_BACKGROUND_OFFSET2 = 10;
    const wrapAnsi2562 = (offset = 0) => (code2) => `\x1B[${38 + offset};5;${code2}m`;
    const wrapAnsi16m2 = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles2() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [
            0,
            0
          ],
          bold: [
            1,
            22
          ],
          dim: [
            2,
            22
          ],
          italic: [
            3,
            23
          ],
          underline: [
            4,
            24
          ],
          overline: [
            53,
            55
          ],
          inverse: [
            7,
            27
          ],
          hidden: [
            8,
            28
          ],
          strikethrough: [
            9,
            29
          ]
        },
        color: {
          black: [
            30,
            39
          ],
          red: [
            31,
            39
          ],
          green: [
            32,
            39
          ],
          yellow: [
            33,
            39
          ],
          blue: [
            34,
            39
          ],
          magenta: [
            35,
            39
          ],
          cyan: [
            36,
            39
          ],
          white: [
            37,
            39
          ],
          blackBright: [
            90,
            39
          ],
          redBright: [
            91,
            39
          ],
          greenBright: [
            92,
            39
          ],
          yellowBright: [
            93,
            39
          ],
          blueBright: [
            94,
            39
          ],
          magentaBright: [
            95,
            39
          ],
          cyanBright: [
            96,
            39
          ],
          whiteBright: [
            97,
            39
          ]
        },
        bgColor: {
          bgBlack: [
            40,
            49
          ],
          bgRed: [
            41,
            49
          ],
          bgGreen: [
            42,
            49
          ],
          bgYellow: [
            43,
            49
          ],
          bgBlue: [
            44,
            49
          ],
          bgMagenta: [
            45,
            49
          ],
          bgCyan: [
            46,
            49
          ],
          bgWhite: [
            47,
            49
          ],
          bgBlackBright: [
            100,
            49
          ],
          bgRedBright: [
            101,
            49
          ],
          bgGreenBright: [
            102,
            49
          ],
          bgYellowBright: [
            103,
            49
          ],
          bgBlueBright: [
            104,
            49
          ],
          bgMagentaBright: [
            105,
            49
          ],
          bgCyanBright: [
            106,
            49
          ],
          bgWhiteBright: [
            107,
            49
          ]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi2562();
      styles2.color.ansi16m = wrapAnsi16m2();
      styles2.bgColor.ansi256 = wrapAnsi2562(ANSI_BACKGROUND_OFFSET2);
      styles2.bgColor.ansi16m = wrapAnsi16m2(ANSI_BACKGROUND_OFFSET2);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex2) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex2.toString(16));
            if (!matches) {
              return [
                0,
                0,
                0
              ];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex2) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex2)),
          enumerable: false
        }
      });
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles2
    });
  })(ansiStyles);
  var ansiStylesExports = ansiStyles.exports;
  const styles = getDefaultExportFromCjs$1(ansiStylesExports);
  function wrap(style, text) {
    return `${style.open}${text}${style.close}`;
  }
  function tryJsonStringify(obj, fallback) {
    try {
      return JSON.stringify(obj, null, 2);
    } catch (err) {
      return fallback;
    }
  }
  function formatKVMapItem(value) {
    if (typeof value === "string") {
      return value.trim();
    }
    if (value === null || value === void 0) {
      return value;
    }
    return tryJsonStringify(value, value.toString());
  }
  function elapsed(run) {
    if (!run.end_time) return "";
    const elapsed2 = run.end_time - run.start_time;
    if (elapsed2 < 1e3) {
      return `${elapsed2}ms`;
    }
    return `${(elapsed2 / 1e3).toFixed(2)}s`;
  }
  const { color } = styles;
  class ConsoleCallbackHandler extends BaseTracer {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "console_callback_handler"
      });
    }
    persistRun(_run) {
      return Promise.resolve();
    }
    getParents(run) {
      const parents = [];
      let currentRun = run;
      while (currentRun.parent_run_id) {
        const parent = this.runMap.get(currentRun.parent_run_id);
        if (parent) {
          parents.push(parent);
          currentRun = parent;
        } else {
          break;
        }
      }
      return parents;
    }
    getBreadcrumbs(run) {
      const parents = this.getParents(run).reverse();
      const string = [
        ...parents,
        run
      ].map((parent, i2, arr2) => {
        const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
        return i2 === arr2.length - 1 ? wrap(styles.bold, name) : name;
      }).join(" > ");
      return wrap(color.grey, string);
    }
    onChainStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
    }
    onChainEnd(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
    }
    onChainError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    onLLMStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      const inputs = "prompts" in run.inputs ? {
        prompts: run.inputs.prompts.map((p2) => p2.trim())
      } : run.inputs;
      console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
    }
    onLLMEnd(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
    }
    onLLMError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    onToolStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
    }
    onToolEnd(run) {
      var _a;
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem((_a = run.outputs) == null ? void 0 : _a.output)}"`);
    }
    onToolError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    onRetrieverStart(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
    }
    onRetrieverEnd(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
    }
    onRetrieverError(run) {
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
    }
    onAgentAction(run) {
      const agentRun = run;
      const crumbs = this.getBreadcrumbs(run);
      console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
    }
  }
  class LangChainTracer extends BaseTracer {
    constructor(fields = {}) {
      super(fields);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "langchain_tracer"
      });
      Object.defineProperty(this, "projectName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "exampleId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      const { exampleId, projectName, client } = fields;
      this.projectName = projectName ?? getEnvironmentVariable$1("LANGCHAIN_PROJECT") ?? getEnvironmentVariable$1("LANGCHAIN_SESSION");
      this.exampleId = exampleId;
      this.client = client ?? new Client({});
      const traceableTree = LangChainTracer.getTraceableRunTree();
      if (traceableTree) {
        this.updateFromRunTree(traceableTree);
      }
    }
    async _convertToCreate(run, example_id = void 0) {
      return {
        ...run,
        extra: {
          ...run.extra,
          runtime: await getRuntimeEnvironment$1()
        },
        child_runs: void 0,
        session_name: this.projectName,
        reference_example_id: run.parent_run_id ? void 0 : example_id
      };
    }
    async persistRun(_run) {
    }
    async onRunCreate(run) {
      const persistedRun = await this._convertToCreate(run, this.exampleId);
      await this.client.createRun(persistedRun);
    }
    async onRunUpdate(run) {
      const runUpdate = {
        end_time: run.end_time,
        error: run.error,
        outputs: run.outputs,
        events: run.events,
        inputs: run.inputs,
        trace_id: run.trace_id,
        dotted_order: run.dotted_order,
        parent_run_id: run.parent_run_id
      };
      await this.client.updateRun(run.id, runUpdate);
    }
    getRun(id2) {
      return this.runMap.get(id2);
    }
    updateFromRunTree(runTree) {
      let rootRun = runTree;
      const visited = /* @__PURE__ */ new Set();
      while (rootRun.parent_run) {
        if (visited.has(rootRun.id)) break;
        visited.add(rootRun.id);
        if (!rootRun.parent_run) break;
        rootRun = rootRun.parent_run;
      }
      visited.clear();
      const queue2 = [
        rootRun
      ];
      while (queue2.length > 0) {
        const current = queue2.shift();
        if (!current || visited.has(current.id)) continue;
        visited.add(current.id);
        this.runMap.set(current.id, current);
        if (current.child_runs) {
          queue2.push(...current.child_runs);
        }
      }
      this.client = runTree.client ?? this.client;
      this.projectName = runTree.project_name ?? this.projectName;
      this.exampleId = runTree.reference_example_id ?? this.exampleId;
    }
    convertToRunTree(id2) {
      const runTreeMap = {};
      const runTreeList = [];
      for (const [id3, run] of this.runMap) {
        const runTree = new RunTree({
          ...run,
          child_runs: [],
          parent_run: void 0,
          client: this.client,
          project_name: this.projectName,
          reference_example_id: this.exampleId,
          tracingEnabled: true
        });
        runTreeMap[id3] = runTree;
        runTreeList.push([
          id3,
          run.dotted_order
        ]);
      }
      runTreeList.sort((a, b) => {
        if (!a[1] || !b[1]) return 0;
        return a[1].localeCompare(b[1]);
      });
      for (const [id3] of runTreeList) {
        const run = this.runMap.get(id3);
        const runTree = runTreeMap[id3];
        if (!run || !runTree) continue;
        if (run.parent_run_id) {
          const parentRunTree = runTreeMap[run.parent_run_id];
          if (parentRunTree) {
            parentRunTree.child_runs.push(runTree);
            runTree.parent_run = parentRunTree;
          }
        }
      }
      return runTreeMap[id2];
    }
    static getTraceableRunTree() {
      try {
        return getCurrentRunTree();
      } catch {
        return void 0;
      }
    }
  }
  let queue;
  function createQueue() {
    const PQueue2 = "default" in _default ? _default.default : _default;
    return new PQueue2({
      autoStart: true,
      concurrency: 1
    });
  }
  async function consumeCallback(promiseFn, wait) {
    if (wait === true) {
      await promiseFn();
    } else {
      if (typeof queue === "undefined") {
        queue = createQueue();
      }
      void queue.add(promiseFn);
    }
  }
  const isTracingEnabled = (tracingEnabled) => {
    const envVars = [
      "LANGSMITH_TRACING_V2",
      "LANGCHAIN_TRACING_V2",
      "LANGSMITH_TRACING",
      "LANGCHAIN_TRACING"
    ];
    return !!envVars.find((envVar) => getEnvironmentVariable$1(envVar) === "true");
  };
  function parseCallbackConfigArg(arg) {
    if (!arg) {
      return {};
    } else if (Array.isArray(arg) || "name" in arg) {
      return {
        callbacks: arg
      };
    } else {
      return arg;
    }
  }
  class BaseCallbackManager {
    setHandler(handler) {
      return this.setHandlers([
        handler
      ]);
    }
  }
  class BaseRunManager {
    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
      Object.defineProperty(this, "runId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: runId
      });
      Object.defineProperty(this, "handlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: handlers
      });
      Object.defineProperty(this, "inheritableHandlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: inheritableHandlers
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: tags
      });
      Object.defineProperty(this, "inheritableTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: inheritableTags
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: metadata
      });
      Object.defineProperty(this, "inheritableMetadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: inheritableMetadata
      });
      Object.defineProperty(this, "_parentRunId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _parentRunId
      });
    }
    get parentRunId() {
      return this._parentRunId;
    }
    async handleText(text) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        try {
          await ((_a = handler.handleText) == null ? void 0 : _a.call(handler, text, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        try {
          await ((_a = handler.handleCustomEvent) == null ? void 0 : _a.call(handler, eventName, data, this.runId, this.tags, this.metadata));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForRetrieverRun extends BaseRunManager {
    getChild(tag) {
      const manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([
          tag
        ], false);
      }
      return manager;
    }
    async handleRetrieverEnd(documents2) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreRetriever) {
          try {
            await ((_a = handler.handleRetrieverEnd) == null ? void 0 : _a.call(handler, documents2, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleRetrieverError(err) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreRetriever) {
          try {
            await ((_a = handler.handleRetrieverError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
          } catch (error) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForLLMRun extends BaseRunManager {
    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreLLM) {
          try {
            await ((_a = handler.handleLLMNewToken) == null ? void 0 : _a.call(handler, token, idx ?? {
              prompt: 0,
              completion: 0
            }, this.runId, this._parentRunId, this.tags, fields));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleLLMError(err) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreLLM) {
          try {
            await ((_a = handler.handleLLMError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
          } catch (err2) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err2}`);
            if (handler.raiseError) {
              throw err2;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleLLMEnd(output) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreLLM) {
          try {
            await ((_a = handler.handleLLMEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForChainRun extends BaseRunManager {
    getChild(tag) {
      const manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([
          tag
        ], false);
      }
      return manager;
    }
    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreChain) {
          try {
            await ((_a = handler.handleChainError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags, kwargs));
          } catch (err2) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err2}`);
            if (handler.raiseError) {
              throw err2;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreChain) {
          try {
            await ((_a = handler.handleChainEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags, kwargs));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleAgentAction(action) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreAgent) {
          try {
            await ((_a = handler.handleAgentAction) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleAgentEnd(action) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreAgent) {
          try {
            await ((_a = handler.handleAgentEnd) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManagerForToolRun extends BaseRunManager {
    getChild(tag) {
      const manager = new CallbackManager(this.runId);
      manager.setHandlers(this.inheritableHandlers);
      manager.addTags(this.inheritableTags);
      manager.addMetadata(this.inheritableMetadata);
      if (tag) {
        manager.addTags([
          tag
        ], false);
      }
      return manager;
    }
    async handleToolError(err) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreAgent) {
          try {
            await ((_a = handler.handleToolError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
          } catch (err2) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err2}`);
            if (handler.raiseError) {
              throw err2;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    async handleToolEnd(output) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreAgent) {
          try {
            await ((_a = handler.handleToolEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
  }
  class CallbackManager extends BaseCallbackManager {
    constructor(parentRunId, options) {
      super();
      Object.defineProperty(this, "handlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "inheritableHandlers", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "inheritableTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "inheritableMetadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "callback_manager"
      });
      Object.defineProperty(this, "_parentRunId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.handlers = (options == null ? void 0 : options.handlers) ?? this.handlers;
      this.inheritableHandlers = (options == null ? void 0 : options.inheritableHandlers) ?? this.inheritableHandlers;
      this.tags = (options == null ? void 0 : options.tags) ?? this.tags;
      this.inheritableTags = (options == null ? void 0 : options.inheritableTags) ?? this.inheritableTags;
      this.metadata = (options == null ? void 0 : options.metadata) ?? this.metadata;
      this.inheritableMetadata = (options == null ? void 0 : options.inheritableMetadata) ?? this.inheritableMetadata;
      this._parentRunId = parentRunId;
    }
    getParentRunId() {
      return this._parentRunId;
    }
    async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      return Promise.all(prompts.map(async (prompt, idx) => {
        const runId_ = idx === 0 && runId ? runId : v4();
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreLLM) {
            return;
          }
          if (isBaseTracer(handler)) {
            handler._createRunForLLMStart(llm, [
              prompt
            ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
          }
          return consumeCallback(async () => {
            var _a;
            try {
              await ((_a = handler.handleLLMStart) == null ? void 0 : _a.call(handler, llm, [
                prompt
              ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
              if (handler.raiseError) {
                throw err;
              }
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }));
    }
    async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      return Promise.all(messages.map(async (messageGroup, idx) => {
        const runId_ = idx === 0 && runId ? runId : v4();
        await Promise.all(this.handlers.map((handler) => {
          if (handler.ignoreLLM) {
            return;
          }
          if (isBaseTracer(handler)) {
            handler._createRunForChatModelStart(llm, [
              messageGroup
            ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
          }
          return consumeCallback(async () => {
            var _a, _b;
            try {
              if (handler.handleChatModelStart) {
                await ((_a = handler.handleChatModelStart) == null ? void 0 : _a.call(handler, llm, [
                  messageGroup
                ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
              } else if (handler.handleLLMStart) {
                const messageString = getBufferString(messageGroup);
                await ((_b = handler.handleLLMStart) == null ? void 0 : _b.call(handler, llm, [
                  messageString
                ], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
              }
            } catch (err) {
              const logFunction = handler.raiseError ? console.error : console.warn;
              logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
              if (handler.raiseError) {
                throw err;
              }
            }
          }, handler.awaitHandlers);
        }));
        return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
      }));
    }
    async handleChainStart(chain, inputs, runId = v4(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreChain) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
        }
        return consumeCallback(async () => {
          var _a;
          try {
            await ((_a = handler.handleChainStart) == null ? void 0 : _a.call(handler, chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }
    async handleToolStart(tool, input, runId = v4(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreAgent) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          var _a;
          try {
            await ((_a = handler.handleToolStart) == null ? void 0 : _a.call(handler, tool, input, runId, this._parentRunId, this.tags, this.metadata, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }
    async handleRetrieverStart(retriever, query, runId = v4(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreRetriever) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          var _a;
          try {
            await ((_a = handler.handleRetrieverStart) == null ? void 0 : _a.call(handler, retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }
    async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreCustomEvent) {
          try {
            await ((_a = handler.handleCustomEvent) == null ? void 0 : _a.call(handler, eventName, data, runId, this.tags, this.metadata));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }
      }, handler.awaitHandlers)));
    }
    addHandler(handler, inherit = true) {
      this.handlers.push(handler);
      if (inherit) {
        this.inheritableHandlers.push(handler);
      }
    }
    removeHandler(handler) {
      this.handlers = this.handlers.filter((_handler) => _handler !== handler);
      this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
    }
    setHandlers(handlers, inherit = true) {
      this.handlers = [];
      this.inheritableHandlers = [];
      for (const handler of handlers) {
        this.addHandler(handler, inherit);
      }
    }
    addTags(tags, inherit = true) {
      this.removeTags(tags);
      this.tags.push(...tags);
      if (inherit) {
        this.inheritableTags.push(...tags);
      }
    }
    removeTags(tags) {
      this.tags = this.tags.filter((tag) => !tags.includes(tag));
      this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
    }
    addMetadata(metadata, inherit = true) {
      this.metadata = {
        ...this.metadata,
        ...metadata
      };
      if (inherit) {
        this.inheritableMetadata = {
          ...this.inheritableMetadata,
          ...metadata
        };
      }
    }
    removeMetadata(metadata) {
      for (const key of Object.keys(metadata)) {
        delete this.metadata[key];
        delete this.inheritableMetadata[key];
      }
    }
    copy(additionalHandlers = [], inherit = true) {
      const manager = new CallbackManager(this._parentRunId);
      for (const handler of this.handlers) {
        const inheritable = this.inheritableHandlers.includes(handler);
        manager.addHandler(handler, inheritable);
      }
      for (const tag of this.tags) {
        const inheritable = this.inheritableTags.includes(tag);
        manager.addTags([
          tag
        ], inheritable);
      }
      for (const key of Object.keys(this.metadata)) {
        const inheritable = Object.keys(this.inheritableMetadata).includes(key);
        manager.addMetadata({
          [key]: this.metadata[key]
        }, inheritable);
      }
      for (const handler of additionalHandlers) {
        if (manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)) {
          continue;
        }
        manager.addHandler(handler, inherit);
      }
      return manager;
    }
    static fromHandlers(handlers) {
      class Handler extends BaseCallbackHandler {
        constructor() {
          super();
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: v4()
          });
          Object.assign(this, handlers);
        }
      }
      const manager = new this();
      manager.addHandler(new Handler());
      return manager;
    }
    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
      return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
    }
    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
      var _a, _b;
      let callbackManager;
      if (inheritableHandlers || localHandlers) {
        if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
          callbackManager = new CallbackManager();
          callbackManager.setHandlers((inheritableHandlers == null ? void 0 : inheritableHandlers.map(ensureHandler)) ?? [], true);
        } else {
          callbackManager = inheritableHandlers;
        }
        callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers == null ? void 0 : localHandlers.handlers, false);
      }
      const verboseEnabled = getEnvironmentVariable$1("LANGCHAIN_VERBOSE") === "true" || (options == null ? void 0 : options.verbose);
      const tracingV2Enabled = ((_a = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _a.tracingEnabled) || isTracingEnabled();
      const tracingEnabled = tracingV2Enabled || (getEnvironmentVariable$1("LANGCHAIN_TRACING") ?? false);
      if (verboseEnabled || tracingEnabled) {
        if (!callbackManager) {
          callbackManager = new CallbackManager();
        }
        if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
          const consoleHandler = new ConsoleCallbackHandler();
          callbackManager.addHandler(consoleHandler, true);
        }
        if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
          if (tracingV2Enabled) {
            const tracerV2 = new LangChainTracer();
            callbackManager.addHandler(tracerV2, true);
            callbackManager._parentRunId = ((_b = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _b.id) ?? callbackManager._parentRunId;
          }
        }
      }
      if (inheritableTags || localTags) {
        if (callbackManager) {
          callbackManager.addTags(inheritableTags ?? []);
          callbackManager.addTags(localTags ?? [], false);
        }
      }
      if (inheritableMetadata || localMetadata) {
        if (callbackManager) {
          callbackManager.addMetadata(inheritableMetadata ?? {});
          callbackManager.addMetadata(localMetadata ?? {}, false);
        }
      }
      return callbackManager;
    }
  }
  function ensureHandler(handler) {
    if ("name" in handler) {
      return handler;
    }
    return BaseCallbackHandler.fromMethods(handler);
  }
  class MockAsyncLocalStorage {
    getStore() {
      return void 0;
    }
    run(_store, callback) {
      return callback();
    }
  }
  const mockAsyncLocalStorage = new MockAsyncLocalStorage();
  const TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
  const LC_CHILD_KEY = Symbol.for("lc:child_config");
  class AsyncLocalStorageProvider {
    getInstance() {
      return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;
    }
    getRunnableConfig() {
      var _a, _b;
      const storage = this.getInstance();
      return (_b = (_a = storage.getStore()) == null ? void 0 : _a.extra) == null ? void 0 : _b[LC_CHILD_KEY];
    }
    runWithConfig(config, callback, avoidCreatingRootRunTree) {
      var _a;
      const callbackManager = CallbackManager._configureSync(config == null ? void 0 : config.callbacks, void 0, config == null ? void 0 : config.tags, void 0, config == null ? void 0 : config.metadata);
      const storage = this.getInstance();
      const parentRunId = callbackManager == null ? void 0 : callbackManager.getParentRunId();
      const langChainTracer = (_a = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _a.find((handler) => (handler == null ? void 0 : handler.name) === "langchain_tracer");
      let runTree;
      if (langChainTracer && parentRunId) {
        runTree = langChainTracer.convertToRunTree(parentRunId);
      } else if (!avoidCreatingRootRunTree) {
        runTree = new RunTree({
          name: "<runnable_lambda>",
          tracingEnabled: false
        });
      }
      if (runTree) {
        runTree.extra = {
          ...runTree.extra,
          [LC_CHILD_KEY]: config
        };
      }
      return storage.run(runTree, callback);
    }
    initializeGlobalInstance(instance2) {
      if (globalThis[TRACING_ALS_KEY] === void 0) {
        globalThis[TRACING_ALS_KEY] = instance2;
      }
    }
  }
  const AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
  async function raceWithSignal(promise, signal) {
    if (signal === void 0) {
      return promise;
    }
    let listener;
    return Promise.race([
      promise.catch((err) => {
        if (!(signal == null ? void 0 : signal.aborted)) {
          throw err;
        } else {
          return void 0;
        }
      }),
      new Promise((_, reject) => {
        listener = () => {
          reject(new Error("Aborted"));
        };
        signal.addEventListener("abort", listener);
        if (signal.aborted) {
          reject(new Error("Aborted"));
        }
      })
    ]).finally(() => signal.removeEventListener("abort", listener));
  }
  class IterableReadableStream extends ReadableStream {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "reader", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
    }
    ensureReader() {
      if (!this.reader) {
        this.reader = this.getReader();
      }
    }
    async next() {
      this.ensureReader();
      try {
        const result = await this.reader.read();
        if (result.done) {
          this.reader.releaseLock();
          return {
            done: true,
            value: void 0
          };
        } else {
          return {
            done: false,
            value: result.value
          };
        }
      } catch (e) {
        this.reader.releaseLock();
        throw e;
      }
    }
    async return() {
      this.ensureReader();
      if (this.locked) {
        const cancelPromise = this.reader.cancel();
        this.reader.releaseLock();
        await cancelPromise;
      }
      return {
        done: true,
        value: void 0
      };
    }
    async throw(e) {
      this.ensureReader();
      if (this.locked) {
        const cancelPromise = this.reader.cancel();
        this.reader.releaseLock();
        await cancelPromise;
      }
      throw e;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    async [Symbol.asyncDispose]() {
      await this.return();
    }
    static fromReadableStream(stream) {
      const reader = stream.getReader();
      return new IterableReadableStream({
        start(controller) {
          return pump();
          function pump() {
            return reader.read().then(({ done, value }) => {
              if (done) {
                controller.close();
                return;
              }
              controller.enqueue(value);
              return pump();
            });
          }
        },
        cancel() {
          reader.releaseLock();
        }
      });
    }
    static fromAsyncGenerator(generator) {
      return new IterableReadableStream({
        async pull(controller) {
          const { value, done } = await generator.next();
          if (done) {
            controller.close();
          }
          controller.enqueue(value);
        },
        async cancel(reason) {
          await generator.return(reason);
        }
      });
    }
  }
  function atee(iter, length = 2) {
    const buffers = Array.from({
      length
    }, () => []);
    return buffers.map(async function* makeIter(buffer2) {
      while (true) {
        if (buffer2.length === 0) {
          const result = await iter.next();
          for (const buffer3 of buffers) {
            buffer3.push(result);
          }
        } else if (buffer2[0].done) {
          return;
        } else {
          yield buffer2.shift().value;
        }
      }
    });
  }
  function concat(first, second) {
    if (Array.isArray(first) && Array.isArray(second)) {
      return first.concat(second);
    } else if (typeof first === "string" && typeof second === "string") {
      return first + second;
    } else if (typeof first === "number" && typeof second === "number") {
      return first + second;
    } else if ("concat" in first && typeof first.concat === "function") {
      return first.concat(second);
    } else if (typeof first === "object" && typeof second === "object") {
      const chunk = {
        ...first
      };
      for (const [key, value] of Object.entries(second)) {
        if (key in chunk && !Array.isArray(chunk[key])) {
          chunk[key] = concat(chunk[key], value);
        } else {
          chunk[key] = value;
        }
      }
      return chunk;
    } else {
      throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
    }
  }
  class AsyncGeneratorWithSetup {
    constructor(params) {
      var _a;
      Object.defineProperty(this, "generator", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "setup", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "config", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "signal", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "firstResult", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "firstResultUsed", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      this.generator = params.generator;
      this.config = params.config;
      this.signal = params.signal ?? ((_a = this.config) == null ? void 0 : _a.signal);
      this.setup = new Promise((resolve, reject) => {
        void AsyncLocalStorageProviderSingleton.runWithConfig(params.config, async () => {
          this.firstResult = params.generator.next();
          if (params.startSetup) {
            this.firstResult.then(params.startSetup).then(resolve, reject);
          } else {
            this.firstResult.then((_result) => resolve(void 0), reject);
          }
        }, true);
      });
    }
    async next(...args) {
      var _a;
      (_a = this.signal) == null ? void 0 : _a.throwIfAborted();
      if (!this.firstResultUsed) {
        this.firstResultUsed = true;
        return this.firstResult;
      }
      return AsyncLocalStorageProviderSingleton.runWithConfig(this.config, this.signal ? async () => {
        return raceWithSignal(this.generator.next(...args), this.signal);
      } : async () => {
        return this.generator.next(...args);
      }, true);
    }
    async return(value) {
      return this.generator.return(value);
    }
    async throw(e) {
      return this.generator.throw(e);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    async [Symbol.asyncDispose]() {
      await this.return();
    }
  }
  async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
    const gen = new AsyncGeneratorWithSetup({
      generator,
      startSetup,
      signal
    });
    const setup = await gen.setup;
    return {
      output: to(gen, setup, ...args),
      setup
    };
  }
  class RunLogPatch {
    constructor(fields) {
      Object.defineProperty(this, "ops", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.ops = fields.ops ?? [];
    }
    concat(other) {
      const ops = this.ops.concat(other.ops);
      const states = applyPatch({}, ops);
      return new RunLog({
        ops,
        state: states[states.length - 1].newDocument
      });
    }
  }
  class RunLog extends RunLogPatch {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "state", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.state = fields.state;
    }
    concat(other) {
      const ops = this.ops.concat(other.ops);
      const states = applyPatch(this.state, other.ops);
      return new RunLog({
        ops,
        state: states[states.length - 1].newDocument
      });
    }
    static fromRunLogPatch(patch2) {
      const states = applyPatch({}, patch2.ops);
      return new RunLog({
        ops: patch2.ops,
        state: states[states.length - 1].newDocument
      });
    }
  }
  const isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
  async function _getStandardizedInputs(run, schemaFormat) {
    if (schemaFormat === "original") {
      throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
    }
    const { inputs } = run;
    if ([
      "retriever",
      "llm",
      "prompt"
    ].includes(run.run_type)) {
      return inputs;
    }
    if (Object.keys(inputs).length === 1 && (inputs == null ? void 0 : inputs.input) === "") {
      return void 0;
    }
    return inputs.input;
  }
  async function _getStandardizedOutputs(run, schemaFormat) {
    const { outputs } = run;
    if (schemaFormat === "original") {
      return outputs;
    }
    if ([
      "retriever",
      "llm",
      "prompt"
    ].includes(run.run_type)) {
      return outputs;
    }
    if (outputs !== void 0 && Object.keys(outputs).length === 1 && (outputs == null ? void 0 : outputs.output) !== void 0) {
      return outputs.output;
    }
    return outputs;
  }
  function isChatGenerationChunk(x2) {
    return x2 !== void 0 && x2.message !== void 0;
  }
  class LogStreamCallbackHandler extends BaseTracer {
    constructor(fields) {
      super({
        _awaitHandler: true,
        ...fields
      });
      Object.defineProperty(this, "autoClose", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "includeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "_schemaFormat", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "original"
      });
      Object.defineProperty(this, "rootId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "keyMapByRunId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "counterMapByRunName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "transformStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "writer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "receiveStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "log_stream_tracer"
      });
      this.autoClose = (fields == null ? void 0 : fields.autoClose) ?? true;
      this.includeNames = fields == null ? void 0 : fields.includeNames;
      this.includeTypes = fields == null ? void 0 : fields.includeTypes;
      this.includeTags = fields == null ? void 0 : fields.includeTags;
      this.excludeNames = fields == null ? void 0 : fields.excludeNames;
      this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
      this.excludeTags = fields == null ? void 0 : fields.excludeTags;
      this._schemaFormat = (fields == null ? void 0 : fields._schemaFormat) ?? this._schemaFormat;
      this.transformStream = new TransformStream();
      this.writer = this.transformStream.writable.getWriter();
      this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
    }
    [Symbol.asyncIterator]() {
      return this.receiveStream;
    }
    async persistRun(_run) {
    }
    _includeRun(run) {
      if (run.id === this.rootId) {
        return false;
      }
      const runTags = run.tags ?? [];
      let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
      if (this.includeNames !== void 0) {
        include = include || this.includeNames.includes(run.name);
      }
      if (this.includeTypes !== void 0) {
        include = include || this.includeTypes.includes(run.run_type);
      }
      if (this.includeTags !== void 0) {
        include = include || runTags.find((tag) => {
          var _a;
          return (_a = this.includeTags) == null ? void 0 : _a.includes(tag);
        }) !== void 0;
      }
      if (this.excludeNames !== void 0) {
        include = include && !this.excludeNames.includes(run.name);
      }
      if (this.excludeTypes !== void 0) {
        include = include && !this.excludeTypes.includes(run.run_type);
      }
      if (this.excludeTags !== void 0) {
        include = include && runTags.every((tag) => {
          var _a;
          return !((_a = this.excludeTags) == null ? void 0 : _a.includes(tag));
        });
      }
      return include;
    }
    async *tapOutputIterable(runId, output) {
      for await (const chunk of output) {
        if (runId !== this.rootId) {
          const key = this.keyMapByRunId[runId];
          if (key) {
            await this.writer.write(new RunLogPatch({
              ops: [
                {
                  op: "add",
                  path: `/logs/${key}/streamed_output/-`,
                  value: chunk
                }
              ]
            }));
          }
        }
        yield chunk;
      }
    }
    async onRunCreate(run) {
      var _a;
      if (this.rootId === void 0) {
        this.rootId = run.id;
        await this.writer.write(new RunLogPatch({
          ops: [
            {
              op: "replace",
              path: "",
              value: {
                id: run.id,
                name: run.name,
                type: run.run_type,
                streamed_output: [],
                final_output: void 0,
                logs: {}
              }
            }
          ]
        }));
      }
      if (!this._includeRun(run)) {
        return;
      }
      if (this.counterMapByRunName[run.name] === void 0) {
        this.counterMapByRunName[run.name] = 0;
      }
      this.counterMapByRunName[run.name] += 1;
      const count2 = this.counterMapByRunName[run.name];
      this.keyMapByRunId[run.id] = count2 === 1 ? run.name : `${run.name}:${count2}`;
      const logEntry = {
        id: run.id,
        name: run.name,
        type: run.run_type,
        tags: run.tags ?? [],
        metadata: ((_a = run.extra) == null ? void 0 : _a.metadata) ?? {},
        start_time: new Date(run.start_time).toISOString(),
        streamed_output: [],
        streamed_output_str: [],
        final_output: void 0,
        end_time: void 0
      };
      if (this._schemaFormat === "streaming_events") {
        logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
      }
      await this.writer.write(new RunLogPatch({
        ops: [
          {
            op: "add",
            path: `/logs/${this.keyMapByRunId[run.id]}`,
            value: logEntry
          }
        ]
      }));
    }
    async onRunUpdate(run) {
      try {
        const runName = this.keyMapByRunId[run.id];
        if (runName === void 0) {
          return;
        }
        const ops = [];
        if (this._schemaFormat === "streaming_events") {
          ops.push({
            op: "replace",
            path: `/logs/${runName}/inputs`,
            value: await _getStandardizedInputs(run, this._schemaFormat)
          });
        }
        ops.push({
          op: "add",
          path: `/logs/${runName}/final_output`,
          value: await _getStandardizedOutputs(run, this._schemaFormat)
        });
        if (run.end_time !== void 0) {
          ops.push({
            op: "add",
            path: `/logs/${runName}/end_time`,
            value: new Date(run.end_time).toISOString()
          });
        }
        const patch2 = new RunLogPatch({
          ops
        });
        await this.writer.write(patch2);
      } finally {
        if (run.id === this.rootId) {
          const patch2 = new RunLogPatch({
            ops: [
              {
                op: "replace",
                path: "/final_output",
                value: await _getStandardizedOutputs(run, this._schemaFormat)
              }
            ]
          });
          await this.writer.write(patch2);
          if (this.autoClose) {
            await this.writer.close();
          }
        }
      }
    }
    async onLLMNewToken(run, token, kwargs) {
      const runName = this.keyMapByRunId[run.id];
      if (runName === void 0) {
        return;
      }
      const isChatModel = run.inputs.messages !== void 0;
      let streamedOutputValue;
      if (isChatModel) {
        if (isChatGenerationChunk(kwargs == null ? void 0 : kwargs.chunk)) {
          streamedOutputValue = kwargs == null ? void 0 : kwargs.chunk;
        } else {
          streamedOutputValue = new AIMessageChunk({
            id: `run-${run.id}`,
            content: token
          });
        }
      } else {
        streamedOutputValue = token;
      }
      const patch2 = new RunLogPatch({
        ops: [
          {
            op: "add",
            path: `/logs/${runName}/streamed_output_str/-`,
            value: token
          },
          {
            op: "add",
            path: `/logs/${runName}/streamed_output/-`,
            value: streamedOutputValue
          }
        ]
      });
      await this.writer.write(patch2);
    }
  }
  class GenerationChunk {
    constructor(fields) {
      Object.defineProperty(this, "text", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "generationInfo", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.text = fields.text;
      this.generationInfo = fields.generationInfo;
    }
    concat(chunk) {
      return new GenerationChunk({
        text: this.text + chunk.text,
        generationInfo: {
          ...this.generationInfo,
          ...chunk.generationInfo
        }
      });
    }
  }
  function assignName({ name, serialized }) {
    if (name !== void 0) {
      return name;
    }
    if ((serialized == null ? void 0 : serialized.name) !== void 0) {
      return serialized.name;
    } else if ((serialized == null ? void 0 : serialized.id) !== void 0 && Array.isArray(serialized == null ? void 0 : serialized.id)) {
      return serialized.id[serialized.id.length - 1];
    }
    return "Unnamed";
  }
  const isStreamEventsHandler = (handler) => handler.name === "event_stream_tracer";
  class EventStreamCallbackHandler extends BaseTracer {
    constructor(fields) {
      super({
        _awaitHandler: true,
        ...fields
      });
      Object.defineProperty(this, "autoClose", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "includeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "runInfoMap", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "tappedPromises", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(this, "transformStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "writer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "receiveStream", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "event_stream_tracer"
      });
      this.autoClose = (fields == null ? void 0 : fields.autoClose) ?? true;
      this.includeNames = fields == null ? void 0 : fields.includeNames;
      this.includeTypes = fields == null ? void 0 : fields.includeTypes;
      this.includeTags = fields == null ? void 0 : fields.includeTags;
      this.excludeNames = fields == null ? void 0 : fields.excludeNames;
      this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
      this.excludeTags = fields == null ? void 0 : fields.excludeTags;
      this.transformStream = new TransformStream();
      this.writer = this.transformStream.writable.getWriter();
      this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
    }
    [Symbol.asyncIterator]() {
      return this.receiveStream;
    }
    async persistRun(_run) {
    }
    _includeRun(run) {
      const runTags = run.tags ?? [];
      let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
      if (this.includeNames !== void 0) {
        include = include || this.includeNames.includes(run.name);
      }
      if (this.includeTypes !== void 0) {
        include = include || this.includeTypes.includes(run.runType);
      }
      if (this.includeTags !== void 0) {
        include = include || runTags.find((tag) => {
          var _a;
          return (_a = this.includeTags) == null ? void 0 : _a.includes(tag);
        }) !== void 0;
      }
      if (this.excludeNames !== void 0) {
        include = include && !this.excludeNames.includes(run.name);
      }
      if (this.excludeTypes !== void 0) {
        include = include && !this.excludeTypes.includes(run.runType);
      }
      if (this.excludeTags !== void 0) {
        include = include && runTags.every((tag) => {
          var _a;
          return !((_a = this.excludeTags) == null ? void 0 : _a.includes(tag));
        });
      }
      return include;
    }
    async *tapOutputIterable(runId, outputStream) {
      const firstChunk = await outputStream.next();
      if (firstChunk.done) {
        return;
      }
      const runInfo = this.runInfoMap.get(runId);
      if (runInfo === void 0) {
        yield firstChunk.value;
        return;
      }
      function _formatOutputChunk(eventType, data) {
        if (eventType === "llm" && typeof data === "string") {
          return new GenerationChunk({
            text: data
          });
        }
        return data;
      }
      let tappedPromise = this.tappedPromises.get(runId);
      if (tappedPromise === void 0) {
        let tappedPromiseResolver;
        tappedPromise = new Promise((resolve) => {
          tappedPromiseResolver = resolve;
        });
        this.tappedPromises.set(runId, tappedPromise);
        try {
          const event = {
            event: `on_${runInfo.runType}_stream`,
            run_id: runId,
            name: runInfo.name,
            tags: runInfo.tags,
            metadata: runInfo.metadata,
            data: {}
          };
          await this.send({
            ...event,
            data: {
              chunk: _formatOutputChunk(runInfo.runType, firstChunk.value)
            }
          }, runInfo);
          yield firstChunk.value;
          for await (const chunk of outputStream) {
            if (runInfo.runType !== "tool" && runInfo.runType !== "retriever") {
              await this.send({
                ...event,
                data: {
                  chunk: _formatOutputChunk(runInfo.runType, chunk)
                }
              }, runInfo);
            }
            yield chunk;
          }
        } finally {
          tappedPromiseResolver();
        }
      } else {
        yield firstChunk.value;
        for await (const chunk of outputStream) {
          yield chunk;
        }
      }
    }
    async send(payload, run) {
      if (this._includeRun(run)) {
        await this.writer.write(payload);
      }
    }
    async sendEndEvent(payload, run) {
      const tappedPromise = this.tappedPromises.get(payload.run_id);
      if (tappedPromise !== void 0) {
        void tappedPromise.then(() => {
          void this.send(payload, run);
        });
      } else {
        await this.send(payload, run);
      }
    }
    async onLLMStart(run) {
      var _a, _b;
      const runName = assignName(run);
      const runType = run.inputs.messages !== void 0 ? "chat_model" : "llm";
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a = run.extra) == null ? void 0 : _a.metadata) ?? {},
        name: runName,
        runType,
        inputs: run.inputs
      };
      this.runInfoMap.set(run.id, runInfo);
      const eventName = `on_${runType}_start`;
      await this.send({
        event: eventName,
        data: {
          input: run.inputs
        },
        name: runName,
        tags: run.tags ?? [],
        run_id: run.id,
        metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
      }, runInfo);
    }
    async onLLMNewToken(run, token, kwargs) {
      const runInfo = this.runInfoMap.get(run.id);
      let chunk;
      let eventName;
      if (runInfo === void 0) {
        throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
      }
      if (this.runInfoMap.size === 1) {
        return;
      }
      if (runInfo.runType === "chat_model") {
        eventName = "on_chat_model_stream";
        if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) {
          chunk = new AIMessageChunk({
            content: token,
            id: `run-${run.id}`
          });
        } else {
          chunk = kwargs.chunk.message;
        }
      } else if (runInfo.runType === "llm") {
        eventName = "on_llm_stream";
        if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) {
          chunk = new GenerationChunk({
            text: token
          });
        } else {
          chunk = kwargs.chunk;
        }
      } else {
        throw new Error(`Unexpected run type ${runInfo.runType}`);
      }
      await this.send({
        event: eventName,
        data: {
          chunk
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async onLLMEnd(run) {
      var _a, _b, _c;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      let eventName;
      if (runInfo === void 0) {
        throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
      }
      const generations = (_a = run.outputs) == null ? void 0 : _a.generations;
      let output;
      if (runInfo.runType === "chat_model") {
        for (const generation of generations ?? []) {
          if (output !== void 0) {
            break;
          }
          output = (_b = generation[0]) == null ? void 0 : _b.message;
        }
        eventName = "on_chat_model_end";
      } else if (runInfo.runType === "llm") {
        output = {
          generations: generations == null ? void 0 : generations.map((generation) => {
            return generation.map((chunk) => {
              return {
                text: chunk.text,
                generationInfo: chunk.generationInfo
              };
            });
          }),
          llmOutput: ((_c = run.outputs) == null ? void 0 : _c.llmOutput) ?? {}
        };
        eventName = "on_llm_end";
      } else {
        throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
      }
      await this.sendEndEvent({
        event: eventName,
        data: {
          output,
          input: runInfo.inputs
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async onChainStart(run) {
      var _a, _b;
      const runName = assignName(run);
      const runType = run.run_type ?? "chain";
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a = run.extra) == null ? void 0 : _a.metadata) ?? {},
        name: runName,
        runType: run.run_type
      };
      let eventData = {};
      if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
        eventData = {};
        runInfo.inputs = {};
      } else if (run.inputs.input !== void 0) {
        eventData.input = run.inputs.input;
        runInfo.inputs = run.inputs.input;
      } else {
        eventData.input = run.inputs;
        runInfo.inputs = run.inputs;
      }
      this.runInfoMap.set(run.id, runInfo);
      await this.send({
        event: `on_${runType}_start`,
        data: eventData,
        name: runName,
        tags: run.tags ?? [],
        run_id: run.id,
        metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
      }, runInfo);
    }
    async onChainEnd(run) {
      var _a;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      if (runInfo === void 0) {
        throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
      }
      const eventName = `on_${run.run_type}_end`;
      const inputs = run.inputs ?? runInfo.inputs ?? {};
      const outputs = ((_a = run.outputs) == null ? void 0 : _a.output) ?? run.outputs;
      const data = {
        output: outputs,
        input: inputs
      };
      if (inputs.input && Object.keys(inputs).length === 1) {
        data.input = inputs.input;
        runInfo.inputs = inputs.input;
      }
      await this.sendEndEvent({
        event: eventName,
        data,
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata ?? {}
      }, runInfo);
    }
    async onToolStart(run) {
      var _a, _b;
      const runName = assignName(run);
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a = run.extra) == null ? void 0 : _a.metadata) ?? {},
        name: runName,
        runType: "tool",
        inputs: run.inputs ?? {}
      };
      this.runInfoMap.set(run.id, runInfo);
      await this.send({
        event: "on_tool_start",
        data: {
          input: run.inputs ?? {}
        },
        name: runName,
        run_id: run.id,
        tags: run.tags ?? [],
        metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
      }, runInfo);
    }
    async onToolEnd(run) {
      var _a;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      if (runInfo === void 0) {
        throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
      }
      if (runInfo.inputs === void 0) {
        throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
      }
      const output = ((_a = run.outputs) == null ? void 0 : _a.output) === void 0 ? run.outputs : run.outputs.output;
      await this.sendEndEvent({
        event: "on_tool_end",
        data: {
          output,
          input: runInfo.inputs
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async onRetrieverStart(run) {
      var _a, _b;
      const runName = assignName(run);
      const runType = "retriever";
      const runInfo = {
        tags: run.tags ?? [],
        metadata: ((_a = run.extra) == null ? void 0 : _a.metadata) ?? {},
        name: runName,
        runType,
        inputs: {
          query: run.inputs.query
        }
      };
      this.runInfoMap.set(run.id, runInfo);
      await this.send({
        event: "on_retriever_start",
        data: {
          input: {
            query: run.inputs.query
          }
        },
        name: runName,
        tags: run.tags ?? [],
        run_id: run.id,
        metadata: ((_b = run.extra) == null ? void 0 : _b.metadata) ?? {}
      }, runInfo);
    }
    async onRetrieverEnd(run) {
      var _a;
      const runInfo = this.runInfoMap.get(run.id);
      this.runInfoMap.delete(run.id);
      if (runInfo === void 0) {
        throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
      }
      await this.sendEndEvent({
        event: "on_retriever_end",
        data: {
          output: ((_a = run.outputs) == null ? void 0 : _a.documents) ?? run.outputs,
          input: runInfo.inputs
        },
        run_id: run.id,
        name: runInfo.name,
        tags: runInfo.tags,
        metadata: runInfo.metadata
      }, runInfo);
    }
    async handleCustomEvent(eventName, data, runId) {
      const runInfo = this.runInfoMap.get(runId);
      if (runInfo === void 0) {
        throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
      }
      await this.send({
        event: "on_custom_event",
        run_id: runId,
        name: eventName,
        tags: runInfo.tags,
        metadata: runInfo.metadata,
        data
      }, runInfo);
    }
    async finish() {
      const pendingPromises = [
        ...this.tappedPromises.values()
      ];
      void Promise.all(pendingPromises).finally(() => {
        void this.writer.close();
      });
    }
  }
  const DEFAULT_RECURSION_LIMIT = 25;
  async function getCallbackManagerForConfig(config) {
    return CallbackManager._configureSync(config == null ? void 0 : config.callbacks, void 0, config == null ? void 0 : config.tags, void 0, config == null ? void 0 : config.metadata);
  }
  function mergeConfigs(...configs) {
    const copy2 = {};
    for (const options of configs.filter((c) => !!c)) {
      for (const key of Object.keys(options)) {
        if (key === "metadata") {
          copy2[key] = {
            ...copy2[key],
            ...options[key]
          };
        } else if (key === "tags") {
          const baseKeys = copy2[key] ?? [];
          copy2[key] = [
            ...new Set(baseKeys.concat(options[key] ?? []))
          ];
        } else if (key === "configurable") {
          copy2[key] = {
            ...copy2[key],
            ...options[key]
          };
        } else if (key === "timeout") {
          if (copy2.timeout === void 0) {
            copy2.timeout = options.timeout;
          } else if (options.timeout !== void 0) {
            copy2.timeout = Math.min(copy2.timeout, options.timeout);
          }
        } else if (key === "signal") {
          if (copy2.signal === void 0) {
            copy2.signal = options.signal;
          } else if (options.signal !== void 0) {
            if ("any" in AbortSignal) {
              copy2.signal = AbortSignal.any([
                copy2.signal,
                options.signal
              ]);
            } else {
              copy2.signal = options.signal;
            }
          }
        } else if (key === "callbacks") {
          const baseCallbacks = copy2.callbacks;
          const providedCallbacks = options.callbacks;
          if (Array.isArray(providedCallbacks)) {
            if (!baseCallbacks) {
              copy2.callbacks = providedCallbacks;
            } else if (Array.isArray(baseCallbacks)) {
              copy2.callbacks = baseCallbacks.concat(providedCallbacks);
            } else {
              const manager = baseCallbacks.copy();
              for (const callback of providedCallbacks) {
                manager.addHandler(ensureHandler(callback), true);
              }
              copy2.callbacks = manager;
            }
          } else if (providedCallbacks) {
            if (!baseCallbacks) {
              copy2.callbacks = providedCallbacks;
            } else if (Array.isArray(baseCallbacks)) {
              const manager = providedCallbacks.copy();
              for (const callback of baseCallbacks) {
                manager.addHandler(ensureHandler(callback), true);
              }
              copy2.callbacks = manager;
            } else {
              copy2.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
                handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
                tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
                inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
                metadata: {
                  ...baseCallbacks.metadata,
                  ...providedCallbacks.metadata
                }
              });
            }
          }
        } else {
          const typedKey = key;
          copy2[typedKey] = options[typedKey] ?? copy2[typedKey];
        }
      }
    }
    return copy2;
  }
  const PRIMITIVES = /* @__PURE__ */ new Set([
    "string",
    "number",
    "boolean"
  ]);
  function ensureConfig(config) {
    var _a;
    const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();
    let empty2 = {
      tags: [],
      metadata: {},
      recursionLimit: 25,
      runId: void 0
    };
    if (implicitConfig) {
      const { runId, runName, ...rest } = implicitConfig;
      empty2 = Object.entries(rest).reduce((currentConfig, [key, value]) => {
        if (value !== void 0) {
          currentConfig[key] = value;
        }
        return currentConfig;
      }, empty2);
    }
    if (config) {
      empty2 = Object.entries(config).reduce((currentConfig, [key, value]) => {
        if (value !== void 0) {
          currentConfig[key] = value;
        }
        return currentConfig;
      }, empty2);
    }
    if (empty2 == null ? void 0 : empty2.configurable) {
      for (const key of Object.keys(empty2.configurable)) {
        if (PRIMITIVES.has(typeof empty2.configurable[key]) && !((_a = empty2.metadata) == null ? void 0 : _a[key])) {
          if (!empty2.metadata) {
            empty2.metadata = {};
          }
          empty2.metadata[key] = empty2.configurable[key];
        }
      }
    }
    if (empty2.timeout !== void 0) {
      if (empty2.timeout <= 0) {
        throw new Error("Timeout must be a positive number");
      }
      const timeoutSignal = AbortSignal.timeout(empty2.timeout);
      if (empty2.signal !== void 0) {
        if ("any" in AbortSignal) {
          empty2.signal = AbortSignal.any([
            empty2.signal,
            timeoutSignal
          ]);
        }
      } else {
        empty2.signal = timeoutSignal;
      }
      delete empty2.timeout;
    }
    return empty2;
  }
  function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
    const newConfig = ensureConfig(config);
    if (callbacks !== void 0) {
      delete newConfig.runName;
      newConfig.callbacks = callbacks;
    }
    if (recursionLimit !== void 0) {
      newConfig.recursionLimit = recursionLimit;
    }
    if (maxConcurrency !== void 0) {
      newConfig.maxConcurrency = maxConcurrency;
    }
    if (runName !== void 0) {
      newConfig.runName = runName;
    }
    if (configurable !== void 0) {
      newConfig.configurable = {
        ...newConfig.configurable,
        ...configurable
      };
    }
    if (runId !== void 0) {
      delete newConfig.runId;
    }
    return newConfig;
  }
  const STATUS_NO_RETRY = [
    400,
    401,
    402,
    403,
    404,
    405,
    406,
    407,
    409
  ];
  const defaultFailedAttemptHandler = (error) => {
    var _a, _b;
    if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") {
      throw error;
    }
    if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
      throw error;
    }
    const status2 = ((_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) ?? (error == null ? void 0 : error.status);
    if (status2 && STATUS_NO_RETRY.includes(+status2)) {
      throw error;
    }
    if (((_b = error == null ? void 0 : error.error) == null ? void 0 : _b.code) === "insufficient_quota") {
      const err = new Error(error == null ? void 0 : error.message);
      err.name = "InsufficientQuotaError";
      throw err;
    }
  };
  class AsyncCaller {
    constructor(params) {
      Object.defineProperty(this, "maxConcurrency", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "maxRetries", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "onFailedAttempt", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "queue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.maxConcurrency = params.maxConcurrency ?? Infinity;
      this.maxRetries = params.maxRetries ?? 6;
      this.onFailedAttempt = params.onFailedAttempt ?? defaultFailedAttemptHandler;
      const PQueue2 = "default" in _default ? _default.default : _default;
      this.queue = new PQueue2({
        concurrency: this.maxConcurrency
      });
    }
    call(callable, ...args) {
      return this.queue.add(() => pRetry$1(() => callable(...args).catch((error) => {
        if (error instanceof Error) {
          throw error;
        } else {
          throw new Error(error);
        }
      }), {
        onFailedAttempt: this.onFailedAttempt,
        retries: this.maxRetries,
        randomize: true
      }), {
        throwOnTimeout: true
      });
    }
    callWithOptions(options, callable, ...args) {
      if (options.signal) {
        return Promise.race([
          this.call(callable, ...args),
          new Promise((_, reject) => {
            var _a;
            (_a = options.signal) == null ? void 0 : _a.addEventListener("abort", () => {
              reject(new Error("AbortError"));
            });
          })
        ]);
      }
      return this.call(callable, ...args);
    }
    fetch(...args) {
      return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
    }
  }
  class RootListenersTracer extends BaseTracer {
    constructor({ config, onStart, onEnd, onError }) {
      super({
        _awaitHandler: true
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "RootListenersTracer"
      });
      Object.defineProperty(this, "rootId", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "config", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "argOnStart", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "argOnEnd", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "argOnError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.config = config;
      this.argOnStart = onStart;
      this.argOnEnd = onEnd;
      this.argOnError = onError;
    }
    persistRun(_) {
      return Promise.resolve();
    }
    async onRunCreate(run) {
      if (this.rootId) {
        return;
      }
      this.rootId = run.id;
      if (this.argOnStart) {
        await this.argOnStart(run, this.config);
      }
    }
    async onRunUpdate(run) {
      if (run.id !== this.rootId) {
        return;
      }
      if (!run.error) {
        if (this.argOnEnd) {
          await this.argOnEnd(run, this.config);
        }
      } else if (this.argOnError) {
        await this.argOnError(run, this.config);
      }
    }
  }
  function isRunnableInterface(thing) {
    return thing ? thing.lc_runnable : false;
  }
  class _RootEventFilter {
    constructor(fields) {
      Object.defineProperty(this, "includeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "includeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTypes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "excludeTags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.includeNames = fields.includeNames;
      this.includeTypes = fields.includeTypes;
      this.includeTags = fields.includeTags;
      this.excludeNames = fields.excludeNames;
      this.excludeTypes = fields.excludeTypes;
      this.excludeTags = fields.excludeTags;
    }
    includeEvent(event, rootType) {
      let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
      const eventTags = event.tags ?? [];
      if (this.includeNames !== void 0) {
        include = include || this.includeNames.includes(event.name);
      }
      if (this.includeTypes !== void 0) {
        include = include || this.includeTypes.includes(rootType);
      }
      if (this.includeTags !== void 0) {
        include = include || eventTags.some((tag) => {
          var _a;
          return (_a = this.includeTags) == null ? void 0 : _a.includes(tag);
        });
      }
      if (this.excludeNames !== void 0) {
        include = include && !this.excludeNames.includes(event.name);
      }
      if (this.excludeTypes !== void 0) {
        include = include && !this.excludeTypes.includes(rootType);
      }
      if (this.excludeTags !== void 0) {
        include = include && eventTags.every((tag) => {
          var _a;
          return !((_a = this.excludeTags) == null ? void 0 : _a.includes(tag));
        });
      }
      return include;
    }
  }
  const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
  const defaultOptions = {
    name: void 0,
    $refStrategy: "root",
    basePath: [
      "#"
    ],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref"
  };
  const getDefaultOptions = (options) => typeof options === "string" ? {
    ...defaultOptions,
    name: options
  } : {
    ...defaultOptions,
    ...options
  };
  const getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== void 0 ? [
      ..._options.basePath,
      _options.definitionPath,
      _options.name
    ] : _options.basePath;
    return {
      ..._options,
      currentPath,
      propertyPath: void 0,
      seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [
            ..._options.basePath,
            _options.definitionPath,
            name
          ],
          jsonSchema: void 0
        }
      ]))
    };
  };
  function addErrorMessage(res, key, errorMessage, refs) {
    if (!(refs == null ? void 0 : refs.errorMessages)) return;
    if (errorMessage) {
      res.errorMessage = {
        ...res.errorMessage,
        [key]: errorMessage
      };
    }
  }
  function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
  }
  function parseAnyDef() {
    return {};
  }
  function parseArrayDef(def, refs) {
    var _a, _b;
    const res = {
      type: "array"
    };
    if (((_b = (_a = def.type) == null ? void 0 : _a._def) == null ? void 0 : _b.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
      res.items = parseDef(def.type._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "items"
        ]
      });
    }
    if (def.minLength) {
      setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
      setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
      setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
      setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
  }
  function parseBigintDef(def, refs) {
    const res = {
      type: "integer",
      format: "int64"
    };
    if (!def.checks) return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function parseBooleanDef() {
    return {
      type: "boolean"
    };
  }
  function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
  }
  const parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };
  function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
      return {
        anyOf: strategy.map((item, i2) => parseDateDef(def, refs, item))
      };
    }
    switch (strategy) {
      case "string":
      case "format:date-time":
        return {
          type: "string",
          format: "date-time"
        };
      case "format:date":
        return {
          type: "string",
          format: "date"
        };
      case "integer":
        return integerDateParser(def, refs);
    }
  }
  const integerDateParser = (def, refs) => {
    const res = {
      type: "integer",
      format: "unix-time"
    };
    if (refs.target === "openApi3") {
      return res;
    }
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          break;
      }
    }
    return res;
  };
  function parseDefaultDef(_def, refs) {
    return {
      ...parseDef(_def.innerType._def, refs),
      default: _def.defaultValue()
    };
  }
  function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
  }
  function parseEnumDef(def) {
    return {
      type: "string",
      enum: def.values
    };
  }
  const isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string") return false;
    return "allOf" in type;
  };
  function parseIntersectionDef(def, refs) {
    const allOf = [
      parseDef(def.left._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          "0"
        ]
      }),
      parseDef(def.right._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "allOf",
          "1"
        ]
      })
    ].filter((x2) => !!x2);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? {
      unevaluatedProperties: false
    } : void 0;
    const mergedAllOf = [];
    allOf.forEach((schema) => {
      if (isJsonSchema7AllOfType(schema)) {
        mergedAllOf.push(...schema.allOf);
        if (schema.unevaluatedProperties === void 0) {
          unevaluatedProperties = void 0;
        }
      } else {
        let nestedSchema = schema;
        if ("additionalProperties" in schema && schema.additionalProperties === false) {
          const { additionalProperties, ...rest } = schema;
          nestedSchema = rest;
        } else {
          unevaluatedProperties = void 0;
        }
        mergedAllOf.push(nestedSchema);
      }
    });
    return mergedAllOf.length ? {
      allOf: mergedAllOf,
      ...unevaluatedProperties
    } : void 0;
  }
  function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
      return {
        type: Array.isArray(def.value) ? "array" : "object"
      };
    }
    if (refs.target === "openApi3") {
      return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [
          def.value
        ]
      };
    }
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      const: def.value
    };
  }
  let emojiRegex;
  const zodPatterns = {
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    emoji: () => {
      if (emojiRegex === void 0) {
        emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
      }
      return emojiRegex;
    },
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/
  };
  function parseStringDef(def, refs) {
    const res = {
      type: "string"
    };
    function processPattern(value) {
      return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(value) : value;
    }
    if (def.checks) {
      for (const check of def.checks) {
        switch (check.kind) {
          case "min":
            setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            break;
          case "max":
            setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "email":
            switch (refs.emailStrategy) {
              case "format:email":
                addFormat(res, "email", check.message, refs);
                break;
              case "format:idn-email":
                addFormat(res, "idn-email", check.message, refs);
                break;
              case "pattern:zod":
                addPattern(res, zodPatterns.email, check.message, refs);
                break;
            }
            break;
          case "url":
            addFormat(res, "uri", check.message, refs);
            break;
          case "uuid":
            addFormat(res, "uuid", check.message, refs);
            break;
          case "regex":
            addPattern(res, check.regex, check.message, refs);
            break;
          case "cuid":
            addPattern(res, zodPatterns.cuid, check.message, refs);
            break;
          case "cuid2":
            addPattern(res, zodPatterns.cuid2, check.message, refs);
            break;
          case "startsWith":
            addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);
            break;
          case "endsWith":
            addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);
            break;
          case "datetime":
            addFormat(res, "date-time", check.message, refs);
            break;
          case "date":
            addFormat(res, "date", check.message, refs);
            break;
          case "time":
            addFormat(res, "time", check.message, refs);
            break;
          case "duration":
            addFormat(res, "duration", check.message, refs);
            break;
          case "length":
            setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
            setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
            break;
          case "includes": {
            addPattern(res, RegExp(processPattern(check.value)), check.message, refs);
            break;
          }
          case "ip": {
            if (check.version !== "v6") {
              addFormat(res, "ipv4", check.message, refs);
            }
            if (check.version !== "v4") {
              addFormat(res, "ipv6", check.message, refs);
            }
            break;
          }
          case "emoji":
            addPattern(res, zodPatterns.emoji, check.message, refs);
            break;
          case "ulid": {
            addPattern(res, zodPatterns.ulid, check.message, refs);
            break;
          }
          case "base64": {
            switch (refs.base64Strategy) {
              case "format:binary": {
                addFormat(res, "binary", check.message, refs);
                break;
              }
              case "contentEncoding:base64": {
                setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                break;
              }
              case "pattern:zod": {
                addPattern(res, zodPatterns.base64, check.message, refs);
                break;
              }
            }
            break;
          }
          case "nanoid": {
            addPattern(res, zodPatterns.nanoid, check.message, refs);
          }
        }
      }
    }
    return res;
  }
  const escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join("");
  const addFormat = (schema, value, message, refs) => {
    var _a;
    if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x2) => x2.format))) {
      if (!schema.anyOf) {
        schema.anyOf = [];
      }
      if (schema.format) {
        schema.anyOf.push({
          format: schema.format,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: {
              format: schema.errorMessage.format
            }
          }
        });
        delete schema.format;
        if (schema.errorMessage) {
          delete schema.errorMessage.format;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.anyOf.push({
        format: value,
        ...message && refs.errorMessages && {
          errorMessage: {
            format: message
          }
        }
      });
    } else {
      setResponseValueAndErrors(schema, "format", value, message, refs);
    }
  };
  const addPattern = (schema, regex, message, refs) => {
    var _a;
    if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x2) => x2.pattern))) {
      if (!schema.allOf) {
        schema.allOf = [];
      }
      if (schema.pattern) {
        schema.allOf.push({
          pattern: schema.pattern,
          ...schema.errorMessage && refs.errorMessages && {
            errorMessage: {
              pattern: schema.errorMessage.pattern
            }
          }
        });
        delete schema.pattern;
        if (schema.errorMessage) {
          delete schema.errorMessage.pattern;
          if (Object.keys(schema.errorMessage).length === 0) {
            delete schema.errorMessage;
          }
        }
      }
      schema.allOf.push({
        pattern: processRegExp(regex, refs),
        ...message && refs.errorMessages && {
          errorMessage: {
            pattern: message
          }
        }
      });
    } else {
      setResponseValueAndErrors(schema, "pattern", processRegExp(regex, refs), message, refs);
    }
  };
  const processRegExp = (regexOrFunction, refs) => {
    var _a;
    const regex = typeof regexOrFunction === "function" ? regexOrFunction() : regexOrFunction;
    if (!refs.applyRegexFlags || !regex.flags) return regex.source;
    const flags = {
      i: regex.flags.includes("i"),
      m: regex.flags.includes("m"),
      s: regex.flags.includes("s")
    };
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i2 = 0; i2 < source.length; i2++) {
      if (isEscaped) {
        pattern += source[i2];
        isEscaped = false;
        continue;
      }
      if (flags.i) {
        if (inCharGroup) {
          if (source[i2].match(/[a-z]/)) {
            if (inCharRange) {
              pattern += source[i2];
              pattern += `${source[i2 - 2]}-${source[i2]}`.toUpperCase();
              inCharRange = false;
            } else if (source[i2 + 1] === "-" && ((_a = source[i2 + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
              pattern += source[i2];
              inCharRange = true;
            } else {
              pattern += `${source[i2]}${source[i2].toUpperCase()}`;
            }
            continue;
          }
        } else if (source[i2].match(/[a-z]/)) {
          pattern += `[${source[i2]}${source[i2].toUpperCase()}]`;
          continue;
        }
      }
      if (flags.m) {
        if (source[i2] === "^") {
          pattern += `(^|(?<=[\r
]))`;
          continue;
        } else if (source[i2] === "$") {
          pattern += `($|(?=[\r
]))`;
          continue;
        }
      }
      if (flags.s && source[i2] === ".") {
        pattern += inCharGroup ? `${source[i2]}\r
` : `[${source[i2]}\r
]`;
        continue;
      }
      pattern += source[i2];
      if (source[i2] === "\\") {
        isEscaped = true;
      } else if (inCharGroup && source[i2] === "]") {
        inCharGroup = false;
      } else if (!inCharGroup && source[i2] === "[") {
        inCharGroup = true;
      }
    }
    try {
      const regexTest = new RegExp(pattern);
    } catch {
      console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
      return regex.source;
    }
    return pattern;
  };
  function parseRecordDef(def, refs) {
    var _a, _b, _c, _d;
    if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        type: "object",
        required: def.keyType._def.values,
        properties: def.keyType._def.values.reduce((acc, key) => ({
          ...acc,
          [key]: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [
              ...refs.currentPath,
              "properties",
              key
            ]
          }) ?? {}
        }), {}),
        additionalProperties: false
      };
    }
    const schema = {
      type: "object",
      additionalProperties: parseDef(def.valueType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "additionalProperties"
        ]
      }) ?? {}
    };
    if (refs.target === "openApi3") {
      return schema;
    }
    if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
      const keyType = Object.entries(parseStringDef(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : {
        ...acc,
        [key]: value
      }, {});
      return {
        ...schema,
        propertyNames: keyType
      };
    } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
      return {
        ...schema,
        propertyNames: {
          enum: def.keyType._def.values
        }
      };
    }
    return schema;
  }
  function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
      return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items",
        "items",
        "0"
      ]
    }) || {};
    const values = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items",
        "items",
        "1"
      ]
    }) || {};
    return {
      type: "array",
      maxItems: 125,
      items: {
        type: "array",
        items: [
          keys,
          values
        ],
        minItems: 2,
        maxItems: 2
      }
    };
  }
  function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
      return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
      type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : [
        "string",
        "number"
      ],
      enum: actualValues
    };
  }
  function parseNeverDef() {
    return {
      not: {}
    };
  }
  function parseNullDef(refs) {
    return refs.target === "openApi3" ? {
      enum: [
        "null"
      ],
      nullable: true
    } : {
      type: "null"
    };
  }
  const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null"
  };
  function parseUnionDef(def, refs) {
    if (refs.target === "openApi3") return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    if (options.every((x2) => x2._def.typeName in primitiveMappings && (!x2._def.checks || !x2._def.checks.length))) {
      const types = options.reduce((types2, x2) => {
        const type = primitiveMappings[x2._def.typeName];
        return type && !types2.includes(type) ? [
          ...types2,
          type
        ] : types2;
      }, []);
      return {
        type: types.length > 1 ? types : types[0]
      };
    } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
      const types = options.reduce((acc, x2) => {
        const type = typeof x2._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [
              ...acc,
              type
            ];
          case "bigint":
            return [
              ...acc,
              "integer"
            ];
          case "object":
            if (x2._def.value === null) return [
              ...acc,
              "null"
            ];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      }, []);
      if (types.length === options.length) {
        const uniqueTypes = types.filter((x2, i2, a) => a.indexOf(x2) === i2);
        return {
          type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
          enum: options.reduce((acc, x2) => {
            return acc.includes(x2._def.value) ? acc : [
              ...acc,
              x2._def.value
            ];
          }, [])
        };
      }
    } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
      return {
        type: "string",
        enum: options.reduce((acc, x2) => [
          ...acc,
          ...x2._def.values.filter((x3) => !acc.includes(x3))
        ], [])
      };
    }
    return asAnyOf(def, refs);
  }
  const asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i2) => parseDef(x2._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "anyOf",
        `${i2}`
      ]
    })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
    return anyOf.length ? {
      anyOf
    } : void 0;
  };
  function parseNullableDef(def, refs) {
    if ([
      "ZodString",
      "ZodNumber",
      "ZodBigInt",
      "ZodBoolean",
      "ZodNull"
    ].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
      if (refs.target === "openApi3") {
        return {
          type: primitiveMappings[def.innerType._def.typeName],
          nullable: true
        };
      }
      return {
        type: [
          primitiveMappings[def.innerType._def.typeName],
          "null"
        ]
      };
    }
    if (refs.target === "openApi3") {
      const base2 = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath
        ]
      });
      if (base2 && "$ref" in base2) return {
        allOf: [
          base2
        ],
        nullable: true
      };
      return base2 && {
        ...base2,
        nullable: true
      };
    }
    const base = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "anyOf",
        "0"
      ]
    });
    return base && {
      anyOf: [
        base,
        {
          type: "null"
        }
      ]
    };
  }
  function parseNumberDef(def, refs) {
    const res = {
      type: "number"
    };
    if (!def.checks) return res;
    for (const check of def.checks) {
      switch (check.kind) {
        case "int":
          res.type = "integer";
          addErrorMessage(res, "type", check.message, refs);
          break;
        case "min":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMinimum = true;
            }
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          }
          break;
        case "max":
          if (refs.target === "jsonSchema7") {
            if (check.inclusive) {
              setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
            } else {
              setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
            }
          } else {
            if (!check.inclusive) {
              res.exclusiveMaximum = true;
            }
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          }
          break;
        case "multipleOf":
          setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
          break;
      }
    }
    return res;
  }
  function decideAdditionalProperties(def, refs) {
    if (refs.removeAdditionalStrategy === "strict") {
      return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys !== "strict" : parseDef(def.catchall._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "additionalProperties"
        ]
      }) ?? true;
    } else {
      return def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : parseDef(def.catchall._def, {
        ...refs,
        currentPath: [
          ...refs.currentPath,
          "additionalProperties"
        ]
      }) ?? true;
    }
  }
  function parseObjectDef(def, refs) {
    const result = {
      type: "object",
      ...Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
        if (propDef === void 0 || propDef._def === void 0) return acc;
        const parsedDef = parseDef(propDef._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "properties",
            propName
          ],
          propertyPath: [
            ...refs.currentPath,
            "properties",
            propName
          ]
        });
        if (parsedDef === void 0) return acc;
        return {
          properties: {
            ...acc.properties,
            [propName]: parsedDef
          },
          required: propDef.isOptional() ? acc.required : [
            ...acc.required,
            propName
          ]
        };
      }, {
        properties: {},
        required: []
      }),
      additionalProperties: decideAdditionalProperties(def, refs)
    };
    if (!result.required.length) delete result.required;
    return result;
  }
  const parseOptionalDef = (def, refs) => {
    var _a;
    if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
      return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "anyOf",
        "1"
      ]
    });
    return innerSchema ? {
      anyOf: [
        {
          not: {}
        },
        innerSchema
      ]
    } : {};
  };
  const parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
      return parseDef(def.in._def, refs);
    } else if (refs.pipeStrategy === "output") {
      return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "allOf",
        "0"
      ]
    });
    const b = parseDef(def.out._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "allOf",
        a ? "1" : "0"
      ]
    });
    return {
      allOf: [
        a,
        b
      ].filter((x2) => x2 !== void 0)
    };
  };
  function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
  }
  function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [
        ...refs.currentPath,
        "items"
      ]
    });
    const schema = {
      type: "array",
      uniqueItems: true,
      items
    };
    if (def.minSize) {
      setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
      setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
  }
  function parseTupleDef(def, refs) {
    if (def.rest) {
      return {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x2, i2) => parseDef(x2._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "items",
            `${i2}`
          ]
        })).reduce((acc, x2) => x2 === void 0 ? acc : [
          ...acc,
          x2
        ], []),
        additionalItems: parseDef(def.rest._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "additionalItems"
          ]
        })
      };
    } else {
      return {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x2, i2) => parseDef(x2._def, {
          ...refs,
          currentPath: [
            ...refs.currentPath,
            "items",
            `${i2}`
          ]
        })).reduce((acc, x2) => x2 === void 0 ? acc : [
          ...acc,
          x2
        ], [])
      };
    }
  }
  function parseUndefinedDef() {
    return {
      not: {}
    };
  }
  function parseUnknownDef() {
    return {};
  }
  const parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
  };
  function parseDef(def, refs, forceResolution = false) {
    var _a;
    const seenItem = refs.seen.get(def);
    if (refs.override) {
      const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(refs, def, refs, seenItem, forceResolution);
      if (overrideResult !== ignoreOverride) {
        return overrideResult;
      }
    }
    if (seenItem && !forceResolution) {
      const seenSchema = get$ref(seenItem, refs);
      if (seenSchema !== void 0) {
        return seenSchema;
      }
    }
    const newItem = {
      def,
      path: refs.currentPath,
      jsonSchema: void 0
    };
    refs.seen.set(def, newItem);
    const jsonSchema = selectParser(def, def.typeName, refs);
    if (jsonSchema) {
      addMeta(def, refs, jsonSchema);
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
  }
  const get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
      case "root":
        return {
          $ref: item.path.join("/")
        };
      case "relative":
        return {
          $ref: getRelativePath(refs.currentPath, item.path)
        };
      case "none":
      case "seen": {
        if (item.path.length < refs.currentPath.length && item.path.every((value, index2) => refs.currentPath[index2] === value)) {
          console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
          return {};
        }
        return refs.$refStrategy === "seen" ? {} : void 0;
      }
    }
  };
  const getRelativePath = (pathA, pathB) => {
    let i2 = 0;
    for (; i2 < pathA.length && i2 < pathB.length; i2++) {
      if (pathA[i2] !== pathB[i2]) break;
    }
    return [
      (pathA.length - i2).toString(),
      ...pathB.slice(i2)
    ].join("/");
  };
  const selectParser = (def, typeName, refs) => {
    switch (typeName) {
      case ZodFirstPartyTypeKind.ZodString:
        return parseStringDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNumber:
        return parseNumberDef(def, refs);
      case ZodFirstPartyTypeKind.ZodObject:
        return parseObjectDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBigInt:
        return parseBigintDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBoolean:
        return parseBooleanDef();
      case ZodFirstPartyTypeKind.ZodDate:
        return parseDateDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUndefined:
        return parseUndefinedDef();
      case ZodFirstPartyTypeKind.ZodNull:
        return parseNullDef(refs);
      case ZodFirstPartyTypeKind.ZodArray:
        return parseArrayDef(def, refs);
      case ZodFirstPartyTypeKind.ZodUnion:
      case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
        return parseUnionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodIntersection:
        return parseIntersectionDef(def, refs);
      case ZodFirstPartyTypeKind.ZodTuple:
        return parseTupleDef(def, refs);
      case ZodFirstPartyTypeKind.ZodRecord:
        return parseRecordDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLiteral:
        return parseLiteralDef(def, refs);
      case ZodFirstPartyTypeKind.ZodEnum:
        return parseEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNativeEnum:
        return parseNativeEnumDef(def);
      case ZodFirstPartyTypeKind.ZodNullable:
        return parseNullableDef(def, refs);
      case ZodFirstPartyTypeKind.ZodOptional:
        return parseOptionalDef(def, refs);
      case ZodFirstPartyTypeKind.ZodMap:
        return parseMapDef(def, refs);
      case ZodFirstPartyTypeKind.ZodSet:
        return parseSetDef(def, refs);
      case ZodFirstPartyTypeKind.ZodLazy:
        return parseDef(def.getter()._def, refs);
      case ZodFirstPartyTypeKind.ZodPromise:
        return parsePromiseDef(def, refs);
      case ZodFirstPartyTypeKind.ZodNaN:
      case ZodFirstPartyTypeKind.ZodNever:
        return parseNeverDef();
      case ZodFirstPartyTypeKind.ZodEffects:
        return parseEffectsDef(def, refs);
      case ZodFirstPartyTypeKind.ZodAny:
        return parseAnyDef();
      case ZodFirstPartyTypeKind.ZodUnknown:
        return parseUnknownDef();
      case ZodFirstPartyTypeKind.ZodDefault:
        return parseDefaultDef(def, refs);
      case ZodFirstPartyTypeKind.ZodBranded:
        return parseBrandedDef(def, refs);
      case ZodFirstPartyTypeKind.ZodReadonly:
        return parseReadonlyDef(def, refs);
      case ZodFirstPartyTypeKind.ZodCatch:
        return parseCatchDef(def, refs);
      case ZodFirstPartyTypeKind.ZodPipeline:
        return parsePipelineDef(def, refs);
      case ZodFirstPartyTypeKind.ZodFunction:
      case ZodFirstPartyTypeKind.ZodVoid:
      case ZodFirstPartyTypeKind.ZodSymbol:
        return void 0;
      default:
        return /* @__PURE__ */ ((_) => void 0)();
    }
  };
  const addMeta = (def, refs, jsonSchema) => {
    if (def.description) {
      jsonSchema.description = def.description;
      if (refs.markdownDescription) {
        jsonSchema.markdownDescription = def.description;
      }
    }
    return jsonSchema;
  };
  const zodToJsonSchema = (schema, options) => {
    const refs = getRefs(options);
    const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
      ...acc,
      [name2]: parseDef(schema2._def, {
        ...refs,
        currentPath: [
          ...refs.basePath,
          refs.definitionPath,
          name2
        ]
      }, true) ?? {}
    }), {}) : void 0;
    const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
    const main = parseDef(schema._def, name === void 0 ? refs : {
      ...refs,
      currentPath: [
        ...refs.basePath,
        refs.definitionPath,
        name
      ]
    }, false) ?? {};
    const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
    if (title !== void 0) {
      main.title = title;
    }
    const combined = name === void 0 ? definitions ? {
      ...main,
      [refs.definitionPath]: definitions
    } : main : {
      $ref: [
        ...refs.$refStrategy === "relative" ? [] : refs.basePath,
        refs.definitionPath,
        name
      ].join("/"),
      [refs.definitionPath]: {
        ...definitions,
        [name]: main
      }
    };
    if (refs.target === "jsonSchema7") {
      combined.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (refs.target === "jsonSchema2019-09") {
      combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    return combined;
  };
  function _escapeNodeLabel(nodeLabel) {
    return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
  }
  function _adjustMermaidEdge(edge, nodes) {
    const sourceNodeLabel = nodes[edge.source] ?? edge.source;
    const targetNodeLabel = nodes[edge.target] ?? edge.target;
    return [
      sourceNodeLabel,
      targetNodeLabel
    ];
  }
  function _generateMermaidGraphStyles(nodeColors) {
    let styles2 = "";
    for (const [className, color2] of Object.entries(nodeColors)) {
      styles2 += `	classDef ${className}class fill:${color2};
`;
    }
    return styles2;
  }
  function drawMermaid(nodes, edges, config) {
    const { firstNodeLabel, lastNodeLabel, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config ?? {};
    let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : "graph TD;\n";
    if (withStyles) {
      const defaultClassLabel = "default";
      const formatDict = {
        [defaultClassLabel]: "{0}([{1}]):::otherclass"
      };
      if (firstNodeLabel !== void 0) {
        formatDict[firstNodeLabel] = "{0}[{0}]:::startclass";
      }
      if (lastNodeLabel !== void 0) {
        formatDict[lastNodeLabel] = "{0}[{0}]:::endclass";
      }
      for (const node of Object.values(nodes)) {
        const nodeLabel = formatDict[node] ?? formatDict[defaultClassLabel];
        const escapedNodeLabel = _escapeNodeLabel(node);
        const nodeParts = node.split(":");
        const nodeSplit = nodeParts[nodeParts.length - 1];
        mermaidGraph += `	${nodeLabel.replace(/\{0\}/g, escapedNodeLabel).replace(/\{1\}/g, nodeSplit)};
`;
      }
    }
    let subgraph = "";
    for (const edge of edges) {
      const sourcePrefix = edge.source.includes(":") ? edge.source.split(":")[0] : void 0;
      const targetPrefix = edge.target.includes(":") ? edge.target.split(":")[0] : void 0;
      if (subgraph !== "" && (subgraph !== sourcePrefix || subgraph !== targetPrefix)) {
        mermaidGraph += "	end\n";
        subgraph = "";
      }
      if (subgraph === "" && sourcePrefix !== void 0 && sourcePrefix === targetPrefix) {
        mermaidGraph = `	subgraph ${sourcePrefix}
`;
        subgraph = sourcePrefix;
      }
      const [source, target] = _adjustMermaidEdge(edge, nodes);
      let edgeLabel = "";
      if (edge.data !== void 0) {
        let edgeData = edge.data;
        const words = edgeData.split(" ");
        if (words.length > wrapLabelNWords) {
          edgeData = words.reduce((acc, word, i2) => {
            if (i2 % wrapLabelNWords === 0) acc.push("");
            acc[acc.length - 1] += ` ${word}`;
            return acc;
          }, []).join("<br>");
        }
        if (edge.conditional) {
          edgeLabel = ` -. ${edgeData} .-> `;
        } else {
          edgeLabel = ` -- ${edgeData} --> `;
        }
      } else {
        if (edge.conditional) {
          edgeLabel = ` -.-> `;
        } else {
          edgeLabel = ` --> `;
        }
      }
      mermaidGraph += `	${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};
`;
    }
    if (subgraph !== "") {
      mermaidGraph += "end\n";
    }
    if (withStyles && nodeColors !== void 0) {
      mermaidGraph += _generateMermaidGraphStyles(nodeColors);
    }
    return mermaidGraph;
  }
  async function drawMermaidPng(mermaidSyntax, config) {
    let { backgroundColor = "white" } = config ?? {};
    const mermaidSyntaxEncoded = btoa(mermaidSyntax);
    if (backgroundColor !== void 0) {
      const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
      if (!hexColorPattern.test(backgroundColor)) {
        backgroundColor = `!${backgroundColor}`;
      }
    }
    const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;
    const res = await fetch(imageUrl);
    if (!res.ok) {
      throw new Error([
        `Failed to render the graph using the Mermaid.INK API.`,
        `Status code: ${res.status}`,
        `Status text: ${res.statusText}`
      ].join("\n"));
    }
    const content = await res.blob();
    return content;
  }
  const MAX_DATA_DISPLAY_NAME_LENGTH = 42;
  function nodeDataStr(node) {
    if (!validate$1(node.id)) {
      return node.id;
    } else if (isRunnableInterface(node.data)) {
      try {
        let data = node.data.getName();
        data = data.startsWith("Runnable") ? data.slice("Runnable".length) : data;
        if (data.length > MAX_DATA_DISPLAY_NAME_LENGTH) {
          data = `${data.substring(0, MAX_DATA_DISPLAY_NAME_LENGTH)}...`;
        }
        return data;
      } catch (error) {
        return node.data.getName();
      }
    } else {
      return node.data.name ?? "UnknownSchema";
    }
  }
  function nodeDataJson(node) {
    if (isRunnableInterface(node.data)) {
      return {
        type: "runnable",
        data: {
          id: node.data.lc_id,
          name: node.data.getName()
        }
      };
    } else {
      return {
        type: "schema",
        data: {
          ...zodToJsonSchema(node.data.schema),
          title: node.data.name
        }
      };
    }
  }
  class Graph {
    constructor() {
      Object.defineProperty(this, "nodes", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      Object.defineProperty(this, "edges", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
    }
    toJSON() {
      const stableNodeIds = {};
      Object.values(this.nodes).forEach((node, i2) => {
        stableNodeIds[node.id] = validate$1(node.id) ? i2 : node.id;
      });
      return {
        nodes: Object.values(this.nodes).map((node) => ({
          id: stableNodeIds[node.id],
          ...nodeDataJson(node)
        })),
        edges: this.edges.map((edge) => {
          const item = {
            source: stableNodeIds[edge.source],
            target: stableNodeIds[edge.target]
          };
          if (typeof edge.data !== "undefined") {
            item.data = edge.data;
          }
          if (typeof edge.conditional !== "undefined") {
            item.conditional = edge.conditional;
          }
          return item;
        })
      };
    }
    addNode(data, id2) {
      if (id2 !== void 0 && this.nodes[id2] !== void 0) {
        throw new Error(`Node with id ${id2} already exists`);
      }
      const nodeId = id2 || v4();
      const node = {
        id: nodeId,
        data
      };
      this.nodes[nodeId] = node;
      return node;
    }
    removeNode(node) {
      delete this.nodes[node.id];
      this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
    }
    addEdge(source, target, data, conditional) {
      if (this.nodes[source.id] === void 0) {
        throw new Error(`Source node ${source.id} not in graph`);
      }
      if (this.nodes[target.id] === void 0) {
        throw new Error(`Target node ${target.id} not in graph`);
      }
      const edge = {
        source: source.id,
        target: target.id,
        data,
        conditional
      };
      this.edges.push(edge);
      return edge;
    }
    firstNode() {
      const targets = new Set(this.edges.map((edge) => edge.target));
      const found = [];
      Object.values(this.nodes).forEach((node) => {
        if (!targets.has(node.id)) {
          found.push(node);
        }
      });
      return found[0];
    }
    lastNode() {
      const sources = new Set(this.edges.map((edge) => edge.source));
      const found = [];
      Object.values(this.nodes).forEach((node) => {
        if (!sources.has(node.id)) {
          found.push(node);
        }
      });
      return found[0];
    }
    extend(graph, prefix = "") {
      let finalPrefix = prefix;
      const nodeIds = Object.values(graph.nodes).map((node) => node.id);
      if (nodeIds.every(validate$1)) {
        finalPrefix = "";
      }
      const prefixed = (id2) => {
        return finalPrefix ? `${finalPrefix}:${id2}` : id2;
      };
      Object.entries(graph.nodes).forEach(([key, value]) => {
        this.nodes[prefixed(key)] = {
          ...value,
          id: prefixed(key)
        };
      });
      const newEdges = graph.edges.map((edge) => {
        return {
          ...edge,
          source: prefixed(edge.source),
          target: prefixed(edge.target)
        };
      });
      this.edges = [
        ...this.edges,
        ...newEdges
      ];
      const first = graph.firstNode();
      const last = graph.lastNode();
      return [
        first ? {
          id: prefixed(first.id),
          data: first.data
        } : void 0,
        last ? {
          id: prefixed(last.id),
          data: last.data
        } : void 0
      ];
    }
    trimFirstNode() {
      const firstNode = this.firstNode();
      if (firstNode) {
        const outgoingEdges = this.edges.filter((edge) => edge.source === firstNode.id);
        if (Object.keys(this.nodes).length === 1 || outgoingEdges.length === 1) {
          this.removeNode(firstNode);
        }
      }
    }
    trimLastNode() {
      const lastNode = this.lastNode();
      if (lastNode) {
        const incomingEdges = this.edges.filter((edge) => edge.target === lastNode.id);
        if (Object.keys(this.nodes).length === 1 || incomingEdges.length === 1) {
          this.removeNode(lastNode);
        }
      }
    }
    drawMermaid(params) {
      const { withStyles, curveStyle, nodeColors = {
        start: "#ffdfba",
        end: "#baffc9",
        other: "#fad7de"
      }, wrapLabelNWords } = params ?? {};
      const nodes = {};
      for (const node of Object.values(this.nodes)) {
        nodes[node.id] = nodeDataStr(node);
      }
      const firstNode = this.firstNode();
      const firstNodeLabel = firstNode ? nodeDataStr(firstNode) : void 0;
      const lastNode = this.lastNode();
      const lastNodeLabel = lastNode ? nodeDataStr(lastNode) : void 0;
      return drawMermaid(nodes, this.edges, {
        firstNodeLabel,
        lastNodeLabel,
        withStyles,
        curveStyle,
        nodeColors,
        wrapLabelNWords
      });
    }
    async drawMermaidPng(params) {
      const mermaidSyntax = this.drawMermaid(params);
      return drawMermaidPng(mermaidSyntax, {
        backgroundColor: params == null ? void 0 : params.backgroundColor
      });
    }
  }
  function convertToHttpEventStream(stream) {
    const encoder = new TextEncoder();
    const finalStream = new ReadableStream({
      async start(controller) {
        for await (const chunk of stream) {
          controller.enqueue(encoder.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
        }
        controller.enqueue(encoder.encode("event: end\n\n"));
        controller.close();
      }
    });
    return IterableReadableStream.fromReadableStream(finalStream);
  }
  function isIterableIterator(thing) {
    return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && typeof thing.next === "function";
  }
  const isIterator = (x2) => x2 != null && typeof x2 === "object" && "next" in x2 && typeof x2.next === "function";
  function isAsyncIterable(thing) {
    return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
  }
  function* consumeIteratorInContext(context, iter) {
    while (true) {
      const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(context, iter.next.bind(iter), true);
      if (done) {
        break;
      } else {
        yield value;
      }
    }
  }
  async function* consumeAsyncIterableInContext(context, iter) {
    const iterator = iter[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await AsyncLocalStorageProviderSingleton.runWithConfig(context, iterator.next.bind(iter), true);
      if (done) {
        break;
      } else {
        yield value;
      }
    }
  }
  function _coerceToDict(value, defaultKey) {
    return value && !Array.isArray(value) && !(value instanceof Date) && typeof value === "object" ? value : {
      [defaultKey]: value
    };
  }
  Runnable = class extends Serializable {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "lc_runnable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
    }
    getName(suffix) {
      const name = this.name ?? this.constructor.lc_name() ?? this.constructor.name;
      return suffix ? `${name}${suffix}` : name;
    }
    bind(kwargs) {
      return new RunnableBinding({
        bound: this,
        kwargs,
        config: {}
      });
    }
    map() {
      return new RunnableEach({
        bound: this
      });
    }
    withRetry(fields) {
      return new RunnableRetry({
        bound: this,
        kwargs: {},
        config: {},
        maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
        ...fields
      });
    }
    withConfig(config) {
      return new RunnableBinding({
        bound: this,
        config,
        kwargs: {}
      });
    }
    withFallbacks(fields) {
      const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
      return new RunnableWithFallbacks({
        runnable: this,
        fallbacks
      });
    }
    _getOptionsList(options, length = 0) {
      if (Array.isArray(options) && options.length !== length) {
        throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
      }
      if (Array.isArray(options)) {
        return options.map(ensureConfig);
      }
      if (length > 1 && !Array.isArray(options) && options.runId) {
        console.warn("Provided runId will be used only for the first element of the batch.");
        const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== "runId"));
        return Array.from({
          length
        }, (_, i2) => ensureConfig(i2 === 0 ? options : subsequent));
      }
      return Array.from({
        length
      }, () => ensureConfig(options));
    }
    async batch(inputs, options, batchOptions) {
      var _a;
      const configList = this._getOptionsList(options ?? {}, inputs.length);
      const maxConcurrency = ((_a = configList[0]) == null ? void 0 : _a.maxConcurrency) ?? (batchOptions == null ? void 0 : batchOptions.maxConcurrency);
      const caller2 = new AsyncCaller({
        maxConcurrency,
        onFailedAttempt: (e) => {
          throw e;
        }
      });
      const batchCalls = inputs.map((input, i2) => caller2.call(async () => {
        try {
          const result = await this.invoke(input, configList[i2]);
          return result;
        } catch (e) {
          if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
            return e;
          }
          throw e;
        }
      }));
      return Promise.all(batchCalls);
    }
    async *_streamIterator(input, options) {
      yield this.invoke(input, options);
    }
    async stream(input, options) {
      const config = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this._streamIterator(input, config),
        config
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
    _separateRunnableConfigFromCallOptions(options) {
      let runnableConfig;
      if (options === void 0) {
        runnableConfig = ensureConfig(options);
      } else {
        runnableConfig = ensureConfig({
          callbacks: options.callbacks,
          tags: options.tags,
          metadata: options.metadata,
          runName: options.runName,
          configurable: options.configurable,
          recursionLimit: options.recursionLimit,
          maxConcurrency: options.maxConcurrency,
          runId: options.runId,
          timeout: options.timeout,
          signal: options.signal
        });
      }
      const callOptions = {
        ...options
      };
      delete callOptions.callbacks;
      delete callOptions.tags;
      delete callOptions.metadata;
      delete callOptions.runName;
      delete callOptions.configurable;
      delete callOptions.recursionLimit;
      delete callOptions.maxConcurrency;
      delete callOptions.runId;
      delete callOptions.timeout;
      delete callOptions.signal;
      return [
        runnableConfig,
        callOptions
      ];
    }
    async _callWithConfig(func, input, options) {
      const config = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config);
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config.runId, config == null ? void 0 : config.runType, void 0, void 0, (config == null ? void 0 : config.runName) ?? this.getName()));
      delete config.runId;
      let output;
      try {
        const promise = func.call(this, input, config, runManager);
        output = await raceWithSignal(promise, options == null ? void 0 : options.signal);
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
      return output;
    }
    async _batchWithConfig(func, inputs, options, batchOptions) {
      var _a;
      const optionsList = this._getOptionsList(options ?? {}, inputs.length);
      const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
      const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
        const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), optionsList[i2].runId, optionsList[i2].runType, void 0, void 0, optionsList[i2].runName ?? this.getName()));
        delete optionsList[i2].runId;
        return handleStartRes;
      }));
      let outputs;
      try {
        const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
        outputs = await raceWithSignal(promise, (_a = optionsList == null ? void 0 : optionsList[0]) == null ? void 0 : _a.signal);
      } catch (e) {
        await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
        throw e;
      }
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs, "output"))));
      return outputs;
    }
    async *_transformStreamWithConfig(inputGenerator, transformer, options) {
      let finalInput;
      let finalInputSupported = true;
      let finalOutput;
      let finalOutputSupported = true;
      const config = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config);
      async function* wrapInputForTracing() {
        for await (const chunk of inputGenerator) {
          if (finalInputSupported) {
            if (finalInput === void 0) {
              finalInput = chunk;
            } else {
              try {
                finalInput = concat(finalInput, chunk);
              } catch {
                finalInput = void 0;
                finalInputSupported = false;
              }
            }
          }
          yield chunk;
        }
      }
      let runManager;
      try {
        const pipe2 = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {
          input: ""
        }, config.runId, config.runType, void 0, void 0, config.runName ?? this.getName()), options == null ? void 0 : options.signal, config);
        delete config.runId;
        runManager = pipe2.setup;
        const streamEventsHandler = runManager == null ? void 0 : runManager.handlers.find(isStreamEventsHandler);
        let iterator = pipe2.output;
        if (streamEventsHandler !== void 0 && runManager !== void 0) {
          iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
        }
        const streamLogHandler = runManager == null ? void 0 : runManager.handlers.find(isLogStreamHandler);
        if (streamLogHandler !== void 0 && runManager !== void 0) {
          iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
        }
        for await (const chunk of iterator) {
          yield chunk;
          if (finalOutputSupported) {
            if (finalOutput === void 0) {
              finalOutput = chunk;
            } else {
              try {
                finalOutput = concat(finalOutput, chunk);
              } catch {
                finalOutput = void 0;
                finalOutputSupported = false;
              }
            }
          }
        }
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e, void 0, void 0, void 0, {
          inputs: _coerceToDict(finalInput, "input")
        }));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(finalOutput ?? {}, void 0, void 0, void 0, {
        inputs: _coerceToDict(finalInput, "input")
      }));
    }
    getGraph(_) {
      const graph = new Graph();
      const inputNode = graph.addNode({
        name: `${this.getName()}Input`,
        schema: z.any()
      });
      const runnableNode = graph.addNode(this);
      const outputNode = graph.addNode({
        name: `${this.getName()}Output`,
        schema: z.any()
      });
      graph.addEdge(inputNode, runnableNode);
      graph.addEdge(runnableNode, outputNode);
      return graph;
    }
    pipe(coerceable) {
      return new RunnableSequence({
        first: this,
        last: _coerceToRunnable(coerceable)
      });
    }
    pick(keys) {
      return this.pipe(new RunnablePick(keys));
    }
    assign(mapping) {
      return this.pipe(new RunnableAssign(new RunnableMap({
        steps: mapping
      })));
    }
    async *transform(generator, options) {
      let finalChunk;
      for await (const chunk of generator) {
        if (finalChunk === void 0) {
          finalChunk = chunk;
        } else {
          finalChunk = concat(finalChunk, chunk);
        }
      }
      yield* this._streamIterator(finalChunk, ensureConfig(options));
    }
    async *streamLog(input, options, streamOptions) {
      const logStreamCallbackHandler = new LogStreamCallbackHandler({
        ...streamOptions,
        autoClose: false,
        _schemaFormat: "original"
      });
      const config = ensureConfig(options);
      yield* this._streamLog(input, logStreamCallbackHandler, config);
    }
    async *_streamLog(input, logStreamCallbackHandler, config) {
      const { callbacks } = config;
      if (callbacks === void 0) {
        config.callbacks = [
          logStreamCallbackHandler
        ];
      } else if (Array.isArray(callbacks)) {
        config.callbacks = callbacks.concat([
          logStreamCallbackHandler
        ]);
      } else {
        const copiedCallbacks = callbacks.copy();
        copiedCallbacks.addHandler(logStreamCallbackHandler, true);
        config.callbacks = copiedCallbacks;
      }
      const runnableStreamPromise = this.stream(input, config);
      async function consumeRunnableStream() {
        try {
          const runnableStream = await runnableStreamPromise;
          for await (const chunk of runnableStream) {
            const patch2 = new RunLogPatch({
              ops: [
                {
                  op: "add",
                  path: "/streamed_output/-",
                  value: chunk
                }
              ]
            });
            await logStreamCallbackHandler.writer.write(patch2);
          }
        } finally {
          await logStreamCallbackHandler.writer.close();
        }
      }
      const runnableStreamConsumePromise = consumeRunnableStream();
      try {
        for await (const log2 of logStreamCallbackHandler) {
          yield log2;
        }
      } finally {
        await runnableStreamConsumePromise;
      }
    }
    streamEvents(input, options, streamOptions) {
      let stream;
      if (options.version === "v1") {
        stream = this._streamEventsV1(input, options, streamOptions);
      } else if (options.version === "v2") {
        stream = this._streamEventsV2(input, options, streamOptions);
      } else {
        throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
      }
      if (options.encoding === "text/event-stream") {
        return convertToHttpEventStream(stream);
      } else {
        return IterableReadableStream.fromAsyncGenerator(stream);
      }
    }
    async *_streamEventsV2(input, options, streamOptions) {
      var _a;
      const eventStreamer = new EventStreamCallbackHandler({
        ...streamOptions,
        autoClose: false
      });
      const config = ensureConfig(options);
      const runId = config.runId ?? v4();
      config.runId = runId;
      const callbacks = config.callbacks;
      if (callbacks === void 0) {
        config.callbacks = [
          eventStreamer
        ];
      } else if (Array.isArray(callbacks)) {
        config.callbacks = callbacks.concat(eventStreamer);
      } else {
        const copiedCallbacks = callbacks.copy();
        copiedCallbacks.addHandler(eventStreamer, true);
        config.callbacks = copiedCallbacks;
      }
      const outerThis = this;
      async function consumeRunnableStream() {
        try {
          const runnableStream = await outerThis.stream(input, config);
          const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
          for await (const _ of tappedStream) {
          }
        } finally {
          await eventStreamer.finish();
        }
      }
      const runnableStreamConsumePromise = consumeRunnableStream();
      let firstEventSent = false;
      let firstEventRunId;
      try {
        for await (const event of eventStreamer) {
          if (!firstEventSent) {
            event.data.input = input;
            firstEventSent = true;
            firstEventRunId = event.run_id;
            yield event;
            continue;
          }
          if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
            if ((_a = event.data) == null ? void 0 : _a.input) {
              delete event.data.input;
            }
          }
          yield event;
        }
      } finally {
        await runnableStreamConsumePromise;
      }
    }
    async *_streamEventsV1(input, options, streamOptions) {
      let runLog;
      let hasEncounteredStartEvent = false;
      const config = ensureConfig(options);
      const rootTags = config.tags ?? [];
      const rootMetadata = config.metadata ?? {};
      const rootName = config.runName ?? this.getName();
      const logStreamCallbackHandler = new LogStreamCallbackHandler({
        ...streamOptions,
        autoClose: false,
        _schemaFormat: "streaming_events"
      });
      const rootEventFilter = new _RootEventFilter({
        ...streamOptions
      });
      const logStream = this._streamLog(input, logStreamCallbackHandler, config);
      for await (const log2 of logStream) {
        if (!runLog) {
          runLog = RunLog.fromRunLogPatch(log2);
        } else {
          runLog = runLog.concat(log2);
        }
        if (runLog.state === void 0) {
          throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
        }
        if (!hasEncounteredStartEvent) {
          hasEncounteredStartEvent = true;
          const state3 = {
            ...runLog.state
          };
          const event = {
            run_id: state3.id,
            event: `on_${state3.type}_start`,
            name: rootName,
            tags: rootTags,
            metadata: rootMetadata,
            data: {
              input
            }
          };
          if (rootEventFilter.includeEvent(event, state3.type)) {
            yield event;
          }
        }
        const paths = log2.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
        const dedupedPaths = [
          ...new Set(paths)
        ];
        for (const path of dedupedPaths) {
          let eventType;
          let data = {};
          const logEntry = runLog.state.logs[path];
          if (logEntry.end_time === void 0) {
            if (logEntry.streamed_output.length > 0) {
              eventType = "stream";
            } else {
              eventType = "start";
            }
          } else {
            eventType = "end";
          }
          if (eventType === "start") {
            if (logEntry.inputs !== void 0) {
              data.input = logEntry.inputs;
            }
          } else if (eventType === "end") {
            if (logEntry.inputs !== void 0) {
              data.input = logEntry.inputs;
            }
            data.output = logEntry.final_output;
          } else if (eventType === "stream") {
            const chunkCount = logEntry.streamed_output.length;
            if (chunkCount !== 1) {
              throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
            }
            data = {
              chunk: logEntry.streamed_output[0]
            };
            logEntry.streamed_output = [];
          }
          yield {
            event: `on_${logEntry.type}_${eventType}`,
            name: logEntry.name,
            run_id: logEntry.id,
            tags: logEntry.tags,
            metadata: logEntry.metadata,
            data
          };
        }
        const { state: state2 } = runLog;
        if (state2.streamed_output.length > 0) {
          const chunkCount = state2.streamed_output.length;
          if (chunkCount !== 1) {
            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state2.name}"`);
          }
          const data = {
            chunk: state2.streamed_output[0]
          };
          state2.streamed_output = [];
          const event = {
            event: `on_${state2.type}_stream`,
            run_id: state2.id,
            tags: rootTags,
            metadata: rootMetadata,
            name: rootName,
            data
          };
          if (rootEventFilter.includeEvent(event, state2.type)) {
            yield event;
          }
        }
      }
      const state = runLog == null ? void 0 : runLog.state;
      if (state !== void 0) {
        const event = {
          event: `on_${state.type}_end`,
          name: rootName,
          run_id: state.id,
          tags: rootTags,
          metadata: rootMetadata,
          data: {
            output: state.final_output
          }
        };
        if (rootEventFilter.includeEvent(event, state.type)) yield event;
      }
    }
    static isRunnable(thing) {
      return isRunnableInterface(thing);
    }
    withListeners({ onStart, onEnd, onError }) {
      return new RunnableBinding({
        bound: this,
        config: {},
        configFactories: [
          (config) => ({
            callbacks: [
              new RootListenersTracer({
                config,
                onStart,
                onEnd,
                onError
              })
            ]
          })
        ]
      });
    }
    asTool(fields) {
      return convertRunnableToTool(this, fields);
    }
  };
  class RunnableBinding extends Runnable {
    static lc_name() {
      return "RunnableBinding";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "bound", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "config", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "kwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "configFactories", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.bound = fields.bound;
      this.kwargs = fields.kwargs;
      this.config = fields.config;
      this.configFactories = fields.configFactories;
    }
    getName(suffix) {
      return this.bound.getName(suffix);
    }
    async _mergeConfig(...options) {
      const config = mergeConfigs(this.config, ...options);
      return mergeConfigs(config, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config))) : []);
    }
    bind(kwargs) {
      return new this.constructor({
        bound: this.bound,
        kwargs: {
          ...this.kwargs,
          ...kwargs
        },
        config: this.config
      });
    }
    withConfig(config) {
      return new this.constructor({
        bound: this.bound,
        kwargs: this.kwargs,
        config: {
          ...this.config,
          ...config
        }
      });
    }
    withRetry(fields) {
      return new this.constructor({
        bound: this.bound.withRetry(fields),
        kwargs: this.kwargs,
        config: this.config
      });
    }
    async invoke(input, options) {
      return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    async batch(inputs, options, batchOptions) {
      const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);
      return this.bound.batch(inputs, mergedOptions, batchOptions);
    }
    async *_streamIterator(input, options) {
      yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    async stream(input, options) {
      return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    async *transform(generator, options) {
      yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));
    }
    streamEvents(input, options, streamOptions) {
      const outerThis = this;
      const generator = async function* () {
        yield* outerThis.bound.streamEvents(input, {
          ...await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs),
          version: options.version
        }, streamOptions);
      };
      return IterableReadableStream.fromAsyncGenerator(generator());
    }
    static isRunnableBinding(thing) {
      return thing.bound && Runnable.isRunnable(thing.bound);
    }
    withListeners({ onStart, onEnd, onError }) {
      return new RunnableBinding({
        bound: this.bound,
        kwargs: this.kwargs,
        config: this.config,
        configFactories: [
          (config) => ({
            callbacks: [
              new RootListenersTracer({
                config,
                onStart,
                onEnd,
                onError
              })
            ]
          })
        ]
      });
    }
  }
  class RunnableEach extends Runnable {
    static lc_name() {
      return "RunnableEach";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "bound", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.bound = fields.bound;
    }
    bind(kwargs) {
      return new RunnableEach({
        bound: this.bound.bind(kwargs)
      });
    }
    async invoke(inputs, config) {
      return this._callWithConfig(this._invoke.bind(this), inputs, config);
    }
    async _invoke(inputs, config, runManager) {
      return this.bound.batch(inputs, patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild()
      }));
    }
    withListeners({ onStart, onEnd, onError }) {
      return new RunnableEach({
        bound: this.bound.withListeners({
          onStart,
          onEnd,
          onError
        })
      });
    }
  }
  class RunnableRetry extends RunnableBinding {
    static lc_name() {
      return "RunnableRetry";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "maxAttemptNumber", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(this, "onFailedAttempt", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: () => {
        }
      });
      this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;
      this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;
    }
    _patchConfigForRetry(attempt, config, runManager) {
      const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
      return patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(tag)
      });
    }
    async _invoke(input, config, runManager) {
      return pRetry$1((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {
        onFailedAttempt: (error) => this.onFailedAttempt(error, input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true
      });
    }
    async invoke(input, config) {
      return this._callWithConfig(this._invoke.bind(this), input, config);
    }
    async _batch(inputs, configs, runManagers, batchOptions) {
      const resultsMap = {};
      try {
        await pRetry$1(async (attemptNumber) => {
          const remainingIndexes = inputs.map((_, i2) => i2).filter((i2) => resultsMap[i2.toString()] === void 0 || resultsMap[i2.toString()] instanceof Error);
          const remainingInputs = remainingIndexes.map((i2) => inputs[i2]);
          const patchedConfigs = remainingIndexes.map((i2) => this._patchConfigForRetry(attemptNumber, configs == null ? void 0 : configs[i2], runManagers == null ? void 0 : runManagers[i2]));
          const results = await super.batch(remainingInputs, patchedConfigs, {
            ...batchOptions,
            returnExceptions: true
          });
          let firstException;
          for (let i2 = 0; i2 < results.length; i2 += 1) {
            const result = results[i2];
            const resultMapIndex = remainingIndexes[i2];
            if (result instanceof Error) {
              if (firstException === void 0) {
                firstException = result;
                firstException.input = remainingInputs[i2];
              }
            }
            resultsMap[resultMapIndex.toString()] = result;
          }
          if (firstException) {
            throw firstException;
          }
          return results;
        }, {
          onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),
          retries: Math.max(this.maxAttemptNumber - 1, 0),
          randomize: true
        });
      } catch (e) {
        if ((batchOptions == null ? void 0 : batchOptions.returnExceptions) !== true) {
          throw e;
        }
      }
      return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
    }
    async batch(inputs, options, batchOptions) {
      return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
    }
  }
  class RunnableSequence extends Runnable {
    static lc_name() {
      return "RunnableSequence";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "first", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "middle", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "last", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      this.first = fields.first;
      this.middle = fields.middle ?? this.middle;
      this.last = fields.last;
      this.name = fields.name;
    }
    get steps() {
      return [
        this.first,
        ...this.middle,
        this.last
      ];
    }
    async invoke(input, options) {
      var _a;
      const config = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config);
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), config.runId, void 0, void 0, void 0, config == null ? void 0 : config.runName));
      delete config.runId;
      let nextStepInput = input;
      let finalOutput;
      try {
        const initialSteps = [
          this.first,
          ...this.middle
        ];
        for (let i2 = 0; i2 < initialSteps.length; i2 += 1) {
          const step = initialSteps[i2];
          const promise = step.invoke(nextStepInput, patchConfig(config, {
            callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:${i2 + 1}`)
          }));
          nextStepInput = await raceWithSignal(promise, options == null ? void 0 : options.signal);
        }
        if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
          throw new Error("Aborted");
        }
        finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:${this.steps.length}`)
        }));
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
      return finalOutput;
    }
    async batch(inputs, options, batchOptions) {
      var _a;
      const configList = this._getOptionsList(options ?? {}, inputs.length);
      const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
      const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
        const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), configList[i2].runId, void 0, void 0, void 0, configList[i2].runName));
        delete configList[i2].runId;
        return handleStartRes;
      }));
      let nextStepInputs = inputs;
      try {
        for (let i2 = 0; i2 < this.steps.length; i2 += 1) {
          const step = this.steps[i2];
          const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
            const childRunManager = runManager == null ? void 0 : runManager.getChild(`seq:step:${i2 + 1}`);
            return patchConfig(configList[j], {
              callbacks: childRunManager
            });
          }), batchOptions);
          nextStepInputs = await raceWithSignal(promise, (_a = configList[0]) == null ? void 0 : _a.signal);
        }
      } catch (e) {
        await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
        throw e;
      }
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(nextStepInputs, "output"))));
      return nextStepInputs;
    }
    async *_streamIterator(input, options) {
      var _a;
      const callbackManager_ = await getCallbackManagerForConfig(options);
      const { runId, ...otherOptions } = options ?? {};
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherOptions == null ? void 0 : otherOptions.runName));
      const steps = [
        this.first,
        ...this.middle,
        this.last
      ];
      let concatSupported = true;
      let finalOutput;
      async function* inputGenerator() {
        yield input;
      }
      try {
        let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:1`)
        }));
        for (let i2 = 1; i2 < steps.length; i2 += 1) {
          const step = steps[i2];
          finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {
            callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:${i2 + 1}`)
          }));
        }
        for await (const chunk of finalGenerator) {
          (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
          yield chunk;
          if (concatSupported) {
            if (finalOutput === void 0) {
              finalOutput = chunk;
            } else {
              try {
                finalOutput = concat(finalOutput, chunk);
              } catch (e) {
                finalOutput = void 0;
                concatSupported = false;
              }
            }
          }
        }
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, "output")));
    }
    getGraph(config) {
      const graph = new Graph();
      let currentLastNode = null;
      this.steps.forEach((step, index2) => {
        const stepGraph = step.getGraph(config);
        if (index2 !== 0) {
          stepGraph.trimFirstNode();
        }
        if (index2 !== this.steps.length - 1) {
          stepGraph.trimLastNode();
        }
        graph.extend(stepGraph);
        const stepFirstNode = stepGraph.firstNode();
        if (!stepFirstNode) {
          throw new Error(`Runnable ${step} has no first node`);
        }
        if (currentLastNode) {
          graph.addEdge(currentLastNode, stepFirstNode);
        }
        currentLastNode = stepGraph.lastNode();
      });
      return graph;
    }
    pipe(coerceable) {
      if (RunnableSequence.isRunnableSequence(coerceable)) {
        return new RunnableSequence({
          first: this.first,
          middle: this.middle.concat([
            this.last,
            coerceable.first,
            ...coerceable.middle
          ]),
          last: coerceable.last,
          name: this.name ?? coerceable.name
        });
      } else {
        return new RunnableSequence({
          first: this.first,
          middle: [
            ...this.middle,
            this.last
          ],
          last: _coerceToRunnable(coerceable),
          name: this.name
        });
      }
    }
    static isRunnableSequence(thing) {
      return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
    }
    static from([first, ...runnables], name) {
      return new RunnableSequence({
        first: _coerceToRunnable(first),
        middle: runnables.slice(0, -1).map(_coerceToRunnable),
        last: _coerceToRunnable(runnables[runnables.length - 1]),
        name
      });
    }
  }
  class RunnableMap extends Runnable {
    static lc_name() {
      return "RunnableMap";
    }
    getStepsKeys() {
      return Object.keys(this.steps);
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "steps", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.steps = {};
      for (const [key, value] of Object.entries(fields.steps)) {
        this.steps[key] = _coerceToRunnable(value);
      }
    }
    static from(steps) {
      return new RunnableMap({
        steps
      });
    }
    async invoke(input, options) {
      const config = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(config);
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {
        input
      }, config.runId, void 0, void 0, void 0, config == null ? void 0 : config.runName));
      delete config.runId;
      const output = {};
      try {
        const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
          output[key] = await runnable.invoke(input, patchConfig(config, {
            callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
          }));
        });
        await raceWithSignal(Promise.all(promises), options == null ? void 0 : options.signal);
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(output));
      return output;
    }
    async *_transform(generator, runManager, options) {
      const steps = {
        ...this.steps
      };
      const inputCopies = atee(generator, Object.keys(steps).length);
      const tasks = new Map(Object.entries(steps).map(([key, runnable], i2) => {
        const gen = runnable.transform(inputCopies[i2], patchConfig(options, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
        }));
        return [
          key,
          gen.next().then((result) => ({
            key,
            gen,
            result
          }))
        ];
      }));
      while (tasks.size) {
        const promise = Promise.race(tasks.values());
        const { key, result, gen } = await raceWithSignal(promise, options == null ? void 0 : options.signal);
        tasks.delete(key);
        if (!result.done) {
          yield {
            [key]: result.value
          };
          tasks.set(key, gen.next().then((result2) => ({
            key,
            gen,
            result: result2
          })));
        }
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config),
        config
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnableTraceable extends Runnable {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "func", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      if (!isTraceableFunction(fields.func)) {
        throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
      }
      this.func = fields.func;
    }
    async invoke(input, options) {
      const [config] = this._getOptionsList(options ?? {}, 1);
      const callbacks = await getCallbackManagerForConfig(config);
      const promise = this.func(patchConfig(config, {
        callbacks
      }), input);
      return raceWithSignal(promise, config == null ? void 0 : config.signal);
    }
    async *_streamIterator(input, options) {
      var _a, _b;
      const [config] = this._getOptionsList(options ?? {}, 1);
      const result = await this.invoke(input, options);
      if (isAsyncIterable(result)) {
        for await (const item of result) {
          (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
          yield item;
        }
        return;
      }
      if (isIterator(result)) {
        while (true) {
          (_b = config == null ? void 0 : config.signal) == null ? void 0 : _b.throwIfAborted();
          const state = result.next();
          if (state.done) break;
          yield state.value;
        }
        return;
      }
      yield result;
    }
    static from(func) {
      return new RunnableTraceable({
        func
      });
    }
  }
  function assertNonTraceableFunction(func) {
    if (isTraceableFunction(func)) {
      throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
    }
  }
  class RunnableLambda extends Runnable {
    static lc_name() {
      return "RunnableLambda";
    }
    constructor(fields) {
      if (isTraceableFunction(fields.func)) {
        return RunnableTraceable.from(fields.func);
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "func", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      assertNonTraceableFunction(fields.func);
      this.func = fields.func;
    }
    static from(func) {
      return new RunnableLambda({
        func
      });
    }
    async _invoke(input, config, runManager) {
      return new Promise((resolve, reject) => {
        const childConfig = patchConfig(config, {
          callbacks: runManager == null ? void 0 : runManager.getChild(),
          recursionLimit: ((config == null ? void 0 : config.recursionLimit) ?? DEFAULT_RECURSION_LIMIT) - 1
        });
        void AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {
          var _a, _b;
          try {
            let output = await this.func(input, {
              ...childConfig
            });
            if (output && Runnable.isRunnable(output)) {
              if ((config == null ? void 0 : config.recursionLimit) === 0) {
                throw new Error("Recursion limit reached.");
              }
              output = await output.invoke(input, {
                ...childConfig,
                recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1
              });
            } else if (isAsyncIterable(output)) {
              let finalOutput;
              for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
                (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
                if (finalOutput === void 0) {
                  finalOutput = chunk;
                } else {
                  try {
                    finalOutput = concat(finalOutput, chunk);
                  } catch (e) {
                    finalOutput = chunk;
                  }
                }
              }
              output = finalOutput;
            } else if (isIterableIterator(output)) {
              let finalOutput;
              for (const chunk of consumeIteratorInContext(childConfig, output)) {
                (_b = config == null ? void 0 : config.signal) == null ? void 0 : _b.throwIfAborted();
                if (finalOutput === void 0) {
                  finalOutput = chunk;
                } else {
                  try {
                    finalOutput = concat(finalOutput, chunk);
                  } catch (e) {
                    finalOutput = chunk;
                  }
                }
              }
              output = finalOutput;
            }
            resolve(output);
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    async invoke(input, options) {
      return this._callWithConfig(this._invoke.bind(this), input, options);
    }
    async *_transform(generator, runManager, config) {
      var _a, _b;
      let finalChunk;
      for await (const chunk of generator) {
        if (finalChunk === void 0) {
          finalChunk = chunk;
        } else {
          try {
            finalChunk = concat(finalChunk, chunk);
          } catch (e) {
            finalChunk = chunk;
          }
        }
      }
      const childConfig = patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(),
        recursionLimit: ((config == null ? void 0 : config.recursionLimit) ?? DEFAULT_RECURSION_LIMIT) - 1
      });
      const output = await new Promise((resolve, reject) => {
        void AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {
          try {
            const res = await this.func(finalChunk, {
              ...childConfig,
              config: childConfig
            });
            resolve(res);
          } catch (e) {
            reject(e);
          }
        });
      });
      if (output && Runnable.isRunnable(output)) {
        if ((config == null ? void 0 : config.recursionLimit) === 0) {
          throw new Error("Recursion limit reached.");
        }
        const stream = await output.stream(finalChunk, childConfig);
        for await (const chunk of stream) {
          yield chunk;
        }
      } else if (isAsyncIterable(output)) {
        for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
          (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
          yield chunk;
        }
      } else if (isIterableIterator(output)) {
        for (const chunk of consumeIteratorInContext(childConfig, output)) {
          (_b = config == null ? void 0 : config.signal) == null ? void 0 : _b.throwIfAborted();
          yield chunk;
        }
      } else {
        yield output;
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config),
        config
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnableWithFallbacks extends Runnable {
    static lc_name() {
      return "RunnableWithFallbacks";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "runnable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "fallbacks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.runnable = fields.runnable;
      this.fallbacks = fields.fallbacks;
    }
    *runnables() {
      yield this.runnable;
      for (const fallback of this.fallbacks) {
        yield fallback;
      }
    }
    async invoke(input, options) {
      var _a;
      const config = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(options);
      const { runId, ...otherConfigFields } = config;
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
      let firstError;
      for (const runnable of this.runnables()) {
        (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
        try {
          const output = await runnable.invoke(input, patchConfig(otherConfigFields, {
            callbacks: runManager == null ? void 0 : runManager.getChild()
          }));
          await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
          return output;
        } catch (e) {
          if (firstError === void 0) {
            firstError = e;
          }
        }
      }
      if (firstError === void 0) {
        throw new Error("No error stored at end of fallback.");
      }
      await (runManager == null ? void 0 : runManager.handleChainError(firstError));
      throw firstError;
    }
    async *_streamIterator(input, options) {
      var _a;
      const config = ensureConfig(options);
      const callbackManager_ = await getCallbackManagerForConfig(options);
      const { runId, ...otherConfigFields } = config;
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
      let firstError;
      let stream;
      for (const runnable of this.runnables()) {
        (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
        const childConfig = patchConfig(otherConfigFields, {
          callbacks: runManager == null ? void 0 : runManager.getChild()
        });
        try {
          stream = await runnable.stream(input, childConfig);
          break;
        } catch (e) {
          if (firstError === void 0) {
            firstError = e;
          }
        }
      }
      if (stream === void 0) {
        const error = firstError ?? new Error("No error stored at end of fallback.");
        await (runManager == null ? void 0 : runManager.handleChainError(error));
        throw error;
      }
      let output;
      try {
        for await (const chunk of stream) {
          yield chunk;
          try {
            output = output === void 0 ? output : concat(output, chunk);
          } catch (e) {
            output = void 0;
          }
        }
      } catch (e) {
        await (runManager == null ? void 0 : runManager.handleChainError(e));
        throw e;
      }
      await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(output, "output")));
    }
    async batch(inputs, options, batchOptions) {
      var _a;
      if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
        throw new Error("Not implemented.");
      }
      const configList = this._getOptionsList(options ?? {}, inputs.length);
      const callbackManagers = await Promise.all(configList.map((config) => getCallbackManagerForConfig(config)));
      const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i2) => {
        const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i2], "input"), configList[i2].runId, void 0, void 0, void 0, configList[i2].runName));
        delete configList[i2].runId;
        return handleStartRes;
      }));
      let firstError;
      for (const runnable of this.runnables()) {
        (_a = configList[0].signal) == null ? void 0 : _a.throwIfAborted();
        try {
          const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {
            callbacks: runManager == null ? void 0 : runManager.getChild()
          })), batchOptions);
          await Promise.all(runManagers.map((runManager, i2) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs[i2], "output"))));
          return outputs;
        } catch (e) {
          if (firstError === void 0) {
            firstError = e;
          }
        }
      }
      if (!firstError) {
        throw new Error("No error stored at end of fallbacks.");
      }
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(firstError)));
      throw firstError;
    }
  }
  function _coerceToRunnable(coerceable) {
    if (typeof coerceable === "function") {
      return new RunnableLambda({
        func: coerceable
      });
    } else if (Runnable.isRunnable(coerceable)) {
      return coerceable;
    } else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
      const runnables = {};
      for (const [key, value] of Object.entries(coerceable)) {
        runnables[key] = _coerceToRunnable(value);
      }
      return new RunnableMap({
        steps: runnables
      });
    } else {
      throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
    }
  }
  class RunnableAssign extends Runnable {
    static lc_name() {
      return "RunnableAssign";
    }
    constructor(fields) {
      if (fields instanceof RunnableMap) {
        fields = {
          mapper: fields
        };
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "mapper", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.mapper = fields.mapper;
    }
    async invoke(input, options) {
      const mapperResult = await this.mapper.invoke(input, options);
      return {
        ...input,
        ...mapperResult
      };
    }
    async *_transform(generator, runManager, options) {
      const mapperKeys = this.mapper.getStepsKeys();
      const [forPassthrough, forMapper] = atee(generator);
      const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {
        callbacks: runManager == null ? void 0 : runManager.getChild()
      }));
      const firstMapperChunkPromise = mapperOutput.next();
      for await (const chunk of forPassthrough) {
        if (typeof chunk !== "object" || Array.isArray(chunk)) {
          throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
        }
        const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
        if (Object.keys(filtered).length > 0) {
          yield filtered;
        }
      }
      yield (await firstMapperChunkPromise).value;
      for await (const chunk of mapperOutput) {
        yield chunk;
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config),
        config
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnablePick extends Runnable {
    static lc_name() {
      return "RunnablePick";
    }
    constructor(fields) {
      if (typeof fields === "string" || Array.isArray(fields)) {
        fields = {
          keys: fields
        };
      }
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "runnables"
        ]
      });
      Object.defineProperty(this, "lc_serializable", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
      });
      Object.defineProperty(this, "keys", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.keys = fields.keys;
    }
    async _pick(input) {
      if (typeof this.keys === "string") {
        return input[this.keys];
      } else {
        const picked = this.keys.map((key) => [
          key,
          input[key]
        ]).filter((v2) => v2[1] !== void 0);
        return picked.length === 0 ? void 0 : Object.fromEntries(picked);
      }
    }
    async invoke(input, options) {
      return this._callWithConfig(this._pick.bind(this), input, options);
    }
    async *_transform(generator) {
      for await (const chunk of generator) {
        const picked = await this._pick(chunk);
        if (picked !== void 0) {
          yield picked;
        }
      }
    }
    transform(generator, options) {
      return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
    }
    async stream(input, options) {
      async function* generator() {
        yield input;
      }
      const config = ensureConfig(options);
      const wrappedGenerator = new AsyncGeneratorWithSetup({
        generator: this.transform(generator(), config),
        config
      });
      await wrappedGenerator.setup;
      return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
    }
  }
  class RunnableToolLike extends RunnableBinding {
    constructor(fields) {
      const sequence = RunnableSequence.from([
        RunnableLambda.from(async (input) => {
          let toolInput;
          if (_isToolCall(input)) {
            try {
              toolInput = await this.schema.parseAsync(input.args);
            } catch (e) {
              throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
            }
          } else {
            toolInput = input;
          }
          return toolInput;
        }).withConfig({
          runName: `${fields.name}:parse_input`
        }),
        fields.bound
      ]).withConfig({
        runName: fields.name
      });
      super({
        bound: sequence,
        config: fields.config ?? {}
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "description", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "schema", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.name = fields.name;
      this.description = fields.description;
      this.schema = fields.schema;
    }
    static lc_name() {
      return "RunnableToolLike";
    }
  }
  function convertRunnableToTool(runnable, fields) {
    var _a;
    const name = fields.name ?? runnable.getName();
    const description = fields.description ?? ((_a = fields.schema) == null ? void 0 : _a.description);
    if (fields.schema.constructor === z.ZodString) {
      return new RunnableToolLike({
        name,
        description,
        schema: z.object({
          input: z.string()
        }).transform((input) => input.input),
        bound: runnable
      });
    }
    return new RunnableToolLike({
      name,
      description,
      schema: fields.schema,
      bound: runnable
    });
  }
  const parseLLMInputItemToBridgeJSON = (input) => {
    if (typeof input === "string") {
      return input;
    }
    if (input instanceof HumanMessage) {
      return {
        instanceof: "HumanMessage",
        item: input,
        content: input.content
      };
    } else if (input instanceof AIMessage) {
      return {
        instanceof: "AIMessage",
        item: input,
        content: input.content
      };
    } else if (input instanceof SystemMessage) {
      return {
        instanceof: "SystemMessage",
        item: input,
        content: input.content
      };
    }
    return input;
  };
  const parseLLMInputToBridgeJSON = (input) => {
    if (!Array.isArray(input)) {
      return parseLLMInputItemToBridgeJSON(input);
    }
    return input.map(parseLLMInputItemToBridgeJSON);
  };
  Document = class {
    constructor(fields) {
      Object.defineProperty(this, "pageContent", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "id", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.pageContent = fields.pageContent !== void 0 ? fields.pageContent.toString() : "";
      this.metadata = fields.metadata ?? {};
      this.id = fields.id;
    }
  };
  class BaseDocumentTransformer extends Runnable {
    constructor() {
      super(...arguments);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain_core",
          "documents",
          "transformers"
        ]
      });
    }
    invoke(input, _options) {
      return this.transformDocuments(input);
    }
  }
  var base64Js$1 = {};
  base64Js$1.byteLength = byteLength$1;
  base64Js$1.toByteArray = toByteArray$1;
  base64Js$1.fromByteArray = fromByteArray$1;
  var lookup$1 = [];
  var revLookup$1 = [];
  var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i$1 = 0, len$1 = code$1.length; i$1 < len$1; ++i$1) {
    lookup$1[i$1] = code$1[i$1];
    revLookup$1[code$1.charCodeAt(i$1)] = i$1;
  }
  revLookup$1["-".charCodeAt(0)] = 62;
  revLookup$1["_".charCodeAt(0)] = 63;
  function getLens$1(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [
      validLen,
      placeHoldersLen
    ];
  }
  function byteLength$1(b64) {
    var lens = getLens$1(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength$1(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray$1(b64) {
    var tmp;
    var lens = getLens$1(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr2 = new Arr$1(_byteLength$1(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup$1[b64.charCodeAt(i2)] << 18 | revLookup$1[b64.charCodeAt(i2 + 1)] << 12 | revLookup$1[b64.charCodeAt(i2 + 2)] << 6 | revLookup$1[b64.charCodeAt(i2 + 3)];
      arr2[curByte++] = tmp >> 16 & 255;
      arr2[curByte++] = tmp >> 8 & 255;
      arr2[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup$1[b64.charCodeAt(i2)] << 2 | revLookup$1[b64.charCodeAt(i2 + 1)] >> 4;
      arr2[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup$1[b64.charCodeAt(i2)] << 10 | revLookup$1[b64.charCodeAt(i2 + 1)] << 4 | revLookup$1[b64.charCodeAt(i2 + 2)] >> 2;
      arr2[curByte++] = tmp >> 8 & 255;
      arr2[curByte++] = tmp & 255;
    }
    return arr2;
  }
  function tripletToBase64$1(num) {
    return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
  }
  function encodeChunk$1(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64$1(tmp));
    }
    return output.join("");
  }
  function fromByteArray$1(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk$1(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value
  }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, key + "", value);
    return value;
  };
  function bytePairMerge(piece, ranks) {
    let parts = Array.from({
      length: piece.length
    }, (_, i2) => ({
      start: i2,
      end: i2 + 1
    }));
    while (parts.length > 1) {
      let minRank = null;
      for (let i2 = 0; i2 < parts.length - 1; i2++) {
        const slice = piece.slice(parts[i2].start, parts[i2 + 1].end);
        const rank = ranks.get(slice.join(","));
        if (rank == null) continue;
        if (minRank == null || rank < minRank[0]) {
          minRank = [
            rank,
            i2
          ];
        }
      }
      if (minRank != null) {
        const i2 = minRank[1];
        parts[i2] = {
          start: parts[i2].start,
          end: parts[i2 + 1].end
        };
        parts.splice(i2 + 1, 1);
      } else {
        break;
      }
    }
    return parts;
  }
  function bytePairEncode(piece, ranks) {
    if (piece.length === 1) return [
      ranks.get(piece.join(","))
    ];
    return bytePairMerge(piece, ranks).map((p2) => ranks.get(piece.slice(p2.start, p2.end).join(","))).filter((x2) => x2 != null);
  }
  function escapeRegex(str) {
    return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  var _Tiktoken = class {
    constructor(ranks, extendedSpecialTokens) {
      __publicField(this, "specialTokens");
      __publicField(this, "inverseSpecialTokens");
      __publicField(this, "patStr");
      __publicField(this, "textEncoder", new TextEncoder());
      __publicField(this, "textDecoder", new TextDecoder("utf-8"));
      __publicField(this, "rankMap", /* @__PURE__ */ new Map());
      __publicField(this, "textMap", /* @__PURE__ */ new Map());
      this.patStr = ranks.pat_str;
      const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo2, x2) => {
        const [_, offsetStr, ...tokens] = x2.split(" ");
        const offset = Number.parseInt(offsetStr, 10);
        tokens.forEach((token, i2) => memo2[token] = offset + i2);
        return memo2;
      }, {});
      for (const [token, rank] of Object.entries(uncompressed)) {
        const bytes = base64Js$1.toByteArray(token);
        this.rankMap.set(bytes.join(","), rank);
        this.textMap.set(rank, bytes);
      }
      this.specialTokens = {
        ...ranks.special_tokens,
        ...extendedSpecialTokens
      };
      this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo2, [text, rank]) => {
        memo2[rank] = this.textEncoder.encode(text);
        return memo2;
      }, {});
    }
    encode(text, allowedSpecial = [], disallowedSpecial = "all") {
      const regexes = new RegExp(this.patStr, "ug");
      const specialRegex = _Tiktoken.specialTokenRegex(Object.keys(this.specialTokens));
      const ret = [];
      const allowedSpecialSet = new Set(allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial);
      const disallowedSpecialSet = new Set(disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter((x2) => !allowedSpecialSet.has(x2)) : disallowedSpecial);
      if (disallowedSpecialSet.size > 0) {
        const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
          ...disallowedSpecialSet
        ]);
        const specialMatch = text.match(disallowedSpecialRegex);
        if (specialMatch != null) {
          throw new Error(`The text contains a special token that is not allowed: ${specialMatch[0]}`);
        }
      }
      let start = 0;
      while (true) {
        let nextSpecial = null;
        let startFind = start;
        while (true) {
          specialRegex.lastIndex = startFind;
          nextSpecial = specialRegex.exec(text);
          if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0])) break;
          startFind = nextSpecial.index + 1;
        }
        const end = (nextSpecial == null ? void 0 : nextSpecial.index) ?? text.length;
        for (const match of text.substring(start, end).matchAll(regexes)) {
          const piece = this.textEncoder.encode(match[0]);
          const token2 = this.rankMap.get(piece.join(","));
          if (token2 != null) {
            ret.push(token2);
            continue;
          }
          ret.push(...bytePairEncode(piece, this.rankMap));
        }
        if (nextSpecial == null) break;
        let token = this.specialTokens[nextSpecial[0]];
        ret.push(token);
        start = nextSpecial.index + nextSpecial[0].length;
      }
      return ret;
    }
    decode(tokens) {
      const res = [];
      let length = 0;
      for (let i22 = 0; i22 < tokens.length; ++i22) {
        const token = tokens[i22];
        const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];
        if (bytes != null) {
          res.push(bytes);
          length += bytes.length;
        }
      }
      const mergedArray = new Uint8Array(length);
      let i2 = 0;
      for (const bytes of res) {
        mergedArray.set(bytes, i2);
        i2 += bytes.length;
      }
      return this.textDecoder.decode(mergedArray);
    }
  };
  var Tiktoken = _Tiktoken;
  __publicField2(Tiktoken, "specialTokenRegex", (tokens) => {
    return new RegExp(tokens.map((i2) => escapeRegex(i2)).join("|"), "g");
  });
  const cache = {};
  const caller = new AsyncCaller({});
  async function getEncoding(encoding) {
    if (!(encoding in cache)) {
      cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
        delete cache[encoding];
        throw e;
      });
    }
    return await cache[encoding];
  }
  class TextSplitter extends BaseDocumentTransformer {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain",
          "document_transformers",
          "text_splitters"
        ]
      });
      Object.defineProperty(this, "chunkSize", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 1e3
      });
      Object.defineProperty(this, "chunkOverlap", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 200
      });
      Object.defineProperty(this, "keepSeparator", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "lengthFunction", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.chunkSize = (fields == null ? void 0 : fields.chunkSize) ?? this.chunkSize;
      this.chunkOverlap = (fields == null ? void 0 : fields.chunkOverlap) ?? this.chunkOverlap;
      this.keepSeparator = (fields == null ? void 0 : fields.keepSeparator) ?? this.keepSeparator;
      this.lengthFunction = (fields == null ? void 0 : fields.lengthFunction) ?? ((text) => text.length);
      if (this.chunkOverlap >= this.chunkSize) {
        throw new Error("Cannot have chunkOverlap >= chunkSize");
      }
    }
    async transformDocuments(documents2, chunkHeaderOptions = {}) {
      return this.splitDocuments(documents2, chunkHeaderOptions);
    }
    splitOnSeparator(text, separator) {
      let splits;
      if (separator) {
        if (this.keepSeparator) {
          const regexEscapedSeparator = separator.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
          splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));
        } else {
          splits = text.split(separator);
        }
      } else {
        splits = text.split("");
      }
      return splits.filter((s) => s !== "");
    }
    async createDocuments(texts, metadatas = [], chunkHeaderOptions = {}) {
      const _metadatas = metadatas.length > 0 ? metadatas : [
        ...Array(texts.length)
      ].map(() => ({}));
      const { chunkHeader = "", chunkOverlapHeader = "(cont'd) ", appendChunkOverlapHeader = false } = chunkHeaderOptions;
      const documents2 = new Array();
      for (let i2 = 0; i2 < texts.length; i2 += 1) {
        const text = texts[i2];
        let lineCounterIndex = 1;
        let prevChunk = null;
        let indexPrevChunk = -1;
        for (const chunk of await this.splitText(text)) {
          let pageContent = chunkHeader;
          const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);
          if (prevChunk === null) {
            const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);
            lineCounterIndex += newLinesBeforeFirstChunk;
          } else {
            const indexEndPrevChunk = indexPrevChunk + await this.lengthFunction(prevChunk);
            if (indexEndPrevChunk < indexChunk) {
              const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);
              lineCounterIndex += numberOfIntermediateNewLines;
            } else if (indexEndPrevChunk > indexChunk) {
              const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);
              lineCounterIndex -= numberOfIntermediateNewLines;
            }
            if (appendChunkOverlapHeader) {
              pageContent += chunkOverlapHeader;
            }
          }
          const newLinesCount = this.numberOfNewLines(chunk);
          const loc = _metadatas[i2].loc && typeof _metadatas[i2].loc === "object" ? {
            ..._metadatas[i2].loc
          } : {};
          loc.lines = {
            from: lineCounterIndex,
            to: lineCounterIndex + newLinesCount
          };
          const metadataWithLinesNumber = {
            ..._metadatas[i2],
            loc
          };
          pageContent += chunk;
          documents2.push(new Document({
            pageContent,
            metadata: metadataWithLinesNumber
          }));
          lineCounterIndex += newLinesCount;
          prevChunk = chunk;
          indexPrevChunk = indexChunk;
        }
      }
      return documents2;
    }
    numberOfNewLines(text, start, end) {
      const textSection = text.slice(start, end);
      return (textSection.match(/\n/g) || []).length;
    }
    async splitDocuments(documents2, chunkHeaderOptions = {}) {
      const selectedDocuments = documents2.filter((doc) => doc.pageContent !== void 0);
      const texts = selectedDocuments.map((doc) => doc.pageContent);
      const metadatas = selectedDocuments.map((doc) => doc.metadata);
      return this.createDocuments(texts, metadatas, chunkHeaderOptions);
    }
    joinDocs(docs, separator) {
      const text = docs.join(separator).trim();
      return text === "" ? null : text;
    }
    async mergeSplits(splits, separator) {
      const docs = [];
      const currentDoc = [];
      let total = 0;
      for (const d of splits) {
        const _len = await this.lengthFunction(d);
        if (total + _len + currentDoc.length * separator.length > this.chunkSize) {
          if (total > this.chunkSize) {
            console.warn(`Created a chunk of size ${total}, +
which is longer than the specified ${this.chunkSize}`);
          }
          if (currentDoc.length > 0) {
            const doc2 = this.joinDocs(currentDoc, separator);
            if (doc2 !== null) {
              docs.push(doc2);
            }
            while (total > this.chunkOverlap || total + _len + currentDoc.length * separator.length > this.chunkSize && total > 0) {
              total -= await this.lengthFunction(currentDoc[0]);
              currentDoc.shift();
            }
          }
        }
        currentDoc.push(d);
        total += _len;
      }
      const doc = this.joinDocs(currentDoc, separator);
      if (doc !== null) {
        docs.push(doc);
      }
      return docs;
    }
  }
  class CharacterTextSplitter extends TextSplitter {
    static lc_name() {
      return "CharacterTextSplitter";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "separator", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "\n\n"
      });
      this.separator = (fields == null ? void 0 : fields.separator) ?? this.separator;
    }
    async splitText(text) {
      const splits = this.splitOnSeparator(text, this.separator);
      return this.mergeSplits(splits, this.keepSeparator ? "" : this.separator);
    }
  }
  class RecursiveCharacterTextSplitter extends TextSplitter {
    static lc_name() {
      return "RecursiveCharacterTextSplitter";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "separators", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "\n\n",
          "\n",
          " ",
          ""
        ]
      });
      this.separators = (fields == null ? void 0 : fields.separators) ?? this.separators;
      this.keepSeparator = (fields == null ? void 0 : fields.keepSeparator) ?? true;
    }
    async _splitText(text, separators) {
      const finalChunks = [];
      let separator = separators[separators.length - 1];
      let newSeparators;
      for (let i2 = 0; i2 < separators.length; i2 += 1) {
        const s = separators[i2];
        if (s === "") {
          separator = s;
          break;
        }
        if (text.includes(s)) {
          separator = s;
          newSeparators = separators.slice(i2 + 1);
          break;
        }
      }
      const splits = this.splitOnSeparator(text, separator);
      let goodSplits = [];
      const _separator = this.keepSeparator ? "" : separator;
      for (const s of splits) {
        if (await this.lengthFunction(s) < this.chunkSize) {
          goodSplits.push(s);
        } else {
          if (goodSplits.length) {
            const mergedText = await this.mergeSplits(goodSplits, _separator);
            finalChunks.push(...mergedText);
            goodSplits = [];
          }
          if (!newSeparators) {
            finalChunks.push(s);
          } else {
            const otherInfo = await this._splitText(s, newSeparators);
            finalChunks.push(...otherInfo);
          }
        }
      }
      if (goodSplits.length) {
        const mergedText = await this.mergeSplits(goodSplits, _separator);
        finalChunks.push(...mergedText);
      }
      return finalChunks;
    }
    async splitText(text) {
      return this._splitText(text, this.separators);
    }
    static fromLanguage(language, options) {
      return new RecursiveCharacterTextSplitter({
        ...options,
        separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language)
      });
    }
    static getSeparatorsForLanguage(language) {
      if (language === "cpp") {
        return [
          "\nclass ",
          "\nvoid ",
          "\nint ",
          "\nfloat ",
          "\ndouble ",
          "\nif ",
          "\nfor ",
          "\nwhile ",
          "\nswitch ",
          "\ncase ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "go") {
        return [
          "\nfunc ",
          "\nvar ",
          "\nconst ",
          "\ntype ",
          "\nif ",
          "\nfor ",
          "\nswitch ",
          "\ncase ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "java") {
        return [
          "\nclass ",
          "\npublic ",
          "\nprotected ",
          "\nprivate ",
          "\nstatic ",
          "\nif ",
          "\nfor ",
          "\nwhile ",
          "\nswitch ",
          "\ncase ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "js") {
        return [
          "\nfunction ",
          "\nconst ",
          "\nlet ",
          "\nvar ",
          "\nclass ",
          "\nif ",
          "\nfor ",
          "\nwhile ",
          "\nswitch ",
          "\ncase ",
          "\ndefault ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "php") {
        return [
          "\nfunction ",
          "\nclass ",
          "\nif ",
          "\nforeach ",
          "\nwhile ",
          "\ndo ",
          "\nswitch ",
          "\ncase ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "proto") {
        return [
          "\nmessage ",
          "\nservice ",
          "\nenum ",
          "\noption ",
          "\nimport ",
          "\nsyntax ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "python") {
        return [
          "\nclass ",
          "\ndef ",
          "\n	def ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "rst") {
        return [
          "\n===\n",
          "\n---\n",
          "\n***\n",
          "\n.. ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "ruby") {
        return [
          "\ndef ",
          "\nclass ",
          "\nif ",
          "\nunless ",
          "\nwhile ",
          "\nfor ",
          "\ndo ",
          "\nbegin ",
          "\nrescue ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "rust") {
        return [
          "\nfn ",
          "\nconst ",
          "\nlet ",
          "\nif ",
          "\nwhile ",
          "\nfor ",
          "\nloop ",
          "\nmatch ",
          "\nconst ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "scala") {
        return [
          "\nclass ",
          "\nobject ",
          "\ndef ",
          "\nval ",
          "\nvar ",
          "\nif ",
          "\nfor ",
          "\nwhile ",
          "\nmatch ",
          "\ncase ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "swift") {
        return [
          "\nfunc ",
          "\nclass ",
          "\nstruct ",
          "\nenum ",
          "\nif ",
          "\nfor ",
          "\nwhile ",
          "\ndo ",
          "\nswitch ",
          "\ncase ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "markdown") {
        return [
          "\n## ",
          "\n### ",
          "\n#### ",
          "\n##### ",
          "\n###### ",
          "```\n\n",
          "\n\n***\n\n",
          "\n\n---\n\n",
          "\n\n___\n\n",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "latex") {
        return [
          "\n\\chapter{",
          "\n\\section{",
          "\n\\subsection{",
          "\n\\subsubsection{",
          "\n\\begin{enumerate}",
          "\n\\begin{itemize}",
          "\n\\begin{description}",
          "\n\\begin{list}",
          "\n\\begin{quote}",
          "\n\\begin{quotation}",
          "\n\\begin{verse}",
          "\n\\begin{verbatim}",
          "\n\\begin{align}",
          "$$",
          "$",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else if (language === "html") {
        return [
          "<body>",
          "<div>",
          "<p>",
          "<br>",
          "<li>",
          "<h1>",
          "<h2>",
          "<h3>",
          "<h4>",
          "<h5>",
          "<h6>",
          "<span>",
          "<table>",
          "<tr>",
          "<td>",
          "<th>",
          "<ul>",
          "<ol>",
          "<header>",
          "<footer>",
          "<nav>",
          "<head>",
          "<style>",
          "<script>",
          "<meta>",
          "<title>",
          " ",
          ""
        ];
      } else if (language === "sol") {
        return [
          "\npragma ",
          "\nusing ",
          "\ncontract ",
          "\ninterface ",
          "\nlibrary ",
          "\nconstructor ",
          "\ntype ",
          "\nfunction ",
          "\nevent ",
          "\nmodifier ",
          "\nerror ",
          "\nstruct ",
          "\nenum ",
          "\nif ",
          "\nfor ",
          "\nwhile ",
          "\ndo while ",
          "\nassembly ",
          "\n\n",
          "\n",
          " ",
          ""
        ];
      } else {
        throw new Error(`Language ${language} is not supported.`);
      }
    }
  }
  class TokenTextSplitter extends TextSplitter {
    static lc_name() {
      return "TokenTextSplitter";
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "encodingName", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "allowedSpecial", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "disallowedSpecial", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tokenizer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.encodingName = (fields == null ? void 0 : fields.encodingName) ?? "gpt2";
      this.allowedSpecial = (fields == null ? void 0 : fields.allowedSpecial) ?? [];
      this.disallowedSpecial = (fields == null ? void 0 : fields.disallowedSpecial) ?? "all";
    }
    async splitText(text) {
      if (!this.tokenizer) {
        this.tokenizer = await getEncoding(this.encodingName);
      }
      const splits = [];
      const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);
      let start_idx = 0;
      while (start_idx < input_ids.length) {
        if (start_idx > 0) {
          start_idx -= this.chunkOverlap;
        }
        const end_idx = Math.min(start_idx + this.chunkSize, input_ids.length);
        const chunk_ids = input_ids.slice(start_idx, end_idx);
        splits.push(this.tokenizer.decode(chunk_ids));
        start_idx = end_idx;
      }
      return splits;
    }
  }
  const __vite__wasmUrl = "/NoLLMChat/assets/voy_search_bg-FlZi7F4l.wasm";
  var buffer = {};
  var base64Js = {};
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [
      validLen,
      placeHoldersLen
    ];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr2[curByte++] = tmp >> 16 & 255;
      arr2[curByte++] = tmp >> 8 & 255;
      arr2[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr2[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr2[curByte++] = tmp >> 8 & 255;
      arr2[curByte++] = tmp & 255;
    }
    return arr2;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  var ieee754 = {};
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    m2 = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m2 ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e, m2, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m2 = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m2 = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m2 = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d, m2 /= 256, mLen -= 8) {
    }
    e = e << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d] |= s * 128;
  };
  (function(exports) {
    const base64 = base64Js;
    const ieee754$1 = ieee754;
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer2;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr2 = new GlobalUint8Array(1);
        const proto2 = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto2, GlobalUint8Array.prototype);
        Object.setPrototypeOf(arr2, proto2);
        return arr2.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new GlobalUint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (GlobalArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
    Object.setPrototypeOf(Buffer3, GlobalUint8Array);
    function assertSize(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size2 < 0) {
        throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
      }
    }
    function alloc(size2, fill, encoding) {
      assertSize(size2);
      if (size2 <= 0) {
        return createBuffer(size2);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
      }
      return createBuffer(size2);
    }
    Buffer3.alloc = function(size2, fill, encoding) {
      return alloc(size2, fill, encoding);
    };
    function allocUnsafe(size2) {
      assertSize(size2);
      return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
    }
    Buffer3.allocUnsafe = function(size2) {
      return allocUnsafe(size2);
    };
    Buffer3.allocUnsafeSlow = function(size2) {
      return allocUnsafe(size2);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength2(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, GlobalUint8Array)) {
        const copy2 = new GlobalUint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new GlobalUint8Array(array);
      } else if (length === void 0) {
        buf = new GlobalUint8Array(array, byteOffset);
      } else {
        buf = new GlobalUint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len2 = checked(obj.length) | 0;
        const buf = createBuffer(len2);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len2);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer2(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare2(a, b) {
      if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, GlobalUint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b) return 0;
      let x2 = a.length;
      let y2 = b.length;
      for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
        if (a[i2] !== b[i2]) {
          x2 = a[i2];
          y2 = b[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, GlobalUint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            GlobalUint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len2 = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len2 === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len2 * 2;
          case "hex":
            return len2 >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n2, m2) {
      const i2 = b[n2];
      b[n2] = b[m2];
      b[m2] = i2;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len2 = this.length;
      if (len2 % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len2 = this.length;
      if (len2 % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len2 = this.length;
      if (len2 % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len2; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, GlobalUint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end - start;
      const len2 = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len2; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof GlobalUint8Array.prototype.indexOf === "function") {
          if (dir) {
            return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [
          val
        ], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr2.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr2.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr2, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr2, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len2 = codePoints.length;
      if (len2 <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len2) {
        res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len2 = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len2) end = len2;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len2 = this.length;
      start = ~~start;
      end = end === void 0 ? len2 : ~~end;
      if (start < 0) {
        start += len2;
        if (start < 0) start = 0;
      } else if (start > len2) {
        start = len2;
      }
      if (end < 0) {
        end += len2;
        if (end < 0) end = 0;
      } else if (end > len2) {
        end = len2;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      let val = this[offset + --byteLength3];
      let mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi2) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi2 = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi2) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength3, this.length);
      let i2 = byteLength3;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value, offset, byteLength3, maxBytes, 0);
      }
      let i2 = byteLength3 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      hi2 = hi2 >> 8;
      buf[offset++] = hi2;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 2] = hi2;
      hi2 = hi2 >> 8;
      buf[offset + 1] = hi2;
      hi2 = hi2 >> 8;
      buf[offset] = hi2;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value, offset, byteLength3, limit - 1, -limit);
      }
      let i2 = byteLength3 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len2 = end - start;
      if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        GlobalUint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len2;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len2 = bytes.length;
        if (len2 === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len2];
        }
      }
      return this;
    };
    const errors2 = {};
    function E2(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E2("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E2("ERR_OUT_OF_RANGE", function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset, byteLength3) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
        boundsError(offset, buf.length - (byteLength3 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength3) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range2;
        {
          if (min === 0 || min === BigInt(0)) {
            range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
          } else {
            range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
          }
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength3);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi2, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i2);
        hi2 = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi2);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length) break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  Buffer2 = buffer.Buffer;
  const Blob$1 = buffer.Blob;
  const BlobOptions = buffer.BlobOptions;
  Buffer$1 = buffer.Buffer;
  const File = buffer.File;
  const FileOptions = buffer.FileOptions;
  const INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;
  const SlowBuffer = buffer.SlowBuffer;
  const TranscodeEncoding = buffer.TranscodeEncoding;
  const atob$1 = buffer.atob;
  const btoa$1 = buffer.btoa;
  const constants = buffer.constants;
  const isAscii = buffer.isAscii;
  const isUtf8 = buffer.isUtf8;
  const kMaxLength = buffer.kMaxLength;
  const kStringMaxLength = buffer.kStringMaxLength;
  const resolveObjectURL = buffer.resolveObjectURL;
  const transcode = buffer.transcode;
  const dist = Object.freeze(Object.defineProperty({
    __proto__: null,
    Blob: Blob$1,
    BlobOptions,
    Buffer: Buffer$1,
    File,
    FileOptions,
    INSPECT_MAX_BYTES,
    SlowBuffer,
    TranscodeEncoding,
    atob: atob$1,
    btoa: btoa$1,
    constants,
    default: Buffer2,
    isAscii,
    isUtf8,
    kMaxLength,
    kStringMaxLength,
    resolveObjectURL,
    transcode
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const __vite__initWasm = async (opts = {}, url) => {
    let result;
    if (url.startsWith("data:")) {
      const urlContent = url.replace(/^data:.*?base64,/, "");
      let bytes;
      if (typeof Buffer2 === "function" && typeof Buffer2.from === "function") {
        bytes = Buffer2.from(urlContent, "base64");
      } else if (typeof atob === "function") {
        const binaryString = atob(urlContent);
        bytes = new Uint8Array(binaryString.length);
        for (let i2 = 0; i2 < binaryString.length; i2++) {
          bytes[i2] = binaryString.charCodeAt(i2);
        }
      } else {
        throw new Error("Cannot decode base64-encoded data URL");
      }
      result = await WebAssembly.instantiate(bytes, opts);
    } else {
      const response = await fetch(url);
      const contentType = response.headers.get("Content-Type") || "";
      if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
        result = await WebAssembly.instantiateStreaming(response, opts);
      } else {
        const buffer2 = await response.arrayBuffer();
        result = await WebAssembly.instantiate(buffer2, opts);
      }
    }
    return result.instance.exports;
  };
  let wasm$1;
  function __wbg_set_wasm(val) {
    wasm$1 = val;
  }
  const heap = new Array(128).fill(void 0);
  heap.push(void 0, null, true, false);
  function getObject(idx) {
    return heap[idx];
  }
  let heap_next = heap.length;
  function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
  }
  function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
  }
  function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
  }
  let WASM_VECTOR_LEN = 0;
  let cachedUint8Memory0 = null;
  function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
      cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8Memory0;
  }
  const lTextEncoder = typeof TextEncoder === "undefined" ? (0, module.require)("util").TextEncoder : TextEncoder;
  let cachedTextEncoder = new lTextEncoder("utf-8");
  const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
  } : function(arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
  function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === void 0) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr2 = malloc(buf.length) >>> 0;
      getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return ptr2;
    }
    let len2 = arg.length;
    let ptr = malloc(len2) >>> 0;
    const mem = getUint8Memory0();
    let offset = 0;
    for (; offset < len2; offset++) {
      const code2 = arg.charCodeAt(offset);
      if (code2 > 127) break;
      mem[ptr + offset] = code2;
    }
    if (offset !== len2) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len2, len2 = offset + arg.length * 3) >>> 0;
      const view = getUint8Memory0().subarray(ptr + offset, ptr + len2);
      const ret = encodeString(arg, view);
      offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
  }
  function isLikeNone(x2) {
    return x2 === void 0 || x2 === null;
  }
  let cachedInt32Memory0 = null;
  function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
      cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
    }
    return cachedInt32Memory0;
  }
  const lTextDecoder = typeof TextDecoder === "undefined" ? (0, module.require)("util").TextDecoder : TextDecoder;
  let cachedTextDecoder = new lTextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  cachedTextDecoder.decode();
  function getStringFromWasm0(ptr, len2) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len2));
  }
  let cachedFloat32Memory0 = null;
  function getFloat32Memory0() {
    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {
      cachedFloat32Memory0 = new Float32Array(wasm$1.memory.buffer);
    }
    return cachedFloat32Memory0;
  }
  function passArrayF32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4) >>> 0;
    getFloat32Memory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
  }
  function handleError(f2, args) {
    try {
      return f2.apply(this, args);
    } catch (e) {
      wasm$1.__wbindgen_exn_store(addHeapObject(e));
    }
  }
  class Voy {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(Voy.prototype);
      obj.__wbg_ptr = ptr;
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm$1.__wbg_voy_free(ptr);
    }
    constructor(resource) {
      const ret = wasm$1.voy_new(isLikeNone(resource) ? 0 : addHeapObject(resource));
      return Voy.__wrap(ret);
    }
    serialize() {
      let deferred1_0;
      let deferred1_1;
      try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.voy_serialize(retptr, this.__wbg_ptr);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        deferred1_0 = r0;
        deferred1_1 = r1;
        return getStringFromWasm0(r0, r1);
      } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
        wasm$1.__wbindgen_free(deferred1_0, deferred1_1);
      }
    }
    static deserialize(serialized_index) {
      const ptr0 = passStringToWasm0(serialized_index, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm$1.voy_deserialize(ptr0, len0);
      return Voy.__wrap(ret);
    }
    index(resource) {
      wasm$1.voy_index(this.__wbg_ptr, addHeapObject(resource));
    }
    search(query, k2) {
      const ptr0 = passArrayF32ToWasm0(query, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm$1.voy_search(this.__wbg_ptr, ptr0, len0, k2);
      return takeObject(ret);
    }
    add(resource) {
      wasm$1.voy_add(this.__wbg_ptr, addHeapObject(resource));
    }
    remove(resource) {
      wasm$1.voy_remove(this.__wbg_ptr, addHeapObject(resource));
    }
    clear() {
      wasm$1.voy_clear(this.__wbg_ptr);
    }
    size() {
      const ret = wasm$1.voy_size(this.__wbg_ptr);
      return ret >>> 0;
    }
  }
  function __wbindgen_object_clone_ref(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  }
  function __wbindgen_is_undefined(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  }
  function __wbindgen_object_drop_ref(arg0) {
    takeObject(arg0);
  }
  function __wbg_new_abda76e883ba8a5f() {
    const ret = new Error();
    return addHeapObject(ret);
  }
  function __wbg_stack_658279fe44541cf6(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  }
  function __wbg_error_f851667af71bcfc6(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm$1.__wbindgen_free(deferred0_0, deferred0_1);
    }
  }
  function __wbg_parse_76a8a18ca3f8730b() {
    return handleError(function(arg0, arg1) {
      const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbg_stringify_d06ad2addc54d51e() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  }
  function __wbindgen_string_get(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  }
  function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  }
  URL = globalThis.URL;
  const __vite__wasmModule = await __vite__initWasm({
    "./voy_search_bg.js": {
      __wbindgen_object_clone_ref,
      __wbindgen_is_undefined,
      __wbindgen_object_drop_ref,
      __wbg_new_abda76e883ba8a5f,
      __wbg_stack_658279fe44541cf6,
      __wbg_error_f851667af71bcfc6,
      __wbg_parse_76a8a18ca3f8730b,
      __wbg_stringify_d06ad2addc54d51e,
      __wbindgen_string_get,
      __wbindgen_throw
    }
  }, __vite__wasmUrl);
  const memory = __vite__wasmModule.memory;
  const __wbg_voy_free = __vite__wasmModule.__wbg_voy_free;
  const voy_new = __vite__wasmModule.voy_new;
  const voy_serialize = __vite__wasmModule.voy_serialize;
  const voy_deserialize = __vite__wasmModule.voy_deserialize;
  const voy_index = __vite__wasmModule.voy_index;
  const voy_search = __vite__wasmModule.voy_search;
  const voy_add = __vite__wasmModule.voy_add;
  const voy_remove = __vite__wasmModule.voy_remove;
  const voy_clear = __vite__wasmModule.voy_clear;
  const voy_size = __vite__wasmModule.voy_size;
  const index = __vite__wasmModule.index;
  const search = __vite__wasmModule.search;
  const add = __vite__wasmModule.add;
  const remove = __vite__wasmModule.remove;
  const clear = __vite__wasmModule.clear;
  const size = __vite__wasmModule.size;
  const __wbindgen_malloc = __vite__wasmModule.__wbindgen_malloc;
  const __wbindgen_realloc = __vite__wasmModule.__wbindgen_realloc;
  const __wbindgen_add_to_stack_pointer = __vite__wasmModule.__wbindgen_add_to_stack_pointer;
  const __wbindgen_free = __vite__wasmModule.__wbindgen_free;
  const __wbindgen_exn_store = __vite__wasmModule.__wbindgen_exn_store;
  const wasm = Object.freeze(Object.defineProperty({
    __proto__: null,
    __wbg_voy_free,
    __wbindgen_add_to_stack_pointer,
    __wbindgen_exn_store,
    __wbindgen_free,
    __wbindgen_malloc,
    __wbindgen_realloc,
    add,
    clear,
    index,
    memory,
    remove,
    search,
    size,
    voy_add,
    voy_clear,
    voy_deserialize,
    voy_index,
    voy_new,
    voy_remove,
    voy_search,
    voy_serialize,
    voy_size
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  __wbg_set_wasm(wasm);
  commonjsRequire = function(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  };
  var localforage$1 = {
    exports: {}
  };
  (function(module2, exports) {
    (function(f2) {
      {
        module2.exports = f2();
      }
    })(function() {
      return function e(t2, n2, r2) {
        function s(o2, u2) {
          if (!n2[o2]) {
            if (!t2[o2]) {
              var a = typeof commonjsRequire == "function" && commonjsRequire;
              if (!u2 && a) return a(o2, true);
              if (i2) return i2(o2, true);
              var f2 = new Error("Cannot find module '" + o2 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n2[o2] = {
              exports: {}
            };
            t2[o2][0].call(l2.exports, function(e2) {
              var n3 = t2[o2][1][e2];
              return s(n3 ? n3 : e2);
            }, l2, l2.exports, e, t2, n2, r2);
          }
          return n2[o2].exports;
        }
        var i2 = typeof commonjsRequire == "function" && commonjsRequire;
        for (var o = 0; o < r2.length; o++) s(r2[o]);
        return s;
      }({
        1: [
          function(_dereq_, module3, exports2) {
            (function(global2) {
              var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
              var scheduleDrain;
              {
                if (Mutation) {
                  var called = 0;
                  var observer = new Mutation(nextTick);
                  var element = global2.document.createTextNode("");
                  observer.observe(element, {
                    characterData: true
                  });
                  scheduleDrain = function() {
                    element.data = called = ++called % 2;
                  };
                } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
                  var channel = new global2.MessageChannel();
                  channel.port1.onmessage = nextTick;
                  scheduleDrain = function() {
                    channel.port2.postMessage(0);
                  };
                } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
                  scheduleDrain = function() {
                    var scriptEl = global2.document.createElement("script");
                    scriptEl.onreadystatechange = function() {
                      nextTick();
                      scriptEl.onreadystatechange = null;
                      scriptEl.parentNode.removeChild(scriptEl);
                      scriptEl = null;
                    };
                    global2.document.documentElement.appendChild(scriptEl);
                  };
                } else {
                  scheduleDrain = function() {
                    setTimeout(nextTick, 0);
                  };
                }
              }
              var draining2;
              var queue2 = [];
              function nextTick() {
                draining2 = true;
                var i2, oldQueue;
                var len2 = queue2.length;
                while (len2) {
                  oldQueue = queue2;
                  queue2 = [];
                  i2 = -1;
                  while (++i2 < len2) {
                    oldQueue[i2]();
                  }
                  len2 = queue2.length;
                }
                draining2 = false;
              }
              module3.exports = immediate;
              function immediate(task) {
                if (queue2.push(task) === 1 && !draining2) {
                  scheduleDrain();
                }
              }
            }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
          },
          {}
        ],
        2: [
          function(_dereq_, module3, exports2) {
            var immediate = _dereq_(1);
            function INTERNAL() {
            }
            var handlers = {};
            var REJECTED = [
              "REJECTED"
            ];
            var FULFILLED = [
              "FULFILLED"
            ];
            var PENDING = [
              "PENDING"
            ];
            module3.exports = Promise2;
            function Promise2(resolver) {
              if (typeof resolver !== "function") {
                throw new TypeError("resolver must be a function");
              }
              this.state = PENDING;
              this.queue = [];
              this.outcome = void 0;
              if (resolver !== INTERNAL) {
                safelyResolveThenable(this, resolver);
              }
            }
            Promise2.prototype["catch"] = function(onRejected) {
              return this.then(null, onRejected);
            };
            Promise2.prototype.then = function(onFulfilled, onRejected) {
              if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
                return this;
              }
              var promise = new this.constructor(INTERNAL);
              if (this.state !== PENDING) {
                var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                unwrap(promise, resolver, this.outcome);
              } else {
                this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
              }
              return promise;
            };
            function QueueItem(promise, onFulfilled, onRejected) {
              this.promise = promise;
              if (typeof onFulfilled === "function") {
                this.onFulfilled = onFulfilled;
                this.callFulfilled = this.otherCallFulfilled;
              }
              if (typeof onRejected === "function") {
                this.onRejected = onRejected;
                this.callRejected = this.otherCallRejected;
              }
            }
            QueueItem.prototype.callFulfilled = function(value) {
              handlers.resolve(this.promise, value);
            };
            QueueItem.prototype.otherCallFulfilled = function(value) {
              unwrap(this.promise, this.onFulfilled, value);
            };
            QueueItem.prototype.callRejected = function(value) {
              handlers.reject(this.promise, value);
            };
            QueueItem.prototype.otherCallRejected = function(value) {
              unwrap(this.promise, this.onRejected, value);
            };
            function unwrap(promise, func, value) {
              immediate(function() {
                var returnValue;
                try {
                  returnValue = func(value);
                } catch (e) {
                  return handlers.reject(promise, e);
                }
                if (returnValue === promise) {
                  handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
                } else {
                  handlers.resolve(promise, returnValue);
                }
              });
            }
            handlers.resolve = function(self2, value) {
              var result = tryCatch(getThen, value);
              if (result.status === "error") {
                return handlers.reject(self2, result.value);
              }
              var thenable = result.value;
              if (thenable) {
                safelyResolveThenable(self2, thenable);
              } else {
                self2.state = FULFILLED;
                self2.outcome = value;
                var i2 = -1;
                var len2 = self2.queue.length;
                while (++i2 < len2) {
                  self2.queue[i2].callFulfilled(value);
                }
              }
              return self2;
            };
            handlers.reject = function(self2, error) {
              self2.state = REJECTED;
              self2.outcome = error;
              var i2 = -1;
              var len2 = self2.queue.length;
              while (++i2 < len2) {
                self2.queue[i2].callRejected(error);
              }
              return self2;
            };
            function getThen(obj) {
              var then = obj && obj.then;
              if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
                return function appyThen() {
                  then.apply(obj, arguments);
                };
              }
            }
            function safelyResolveThenable(self2, thenable) {
              var called = false;
              function onError(value) {
                if (called) {
                  return;
                }
                called = true;
                handlers.reject(self2, value);
              }
              function onSuccess(value) {
                if (called) {
                  return;
                }
                called = true;
                handlers.resolve(self2, value);
              }
              function tryToUnwrap() {
                thenable(onSuccess, onError);
              }
              var result = tryCatch(tryToUnwrap);
              if (result.status === "error") {
                onError(result.value);
              }
            }
            function tryCatch(func, value) {
              var out = {};
              try {
                out.value = func(value);
                out.status = "success";
              } catch (e) {
                out.status = "error";
                out.value = e;
              }
              return out;
            }
            Promise2.resolve = resolve;
            function resolve(value) {
              if (value instanceof this) {
                return value;
              }
              return handlers.resolve(new this(INTERNAL), value);
            }
            Promise2.reject = reject;
            function reject(reason) {
              var promise = new this(INTERNAL);
              return handlers.reject(promise, reason);
            }
            Promise2.all = all;
            function all(iterable) {
              var self2 = this;
              if (Object.prototype.toString.call(iterable) !== "[object Array]") {
                return this.reject(new TypeError("must be an array"));
              }
              var len2 = iterable.length;
              var called = false;
              if (!len2) {
                return this.resolve([]);
              }
              var values = new Array(len2);
              var resolved = 0;
              var i2 = -1;
              var promise = new this(INTERNAL);
              while (++i2 < len2) {
                allResolver(iterable[i2], i2);
              }
              return promise;
              function allResolver(value, i3) {
                self2.resolve(value).then(resolveFromAll, function(error) {
                  if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                  }
                });
                function resolveFromAll(outValue) {
                  values[i3] = outValue;
                  if (++resolved === len2 && !called) {
                    called = true;
                    handlers.resolve(promise, values);
                  }
                }
              }
            }
            Promise2.race = race;
            function race(iterable) {
              var self2 = this;
              if (Object.prototype.toString.call(iterable) !== "[object Array]") {
                return this.reject(new TypeError("must be an array"));
              }
              var len2 = iterable.length;
              var called = false;
              if (!len2) {
                return this.resolve([]);
              }
              var i2 = -1;
              var promise = new this(INTERNAL);
              while (++i2 < len2) {
                resolver(iterable[i2]);
              }
              return promise;
              function resolver(value) {
                self2.resolve(value).then(function(response) {
                  if (!called) {
                    called = true;
                    handlers.resolve(promise, response);
                  }
                }, function(error) {
                  if (!called) {
                    called = true;
                    handlers.reject(promise, error);
                  }
                });
              }
            }
          },
          {
            "1": 1
          }
        ],
        3: [
          function(_dereq_, module3, exports2) {
            (function(global2) {
              if (typeof global2.Promise !== "function") {
                global2.Promise = _dereq_(2);
              }
            }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
          },
          {
            "2": 2
          }
        ],
        4: [
          function(_dereq_, module3, exports2) {
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            function _classCallCheck(instance2, Constructor) {
              if (!(instance2 instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function getIDB() {
              try {
                if (typeof indexedDB !== "undefined") {
                  return indexedDB;
                }
                if (typeof webkitIndexedDB !== "undefined") {
                  return webkitIndexedDB;
                }
                if (typeof mozIndexedDB !== "undefined") {
                  return mozIndexedDB;
                }
                if (typeof OIndexedDB !== "undefined") {
                  return OIndexedDB;
                }
                if (typeof msIndexedDB !== "undefined") {
                  return msIndexedDB;
                }
              } catch (e) {
                return;
              }
            }
            var idb = getIDB();
            function isIndexedDBValid() {
              try {
                if (!idb || !idb.open) {
                  return false;
                }
                var isSafari2 = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
                var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
                return (!isSafari2 || hasFetch) && typeof indexedDB !== "undefined" && typeof IDBKeyRange !== "undefined";
              } catch (e) {
                return false;
              }
            }
            function createBlob(parts, properties) {
              parts = parts || [];
              properties = properties || {};
              try {
                return new Blob(parts, properties);
              } catch (e) {
                if (e.name !== "TypeError") {
                  throw e;
                }
                var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
                var builder = new Builder();
                for (var i2 = 0; i2 < parts.length; i2 += 1) {
                  builder.append(parts[i2]);
                }
                return builder.getBlob(properties.type);
              }
            }
            if (typeof Promise === "undefined") {
              _dereq_(3);
            }
            var Promise$1 = Promise;
            function executeCallback(promise, callback) {
              if (callback) {
                promise.then(function(result) {
                  callback(null, result);
                }, function(error) {
                  callback(error);
                });
              }
            }
            function executeTwoCallbacks(promise, callback, errorCallback) {
              if (typeof callback === "function") {
                promise.then(callback);
              }
              if (typeof errorCallback === "function") {
                promise["catch"](errorCallback);
              }
            }
            function normalizeKey(key2) {
              if (typeof key2 !== "string") {
                console.warn(key2 + " used as a key, but it is not a string.");
                key2 = String(key2);
              }
              return key2;
            }
            function getCallback() {
              if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
                return arguments[arguments.length - 1];
              }
            }
            var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
            var supportsBlobs = void 0;
            var dbContexts = {};
            var toString = Object.prototype.toString;
            var READ_ONLY = "readonly";
            var READ_WRITE = "readwrite";
            function _binStringToArrayBuffer(bin) {
              var length2 = bin.length;
              var buf = new ArrayBuffer(length2);
              var arr2 = new Uint8Array(buf);
              for (var i2 = 0; i2 < length2; i2++) {
                arr2[i2] = bin.charCodeAt(i2);
              }
              return buf;
            }
            function _checkBlobSupportWithoutCaching(idb2) {
              return new Promise$1(function(resolve) {
                var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
                var blob = createBlob([
                  ""
                ]);
                txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
                txn.onabort = function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  resolve(false);
                };
                txn.oncomplete = function() {
                  var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
                  var matchedEdge = navigator.userAgent.match(/Edge\//);
                  resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
                };
              })["catch"](function() {
                return false;
              });
            }
            function _checkBlobSupport(idb2) {
              if (typeof supportsBlobs === "boolean") {
                return Promise$1.resolve(supportsBlobs);
              }
              return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
                supportsBlobs = value;
                return supportsBlobs;
              });
            }
            function _deferReadiness(dbInfo) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = {};
              deferredOperation.promise = new Promise$1(function(resolve, reject) {
                deferredOperation.resolve = resolve;
                deferredOperation.reject = reject;
              });
              dbContext.deferredOperations.push(deferredOperation);
              if (!dbContext.dbReady) {
                dbContext.dbReady = deferredOperation.promise;
              } else {
                dbContext.dbReady = dbContext.dbReady.then(function() {
                  return deferredOperation.promise;
                });
              }
            }
            function _advanceReadiness(dbInfo) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = dbContext.deferredOperations.pop();
              if (deferredOperation) {
                deferredOperation.resolve();
                return deferredOperation.promise;
              }
            }
            function _rejectReadiness(dbInfo, err) {
              var dbContext = dbContexts[dbInfo.name];
              var deferredOperation = dbContext.deferredOperations.pop();
              if (deferredOperation) {
                deferredOperation.reject(err);
                return deferredOperation.promise;
              }
            }
            function _getConnection(dbInfo, upgradeNeeded) {
              return new Promise$1(function(resolve, reject) {
                dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
                if (dbInfo.db) {
                  if (upgradeNeeded) {
                    _deferReadiness(dbInfo);
                    dbInfo.db.close();
                  } else {
                    return resolve(dbInfo.db);
                  }
                }
                var dbArgs = [
                  dbInfo.name
                ];
                if (upgradeNeeded) {
                  dbArgs.push(dbInfo.version);
                }
                var openreq = idb.open.apply(idb, dbArgs);
                if (upgradeNeeded) {
                  openreq.onupgradeneeded = function(e) {
                    var db2 = openreq.result;
                    try {
                      db2.createObjectStore(dbInfo.storeName);
                      if (e.oldVersion <= 1) {
                        db2.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                      }
                    } catch (ex) {
                      if (ex.name === "ConstraintError") {
                        console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                      } else {
                        throw ex;
                      }
                    }
                  };
                }
                openreq.onerror = function(e) {
                  e.preventDefault();
                  reject(openreq.error);
                };
                openreq.onsuccess = function() {
                  var db2 = openreq.result;
                  db2.onversionchange = function(e) {
                    e.target.close();
                  };
                  resolve(db2);
                  _advanceReadiness(dbInfo);
                };
              });
            }
            function _getOriginalConnection(dbInfo) {
              return _getConnection(dbInfo, false);
            }
            function _getUpgradedConnection(dbInfo) {
              return _getConnection(dbInfo, true);
            }
            function _isUpgradeNeeded(dbInfo, defaultVersion) {
              if (!dbInfo.db) {
                return true;
              }
              var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
              var isDowngrade = dbInfo.version < dbInfo.db.version;
              var isUpgrade = dbInfo.version > dbInfo.db.version;
              if (isDowngrade) {
                if (dbInfo.version !== defaultVersion) {
                  console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
                }
                dbInfo.version = dbInfo.db.version;
              }
              if (isUpgrade || isNewStore) {
                if (isNewStore) {
                  var incVersion = dbInfo.db.version + 1;
                  if (incVersion > dbInfo.version) {
                    dbInfo.version = incVersion;
                  }
                }
                return true;
              }
              return false;
            }
            function _encodeBlob(blob) {
              return new Promise$1(function(resolve, reject) {
                var reader = new FileReader();
                reader.onerror = reject;
                reader.onloadend = function(e) {
                  var base64 = btoa(e.target.result || "");
                  resolve({
                    __local_forage_encoded_blob: true,
                    data: base64,
                    type: blob.type
                  });
                };
                reader.readAsBinaryString(blob);
              });
            }
            function _decodeBlob(encodedBlob) {
              var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
              return createBlob([
                arrayBuff
              ], {
                type: encodedBlob.type
              });
            }
            function _isEncodedBlob(value) {
              return value && value.__local_forage_encoded_blob;
            }
            function _fullyReady(callback) {
              var self2 = this;
              var promise = self2._initReady().then(function() {
                var dbContext = dbContexts[self2._dbInfo.name];
                if (dbContext && dbContext.dbReady) {
                  return dbContext.dbReady;
                }
              });
              executeTwoCallbacks(promise, callback, callback);
              return promise;
            }
            function _tryReconnect(dbInfo) {
              _deferReadiness(dbInfo);
              var dbContext = dbContexts[dbInfo.name];
              var forages = dbContext.forages;
              for (var i2 = 0; i2 < forages.length; i2++) {
                var forage = forages[i2];
                if (forage._dbInfo.db) {
                  forage._dbInfo.db.close();
                  forage._dbInfo.db = null;
                }
              }
              dbInfo.db = null;
              return _getOriginalConnection(dbInfo).then(function(db2) {
                dbInfo.db = db2;
                if (_isUpgradeNeeded(dbInfo)) {
                  return _getUpgradedConnection(dbInfo);
                }
                return db2;
              }).then(function(db2) {
                dbInfo.db = dbContext.db = db2;
                for (var i3 = 0; i3 < forages.length; i3++) {
                  forages[i3]._dbInfo.db = db2;
                }
              })["catch"](function(err) {
                _rejectReadiness(dbInfo, err);
                throw err;
              });
            }
            function createTransaction(dbInfo, mode, callback, retries) {
              if (retries === void 0) {
                retries = 1;
              }
              try {
                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
                callback(null, tx);
              } catch (err) {
                if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
                  return Promise$1.resolve().then(function() {
                    if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                      if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                      }
                      return _getUpgradedConnection(dbInfo);
                    }
                  }).then(function() {
                    return _tryReconnect(dbInfo).then(function() {
                      createTransaction(dbInfo, mode, callback, retries - 1);
                    });
                  })["catch"](callback);
                }
                callback(err);
              }
            }
            function createDbContext() {
              return {
                forages: [],
                db: null,
                dbReady: null,
                deferredOperations: []
              };
            }
            function _initStorage(options) {
              var self2 = this;
              var dbInfo = {
                db: null
              };
              if (options) {
                for (var i2 in options) {
                  dbInfo[i2] = options[i2];
                }
              }
              var dbContext = dbContexts[dbInfo.name];
              if (!dbContext) {
                dbContext = createDbContext();
                dbContexts[dbInfo.name] = dbContext;
              }
              dbContext.forages.push(self2);
              if (!self2._initReady) {
                self2._initReady = self2.ready;
                self2.ready = _fullyReady;
              }
              var initPromises = [];
              function ignoreErrors() {
                return Promise$1.resolve();
              }
              for (var j = 0; j < dbContext.forages.length; j++) {
                var forage = dbContext.forages[j];
                if (forage !== self2) {
                  initPromises.push(forage._initReady()["catch"](ignoreErrors));
                }
              }
              var forages = dbContext.forages.slice(0);
              return Promise$1.all(initPromises).then(function() {
                dbInfo.db = dbContext.db;
                return _getOriginalConnection(dbInfo);
              }).then(function(db2) {
                dbInfo.db = db2;
                if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
                  return _getUpgradedConnection(dbInfo);
                }
                return db2;
              }).then(function(db2) {
                dbInfo.db = dbContext.db = db2;
                self2._dbInfo = dbInfo;
                for (var k2 = 0; k2 < forages.length; k2++) {
                  var forage2 = forages[k2];
                  if (forage2 !== self2) {
                    forage2._dbInfo.db = dbInfo.db;
                    forage2._dbInfo.version = dbInfo.version;
                  }
                }
              });
            }
            function getItem(key2, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.get(key2);
                      req.onsuccess = function() {
                        var value = req.result;
                        if (value === void 0) {
                          value = null;
                        }
                        if (_isEncodedBlob(value)) {
                          value = _decodeBlob(value);
                        }
                        resolve(value);
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function iterate(iterator, callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.openCursor();
                      var iterationNumber = 1;
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (cursor) {
                          var value = cursor.value;
                          if (_isEncodedBlob(value)) {
                            value = _decodeBlob(value);
                          }
                          var result = iterator(value, cursor.key, iterationNumber++);
                          if (result !== void 0) {
                            resolve(result);
                          } else {
                            cursor["continue"]();
                          }
                        } else {
                          resolve();
                        }
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function setItem(key2, value, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                var dbInfo;
                self2.ready().then(function() {
                  dbInfo = self2._dbInfo;
                  if (toString.call(value) === "[object Blob]") {
                    return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                      if (blobSupport) {
                        return value;
                      }
                      return _encodeBlob(value);
                    });
                  }
                  return value;
                }).then(function(value2) {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      if (value2 === null) {
                        value2 = void 0;
                      }
                      var req = store.put(value2, key2);
                      transaction.oncomplete = function() {
                        if (value2 === void 0) {
                          value2 = null;
                        }
                        resolve(value2);
                      };
                      transaction.onabort = transaction.onerror = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function removeItem2(key2, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store["delete"](key2);
                      transaction.oncomplete = function() {
                        resolve();
                      };
                      transaction.onerror = function() {
                        reject(req.error);
                      };
                      transaction.onabort = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function clear2(callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.clear();
                      transaction.oncomplete = function() {
                        resolve();
                      };
                      transaction.onabort = transaction.onerror = function() {
                        var err2 = req.error ? req.error : req.transaction.error;
                        reject(err2);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function length(callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.count();
                      req.onsuccess = function() {
                        resolve(req.result);
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function key(n2, callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                if (n2 < 0) {
                  resolve(null);
                  return;
                }
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var advanced = false;
                      var req = store.openKeyCursor();
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (!cursor) {
                          resolve(null);
                          return;
                        }
                        if (n2 === 0) {
                          resolve(cursor.key);
                        } else {
                          if (!advanced) {
                            advanced = true;
                            cursor.advance(n2);
                          } else {
                            resolve(cursor.key);
                          }
                        }
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function keys(callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                    if (err) {
                      return reject(err);
                    }
                    try {
                      var store = transaction.objectStore(self2._dbInfo.storeName);
                      var req = store.openKeyCursor();
                      var keys2 = [];
                      req.onsuccess = function() {
                        var cursor = req.result;
                        if (!cursor) {
                          resolve(keys2);
                          return;
                        }
                        keys2.push(cursor.key);
                        cursor["continue"]();
                      };
                      req.onerror = function() {
                        reject(req.error);
                      };
                    } catch (e) {
                      reject(e);
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function dropInstance(options, callback) {
              callback = getCallback.apply(this, arguments);
              var currentConfig = this.config();
              options = typeof options !== "function" && options || {};
              if (!options.name) {
                options.name = options.name || currentConfig.name;
                options.storeName = options.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options.name) {
                promise = Promise$1.reject("Invalid arguments");
              } else {
                var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
                var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db2) {
                  var dbContext = dbContexts[options.name];
                  var forages = dbContext.forages;
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    forages[i2]._dbInfo.db = db2;
                  }
                  return db2;
                });
                if (!options.storeName) {
                  promise = dbPromise.then(function(db2) {
                    _deferReadiness(options);
                    var dbContext = dbContexts[options.name];
                    var forages = dbContext.forages;
                    db2.close();
                    for (var i2 = 0; i2 < forages.length; i2++) {
                      var forage = forages[i2];
                      forage._dbInfo.db = null;
                    }
                    var dropDBPromise = new Promise$1(function(resolve, reject) {
                      var req = idb.deleteDatabase(options.name);
                      req.onerror = function() {
                        var db3 = req.result;
                        if (db3) {
                          db3.close();
                        }
                        reject(req.error);
                      };
                      req.onblocked = function() {
                        console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                      };
                      req.onsuccess = function() {
                        var db3 = req.result;
                        if (db3) {
                          db3.close();
                        }
                        resolve(db3);
                      };
                    });
                    return dropDBPromise.then(function(db3) {
                      dbContext.db = db3;
                      for (var i3 = 0; i3 < forages.length; i3++) {
                        var _forage = forages[i3];
                        _advanceReadiness(_forage._dbInfo);
                      }
                    })["catch"](function(err) {
                      (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                      });
                      throw err;
                    });
                  });
                } else {
                  promise = dbPromise.then(function(db2) {
                    if (!db2.objectStoreNames.contains(options.storeName)) {
                      return;
                    }
                    var newVersion = db2.version + 1;
                    _deferReadiness(options);
                    var dbContext = dbContexts[options.name];
                    var forages = dbContext.forages;
                    db2.close();
                    for (var i2 = 0; i2 < forages.length; i2++) {
                      var forage = forages[i2];
                      forage._dbInfo.db = null;
                      forage._dbInfo.version = newVersion;
                    }
                    var dropObjectPromise = new Promise$1(function(resolve, reject) {
                      var req = idb.open(options.name, newVersion);
                      req.onerror = function(err) {
                        var db3 = req.result;
                        db3.close();
                        reject(err);
                      };
                      req.onupgradeneeded = function() {
                        var db3 = req.result;
                        db3.deleteObjectStore(options.storeName);
                      };
                      req.onsuccess = function() {
                        var db3 = req.result;
                        db3.close();
                        resolve(db3);
                      };
                    });
                    return dropObjectPromise.then(function(db3) {
                      dbContext.db = db3;
                      for (var j = 0; j < forages.length; j++) {
                        var _forage2 = forages[j];
                        _forage2._dbInfo.db = db3;
                        _advanceReadiness(_forage2._dbInfo);
                      }
                    })["catch"](function(err) {
                      (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                      });
                      throw err;
                    });
                  });
                }
              }
              executeCallback(promise, callback);
              return promise;
            }
            var asyncStorage = {
              _driver: "asyncStorage",
              _initStorage,
              _support: isIndexedDBValid(),
              iterate,
              getItem,
              setItem,
              removeItem: removeItem2,
              clear: clear2,
              length,
              key,
              keys,
              dropInstance
            };
            function isWebSQLValid() {
              return typeof openDatabase === "function";
            }
            var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var BLOB_TYPE_PREFIX = "~~local_forage_type~";
            var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
            var SERIALIZED_MARKER = "__lfsc__:";
            var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
            var TYPE_ARRAYBUFFER = "arbf";
            var TYPE_BLOB = "blob";
            var TYPE_INT8ARRAY = "si08";
            var TYPE_UINT8ARRAY = "ui08";
            var TYPE_UINT8CLAMPEDARRAY = "uic8";
            var TYPE_INT16ARRAY = "si16";
            var TYPE_INT32ARRAY = "si32";
            var TYPE_UINT16ARRAY = "ur16";
            var TYPE_UINT32ARRAY = "ui32";
            var TYPE_FLOAT32ARRAY = "fl32";
            var TYPE_FLOAT64ARRAY = "fl64";
            var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
            var toString$1 = Object.prototype.toString;
            function stringToBuffer(serializedString) {
              var bufferLength = serializedString.length * 0.75;
              var len2 = serializedString.length;
              var i2;
              var p2 = 0;
              var encoded1, encoded2, encoded3, encoded4;
              if (serializedString[serializedString.length - 1] === "=") {
                bufferLength--;
                if (serializedString[serializedString.length - 2] === "=") {
                  bufferLength--;
                }
              }
              var buffer2 = new ArrayBuffer(bufferLength);
              var bytes = new Uint8Array(buffer2);
              for (i2 = 0; i2 < len2; i2 += 4) {
                encoded1 = BASE_CHARS.indexOf(serializedString[i2]);
                encoded2 = BASE_CHARS.indexOf(serializedString[i2 + 1]);
                encoded3 = BASE_CHARS.indexOf(serializedString[i2 + 2]);
                encoded4 = BASE_CHARS.indexOf(serializedString[i2 + 3]);
                bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
                bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
              }
              return buffer2;
            }
            function bufferToString(buffer2) {
              var bytes = new Uint8Array(buffer2);
              var base64String = "";
              var i2;
              for (i2 = 0; i2 < bytes.length; i2 += 3) {
                base64String += BASE_CHARS[bytes[i2] >> 2];
                base64String += BASE_CHARS[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
                base64String += BASE_CHARS[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
                base64String += BASE_CHARS[bytes[i2 + 2] & 63];
              }
              if (bytes.length % 3 === 2) {
                base64String = base64String.substring(0, base64String.length - 1) + "=";
              } else if (bytes.length % 3 === 1) {
                base64String = base64String.substring(0, base64String.length - 2) + "==";
              }
              return base64String;
            }
            function serialize(value, callback) {
              var valueType = "";
              if (value) {
                valueType = toString$1.call(value);
              }
              if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
                var buffer2;
                var marker = SERIALIZED_MARKER;
                if (value instanceof ArrayBuffer) {
                  buffer2 = value;
                  marker += TYPE_ARRAYBUFFER;
                } else {
                  buffer2 = value.buffer;
                  if (valueType === "[object Int8Array]") {
                    marker += TYPE_INT8ARRAY;
                  } else if (valueType === "[object Uint8Array]") {
                    marker += TYPE_UINT8ARRAY;
                  } else if (valueType === "[object Uint8ClampedArray]") {
                    marker += TYPE_UINT8CLAMPEDARRAY;
                  } else if (valueType === "[object Int16Array]") {
                    marker += TYPE_INT16ARRAY;
                  } else if (valueType === "[object Uint16Array]") {
                    marker += TYPE_UINT16ARRAY;
                  } else if (valueType === "[object Int32Array]") {
                    marker += TYPE_INT32ARRAY;
                  } else if (valueType === "[object Uint32Array]") {
                    marker += TYPE_UINT32ARRAY;
                  } else if (valueType === "[object Float32Array]") {
                    marker += TYPE_FLOAT32ARRAY;
                  } else if (valueType === "[object Float64Array]") {
                    marker += TYPE_FLOAT64ARRAY;
                  } else {
                    callback(new Error("Failed to get type for BinaryArray"));
                  }
                }
                callback(marker + bufferToString(buffer2));
              } else if (valueType === "[object Blob]") {
                var fileReader = new FileReader();
                fileReader.onload = function() {
                  var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
                  callback(SERIALIZED_MARKER + TYPE_BLOB + str);
                };
                fileReader.readAsArrayBuffer(value);
              } else {
                try {
                  callback(JSON.stringify(value));
                } catch (e) {
                  console.error("Couldn't convert value into a JSON string: ", value);
                  callback(null, e);
                }
              }
            }
            function deserialize(value) {
              if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
                return JSON.parse(value);
              }
              var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
              var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
              var blobType;
              if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
                var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
                blobType = matcher[1];
                serializedString = serializedString.substring(matcher[0].length);
              }
              var buffer2 = stringToBuffer(serializedString);
              switch (type) {
                case TYPE_ARRAYBUFFER:
                  return buffer2;
                case TYPE_BLOB:
                  return createBlob([
                    buffer2
                  ], {
                    type: blobType
                  });
                case TYPE_INT8ARRAY:
                  return new Int8Array(buffer2);
                case TYPE_UINT8ARRAY:
                  return new Uint8Array(buffer2);
                case TYPE_UINT8CLAMPEDARRAY:
                  return new Uint8ClampedArray(buffer2);
                case TYPE_INT16ARRAY:
                  return new Int16Array(buffer2);
                case TYPE_UINT16ARRAY:
                  return new Uint16Array(buffer2);
                case TYPE_INT32ARRAY:
                  return new Int32Array(buffer2);
                case TYPE_UINT32ARRAY:
                  return new Uint32Array(buffer2);
                case TYPE_FLOAT32ARRAY:
                  return new Float32Array(buffer2);
                case TYPE_FLOAT64ARRAY:
                  return new Float64Array(buffer2);
                default:
                  throw new Error("Unkown type: " + type);
              }
            }
            var localforageSerializer = {
              serialize,
              deserialize,
              stringToBuffer,
              bufferToString
            };
            function createDbTable(t2, dbInfo, callback, errorCallback) {
              t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
            }
            function _initStorage$1(options) {
              var self2 = this;
              var dbInfo = {
                db: null
              };
              if (options) {
                for (var i2 in options) {
                  dbInfo[i2] = typeof options[i2] !== "string" ? options[i2].toString() : options[i2];
                }
              }
              var dbInfoPromise = new Promise$1(function(resolve, reject) {
                try {
                  dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
                } catch (e) {
                  return reject(e);
                }
                dbInfo.db.transaction(function(t2) {
                  createDbTable(t2, dbInfo, function() {
                    self2._dbInfo = dbInfo;
                    resolve();
                  }, function(t3, error) {
                    reject(error);
                  });
                }, reject);
              });
              dbInfo.serializer = localforageSerializer;
              return dbInfoPromise;
            }
            function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
              t2.executeSql(sqlStatement, args, callback, function(t3, error) {
                if (error.code === error.SYNTAX_ERR) {
                  t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [
                    dbInfo.storeName
                  ], function(t4, results) {
                    if (!results.rows.length) {
                      createDbTable(t4, dbInfo, function() {
                        t4.executeSql(sqlStatement, args, callback, errorCallback);
                      }, errorCallback);
                    } else {
                      errorCallback(t4, error);
                    }
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            }
            function getItem$1(key2, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [
                      key2
                    ], function(t3, results) {
                      var result = results.rows.length ? results.rows.item(0).value : null;
                      if (result) {
                        result = dbInfo.serializer.deserialize(result);
                      }
                      resolve(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function iterate$1(iterator, callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                      var rows = results.rows;
                      var length2 = rows.length;
                      for (var i2 = 0; i2 < length2; i2++) {
                        var item = rows.item(i2);
                        var result = item.value;
                        if (result) {
                          result = dbInfo.serializer.deserialize(result);
                        }
                        result = iterator(result, item.key, i2 + 1);
                        if (result !== void 0) {
                          resolve(result);
                          return;
                        }
                      }
                      resolve();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function _setItem(key2, value, callback, retriesLeft) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  if (value === void 0) {
                    value = null;
                  }
                  var originalValue = value;
                  var dbInfo = self2._dbInfo;
                  dbInfo.serializer.serialize(value, function(value2, error) {
                    if (error) {
                      reject(error);
                    } else {
                      dbInfo.db.transaction(function(t2) {
                        tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [
                          key2,
                          value2
                        ], function() {
                          resolve(originalValue);
                        }, function(t3, error2) {
                          reject(error2);
                        });
                      }, function(sqlError) {
                        if (sqlError.code === sqlError.QUOTA_ERR) {
                          if (retriesLeft > 0) {
                            resolve(_setItem.apply(self2, [
                              key2,
                              originalValue,
                              callback,
                              retriesLeft - 1
                            ]));
                            return;
                          }
                          reject(sqlError);
                        }
                      });
                    }
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function setItem$1(key2, value, callback) {
              return _setItem.apply(this, [
                key2,
                value,
                callback,
                1
              ]);
            }
            function removeItem$1(key2, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [
                      key2
                    ], function() {
                      resolve();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function clear$1(callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                      resolve();
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function length$1(callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                      var result = results.rows.item(0).c;
                      resolve(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function key$1(n2, callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [
                      n2 + 1
                    ], function(t3, results) {
                      var result = results.rows.length ? results.rows.item(0).key : null;
                      resolve(result);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function keys$1(callback) {
              var self2 = this;
              var promise = new Promise$1(function(resolve, reject) {
                self2.ready().then(function() {
                  var dbInfo = self2._dbInfo;
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                      var keys2 = [];
                      for (var i2 = 0; i2 < results.rows.length; i2++) {
                        keys2.push(results.rows.item(i2).key);
                      }
                      resolve(keys2);
                    }, function(t3, error) {
                      reject(error);
                    });
                  });
                })["catch"](reject);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function getAllStoreNames(db2) {
              return new Promise$1(function(resolve, reject) {
                db2.transaction(function(t2) {
                  t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
                    var storeNames = [];
                    for (var i2 = 0; i2 < results.rows.length; i2++) {
                      storeNames.push(results.rows.item(i2).name);
                    }
                    resolve({
                      db: db2,
                      storeNames
                    });
                  }, function(t3, error) {
                    reject(error);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            }
            function dropInstance$1(options, callback) {
              callback = getCallback.apply(this, arguments);
              var currentConfig = this.config();
              options = typeof options !== "function" && options || {};
              if (!options.name) {
                options.name = options.name || currentConfig.name;
                options.storeName = options.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options.name) {
                promise = Promise$1.reject("Invalid arguments");
              } else {
                promise = new Promise$1(function(resolve) {
                  var db2;
                  if (options.name === currentConfig.name) {
                    db2 = self2._dbInfo.db;
                  } else {
                    db2 = openDatabase(options.name, "", "", 0);
                  }
                  if (!options.storeName) {
                    resolve(getAllStoreNames(db2));
                  } else {
                    resolve({
                      db: db2,
                      storeNames: [
                        options.storeName
                      ]
                    });
                  }
                }).then(function(operationInfo) {
                  return new Promise$1(function(resolve, reject) {
                    operationInfo.db.transaction(function(t2) {
                      function dropTable(storeName) {
                        return new Promise$1(function(resolve2, reject2) {
                          t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                            resolve2();
                          }, function(t3, error) {
                            reject2(error);
                          });
                        });
                      }
                      var operations = [];
                      for (var i2 = 0, len2 = operationInfo.storeNames.length; i2 < len2; i2++) {
                        operations.push(dropTable(operationInfo.storeNames[i2]));
                      }
                      Promise$1.all(operations).then(function() {
                        resolve();
                      })["catch"](function(e) {
                        reject(e);
                      });
                    }, function(sqlError) {
                      reject(sqlError);
                    });
                  });
                });
              }
              executeCallback(promise, callback);
              return promise;
            }
            var webSQLStorage = {
              _driver: "webSQLStorage",
              _initStorage: _initStorage$1,
              _support: isWebSQLValid(),
              iterate: iterate$1,
              getItem: getItem$1,
              setItem: setItem$1,
              removeItem: removeItem$1,
              clear: clear$1,
              length: length$1,
              key: key$1,
              keys: keys$1,
              dropInstance: dropInstance$1
            };
            function isLocalStorageValid() {
              try {
                return typeof localStorage !== "undefined" && "setItem" in localStorage && !!localStorage.setItem;
              } catch (e) {
                return false;
              }
            }
            function _getKeyPrefix(options, defaultConfig) {
              var keyPrefix = options.name + "/";
              if (options.storeName !== defaultConfig.storeName) {
                keyPrefix += options.storeName + "/";
              }
              return keyPrefix;
            }
            function checkIfLocalStorageThrows() {
              var localStorageTestKey = "_localforage_support_test";
              try {
                localStorage.setItem(localStorageTestKey, true);
                localStorage.removeItem(localStorageTestKey);
                return false;
              } catch (e) {
                return true;
              }
            }
            function _isLocalStorageUsable() {
              return !checkIfLocalStorageThrows() || localStorage.length > 0;
            }
            function _initStorage$2(options) {
              var self2 = this;
              var dbInfo = {};
              if (options) {
                for (var i2 in options) {
                  dbInfo[i2] = options[i2];
                }
              }
              dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
              if (!_isLocalStorageUsable()) {
                return Promise$1.reject();
              }
              self2._dbInfo = dbInfo;
              dbInfo.serializer = localforageSerializer;
              return Promise$1.resolve();
            }
            function clear$2(callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var keyPrefix = self2._dbInfo.keyPrefix;
                for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
                  var key2 = localStorage.key(i2);
                  if (key2.indexOf(keyPrefix) === 0) {
                    localStorage.removeItem(key2);
                  }
                }
              });
              executeCallback(promise, callback);
              return promise;
            }
            function getItem$2(key2, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var result = localStorage.getItem(dbInfo.keyPrefix + key2);
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                return result;
              });
              executeCallback(promise, callback);
              return promise;
            }
            function iterate$2(iterator, callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var keyPrefix = dbInfo.keyPrefix;
                var keyPrefixLength = keyPrefix.length;
                var length2 = localStorage.length;
                var iterationNumber = 1;
                for (var i2 = 0; i2 < length2; i2++) {
                  var key2 = localStorage.key(i2);
                  if (key2.indexOf(keyPrefix) !== 0) {
                    continue;
                  }
                  var value = localStorage.getItem(key2);
                  if (value) {
                    value = dbInfo.serializer.deserialize(value);
                  }
                  value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
                  if (value !== void 0) {
                    return value;
                  }
                }
              });
              executeCallback(promise, callback);
              return promise;
            }
            function key$2(n2, callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var result;
                try {
                  result = localStorage.key(n2);
                } catch (error) {
                  result = null;
                }
                if (result) {
                  result = result.substring(dbInfo.keyPrefix.length);
                }
                return result;
              });
              executeCallback(promise, callback);
              return promise;
            }
            function keys$2(callback) {
              var self2 = this;
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                var length2 = localStorage.length;
                var keys2 = [];
                for (var i2 = 0; i2 < length2; i2++) {
                  var itemKey = localStorage.key(i2);
                  if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                    keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
                  }
                }
                return keys2;
              });
              executeCallback(promise, callback);
              return promise;
            }
            function length$2(callback) {
              var self2 = this;
              var promise = self2.keys().then(function(keys2) {
                return keys2.length;
              });
              executeCallback(promise, callback);
              return promise;
            }
            function removeItem$2(key2, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = self2.ready().then(function() {
                var dbInfo = self2._dbInfo;
                localStorage.removeItem(dbInfo.keyPrefix + key2);
              });
              executeCallback(promise, callback);
              return promise;
            }
            function setItem$2(key2, value, callback) {
              var self2 = this;
              key2 = normalizeKey(key2);
              var promise = self2.ready().then(function() {
                if (value === void 0) {
                  value = null;
                }
                var originalValue = value;
                return new Promise$1(function(resolve, reject) {
                  var dbInfo = self2._dbInfo;
                  dbInfo.serializer.serialize(value, function(value2, error) {
                    if (error) {
                      reject(error);
                    } else {
                      try {
                        localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                        resolve(originalValue);
                      } catch (e) {
                        if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                          reject(e);
                        }
                        reject(e);
                      }
                    }
                  });
                });
              });
              executeCallback(promise, callback);
              return promise;
            }
            function dropInstance$2(options, callback) {
              callback = getCallback.apply(this, arguments);
              options = typeof options !== "function" && options || {};
              if (!options.name) {
                var currentConfig = this.config();
                options.name = options.name || currentConfig.name;
                options.storeName = options.storeName || currentConfig.storeName;
              }
              var self2 = this;
              var promise;
              if (!options.name) {
                promise = Promise$1.reject("Invalid arguments");
              } else {
                promise = new Promise$1(function(resolve) {
                  if (!options.storeName) {
                    resolve(options.name + "/");
                  } else {
                    resolve(_getKeyPrefix(options, self2._defaultConfig));
                  }
                }).then(function(keyPrefix) {
                  for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
                    var key2 = localStorage.key(i2);
                    if (key2.indexOf(keyPrefix) === 0) {
                      localStorage.removeItem(key2);
                    }
                  }
                });
              }
              executeCallback(promise, callback);
              return promise;
            }
            var localStorageWrapper = {
              _driver: "localStorageWrapper",
              _initStorage: _initStorage$2,
              _support: isLocalStorageValid(),
              iterate: iterate$2,
              getItem: getItem$2,
              setItem: setItem$2,
              removeItem: removeItem$2,
              clear: clear$2,
              length: length$2,
              key: key$2,
              keys: keys$2,
              dropInstance: dropInstance$2
            };
            var sameValue = function sameValue2(x2, y2) {
              return x2 === y2 || typeof x2 === "number" && typeof y2 === "number" && isNaN(x2) && isNaN(y2);
            };
            var includes = function includes2(array, searchElement) {
              var len2 = array.length;
              var i2 = 0;
              while (i2 < len2) {
                if (sameValue(array[i2], searchElement)) {
                  return true;
                }
                i2++;
              }
              return false;
            };
            var isArray = Array.isArray || function(arg) {
              return Object.prototype.toString.call(arg) === "[object Array]";
            };
            var DefinedDrivers = {};
            var DriverSupport = {};
            var DefaultDrivers = {
              INDEXEDDB: asyncStorage,
              WEBSQL: webSQLStorage,
              LOCALSTORAGE: localStorageWrapper
            };
            var DefaultDriverOrder = [
              DefaultDrivers.INDEXEDDB._driver,
              DefaultDrivers.WEBSQL._driver,
              DefaultDrivers.LOCALSTORAGE._driver
            ];
            var OptionalDriverMethods = [
              "dropInstance"
            ];
            var LibraryMethods = [
              "clear",
              "getItem",
              "iterate",
              "key",
              "keys",
              "length",
              "removeItem",
              "setItem"
            ].concat(OptionalDriverMethods);
            var DefaultConfig = {
              description: "",
              driver: DefaultDriverOrder.slice(),
              name: "localforage",
              size: 4980736,
              storeName: "keyvaluepairs",
              version: 1
            };
            function callWhenReady(localForageInstance, libraryMethod) {
              localForageInstance[libraryMethod] = function() {
                var _args = arguments;
                return localForageInstance.ready().then(function() {
                  return localForageInstance[libraryMethod].apply(localForageInstance, _args);
                });
              };
            }
            function extend() {
              for (var i2 = 1; i2 < arguments.length; i2++) {
                var arg = arguments[i2];
                if (arg) {
                  for (var _key in arg) {
                    if (arg.hasOwnProperty(_key)) {
                      if (isArray(arg[_key])) {
                        arguments[0][_key] = arg[_key].slice();
                      } else {
                        arguments[0][_key] = arg[_key];
                      }
                    }
                  }
                }
              }
              return arguments[0];
            }
            var LocalForage = function() {
              function LocalForage2(options) {
                _classCallCheck(this, LocalForage2);
                for (var driverTypeKey in DefaultDrivers) {
                  if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                    var driver = DefaultDrivers[driverTypeKey];
                    var driverName = driver._driver;
                    this[driverTypeKey] = driverName;
                    if (!DefinedDrivers[driverName]) {
                      this.defineDriver(driver);
                    }
                  }
                }
                this._defaultConfig = extend({}, DefaultConfig);
                this._config = extend({}, this._defaultConfig, options);
                this._driverSet = null;
                this._initDriver = null;
                this._ready = false;
                this._dbInfo = null;
                this._wrapLibraryMethodsWithReady();
                this.setDriver(this._config.driver)["catch"](function() {
                });
              }
              LocalForage2.prototype.config = function config(options) {
                if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
                  if (this._ready) {
                    return new Error("Can't call config() after localforage has been used.");
                  }
                  for (var i2 in options) {
                    if (i2 === "storeName") {
                      options[i2] = options[i2].replace(/\W/g, "_");
                    }
                    if (i2 === "version" && typeof options[i2] !== "number") {
                      return new Error("Database version must be a number.");
                    }
                    this._config[i2] = options[i2];
                  }
                  if ("driver" in options && options.driver) {
                    return this.setDriver(this._config.driver);
                  }
                  return true;
                } else if (typeof options === "string") {
                  return this._config[options];
                } else {
                  return this._config;
                }
              };
              LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
                var promise = new Promise$1(function(resolve, reject) {
                  try {
                    var driverName = driverObject._driver;
                    var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                    if (!driverObject._driver) {
                      reject(complianceError);
                      return;
                    }
                    var driverMethods = LibraryMethods.concat("_initStorage");
                    for (var i2 = 0, len2 = driverMethods.length; i2 < len2; i2++) {
                      var driverMethodName = driverMethods[i2];
                      var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                      if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                        reject(complianceError);
                        return;
                      }
                    }
                    var configureMissingMethods = function configureMissingMethods2() {
                      var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                        return function() {
                          var error = new Error("Method " + methodName + " is not implemented by the current driver");
                          var promise2 = Promise$1.reject(error);
                          executeCallback(promise2, arguments[arguments.length - 1]);
                          return promise2;
                        };
                      };
                      for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                        var optionalDriverMethod = OptionalDriverMethods[_i];
                        if (!driverObject[optionalDriverMethod]) {
                          driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                        }
                      }
                    };
                    configureMissingMethods();
                    var setDriverSupport = function setDriverSupport2(support) {
                      if (DefinedDrivers[driverName]) {
                        console.info("Redefining LocalForage driver: " + driverName);
                      }
                      DefinedDrivers[driverName] = driverObject;
                      DriverSupport[driverName] = support;
                      resolve();
                    };
                    if ("_support" in driverObject) {
                      if (driverObject._support && typeof driverObject._support === "function") {
                        driverObject._support().then(setDriverSupport, reject);
                      } else {
                        setDriverSupport(!!driverObject._support);
                      }
                    } else {
                      setDriverSupport(true);
                    }
                  } catch (e) {
                    reject(e);
                  }
                });
                executeTwoCallbacks(promise, callback, errorCallback);
                return promise;
              };
              LocalForage2.prototype.driver = function driver() {
                return this._driver || null;
              };
              LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
                var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
                executeTwoCallbacks(getDriverPromise, callback, errorCallback);
                return getDriverPromise;
              };
              LocalForage2.prototype.getSerializer = function getSerializer(callback) {
                var serializerPromise = Promise$1.resolve(localforageSerializer);
                executeTwoCallbacks(serializerPromise, callback);
                return serializerPromise;
              };
              LocalForage2.prototype.ready = function ready(callback) {
                var self2 = this;
                var promise = self2._driverSet.then(function() {
                  if (self2._ready === null) {
                    self2._ready = self2._initDriver();
                  }
                  return self2._ready;
                });
                executeTwoCallbacks(promise, callback, callback);
                return promise;
              };
              LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
                var self2 = this;
                if (!isArray(drivers)) {
                  drivers = [
                    drivers
                  ];
                }
                var supportedDrivers = this._getSupportedDrivers(drivers);
                function setDriverToConfig() {
                  self2._config.driver = self2.driver();
                }
                function extendSelfWithDriver(driver) {
                  self2._extend(driver);
                  setDriverToConfig();
                  self2._ready = self2._initStorage(self2._config);
                  return self2._ready;
                }
                function initDriver(supportedDrivers2) {
                  return function() {
                    var currentDriverIndex = 0;
                    function driverPromiseLoop() {
                      while (currentDriverIndex < supportedDrivers2.length) {
                        var driverName = supportedDrivers2[currentDriverIndex];
                        currentDriverIndex++;
                        self2._dbInfo = null;
                        self2._ready = null;
                        return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                      }
                      setDriverToConfig();
                      var error = new Error("No available storage method found.");
                      self2._driverSet = Promise$1.reject(error);
                      return self2._driverSet;
                    }
                    return driverPromiseLoop();
                  };
                }
                var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
                  return Promise$1.resolve();
                }) : Promise$1.resolve();
                this._driverSet = oldDriverSetDone.then(function() {
                  var driverName = supportedDrivers[0];
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(function(driver) {
                    self2._driver = driver._driver;
                    setDriverToConfig();
                    self2._wrapLibraryMethodsWithReady();
                    self2._initDriver = initDriver(supportedDrivers);
                  });
                })["catch"](function() {
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                });
                executeTwoCallbacks(this._driverSet, callback, errorCallback);
                return this._driverSet;
              };
              LocalForage2.prototype.supports = function supports(driverName) {
                return !!DriverSupport[driverName];
              };
              LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
                extend(this, libraryMethodsAndProperties);
              };
              LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
                var supportedDrivers = [];
                for (var i2 = 0, len2 = drivers.length; i2 < len2; i2++) {
                  var driverName = drivers[i2];
                  if (this.supports(driverName)) {
                    supportedDrivers.push(driverName);
                  }
                }
                return supportedDrivers;
              };
              LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
                for (var i2 = 0, len2 = LibraryMethods.length; i2 < len2; i2++) {
                  callWhenReady(this, LibraryMethods[i2]);
                }
              };
              LocalForage2.prototype.createInstance = function createInstance(options) {
                return new LocalForage2(options);
              };
              return LocalForage2;
            }();
            var localforage_js = new LocalForage();
            module3.exports = localforage_js;
          },
          {
            "3": 3
          }
        ]
      }, {}, [
        4
      ])(4);
    });
  })(localforage$1);
  var localforageExports = localforage$1.exports;
  const localforage = getDefaultExportFromCjs$1(localforageExports);
  class BaseRetriever extends Runnable {
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "callbacks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "tags", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "metadata", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "verbose", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.callbacks = fields == null ? void 0 : fields.callbacks;
      this.tags = (fields == null ? void 0 : fields.tags) ?? [];
      this.metadata = (fields == null ? void 0 : fields.metadata) ?? {};
      this.verbose = (fields == null ? void 0 : fields.verbose) ?? false;
    }
    _getRelevantDocuments(_query, _callbacks) {
      throw new Error("Not implemented!");
    }
    async invoke(input, options) {
      return this.getRelevantDocuments(input, ensureConfig(options));
    }
    async getRelevantDocuments(query, config) {
      const parsedConfig = ensureConfig(parseCallbackConfigArg(config));
      const callbackManager_ = await CallbackManager.configure(parsedConfig.callbacks, this.callbacks, parsedConfig.tags, this.tags, parsedConfig.metadata, this.metadata, {
        verbose: this.verbose
      });
      const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleRetrieverStart(this.toJSON(), query, parsedConfig.runId, void 0, void 0, void 0, parsedConfig.runName));
      try {
        const results = await this._getRelevantDocuments(query, runManager);
        await (runManager == null ? void 0 : runManager.handleRetrieverEnd(results));
        return results;
      } catch (error) {
        await (runManager == null ? void 0 : runManager.handleRetrieverError(error));
        throw error;
      }
    }
  }
  class VectorStoreRetriever extends BaseRetriever {
    static lc_name() {
      return "VectorStoreRetriever";
    }
    get lc_namespace() {
      return [
        "langchain_core",
        "vectorstores"
      ];
    }
    _vectorstoreType() {
      return this.vectorStore._vectorstoreType();
    }
    constructor(fields) {
      super(fields);
      Object.defineProperty(this, "vectorStore", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "k", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 4
      });
      Object.defineProperty(this, "searchType", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "similarity"
      });
      Object.defineProperty(this, "searchKwargs", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "filter", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.vectorStore = fields.vectorStore;
      this.k = fields.k ?? this.k;
      this.searchType = fields.searchType ?? this.searchType;
      this.filter = fields.filter;
      if (fields.searchType === "mmr") {
        this.searchKwargs = fields.searchKwargs;
      }
    }
    async _getRelevantDocuments(query, runManager) {
      if (this.searchType === "mmr") {
        if (typeof this.vectorStore.maxMarginalRelevanceSearch !== "function") {
          throw new Error(`The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`);
        }
        return this.vectorStore.maxMarginalRelevanceSearch(query, {
          k: this.k,
          filter: this.filter,
          ...this.searchKwargs
        }, runManager == null ? void 0 : runManager.getChild("vectorstore"));
      }
      return this.vectorStore.similaritySearch(query, this.k, this.filter, runManager == null ? void 0 : runManager.getChild("vectorstore"));
    }
    async addDocuments(documents2, options) {
      return this.vectorStore.addDocuments(documents2, options);
    }
  }
  class VectorStore extends Serializable {
    constructor(embeddings, dbConfig) {
      super(dbConfig);
      Object.defineProperty(this, "lc_namespace", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: [
          "langchain",
          "vectorstores",
          this._vectorstoreType()
        ]
      });
      Object.defineProperty(this, "embeddings", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.embeddings = embeddings;
    }
    async delete(_params) {
      throw new Error("Not implemented.");
    }
    async similaritySearch(query, k2 = 4, filter2 = void 0, _callbacks = void 0) {
      const results = await this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k2, filter2);
      return results.map((result) => result[0]);
    }
    async similaritySearchWithScore(query, k2 = 4, filter2 = void 0, _callbacks = void 0) {
      return this.similaritySearchVectorWithScore(await this.embeddings.embedQuery(query), k2, filter2);
    }
    static fromTexts(_texts, _metadatas, _embeddings, _dbConfig) {
      throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
    }
    static fromDocuments(_docs, _embeddings, _dbConfig) {
      throw new Error("the Langchain vectorstore implementation you are using forgot to override this, please report a bug");
    }
    asRetriever(kOrFields, filter2, callbacks, tags, metadata, verbose) {
      if (typeof kOrFields === "number") {
        return new VectorStoreRetriever({
          vectorStore: this,
          k: kOrFields,
          filter: filter2,
          tags: [
            ...tags ?? [],
            this._vectorstoreType()
          ],
          metadata,
          verbose,
          callbacks
        });
      } else {
        const params = {
          vectorStore: this,
          k: kOrFields == null ? void 0 : kOrFields.k,
          filter: kOrFields == null ? void 0 : kOrFields.filter,
          tags: [
            ...(kOrFields == null ? void 0 : kOrFields.tags) ?? [],
            this._vectorstoreType()
          ],
          metadata: kOrFields == null ? void 0 : kOrFields.metadata,
          verbose: kOrFields == null ? void 0 : kOrFields.verbose,
          callbacks: kOrFields == null ? void 0 : kOrFields.callbacks,
          searchType: kOrFields == null ? void 0 : kOrFields.searchType
        };
        if ((kOrFields == null ? void 0 : kOrFields.searchType) === "mmr") {
          return new VectorStoreRetriever({
            ...params,
            searchKwargs: kOrFields.searchKwargs
          });
        }
        return new VectorStoreRetriever({
          ...params
        });
      }
    }
  }
  function cosine$1(a, b) {
    let p2 = 0;
    let p22 = 0;
    let q2 = 0;
    for (let i2 = 0; i2 < a.length; i2++) {
      p2 += a[i2] * b[i2];
      p22 += a[i2] * a[i2];
      q2 += b[i2] * b[i2];
    }
    return p2 / (Math.sqrt(p22) * Math.sqrt(q2));
  }
  function cosine(a, b) {
    let p2 = 0;
    let p22 = 0;
    let q2 = 0;
    for (let i2 = 0; i2 < a.length; i2++) {
      p2 += a[i2] * b[i2];
      p22 += a[i2] * a[i2];
      q2 += b[i2] * b[i2];
    }
    return p2 / (Math.sqrt(p22) * Math.sqrt(q2));
  }
  function matrixFunc(X2, Y2, func) {
    if (X2.length === 0 || X2[0].length === 0 || Y2.length === 0 || Y2[0].length === 0) {
      return [
        []
      ];
    }
    if (X2[0].length !== Y2[0].length) {
      throw new Error(`Number of columns in X and Y must be the same. X has shape ${[
        X2.length,
        X2[0].length
      ]} and Y has shape ${[
        Y2.length,
        Y2[0].length
      ]}.`);
    }
    return X2.map((xVector) => Y2.map((yVector) => func(xVector, yVector)).map((similarity) => Number.isNaN(similarity) ? 0 : similarity));
  }
  function cosineSimilarity(X2, Y2) {
    return matrixFunc(X2, Y2, cosine);
  }
  function maximalMarginalRelevance(queryEmbedding, embeddingList, lambda = 0.5, k2 = 4) {
    if (Math.min(k2, embeddingList.length) <= 0) {
      return [];
    }
    const queryEmbeddingExpanded = Array.isArray(queryEmbedding[0]) ? queryEmbedding : [
      queryEmbedding
    ];
    const similarityToQuery = cosineSimilarity(queryEmbeddingExpanded, embeddingList)[0];
    const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;
    const selectedEmbeddings = [
      embeddingList[mostSimilarEmbeddingIndex]
    ];
    const selectedEmbeddingsIndexes = [
      mostSimilarEmbeddingIndex
    ];
    while (selectedEmbeddingsIndexes.length < Math.min(k2, embeddingList.length)) {
      let bestScore = -Infinity;
      let bestIndex = -1;
      const similarityToSelected = cosineSimilarity(embeddingList, selectedEmbeddings);
      similarityToQuery.forEach((queryScore, queryScoreIndex) => {
        if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {
          return;
        }
        const maxSimilarityToSelected = Math.max(...similarityToSelected[queryScoreIndex]);
        const score = lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;
        if (score > bestScore) {
          bestScore = score;
          bestIndex = queryScoreIndex;
        }
      });
      selectedEmbeddings.push(embeddingList[bestIndex]);
      selectedEmbeddingsIndexes.push(bestIndex);
    }
    return selectedEmbeddingsIndexes;
  }
  function argMax(array) {
    if (array.length === 0) {
      return {
        maxIndex: -1,
        maxValue: NaN
      };
    }
    let maxValue = array[0];
    let maxIndex = 0;
    for (let i2 = 1; i2 < array.length; i2 += 1) {
      if (array[i2] > maxValue) {
        maxIndex = i2;
        maxValue = array[i2];
      }
    }
    return {
      maxIndex,
      maxValue
    };
  }
  class MemoryVectorStore extends VectorStore {
    _vectorstoreType() {
      return "memory";
    }
    constructor(embeddings, { similarity, ...rest } = {}) {
      super(embeddings, rest);
      Object.defineProperty(this, "memoryVectors", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "similarity", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.similarity = similarity ?? cosine$1;
    }
    async addDocuments(documents2) {
      const texts = documents2.map(({ pageContent }) => pageContent);
      return this.addVectors(await this.embeddings.embedDocuments(texts), documents2);
    }
    async addVectors(vectors, documents2) {
      const memoryVectors = vectors.map((embedding, idx) => ({
        content: documents2[idx].pageContent,
        embedding,
        metadata: documents2[idx].metadata,
        id: documents2[idx].id
      }));
      this.memoryVectors = this.memoryVectors.concat(memoryVectors);
    }
    async _queryVectors(query, k2, filter2) {
      const filterFunction = (memoryVector) => {
        if (!filter2) {
          return true;
        }
        const doc = new Document({
          metadata: memoryVector.metadata,
          pageContent: memoryVector.content,
          id: memoryVector.id
        });
        return filter2(doc);
      };
      const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);
      return filteredMemoryVectors.map((vector, index2) => ({
        similarity: this.similarity(query, vector.embedding),
        index: index2,
        metadata: vector.metadata,
        content: vector.content,
        embedding: vector.embedding,
        id: vector.id
      })).sort((a, b) => a.similarity > b.similarity ? -1 : 0).slice(0, k2);
    }
    async similaritySearchVectorWithScore(query, k2, filter2) {
      const searches = await this._queryVectors(query, k2, filter2);
      const result = searches.map((search2) => [
        new Document({
          metadata: search2.metadata,
          pageContent: search2.content,
          id: search2.id
        }),
        search2.similarity
      ]);
      return result;
    }
    async maxMarginalRelevanceSearch(query, options) {
      const queryEmbedding = await this.embeddings.embedQuery(query);
      const searches = await this._queryVectors(queryEmbedding, options.fetchK ?? 20, options.filter);
      const embeddingList = searches.map((searchResp) => searchResp.embedding);
      const mmrIndexes = maximalMarginalRelevance(queryEmbedding, embeddingList, options.lambda, options.k);
      return mmrIndexes.map((idx) => new Document({
        metadata: searches[idx].metadata,
        pageContent: searches[idx].content,
        id: searches[idx].id
      }));
    }
    static async fromTexts(texts, metadatas, embeddings, dbConfig) {
      const docs = [];
      for (let i2 = 0; i2 < texts.length; i2 += 1) {
        const metadata = Array.isArray(metadatas) ? metadatas[i2] : metadatas;
        const newDoc = new Document({
          pageContent: texts[i2],
          metadata
        });
        docs.push(newDoc);
      }
      return MemoryVectorStore.fromDocuments(docs, embeddings, dbConfig);
    }
    static async fromDocuments(docs, embeddings, dbConfig) {
      const instance2 = new this(embeddings, dbConfig);
      await instance2.addDocuments(docs);
      return instance2;
    }
    static async fromExistingIndex(embeddings, dbConfig) {
      const instance2 = new this(embeddings, dbConfig);
      return instance2;
    }
  }
  class VoyVectorStore extends VectorStore {
    _vectorstoreType() {
      return "voi";
    }
    constructor(client, embeddings) {
      super(embeddings, {});
      Object.defineProperty(this, "client", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "numDimensions", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: null
      });
      Object.defineProperty(this, "docstore", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      this.client = client;
      this.embeddings = embeddings;
    }
    async addDocuments(documents2) {
      const texts = documents2.map(({ pageContent }) => pageContent);
      if (documents2.length === 0) {
        return;
      }
      const firstVector = (await this.embeddings.embedDocuments(texts.slice(0, 1)))[0];
      if (this.numDimensions === null) {
        this.numDimensions = firstVector.length;
      } else if (this.numDimensions !== firstVector.length) {
        throw new Error(`Vectors must have the same length as the number of dimensions (${this.numDimensions})`);
      }
      const restResults = await this.embeddings.embedDocuments(texts.slice(1));
      await this.addVectors([
        firstVector,
        ...restResults
      ], documents2);
    }
    async addVectors(vectors, documents2) {
      if (vectors.length === 0) {
        return;
      }
      if (this.numDimensions === null) {
        this.numDimensions = vectors[0].length;
      }
      if (vectors.length !== documents2.length) {
        throw new Error(`Vectors and metadata must have the same length`);
      }
      if (!vectors.every((v2) => v2.length === this.numDimensions)) {
        throw new Error(`Vectors must have the same length as the number of dimensions (${this.numDimensions})`);
      }
      vectors.forEach((item, idx) => {
        const doc = documents2[idx];
        this.docstore.push({
          embeddings: item,
          document: doc
        });
      });
      const embeddings = this.docstore.map((item, idx) => ({
        id: String(idx),
        embeddings: item.embeddings,
        title: "",
        url: ""
      }));
      this.client.index({
        embeddings
      });
    }
    async similaritySearchVectorWithScore(query, k2) {
      if (this.numDimensions === null) {
        throw new Error("There aren't any elements in the index yet.");
      }
      if (query.length !== this.numDimensions) {
        throw new Error(`Query vector must have the same length as the number of dimensions (${this.numDimensions})`);
      }
      const itemsToQuery = Math.min(this.docstore.length, k2);
      if (itemsToQuery > this.docstore.length) {
        console.warn(`k (${k2}) is greater than the number of elements in the index (${this.docstore.length}), setting k to ${itemsToQuery}`);
      }
      const results = this.client.search(new Float32Array(query), itemsToQuery);
      return results.neighbors.map(({ id: id2 }, idx) => [
        this.docstore[parseInt(id2, 10)].document,
        idx
      ]);
    }
    async delete(params) {
      if (params.deleteAll === true) {
        await this.client.clear();
      } else {
        throw new Error(`You must provide a "deleteAll" parameter.`);
      }
    }
    static async fromTexts(texts, metadatas, embeddings, client) {
      const docs = [];
      for (let i2 = 0; i2 < texts.length; i2 += 1) {
        const metadata = Array.isArray(metadatas) ? metadatas[i2] : metadatas;
        const newDoc = new Document({
          pageContent: texts[i2],
          metadata
        });
        docs.push(newDoc);
      }
      return VoyVectorStore.fromDocuments(docs, embeddings, client);
    }
    static async fromDocuments(docs, embeddings, client) {
      const instance2 = new VoyVectorStore(client, embeddings);
      await instance2.addDocuments(docs);
      return instance2;
    }
  }
  var md5 = {
    exports: {}
  };
  const __viteBrowserExternal = {};
  __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  require$$5 = getAugmentedNamespace(__viteBrowserExternal$1);
  require$$0 = getAugmentedNamespace(dist);
  (function(module2) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_MD5_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process$1 === "object" && process$1.versions && process$1.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && true && module2.exports;
      var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [
        128,
        32768,
        8388608,
        -2147483648
      ];
      var SHIFT = [
        0,
        8,
        16,
        24
      ];
      var OUTPUT_TYPES = [
        "hex",
        "array",
        "digest",
        "buffer",
        "arrayBuffer",
        "base64"
      ];
      var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer2 = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer2);
        blocks = new Uint32Array(buffer2);
      }
      var isArray = Array.isArray;
      if (root.JS_MD5_NO_NODE_JS || !isArray) {
        isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      var isView = ArrayBuffer.isView;
      if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !isView)) {
        isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var formatMessage = function(message) {
        var type = typeof message;
        if (type === "string") {
          return [
            message,
            true
          ];
        }
        if (type !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [
            new Uint8Array(message),
            false
          ];
        }
        if (!isArray(message) && !isView(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [
          message,
          false
        ];
      };
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md5(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md5();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto2 = require$$5;
        var Buffer3 = require$$0.Buffer;
        var bufferFrom;
        if (Buffer3.from && !root.JS_MD5_NO_BUFFER_FROM) {
          bufferFrom = Buffer3.from;
        } else {
          bufferFrom = function(message) {
            return new Buffer3(message);
          };
        }
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto2.createHash("md5").update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(INPUT_ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (isArray(message) || isView(message) || message.constructor === Buffer3) {
            return crypto2.createHash("md5").update(bufferFrom(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType) {
        return function(key, message) {
          return new HmacMd5(key, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function() {
        var method = createHmacOutputMethod("hex");
        method.create = function(key) {
          return new HmacMd5(key);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createHmacOutputMethod(type);
        }
        return method;
      };
      function Md5(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer3 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer3);
            this.blocks = new Uint32Array(buffer3);
          } else {
            this.blocks = [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md5.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString2 = result[1];
        var code2, index2 = 0, i2, length = message.length, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index2 < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (isString2) {
            if (ARRAY_BUFFER) {
              for (i2 = this.start; index2 < length && i2 < 64; ++index2) {
                code2 = message.charCodeAt(index2);
                if (code2 < 128) {
                  buffer82[i2++] = code2;
                } else if (code2 < 2048) {
                  buffer82[i2++] = 192 | code2 >>> 6;
                  buffer82[i2++] = 128 | code2 & 63;
                } else if (code2 < 55296 || code2 >= 57344) {
                  buffer82[i2++] = 224 | code2 >>> 12;
                  buffer82[i2++] = 128 | code2 >>> 6 & 63;
                  buffer82[i2++] = 128 | code2 & 63;
                } else {
                  code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                  buffer82[i2++] = 240 | code2 >>> 18;
                  buffer82[i2++] = 128 | code2 >>> 12 & 63;
                  buffer82[i2++] = 128 | code2 >>> 6 & 63;
                  buffer82[i2++] = 128 | code2 & 63;
                }
              }
            } else {
              for (i2 = this.start; index2 < length && i2 < 64; ++index2) {
                code2 = message.charCodeAt(index2);
                if (code2 < 128) {
                  blocks2[i2 >>> 2] |= code2 << SHIFT[i2++ & 3];
                } else if (code2 < 2048) {
                  blocks2[i2 >>> 2] |= (192 | code2 >>> 6) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
                } else if (code2 < 55296 || code2 >= 57344) {
                  blocks2[i2 >>> 2] |= (224 | code2 >>> 12) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code2 >>> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
                } else {
                  code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                  blocks2[i2 >>> 2] |= (240 | code2 >>> 18) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code2 >>> 12 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code2 >>> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >>> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
                }
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i2 = this.start; index2 < length && i2 < 64; ++index2) {
                buffer82[i2++] = message[index2];
              }
            } else {
              for (i2 = this.start; index2 < length && i2 < 64; ++index2) {
                blocks2[i2 >>> 2] |= message[index2] << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          this.bytes += i2 - this.start;
          if (i2 >= 64) {
            this.start = i2 - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i2;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Md5.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex;
        blocks2[i2 >>> 2] |= EXTRA[i2 & 3];
        if (i2 >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
        this.hash();
      };
      Md5.prototype.hash = function() {
        var a, b, c, d, bc2, da2, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 680876937;
          a = (a << 7 | a >>> 25) - 271733879 << 0;
          d = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
          d = (d << 12 | d >>> 20) + a << 0;
          c = (-271733879 ^ d & (a ^ -271733879)) + blocks2[2] - 1126478375;
          c = (c << 17 | c >>> 15) + d << 0;
          b = (a ^ c & (d ^ a)) + blocks2[3] - 1316259209;
          b = (b << 22 | b >>> 10) + c << 0;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (d ^ b & (c ^ d)) + blocks2[0] - 680876936;
          a = (a << 7 | a >>> 25) + b << 0;
          d += (c ^ a & (b ^ c)) + blocks2[1] - 389564586;
          d = (d << 12 | d >>> 20) + a << 0;
          c += (b ^ d & (a ^ b)) + blocks2[2] + 606105819;
          c = (c << 17 | c >>> 15) + d << 0;
          b += (a ^ c & (d ^ a)) + blocks2[3] - 1044525330;
          b = (b << 22 | b >>> 10) + c << 0;
        }
        a += (d ^ b & (c ^ d)) + blocks2[4] - 176418897;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[5] + 1200080426;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[6] - 1473231341;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[7] - 45705983;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks2[8] + 1770035416;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[9] - 1958414417;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[10] - 42063;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[11] - 1990404162;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks2[12] + 1804603682;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks2[13] - 40341101;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks2[14] - 1502002290;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks2[15] + 1236535329;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[1] - 165796510;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[6] - 1069501632;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[11] + 643717713;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[0] - 373897302;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[5] - 701558691;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[10] + 38016083;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[15] - 660478335;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[4] - 405537848;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[9] + 568446438;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[14] - 1019803690;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[3] - 187363961;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[8] + 1163531501;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks2[13] - 1444681467;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks2[2] - 51403784;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks2[7] + 1735328473;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks2[12] - 1926607734;
        b = (b << 20 | b >>> 12) + c << 0;
        bc2 = b ^ c;
        a += (bc2 ^ d) + blocks2[5] - 378558;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc2 ^ a) + blocks2[8] - 2022574463;
        d = (d << 11 | d >>> 21) + a << 0;
        da2 = d ^ a;
        c += (da2 ^ b) + blocks2[11] + 1839030562;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da2 ^ c) + blocks2[14] - 35309556;
        b = (b << 23 | b >>> 9) + c << 0;
        bc2 = b ^ c;
        a += (bc2 ^ d) + blocks2[1] - 1530992060;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc2 ^ a) + blocks2[4] + 1272893353;
        d = (d << 11 | d >>> 21) + a << 0;
        da2 = d ^ a;
        c += (da2 ^ b) + blocks2[7] - 155497632;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da2 ^ c) + blocks2[10] - 1094730640;
        b = (b << 23 | b >>> 9) + c << 0;
        bc2 = b ^ c;
        a += (bc2 ^ d) + blocks2[13] + 681279174;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc2 ^ a) + blocks2[0] - 358537222;
        d = (d << 11 | d >>> 21) + a << 0;
        da2 = d ^ a;
        c += (da2 ^ b) + blocks2[3] - 722521979;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da2 ^ c) + blocks2[6] + 76029189;
        b = (b << 23 | b >>> 9) + c << 0;
        bc2 = b ^ c;
        a += (bc2 ^ d) + blocks2[9] - 640364487;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc2 ^ a) + blocks2[12] - 421815835;
        d = (d << 11 | d >>> 21) + a << 0;
        da2 = d ^ a;
        c += (da2 ^ b) + blocks2[15] + 530742520;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da2 ^ c) + blocks2[2] - 995338651;
        b = (b << 23 | b >>> 9) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[0] - 198630844;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[7] + 1126891415;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[14] - 1416354905;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[5] - 57434055;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[12] + 1700485571;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[3] - 1894986606;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[10] - 1051523;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[1] - 2054922799;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[8] + 1873313359;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[15] - 30611744;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[6] - 1560198380;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[13] + 1309151649;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks2[4] - 145523070;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks2[11] - 1120210379;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks2[2] + 718787259;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks2[9] - 343485551;
        b = (b << 21 | b >>> 11) + c << 0;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md5.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >>> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >>> 12 & 15] + HEX_CHARS[h0 >>> 8 & 15] + HEX_CHARS[h0 >>> 20 & 15] + HEX_CHARS[h0 >>> 16 & 15] + HEX_CHARS[h0 >>> 28 & 15] + HEX_CHARS[h0 >>> 24 & 15] + HEX_CHARS[h1 >>> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >>> 12 & 15] + HEX_CHARS[h1 >>> 8 & 15] + HEX_CHARS[h1 >>> 20 & 15] + HEX_CHARS[h1 >>> 16 & 15] + HEX_CHARS[h1 >>> 28 & 15] + HEX_CHARS[h1 >>> 24 & 15] + HEX_CHARS[h2 >>> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >>> 12 & 15] + HEX_CHARS[h2 >>> 8 & 15] + HEX_CHARS[h2 >>> 20 & 15] + HEX_CHARS[h2 >>> 16 & 15] + HEX_CHARS[h2 >>> 28 & 15] + HEX_CHARS[h2 >>> 24 & 15] + HEX_CHARS[h3 >>> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >>> 12 & 15] + HEX_CHARS[h3 >>> 8 & 15] + HEX_CHARS[h3 >>> 20 & 15] + HEX_CHARS[h3 >>> 16 & 15] + HEX_CHARS[h3 >>> 28 & 15] + HEX_CHARS[h3 >>> 24 & 15];
      };
      Md5.prototype.toString = Md5.prototype.hex;
      Md5.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >>> 8 & 255,
          h0 >>> 16 & 255,
          h0 >>> 24 & 255,
          h1 & 255,
          h1 >>> 8 & 255,
          h1 >>> 16 & 255,
          h1 >>> 24 & 255,
          h2 & 255,
          h2 >>> 8 & 255,
          h2 >>> 16 & 255,
          h2 >>> 24 & 255,
          h3 & 255,
          h3 >>> 8 & 255,
          h3 >>> 16 & 255,
          h3 >>> 24 & 255
        ];
      };
      Md5.prototype.array = Md5.prototype.digest;
      Md5.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer3 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer3);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer3;
      };
      Md5.prototype.buffer = Md5.prototype.arrayBuffer;
      Md5.prototype.base64 = function() {
        var v1, v2, v3, base64Str = "", bytes = this.array();
        for (var i2 = 0; i2 < 15; ) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
        }
        v1 = bytes[i2];
        base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
        return base64Str;
      };
      function HmacMd5(key, sharedMemory) {
        var i2, result = formatMessage(key);
        key = result[0];
        if (result[1]) {
          var bytes = [], length = key.length, index2 = 0, code2;
          for (i2 = 0; i2 < length; ++i2) {
            code2 = key.charCodeAt(i2);
            if (code2 < 128) {
              bytes[index2++] = code2;
            } else if (code2 < 2048) {
              bytes[index2++] = 192 | code2 >>> 6;
              bytes[index2++] = 128 | code2 & 63;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes[index2++] = 224 | code2 >>> 12;
              bytes[index2++] = 128 | code2 >>> 6 & 63;
              bytes[index2++] = 128 | code2 & 63;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i2) & 1023);
              bytes[index2++] = 240 | code2 >>> 18;
              bytes[index2++] = 128 | code2 >>> 12 & 63;
              bytes[index2++] = 128 | code2 >>> 6 & 63;
              bytes[index2++] = 128 | code2 & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 64) {
          key = new Md5(true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i2 = 0; i2 < 64; ++i2) {
          var b = key[i2] || 0;
          oKeyPad[i2] = 92 ^ b;
          iKeyPad[i2] = 54 ^ b;
        }
        Md5.call(this, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacMd5.prototype = new Md5();
      HmacMd5.prototype.finalize = function() {
        Md5.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Md5.call(this, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Md5.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.md5 = exports;
      exports.md5.hmac = createHmacMethod();
      if (COMMON_JS) {
        module2.exports = exports;
      } else {
        root.md5 = exports;
      }
    })();
  })(md5);
  var md5Exports = md5.exports;
  encodeSplitter = (strings) => {
    if (!strings) return "";
    return strings.join("|\u294A|");
  };
  decodeSplitter = (strings) => {
    if (!strings) return [];
    return strings.split("|\u294A|");
  };
  const encodeLine = (strings) => {
    if (!strings) return "";
    return strings.join("|\u294C|");
  };
  decodeLine = (strings) => {
    if (!strings) return [];
    return strings.split("|\u294C|");
  };
  encodeCSVData = (headers, data) => {
    return {
      headers: encodeSplitter(headers),
      data: encodeLine(data.map((row) => encodeSplitter(row)))
    };
  };
  decodeCSVData = (headerString, data) => {
    const headers = decodeSplitter(headerString);
    const rows = decodeLine(data).reduce((acc, row) => {
      const rowValues = decodeSplitter(row);
      return rowValues.length === headers.length ? [
        ...acc,
        headers.reduce((acc2, header, index2) => ({
          ...acc2,
          [header]: rowValues[index2]
        }), {})
      ] : acc;
    }, []);
    return {
      headers,
      rows
    };
  };
  const mapVectorDataByProvider = async ({ provider, storedData, databaseName }) => {
    switch (provider) {
      case "voy":
        return storedData.map((entry, index2) => {
          var _a, _b;
          return {
            id: entry.id || ((_a = entry.metadata) == null ? void 0 : _a.id) || index2,
            title: JSON.stringify({
              pageContent: entry.content,
              metadata: entry.metadata
            }),
            url: `/${databaseName}/items/${entry.id || ((_b = entry.metadata) == null ? void 0 : _b.id) || index2}`,
            embeddings: entry.embedding
          };
        });
      case "memory":
        return storedData.map((entry, index2) => {
          var _a;
          return {
            content: entry.content,
            embedding: entry.embedding,
            metadata: entry.metadata,
            id: entry.id || ((_a = entry.metadata) == null ? void 0 : _a.id) || index2
          };
        });
      default:
        throw new Error("Invalid provider");
    }
  };
  const getVectorDatabaseStorage = async ({ storageType, provider, databaseName, storageService, storageDataNode }) => {
    switch (storageType) {
      case "DataNode": {
        if (!storageDataNode) {
          throw new Error("Storage data node not found");
        }
        if ("csv" in storageDataNode) {
          const { rows } = decodeCSVData((storageDataNode == null ? void 0 : storageDataNode.headers) || "", (storageDataNode == null ? void 0 : storageDataNode.csv) || "");
          return mapVectorDataByProvider({
            provider,
            storedData: rows,
            databaseName
          });
        }
        if ("json" in storageDataNode) {
          return mapVectorDataByProvider({
            provider,
            storedData: JSON.parse((storageDataNode == null ? void 0 : storageDataNode.json) || "[]"),
            databaseName
          });
        }
        if ("jsonl" in storageDataNode) {
          return mapVectorDataByProvider({
            provider,
            storedData: decodeLine(storageDataNode == null ? void 0 : storageDataNode.jsonl).map((item) => JSON.parse(item)),
            databaseName
          });
        }
        return [];
      }
      case "IndexedDB": {
        const storedData = await (storageService == null ? void 0 : storageService.getItem(databaseName));
        if (!storedData) {
          return [];
        }
        return mapVectorDataByProvider({
          provider,
          storedData,
          databaseName
        });
      }
    }
  };
  const storeVectorDatabaseStorage = async ({ docstore, storageType, databaseName, embeddingStorage, storageDataNode }) => {
    const data = docstore.map((entry) => {
      if ("embedding" in entry) {
        return {
          id: entry.id,
          embedding: entry.embedding,
          content: entry.content,
          metadata: entry.metadata
        };
      }
      return {
        id: entry.document.metadata.id,
        content: entry.document.pageContent,
        metadata: entry.document.metadata,
        embedding: entry.embeddings
      };
    });
    switch (storageType) {
      case "DataNode":
        {
          if (!storageDataNode) {
            throw new Error("Storage data node not found");
          }
          const storageDataNodeType = getStorageDataSource(storageDataNode);
          if (storageDataNodeType === "CSVData") {
            await getRepository(storageDataNodeType).update(storageDataNode.id, {
              csv: encodeLine(data.map((item) => {
                const headers = decodeSplitter(storageDataNode.headers);
                const row = headers.map((header) => item[header]);
                return encodeSplitter(row);
              }))
            });
          }
          if (storageDataNodeType === "JSONData") {
            await getRepository(storageDataNodeType).update(storageDataNode.id, {
              json: JSON.stringify(data)
            });
          }
          if (storageDataNodeType === "JSONLData") {
            await getRepository(storageDataNodeType).update(storageDataNode.id, {
              jsonl: encodeLine(data.map((item) => JSON.stringify(item)))
            });
          }
        }
        break;
      case "IndexedDB":
        {
          await embeddingStorage.setItem(databaseName, data);
        }
        break;
    }
    return data;
  };
  getStorageDataSource = (dataSource) => {
    return "csv" in dataSource ? "CSVData" : "json" in dataSource ? "JSONData" : "jsonl" in dataSource ? "JSONLData" : void 0;
  };
  const getDatabaseId = (name) => md5Exports.md5(name);
  DEFAULT_EMBEDDING_MODEL = "nomic-ai/nomic-embed-text-v1.5";
  class Embeddings {
    constructor(params) {
      Object.defineProperty(this, "caller", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      this.caller = new AsyncCaller(params ?? {});
    }
  }
  const chunkArray = (arr2, chunkSize) => arr2.reduce((chunks, elem, index2) => {
    const chunkIndex = Math.floor(index2 / chunkSize);
    const chunk = chunks[chunkIndex] || [];
    chunks[chunkIndex] = chunk.concat([
      elem
    ]);
    return chunks;
  }, []);
  const worker = new Worker(new URL("/NoLLMChat/assets/embedding.worker-BPS3YavN.js", import.meta.url), {
    type: "module"
  });
  class WorkerEmbeddings extends Embeddings {
    constructor(fields) {
      super(fields ?? {});
      this.ready = false;
      this.modelName = "Xenova/all-MiniLM-L6-v2";
      this.model = "Xenova/all-MiniLM-L6-v2";
      this.batchSize = 512;
      this.stripNewLines = true;
      this.EMBEDDING_LOAD_MESSAGE_ID = "EMBEDDING_LOAD_MESSAGE_ID";
      this.refProcesses = /* @__PURE__ */ new Map();
      this.initWorker = () => {
        sendToWorker(worker, "load", this.EMBEDDING_LOAD_MESSAGE_ID, [
          this.model,
          this.pretrainedOptions
        ]);
        worker.addEventListener("message", this.handleMessages);
        const promiseInfo = getEmptyPromise();
        this.refProcesses.set(this.EMBEDDING_LOAD_MESSAGE_ID, [
          promiseInfo.promise,
          promiseInfo.resolve,
          promiseInfo.reject
        ]);
        return promiseInfo.promise;
      };
      this.handleMessages = (event) => {
        const messageId = event.data.messageId;
        if (messageId === WOKER_INIT_MESSAGE_ID) ;
        else if (event.data.type === "complete" || event.data.type === "error") {
          const [, resolve, reject] = this.refProcesses.get(messageId) || [];
          if (event.data.type === "complete") {
            resolve == null ? void 0 : resolve(event.data.payload);
          } else {
            reject == null ? void 0 : reject(new Error(JSON.stringify(event.data.payload)));
          }
          if (messageId === this.EMBEDDING_LOAD_MESSAGE_ID) {
            this.ready = !!event.data.payload;
          }
          this.refProcesses.delete(messageId);
        } else if (event.data.type === "started") ;
        else if (event.data.type === "inprogress") ;
        else {
          logWarn("Unknown message type", event.data);
        }
      };
      this.runEmbedding = async (texts) => {
        if (!worker) {
          throw new Error("MISSING WORKER");
        }
        const initProcess = this.refProcesses.get(this.EMBEDDING_LOAD_MESSAGE_ID);
        if (initProcess == null ? void 0 : initProcess[0]) {
          await (initProcess == null ? void 0 : initProcess[0]);
        }
        if (!this.ready) {
          throw new Error("WORKER NOT READY YET");
        }
        return this.caller.call(async () => {
          const messageId = nanoid();
          const promiseInfo = getEmptyPromise(() => {
            sendToWorker(worker, "embedding", messageId, [
              texts,
              this.pipelineOptions
            ]);
          });
          this.refProcesses.set(messageId, [
            promiseInfo.promise,
            promiseInfo.resolve,
            promiseInfo.reject
          ]);
          return promiseInfo.promise.then((result) => {
            return result;
          });
        });
      };
      this.modelName = (fields == null ? void 0 : fields.model) ?? (fields == null ? void 0 : fields.modelName) ?? this.model;
      this.model = this.modelName;
      this.stripNewLines = (fields == null ? void 0 : fields.stripNewLines) ?? this.stripNewLines;
      this.timeout = fields == null ? void 0 : fields.timeout;
      this.pretrainedOptions = (fields == null ? void 0 : fields.pretrainedOptions) ?? {};
      this.pipelineOptions = {
        pooling: "mean",
        normalize: true,
        ...fields == null ? void 0 : fields.pipelineOptions
      };
      this.initWorker();
    }
    async embedDocuments(texts) {
      const batches = chunkArray(this.stripNewLines ? texts.map((t2) => t2.replace(/\n/g, " ")) : texts, this.batchSize);
      const batchRequests = batches.map((batch) => this.runEmbedding(batch));
      const batchResponses = await Promise.all(batchRequests);
      const embeddings = [];
      for (let i2 = 0; i2 < batchResponses.length; i2 += 1) {
        const batchResponse = batchResponses[i2];
        for (let j = 0; j < batchResponse.length; j += 1) {
          embeddings.push(batchResponse[j]);
        }
      }
      return embeddings;
    }
    async embedQuery(text) {
      const data = await this.runEmbedding([
        this.stripNewLines ? text.replace(/\n/g, " ") : text
      ]);
      return data[0];
    }
  }
  const splitterDocuments = (database, documents2) => {
    var _a;
    try {
      const metadata = JSON.parse(database.metadata || "{}");
      if (!(metadata == null ? void 0 : metadata.textSplitter)) {
        return documents2;
      }
      switch ((_a = metadata == null ? void 0 : metadata.textSplitter) == null ? void 0 : _a.type) {
        case "TokenTextSplitter":
          return new TokenTextSplitter({
            chunkOverlap: +metadata.textSplitter.chunkOverlap,
            chunkSize: +metadata.textSplitter.chunkSize
          }).splitDocuments(documents2);
        case "CharacterTextSplitter":
          return new CharacterTextSplitter({
            chunkOverlap: +metadata.textSplitter.chunkOverlap,
            chunkSize: +metadata.textSplitter.chunkSize
          }).splitDocuments(documents2);
        case "RecursiveCharacterTextSplitter":
          return new RecursiveCharacterTextSplitter({
            chunkOverlap: +metadata.textSplitter.chunkOverlap,
            chunkSize: +metadata.textSplitter.chunkSize
          }).splitDocuments(documents2);
        default:
          throw new Error("Invalid text splitter");
      }
    } catch {
      return documents2;
    }
  };
  const getLocalEmbeddingStateActions = (set, get2) => {
    return {
      init: async () => {
        try {
          const embedding = get2().embedding;
          if (!embedding) {
            set({
              embedding: new WorkerEmbeddings({
                modelName: DEFAULT_EMBEDDING_MODEL
              })
            });
          }
          const embeddingStorage = get2().embeddingStorage;
          if (!embeddingStorage) {
            set({
              embeddingStorage: localforage.createInstance({
                name: "vector-database",
                driver: localforage.INDEXEDDB,
                storeName: "main"
              })
            });
          }
        } catch (error) {
          logWarn("Failed init:", error);
        } finally {
          set({
            ready: true
          });
        }
      },
      index: async (databaseInfo, documents2) => {
        const embedding = get2().embedding;
        const embeddingStorage = get2().embeddingStorage;
        if (!embedding || !embeddingStorage) {
          throw new Error("Missing embedding model or storage.");
        }
        const database = await getRepository("VectorDatabase").findOne({
          where: {
            id: databaseInfo.databaseId
          }
        });
        if (!database) {
          throw new Error("Database not found.");
        }
        if (!database.provider) {
          throw new Error("Database provider not found.");
        }
        const dataSource = databaseInfo.dataSourceId && databaseInfo.dataSourceType ? await getRepository(databaseInfo.dataSourceType).findOne({
          where: {
            id: databaseInfo.dataSourceId
          }
        }) : void 0;
        const databaseName = getDatabaseId(database.name);
        const splittedDocuments = await splitterDocuments(database, documents2);
        const data = await getVectorDatabaseStorage({
          databaseName,
          storageType: database.storage || "IndexedDB",
          provider: database.provider,
          storageService: embeddingStorage,
          storageDataNode: dataSource
        });
        switch (database.provider) {
          case VectorDatabaseProviderEnum.Voy:
            {
              const voyClient = new Voy({
                embeddings: data
              });
              const store = new VoyVectorStore(voyClient, embedding);
              await store.addDocuments(splittedDocuments);
              await storeVectorDatabaseStorage({
                databaseName,
                provider: database.provider,
                embeddingStorage,
                docstore: store.docstore,
                storageType: database.storage || "IndexedDB",
                storageDataNode: dataSource
              });
            }
            break;
          case VectorDatabaseProviderEnum.Memory:
            {
              const store = new MemoryVectorStore(embedding);
              store.memoryVectors = data;
              await store.addDocuments(splittedDocuments);
              await storeVectorDatabaseStorage({
                databaseName,
                provider: database.provider,
                embeddingStorage,
                docstore: store.memoryVectors,
                storageType: database.storage || "IndexedDB",
                storageDataNode: dataSource
              });
            }
            break;
        }
      },
      getVectorDatabase: async (databaseInfo, ...args) => {
        const embedding = get2().embedding;
        const embeddingStorage = get2().embeddingStorage;
        if (!embedding || !embeddingStorage) {
          throw new Error("Missing embedding model or storage.");
        }
        const database = await getRepository("VectorDatabase").findOne({
          where: {
            id: databaseInfo.databaseId
          }
        });
        if (!database) {
          throw new Error("Database not found.");
        }
        if (!database.provider) {
          throw new Error("Database provider not found.");
        }
        const dataSource = databaseInfo.dataSourceId && databaseInfo.dataSourceType ? await getRepository(databaseInfo.dataSourceType).findOne({
          where: {
            id: databaseInfo.dataSourceId
          }
        }) : void 0;
        const databaseName = getDatabaseId(database.name);
        const data = await getVectorDatabaseStorage({
          databaseName,
          storageType: database.storage || "IndexedDB",
          provider: database.provider,
          storageService: get2().embeddingStorage,
          storageDataNode: dataSource
        });
        switch (database.provider) {
          case VectorDatabaseProviderEnum.Voy: {
            const voyClient = new Voy({
              embeddings: data
            });
            return new VoyVectorStore(voyClient, embedding);
          }
          case VectorDatabaseProviderEnum.Memory: {
            const store = new MemoryVectorStore(embedding, args);
            store.memoryVectors = data;
            return store;
          }
          default:
            throw new Error("Invalid provider");
        }
      },
      similaritySearch: async (databaseInfo, ...args) => {
        const embedding = get2().embedding;
        const embeddingStorage = get2().embeddingStorage;
        if (!embedding || !embeddingStorage) {
          throw new Error("Missing embedding model or storage.");
        }
        const database = await getRepository("VectorDatabase").findOne({
          where: {
            id: databaseInfo.databaseId
          }
        });
        if (!database || !database.provider) {
          throw new Error("Database not found.");
        }
        if (!database.provider) {
          throw new Error("Database provider not found.");
        }
        const dataSource = databaseInfo.dataSourceId && databaseInfo.dataSourceType ? await getRepository(databaseInfo.dataSourceType).findOne({
          where: {
            id: databaseInfo.dataSourceId
          }
        }) : void 0;
        const databaseName = getDatabaseId(database.name);
        const data = await getVectorDatabaseStorage({
          databaseName,
          storageDataNode: dataSource,
          provider: database.provider,
          storageService: embeddingStorage,
          storageType: database.storage || "IndexedDB"
        });
        switch (database.provider) {
          case VectorDatabaseProviderEnum.Voy: {
            const voyClient = new Voy({
              embeddings: data
            });
            const store = new VoyVectorStore(voyClient, embedding);
            const documents2 = await store.similaritySearch(...args);
            return documents2;
          }
          case VectorDatabaseProviderEnum.Memory: {
            const store = new MemoryVectorStore(embedding);
            store.memoryVectors = data;
            const documents2 = await store.similaritySearch(...args);
            return documents2;
          }
          default:
            throw new Error("Invalid provider");
        }
      },
      similaritySearchWithScore: async (databaseInfo, ...args) => {
        const embedding = get2().embedding;
        const embeddingStorage = get2().embeddingStorage;
        if (!embedding || !embeddingStorage) {
          throw new Error("Missing embedding model or storage.");
        }
        const database = await getRepository("VectorDatabase").findOne({
          where: {
            id: databaseInfo.databaseId
          }
        });
        if (!database || !database.provider) {
          throw new Error("Database not found.");
        }
        if (!database.provider) {
          throw new Error("Database provider not found.");
        }
        const dataSource = databaseInfo.dataSourceId && databaseInfo.dataSourceType ? await getRepository(databaseInfo.dataSourceType).findOne({
          where: {
            id: databaseInfo.dataSourceId
          }
        }) : void 0;
        const databaseName = getDatabaseId(database.name);
        const data = await getVectorDatabaseStorage({
          databaseName,
          provider: database.provider,
          storageDataNode: dataSource,
          storageService: embeddingStorage,
          storageType: database.storage || "IndexedDB"
        });
        switch (database.provider) {
          case VectorDatabaseProviderEnum.Voy: {
            const voyClient = new Voy({
              embeddings: data
            });
            const store = new VoyVectorStore(voyClient, embedding);
            const documents2 = await store.similaritySearchWithScore(...args);
            return documents2;
          }
          case VectorDatabaseProviderEnum.Memory: {
            const store = new MemoryVectorStore(embedding);
            store.memoryVectors = data;
            const documents2 = await store.similaritySearchWithScore(...args);
            return documents2;
          }
          default:
            throw new Error("Invalid provider");
        }
      }
    };
  };
  const defaultLocalEmbeddingState = {
    ready: false,
    embedding: void 0,
    embeddingStorage: void 0
  };
  useLocalEmbeddingState = create()(devtools((set, get2) => ({
    ...defaultLocalEmbeddingState,
    ...getLocalEmbeddingStateActions(set, get2)
  })));
  function ThemeProvider({ children }) {
    const theme = useAppState((state) => state.theme);
    reactExports.useEffect(() => {
      const inputTheme = theme || "light";
      const root = window.document.documentElement;
      root.classList.remove("light", "dark");
      if (inputTheme === "system") {
        const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        root.classList.add(systemTheme);
        return;
      }
      root.classList.add(inputTheme);
    }, [
      theme
    ]);
    return children;
  }
  const useAppHydration = () => {
    const [hydrated, setHydrated] = reactExports.useState(false);
    reactExports.useEffect(() => {
      const unsubHydrate = useAppState.persist.onHydrate(() => setHydrated(false));
      const unsubFinishHydration = useAppState.persist.onFinishHydration(() => setHydrated(true));
      setHydrated(useAppState.persist.hasHydrated());
      return () => {
        unsubHydrate();
        unsubFinishHydration();
      };
    }, []);
    return hydrated;
  };
  const AppRoute = reactExports.lazy(() => __vitePreload(() => import("./routes-Q3DgWzwS.js").then(async (m2) => {
    await m2.__tla;
    return m2;
  }).then((n2) => n2.aO), true ? [] : void 0));
  dayjs_minExports.extend(relatedTime);
  TextToSpeech.init();
  const logErrorHook = (error, info) => {
    logError(error, info);
  };
  const MainApp = reactExports.memo(() => {
    const initSessionState = useSessionState((state) => state.init);
    const initLocalLLMState = useLocalLLMState((state) => state.init);
    const initLocalEmbeddingState = useLocalEmbeddingState((state) => state.init);
    const ready = useSessionState((state) => state.ready);
    const error = useSessionState((state) => state.error);
    const hydrated = useAppHydration();
    reactExports.useEffect(() => {
      initSessionState();
      initLocalLLMState();
      initLocalEmbeddingState();
    }, [
      initLocalEmbeddingState,
      initLocalLLMState,
      initSessionState
    ]);
    if (error) {
      return jsxRuntimeExports.jsx(DefaultError, {
        error
      });
    } else if (!ready || !hydrated) {
      return jsxRuntimeExports.jsx(DefaultLoader, {
        className: "w-screen h-screen"
      });
    }
    return jsxRuntimeExports.jsx(NiceModal.Provider, {
      children: jsxRuntimeExports.jsx(ErrorBoundary, {
        fallback: jsxRuntimeExports.jsx(DefaultError, {}),
        onError: logErrorHook,
        children: jsxRuntimeExports.jsx(reactExports.Suspense, {
          fallback: jsxRuntimeExports.jsx(DefaultLoader, {
            className: "w-screen h-screen"
          }),
          children: jsxRuntimeExports.jsx(AppRoute, {})
        })
      })
    });
  });
  const App = reactExports.memo(() => {
    return jsxRuntimeExports.jsx(ThemeProvider, {
      children: jsxRuntimeExports.jsxs(FileSystemProvider, {
        children: [
          jsxRuntimeExports.jsx(MainApp, {}),
          jsxRuntimeExports.jsx(Toaster, {})
        ]
      })
    });
  });
  createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(reactExports.StrictMode, {
    children: jsxRuntimeExports.jsx(App, {})
  }));
})();
export {
  useLocalLLMState as $,
  composeRefs as A,
  dispatchDiscreteCustomEvent as B,
  SessionTypeEnum as C,
  DismissableLayer as D,
  DefaultLoader as E,
  logDebug as F,
  useConstant as G,
  motionValue as H,
  useIsomorphicLayoutEffect as I,
  cancelFrame as J,
  frame as K,
  LazyIcon as L,
  MotionConfigContext as M,
  interpolate as N,
  collectMotionValues as O,
  Primitive as P,
  isMotionValue as Q,
  React$1 as R,
  Slot as S,
  frameData as T,
  animateValue as U,
  create as V,
  subscribeWithSelector as W,
  devtools as X,
  FlowNodeTypeEnum as Y,
  VisuallyHidden as Z,
  __vitePreload as _,
  __tla,
  ReactDOM$1 as a,
  customAlphabet as a0,
  React as a1,
  toast as a2,
  encodeCSVData as a3,
  logWarn as a4,
  encodeSplitter as a5,
  VectorDatabaseTypeEnum as a6,
  VectorDatabaseStorageEnum as a7,
  VectorDatabaseProviderEnum as a8,
  flowNodeTypeToEntity as a9,
  process$1 as aA,
  DEFAULT_EMBEDDING_MODEL as aB,
  ReactDOM as aC,
  twMerge as aD,
  cx as aE,
  getAugmentedNamespace as aF,
  commonjsRequire as aG,
  require$$5 as aH,
  __viteBrowserExternal$1 as aI,
  SessionStatusEnum as aa,
  logError as ab,
  Runnable as ac,
  HumanMessage as ad,
  Serializable as ae,
  AIMessage as af,
  decodeCSVData as ag,
  SystemMessage as ah,
  useLocalEmbeddingState as ai,
  getStorageDataSource as aj,
  textToSpeech as ak,
  getDefaultExportFromCjs$1 as al,
  clsx as am,
  dayjs as an,
  decodeLine as ao,
  decodeSplitter as ap,
  Document as aq,
  MotionValue as ar,
  nanoid as as,
  isDev as at,
  PresenceContext as au,
  LayoutGroupContext as av,
  commonjsGlobal as aw,
  Buffer$1 as ax,
  require$$0 as ay,
  Buffer2 as az,
  useControllableState as b,
  createContextScope as c,
  composeEventHandlers as d,
  Presence as e,
  useComposedRefs as f,
  cn as g,
  cva as h,
  useCallbackRef as i,
  jsxRuntimeExports as j,
  createContext2 as k,
  Portal as l,
  reactDomExports as m,
  Slottable as n,
  Root as o,
  useTranslation as p,
  motion as q,
  reactExports as r,
  useSessionState as s,
  useAppState as t,
  useLayoutEffect2 as u,
  create$1 as v,
  useModal as w,
  useToast as x,
  getRepository as y,
  createCollection as z
};
