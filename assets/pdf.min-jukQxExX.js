const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-Bs2EL0Mm.js","assets/index-DAbXUXm9.css"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
import { aA as process$1, _ as __vitePreload, az as Buffer2, __tla as __tla_0 } from "./index-Bs2EL0Mm.js";
import { aq as global, __tla as __tla_1 } from "./use-llm-Kc_COJca.js";
import { __tla as __tla_2 } from "./routes-Q3DgWzwS.js";
let te, ee, ie, se, ne, re, ae, oe, le, he, ce, de, ue, pe, ge, fe, me, be, ve, ye, Ae, we, xe, _e, Ee, Ce, Se, Te, Me, ke, Pe, Re, De, Ie, Fe, Le, Oe, Ne, Be, He, Ue, ze, je;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_2;
    } catch {
    }
  })()
]).then(async () => {
  var _Util_static, t_fn, e_fn, _i, _s, _n, _r, _a, _o, _l, _EditorToolbar_static, h_fn, _EditorToolbar_instances, d_fn, u_fn, p_fn, c_fn, g_get, _a2, _s2, _f, _HighlightToolbar_instances, m_fn, v_fn, b_fn, _y, _A, _y2, _w, _ImageManager_instances, x_fn, __, _E, _C, _S, _KeyboardManager_instances, T_fn, _M, _k, _P, _R, _D, _I, _F, _L, _O, _N, _B, _H, _U, _z, _j, _W, _G, _V, _$, _q, _X, _K, _Y, _Q, _J, _Z, _tt, _et, _it, _st, _nt, _rt, _at, _ot, _lt, _ht, _ct, _dt, _ut, _pt, _gt, _AnnotationEditorUIManager_instances, vt_fn, yt_fn, At_fn, wt_fn, _t_fn, ft_fn, Et_fn, Ct_fn, bt_fn, St_fn, Tt_fn, Mt_fn, mt_fn, xt_fn, Rt_fn, It_fn, Ft_fn, kt_fn, Lt_get, Dt_fn, Pt_fn, _o2, _Ot, _Nt, _Bt, _Ht, _Ut, _zt, _jt, _r2, _Wt, _Gt, _Vt, _$t, _AltText_instances, qt_get, Xt_fn, _Kt, _Yt, _o3, _Qt, _Jt, _Zt, _te, _ee, _ie, _se, _ne, _re, _ae, _oe, _le, _he, _ce, _de, _ue, _pe, _AnnotationEditor_instances, fe_fn, _AnnotationEditor_static, me_fn, be_fn, ve_fn, ye_fn, we_fn, Ae_fn, Ee_fn, _e_fn, xe_fn, Ce_fn, Se_fn, Te_fn, Me_fn, ge_fn, _ke, _Pe, _Re, _AnnotationStorage_instances, De_fn, _Ie, _Fe, _Le, _CanvasGraphics_instances, Oe_fn, Ne_fn, _Be, _He, _Ue, _MessageHandler_instances, ze_fn, We_fn, je_fn, Ge_fn, _Ve, _$e, _qe, _Xe, _Ke, _Ye, _Qe, _Je, _Ze, _ti, _OptionalContentConfig_instances, ei_fn, _a3, _ii, _ut2, _si, _ni, _ri, _ai, _oi, _li, _hi, _ci, _di, _ui, _pi, _gi, _fi, _mi, _bi, _vi, _yi, _Ai, _wi, _xi, __i, _TextLayer_instances, Ci_fn, Mi_fn, Ti_fn, _TextLayer_static, Si_fn, Pi_fn, Ei_fn, ki_fn, _Ri, _Di, _Ii, _Fi, _Li, _Oi, _y3, _DOMFilterFactory_instances, w_get, Ni_get, Bi_get, Hi_fn, Ui_fn, $i_fn, Gi_fn, zi_fn, qi_fn, ji_fn, Vi_fn, Wi_fn, _b, _Fi2, _Xi, _Ki, _PDFPageProxy_instances, Qi_fn, Yi_fn, _Ji, _Zi, _ts, _es, _is, _PDFWorker_instances, ss_fn, _PDFWorker_static, ns_get, _rs, _as, _os, _ls, _hs, _WorkerTransport_instances, cs_fn, _ds, _PDFObjects_instances, us_fn, _ps, _gs, _fs, _ms, _bs, _vs, _AnnotationElement_instances, ys_fn, _LinkAnnotationElement_instances, xs_fn, As_fn, ws_fn, __s, _Cs, _Ts, _ks, _Rs, _ut3, _Ds, _Is, _Fs, _Ls, _Os, _Ns, _Bs, _S2, _Hs, _Us, _zs, _ms2, _js, _PopupElement_instances, Ws_get, Gs_get, Vs_get, $s_fn, Es_fn, qs_fn, Ps_fn, Ms_fn, Ss_fn, _Xs, _Ks, _Ys, _Qs, _Js, _Zs, _FileAttachmentAnnotationElement_instances, tn_fn, _en, _in, _sn, _nn, _AnnotationLayer_instances, rn_fn, an_fn, _Rs2, _on, _ln, _hn, _Gs, _FreeTextEditor_instances, cn_fn, dn_fn, pn_fn, un_fn, _FreeTextEditor_static, gn_fn, fn_fn, bn_fn, mn_fn, vn_fn, _yn, _An, _wn, _xn, __n, _En, _Cn, _Sn, _Tn, _Mn, _kn, _Pn, _Rn, _Dn, _In, _Fn, _FreeDrawOutliner_instances, Ln_fn, On_fn, Bn_fn, Nn_fn, Hn_fn, zn_fn, Un_fn, _yn2, _jn, _wn2, _xn2, _Rn2, _kn2, _Wn, _FreeDrawOutline_instances, Vn_fn, $n_fn, Gn_fn, _yn3, _qn, _Xn, _HighlightOutliner_instances, Jn_fn, Zn_fn, Yn_fn, Qn_fn, Kn_fn, _yn4, _tr, _er, _ir, _sr, _nr, _rr, _ar, _r3, _or, _lr, _f2, _hr, _cr, _ColorPicker_instances, ur_fn, pr_fn, Es_fn2, dr_fn, h_fn2, gr_get, _fr, _mr, _br, _vr, _n2, _yr, _Ar, _wr, _xr, __r, _y4, _Er, _Cr, _Sr, _Tr, _Mr, _Pn2, _kr, _HighlightEditor_instances, Dr_fn, Pr_fn, dn_fn2, Fr_fn, Lr_fn, Nr_fn, Rr_fn, _HighlightEditor_static, Ir_fn, Br_fn, Hr_fn, Or_fn, Ur_fn, zr_fn, Wr_fn, jr_fn, vn_fn2, _Gr, _Vr, _$r, _qr, _Xr, _Kr, _Yr, _Qr, _Jr, _Zr, _ta, _ea, _ia, _InkEditor_instances, Fr_fn2, dn_fn3, sa_fn, da_fn, ua_fn, pa_fn, fa_fn, ba_fn, va_fn, ga_fn, ma_fn, ya_fn, ra_fn, ha_fn, ca_fn, wa_fn, aa_fn, oa_fn, la_fn, xa_fn, Aa_fn, _InkEditor_static, Ea_fn, Ca_fn, Sa_fn, Ta_fn, Ma_fn, _a_fn, na_fn, _ka, _Pa, _Ra, _Da, _Ia, _Fa, _La, _Jr2, _Oa, _Na, _Ba, _StampEditor_instances, Ha_fn, Ua_fn, za_fn, aa_fn2, Ga_fn, Wa_fn, ja_fn, Va_fn, oa_fn2, vn_fn3, _en2, _$a, _qa, _Xa, _Ka, _Ya, _Qa, _Ja, _Za, _to, _eo, _f3, _U2, _AnnotationEditorLayer_instances, so_fn, no_get, ro_fn, ao_fn, io_fn, _Ls2, _y5, _oo, _lo, _DrawLayer_static, ho_fn, _DrawLayer_instances, co_fn, do_fn;
  var t = {
    9306: (t2, e2, i2) => {
      var s2 = i2(4901), n2 = i2(6823), r2 = TypeError;
      t2.exports = function(t3) {
        if (s2(t3)) return t3;
        throw new r2(n2(t3) + " is not a function");
      };
    },
    3506: (t2, e2, i2) => {
      var s2 = i2(3925), n2 = String, r2 = TypeError;
      t2.exports = function(t3) {
        if (s2(t3)) return t3;
        throw new r2("Can't set " + n2(t3) + " as a prototype");
      };
    },
    7080: (t2, e2, i2) => {
      var s2 = i2(4402).has;
      t2.exports = function(t3) {
        s2(t3);
        return t3;
      };
    },
    679: (t2, e2, i2) => {
      var s2 = i2(1625), n2 = TypeError;
      t2.exports = function(t3, e3) {
        if (s2(e3, t3)) return t3;
        throw new n2("Incorrect invocation");
      };
    },
    8551: (t2, e2, i2) => {
      var s2 = i2(34), n2 = String, r2 = TypeError;
      t2.exports = function(t3) {
        if (s2(t3)) return t3;
        throw new r2(n2(t3) + " is not an object");
      };
    },
    7811: (t2) => {
      t2.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
    },
    7394: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(6706), r2 = i2(2195), a2 = s2.ArrayBuffer, o2 = s2.TypeError;
      t2.exports = a2 && n2(a2.prototype, "byteLength", "get") || function(t3) {
        if ("ArrayBuffer" !== r2(t3)) throw new o2("ArrayBuffer expected");
        return t3.byteLength;
      };
    },
    3238: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(7476), r2 = i2(7394), a2 = s2.ArrayBuffer, o2 = a2 && a2.prototype, l2 = o2 && n2(o2.slice);
      t2.exports = function(t3) {
        if (0 !== r2(t3)) return false;
        if (!l2) return false;
        try {
          l2(t3, 0, 0);
          return false;
        } catch (t4) {
          return true;
        }
      };
    },
    5169: (t2, e2, i2) => {
      var s2 = i2(3238), n2 = TypeError;
      t2.exports = function(t3) {
        if (s2(t3)) throw new n2("ArrayBuffer is detached");
        return t3;
      };
    },
    5636: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(9504), r2 = i2(6706), a2 = i2(7696), o2 = i2(5169), l2 = i2(7394), h2 = i2(4483), c2 = i2(1548), d2 = s2.structuredClone, u2 = s2.ArrayBuffer, p2 = s2.DataView, g2 = Math.min, f2 = u2.prototype, m2 = p2.prototype, b2 = n2(f2.slice), v2 = r2(f2, "resizable", "get"), y2 = r2(f2, "maxByteLength", "get"), A2 = n2(m2.getInt8), w2 = n2(m2.setInt8);
      t2.exports = (c2 || h2) && function(t3, e3, i3) {
        var s3, n3 = l2(t3), r3 = void 0 === e3 ? n3 : a2(e3), f3 = !v2 || !v2(t3);
        o2(t3);
        if (c2) {
          t3 = d2(t3, {
            transfer: [
              t3
            ]
          });
          if (n3 === r3 && (i3 || f3)) return t3;
        }
        if (n3 >= r3 && (!i3 || f3)) s3 = b2(t3, 0, r3);
        else {
          var m3 = i3 && !f3 && y2 ? {
            maxByteLength: y2(t3)
          } : void 0;
          s3 = new u2(r3, m3);
          for (var x2 = new p2(t3), _2 = new p2(s3), E2 = g2(r3, n3), C2 = 0; C2 < E2; C2++) w2(_2, C2, A2(x2, C2));
        }
        c2 || h2(t3);
        return s3;
      };
    },
    4644: (t2, e2, i2) => {
      var s2, n2, r2, a2 = i2(7811), o2 = i2(3724), l2 = i2(4576), h2 = i2(4901), c2 = i2(34), d2 = i2(9297), u2 = i2(6955), p2 = i2(6823), g2 = i2(6699), f2 = i2(6840), m2 = i2(2106), b2 = i2(1625), v2 = i2(2787), y2 = i2(2967), A2 = i2(8227), w2 = i2(3392), x2 = i2(1181), _2 = x2.enforce, E2 = x2.get, C2 = l2.Int8Array, S2 = C2 && C2.prototype, T2 = l2.Uint8ClampedArray, M2 = T2 && T2.prototype, k2 = C2 && v2(C2), P2 = S2 && v2(S2), R2 = Object.prototype, D2 = l2.TypeError, I2 = A2("toStringTag"), L2 = w2("TYPED_ARRAY_TAG"), O2 = "TypedArrayConstructor", N2 = a2 && !!y2 && "Opera" !== u2(l2.opera), B2 = false, H2 = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, U2 = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, getTypedArrayConstructor = function(t3) {
        var e3 = v2(t3);
        if (c2(e3)) {
          var i3 = E2(e3);
          return i3 && d2(i3, O2) ? i3[O2] : getTypedArrayConstructor(e3);
        }
      }, isTypedArray = function(t3) {
        if (!c2(t3)) return false;
        var e3 = u2(t3);
        return d2(H2, e3) || d2(U2, e3);
      };
      for (s2 in H2) (r2 = (n2 = l2[s2]) && n2.prototype) ? _2(r2)[O2] = n2 : N2 = false;
      for (s2 in U2) (r2 = (n2 = l2[s2]) && n2.prototype) && (_2(r2)[O2] = n2);
      if (!N2 || !h2(k2) || k2 === Function.prototype) {
        k2 = function TypedArray() {
          throw new D2("Incorrect invocation");
        };
        if (N2) for (s2 in H2) l2[s2] && y2(l2[s2], k2);
      }
      if (!N2 || !P2 || P2 === R2) {
        P2 = k2.prototype;
        if (N2) for (s2 in H2) l2[s2] && y2(l2[s2].prototype, P2);
      }
      N2 && v2(M2) !== P2 && y2(M2, P2);
      if (o2 && !d2(P2, I2)) {
        B2 = true;
        m2(P2, I2, {
          configurable: true,
          get: function() {
            return c2(this) ? this[L2] : void 0;
          }
        });
        for (s2 in H2) l2[s2] && g2(l2[s2], L2, s2);
      }
      t2.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: N2,
        TYPED_ARRAY_TAG: B2 && L2,
        aTypedArray: function(t3) {
          if (isTypedArray(t3)) return t3;
          throw new D2("Target is not a typed array");
        },
        aTypedArrayConstructor: function(t3) {
          if (h2(t3) && (!y2 || b2(k2, t3))) return t3;
          throw new D2(p2(t3) + " is not a typed array constructor");
        },
        exportTypedArrayMethod: function(t3, e3, i3, s3) {
          if (o2) {
            if (i3) for (var n3 in H2) {
              var r3 = l2[n3];
              if (r3 && d2(r3.prototype, t3)) try {
                delete r3.prototype[t3];
              } catch (i4) {
                try {
                  r3.prototype[t3] = e3;
                } catch (t4) {
                }
              }
            }
            P2[t3] && !i3 || f2(P2, t3, i3 ? e3 : N2 && S2[t3] || e3, s3);
          }
        },
        exportTypedArrayStaticMethod: function(t3, e3, i3) {
          var s3, n3;
          if (o2) {
            if (y2) {
              if (i3) {
                for (s3 in H2) if ((n3 = l2[s3]) && d2(n3, t3)) try {
                  delete n3[t3];
                } catch (t4) {
                }
              }
              if (k2[t3] && !i3) return;
              try {
                return f2(k2, t3, i3 ? e3 : N2 && k2[t3] || e3);
              } catch (t4) {
              }
            }
            for (s3 in H2) !(n3 = l2[s3]) || n3[t3] && !i3 || f2(n3, t3, e3);
          }
        },
        getTypedArrayConstructor,
        isView: function isView(t3) {
          if (!c2(t3)) return false;
          var e3 = u2(t3);
          return "DataView" === e3 || d2(H2, e3) || d2(U2, e3);
        },
        isTypedArray,
        TypedArray: k2,
        TypedArrayPrototype: P2
      };
    },
    5370: (t2, e2, i2) => {
      var s2 = i2(6198);
      t2.exports = function(t3, e3, i3) {
        for (var n2 = 0, r2 = arguments.length > 2 ? i3 : s2(e3), a2 = new t3(r2); r2 > n2; ) a2[n2] = e3[n2++];
        return a2;
      };
    },
    9617: (t2, e2, i2) => {
      var s2 = i2(5397), n2 = i2(5610), r2 = i2(6198), createMethod = function(t3) {
        return function(e3, i3, a2) {
          var o2 = s2(e3), l2 = r2(o2);
          if (0 === l2) return !t3 && -1;
          var h2, c2 = n2(a2, l2);
          if (t3 && i3 != i3) {
            for (; l2 > c2; ) if ((h2 = o2[c2++]) != h2) return true;
          } else for (; l2 > c2; c2++) if ((t3 || c2 in o2) && o2[c2] === i3) return t3 || c2 || 0;
          return !t3 && -1;
        };
      };
      t2.exports = {
        includes: createMethod(true),
        indexOf: createMethod(false)
      };
    },
    4527: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(4376), r2 = TypeError, a2 = Object.getOwnPropertyDescriptor, o2 = s2 && !function() {
        if (void 0 !== this) return true;
        try {
          Object.defineProperty([], "length", {
            writable: false
          }).length = 1;
        } catch (t3) {
          return t3 instanceof TypeError;
        }
      }();
      t2.exports = o2 ? function(t3, e3) {
        if (n2(t3) && !a2(t3, "length").writable) throw new r2("Cannot set read only .length");
        return t3.length = e3;
      } : function(t3, e3) {
        return t3.length = e3;
      };
    },
    7628: (t2, e2, i2) => {
      var s2 = i2(6198);
      t2.exports = function(t3, e3) {
        for (var i3 = s2(t3), n2 = new e3(i3), r2 = 0; r2 < i3; r2++) n2[r2] = t3[i3 - r2 - 1];
        return n2;
      };
    },
    9928: (t2, e2, i2) => {
      var s2 = i2(6198), n2 = i2(1291), r2 = RangeError;
      t2.exports = function(t3, e3, i3, a2) {
        var o2 = s2(t3), l2 = n2(i3), h2 = l2 < 0 ? o2 + l2 : l2;
        if (h2 >= o2 || h2 < 0) throw new r2("Incorrect index");
        for (var c2 = new e3(o2), d2 = 0; d2 < o2; d2++) c2[d2] = d2 === h2 ? a2 : t3[d2];
        return c2;
      };
    },
    6319: (t2, e2, i2) => {
      var s2 = i2(8551), n2 = i2(9539);
      t2.exports = function(t3, e3, i3, r2) {
        try {
          return r2 ? e3(s2(i3)[0], i3[1]) : e3(i3);
        } catch (e4) {
          n2(t3, "throw", e4);
        }
      };
    },
    2195: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = s2({}.toString), r2 = s2("".slice);
      t2.exports = function(t3) {
        return r2(n2(t3), 8, -1);
      };
    },
    6955: (t2, e2, i2) => {
      var s2 = i2(2140), n2 = i2(4901), r2 = i2(2195), a2 = i2(8227)("toStringTag"), o2 = Object, l2 = "Arguments" === r2(/* @__PURE__ */ function() {
        return arguments;
      }());
      t2.exports = s2 ? r2 : function(t3) {
        var e3, i3, s3;
        return void 0 === t3 ? "Undefined" : null === t3 ? "Null" : "string" == typeof (i3 = function(t4, e4) {
          try {
            return t4[e4];
          } catch (t5) {
          }
        }(e3 = o2(t3), a2)) ? i3 : l2 ? r2(e3) : "Object" === (s3 = r2(e3)) && n2(e3.callee) ? "Arguments" : s3;
      };
    },
    7740: (t2, e2, i2) => {
      var s2 = i2(9297), n2 = i2(5031), r2 = i2(7347), a2 = i2(4913);
      t2.exports = function(t3, e3, i3) {
        for (var o2 = n2(e3), l2 = a2.f, h2 = r2.f, c2 = 0; c2 < o2.length; c2++) {
          var d2 = o2[c2];
          s2(t3, d2) || i3 && s2(i3, d2) || l2(t3, d2, h2(e3, d2));
        }
      };
    },
    2211: (t2, e2, i2) => {
      var s2 = i2(9039);
      t2.exports = !s2(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    },
    2529: (t2) => {
      t2.exports = function(t3, e2) {
        return {
          value: t3,
          done: e2
        };
      };
    },
    6699: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(4913), r2 = i2(6980);
      t2.exports = s2 ? function(t3, e3, i3) {
        return n2.f(t3, e3, r2(1, i3));
      } : function(t3, e3, i3) {
        t3[e3] = i3;
        return t3;
      };
    },
    6980: (t2) => {
      t2.exports = function(t3, e2) {
        return {
          enumerable: !(1 & t3),
          configurable: !(2 & t3),
          writable: !(4 & t3),
          value: e2
        };
      };
    },
    4659: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(4913), r2 = i2(6980);
      t2.exports = function(t3, e3, i3) {
        s2 ? n2.f(t3, e3, r2(0, i3)) : t3[e3] = i3;
      };
    },
    2106: (t2, e2, i2) => {
      var s2 = i2(283), n2 = i2(4913);
      t2.exports = function(t3, e3, i3) {
        i3.get && s2(i3.get, e3, {
          getter: true
        });
        i3.set && s2(i3.set, e3, {
          setter: true
        });
        return n2.f(t3, e3, i3);
      };
    },
    6840: (t2, e2, i2) => {
      var s2 = i2(4901), n2 = i2(4913), r2 = i2(283), a2 = i2(9433);
      t2.exports = function(t3, e3, i3, o2) {
        o2 || (o2 = {});
        var l2 = o2.enumerable, h2 = void 0 !== o2.name ? o2.name : e3;
        s2(i3) && r2(i3, h2, o2);
        if (o2.global) l2 ? t3[e3] = i3 : a2(e3, i3);
        else {
          try {
            o2.unsafe ? t3[e3] && (l2 = true) : delete t3[e3];
          } catch (t4) {
          }
          l2 ? t3[e3] = i3 : n2.f(t3, e3, {
            value: i3,
            enumerable: false,
            configurable: !o2.nonConfigurable,
            writable: !o2.nonWritable
          });
        }
        return t3;
      };
    },
    6279: (t2, e2, i2) => {
      var s2 = i2(6840);
      t2.exports = function(t3, e3, i3) {
        for (var n2 in e3) s2(t3, n2, e3[n2], i3);
        return t3;
      };
    },
    9433: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = Object.defineProperty;
      t2.exports = function(t3, e3) {
        try {
          n2(s2, t3, {
            value: e3,
            configurable: true,
            writable: true
          });
        } catch (i3) {
          s2[t3] = e3;
        }
        return e3;
      };
    },
    3724: (t2, e2, i2) => {
      var s2 = i2(9039);
      t2.exports = !s2(function() {
        return 7 !== Object.defineProperty({}, 1, {
          get: function() {
            return 7;
          }
        })[1];
      });
    },
    4483: (t2, e2, i2) => {
      var s2, n2, r2, a2, o2 = i2(4576), l2 = i2(9429), h2 = i2(1548), c2 = o2.structuredClone, d2 = o2.ArrayBuffer, u2 = o2.MessageChannel, p2 = false;
      if (h2) p2 = function(t3) {
        c2(t3, {
          transfer: [
            t3
          ]
        });
      };
      else if (d2) try {
        u2 || (s2 = l2("worker_threads")) && (u2 = s2.MessageChannel);
        if (u2) {
          n2 = new u2();
          r2 = new d2(2);
          a2 = function(t3) {
            n2.port1.postMessage(null, [
              t3
            ]);
          };
          if (2 === r2.byteLength) {
            a2(r2);
            0 === r2.byteLength && (p2 = a2);
          }
        }
      } catch (t3) {
      }
      t2.exports = p2;
    },
    4055: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(34), r2 = s2.document, a2 = n2(r2) && n2(r2.createElement);
      t2.exports = function(t3) {
        return a2 ? r2.createElement(t3) : {};
      };
    },
    6837: (t2) => {
      var e2 = TypeError;
      t2.exports = function(t3) {
        if (t3 > 9007199254740991) throw e2("Maximum allowed index exceeded");
        return t3;
      };
    },
    5002: (t2) => {
      t2.exports = {
        IndexSizeError: {
          s: "INDEX_SIZE_ERR",
          c: 1,
          m: 1
        },
        DOMStringSizeError: {
          s: "DOMSTRING_SIZE_ERR",
          c: 2,
          m: 0
        },
        HierarchyRequestError: {
          s: "HIERARCHY_REQUEST_ERR",
          c: 3,
          m: 1
        },
        WrongDocumentError: {
          s: "WRONG_DOCUMENT_ERR",
          c: 4,
          m: 1
        },
        InvalidCharacterError: {
          s: "INVALID_CHARACTER_ERR",
          c: 5,
          m: 1
        },
        NoDataAllowedError: {
          s: "NO_DATA_ALLOWED_ERR",
          c: 6,
          m: 0
        },
        NoModificationAllowedError: {
          s: "NO_MODIFICATION_ALLOWED_ERR",
          c: 7,
          m: 1
        },
        NotFoundError: {
          s: "NOT_FOUND_ERR",
          c: 8,
          m: 1
        },
        NotSupportedError: {
          s: "NOT_SUPPORTED_ERR",
          c: 9,
          m: 1
        },
        InUseAttributeError: {
          s: "INUSE_ATTRIBUTE_ERR",
          c: 10,
          m: 1
        },
        InvalidStateError: {
          s: "INVALID_STATE_ERR",
          c: 11,
          m: 1
        },
        SyntaxError: {
          s: "SYNTAX_ERR",
          c: 12,
          m: 1
        },
        InvalidModificationError: {
          s: "INVALID_MODIFICATION_ERR",
          c: 13,
          m: 1
        },
        NamespaceError: {
          s: "NAMESPACE_ERR",
          c: 14,
          m: 1
        },
        InvalidAccessError: {
          s: "INVALID_ACCESS_ERR",
          c: 15,
          m: 1
        },
        ValidationError: {
          s: "VALIDATION_ERR",
          c: 16,
          m: 0
        },
        TypeMismatchError: {
          s: "TYPE_MISMATCH_ERR",
          c: 17,
          m: 1
        },
        SecurityError: {
          s: "SECURITY_ERR",
          c: 18,
          m: 1
        },
        NetworkError: {
          s: "NETWORK_ERR",
          c: 19,
          m: 1
        },
        AbortError: {
          s: "ABORT_ERR",
          c: 20,
          m: 1
        },
        URLMismatchError: {
          s: "URL_MISMATCH_ERR",
          c: 21,
          m: 1
        },
        QuotaExceededError: {
          s: "QUOTA_EXCEEDED_ERR",
          c: 22,
          m: 1
        },
        TimeoutError: {
          s: "TIMEOUT_ERR",
          c: 23,
          m: 1
        },
        InvalidNodeTypeError: {
          s: "INVALID_NODE_TYPE_ERR",
          c: 24,
          m: 1
        },
        DataCloneError: {
          s: "DATA_CLONE_ERR",
          c: 25,
          m: 1
        }
      };
    },
    8727: (t2) => {
      t2.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    },
    6193: (t2, e2, i2) => {
      var s2 = i2(4215);
      t2.exports = "NODE" === s2;
    },
    2839: (t2, e2, i2) => {
      var s2 = i2(4576).navigator, n2 = s2 && s2.userAgent;
      t2.exports = n2 ? String(n2) : "";
    },
    9519: (t2, e2, i2) => {
      var s2, n2, r2 = i2(4576), a2 = i2(2839), o2 = r2.process, l2 = r2.Deno, h2 = o2 && o2.versions || l2 && l2.version, c2 = h2 && h2.v8;
      c2 && (n2 = (s2 = c2.split("."))[0] > 0 && s2[0] < 4 ? 1 : +(s2[0] + s2[1]));
      !n2 && a2 && (!(s2 = a2.match(/Edge\/(\d+)/)) || s2[1] >= 74) && (s2 = a2.match(/Chrome\/(\d+)/)) && (n2 = +s2[1]);
      t2.exports = n2;
    },
    4215: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(2839), r2 = i2(2195), userAgentStartsWith = function(t3) {
        return n2.slice(0, t3.length) === t3;
      };
      t2.exports = userAgentStartsWith("Bun/") ? "BUN" : userAgentStartsWith("Cloudflare-Workers") ? "CLOUDFLARE" : userAgentStartsWith("Deno/") ? "DENO" : userAgentStartsWith("Node.js/") ? "NODE" : s2.Bun && "string" == typeof Bun.version ? "BUN" : s2.Deno && "object" == typeof Deno.version ? "DENO" : "process" === r2(s2.process) ? "NODE" : s2.window && s2.document ? "BROWSER" : "REST";
    },
    8574: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = Error, r2 = s2("".replace), a2 = String(new n2("zxcasd").stack), o2 = /\n\s*at [^:]*:[^\n]*/, l2 = o2.test(a2);
      t2.exports = function(t3, e3) {
        if (l2 && "string" == typeof t3 && !n2.prepareStackTrace) for (; e3--; ) t3 = r2(t3, o2, "");
        return t3;
      };
    },
    6518: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(7347).f, r2 = i2(6699), a2 = i2(6840), o2 = i2(9433), l2 = i2(7740), h2 = i2(2796);
      t2.exports = function(t3, e3) {
        var i3, c2, d2, u2, p2, g2 = t3.target, f2 = t3.global, m2 = t3.stat;
        if (i3 = f2 ? s2 : m2 ? s2[g2] || o2(g2, {}) : s2[g2] && s2[g2].prototype) for (c2 in e3) {
          u2 = e3[c2];
          d2 = t3.dontCallGetSet ? (p2 = n2(i3, c2)) && p2.value : i3[c2];
          if (!h2(f2 ? c2 : g2 + (m2 ? "." : "#") + c2, t3.forced) && void 0 !== d2) {
            if (typeof u2 == typeof d2) continue;
            l2(u2, d2);
          }
          (t3.sham || d2 && d2.sham) && r2(u2, "sham", true);
          a2(i3, c2, u2, t3);
        }
      };
    },
    9039: (t2) => {
      t2.exports = function(t3) {
        try {
          return !!t3();
        } catch (t4) {
          return true;
        }
      };
    },
    6080: (t2, e2, i2) => {
      var s2 = i2(7476), n2 = i2(9306), r2 = i2(616), a2 = s2(s2.bind);
      t2.exports = function(t3, e3) {
        n2(t3);
        return void 0 === e3 ? t3 : r2 ? a2(t3, e3) : function() {
          return t3.apply(e3, arguments);
        };
      };
    },
    616: (t2, e2, i2) => {
      var s2 = i2(9039);
      t2.exports = !s2(function() {
        var t3 = (function() {
        }).bind();
        return "function" != typeof t3 || t3.hasOwnProperty("prototype");
      });
    },
    9565: (t2, e2, i2) => {
      var s2 = i2(616), n2 = Function.prototype.call;
      t2.exports = s2 ? n2.bind(n2) : function() {
        return n2.apply(n2, arguments);
      };
    },
    350: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(9297), r2 = Function.prototype, a2 = s2 && Object.getOwnPropertyDescriptor, o2 = n2(r2, "name"), l2 = o2 && "something" === (function something() {
      }).name, h2 = o2 && (!s2 || s2 && a2(r2, "name").configurable);
      t2.exports = {
        EXISTS: o2,
        PROPER: l2,
        CONFIGURABLE: h2
      };
    },
    6706: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(9306);
      t2.exports = function(t3, e3, i3) {
        try {
          return s2(n2(Object.getOwnPropertyDescriptor(t3, e3)[i3]));
        } catch (t4) {
        }
      };
    },
    7476: (t2, e2, i2) => {
      var s2 = i2(2195), n2 = i2(9504);
      t2.exports = function(t3) {
        if ("Function" === s2(t3)) return n2(t3);
      };
    },
    9504: (t2, e2, i2) => {
      var s2 = i2(616), n2 = Function.prototype, r2 = n2.call, a2 = s2 && n2.bind.bind(r2, r2);
      t2.exports = s2 ? a2 : function(t3) {
        return function() {
          return r2.apply(t3, arguments);
        };
      };
    },
    9429: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(6193);
      t2.exports = function(t3) {
        if (n2) {
          try {
            return s2.process.getBuiltinModule(t3);
          } catch (t4) {
          }
          try {
            return Function('return require("' + t3 + '")')();
          } catch (t4) {
          }
        }
      };
    },
    7751: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(4901);
      t2.exports = function(t3, e3) {
        return arguments.length < 2 ? (i3 = s2[t3], n2(i3) ? i3 : void 0) : s2[t3] && s2[t3][e3];
        var i3;
      };
    },
    1767: (t2) => {
      t2.exports = function(t3) {
        return {
          iterator: t3,
          next: t3.next,
          done: false
        };
      };
    },
    8646: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(8551), r2 = i2(1767), a2 = i2(851);
      t2.exports = function(t3, e3) {
        e3 && "string" == typeof t3 || n2(t3);
        var i3 = a2(t3);
        return r2(n2(void 0 !== i3 ? s2(i3, t3) : t3));
      };
    },
    851: (t2, e2, i2) => {
      var s2 = i2(6955), n2 = i2(5966), r2 = i2(4117), a2 = i2(6269), o2 = i2(8227)("iterator");
      t2.exports = function(t3) {
        if (!r2(t3)) return n2(t3, o2) || n2(t3, "@@iterator") || a2[s2(t3)];
      };
    },
    81: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(9306), r2 = i2(8551), a2 = i2(6823), o2 = i2(851), l2 = TypeError;
      t2.exports = function(t3, e3) {
        var i3 = arguments.length < 2 ? o2(t3) : e3;
        if (n2(i3)) return r2(s2(i3, t3));
        throw new l2(a2(t3) + " is not iterable");
      };
    },
    5966: (t2, e2, i2) => {
      var s2 = i2(9306), n2 = i2(4117);
      t2.exports = function(t3, e3) {
        var i3 = t3[e3];
        return n2(i3) ? void 0 : s2(i3);
      };
    },
    3789: (t2, e2, i2) => {
      var s2 = i2(9306), n2 = i2(8551), r2 = i2(9565), a2 = i2(1291), o2 = i2(1767), l2 = "Invalid size", h2 = RangeError, c2 = TypeError, d2 = Math.max, SetRecord = function(t3, e3) {
        this.set = t3;
        this.size = d2(e3, 0);
        this.has = s2(t3.has);
        this.keys = s2(t3.keys);
      };
      SetRecord.prototype = {
        getIterator: function() {
          return o2(n2(r2(this.keys, this.set)));
        },
        includes: function(t3) {
          return r2(this.has, this.set, t3);
        }
      };
      t2.exports = function(t3) {
        n2(t3);
        var e3 = +t3.size;
        if (e3 != e3) throw new c2(l2);
        var i3 = a2(e3);
        if (i3 < 0) throw new h2(l2);
        return new SetRecord(t3, i3);
      };
    },
    4576: function(t2) {
      var check = function(t3) {
        return t3 && t3.Math === Math && t3;
      };
      t2.exports = check("object" == typeof globalThis && globalThis) || check("object" == typeof window && window) || check("object" == typeof self && self) || check("object" == typeof global && global) || check("object" == typeof this && this) || /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")();
    },
    9297: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(8981), r2 = s2({}.hasOwnProperty);
      t2.exports = Object.hasOwn || function hasOwn(t3, e3) {
        return r2(n2(t3), e3);
      };
    },
    421: (t2) => {
      t2.exports = {};
    },
    397: (t2, e2, i2) => {
      var s2 = i2(7751);
      t2.exports = s2("document", "documentElement");
    },
    5917: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(9039), r2 = i2(4055);
      t2.exports = !s2 && !n2(function() {
        return 7 !== Object.defineProperty(r2("div"), "a", {
          get: function() {
            return 7;
          }
        }).a;
      });
    },
    7055: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(9039), r2 = i2(2195), a2 = Object, o2 = s2("".split);
      t2.exports = n2(function() {
        return !a2("z").propertyIsEnumerable(0);
      }) ? function(t3) {
        return "String" === r2(t3) ? o2(t3, "") : a2(t3);
      } : a2;
    },
    3167: (t2, e2, i2) => {
      var s2 = i2(4901), n2 = i2(34), r2 = i2(2967);
      t2.exports = function(t3, e3, i3) {
        var a2, o2;
        r2 && s2(a2 = e3.constructor) && a2 !== i3 && n2(o2 = a2.prototype) && o2 !== i3.prototype && r2(t3, o2);
        return t3;
      };
    },
    3706: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(4901), r2 = i2(7629), a2 = s2(Function.toString);
      n2(r2.inspectSource) || (r2.inspectSource = function(t3) {
        return a2(t3);
      });
      t2.exports = r2.inspectSource;
    },
    1181: (t2, e2, i2) => {
      var s2, n2, r2, a2 = i2(8622), o2 = i2(4576), l2 = i2(34), h2 = i2(6699), c2 = i2(9297), d2 = i2(7629), u2 = i2(6119), p2 = i2(421), g2 = "Object already initialized", f2 = o2.TypeError, m2 = o2.WeakMap;
      if (a2 || d2.state) {
        var b2 = d2.state || (d2.state = new m2());
        b2.get = b2.get;
        b2.has = b2.has;
        b2.set = b2.set;
        s2 = function(t3, e3) {
          if (b2.has(t3)) throw new f2(g2);
          e3.facade = t3;
          b2.set(t3, e3);
          return e3;
        };
        n2 = function(t3) {
          return b2.get(t3) || {};
        };
        r2 = function(t3) {
          return b2.has(t3);
        };
      } else {
        var v2 = u2("state");
        p2[v2] = true;
        s2 = function(t3, e3) {
          if (c2(t3, v2)) throw new f2(g2);
          e3.facade = t3;
          h2(t3, v2, e3);
          return e3;
        };
        n2 = function(t3) {
          return c2(t3, v2) ? t3[v2] : {};
        };
        r2 = function(t3) {
          return c2(t3, v2);
        };
      }
      t2.exports = {
        set: s2,
        get: n2,
        has: r2,
        enforce: function(t3) {
          return r2(t3) ? n2(t3) : s2(t3, {});
        },
        getterFor: function(t3) {
          return function(e3) {
            var i3;
            if (!l2(e3) || (i3 = n2(e3)).type !== t3) throw new f2("Incompatible receiver, " + t3 + " required");
            return i3;
          };
        }
      };
    },
    4209: (t2, e2, i2) => {
      var s2 = i2(8227), n2 = i2(6269), r2 = s2("iterator"), a2 = Array.prototype;
      t2.exports = function(t3) {
        return void 0 !== t3 && (n2.Array === t3 || a2[r2] === t3);
      };
    },
    4376: (t2, e2, i2) => {
      var s2 = i2(2195);
      t2.exports = Array.isArray || function isArray(t3) {
        return "Array" === s2(t3);
      };
    },
    1108: (t2, e2, i2) => {
      var s2 = i2(6955);
      t2.exports = function(t3) {
        var e3 = s2(t3);
        return "BigInt64Array" === e3 || "BigUint64Array" === e3;
      };
    },
    4901: (t2) => {
      var e2 = "object" == typeof document && document.all;
      t2.exports = void 0 === e2 && void 0 !== e2 ? function(t3) {
        return "function" == typeof t3 || t3 === e2;
      } : function(t3) {
        return "function" == typeof t3;
      };
    },
    2796: (t2, e2, i2) => {
      var s2 = i2(9039), n2 = i2(4901), r2 = /#|\.prototype\./, isForced = function(t3, e3) {
        var i3 = o2[a2(t3)];
        return i3 === h2 || i3 !== l2 && (n2(e3) ? s2(e3) : !!e3);
      }, a2 = isForced.normalize = function(t3) {
        return String(t3).replace(r2, ".").toLowerCase();
      }, o2 = isForced.data = {}, l2 = isForced.NATIVE = "N", h2 = isForced.POLYFILL = "P";
      t2.exports = isForced;
    },
    4117: (t2) => {
      t2.exports = function(t3) {
        return null == t3;
      };
    },
    34: (t2, e2, i2) => {
      var s2 = i2(4901);
      t2.exports = function(t3) {
        return "object" == typeof t3 ? null !== t3 : s2(t3);
      };
    },
    3925: (t2, e2, i2) => {
      var s2 = i2(34);
      t2.exports = function(t3) {
        return s2(t3) || null === t3;
      };
    },
    6395: (t2) => {
      t2.exports = false;
    },
    757: (t2, e2, i2) => {
      var s2 = i2(7751), n2 = i2(4901), r2 = i2(1625), a2 = i2(7040), o2 = Object;
      t2.exports = a2 ? function(t3) {
        return "symbol" == typeof t3;
      } : function(t3) {
        var e3 = s2("Symbol");
        return n2(e3) && r2(e3.prototype, o2(t3));
      };
    },
    507: (t2, e2, i2) => {
      var s2 = i2(9565);
      t2.exports = function(t3, e3, i3) {
        for (var n2, r2, a2 = i3 ? t3 : t3.iterator, o2 = t3.next; !(n2 = s2(o2, a2)).done; ) if (void 0 !== (r2 = e3(n2.value))) return r2;
      };
    },
    2652: (t2, e2, i2) => {
      var s2 = i2(6080), n2 = i2(9565), r2 = i2(8551), a2 = i2(6823), o2 = i2(4209), l2 = i2(6198), h2 = i2(1625), c2 = i2(81), d2 = i2(851), u2 = i2(9539), p2 = TypeError, Result = function(t3, e3) {
        this.stopped = t3;
        this.result = e3;
      }, g2 = Result.prototype;
      t2.exports = function(t3, e3, i3) {
        var f2, m2, b2, v2, y2, A2, w2, x2 = i3 && i3.that, _2 = !(!i3 || !i3.AS_ENTRIES), E2 = !(!i3 || !i3.IS_RECORD), C2 = !(!i3 || !i3.IS_ITERATOR), S2 = !(!i3 || !i3.INTERRUPTED), T2 = s2(e3, x2), stop = function(t4) {
          f2 && u2(f2, "normal", t4);
          return new Result(true, t4);
        }, callFn = function(t4) {
          if (_2) {
            r2(t4);
            return S2 ? T2(t4[0], t4[1], stop) : T2(t4[0], t4[1]);
          }
          return S2 ? T2(t4, stop) : T2(t4);
        };
        if (E2) f2 = t3.iterator;
        else if (C2) f2 = t3;
        else {
          if (!(m2 = d2(t3))) throw new p2(a2(t3) + " is not iterable");
          if (o2(m2)) {
            for (b2 = 0, v2 = l2(t3); v2 > b2; b2++) if ((y2 = callFn(t3[b2])) && h2(g2, y2)) return y2;
            return new Result(false);
          }
          f2 = c2(t3, m2);
        }
        A2 = E2 ? t3.next : f2.next;
        for (; !(w2 = n2(A2, f2)).done; ) {
          try {
            y2 = callFn(w2.value);
          } catch (t4) {
            u2(f2, "throw", t4);
          }
          if ("object" == typeof y2 && y2 && h2(g2, y2)) return y2;
        }
        return new Result(false);
      };
    },
    9539: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(8551), r2 = i2(5966);
      t2.exports = function(t3, e3, i3) {
        var a2, o2;
        n2(t3);
        try {
          if (!(a2 = r2(t3, "return"))) {
            if ("throw" === e3) throw i3;
            return i3;
          }
          a2 = s2(a2, t3);
        } catch (t4) {
          o2 = true;
          a2 = t4;
        }
        if ("throw" === e3) throw i3;
        if (o2) throw a2;
        n2(a2);
        return i3;
      };
    },
    9462: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(2360), r2 = i2(6699), a2 = i2(6279), o2 = i2(8227), l2 = i2(1181), h2 = i2(5966), c2 = i2(7657).IteratorPrototype, d2 = i2(2529), u2 = i2(9539), p2 = o2("toStringTag"), g2 = "IteratorHelper", f2 = "WrapForValidIterator", m2 = l2.set, createIteratorProxyPrototype = function(t3) {
        var e3 = l2.getterFor(t3 ? f2 : g2);
        return a2(n2(c2), {
          next: function next() {
            var i3 = e3(this);
            if (t3) return i3.nextHandler();
            try {
              var s3 = i3.done ? void 0 : i3.nextHandler();
              return d2(s3, i3.done);
            } catch (t4) {
              i3.done = true;
              throw t4;
            }
          },
          return: function() {
            var i3 = e3(this), n3 = i3.iterator;
            i3.done = true;
            if (t3) {
              var r3 = h2(n3, "return");
              return r3 ? s2(r3, n3) : d2(void 0, true);
            }
            if (i3.inner) try {
              u2(i3.inner.iterator, "normal");
            } catch (t4) {
              return u2(n3, "throw", t4);
            }
            u2(n3, "normal");
            return d2(void 0, true);
          }
        });
      }, b2 = createIteratorProxyPrototype(true), v2 = createIteratorProxyPrototype(false);
      r2(v2, p2, "Iterator Helper");
      t2.exports = function(t3, e3) {
        var i3 = function Iterator(i4, s3) {
          if (s3) {
            s3.iterator = i4.iterator;
            s3.next = i4.next;
          } else s3 = i4;
          s3.type = e3 ? f2 : g2;
          s3.nextHandler = t3;
          s3.counter = 0;
          s3.done = false;
          m2(this, s3);
        };
        i3.prototype = e3 ? b2 : v2;
        return i3;
      };
    },
    713: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(9306), r2 = i2(8551), a2 = i2(1767), o2 = i2(9462), l2 = i2(6319), h2 = o2(function() {
        var t3 = this.iterator, e3 = r2(s2(this.next, t3));
        if (!(this.done = !!e3.done)) return l2(t3, this.mapper, [
          e3.value,
          this.counter++
        ], true);
      });
      t2.exports = function map(t3) {
        r2(this);
        n2(t3);
        return new h2(a2(this), {
          mapper: t3
        });
      };
    },
    7657: (t2, e2, i2) => {
      var s2, n2, r2, a2 = i2(9039), o2 = i2(4901), l2 = i2(34), h2 = i2(2360), c2 = i2(2787), d2 = i2(6840), u2 = i2(8227), p2 = i2(6395), g2 = u2("iterator"), f2 = false;
      [].keys && ("next" in (r2 = [].keys()) ? (n2 = c2(c2(r2))) !== Object.prototype && (s2 = n2) : f2 = true);
      !l2(s2) || a2(function() {
        var t3 = {};
        return s2[g2].call(t3) !== t3;
      }) ? s2 = {} : p2 && (s2 = h2(s2));
      o2(s2[g2]) || d2(s2, g2, function() {
        return this;
      });
      t2.exports = {
        IteratorPrototype: s2,
        BUGGY_SAFARI_ITERATORS: f2
      };
    },
    6269: (t2) => {
      t2.exports = {};
    },
    6198: (t2, e2, i2) => {
      var s2 = i2(8014);
      t2.exports = function(t3) {
        return s2(t3.length);
      };
    },
    283: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(9039), r2 = i2(4901), a2 = i2(9297), o2 = i2(3724), l2 = i2(350).CONFIGURABLE, h2 = i2(3706), c2 = i2(1181), d2 = c2.enforce, u2 = c2.get, p2 = String, g2 = Object.defineProperty, f2 = s2("".slice), m2 = s2("".replace), b2 = s2([].join), v2 = o2 && !n2(function() {
        return 8 !== g2(function() {
        }, "length", {
          value: 8
        }).length;
      }), y2 = String(String).split("String"), A2 = t2.exports = function(t3, e3, i3) {
        "Symbol(" === f2(p2(e3), 0, 7) && (e3 = "[" + m2(p2(e3), /^Symbol\(([^)]*)\).*$/, "$1") + "]");
        i3 && i3.getter && (e3 = "get " + e3);
        i3 && i3.setter && (e3 = "set " + e3);
        (!a2(t3, "name") || l2 && t3.name !== e3) && (o2 ? g2(t3, "name", {
          value: e3,
          configurable: true
        }) : t3.name = e3);
        v2 && i3 && a2(i3, "arity") && t3.length !== i3.arity && g2(t3, "length", {
          value: i3.arity
        });
        try {
          i3 && a2(i3, "constructor") && i3.constructor ? o2 && g2(t3, "prototype", {
            writable: false
          }) : t3.prototype && (t3.prototype = void 0);
        } catch (t4) {
        }
        var s3 = d2(t3);
        a2(s3, "source") || (s3.source = b2(y2, "string" == typeof e3 ? e3 : ""));
        return t3;
      };
      Function.prototype.toString = A2(function toString() {
        return r2(this) && u2(this).source || h2(this);
      }, "toString");
    },
    741: (t2) => {
      var e2 = Math.ceil, i2 = Math.floor;
      t2.exports = Math.trunc || function trunc(t3) {
        var s2 = +t3;
        return (s2 > 0 ? i2 : e2)(s2);
      };
    },
    6043: (t2, e2, i2) => {
      var s2 = i2(9306), n2 = TypeError, PromiseCapability = function(t3) {
        var e3, i3;
        this.promise = new t3(function(t4, s3) {
          if (void 0 !== e3 || void 0 !== i3) throw new n2("Bad Promise constructor");
          e3 = t4;
          i3 = s3;
        });
        this.resolve = s2(e3);
        this.reject = s2(i3);
      };
      t2.exports.f = function(t3) {
        return new PromiseCapability(t3);
      };
    },
    2603: (t2, e2, i2) => {
      var s2 = i2(655);
      t2.exports = function(t3, e3) {
        return void 0 === t3 ? arguments.length < 2 ? "" : e3 : s2(t3);
      };
    },
    4149: (t2) => {
      var e2 = RangeError;
      t2.exports = function(t3) {
        if (t3 == t3) return t3;
        throw new e2("NaN is not allowed");
      };
    },
    2360: (t2, e2, i2) => {
      var s2, n2 = i2(8551), r2 = i2(6801), a2 = i2(8727), o2 = i2(421), l2 = i2(397), h2 = i2(4055), c2 = i2(6119), d2 = "prototype", u2 = "script", p2 = c2("IE_PROTO"), EmptyConstructor = function() {
      }, scriptTag = function(t3) {
        return "<" + u2 + ">" + t3 + "</" + u2 + ">";
      }, NullProtoObjectViaActiveX = function(t3) {
        t3.write(scriptTag(""));
        t3.close();
        var e3 = t3.parentWindow.Object;
        t3 = null;
        return e3;
      }, NullProtoObject = function() {
        try {
          s2 = new ActiveXObject("htmlfile");
        } catch (t4) {
        }
        NullProtoObject = "undefined" != typeof document ? document.domain && s2 ? NullProtoObjectViaActiveX(s2) : function() {
          var t4, e3 = h2("iframe"), i3 = "java" + u2 + ":";
          e3.style.display = "none";
          l2.appendChild(e3);
          e3.src = String(i3);
          (t4 = e3.contentWindow.document).open();
          t4.write(scriptTag("document.F=Object"));
          t4.close();
          return t4.F;
        }() : NullProtoObjectViaActiveX(s2);
        for (var t3 = a2.length; t3--; ) delete NullProtoObject[d2][a2[t3]];
        return NullProtoObject();
      };
      o2[p2] = true;
      t2.exports = Object.create || function create(t3, e3) {
        var i3;
        if (null !== t3) {
          EmptyConstructor[d2] = n2(t3);
          i3 = new EmptyConstructor();
          EmptyConstructor[d2] = null;
          i3[p2] = t3;
        } else i3 = NullProtoObject();
        return void 0 === e3 ? i3 : r2.f(i3, e3);
      };
    },
    6801: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(8686), r2 = i2(4913), a2 = i2(8551), o2 = i2(5397), l2 = i2(1072);
      e2.f = s2 && !n2 ? Object.defineProperties : function defineProperties(t3, e3) {
        a2(t3);
        for (var i3, s3 = o2(e3), n3 = l2(e3), h2 = n3.length, c2 = 0; h2 > c2; ) r2.f(t3, i3 = n3[c2++], s3[i3]);
        return t3;
      };
    },
    4913: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(5917), r2 = i2(8686), a2 = i2(8551), o2 = i2(6969), l2 = TypeError, h2 = Object.defineProperty, c2 = Object.getOwnPropertyDescriptor, d2 = "enumerable", u2 = "configurable", p2 = "writable";
      e2.f = s2 ? r2 ? function defineProperty(t3, e3, i3) {
        a2(t3);
        e3 = o2(e3);
        a2(i3);
        if ("function" == typeof t3 && "prototype" === e3 && "value" in i3 && p2 in i3 && !i3[p2]) {
          var s3 = c2(t3, e3);
          if (s3 && s3[p2]) {
            t3[e3] = i3.value;
            i3 = {
              configurable: u2 in i3 ? i3[u2] : s3[u2],
              enumerable: d2 in i3 ? i3[d2] : s3[d2],
              writable: false
            };
          }
        }
        return h2(t3, e3, i3);
      } : h2 : function defineProperty(t3, e3, i3) {
        a2(t3);
        e3 = o2(e3);
        a2(i3);
        if (n2) try {
          return h2(t3, e3, i3);
        } catch (t4) {
        }
        if ("get" in i3 || "set" in i3) throw new l2("Accessors not supported");
        "value" in i3 && (t3[e3] = i3.value);
        return t3;
      };
    },
    7347: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(9565), r2 = i2(8773), a2 = i2(6980), o2 = i2(5397), l2 = i2(6969), h2 = i2(9297), c2 = i2(5917), d2 = Object.getOwnPropertyDescriptor;
      e2.f = s2 ? d2 : function getOwnPropertyDescriptor(t3, e3) {
        t3 = o2(t3);
        e3 = l2(e3);
        if (c2) try {
          return d2(t3, e3);
        } catch (t4) {
        }
        if (h2(t3, e3)) return a2(!n2(r2.f, t3, e3), t3[e3]);
      };
    },
    8480: (t2, e2, i2) => {
      var s2 = i2(1828), n2 = i2(8727).concat("length", "prototype");
      e2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(t3) {
        return s2(t3, n2);
      };
    },
    3717: (t2, e2) => {
      e2.f = Object.getOwnPropertySymbols;
    },
    2787: (t2, e2, i2) => {
      var s2 = i2(9297), n2 = i2(4901), r2 = i2(8981), a2 = i2(6119), o2 = i2(2211), l2 = a2("IE_PROTO"), h2 = Object, c2 = h2.prototype;
      t2.exports = o2 ? h2.getPrototypeOf : function(t3) {
        var e3 = r2(t3);
        if (s2(e3, l2)) return e3[l2];
        var i3 = e3.constructor;
        return n2(i3) && e3 instanceof i3 ? i3.prototype : e3 instanceof h2 ? c2 : null;
      };
    },
    1625: (t2, e2, i2) => {
      var s2 = i2(9504);
      t2.exports = s2({}.isPrototypeOf);
    },
    1828: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(9297), r2 = i2(5397), a2 = i2(9617).indexOf, o2 = i2(421), l2 = s2([].push);
      t2.exports = function(t3, e3) {
        var i3, s3 = r2(t3), h2 = 0, c2 = [];
        for (i3 in s3) !n2(o2, i3) && n2(s3, i3) && l2(c2, i3);
        for (; e3.length > h2; ) n2(s3, i3 = e3[h2++]) && (~a2(c2, i3) || l2(c2, i3));
        return c2;
      };
    },
    1072: (t2, e2, i2) => {
      var s2 = i2(1828), n2 = i2(8727);
      t2.exports = Object.keys || function keys(t3) {
        return s2(t3, n2);
      };
    },
    8773: (t2, e2) => {
      var i2 = {}.propertyIsEnumerable, s2 = Object.getOwnPropertyDescriptor, n2 = s2 && !i2.call({
        1: 2
      }, 1);
      e2.f = n2 ? function propertyIsEnumerable(t3) {
        var e3 = s2(this, t3);
        return !!e3 && e3.enumerable;
      } : i2;
    },
    2967: (t2, e2, i2) => {
      var s2 = i2(6706), n2 = i2(34), r2 = i2(7750), a2 = i2(3506);
      t2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var t3, e3 = false, i3 = {};
        try {
          (t3 = s2(Object.prototype, "__proto__", "set"))(i3, []);
          e3 = i3 instanceof Array;
        } catch (t4) {
        }
        return function setPrototypeOf(i4, s3) {
          r2(i4);
          a2(s3);
          if (!n2(i4)) return i4;
          e3 ? t3(i4, s3) : i4.__proto__ = s3;
          return i4;
        };
      }() : void 0);
    },
    4270: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(4901), r2 = i2(34), a2 = TypeError;
      t2.exports = function(t3, e3) {
        var i3, o2;
        if ("string" === e3 && n2(i3 = t3.toString) && !r2(o2 = s2(i3, t3))) return o2;
        if (n2(i3 = t3.valueOf) && !r2(o2 = s2(i3, t3))) return o2;
        if ("string" !== e3 && n2(i3 = t3.toString) && !r2(o2 = s2(i3, t3))) return o2;
        throw new a2("Can't convert object to primitive value");
      };
    },
    5031: (t2, e2, i2) => {
      var s2 = i2(7751), n2 = i2(9504), r2 = i2(8480), a2 = i2(3717), o2 = i2(8551), l2 = n2([].concat);
      t2.exports = s2("Reflect", "ownKeys") || function ownKeys(t3) {
        var e3 = r2.f(o2(t3)), i3 = a2.f;
        return i3 ? l2(e3, i3(t3)) : e3;
      };
    },
    8235: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(9297), r2 = SyntaxError, a2 = parseInt, o2 = String.fromCharCode, l2 = s2("".charAt), h2 = s2("".slice), c2 = s2(/./.exec), d2 = {
        '\\"': '"',
        "\\\\": "\\",
        "\\/": "/",
        "\\b": "\b",
        "\\f": "\f",
        "\\n": "\n",
        "\\r": "\r",
        "\\t": "	"
      }, u2 = /^[\da-f]{4}$/i, p2 = /^[\u0000-\u001F]$/;
      t2.exports = function(t3, e3) {
        for (var i3 = true, s3 = ""; e3 < t3.length; ) {
          var g2 = l2(t3, e3);
          if ("\\" === g2) {
            var f2 = h2(t3, e3, e3 + 2);
            if (n2(d2, f2)) {
              s3 += d2[f2];
              e3 += 2;
            } else {
              if ("\\u" !== f2) throw new r2('Unknown escape sequence: "' + f2 + '"');
              var m2 = h2(t3, e3 += 2, e3 + 4);
              if (!c2(u2, m2)) throw new r2("Bad Unicode escape at: " + e3);
              s3 += o2(a2(m2, 16));
              e3 += 4;
            }
          } else {
            if ('"' === g2) {
              i3 = false;
              e3++;
              break;
            }
            if (c2(p2, g2)) throw new r2("Bad control character in string literal at: " + e3);
            s3 += g2;
            e3++;
          }
        }
        if (i3) throw new r2("Unterminated string at: " + e3);
        return {
          value: s3,
          end: e3
        };
      };
    },
    7750: (t2, e2, i2) => {
      var s2 = i2(4117), n2 = TypeError;
      t2.exports = function(t3) {
        if (s2(t3)) throw new n2("Can't call method on " + t3);
        return t3;
      };
    },
    9286: (t2, e2, i2) => {
      var s2 = i2(4402), n2 = i2(8469), r2 = s2.Set, a2 = s2.add;
      t2.exports = function(t3) {
        var e3 = new r2();
        n2(t3, function(t4) {
          a2(e3, t4);
        });
        return e3;
      };
    },
    3440: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(4402), r2 = i2(9286), a2 = i2(5170), o2 = i2(3789), l2 = i2(8469), h2 = i2(507), c2 = n2.has, d2 = n2.remove;
      t2.exports = function difference(t3) {
        var e3 = s2(this), i3 = o2(t3), n3 = r2(e3);
        a2(e3) <= i3.size ? l2(e3, function(t4) {
          i3.includes(t4) && d2(n3, t4);
        }) : h2(i3.getIterator(), function(t4) {
          c2(e3, t4) && d2(n3, t4);
        });
        return n3;
      };
    },
    4402: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = Set.prototype;
      t2.exports = {
        Set,
        add: s2(n2.add),
        has: s2(n2.has),
        remove: s2(n2.delete),
        proto: n2
      };
    },
    8750: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(4402), r2 = i2(5170), a2 = i2(3789), o2 = i2(8469), l2 = i2(507), h2 = n2.Set, c2 = n2.add, d2 = n2.has;
      t2.exports = function intersection(t3) {
        var e3 = s2(this), i3 = a2(t3), n3 = new h2();
        r2(e3) > i3.size ? l2(i3.getIterator(), function(t4) {
          d2(e3, t4) && c2(n3, t4);
        }) : o2(e3, function(t4) {
          i3.includes(t4) && c2(n3, t4);
        });
        return n3;
      };
    },
    4449: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(4402).has, r2 = i2(5170), a2 = i2(3789), o2 = i2(8469), l2 = i2(507), h2 = i2(9539);
      t2.exports = function isDisjointFrom(t3) {
        var e3 = s2(this), i3 = a2(t3);
        if (r2(e3) <= i3.size) return false !== o2(e3, function(t4) {
          if (i3.includes(t4)) return false;
        }, true);
        var c2 = i3.getIterator();
        return false !== l2(c2, function(t4) {
          if (n2(e3, t4)) return h2(c2, "normal", false);
        });
      };
    },
    3838: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(5170), r2 = i2(8469), a2 = i2(3789);
      t2.exports = function isSubsetOf(t3) {
        var e3 = s2(this), i3 = a2(t3);
        return !(n2(e3) > i3.size) && false !== r2(e3, function(t4) {
          if (!i3.includes(t4)) return false;
        }, true);
      };
    },
    8527: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(4402).has, r2 = i2(5170), a2 = i2(3789), o2 = i2(507), l2 = i2(9539);
      t2.exports = function isSupersetOf(t3) {
        var e3 = s2(this), i3 = a2(t3);
        if (r2(e3) < i3.size) return false;
        var h2 = i3.getIterator();
        return false !== o2(h2, function(t4) {
          if (!n2(e3, t4)) return l2(h2, "normal", false);
        });
      };
    },
    8469: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = i2(507), r2 = i2(4402), a2 = r2.Set, o2 = r2.proto, l2 = s2(o2.forEach), h2 = s2(o2.keys), c2 = h2(new a2()).next;
      t2.exports = function(t3, e3, i3) {
        return i3 ? n2({
          iterator: h2(t3),
          next: c2
        }, e3) : l2(t3, e3);
      };
    },
    4916: (t2, e2, i2) => {
      var s2 = i2(7751), createSetLike = function(t3) {
        return {
          size: t3,
          has: function() {
            return false;
          },
          keys: function() {
            return {
              next: function() {
                return {
                  done: true
                };
              }
            };
          }
        };
      };
      t2.exports = function(t3) {
        var e3 = s2("Set");
        try {
          new e3()[t3](createSetLike(0));
          try {
            new e3()[t3](createSetLike(-1));
            return false;
          } catch (t4) {
            return true;
          }
        } catch (t4) {
          return false;
        }
      };
    },
    5170: (t2, e2, i2) => {
      var s2 = i2(6706), n2 = i2(4402);
      t2.exports = s2(n2.proto, "size", "get") || function(t3) {
        return t3.size;
      };
    },
    3650: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(4402), r2 = i2(9286), a2 = i2(3789), o2 = i2(507), l2 = n2.add, h2 = n2.has, c2 = n2.remove;
      t2.exports = function symmetricDifference(t3) {
        var e3 = s2(this), i3 = a2(t3).getIterator(), n3 = r2(e3);
        o2(i3, function(t4) {
          h2(e3, t4) ? c2(n3, t4) : l2(n3, t4);
        });
        return n3;
      };
    },
    4204: (t2, e2, i2) => {
      var s2 = i2(7080), n2 = i2(4402).add, r2 = i2(9286), a2 = i2(3789), o2 = i2(507);
      t2.exports = function union(t3) {
        var e3 = s2(this), i3 = a2(t3).getIterator(), l2 = r2(e3);
        o2(i3, function(t4) {
          n2(l2, t4);
        });
        return l2;
      };
    },
    6119: (t2, e2, i2) => {
      var s2 = i2(5745), n2 = i2(3392), r2 = s2("keys");
      t2.exports = function(t3) {
        return r2[t3] || (r2[t3] = n2(t3));
      };
    },
    7629: (t2, e2, i2) => {
      var s2 = i2(6395), n2 = i2(4576), r2 = i2(9433), a2 = "__core-js_shared__", o2 = t2.exports = n2[a2] || r2(a2, {});
      (o2.versions || (o2.versions = [])).push({
        version: "3.38.1",
        mode: s2 ? "pure" : "global",
        copyright: "\xA9 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    },
    5745: (t2, e2, i2) => {
      var s2 = i2(7629);
      t2.exports = function(t3, e3) {
        return s2[t3] || (s2[t3] = e3 || {});
      };
    },
    1548: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(9039), r2 = i2(9519), a2 = i2(4215), o2 = s2.structuredClone;
      t2.exports = !!o2 && !n2(function() {
        if ("DENO" === a2 && r2 > 92 || "NODE" === a2 && r2 > 94 || "BROWSER" === a2 && r2 > 97) return false;
        var t3 = new ArrayBuffer(8), e3 = o2(t3, {
          transfer: [
            t3
          ]
        });
        return 0 !== t3.byteLength || 8 !== e3.byteLength;
      });
    },
    4495: (t2, e2, i2) => {
      var s2 = i2(9519), n2 = i2(9039), r2 = i2(4576).String;
      t2.exports = !!Object.getOwnPropertySymbols && !n2(function() {
        var t3 = Symbol("symbol detection");
        return !r2(t3) || !(Object(t3) instanceof Symbol) || !Symbol.sham && s2 && s2 < 41;
      });
    },
    5610: (t2, e2, i2) => {
      var s2 = i2(1291), n2 = Math.max, r2 = Math.min;
      t2.exports = function(t3, e3) {
        var i3 = s2(t3);
        return i3 < 0 ? n2(i3 + e3, 0) : r2(i3, e3);
      };
    },
    5854: (t2, e2, i2) => {
      var s2 = i2(2777), n2 = TypeError;
      t2.exports = function(t3) {
        var e3 = s2(t3, "number");
        if ("number" == typeof e3) throw new n2("Can't convert number to bigint");
        return BigInt(e3);
      };
    },
    7696: (t2, e2, i2) => {
      var s2 = i2(1291), n2 = i2(8014), r2 = RangeError;
      t2.exports = function(t3) {
        if (void 0 === t3) return 0;
        var e3 = s2(t3), i3 = n2(e3);
        if (e3 !== i3) throw new r2("Wrong length or index");
        return i3;
      };
    },
    5397: (t2, e2, i2) => {
      var s2 = i2(7055), n2 = i2(7750);
      t2.exports = function(t3) {
        return s2(n2(t3));
      };
    },
    1291: (t2, e2, i2) => {
      var s2 = i2(741);
      t2.exports = function(t3) {
        var e3 = +t3;
        return e3 != e3 || 0 === e3 ? 0 : s2(e3);
      };
    },
    8014: (t2, e2, i2) => {
      var s2 = i2(1291), n2 = Math.min;
      t2.exports = function(t3) {
        var e3 = s2(t3);
        return e3 > 0 ? n2(e3, 9007199254740991) : 0;
      };
    },
    8981: (t2, e2, i2) => {
      var s2 = i2(7750), n2 = Object;
      t2.exports = function(t3) {
        return n2(s2(t3));
      };
    },
    9590: (t2, e2, i2) => {
      var s2 = i2(1291), n2 = RangeError;
      t2.exports = function(t3) {
        var e3 = s2(t3);
        if (e3 < 0) throw new n2("The argument can't be less than 0");
        return e3;
      };
    },
    2777: (t2, e2, i2) => {
      var s2 = i2(9565), n2 = i2(34), r2 = i2(757), a2 = i2(5966), o2 = i2(4270), l2 = i2(8227), h2 = TypeError, c2 = l2("toPrimitive");
      t2.exports = function(t3, e3) {
        if (!n2(t3) || r2(t3)) return t3;
        var i3, l3 = a2(t3, c2);
        if (l3) {
          void 0 === e3 && (e3 = "default");
          i3 = s2(l3, t3, e3);
          if (!n2(i3) || r2(i3)) return i3;
          throw new h2("Can't convert object to primitive value");
        }
        void 0 === e3 && (e3 = "number");
        return o2(t3, e3);
      };
    },
    6969: (t2, e2, i2) => {
      var s2 = i2(2777), n2 = i2(757);
      t2.exports = function(t3) {
        var e3 = s2(t3, "string");
        return n2(e3) ? e3 : e3 + "";
      };
    },
    2140: (t2, e2, i2) => {
      var s2 = {};
      s2[i2(8227)("toStringTag")] = "z";
      t2.exports = "[object z]" === String(s2);
    },
    655: (t2, e2, i2) => {
      var s2 = i2(6955), n2 = String;
      t2.exports = function(t3) {
        if ("Symbol" === s2(t3)) throw new TypeError("Cannot convert a Symbol value to a string");
        return n2(t3);
      };
    },
    6823: (t2) => {
      var e2 = String;
      t2.exports = function(t3) {
        try {
          return e2(t3);
        } catch (t4) {
          return "Object";
        }
      };
    },
    3392: (t2, e2, i2) => {
      var s2 = i2(9504), n2 = 0, r2 = Math.random(), a2 = s2(1 .toString);
      t2.exports = function(t3) {
        return "Symbol(" + (void 0 === t3 ? "" : t3) + ")_" + a2(++n2 + r2, 36);
      };
    },
    7040: (t2, e2, i2) => {
      var s2 = i2(4495);
      t2.exports = s2 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
    },
    8686: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(9039);
      t2.exports = s2 && n2(function() {
        return 42 !== Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype;
      });
    },
    2812: (t2) => {
      var e2 = TypeError;
      t2.exports = function(t3, i2) {
        if (t3 < i2) throw new e2("Not enough arguments");
        return t3;
      };
    },
    8622: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(4901), r2 = s2.WeakMap;
      t2.exports = n2(r2) && /native code/.test(String(r2));
    },
    8227: (t2, e2, i2) => {
      var s2 = i2(4576), n2 = i2(5745), r2 = i2(9297), a2 = i2(3392), o2 = i2(4495), l2 = i2(7040), h2 = s2.Symbol, c2 = n2("wks"), d2 = l2 ? h2.for || h2 : h2 && h2.withoutSetter || a2;
      t2.exports = function(t3) {
        r2(c2, t3) || (c2[t3] = o2 && r2(h2, t3) ? h2[t3] : d2("Symbol." + t3));
        return c2[t3];
      };
    },
    6573: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(2106), r2 = i2(3238), a2 = ArrayBuffer.prototype;
      s2 && !("detached" in a2) && n2(a2, "detached", {
        configurable: true,
        get: function detached() {
          return r2(this);
        }
      });
    },
    7936: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(5636);
      n2 && s2({
        target: "ArrayBuffer",
        proto: true
      }, {
        transferToFixedLength: function transferToFixedLength() {
          return n2(this, arguments.length ? arguments[0] : void 0, false);
        }
      });
    },
    8100: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(5636);
      n2 && s2({
        target: "ArrayBuffer",
        proto: true
      }, {
        transfer: function transfer() {
          return n2(this, arguments.length ? arguments[0] : void 0, true);
        }
      });
    },
    4114: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(8981), r2 = i2(6198), a2 = i2(4527), o2 = i2(6837);
      s2({
        target: "Array",
        proto: true,
        arity: 1,
        forced: i2(9039)(function() {
          return 4294967297 !== [].push.call({
            length: 4294967296
          }, 1);
        }) || !function() {
          try {
            Object.defineProperty([], "length", {
              writable: false
            }).push();
          } catch (t3) {
            return t3 instanceof TypeError;
          }
        }()
      }, {
        push: function push(t3) {
          var e3 = n2(this), i3 = r2(e3), s3 = arguments.length;
          o2(i3 + s3);
          for (var l2 = 0; l2 < s3; l2++) {
            e3[i3] = arguments[l2];
            i3++;
          }
          a2(e3, i3);
          return i3;
        }
      });
    },
    4628: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(6043);
      s2({
        target: "Promise",
        stat: true
      }, {
        withResolvers: function withResolvers() {
          var t3 = n2.f(this);
          return {
            promise: t3.promise,
            resolve: t3.resolve,
            reject: t3.reject
          };
        }
      });
    },
    7642: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(3440);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("difference")
      }, {
        difference: n2
      });
    },
    8004: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(9039), r2 = i2(8750);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("intersection") || n2(function() {
          return "3,2" !== String(Array.from((/* @__PURE__ */ new Set([
            1,
            2,
            3
          ])).intersection(/* @__PURE__ */ new Set([
            3,
            2
          ]))));
        })
      }, {
        intersection: r2
      });
    },
    3853: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(4449);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("isDisjointFrom")
      }, {
        isDisjointFrom: n2
      });
    },
    5876: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(3838);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("isSubsetOf")
      }, {
        isSubsetOf: n2
      });
    },
    2475: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(8527);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("isSupersetOf")
      }, {
        isSupersetOf: n2
      });
    },
    5024: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(3650);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("symmetricDifference")
      }, {
        symmetricDifference: n2
      });
    },
    1698: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(4204);
      s2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("union")
      }, {
        union: n2
      });
    },
    7467: (t2, e2, i2) => {
      var s2 = i2(7628), n2 = i2(4644), r2 = n2.aTypedArray, a2 = n2.exportTypedArrayMethod, o2 = n2.getTypedArrayConstructor;
      a2("toReversed", function toReversed() {
        return s2(r2(this), o2(this));
      });
    },
    4732: (t2, e2, i2) => {
      var s2 = i2(4644), n2 = i2(9504), r2 = i2(9306), a2 = i2(5370), o2 = s2.aTypedArray, l2 = s2.getTypedArrayConstructor, h2 = s2.exportTypedArrayMethod, c2 = n2(s2.TypedArrayPrototype.sort);
      h2("toSorted", function toSorted(t3) {
        void 0 !== t3 && r2(t3);
        var e3 = o2(this), i3 = a2(l2(e3), e3);
        return c2(i3, t3);
      });
    },
    9577: (t2, e2, i2) => {
      var s2 = i2(9928), n2 = i2(4644), r2 = i2(1108), a2 = i2(1291), o2 = i2(5854), l2 = n2.aTypedArray, h2 = n2.getTypedArrayConstructor, c2 = n2.exportTypedArrayMethod, d2 = !!function() {
        try {
          new Int8Array(1).with(2, {
            valueOf: function() {
              throw 8;
            }
          });
        } catch (t3) {
          return 8 === t3;
        }
      }();
      c2("with", {
        with: function(t3, e3) {
          var i3 = l2(this), n3 = a2(t3), c3 = r2(i3) ? o2(e3) : +e3;
          return s2(i3, h2(i3), n3, c3);
        }
      }.with, !d2);
    },
    8992: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(4576), r2 = i2(679), a2 = i2(8551), o2 = i2(4901), l2 = i2(2787), h2 = i2(2106), c2 = i2(4659), d2 = i2(9039), u2 = i2(9297), p2 = i2(8227), g2 = i2(7657).IteratorPrototype, f2 = i2(3724), m2 = i2(6395), b2 = "constructor", v2 = "Iterator", y2 = p2("toStringTag"), A2 = TypeError, w2 = n2[v2], x2 = m2 || !o2(w2) || w2.prototype !== g2 || !d2(function() {
        w2({});
      }), _2 = function Iterator() {
        r2(this, g2);
        if (l2(this) === g2) throw new A2("Abstract class Iterator not directly constructable");
      }, defineIteratorPrototypeAccessor = function(t3, e3) {
        f2 ? h2(g2, t3, {
          configurable: true,
          get: function() {
            return e3;
          },
          set: function(e4) {
            a2(this);
            if (this === g2) throw new A2("You can't redefine this property");
            u2(this, t3) ? this[t3] = e4 : c2(this, t3, e4);
          }
        }) : g2[t3] = e3;
      };
      u2(g2, y2) || defineIteratorPrototypeAccessor(y2, v2);
      !x2 && u2(g2, b2) && g2[b2] !== Object || defineIteratorPrototypeAccessor(b2, _2);
      _2.prototype = g2;
      s2({
        global: true,
        constructor: true,
        forced: x2
      }, {
        Iterator: _2
      });
    },
    4743: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(9565), r2 = i2(8551), a2 = i2(1767), o2 = i2(4149), l2 = i2(9590), h2 = i2(9462), c2 = i2(6395), d2 = h2(function() {
        for (var t3, e3 = this.iterator, i3 = this.next; this.remaining; ) {
          this.remaining--;
          t3 = r2(n2(i3, e3));
          if (this.done = !!t3.done) return;
        }
        t3 = r2(n2(i3, e3));
        if (!(this.done = !!t3.done)) return t3.value;
      });
      s2({
        target: "Iterator",
        proto: true,
        real: true,
        forced: c2
      }, {
        drop: function drop(t3) {
          r2(this);
          var e3 = l2(o2(+t3));
          return new d2(a2(this), {
            remaining: e3
          });
        }
      });
    },
    3215: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(2652), r2 = i2(9306), a2 = i2(8551), o2 = i2(1767);
      s2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        every: function every(t3) {
          a2(this);
          r2(t3);
          var e3 = o2(this), i3 = 0;
          return !n2(e3, function(e4, s3) {
            if (!t3(e4, i3++)) return s3();
          }, {
            IS_RECORD: true,
            INTERRUPTED: true
          }).stopped;
        }
      });
    },
    4520: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(9565), r2 = i2(9306), a2 = i2(8551), o2 = i2(1767), l2 = i2(9462), h2 = i2(6319), c2 = i2(6395), d2 = l2(function() {
        for (var t3, e3, i3 = this.iterator, s3 = this.predicate, r3 = this.next; ; ) {
          t3 = a2(n2(r3, i3));
          if (this.done = !!t3.done) return;
          e3 = t3.value;
          if (h2(i3, s3, [
            e3,
            this.counter++
          ], true)) return e3;
        }
      });
      s2({
        target: "Iterator",
        proto: true,
        real: true,
        forced: c2
      }, {
        filter: function filter(t3) {
          a2(this);
          r2(t3);
          return new d2(o2(this), {
            predicate: t3
          });
        }
      });
    },
    670: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(9565), r2 = i2(9306), a2 = i2(8551), o2 = i2(1767), l2 = i2(8646), h2 = i2(9462), c2 = i2(9539), d2 = i2(6395), u2 = h2(function() {
        for (var t3, e3, i3 = this.iterator, s3 = this.mapper; ; ) {
          if (e3 = this.inner) try {
            if (!(t3 = a2(n2(e3.next, e3.iterator))).done) return t3.value;
            this.inner = null;
          } catch (t4) {
            c2(i3, "throw", t4);
          }
          t3 = a2(n2(this.next, i3));
          if (this.done = !!t3.done) return;
          try {
            this.inner = l2(s3(t3.value, this.counter++), false);
          } catch (t4) {
            c2(i3, "throw", t4);
          }
        }
      });
      s2({
        target: "Iterator",
        proto: true,
        real: true,
        forced: d2
      }, {
        flatMap: function flatMap(t3) {
          a2(this);
          r2(t3);
          return new u2(o2(this), {
            mapper: t3,
            inner: null
          });
        }
      });
    },
    1454: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(713);
      s2({
        target: "Iterator",
        proto: true,
        real: true,
        forced: i2(6395)
      }, {
        map: n2
      });
    },
    7550: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(2652), r2 = i2(9306), a2 = i2(8551), o2 = i2(1767);
      s2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        some: function some(t3) {
          a2(this);
          r2(t3);
          var e3 = o2(this), i3 = 0;
          return n2(e3, function(e4, s3) {
            if (t3(e4, i3++)) return s3();
          }, {
            IS_RECORD: true,
            INTERRUPTED: true
          }).stopped;
        }
      });
    },
    8335: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(3724), r2 = i2(4576), a2 = i2(7751), o2 = i2(9504), l2 = i2(9565), h2 = i2(4901), c2 = i2(34), d2 = i2(4376), u2 = i2(9297), p2 = i2(655), g2 = i2(6198), f2 = i2(4659), m2 = i2(9039), b2 = i2(8235), v2 = i2(4495), y2 = r2.JSON, A2 = r2.Number, w2 = r2.SyntaxError, x2 = y2 && y2.parse, _2 = a2("Object", "keys"), E2 = Object.getOwnPropertyDescriptor, C2 = o2("".charAt), S2 = o2("".slice), T2 = o2(/./.exec), M2 = o2([].push), k2 = /^\d$/, P2 = /^[1-9]$/, R2 = /^[\d-]$/, D2 = /^[\t\n\r ]$/, internalize = function(t3, e3, i3, s3) {
        var n3, r3, a3, o3, h3, p3 = t3[e3], f3 = s3 && p3 === s3.value, m3 = f3 && "string" == typeof s3.source ? {
          source: s3.source
        } : {};
        if (c2(p3)) {
          var b3 = d2(p3), v3 = f3 ? s3.nodes : b3 ? [] : {};
          if (b3) {
            n3 = v3.length;
            a3 = g2(p3);
            for (o3 = 0; o3 < a3; o3++) internalizeProperty(p3, o3, internalize(p3, "" + o3, i3, o3 < n3 ? v3[o3] : void 0));
          } else {
            r3 = _2(p3);
            a3 = g2(r3);
            for (o3 = 0; o3 < a3; o3++) {
              h3 = r3[o3];
              internalizeProperty(p3, h3, internalize(p3, h3, i3, u2(v3, h3) ? v3[h3] : void 0));
            }
          }
        }
        return l2(i3, t3, e3, p3, m3);
      }, internalizeProperty = function(t3, e3, i3) {
        if (n2) {
          var s3 = E2(t3, e3);
          if (s3 && !s3.configurable) return;
        }
        void 0 === i3 ? delete t3[e3] : f2(t3, e3, i3);
      }, Node2 = function(t3, e3, i3, s3) {
        this.value = t3;
        this.end = e3;
        this.source = i3;
        this.nodes = s3;
      }, Context = function(t3, e3) {
        this.source = t3;
        this.index = e3;
      };
      Context.prototype = {
        fork: function(t3) {
          return new Context(this.source, t3);
        },
        parse: function() {
          var t3 = this.source, e3 = this.skip(D2, this.index), i3 = this.fork(e3), s3 = C2(t3, e3);
          if (T2(R2, s3)) return i3.number();
          switch (s3) {
            case "{":
              return i3.object();
            case "[":
              return i3.array();
            case '"':
              return i3.string();
            case "t":
              return i3.keyword(true);
            case "f":
              return i3.keyword(false);
            case "n":
              return i3.keyword(null);
          }
          throw new w2('Unexpected character: "' + s3 + '" at: ' + e3);
        },
        node: function(t3, e3, i3, s3, n3) {
          return new Node2(e3, s3, t3 ? null : S2(this.source, i3, s3), n3);
        },
        object: function() {
          for (var t3 = this.source, e3 = this.index + 1, i3 = false, s3 = {}, n3 = {}; e3 < t3.length; ) {
            e3 = this.until([
              '"',
              "}"
            ], e3);
            if ("}" === C2(t3, e3) && !i3) {
              e3++;
              break;
            }
            var r3 = this.fork(e3).string(), a3 = r3.value;
            e3 = r3.end;
            e3 = this.until([
              ":"
            ], e3) + 1;
            e3 = this.skip(D2, e3);
            r3 = this.fork(e3).parse();
            f2(n3, a3, r3);
            f2(s3, a3, r3.value);
            e3 = this.until([
              ",",
              "}"
            ], r3.end);
            var o3 = C2(t3, e3);
            if ("," === o3) {
              i3 = true;
              e3++;
            } else if ("}" === o3) {
              e3++;
              break;
            }
          }
          return this.node(1, s3, this.index, e3, n3);
        },
        array: function() {
          for (var t3 = this.source, e3 = this.index + 1, i3 = false, s3 = [], n3 = []; e3 < t3.length; ) {
            e3 = this.skip(D2, e3);
            if ("]" === C2(t3, e3) && !i3) {
              e3++;
              break;
            }
            var r3 = this.fork(e3).parse();
            M2(n3, r3);
            M2(s3, r3.value);
            e3 = this.until([
              ",",
              "]"
            ], r3.end);
            if ("," === C2(t3, e3)) {
              i3 = true;
              e3++;
            } else if ("]" === C2(t3, e3)) {
              e3++;
              break;
            }
          }
          return this.node(1, s3, this.index, e3, n3);
        },
        string: function() {
          var t3 = this.index, e3 = b2(this.source, this.index + 1);
          return this.node(0, e3.value, t3, e3.end);
        },
        number: function() {
          var t3 = this.source, e3 = this.index, i3 = e3;
          "-" === C2(t3, i3) && i3++;
          if ("0" === C2(t3, i3)) i3++;
          else {
            if (!T2(P2, C2(t3, i3))) throw new w2("Failed to parse number at: " + i3);
            i3 = this.skip(k2, i3 + 1);
          }
          "." === C2(t3, i3) && (i3 = this.skip(k2, i3 + 1));
          if ("e" === C2(t3, i3) || "E" === C2(t3, i3)) {
            i3++;
            "+" !== C2(t3, i3) && "-" !== C2(t3, i3) || i3++;
            if (i3 === (i3 = this.skip(k2, i3))) throw new w2("Failed to parse number's exponent value at: " + i3);
          }
          return this.node(0, A2(S2(t3, e3, i3)), e3, i3);
        },
        keyword: function(t3) {
          var e3 = "" + t3, i3 = this.index, s3 = i3 + e3.length;
          if (S2(this.source, i3, s3) !== e3) throw new w2("Failed to parse value at: " + i3);
          return this.node(0, t3, i3, s3);
        },
        skip: function(t3, e3) {
          for (var i3 = this.source; e3 < i3.length && T2(t3, C2(i3, e3)); e3++) ;
          return e3;
        },
        until: function(t3, e3) {
          e3 = this.skip(D2, e3);
          for (var i3 = C2(this.source, e3), s3 = 0; s3 < t3.length; s3++) if (t3[s3] === i3) return e3;
          throw new w2('Unexpected character: "' + i3 + '" at: ' + e3);
        }
      };
      var I2 = m2(function() {
        var t3, e3 = "9007199254740993";
        x2(e3, function(e4, i3, s3) {
          t3 = s3.source;
        });
        return t3 !== e3;
      }), L2 = v2 && !m2(function() {
        return 1 / x2("-0 	") != -1 / 0;
      });
      s2({
        target: "JSON",
        stat: true,
        forced: I2
      }, {
        parse: function parse(t3, e3) {
          return L2 && !h2(e3) ? x2(t3) : function(t4, e4) {
            t4 = p2(t4);
            var i3 = new Context(t4, 0), s3 = i3.parse(), n3 = s3.value, r3 = i3.skip(D2, s3.end);
            if (r3 < t4.length) throw new w2('Unexpected extra character: "' + C2(t4, r3) + '" after the parsed data at: ' + r3);
            return h2(e4) ? internalize({
              "": n3
            }, "", e4, s3) : n3;
          }(t3, e3);
        }
      });
    },
    4979: (t2, e2, i2) => {
      var s2 = i2(6518), n2 = i2(4576), r2 = i2(7751), a2 = i2(6980), o2 = i2(4913).f, l2 = i2(9297), h2 = i2(679), c2 = i2(3167), d2 = i2(2603), u2 = i2(5002), p2 = i2(8574), g2 = i2(3724), f2 = i2(6395), m2 = "DOMException", b2 = r2("Error"), v2 = r2(m2), y2 = function DOMException() {
        h2(this, A2);
        var t3 = arguments.length, e3 = d2(t3 < 1 ? void 0 : arguments[0]), i3 = d2(t3 < 2 ? void 0 : arguments[1], "Error"), s3 = new v2(e3, i3), n3 = new b2(e3);
        n3.name = m2;
        o2(s3, "stack", a2(1, p2(n3.stack, 1)));
        c2(s3, this, y2);
        return s3;
      }, A2 = y2.prototype = v2.prototype, w2 = "stack" in new b2(m2), x2 = "stack" in new v2(1, 2), _2 = v2 && g2 && Object.getOwnPropertyDescriptor(n2, m2), E2 = !(!_2 || _2.writable && _2.configurable), C2 = w2 && !E2 && !x2;
      s2({
        global: true,
        constructor: true,
        forced: f2 || C2
      }, {
        DOMException: C2 ? y2 : v2
      });
      var S2 = r2(m2), T2 = S2.prototype;
      if (T2.constructor !== S2) {
        f2 || o2(T2, "constructor", a2(1, S2));
        for (var M2 in u2) if (l2(u2, M2)) {
          var k2 = u2[M2], P2 = k2.s;
          l2(S2, P2) || o2(S2, P2, a2(6, k2.c));
        }
      }
    },
    4603: (t2, e2, i2) => {
      var s2 = i2(6840), n2 = i2(9504), r2 = i2(655), a2 = i2(2812), o2 = URLSearchParams, l2 = o2.prototype, h2 = n2(l2.append), c2 = n2(l2.delete), d2 = n2(l2.forEach), u2 = n2([].push), p2 = new o2("a=1&a=2&b=3");
      p2.delete("a", 1);
      p2.delete("b", void 0);
      p2 + "" != "a=2" && s2(l2, "delete", function(t3) {
        var e3 = arguments.length, i3 = e3 < 2 ? void 0 : arguments[1];
        if (e3 && void 0 === i3) return c2(this, t3);
        var s3 = [];
        d2(this, function(t4, e4) {
          u2(s3, {
            key: e4,
            value: t4
          });
        });
        a2(e3, 1);
        for (var n3, o3 = r2(t3), l3 = r2(i3), p3 = 0, g2 = 0, f2 = false, m2 = s3.length; p3 < m2; ) {
          n3 = s3[p3++];
          if (f2 || n3.key === o3) {
            f2 = true;
            c2(this, n3.key);
          } else g2++;
        }
        for (; g2 < m2; ) (n3 = s3[g2++]).key === o3 && n3.value === l3 || h2(this, n3.key, n3.value);
      }, {
        enumerable: true,
        unsafe: true
      });
    },
    7566: (t2, e2, i2) => {
      var s2 = i2(6840), n2 = i2(9504), r2 = i2(655), a2 = i2(2812), o2 = URLSearchParams, l2 = o2.prototype, h2 = n2(l2.getAll), c2 = n2(l2.has), d2 = new o2("a=1");
      !d2.has("a", 2) && d2.has("a", void 0) || s2(l2, "has", function has(t3) {
        var e3 = arguments.length, i3 = e3 < 2 ? void 0 : arguments[1];
        if (e3 && void 0 === i3) return c2(this, t3);
        var s3 = h2(this, t3);
        a2(e3, 1);
        for (var n3 = r2(i3), o3 = 0; o3 < s3.length; ) if (s3[o3++] === n3) return true;
        return false;
      }, {
        enumerable: true,
        unsafe: true
      });
    },
    8721: (t2, e2, i2) => {
      var s2 = i2(3724), n2 = i2(9504), r2 = i2(2106), a2 = URLSearchParams.prototype, o2 = n2(a2.forEach);
      s2 && !("size" in a2) && r2(a2, "size", {
        get: function size() {
          var t3 = 0;
          o2(this, function() {
            t3++;
          });
          return t3;
        },
        configurable: true,
        enumerable: true
      });
    }
  }, e = {};
  function __webpack_require__(i2) {
    var s2 = e[i2];
    if (void 0 !== s2) return s2.exports;
    var n2 = e[i2] = {
      exports: {}
    };
    t[i2].call(n2.exports, n2, n2.exports, __webpack_require__);
    return n2.exports;
  }
  __webpack_require__.d = (t2, e2) => {
    for (var i2 in e2) __webpack_require__.o(e2, i2) && !__webpack_require__.o(t2, i2) && Object.defineProperty(t2, i2, {
      enumerable: true,
      get: e2[i2]
    });
  };
  __webpack_require__.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
  var __webpack_exports__ = globalThis.pdfjsLib = {};
  __webpack_require__.d(__webpack_exports__, {
    AbortException: () => AbortException,
    AnnotationEditorLayer: () => AnnotationEditorLayer,
    AnnotationEditorParamsType: () => m,
    AnnotationEditorType: () => f,
    AnnotationEditorUIManager: () => AnnotationEditorUIManager,
    AnnotationLayer: () => AnnotationLayer,
    AnnotationMode: () => g,
    ColorPicker: () => ColorPicker,
    DOMSVGFactory: () => DOMSVGFactory,
    DrawLayer: () => DrawLayer,
    FeatureTest: () => util_FeatureTest,
    GlobalWorkerOptions: () => GlobalWorkerOptions,
    ImageKind: () => E,
    InvalidPDFException: () => InvalidPDFException,
    MissingPDFException: () => MissingPDFException,
    OPS: () => Y,
    OutputScale: () => OutputScale,
    PDFDataRangeTransport: () => PDFDataRangeTransport,
    PDFDateString: () => PDFDateString,
    PDFWorker: () => PDFWorker,
    PasswordResponses: () => Q,
    PermissionFlag: () => b,
    PixelsPerInch: () => PixelsPerInch,
    RenderingCancelledException: () => RenderingCancelledException,
    TextLayer: () => TextLayer,
    UnexpectedResponseException: () => UnexpectedResponseException,
    Util: () => Util,
    VerbosityLevel: () => K,
    XfaLayer: () => XfaLayer,
    build: () => Yt,
    createValidAbsoluteUrl: () => createValidAbsoluteUrl,
    fetchData: () => fetchData,
    getDocument: () => getDocument,
    getFilenameFromUrl: () => getFilenameFromUrl,
    getPdfFilenameFromUrl: () => getPdfFilenameFromUrl,
    getXfaPageViewport: () => getXfaPageViewport,
    isDataScheme: () => isDataScheme,
    isPdfFile: () => isPdfFile,
    noContextMenu: () => noContextMenu,
    normalizeUnicode: () => normalizeUnicode,
    setLayerDimensions: () => setLayerDimensions,
    shadow: () => shadow,
    version: () => Kt
  });
  __webpack_require__(4114), __webpack_require__(6573), __webpack_require__(8100), __webpack_require__(7936), __webpack_require__(7467), __webpack_require__(4732), __webpack_require__(9577), __webpack_require__(4979), __webpack_require__(4603), __webpack_require__(7566), __webpack_require__(8721);
  const i = !("object" != typeof process$1 || process$1 + "" != "[object process]" || process$1.versions.nw || process$1.versions.electron && process$1.type && "browser" !== process$1.type), s = [
    1,
    0,
    0,
    1,
    0,
    0
  ], n = [
    1e-3,
    0,
    0,
    1e-3,
    0,
    0
  ], r = 1.35, a = 1, o = 2, l = 4, h = 16, c = 32, d = 64, u = 128, p = 256, g = {
    DISABLE: 0,
    ENABLE: 1,
    ENABLE_FORMS: 2,
    ENABLE_STORAGE: 3
  }, f = {
    DISABLE: -1,
    NONE: 0,
    FREETEXT: 3,
    HIGHLIGHT: 9,
    STAMP: 13,
    INK: 15
  }, m = {
    RESIZE: 1,
    CREATE: 2,
    FREETEXT_SIZE: 11,
    FREETEXT_COLOR: 12,
    FREETEXT_OPACITY: 13,
    INK_COLOR: 21,
    INK_THICKNESS: 22,
    INK_OPACITY: 23,
    HIGHLIGHT_COLOR: 31,
    HIGHLIGHT_DEFAULT_COLOR: 32,
    HIGHLIGHT_THICKNESS: 33,
    HIGHLIGHT_FREE: 34,
    HIGHLIGHT_SHOW_ALL: 35
  }, b = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
  }, v = 0, y = 1, A = 2, w = 3, x = 3, _ = 4, E = {
    GRAYSCALE_1BPP: 1,
    RGB_24BPP: 2,
    RGBA_32BPP: 3
  }, C = 1, S = 2, T = 3, M = 4, k = 5, P = 6, R = 7, D = 8, I = 9, L = 10, O = 11, N = 12, B = 13, H = 14, U = 15, z = 16, j = 17, W = 20, G = 1, V = 2, $ = 3, q = 4, X = 5, K = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
  }, Y = {
    dependency: 1,
    setLineWidth: 2,
    setLineCap: 3,
    setLineJoin: 4,
    setMiterLimit: 5,
    setDash: 6,
    setRenderingIntent: 7,
    setFlatness: 8,
    setGState: 9,
    save: 10,
    restore: 11,
    transform: 12,
    moveTo: 13,
    lineTo: 14,
    curveTo: 15,
    curveTo2: 16,
    curveTo3: 17,
    closePath: 18,
    rectangle: 19,
    stroke: 20,
    closeStroke: 21,
    fill: 22,
    eoFill: 23,
    fillStroke: 24,
    eoFillStroke: 25,
    closeFillStroke: 26,
    closeEOFillStroke: 27,
    endPath: 28,
    clip: 29,
    eoClip: 30,
    beginText: 31,
    endText: 32,
    setCharSpacing: 33,
    setWordSpacing: 34,
    setHScale: 35,
    setLeading: 36,
    setFont: 37,
    setTextRenderingMode: 38,
    setTextRise: 39,
    moveText: 40,
    setLeadingMoveText: 41,
    setTextMatrix: 42,
    nextLine: 43,
    showText: 44,
    showSpacedText: 45,
    nextLineShowText: 46,
    nextLineSetSpacingShowText: 47,
    setCharWidth: 48,
    setCharWidthAndBounds: 49,
    setStrokeColorSpace: 50,
    setFillColorSpace: 51,
    setStrokeColor: 52,
    setStrokeColorN: 53,
    setFillColor: 54,
    setFillColorN: 55,
    setStrokeGray: 56,
    setFillGray: 57,
    setStrokeRGBColor: 58,
    setFillRGBColor: 59,
    setStrokeCMYKColor: 60,
    setFillCMYKColor: 61,
    shadingFill: 62,
    beginInlineImage: 63,
    beginImageData: 64,
    endInlineImage: 65,
    paintXObject: 66,
    markPoint: 67,
    markPointProps: 68,
    beginMarkedContent: 69,
    beginMarkedContentProps: 70,
    endMarkedContent: 71,
    beginCompat: 72,
    endCompat: 73,
    paintFormXObjectBegin: 74,
    paintFormXObjectEnd: 75,
    beginGroup: 76,
    endGroup: 77,
    beginAnnotation: 80,
    endAnnotation: 81,
    paintImageMaskXObject: 83,
    paintImageMaskXObjectGroup: 84,
    paintImageXObject: 85,
    paintInlineImageXObject: 86,
    paintInlineImageXObjectGroup: 87,
    paintImageXObjectRepeat: 88,
    paintImageMaskXObjectRepeat: 89,
    paintSolidColorImageMask: 90,
    constructPath: 91,
    setStrokeTransparent: 92,
    setFillTransparent: 93
  }, Q = {
    NEED_PASSWORD: 1,
    INCORRECT_PASSWORD: 2
  };
  let J = K.WARNINGS;
  function setVerbosityLevel(t2) {
    Number.isInteger(t2) && (J = t2);
  }
  function getVerbosityLevel() {
    return J;
  }
  function info(t2) {
    J >= K.INFOS && console.log(`Info: ${t2}`);
  }
  function warn(t2) {
    J >= K.WARNINGS && console.log(`Warning: ${t2}`);
  }
  function unreachable(t2) {
    throw new Error(t2);
  }
  function assert(t2, e2) {
    t2 || unreachable(e2);
  }
  function createValidAbsoluteUrl(t2, e2 = null, i2 = null) {
    if (!t2) return null;
    try {
      if (i2 && "string" == typeof t2) {
        if (i2.addDefaultProtocol && t2.startsWith("www.")) {
          const e3 = t2.match(/\./g);
          (e3 == null ? void 0 : e3.length) >= 2 && (t2 = `http://${t2}`);
        }
        if (i2.tryConvertEncoding) try {
          t2 = function stringToUTF8String(t3) {
            return decodeURIComponent(escape(t3));
          }(t2);
        } catch {
        }
      }
      const s2 = e2 ? new URL(t2, e2) : new URL(t2);
      if (function _isValidProtocol(t3) {
        switch (t3 == null ? void 0 : t3.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return true;
          default:
            return false;
        }
      }(s2)) return s2;
    } catch {
    }
    return null;
  }
  function shadow(t2, e2, i2, s2 = false) {
    Object.defineProperty(t2, e2, {
      value: i2,
      enumerable: !s2,
      configurable: true,
      writable: false
    });
    return i2;
  }
  const Z = function BaseExceptionClosure() {
    function BaseException(t2, e2) {
      this.message = t2;
      this.name = e2;
    }
    BaseException.prototype = new Error();
    BaseException.constructor = BaseException;
    return BaseException;
  }();
  class PasswordException extends Z {
    constructor(t2, e2) {
      super(t2, "PasswordException");
      this.code = e2;
    }
  }
  class UnknownErrorException extends Z {
    constructor(t2, e2) {
      super(t2, "UnknownErrorException");
      this.details = e2;
    }
  }
  class InvalidPDFException extends Z {
    constructor(t2) {
      super(t2, "InvalidPDFException");
    }
  }
  class MissingPDFException extends Z {
    constructor(t2) {
      super(t2, "MissingPDFException");
    }
  }
  class UnexpectedResponseException extends Z {
    constructor(t2, e2) {
      super(t2, "UnexpectedResponseException");
      this.status = e2;
    }
  }
  class FormatError extends Z {
    constructor(t2) {
      super(t2, "FormatError");
    }
  }
  class AbortException extends Z {
    constructor(t2) {
      super(t2, "AbortException");
    }
  }
  function bytesToString(t2) {
    "object" == typeof t2 && void 0 !== (t2 == null ? void 0 : t2.length) || unreachable("Invalid argument for bytesToString");
    const e2 = t2.length, i2 = 8192;
    if (e2 < i2) return String.fromCharCode.apply(null, t2);
    const s2 = [];
    for (let n2 = 0; n2 < e2; n2 += i2) {
      const r2 = Math.min(n2 + i2, e2), a2 = t2.subarray(n2, r2);
      s2.push(String.fromCharCode.apply(null, a2));
    }
    return s2.join("");
  }
  function stringToBytes(t2) {
    "string" != typeof t2 && unreachable("Invalid argument for stringToBytes");
    const e2 = t2.length, i2 = new Uint8Array(e2);
    for (let s2 = 0; s2 < e2; ++s2) i2[s2] = 255 & t2.charCodeAt(s2);
    return i2;
  }
  function objectFromMap(t2) {
    const e2 = /* @__PURE__ */ Object.create(null);
    for (const [i2, s2] of t2) e2[i2] = s2;
    return e2;
  }
  class util_FeatureTest {
    static get isLittleEndian() {
      return shadow(this, "isLittleEndian", function isLittleEndian() {
        const t2 = new Uint8Array(4);
        t2[0] = 1;
        return 1 === new Uint32Array(t2.buffer, 0, 1)[0];
      }());
    }
    static get isEvalSupported() {
      return shadow(this, "isEvalSupported", function isEvalSupported() {
        try {
          new Function("");
          return true;
        } catch {
          return false;
        }
      }());
    }
    static get isOffscreenCanvasSupported() {
      return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get platform() {
      return "undefined" != typeof navigator && "string" == typeof (navigator == null ? void 0 : navigator.platform) ? shadow(this, "platform", {
        isMac: navigator.platform.includes("Mac"),
        isWindows: navigator.platform.includes("Win"),
        isFirefox: "string" == typeof (navigator == null ? void 0 : navigator.userAgent) && navigator.userAgent.includes("Firefox")
      }) : shadow(this, "platform", {
        isMac: false,
        isWindows: false,
        isFirefox: false
      });
    }
    static get isCSSRoundSupported() {
      var _a4, _b2;
      return shadow(this, "isCSSRoundSupported", (_b2 = (_a4 = globalThis.CSS) == null ? void 0 : _a4.supports) == null ? void 0 : _b2.call(_a4, "width: round(1.5px, 1px)"));
    }
  }
  const tt = Array.from(Array(256).keys(), (t2) => t2.toString(16).padStart(2, "0"));
  class Util {
    static makeHexColor(t2, e2, i2) {
      return `#${tt[t2]}${tt[e2]}${tt[i2]}`;
    }
    static scaleMinMax(t2, e2) {
      let i2;
      if (t2[0]) {
        if (t2[0] < 0) {
          i2 = e2[0];
          e2[0] = e2[2];
          e2[2] = i2;
        }
        e2[0] *= t2[0];
        e2[2] *= t2[0];
        if (t2[3] < 0) {
          i2 = e2[1];
          e2[1] = e2[3];
          e2[3] = i2;
        }
        e2[1] *= t2[3];
        e2[3] *= t2[3];
      } else {
        i2 = e2[0];
        e2[0] = e2[1];
        e2[1] = i2;
        i2 = e2[2];
        e2[2] = e2[3];
        e2[3] = i2;
        if (t2[1] < 0) {
          i2 = e2[1];
          e2[1] = e2[3];
          e2[3] = i2;
        }
        e2[1] *= t2[1];
        e2[3] *= t2[1];
        if (t2[2] < 0) {
          i2 = e2[0];
          e2[0] = e2[2];
          e2[2] = i2;
        }
        e2[0] *= t2[2];
        e2[2] *= t2[2];
      }
      e2[0] += t2[4];
      e2[1] += t2[5];
      e2[2] += t2[4];
      e2[3] += t2[5];
    }
    static transform(t2, e2) {
      return [
        t2[0] * e2[0] + t2[2] * e2[1],
        t2[1] * e2[0] + t2[3] * e2[1],
        t2[0] * e2[2] + t2[2] * e2[3],
        t2[1] * e2[2] + t2[3] * e2[3],
        t2[0] * e2[4] + t2[2] * e2[5] + t2[4],
        t2[1] * e2[4] + t2[3] * e2[5] + t2[5]
      ];
    }
    static applyTransform(t2, e2) {
      return [
        t2[0] * e2[0] + t2[1] * e2[2] + e2[4],
        t2[0] * e2[1] + t2[1] * e2[3] + e2[5]
      ];
    }
    static applyInverseTransform(t2, e2) {
      const i2 = e2[0] * e2[3] - e2[1] * e2[2];
      return [
        (t2[0] * e2[3] - t2[1] * e2[2] + e2[2] * e2[5] - e2[4] * e2[3]) / i2,
        (-t2[0] * e2[1] + t2[1] * e2[0] + e2[4] * e2[1] - e2[5] * e2[0]) / i2
      ];
    }
    static getAxialAlignedBoundingBox(t2, e2) {
      const i2 = this.applyTransform(t2, e2), s2 = this.applyTransform(t2.slice(2, 4), e2), n2 = this.applyTransform([
        t2[0],
        t2[3]
      ], e2), r2 = this.applyTransform([
        t2[2],
        t2[1]
      ], e2);
      return [
        Math.min(i2[0], s2[0], n2[0], r2[0]),
        Math.min(i2[1], s2[1], n2[1], r2[1]),
        Math.max(i2[0], s2[0], n2[0], r2[0]),
        Math.max(i2[1], s2[1], n2[1], r2[1])
      ];
    }
    static inverseTransform(t2) {
      const e2 = t2[0] * t2[3] - t2[1] * t2[2];
      return [
        t2[3] / e2,
        -t2[1] / e2,
        -t2[2] / e2,
        t2[0] / e2,
        (t2[2] * t2[5] - t2[4] * t2[3]) / e2,
        (t2[4] * t2[1] - t2[5] * t2[0]) / e2
      ];
    }
    static singularValueDecompose2dScale(t2) {
      const e2 = [
        t2[0],
        t2[2],
        t2[1],
        t2[3]
      ], i2 = t2[0] * e2[0] + t2[1] * e2[2], s2 = t2[0] * e2[1] + t2[1] * e2[3], n2 = t2[2] * e2[0] + t2[3] * e2[2], r2 = t2[2] * e2[1] + t2[3] * e2[3], a2 = (i2 + r2) / 2, o2 = Math.sqrt((i2 + r2) ** 2 - 4 * (i2 * r2 - n2 * s2)) / 2, l2 = a2 + o2 || 1, h2 = a2 - o2 || 1;
      return [
        Math.sqrt(l2),
        Math.sqrt(h2)
      ];
    }
    static normalizeRect(t2) {
      const e2 = t2.slice(0);
      if (t2[0] > t2[2]) {
        e2[0] = t2[2];
        e2[2] = t2[0];
      }
      if (t2[1] > t2[3]) {
        e2[1] = t2[3];
        e2[3] = t2[1];
      }
      return e2;
    }
    static intersect(t2, e2) {
      const i2 = Math.max(Math.min(t2[0], t2[2]), Math.min(e2[0], e2[2])), s2 = Math.min(Math.max(t2[0], t2[2]), Math.max(e2[0], e2[2]));
      if (i2 > s2) return null;
      const n2 = Math.max(Math.min(t2[1], t2[3]), Math.min(e2[1], e2[3])), r2 = Math.min(Math.max(t2[1], t2[3]), Math.max(e2[1], e2[3]));
      return n2 > r2 ? null : [
        i2,
        n2,
        s2,
        r2
      ];
    }
    static bezierBoundingBox(t2, e2, i2, s2, n2, r2, a2, o2, l2) {
      if (l2) {
        l2[0] = Math.min(l2[0], t2, a2);
        l2[1] = Math.min(l2[1], e2, o2);
        l2[2] = Math.max(l2[2], t2, a2);
        l2[3] = Math.max(l2[3], e2, o2);
      } else l2 = [
        Math.min(t2, a2),
        Math.min(e2, o2),
        Math.max(t2, a2),
        Math.max(e2, o2)
      ];
      __privateMethod(this, _Util_static, e_fn).call(this, t2, i2, n2, a2, e2, s2, r2, o2, 3 * (3 * (i2 - n2) - t2 + a2), 6 * (t2 - 2 * i2 + n2), 3 * (i2 - t2), l2);
      __privateMethod(this, _Util_static, e_fn).call(this, t2, i2, n2, a2, e2, s2, r2, o2, 3 * (3 * (s2 - r2) - e2 + o2), 6 * (e2 - 2 * s2 + r2), 3 * (s2 - e2), l2);
      return l2;
    }
  }
  _Util_static = new WeakSet();
  t_fn = function(t2, e2, i2, s2, n2, r2, a2, o2, l2, h2) {
    if (l2 <= 0 || l2 >= 1) return;
    const c2 = 1 - l2, d2 = l2 * l2, u2 = d2 * l2, p2 = c2 * (c2 * (c2 * t2 + 3 * l2 * e2) + 3 * d2 * i2) + u2 * s2, g2 = c2 * (c2 * (c2 * n2 + 3 * l2 * r2) + 3 * d2 * a2) + u2 * o2;
    h2[0] = Math.min(h2[0], p2);
    h2[1] = Math.min(h2[1], g2);
    h2[2] = Math.max(h2[2], p2);
    h2[3] = Math.max(h2[3], g2);
  };
  e_fn = function(t2, e2, i2, s2, n2, r2, a2, o2, l2, h2, c2, d2) {
    if (Math.abs(l2) < 1e-12) {
      Math.abs(h2) >= 1e-12 && __privateMethod(this, _Util_static, t_fn).call(this, t2, e2, i2, s2, n2, r2, a2, o2, -c2 / h2, d2);
      return;
    }
    const u2 = h2 ** 2 - 4 * c2 * l2;
    if (u2 < 0) return;
    const p2 = Math.sqrt(u2), g2 = 2 * l2;
    __privateMethod(this, _Util_static, t_fn).call(this, t2, e2, i2, s2, n2, r2, a2, o2, (-h2 + p2) / g2, d2);
    __privateMethod(this, _Util_static, t_fn).call(this, t2, e2, i2, s2, n2, r2, a2, o2, (-h2 - p2) / g2, d2);
  };
  __privateAdd(Util, _Util_static);
  let et = null, it = null;
  function normalizeUnicode(t2) {
    if (!et) {
      et = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
      it = /* @__PURE__ */ new Map([
        [
          "\uFB05",
          "\u017Ft"
        ]
      ]);
    }
    return t2.replaceAll(et, (t3, e2, i2) => e2 ? e2.normalize("NFKC") : it.get(i2));
  }
  const st = "pdfjs_internal_id_", nt = 0, rt = 1, at = 2, ot = 3, lt = 4, ht = 5, ct = 6, dt = 7, ut = 8;
  __webpack_require__(4628), __webpack_require__(7642), __webpack_require__(8004), __webpack_require__(3853), __webpack_require__(5876), __webpack_require__(2475), __webpack_require__(5024), __webpack_require__(1698), __webpack_require__(1454), __webpack_require__(8992), __webpack_require__(4743), __webpack_require__(3215), __webpack_require__(7550), __webpack_require__(8335);
  const pt = "http://www.w3.org/2000/svg";
  const _PixelsPerInch = class _PixelsPerInch {
  };
  __publicField(_PixelsPerInch, "CSS", 96);
  __publicField(_PixelsPerInch, "PDF", 72);
  __publicField(_PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
  let PixelsPerInch = _PixelsPerInch;
  async function fetchData(t2, e2 = "text") {
    if (isValidFetchUrl(t2, document.baseURI)) {
      const i2 = await fetch(t2);
      if (!i2.ok) throw new Error(i2.statusText);
      switch (e2) {
        case "arraybuffer":
          return i2.arrayBuffer();
        case "blob":
          return i2.blob();
        case "json":
          return i2.json();
      }
      return i2.text();
    }
    return new Promise((i2, s2) => {
      const n2 = new XMLHttpRequest();
      n2.open("GET", t2, true);
      n2.responseType = e2;
      n2.onreadystatechange = () => {
        if (n2.readyState === XMLHttpRequest.DONE) if (200 !== n2.status && 0 !== n2.status) s2(new Error(n2.statusText));
        else {
          switch (e2) {
            case "arraybuffer":
            case "blob":
            case "json":
              i2(n2.response);
              return;
          }
          i2(n2.responseText);
        }
      };
      n2.send(null);
    });
  }
  class PageViewport {
    constructor({ viewBox: t2, scale: e2, rotation: i2, offsetX: s2 = 0, offsetY: n2 = 0, dontFlip: r2 = false }) {
      this.viewBox = t2;
      this.scale = e2;
      this.rotation = i2;
      this.offsetX = s2;
      this.offsetY = n2;
      const a2 = (t2[2] + t2[0]) / 2, o2 = (t2[3] + t2[1]) / 2;
      let l2, h2, c2, d2, u2, p2, g2, f2;
      (i2 %= 360) < 0 && (i2 += 360);
      switch (i2) {
        case 180:
          l2 = -1;
          h2 = 0;
          c2 = 0;
          d2 = 1;
          break;
        case 90:
          l2 = 0;
          h2 = 1;
          c2 = 1;
          d2 = 0;
          break;
        case 270:
          l2 = 0;
          h2 = -1;
          c2 = -1;
          d2 = 0;
          break;
        case 0:
          l2 = 1;
          h2 = 0;
          c2 = 0;
          d2 = -1;
          break;
        default:
          throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
      }
      if (r2) {
        c2 = -c2;
        d2 = -d2;
      }
      if (0 === l2) {
        u2 = Math.abs(o2 - t2[1]) * e2 + s2;
        p2 = Math.abs(a2 - t2[0]) * e2 + n2;
        g2 = (t2[3] - t2[1]) * e2;
        f2 = (t2[2] - t2[0]) * e2;
      } else {
        u2 = Math.abs(a2 - t2[0]) * e2 + s2;
        p2 = Math.abs(o2 - t2[1]) * e2 + n2;
        g2 = (t2[2] - t2[0]) * e2;
        f2 = (t2[3] - t2[1]) * e2;
      }
      this.transform = [
        l2 * e2,
        h2 * e2,
        c2 * e2,
        d2 * e2,
        u2 - l2 * e2 * a2 - c2 * e2 * o2,
        p2 - h2 * e2 * a2 - d2 * e2 * o2
      ];
      this.width = g2;
      this.height = f2;
    }
    get rawDims() {
      const { viewBox: t2 } = this;
      return shadow(this, "rawDims", {
        pageWidth: t2[2] - t2[0],
        pageHeight: t2[3] - t2[1],
        pageX: t2[0],
        pageY: t2[1]
      });
    }
    clone({ scale: t2 = this.scale, rotation: e2 = this.rotation, offsetX: i2 = this.offsetX, offsetY: s2 = this.offsetY, dontFlip: n2 = false } = {}) {
      return new PageViewport({
        viewBox: this.viewBox.slice(),
        scale: t2,
        rotation: e2,
        offsetX: i2,
        offsetY: s2,
        dontFlip: n2
      });
    }
    convertToViewportPoint(t2, e2) {
      return Util.applyTransform([
        t2,
        e2
      ], this.transform);
    }
    convertToViewportRectangle(t2) {
      const e2 = Util.applyTransform([
        t2[0],
        t2[1]
      ], this.transform), i2 = Util.applyTransform([
        t2[2],
        t2[3]
      ], this.transform);
      return [
        e2[0],
        e2[1],
        i2[0],
        i2[1]
      ];
    }
    convertToPdfPoint(t2, e2) {
      return Util.applyInverseTransform([
        t2,
        e2
      ], this.transform);
    }
  }
  class RenderingCancelledException extends Z {
    constructor(t2, e2 = 0) {
      super(t2, "RenderingCancelledException");
      this.extraDelay = e2;
    }
  }
  function isDataScheme(t2) {
    const e2 = t2.length;
    let i2 = 0;
    for (; i2 < e2 && "" === t2[i2].trim(); ) i2++;
    return "data:" === t2.substring(i2, i2 + 5).toLowerCase();
  }
  function isPdfFile(t2) {
    return "string" == typeof t2 && /\.pdf$/i.test(t2);
  }
  function getFilenameFromUrl(t2) {
    [t2] = t2.split(/[#?]/, 1);
    return t2.substring(t2.lastIndexOf("/") + 1);
  }
  function getPdfFilenameFromUrl(t2, e2 = "document.pdf") {
    if ("string" != typeof t2) return e2;
    if (isDataScheme(t2)) {
      warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
      return e2;
    }
    const i2 = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, s2 = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(t2);
    let n2 = i2.exec(s2[1]) || i2.exec(s2[2]) || i2.exec(s2[3]);
    if (n2) {
      n2 = n2[0];
      if (n2.includes("%")) try {
        n2 = i2.exec(decodeURIComponent(n2))[0];
      } catch {
      }
    }
    return n2 || e2;
  }
  class StatTimer {
    constructor() {
      __publicField(this, "started", /* @__PURE__ */ Object.create(null));
      __publicField(this, "times", []);
    }
    time(t2) {
      t2 in this.started && warn(`Timer is already running for ${t2}`);
      this.started[t2] = Date.now();
    }
    timeEnd(t2) {
      t2 in this.started || warn(`Timer has not been started for ${t2}`);
      this.times.push({
        name: t2,
        start: this.started[t2],
        end: Date.now()
      });
      delete this.started[t2];
    }
    toString() {
      const t2 = [];
      let e2 = 0;
      for (const { name: t3 } of this.times) e2 = Math.max(t3.length, e2);
      for (const { name: i2, start: s2, end: n2 } of this.times) t2.push(`${i2.padEnd(e2)} ${n2 - s2}ms
`);
      return t2.join("");
    }
  }
  function isValidFetchUrl(t2, e2) {
    try {
      const { protocol: i2 } = e2 ? new URL(t2, e2) : new URL(t2);
      return "http:" === i2 || "https:" === i2;
    } catch {
      return false;
    }
  }
  function noContextMenu(t2) {
    t2.preventDefault();
  }
  function deprecated(t2) {
    console.log("Deprecated API usage: " + t2);
  }
  class PDFDateString {
    static toDateObject(t2) {
      if (!t2 || "string" != typeof t2) return null;
      __privateGet(this, _i) || __privateSet(this, _i, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
      const e2 = __privateGet(this, _i).exec(t2);
      if (!e2) return null;
      const i2 = parseInt(e2[1], 10);
      let s2 = parseInt(e2[2], 10);
      s2 = s2 >= 1 && s2 <= 12 ? s2 - 1 : 0;
      let n2 = parseInt(e2[3], 10);
      n2 = n2 >= 1 && n2 <= 31 ? n2 : 1;
      let r2 = parseInt(e2[4], 10);
      r2 = r2 >= 0 && r2 <= 23 ? r2 : 0;
      let a2 = parseInt(e2[5], 10);
      a2 = a2 >= 0 && a2 <= 59 ? a2 : 0;
      let o2 = parseInt(e2[6], 10);
      o2 = o2 >= 0 && o2 <= 59 ? o2 : 0;
      const l2 = e2[7] || "Z";
      let h2 = parseInt(e2[8], 10);
      h2 = h2 >= 0 && h2 <= 23 ? h2 : 0;
      let c2 = parseInt(e2[9], 10) || 0;
      c2 = c2 >= 0 && c2 <= 59 ? c2 : 0;
      if ("-" === l2) {
        r2 += h2;
        a2 += c2;
      } else if ("+" === l2) {
        r2 -= h2;
        a2 -= c2;
      }
      return new Date(Date.UTC(i2, s2, n2, r2, a2, o2));
    }
  }
  _i = new WeakMap();
  __privateAdd(PDFDateString, _i);
  function getXfaPageViewport(t2, { scale: e2 = 1, rotation: i2 = 0 }) {
    const { width: s2, height: n2 } = t2.attributes.style, r2 = [
      0,
      0,
      parseInt(s2),
      parseInt(n2)
    ];
    return new PageViewport({
      viewBox: r2,
      scale: e2,
      rotation: i2
    });
  }
  function getRGB(t2) {
    if (t2.startsWith("#")) {
      const e2 = parseInt(t2.slice(1), 16);
      return [
        (16711680 & e2) >> 16,
        (65280 & e2) >> 8,
        255 & e2
      ];
    }
    if (t2.startsWith("rgb(")) return t2.slice(4, -1).split(",").map((t3) => parseInt(t3));
    if (t2.startsWith("rgba(")) return t2.slice(5, -1).split(",").map((t3) => parseInt(t3)).slice(0, 3);
    warn(`Not a valid color format: "${t2}"`);
    return [
      0,
      0,
      0
    ];
  }
  function getCurrentTransform(t2) {
    const { a: e2, b: i2, c: s2, d: n2, e: r2, f: a2 } = t2.getTransform();
    return [
      e2,
      i2,
      s2,
      n2,
      r2,
      a2
    ];
  }
  function getCurrentTransformInverse(t2) {
    const { a: e2, b: i2, c: s2, d: n2, e: r2, f: a2 } = t2.getTransform().invertSelf();
    return [
      e2,
      i2,
      s2,
      n2,
      r2,
      a2
    ];
  }
  function setLayerDimensions(t2, e2, i2 = false, s2 = true) {
    if (e2 instanceof PageViewport) {
      const { pageWidth: s3, pageHeight: n2 } = e2.rawDims, { style: r2 } = t2, a2 = util_FeatureTest.isCSSRoundSupported, o2 = `var(--scale-factor) * ${s3}px`, l2 = `var(--scale-factor) * ${n2}px`, h2 = a2 ? `round(down, ${o2}, var(--scale-round-x, 1px))` : `calc(${o2})`, c2 = a2 ? `round(down, ${l2}, var(--scale-round-y, 1px))` : `calc(${l2})`;
      if (i2 && e2.rotation % 180 != 0) {
        r2.width = c2;
        r2.height = h2;
      } else {
        r2.width = h2;
        r2.height = c2;
      }
    }
    s2 && t2.setAttribute("data-main-rotation", e2.rotation);
  }
  class OutputScale {
    constructor() {
      const t2 = window.devicePixelRatio || 1;
      this.sx = t2;
      this.sy = t2;
    }
    get scaled() {
      return 1 !== this.sx || 1 !== this.sy;
    }
    get symmetric() {
      return this.sx === this.sy;
    }
  }
  const _EditorToolbar = class _EditorToolbar {
    constructor(t2) {
      __privateAdd(this, _EditorToolbar_instances);
      __privateAdd(this, _s, null);
      __privateAdd(this, _n, null);
      __privateAdd(this, _r);
      __privateAdd(this, _a, null);
      __privateAdd(this, _o, null);
      __privateSet(this, _r, t2);
      __privateGet(_EditorToolbar, _l) || __privateSet(_EditorToolbar, _l, Object.freeze({
        freetext: "pdfjs-editor-remove-freetext-button",
        highlight: "pdfjs-editor-remove-highlight-button",
        ink: "pdfjs-editor-remove-ink-button",
        stamp: "pdfjs-editor-remove-stamp-button"
      }));
    }
    render() {
      const t2 = __privateSet(this, _s, document.createElement("div"));
      t2.classList.add("editToolbar", "hidden");
      t2.setAttribute("role", "toolbar");
      const e2 = __privateGet(this, _r)._uiManager._signal;
      t2.addEventListener("contextmenu", noContextMenu, {
        signal: e2
      });
      t2.addEventListener("pointerdown", __privateMethod(_EditorToolbar, _EditorToolbar_static, h_fn), {
        signal: e2
      });
      const i2 = __privateSet(this, _a, document.createElement("div"));
      i2.className = "buttons";
      t2.append(i2);
      const s2 = __privateGet(this, _r).toolbarPosition;
      if (s2) {
        const { style: e3 } = t2, i3 = "ltr" === __privateGet(this, _r)._uiManager.direction ? 1 - s2[0] : s2[0];
        e3.insetInlineEnd = 100 * i3 + "%";
        e3.top = `calc(${100 * s2[1]}% + var(--editor-toolbar-vert-offset))`;
      }
      __privateMethod(this, _EditorToolbar_instances, c_fn).call(this);
      return t2;
    }
    get div() {
      return __privateGet(this, _s);
    }
    hide() {
      var _a4;
      __privateGet(this, _s).classList.add("hidden");
      (_a4 = __privateGet(this, _n)) == null ? void 0 : _a4.hideDropdown();
    }
    show() {
      var _a4;
      __privateGet(this, _s).classList.remove("hidden");
      (_a4 = __privateGet(this, _o)) == null ? void 0 : _a4.shown();
    }
    async addAltText(t2) {
      const e2 = await t2.render();
      __privateMethod(this, _EditorToolbar_instances, p_fn).call(this, e2);
      __privateGet(this, _a).prepend(e2, __privateGet(this, _EditorToolbar_instances, g_get));
      __privateSet(this, _o, t2);
    }
    addColorPicker(t2) {
      __privateSet(this, _n, t2);
      const e2 = t2.renderButton();
      __privateMethod(this, _EditorToolbar_instances, p_fn).call(this, e2);
      __privateGet(this, _a).prepend(e2, __privateGet(this, _EditorToolbar_instances, g_get));
    }
    remove() {
      var _a4;
      __privateGet(this, _s).remove();
      (_a4 = __privateGet(this, _n)) == null ? void 0 : _a4.destroy();
      __privateSet(this, _n, null);
    }
  };
  _s = new WeakMap();
  _n = new WeakMap();
  _r = new WeakMap();
  _a = new WeakMap();
  _o = new WeakMap();
  _l = new WeakMap();
  _EditorToolbar_static = new WeakSet();
  h_fn = function(t2) {
    t2.stopPropagation();
  };
  _EditorToolbar_instances = new WeakSet();
  d_fn = function(t2) {
    __privateGet(this, _r)._focusEventsAllowed = false;
    t2.preventDefault();
    t2.stopPropagation();
  };
  u_fn = function(t2) {
    __privateGet(this, _r)._focusEventsAllowed = true;
    t2.preventDefault();
    t2.stopPropagation();
  };
  p_fn = function(t2) {
    const e2 = __privateGet(this, _r)._uiManager._signal;
    t2.addEventListener("focusin", __privateMethod(this, _EditorToolbar_instances, d_fn).bind(this), {
      capture: true,
      signal: e2
    });
    t2.addEventListener("focusout", __privateMethod(this, _EditorToolbar_instances, u_fn).bind(this), {
      capture: true,
      signal: e2
    });
    t2.addEventListener("contextmenu", noContextMenu, {
      signal: e2
    });
  };
  c_fn = function() {
    const { editorType: t2, _uiManager: e2 } = __privateGet(this, _r), i2 = document.createElement("button");
    i2.className = "delete";
    i2.tabIndex = 0;
    i2.setAttribute("data-l10n-id", __privateGet(_EditorToolbar, _l)[t2]);
    __privateMethod(this, _EditorToolbar_instances, p_fn).call(this, i2);
    i2.addEventListener("click", (t3) => {
      e2.delete();
    }, {
      signal: e2._signal
    });
    __privateGet(this, _a).append(i2);
  };
  g_get = function() {
    const t2 = document.createElement("div");
    t2.className = "divider";
    return t2;
  };
  __privateAdd(_EditorToolbar, _EditorToolbar_static);
  __privateAdd(_EditorToolbar, _l, null);
  let EditorToolbar = _EditorToolbar;
  class HighlightToolbar {
    constructor(t2) {
      __privateAdd(this, _HighlightToolbar_instances);
      __privateAdd(this, _a2, null);
      __privateAdd(this, _s2, null);
      __privateAdd(this, _f);
      __privateSet(this, _f, t2);
    }
    show(t2, e2, i2) {
      const [s2, n2] = __privateMethod(this, _HighlightToolbar_instances, v_fn).call(this, e2, i2), { style: r2 } = __privateGet(this, _s2) || __privateSet(this, _s2, __privateMethod(this, _HighlightToolbar_instances, m_fn).call(this));
      t2.append(__privateGet(this, _s2));
      r2.insetInlineEnd = 100 * s2 + "%";
      r2.top = `calc(${100 * n2}% + var(--editor-toolbar-vert-offset))`;
    }
    hide() {
      __privateGet(this, _s2).remove();
    }
  }
  _a2 = new WeakMap();
  _s2 = new WeakMap();
  _f = new WeakMap();
  _HighlightToolbar_instances = new WeakSet();
  m_fn = function() {
    const t2 = __privateSet(this, _s2, document.createElement("div"));
    t2.className = "editToolbar";
    t2.setAttribute("role", "toolbar");
    t2.addEventListener("contextmenu", noContextMenu, {
      signal: __privateGet(this, _f)._signal
    });
    const e2 = __privateSet(this, _a2, document.createElement("div"));
    e2.className = "buttons";
    t2.append(e2);
    __privateMethod(this, _HighlightToolbar_instances, b_fn).call(this);
    return t2;
  };
  v_fn = function(t2, e2) {
    let i2 = 0, s2 = 0;
    for (const n2 of t2) {
      const t3 = n2.y + n2.height;
      if (t3 < i2) continue;
      const r2 = n2.x + (e2 ? n2.width : 0);
      if (t3 > i2) {
        s2 = r2;
        i2 = t3;
      } else e2 ? r2 > s2 && (s2 = r2) : r2 < s2 && (s2 = r2);
    }
    return [
      e2 ? 1 - s2 : s2,
      i2
    ];
  };
  b_fn = function() {
    const t2 = document.createElement("button");
    t2.className = "highlightButton";
    t2.tabIndex = 0;
    t2.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
    const e2 = document.createElement("span");
    t2.append(e2);
    e2.className = "visuallyHidden";
    e2.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
    const i2 = __privateGet(this, _f)._signal;
    t2.addEventListener("contextmenu", noContextMenu, {
      signal: i2
    });
    t2.addEventListener("click", () => {
      __privateGet(this, _f).highlightSelection("floating_button");
    }, {
      signal: i2
    });
    __privateGet(this, _a2).append(t2);
  };
  function bindEvents(t2, e2, i2) {
    for (const s2 of i2) e2.addEventListener(s2, t2[s2].bind(t2));
  }
  class IdManager {
    constructor() {
      __privateAdd(this, _y, 0);
    }
    get id() {
      return "pdfjs_internal_editor_" + __privateWrapper(this, _y)._++;
    }
  }
  _y = new WeakMap();
  const _ImageManager = class _ImageManager {
    constructor() {
      __privateAdd(this, _ImageManager_instances);
      __privateAdd(this, _A, function getUuid() {
        if ("undefined" != typeof crypto && "function" == typeof (crypto == null ? void 0 : crypto.randomUUID)) return crypto.randomUUID();
        const t2 = new Uint8Array(32);
        if ("undefined" != typeof crypto && "function" == typeof (crypto == null ? void 0 : crypto.getRandomValues)) crypto.getRandomValues(t2);
        else for (let e2 = 0; e2 < 32; e2++) t2[e2] = Math.floor(255 * Math.random());
        return bytesToString(t2);
      }());
      __privateAdd(this, _y2, 0);
      __privateAdd(this, _w, null);
    }
    static get _isSVGFittingCanvas() {
      const t2 = new OffscreenCanvas(1, 3).getContext("2d", {
        willReadFrequently: true
      }), e2 = new Image();
      e2.src = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>';
      return shadow(this, "_isSVGFittingCanvas", e2.decode().then(() => {
        t2.drawImage(e2, 0, 0, 1, 1, 0, 0, 1, 3);
        return 0 === new Uint32Array(t2.getImageData(0, 0, 1, 1).data.buffer)[0];
      }));
    }
    async getFromFile(t2) {
      const { lastModified: e2, name: i2, size: s2, type: n2 } = t2;
      return __privateMethod(this, _ImageManager_instances, x_fn).call(this, `${e2}_${i2}_${s2}_${n2}`, t2);
    }
    async getFromUrl(t2) {
      return __privateMethod(this, _ImageManager_instances, x_fn).call(this, t2, t2);
    }
    async getFromBlob(t2, e2) {
      const i2 = await e2;
      return __privateMethod(this, _ImageManager_instances, x_fn).call(this, t2, i2);
    }
    async getFromId(t2) {
      __privateGet(this, _w) || __privateSet(this, _w, /* @__PURE__ */ new Map());
      const e2 = __privateGet(this, _w).get(t2);
      if (!e2) return null;
      if (e2.bitmap) {
        e2.refCounter += 1;
        return e2;
      }
      if (e2.file) return this.getFromFile(e2.file);
      if (e2.blobPromise) {
        const { blobPromise: t3 } = e2;
        delete e2.blobPromise;
        return this.getFromBlob(e2.id, t3);
      }
      return this.getFromUrl(e2.url);
    }
    getFromCanvas(t2, e2) {
      __privateGet(this, _w) || __privateSet(this, _w, /* @__PURE__ */ new Map());
      let i2 = __privateGet(this, _w).get(t2);
      if (i2 == null ? void 0 : i2.bitmap) {
        i2.refCounter += 1;
        return i2;
      }
      const s2 = new OffscreenCanvas(e2.width, e2.height);
      s2.getContext("2d").drawImage(e2, 0, 0);
      i2 = {
        bitmap: s2.transferToImageBitmap(),
        id: `image_${__privateGet(this, _A)}_${__privateWrapper(this, _y2)._++}`,
        refCounter: 1,
        isSvg: false
      };
      __privateGet(this, _w).set(t2, i2);
      __privateGet(this, _w).set(i2.id, i2);
      return i2;
    }
    getSvgUrl(t2) {
      const e2 = __privateGet(this, _w).get(t2);
      return (e2 == null ? void 0 : e2.isSvg) ? e2.svgUrl : null;
    }
    deleteId(t2) {
      var _a4;
      __privateGet(this, _w) || __privateSet(this, _w, /* @__PURE__ */ new Map());
      const e2 = __privateGet(this, _w).get(t2);
      if (!e2) return;
      e2.refCounter -= 1;
      if (0 !== e2.refCounter) return;
      const { bitmap: i2 } = e2;
      if (!e2.url && !e2.file) {
        const t3 = new OffscreenCanvas(i2.width, i2.height);
        t3.getContext("bitmaprenderer").transferFromImageBitmap(i2);
        e2.blobPromise = t3.convertToBlob();
      }
      (_a4 = i2.close) == null ? void 0 : _a4.call(i2);
      e2.bitmap = null;
    }
    isValidId(t2) {
      return t2.startsWith(`image_${__privateGet(this, _A)}_`);
    }
  };
  _A = new WeakMap();
  _y2 = new WeakMap();
  _w = new WeakMap();
  _ImageManager_instances = new WeakSet();
  x_fn = async function(t2, e2) {
    __privateGet(this, _w) || __privateSet(this, _w, /* @__PURE__ */ new Map());
    let i2 = __privateGet(this, _w).get(t2);
    if (null === i2) return null;
    if (i2 == null ? void 0 : i2.bitmap) {
      i2.refCounter += 1;
      return i2;
    }
    try {
      i2 || (i2 = {
        bitmap: null,
        id: `image_${__privateGet(this, _A)}_${__privateWrapper(this, _y2)._++}`,
        refCounter: 0,
        isSvg: false
      });
      let t3;
      if ("string" == typeof e2) {
        i2.url = e2;
        t3 = await fetchData(e2, "blob");
      } else e2 instanceof File ? t3 = i2.file = e2 : e2 instanceof Blob && (t3 = e2);
      if ("image/svg+xml" === t3.type) {
        const e3 = _ImageManager._isSVGFittingCanvas, s2 = new FileReader(), n2 = new Image(), r2 = new Promise((t4, r3) => {
          n2.onload = () => {
            i2.bitmap = n2;
            i2.isSvg = true;
            t4();
          };
          s2.onload = async () => {
            const t5 = i2.svgUrl = s2.result;
            n2.src = await e3 ? `${t5}#svgView(preserveAspectRatio(none))` : t5;
          };
          n2.onerror = s2.onerror = r3;
        });
        s2.readAsDataURL(t3);
        await r2;
      } else i2.bitmap = await createImageBitmap(t3);
      i2.refCounter = 1;
    } catch (t3) {
      console.error(t3);
      i2 = null;
    }
    __privateGet(this, _w).set(t2, i2);
    i2 && __privateGet(this, _w).set(i2.id, i2);
    return i2;
  };
  let ImageManager = _ImageManager;
  class CommandManager {
    constructor(t2 = 128) {
      __privateAdd(this, __, []);
      __privateAdd(this, _E, false);
      __privateAdd(this, _C);
      __privateAdd(this, _S, -1);
      __privateSet(this, _C, t2);
    }
    add({ cmd: t2, undo: e2, post: i2, mustExec: s2, type: n2 = NaN, overwriteIfSameType: r2 = false, keepUndo: a2 = false }) {
      s2 && t2();
      if (__privateGet(this, _E)) return;
      const o2 = {
        cmd: t2,
        undo: e2,
        post: i2,
        type: n2
      };
      if (-1 === __privateGet(this, _S)) {
        __privateGet(this, __).length > 0 && (__privateGet(this, __).length = 0);
        __privateSet(this, _S, 0);
        __privateGet(this, __).push(o2);
        return;
      }
      if (r2 && __privateGet(this, __)[__privateGet(this, _S)].type === n2) {
        a2 && (o2.undo = __privateGet(this, __)[__privateGet(this, _S)].undo);
        __privateGet(this, __)[__privateGet(this, _S)] = o2;
        return;
      }
      const l2 = __privateGet(this, _S) + 1;
      if (l2 === __privateGet(this, _C)) __privateGet(this, __).splice(0, 1);
      else {
        __privateSet(this, _S, l2);
        l2 < __privateGet(this, __).length && __privateGet(this, __).splice(l2);
      }
      __privateGet(this, __).push(o2);
    }
    undo() {
      if (-1 === __privateGet(this, _S)) return;
      __privateSet(this, _E, true);
      const { undo: t2, post: e2 } = __privateGet(this, __)[__privateGet(this, _S)];
      t2();
      e2 == null ? void 0 : e2();
      __privateSet(this, _E, false);
      __privateSet(this, _S, __privateGet(this, _S) - 1);
    }
    redo() {
      if (__privateGet(this, _S) < __privateGet(this, __).length - 1) {
        __privateSet(this, _S, __privateGet(this, _S) + 1);
        __privateSet(this, _E, true);
        const { cmd: t2, post: e2 } = __privateGet(this, __)[__privateGet(this, _S)];
        t2();
        e2 == null ? void 0 : e2();
        __privateSet(this, _E, false);
      }
    }
    hasSomethingToUndo() {
      return -1 !== __privateGet(this, _S);
    }
    hasSomethingToRedo() {
      return __privateGet(this, _S) < __privateGet(this, __).length - 1;
    }
    destroy() {
      __privateSet(this, __, null);
    }
  }
  __ = new WeakMap();
  _E = new WeakMap();
  _C = new WeakMap();
  _S = new WeakMap();
  class KeyboardManager {
    constructor(t2) {
      __privateAdd(this, _KeyboardManager_instances);
      this.buffer = [];
      this.callbacks = /* @__PURE__ */ new Map();
      this.allKeys = /* @__PURE__ */ new Set();
      const { isMac: e2 } = util_FeatureTest.platform;
      for (const [i2, s2, n2 = {}] of t2) for (const t3 of i2) {
        const i3 = t3.startsWith("mac+");
        if (e2 && i3) {
          this.callbacks.set(t3.slice(4), {
            callback: s2,
            options: n2
          });
          this.allKeys.add(t3.split("+").at(-1));
        } else if (!e2 && !i3) {
          this.callbacks.set(t3, {
            callback: s2,
            options: n2
          });
          this.allKeys.add(t3.split("+").at(-1));
        }
      }
    }
    exec(t2, e2) {
      if (!this.allKeys.has(e2.key)) return;
      const i2 = this.callbacks.get(__privateMethod(this, _KeyboardManager_instances, T_fn).call(this, e2));
      if (!i2) return;
      const { callback: s2, options: { bubbles: n2 = false, args: r2 = [], checker: a2 = null } } = i2;
      if (!a2 || a2(t2, e2)) {
        s2.bind(t2, ...r2, e2)();
        if (!n2) {
          e2.stopPropagation();
          e2.preventDefault();
        }
      }
    }
  }
  _KeyboardManager_instances = new WeakSet();
  T_fn = function(t2) {
    t2.altKey && this.buffer.push("alt");
    t2.ctrlKey && this.buffer.push("ctrl");
    t2.metaKey && this.buffer.push("meta");
    t2.shiftKey && this.buffer.push("shift");
    this.buffer.push(t2.key);
    const e2 = this.buffer.join("+");
    this.buffer.length = 0;
    return e2;
  };
  const _ColorManager = class _ColorManager {
    get _colors() {
      const t2 = /* @__PURE__ */ new Map([
        [
          "CanvasText",
          null
        ],
        [
          "Canvas",
          null
        ]
      ]);
      !function getColorValues(t3) {
        const e2 = document.createElement("span");
        e2.style.visibility = "hidden";
        document.body.append(e2);
        for (const i2 of t3.keys()) {
          e2.style.color = i2;
          const s2 = window.getComputedStyle(e2).color;
          t3.set(i2, getRGB(s2));
        }
        e2.remove();
      }(t2);
      return shadow(this, "_colors", t2);
    }
    convert(t2) {
      const e2 = getRGB(t2);
      if (!window.matchMedia("(forced-colors: active)").matches) return e2;
      for (const [t3, i2] of this._colors) if (i2.every((t4, i3) => t4 === e2[i3])) return _ColorManager._colorsMapping.get(t3);
      return e2;
    }
    getHexCode(t2) {
      const e2 = this._colors.get(t2);
      return e2 ? Util.makeHexColor(...e2) : t2;
    }
  };
  __publicField(_ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([
    [
      "CanvasText",
      [
        0,
        0,
        0
      ]
    ],
    [
      "Canvas",
      [
        255,
        255,
        255
      ]
    ]
  ]));
  let ColorManager = _ColorManager;
  const _AnnotationEditorUIManager = class _AnnotationEditorUIManager {
    constructor(t2, e2, i2, s2, n2, r2, a2, o2, l2, h2, c2) {
      __privateAdd(this, _AnnotationEditorUIManager_instances);
      __privateAdd(this, _M, new AbortController());
      __privateAdd(this, _k, null);
      __privateAdd(this, _P, /* @__PURE__ */ new Map());
      __privateAdd(this, _R, /* @__PURE__ */ new Map());
      __privateAdd(this, _D, null);
      __privateAdd(this, _I, null);
      __privateAdd(this, _F, null);
      __privateAdd(this, _L, new CommandManager());
      __privateAdd(this, _O, null);
      __privateAdd(this, _N, 0);
      __privateAdd(this, _B, /* @__PURE__ */ new Set());
      __privateAdd(this, _H, null);
      __privateAdd(this, _U, null);
      __privateAdd(this, _z, /* @__PURE__ */ new Set());
      __privateAdd(this, _j, false);
      __privateAdd(this, _W, false);
      __privateAdd(this, _G, false);
      __privateAdd(this, _V, null);
      __privateAdd(this, _$, null);
      __privateAdd(this, _q, null);
      __privateAdd(this, _X, null);
      __privateAdd(this, _K, false);
      __privateAdd(this, _Y, null);
      __privateAdd(this, _Q, new IdManager());
      __privateAdd(this, _J, false);
      __privateAdd(this, _Z, false);
      __privateAdd(this, _tt, null);
      __privateAdd(this, _et, null);
      __privateAdd(this, _it, null);
      __privateAdd(this, _st, null);
      __privateAdd(this, _nt, f.NONE);
      __privateAdd(this, _rt, /* @__PURE__ */ new Set());
      __privateAdd(this, _at, null);
      __privateAdd(this, _ot, null);
      __privateAdd(this, _lt, null);
      __privateAdd(this, _ht, {
        isEditing: false,
        isEmpty: true,
        hasSomethingToUndo: false,
        hasSomethingToRedo: false,
        hasSelectedEditor: false,
        hasSelectedText: false
      });
      __privateAdd(this, _ct, [
        0,
        0
      ]);
      __privateAdd(this, _dt, null);
      __privateAdd(this, _ut, null);
      __privateAdd(this, _pt, null);
      __privateAdd(this, _gt, null);
      const d2 = this._signal = __privateGet(this, _M).signal;
      __privateSet(this, _ut, t2);
      __privateSet(this, _pt, e2);
      __privateSet(this, _D, i2);
      this._eventBus = s2;
      s2._on("editingaction", this.onEditingAction.bind(this), {
        signal: d2
      });
      s2._on("pagechanging", this.onPageChanging.bind(this), {
        signal: d2
      });
      s2._on("scalechanging", this.onScaleChanging.bind(this), {
        signal: d2
      });
      s2._on("rotationchanging", this.onRotationChanging.bind(this), {
        signal: d2
      });
      s2._on("setpreference", this.onSetPreference.bind(this), {
        signal: d2
      });
      s2._on("switchannotationeditorparams", (t3) => this.updateParams(t3.type, t3.value), {
        signal: d2
      });
      __privateMethod(this, _AnnotationEditorUIManager_instances, ft_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, mt_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, bt_fn).call(this);
      __privateSet(this, _I, n2.annotationStorage);
      __privateSet(this, _V, n2.filterFactory);
      __privateSet(this, _ot, r2);
      __privateSet(this, _X, a2 || null);
      __privateSet(this, _j, o2);
      __privateSet(this, _W, l2);
      __privateSet(this, _G, h2);
      __privateSet(this, _st, c2 || null);
      this.viewParameters = {
        realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
        rotation: 0
      };
      this.isShiftKeyDown = false;
    }
    static get _keyboardManager() {
      const t2 = _AnnotationEditorUIManager.prototype, arrowChecker = (t3) => __privateGet(t3, _ut).contains(document.activeElement) && "BUTTON" !== document.activeElement.tagName && t3.hasSomethingToControl(), textInputChecker = (t3, { target: e3 }) => {
        if (e3 instanceof HTMLInputElement) {
          const { type: t4 } = e3;
          return "text" !== t4 && "number" !== t4;
        }
        return true;
      }, e2 = this.TRANSLATE_SMALL, i2 = this.TRANSLATE_BIG;
      return shadow(this, "_keyboardManager", new KeyboardManager([
        [
          [
            "ctrl+a",
            "mac+meta+a"
          ],
          t2.selectAll,
          {
            checker: textInputChecker
          }
        ],
        [
          [
            "ctrl+z",
            "mac+meta+z"
          ],
          t2.undo,
          {
            checker: textInputChecker
          }
        ],
        [
          [
            "ctrl+y",
            "ctrl+shift+z",
            "mac+meta+shift+z",
            "ctrl+shift+Z",
            "mac+meta+shift+Z"
          ],
          t2.redo,
          {
            checker: textInputChecker
          }
        ],
        [
          [
            "Backspace",
            "alt+Backspace",
            "ctrl+Backspace",
            "shift+Backspace",
            "mac+Backspace",
            "mac+alt+Backspace",
            "mac+ctrl+Backspace",
            "Delete",
            "ctrl+Delete",
            "shift+Delete",
            "mac+Delete"
          ],
          t2.delete,
          {
            checker: textInputChecker
          }
        ],
        [
          [
            "Enter",
            "mac+Enter"
          ],
          t2.addNewEditorFromKeyboard,
          {
            checker: (t3, { target: e3 }) => !(e3 instanceof HTMLButtonElement) && __privateGet(t3, _ut).contains(e3) && !t3.isEnterHandled
          }
        ],
        [
          [
            " ",
            "mac+ "
          ],
          t2.addNewEditorFromKeyboard,
          {
            checker: (t3, { target: e3 }) => !(e3 instanceof HTMLButtonElement) && __privateGet(t3, _ut).contains(document.activeElement)
          }
        ],
        [
          [
            "Escape",
            "mac+Escape"
          ],
          t2.unselectAll
        ],
        [
          [
            "ArrowLeft",
            "mac+ArrowLeft"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              -e2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowLeft",
            "mac+shift+ArrowLeft"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              -i2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ArrowRight",
            "mac+ArrowRight"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              e2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowRight",
            "mac+shift+ArrowRight"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              i2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ArrowUp",
            "mac+ArrowUp"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              0,
              -e2
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowUp",
            "mac+shift+ArrowUp"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              0,
              -i2
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ArrowDown",
            "mac+ArrowDown"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              0,
              e2
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowDown",
            "mac+shift+ArrowDown"
          ],
          t2.translateSelectedEditors,
          {
            args: [
              0,
              i2
            ],
            checker: arrowChecker
          }
        ]
      ]));
    }
    destroy() {
      var _a4, _b2, _c, _d;
      (_a4 = __privateGet(this, _gt)) == null ? void 0 : _a4.resolve();
      __privateSet(this, _gt, null);
      (_b2 = __privateGet(this, _M)) == null ? void 0 : _b2.abort();
      __privateSet(this, _M, null);
      this._signal = null;
      for (const t2 of __privateGet(this, _R).values()) t2.destroy();
      __privateGet(this, _R).clear();
      __privateGet(this, _P).clear();
      __privateGet(this, _z).clear();
      __privateSet(this, _k, null);
      __privateGet(this, _rt).clear();
      __privateGet(this, _L).destroy();
      (_c = __privateGet(this, _D)) == null ? void 0 : _c.destroy();
      (_d = __privateGet(this, _Y)) == null ? void 0 : _d.hide();
      __privateSet(this, _Y, null);
      if (__privateGet(this, _$)) {
        clearTimeout(__privateGet(this, _$));
        __privateSet(this, _$, null);
      }
      if (__privateGet(this, _dt)) {
        clearTimeout(__privateGet(this, _dt));
        __privateSet(this, _dt, null);
      }
    }
    combinedSignal(t2) {
      return AbortSignal.any([
        this._signal,
        t2.signal
      ]);
    }
    get mlManager() {
      return __privateGet(this, _st);
    }
    get useNewAltTextFlow() {
      return __privateGet(this, _W);
    }
    get useNewAltTextWhenAddingImage() {
      return __privateGet(this, _G);
    }
    get hcmFilter() {
      return shadow(this, "hcmFilter", __privateGet(this, _ot) ? __privateGet(this, _V).addHCMFilter(__privateGet(this, _ot).foreground, __privateGet(this, _ot).background) : "none");
    }
    get direction() {
      return shadow(this, "direction", getComputedStyle(__privateGet(this, _ut)).direction);
    }
    get highlightColors() {
      return shadow(this, "highlightColors", __privateGet(this, _X) ? new Map(__privateGet(this, _X).split(",").map((t2) => t2.split("=").map((t3) => t3.trim()))) : null);
    }
    get highlightColorNames() {
      return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (t2) => t2.reverse())) : null);
    }
    setMainHighlightColorPicker(t2) {
      __privateSet(this, _it, t2);
    }
    editAltText(t2, e2 = false) {
      var _a4;
      (_a4 = __privateGet(this, _D)) == null ? void 0 : _a4.editAltText(this, t2, e2);
    }
    switchToMode(t2, e2) {
      this._eventBus.on("annotationeditormodechanged", e2, {
        once: true,
        signal: this._signal
      });
      this._eventBus.dispatch("showannotationeditorui", {
        source: this,
        mode: t2
      });
    }
    setPreference(t2, e2) {
      this._eventBus.dispatch("setpreference", {
        source: this,
        name: t2,
        value: e2
      });
    }
    onSetPreference({ name: t2, value: e2 }) {
      if ("enableNewAltTextWhenAddingImage" === t2) __privateSet(this, _G, e2);
    }
    onPageChanging({ pageNumber: t2 }) {
      __privateSet(this, _N, t2 - 1);
    }
    focusMainContainer() {
      __privateGet(this, _ut).focus();
    }
    findParent(t2, e2) {
      for (const i2 of __privateGet(this, _R).values()) {
        const { x: s2, y: n2, width: r2, height: a2 } = i2.div.getBoundingClientRect();
        if (t2 >= s2 && t2 <= s2 + r2 && e2 >= n2 && e2 <= n2 + a2) return i2;
      }
      return null;
    }
    disableUserSelect(t2 = false) {
      __privateGet(this, _pt).classList.toggle("noUserSelect", t2);
    }
    addShouldRescale(t2) {
      __privateGet(this, _z).add(t2);
    }
    removeShouldRescale(t2) {
      __privateGet(this, _z).delete(t2);
    }
    onScaleChanging({ scale: t2 }) {
      this.commitOrRemove();
      this.viewParameters.realScale = t2 * PixelsPerInch.PDF_TO_CSS_UNITS;
      for (const t3 of __privateGet(this, _z)) t3.onScaleChanging();
    }
    onRotationChanging({ pagesRotation: t2 }) {
      this.commitOrRemove();
      this.viewParameters.rotation = t2;
    }
    highlightSelection(t2 = "") {
      const e2 = document.getSelection();
      if (!e2 || e2.isCollapsed) return;
      const { anchorNode: i2, anchorOffset: s2, focusNode: n2, focusOffset: r2 } = e2, a2 = e2.toString(), o2 = __privateMethod(this, _AnnotationEditorUIManager_instances, vt_fn).call(this, e2).closest(".textLayer"), l2 = this.getSelectionBoxes(o2);
      if (!l2) return;
      e2.empty();
      const h2 = __privateMethod(this, _AnnotationEditorUIManager_instances, yt_fn).call(this, o2), c2 = __privateGet(this, _nt) === f.NONE, callback = () => {
        h2 == null ? void 0 : h2.createAndAddNewEditor({
          x: 0,
          y: 0
        }, false, {
          methodOfCreation: t2,
          boxes: l2,
          anchorNode: i2,
          anchorOffset: s2,
          focusNode: n2,
          focusOffset: r2,
          text: a2
        });
        c2 && this.showAllEditors("highlight", true, true);
      };
      c2 ? this.switchToMode(f.HIGHLIGHT, callback) : callback();
    }
    addToAnnotationStorage(t2) {
      t2.isEmpty() || !__privateGet(this, _I) || __privateGet(this, _I).has(t2.id) || __privateGet(this, _I).setValue(t2.id, t2);
    }
    blur() {
      this.isShiftKeyDown = false;
      if (__privateGet(this, _K)) {
        __privateSet(this, _K, false);
        __privateMethod(this, _AnnotationEditorUIManager_instances, _t_fn).call(this, "main_toolbar");
      }
      if (!this.hasSelection) return;
      const { activeElement: t2 } = document;
      for (const e2 of __privateGet(this, _rt)) if (e2.div.contains(t2)) {
        __privateSet(this, _et, [
          e2,
          t2
        ]);
        e2._focusEventsAllowed = false;
        break;
      }
    }
    focus() {
      if (!__privateGet(this, _et)) return;
      const [t2, e2] = __privateGet(this, _et);
      __privateSet(this, _et, null);
      e2.addEventListener("focusin", () => {
        t2._focusEventsAllowed = true;
      }, {
        once: true,
        signal: this._signal
      });
      e2.focus();
    }
    addEditListeners() {
      __privateMethod(this, _AnnotationEditorUIManager_instances, bt_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Tt_fn).call(this);
    }
    removeEditListeners() {
      __privateMethod(this, _AnnotationEditorUIManager_instances, St_fn).call(this);
      __privateMethod(this, _AnnotationEditorUIManager_instances, Mt_fn).call(this);
    }
    dragOver(t2) {
      for (const { type: e2 } of t2.dataTransfer.items) for (const i2 of __privateGet(this, _U)) if (i2.isHandlingMimeForPasting(e2)) {
        t2.dataTransfer.dropEffect = "copy";
        t2.preventDefault();
        return;
      }
    }
    drop(t2) {
      for (const e2 of t2.dataTransfer.items) for (const i2 of __privateGet(this, _U)) if (i2.isHandlingMimeForPasting(e2.type)) {
        i2.paste(e2, this.currentLayer);
        t2.preventDefault();
        return;
      }
    }
    copy(t2) {
      var _a4;
      t2.preventDefault();
      (_a4 = __privateGet(this, _k)) == null ? void 0 : _a4.commitOrRemove();
      if (!this.hasSelection) return;
      const e2 = [];
      for (const t3 of __privateGet(this, _rt)) {
        const i2 = t3.serialize(true);
        i2 && e2.push(i2);
      }
      0 !== e2.length && t2.clipboardData.setData("application/pdfjs", JSON.stringify(e2));
    }
    cut(t2) {
      this.copy(t2);
      this.delete();
    }
    async paste(t2) {
      t2.preventDefault();
      const { clipboardData: e2 } = t2;
      for (const t3 of e2.items) for (const e3 of __privateGet(this, _U)) if (e3.isHandlingMimeForPasting(t3.type)) {
        e3.paste(t3, this.currentLayer);
        return;
      }
      let i2 = e2.getData("application/pdfjs");
      if (!i2) return;
      try {
        i2 = JSON.parse(i2);
      } catch (t3) {
        warn(`paste: "${t3.message}".`);
        return;
      }
      if (!Array.isArray(i2)) return;
      this.unselectAll();
      const s2 = this.currentLayer;
      try {
        const t3 = [];
        for (const e3 of i2) {
          const i3 = await s2.deserialize(e3);
          if (!i3) return;
          t3.push(i3);
        }
        const cmd = () => {
          for (const e3 of t3) __privateMethod(this, _AnnotationEditorUIManager_instances, kt_fn).call(this, e3);
          __privateMethod(this, _AnnotationEditorUIManager_instances, Pt_fn).call(this, t3);
        }, undo = () => {
          for (const e3 of t3) e3.remove();
        };
        this.addCommands({
          cmd,
          undo,
          mustExec: true
        });
      } catch (t3) {
        warn(`paste: "${t3.message}".`);
      }
    }
    keydown(t2) {
      this.isShiftKeyDown || "Shift" !== t2.key || (this.isShiftKeyDown = true);
      __privateGet(this, _nt) === f.NONE || this.isEditorHandlingKeyboard || _AnnotationEditorUIManager._keyboardManager.exec(this, t2);
    }
    keyup(t2) {
      if (this.isShiftKeyDown && "Shift" === t2.key) {
        this.isShiftKeyDown = false;
        if (__privateGet(this, _K)) {
          __privateSet(this, _K, false);
          __privateMethod(this, _AnnotationEditorUIManager_instances, _t_fn).call(this, "main_toolbar");
        }
      }
    }
    onEditingAction({ name: t2 }) {
      switch (t2) {
        case "undo":
        case "redo":
        case "delete":
        case "selectAll":
          this[t2]();
          break;
        case "highlightSelection":
          this.highlightSelection("context_menu");
      }
    }
    setEditingState(t2) {
      if (t2) {
        __privateMethod(this, _AnnotationEditorUIManager_instances, Et_fn).call(this);
        __privateMethod(this, _AnnotationEditorUIManager_instances, Tt_fn).call(this);
        __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
          isEditing: __privateGet(this, _nt) !== f.NONE,
          isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Dt_fn).call(this),
          hasSomethingToUndo: __privateGet(this, _L).hasSomethingToUndo(),
          hasSomethingToRedo: __privateGet(this, _L).hasSomethingToRedo(),
          hasSelectedEditor: false
        });
      } else {
        __privateMethod(this, _AnnotationEditorUIManager_instances, Ct_fn).call(this);
        __privateMethod(this, _AnnotationEditorUIManager_instances, Mt_fn).call(this);
        __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
          isEditing: false
        });
        this.disableUserSelect(false);
      }
    }
    registerEditorTypes(t2) {
      if (!__privateGet(this, _U)) {
        __privateSet(this, _U, t2);
        for (const t3 of __privateGet(this, _U)) __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, t3.defaultPropertiesToUpdate);
      }
    }
    getId() {
      return __privateGet(this, _Q).id;
    }
    get currentLayer() {
      return __privateGet(this, _R).get(__privateGet(this, _N));
    }
    getLayer(t2) {
      return __privateGet(this, _R).get(t2);
    }
    get currentPageIndex() {
      return __privateGet(this, _N);
    }
    addLayer(t2) {
      __privateGet(this, _R).set(t2.pageIndex, t2);
      __privateGet(this, _J) ? t2.enable() : t2.disable();
    }
    removeLayer(t2) {
      __privateGet(this, _R).delete(t2.pageIndex);
    }
    async updateMode(t2, e2 = null, i2 = false) {
      if (__privateGet(this, _nt) !== t2) {
        if (__privateGet(this, _gt)) {
          await __privateGet(this, _gt).promise;
          if (!__privateGet(this, _gt)) return;
        }
        __privateSet(this, _gt, Promise.withResolvers());
        __privateSet(this, _nt, t2);
        if (t2 !== f.NONE) {
          this.setEditingState(true);
          await __privateMethod(this, _AnnotationEditorUIManager_instances, It_fn).call(this);
          this.unselectAll();
          for (const e3 of __privateGet(this, _R).values()) e3.updateMode(t2);
          if (e2) {
            for (const t3 of __privateGet(this, _P).values()) if (t3.annotationElementId === e2) {
              this.setSelected(t3);
              t3.enterInEditMode();
            } else t3.unselect();
            __privateGet(this, _gt).resolve();
          } else {
            i2 && this.addNewEditorFromKeyboard();
            __privateGet(this, _gt).resolve();
          }
        } else {
          this.setEditingState(false);
          __privateMethod(this, _AnnotationEditorUIManager_instances, Ft_fn).call(this);
          __privateGet(this, _gt).resolve();
        }
      }
    }
    addNewEditorFromKeyboard() {
      this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
    }
    updateToolbar(t2) {
      t2 !== __privateGet(this, _nt) && this._eventBus.dispatch("switchannotationeditormode", {
        source: this,
        mode: t2
      });
    }
    updateParams(t2, e2) {
      var _a4;
      if (__privateGet(this, _U)) {
        switch (t2) {
          case m.CREATE:
            this.currentLayer.addNewEditor();
            return;
          case m.HIGHLIGHT_DEFAULT_COLOR:
            (_a4 = __privateGet(this, _it)) == null ? void 0 : _a4.updateColor(e2);
            break;
          case m.HIGHLIGHT_SHOW_ALL:
            this._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                data: {
                  type: "highlight",
                  action: "toggle_visibility"
                }
              }
            });
            (__privateGet(this, _lt) || __privateSet(this, _lt, /* @__PURE__ */ new Map())).set(t2, e2);
            this.showAllEditors("highlight", e2);
        }
        for (const i2 of __privateGet(this, _rt)) i2.updateParams(t2, e2);
        for (const i2 of __privateGet(this, _U)) i2.updateDefaultParams(t2, e2);
      }
    }
    showAllEditors(t2, e2, i2 = false) {
      var _a4;
      for (const i3 of __privateGet(this, _P).values()) i3.editorType === t2 && i3.show(e2);
      (((_a4 = __privateGet(this, _lt)) == null ? void 0 : _a4.get(m.HIGHLIGHT_SHOW_ALL)) ?? true) !== e2 && __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, [
        [
          m.HIGHLIGHT_SHOW_ALL,
          e2
        ]
      ]);
    }
    enableWaiting(t2 = false) {
      if (__privateGet(this, _Z) !== t2) {
        __privateSet(this, _Z, t2);
        for (const e2 of __privateGet(this, _R).values()) {
          t2 ? e2.disableClick() : e2.enableClick();
          e2.div.classList.toggle("waiting", t2);
        }
      }
    }
    getEditors(t2) {
      const e2 = [];
      for (const i2 of __privateGet(this, _P).values()) i2.pageIndex === t2 && e2.push(i2);
      return e2;
    }
    getEditor(t2) {
      return __privateGet(this, _P).get(t2);
    }
    addEditor(t2) {
      __privateGet(this, _P).set(t2.id, t2);
    }
    removeEditor(t2) {
      var _a4;
      if (t2.div.contains(document.activeElement)) {
        __privateGet(this, _$) && clearTimeout(__privateGet(this, _$));
        __privateSet(this, _$, setTimeout(() => {
          this.focusMainContainer();
          __privateSet(this, _$, null);
        }, 0));
      }
      __privateGet(this, _P).delete(t2.id);
      this.unselect(t2);
      t2.annotationElementId && __privateGet(this, _B).has(t2.annotationElementId) || ((_a4 = __privateGet(this, _I)) == null ? void 0 : _a4.remove(t2.id));
    }
    addDeletedAnnotationElement(t2) {
      __privateGet(this, _B).add(t2.annotationElementId);
      this.addChangedExistingAnnotation(t2);
      t2.deleted = true;
    }
    isDeletedAnnotationElement(t2) {
      return __privateGet(this, _B).has(t2);
    }
    removeDeletedAnnotationElement(t2) {
      __privateGet(this, _B).delete(t2.annotationElementId);
      this.removeChangedExistingAnnotation(t2);
      t2.deleted = false;
    }
    setActiveEditor(t2) {
      if (__privateGet(this, _k) !== t2) {
        __privateSet(this, _k, t2);
        t2 && __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, t2.propertiesToUpdate);
      }
    }
    updateUI(t2) {
      __privateGet(this, _AnnotationEditorUIManager_instances, Lt_get) === t2 && __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, t2.propertiesToUpdate);
    }
    toggleSelected(t2) {
      if (__privateGet(this, _rt).has(t2)) {
        __privateGet(this, _rt).delete(t2);
        t2.unselect();
        __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
          hasSelectedEditor: this.hasSelection
        });
      } else {
        __privateGet(this, _rt).add(t2);
        t2.select();
        __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, t2.propertiesToUpdate);
        __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
          hasSelectedEditor: true
        });
      }
    }
    setSelected(t2) {
      for (const e2 of __privateGet(this, _rt)) e2 !== t2 && e2.unselect();
      __privateGet(this, _rt).clear();
      __privateGet(this, _rt).add(t2);
      t2.select();
      __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, t2.propertiesToUpdate);
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSelectedEditor: true
      });
    }
    isSelected(t2) {
      return __privateGet(this, _rt).has(t2);
    }
    get firstSelectedEditor() {
      return __privateGet(this, _rt).values().next().value;
    }
    unselect(t2) {
      t2.unselect();
      __privateGet(this, _rt).delete(t2);
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSelectedEditor: this.hasSelection
      });
    }
    get hasSelection() {
      return 0 !== __privateGet(this, _rt).size;
    }
    get isEnterHandled() {
      return 1 === __privateGet(this, _rt).size && this.firstSelectedEditor.isEnterHandled;
    }
    undo() {
      __privateGet(this, _L).undo();
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSomethingToUndo: __privateGet(this, _L).hasSomethingToUndo(),
        hasSomethingToRedo: true,
        isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Dt_fn).call(this)
      });
    }
    redo() {
      __privateGet(this, _L).redo();
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSomethingToUndo: true,
        hasSomethingToRedo: __privateGet(this, _L).hasSomethingToRedo(),
        isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Dt_fn).call(this)
      });
    }
    addCommands(t2) {
      __privateGet(this, _L).add(t2);
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSomethingToUndo: true,
        hasSomethingToRedo: false,
        isEmpty: __privateMethod(this, _AnnotationEditorUIManager_instances, Dt_fn).call(this)
      });
    }
    delete() {
      this.commitOrRemove();
      if (!this.hasSelection) return;
      const t2 = [
        ...__privateGet(this, _rt)
      ];
      this.addCommands({
        cmd: () => {
          for (const e2 of t2) e2.remove();
        },
        undo: () => {
          for (const e2 of t2) __privateMethod(this, _AnnotationEditorUIManager_instances, kt_fn).call(this, e2);
        },
        mustExec: true
      });
    }
    commitOrRemove() {
      var _a4;
      (_a4 = __privateGet(this, _k)) == null ? void 0 : _a4.commitOrRemove();
    }
    hasSomethingToControl() {
      return __privateGet(this, _k) || this.hasSelection;
    }
    selectAll() {
      for (const t2 of __privateGet(this, _rt)) t2.commit();
      __privateMethod(this, _AnnotationEditorUIManager_instances, Pt_fn).call(this, __privateGet(this, _P).values());
    }
    unselectAll() {
      if (__privateGet(this, _k)) {
        __privateGet(this, _k).commitOrRemove();
        if (__privateGet(this, _nt) !== f.NONE) return;
      }
      if (this.hasSelection) {
        for (const t2 of __privateGet(this, _rt)) t2.unselect();
        __privateGet(this, _rt).clear();
        __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
          hasSelectedEditor: false
        });
      }
    }
    translateSelectedEditors(t2, e2, i2 = false) {
      i2 || this.commitOrRemove();
      if (!this.hasSelection) return;
      __privateGet(this, _ct)[0] += t2;
      __privateGet(this, _ct)[1] += e2;
      const [s2, n2] = __privateGet(this, _ct), r2 = [
        ...__privateGet(this, _rt)
      ];
      __privateGet(this, _dt) && clearTimeout(__privateGet(this, _dt));
      __privateSet(this, _dt, setTimeout(() => {
        __privateSet(this, _dt, null);
        __privateGet(this, _ct)[0] = __privateGet(this, _ct)[1] = 0;
        this.addCommands({
          cmd: () => {
            for (const t3 of r2) __privateGet(this, _P).has(t3.id) && t3.translateInPage(s2, n2);
          },
          undo: () => {
            for (const t3 of r2) __privateGet(this, _P).has(t3.id) && t3.translateInPage(-s2, -n2);
          },
          mustExec: false
        });
      }, 1e3));
      for (const i3 of r2) i3.translateInPage(t2, e2);
    }
    setUpDragSession() {
      if (this.hasSelection) {
        this.disableUserSelect(true);
        __privateSet(this, _H, /* @__PURE__ */ new Map());
        for (const t2 of __privateGet(this, _rt)) __privateGet(this, _H).set(t2, {
          savedX: t2.x,
          savedY: t2.y,
          savedPageIndex: t2.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
      }
    }
    endDragSession() {
      if (!__privateGet(this, _H)) return false;
      this.disableUserSelect(false);
      const t2 = __privateGet(this, _H);
      __privateSet(this, _H, null);
      let e2 = false;
      for (const [{ x: i2, y: s2, pageIndex: n2 }, r2] of t2) {
        r2.newX = i2;
        r2.newY = s2;
        r2.newPageIndex = n2;
        e2 || (e2 = i2 !== r2.savedX || s2 !== r2.savedY || n2 !== r2.savedPageIndex);
      }
      if (!e2) return false;
      const move = (t3, e3, i2, s2) => {
        if (__privateGet(this, _P).has(t3.id)) {
          const n2 = __privateGet(this, _R).get(s2);
          if (n2) t3._setParentAndPosition(n2, e3, i2);
          else {
            t3.pageIndex = s2;
            t3.x = e3;
            t3.y = i2;
          }
        }
      };
      this.addCommands({
        cmd: () => {
          for (const [e3, { newX: i2, newY: s2, newPageIndex: n2 }] of t2) move(e3, i2, s2, n2);
        },
        undo: () => {
          for (const [e3, { savedX: i2, savedY: s2, savedPageIndex: n2 }] of t2) move(e3, i2, s2, n2);
        },
        mustExec: true
      });
      return true;
    }
    dragSelectedEditors(t2, e2) {
      if (__privateGet(this, _H)) for (const i2 of __privateGet(this, _H).keys()) i2.drag(t2, e2);
    }
    rebuild(t2) {
      if (null === t2.parent) {
        const e2 = this.getLayer(t2.pageIndex);
        if (e2) {
          e2.changeParent(t2);
          e2.addOrRebuild(t2);
        } else {
          this.addEditor(t2);
          this.addToAnnotationStorage(t2);
          t2.rebuild();
        }
      } else t2.parent.addOrRebuild(t2);
    }
    get isEditorHandlingKeyboard() {
      var _a4;
      return ((_a4 = this.getActive()) == null ? void 0 : _a4.shouldGetKeyboardEvents()) || 1 === __privateGet(this, _rt).size && this.firstSelectedEditor.shouldGetKeyboardEvents();
    }
    isActive(t2) {
      return __privateGet(this, _k) === t2;
    }
    getActive() {
      return __privateGet(this, _k);
    }
    getMode() {
      return __privateGet(this, _nt);
    }
    get imageManager() {
      return shadow(this, "imageManager", new ImageManager());
    }
    getSelectionBoxes(t2) {
      if (!t2) return null;
      const e2 = document.getSelection();
      for (let i3 = 0, s3 = e2.rangeCount; i3 < s3; i3++) if (!t2.contains(e2.getRangeAt(i3).commonAncestorContainer)) return null;
      const { x: i2, y: s2, width: n2, height: r2 } = t2.getBoundingClientRect();
      let a2;
      switch (t2.getAttribute("data-main-rotation")) {
        case "90":
          a2 = (t3, e3, a3, o3) => ({
            x: (e3 - s2) / r2,
            y: 1 - (t3 + a3 - i2) / n2,
            width: o3 / r2,
            height: a3 / n2
          });
          break;
        case "180":
          a2 = (t3, e3, a3, o3) => ({
            x: 1 - (t3 + a3 - i2) / n2,
            y: 1 - (e3 + o3 - s2) / r2,
            width: a3 / n2,
            height: o3 / r2
          });
          break;
        case "270":
          a2 = (t3, e3, a3, o3) => ({
            x: 1 - (e3 + o3 - s2) / r2,
            y: (t3 - i2) / n2,
            width: o3 / r2,
            height: a3 / n2
          });
          break;
        default:
          a2 = (t3, e3, a3, o3) => ({
            x: (t3 - i2) / n2,
            y: (e3 - s2) / r2,
            width: a3 / n2,
            height: o3 / r2
          });
      }
      const o2 = [];
      for (let t3 = 0, i3 = e2.rangeCount; t3 < i3; t3++) {
        const i4 = e2.getRangeAt(t3);
        if (!i4.collapsed) for (const { x: t4, y: e3, width: s3, height: n3 } of i4.getClientRects()) 0 !== s3 && 0 !== n3 && o2.push(a2(t4, e3, s3, n3));
      }
      return 0 === o2.length ? null : o2;
    }
    addChangedExistingAnnotation({ annotationElementId: t2, id: e2 }) {
      (__privateGet(this, _F) || __privateSet(this, _F, /* @__PURE__ */ new Map())).set(t2, e2);
    }
    removeChangedExistingAnnotation({ annotationElementId: t2 }) {
      var _a4;
      (_a4 = __privateGet(this, _F)) == null ? void 0 : _a4.delete(t2);
    }
    renderAnnotationElement(t2) {
      var _a4;
      const e2 = (_a4 = __privateGet(this, _F)) == null ? void 0 : _a4.get(t2.data.id);
      if (!e2) return;
      const i2 = __privateGet(this, _I).getRawValue(e2);
      i2 && (__privateGet(this, _nt) !== f.NONE || i2.hasBeenModified) && i2.renderAnnotationElement(t2);
    }
  };
  _M = new WeakMap();
  _k = new WeakMap();
  _P = new WeakMap();
  _R = new WeakMap();
  _D = new WeakMap();
  _I = new WeakMap();
  _F = new WeakMap();
  _L = new WeakMap();
  _O = new WeakMap();
  _N = new WeakMap();
  _B = new WeakMap();
  _H = new WeakMap();
  _U = new WeakMap();
  _z = new WeakMap();
  _j = new WeakMap();
  _W = new WeakMap();
  _G = new WeakMap();
  _V = new WeakMap();
  _$ = new WeakMap();
  _q = new WeakMap();
  _X = new WeakMap();
  _K = new WeakMap();
  _Y = new WeakMap();
  _Q = new WeakMap();
  _J = new WeakMap();
  _Z = new WeakMap();
  _tt = new WeakMap();
  _et = new WeakMap();
  _it = new WeakMap();
  _st = new WeakMap();
  _nt = new WeakMap();
  _rt = new WeakMap();
  _at = new WeakMap();
  _ot = new WeakMap();
  _lt = new WeakMap();
  _ht = new WeakMap();
  _ct = new WeakMap();
  _dt = new WeakMap();
  _ut = new WeakMap();
  _pt = new WeakMap();
  _gt = new WeakMap();
  _AnnotationEditorUIManager_instances = new WeakSet();
  vt_fn = function({ anchorNode: t2 }) {
    return t2.nodeType === Node.TEXT_NODE ? t2.parentElement : t2;
  };
  yt_fn = function(t2) {
    const { currentLayer: e2 } = this;
    if (e2.hasTextLayer(t2)) return e2;
    for (const e3 of __privateGet(this, _R).values()) if (e3.hasTextLayer(t2)) return e3;
    return null;
  };
  At_fn = function() {
    const t2 = document.getSelection();
    if (!t2 || t2.isCollapsed) return;
    const e2 = __privateMethod(this, _AnnotationEditorUIManager_instances, vt_fn).call(this, t2).closest(".textLayer"), i2 = this.getSelectionBoxes(e2);
    if (i2) {
      __privateGet(this, _Y) || __privateSet(this, _Y, new HighlightToolbar(this));
      __privateGet(this, _Y).show(e2, i2, "ltr" === this.direction);
    }
  };
  wt_fn = function() {
    var _a4, _b2, _c;
    const t2 = document.getSelection();
    if (!t2 || t2.isCollapsed) {
      if (__privateGet(this, _at)) {
        (_a4 = __privateGet(this, _Y)) == null ? void 0 : _a4.hide();
        __privateSet(this, _at, null);
        __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
          hasSelectedText: false
        });
      }
      return;
    }
    const { anchorNode: e2 } = t2;
    if (e2 === __privateGet(this, _at)) return;
    const i2 = __privateMethod(this, _AnnotationEditorUIManager_instances, vt_fn).call(this, t2).closest(".textLayer");
    if (i2) {
      (_b2 = __privateGet(this, _Y)) == null ? void 0 : _b2.hide();
      __privateSet(this, _at, e2);
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSelectedText: true
      });
      if (__privateGet(this, _nt) === f.HIGHLIGHT || __privateGet(this, _nt) === f.NONE) {
        __privateGet(this, _nt) === f.HIGHLIGHT && this.showAllEditors("highlight", true, true);
        __privateSet(this, _K, this.isShiftKeyDown);
        if (!this.isShiftKeyDown) {
          const t3 = __privateGet(this, _nt) === f.HIGHLIGHT ? __privateMethod(this, _AnnotationEditorUIManager_instances, yt_fn).call(this, i2) : null;
          t3 == null ? void 0 : t3.toggleDrawing();
          const e3 = new AbortController(), s2 = this.combinedSignal(e3), pointerup = (i3) => {
            if ("pointerup" !== i3.type || 0 === i3.button) {
              e3.abort();
              t3 == null ? void 0 : t3.toggleDrawing(true);
              "pointerup" === i3.type && __privateMethod(this, _AnnotationEditorUIManager_instances, _t_fn).call(this, "main_toolbar");
            }
          };
          window.addEventListener("pointerup", pointerup, {
            signal: s2
          });
          window.addEventListener("blur", pointerup, {
            signal: s2
          });
        }
      }
    } else if (__privateGet(this, _at)) {
      (_c = __privateGet(this, _Y)) == null ? void 0 : _c.hide();
      __privateSet(this, _at, null);
      __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
        hasSelectedText: false
      });
    }
  };
  _t_fn = function(t2 = "") {
    __privateGet(this, _nt) === f.HIGHLIGHT ? this.highlightSelection(t2) : __privateGet(this, _j) && __privateMethod(this, _AnnotationEditorUIManager_instances, At_fn).call(this);
  };
  ft_fn = function() {
    document.addEventListener("selectionchange", __privateMethod(this, _AnnotationEditorUIManager_instances, wt_fn).bind(this), {
      signal: this._signal
    });
  };
  Et_fn = function() {
    if (__privateGet(this, _q)) return;
    __privateSet(this, _q, new AbortController());
    const t2 = this.combinedSignal(__privateGet(this, _q));
    window.addEventListener("focus", this.focus.bind(this), {
      signal: t2
    });
    window.addEventListener("blur", this.blur.bind(this), {
      signal: t2
    });
  };
  Ct_fn = function() {
    var _a4;
    (_a4 = __privateGet(this, _q)) == null ? void 0 : _a4.abort();
    __privateSet(this, _q, null);
  };
  bt_fn = function() {
    if (__privateGet(this, _tt)) return;
    __privateSet(this, _tt, new AbortController());
    const t2 = this.combinedSignal(__privateGet(this, _tt));
    window.addEventListener("keydown", this.keydown.bind(this), {
      signal: t2
    });
    window.addEventListener("keyup", this.keyup.bind(this), {
      signal: t2
    });
  };
  St_fn = function() {
    var _a4;
    (_a4 = __privateGet(this, _tt)) == null ? void 0 : _a4.abort();
    __privateSet(this, _tt, null);
  };
  Tt_fn = function() {
    if (__privateGet(this, _O)) return;
    __privateSet(this, _O, new AbortController());
    const t2 = this.combinedSignal(__privateGet(this, _O));
    document.addEventListener("copy", this.copy.bind(this), {
      signal: t2
    });
    document.addEventListener("cut", this.cut.bind(this), {
      signal: t2
    });
    document.addEventListener("paste", this.paste.bind(this), {
      signal: t2
    });
  };
  Mt_fn = function() {
    var _a4;
    (_a4 = __privateGet(this, _O)) == null ? void 0 : _a4.abort();
    __privateSet(this, _O, null);
  };
  mt_fn = function() {
    const t2 = this._signal;
    document.addEventListener("dragover", this.dragOver.bind(this), {
      signal: t2
    });
    document.addEventListener("drop", this.drop.bind(this), {
      signal: t2
    });
  };
  xt_fn = function(t2) {
    if (Object.entries(t2).some(([t3, e2]) => __privateGet(this, _ht)[t3] !== e2)) {
      this._eventBus.dispatch("annotationeditorstateschanged", {
        source: this,
        details: Object.assign(__privateGet(this, _ht), t2)
      });
      __privateGet(this, _nt) === f.HIGHLIGHT && false === t2.hasSelectedEditor && __privateMethod(this, _AnnotationEditorUIManager_instances, Rt_fn).call(this, [
        [
          m.HIGHLIGHT_FREE,
          true
        ]
      ]);
    }
  };
  Rt_fn = function(t2) {
    this._eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details: t2
    });
  };
  It_fn = async function() {
    if (!__privateGet(this, _J)) {
      __privateSet(this, _J, true);
      const t2 = [];
      for (const e2 of __privateGet(this, _R).values()) t2.push(e2.enable());
      await Promise.all(t2);
      for (const t3 of __privateGet(this, _P).values()) t3.enable();
    }
  };
  Ft_fn = function() {
    this.unselectAll();
    if (__privateGet(this, _J)) {
      __privateSet(this, _J, false);
      for (const t2 of __privateGet(this, _R).values()) t2.disable();
      for (const t2 of __privateGet(this, _P).values()) t2.disable();
    }
  };
  kt_fn = function(t2) {
    const e2 = __privateGet(this, _R).get(t2.pageIndex);
    if (e2) e2.addOrRebuild(t2);
    else {
      this.addEditor(t2);
      this.addToAnnotationStorage(t2);
    }
  };
  Lt_get = function() {
    let t2 = null;
    for (t2 of __privateGet(this, _rt)) ;
    return t2;
  };
  Dt_fn = function() {
    if (0 === __privateGet(this, _P).size) return true;
    if (1 === __privateGet(this, _P).size) for (const t2 of __privateGet(this, _P).values()) return t2.isEmpty();
    return false;
  };
  Pt_fn = function(t2) {
    for (const t3 of __privateGet(this, _rt)) t3.unselect();
    __privateGet(this, _rt).clear();
    for (const e2 of t2) if (!e2.isEmpty()) {
      __privateGet(this, _rt).add(e2);
      e2.select();
    }
    __privateMethod(this, _AnnotationEditorUIManager_instances, xt_fn).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  };
  __publicField(_AnnotationEditorUIManager, "TRANSLATE_SMALL", 1);
  __publicField(_AnnotationEditorUIManager, "TRANSLATE_BIG", 10);
  let AnnotationEditorUIManager = _AnnotationEditorUIManager;
  const _AltText = class _AltText {
    constructor(t2) {
      __privateAdd(this, _AltText_instances);
      __privateAdd(this, _o2, null);
      __privateAdd(this, _Ot, false);
      __privateAdd(this, _Nt, null);
      __privateAdd(this, _Bt, null);
      __privateAdd(this, _Ht, null);
      __privateAdd(this, _Ut, null);
      __privateAdd(this, _zt, false);
      __privateAdd(this, _jt, null);
      __privateAdd(this, _r2, null);
      __privateAdd(this, _Wt, null);
      __privateAdd(this, _Gt, null);
      __privateAdd(this, _Vt, false);
      __privateSet(this, _r2, t2);
      __privateSet(this, _Vt, t2._uiManager.useNewAltTextFlow);
      __privateGet(_AltText, _$t) || __privateSet(_AltText, _$t, Object.freeze({
        added: "pdfjs-editor-new-alt-text-added-button",
        "added-label": "pdfjs-editor-new-alt-text-added-button-label",
        missing: "pdfjs-editor-new-alt-text-missing-button",
        "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
        review: "pdfjs-editor-new-alt-text-to-review-button",
        "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
      }));
    }
    static initialize(t2) {
      _AltText._l10n ?? (_AltText._l10n = t2);
    }
    async render() {
      const t2 = __privateSet(this, _Nt, document.createElement("button"));
      t2.className = "altText";
      t2.tabIndex = "0";
      const e2 = __privateSet(this, _Bt, document.createElement("span"));
      t2.append(e2);
      if (__privateGet(this, _Vt)) {
        t2.classList.add("new");
        t2.setAttribute("data-l10n-id", __privateGet(_AltText, _$t).missing);
        e2.setAttribute("data-l10n-id", __privateGet(_AltText, _$t)["missing-label"]);
      } else {
        t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
        e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
      }
      const i2 = __privateGet(this, _r2)._uiManager._signal;
      t2.addEventListener("contextmenu", noContextMenu, {
        signal: i2
      });
      t2.addEventListener("pointerdown", (t3) => t3.stopPropagation(), {
        signal: i2
      });
      const onClick = (t3) => {
        t3.preventDefault();
        __privateGet(this, _r2)._uiManager.editAltText(__privateGet(this, _r2));
        __privateGet(this, _Vt) && __privateGet(this, _r2)._reportTelemetry({
          action: "pdfjs.image.alt_text.image_status_label_clicked",
          data: {
            label: __privateGet(this, _AltText_instances, qt_get)
          }
        });
      };
      t2.addEventListener("click", onClick, {
        capture: true,
        signal: i2
      });
      t2.addEventListener("keydown", (e3) => {
        if (e3.target === t2 && "Enter" === e3.key) {
          __privateSet(this, _zt, true);
          onClick(e3);
        }
      }, {
        signal: i2
      });
      await __privateMethod(this, _AltText_instances, Xt_fn).call(this);
      return t2;
    }
    finish() {
      if (__privateGet(this, _Nt)) {
        __privateGet(this, _Nt).focus({
          focusVisible: __privateGet(this, _zt)
        });
        __privateSet(this, _zt, false);
      }
    }
    isEmpty() {
      return __privateGet(this, _Vt) ? null === __privateGet(this, _o2) : !__privateGet(this, _o2) && !__privateGet(this, _Ot);
    }
    hasData() {
      return __privateGet(this, _Vt) ? null !== __privateGet(this, _o2) || !!__privateGet(this, _Wt) : this.isEmpty();
    }
    get guessedText() {
      return __privateGet(this, _Wt);
    }
    async setGuessedText(t2) {
      if (null === __privateGet(this, _o2)) {
        __privateSet(this, _Wt, t2);
        __privateSet(this, _Gt, await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
          generatedAltText: t2
        }));
        __privateMethod(this, _AltText_instances, Xt_fn).call(this);
      }
    }
    toggleAltTextBadge(t2 = false) {
      var _a4;
      if (__privateGet(this, _Vt) && !__privateGet(this, _o2)) {
        if (!__privateGet(this, _jt)) {
          const t3 = __privateSet(this, _jt, document.createElement("div"));
          t3.className = "noAltTextBadge";
          __privateGet(this, _r2).div.append(t3);
        }
        __privateGet(this, _jt).classList.toggle("hidden", !t2);
      } else {
        (_a4 = __privateGet(this, _jt)) == null ? void 0 : _a4.remove();
        __privateSet(this, _jt, null);
      }
    }
    serialize(t2) {
      let e2 = __privateGet(this, _o2);
      t2 || __privateGet(this, _Wt) !== e2 || (e2 = __privateGet(this, _Gt));
      return {
        altText: e2,
        decorative: __privateGet(this, _Ot),
        guessedText: __privateGet(this, _Wt),
        textWithDisclaimer: __privateGet(this, _Gt)
      };
    }
    get data() {
      return {
        altText: __privateGet(this, _o2),
        decorative: __privateGet(this, _Ot)
      };
    }
    set data({ altText: t2, decorative: e2, guessedText: i2, textWithDisclaimer: s2, cancel: n2 = false }) {
      if (i2) {
        __privateSet(this, _Wt, i2);
        __privateSet(this, _Gt, s2);
      }
      if (__privateGet(this, _o2) !== t2 || __privateGet(this, _Ot) !== e2) {
        if (!n2) {
          __privateSet(this, _o2, t2);
          __privateSet(this, _Ot, e2);
        }
        __privateMethod(this, _AltText_instances, Xt_fn).call(this);
      }
    }
    toggle(t2 = false) {
      if (__privateGet(this, _Nt)) {
        if (!t2 && __privateGet(this, _Ut)) {
          clearTimeout(__privateGet(this, _Ut));
          __privateSet(this, _Ut, null);
        }
        __privateGet(this, _Nt).disabled = !t2;
      }
    }
    shown() {
      __privateGet(this, _r2)._reportTelemetry({
        action: "pdfjs.image.alt_text.image_status_label_displayed",
        data: {
          label: __privateGet(this, _AltText_instances, qt_get)
        }
      });
    }
    destroy() {
      var _a4, _b2;
      (_a4 = __privateGet(this, _Nt)) == null ? void 0 : _a4.remove();
      __privateSet(this, _Nt, null);
      __privateSet(this, _Bt, null);
      __privateSet(this, _Ht, null);
      (_b2 = __privateGet(this, _jt)) == null ? void 0 : _b2.remove();
      __privateSet(this, _jt, null);
    }
  };
  _o2 = new WeakMap();
  _Ot = new WeakMap();
  _Nt = new WeakMap();
  _Bt = new WeakMap();
  _Ht = new WeakMap();
  _Ut = new WeakMap();
  _zt = new WeakMap();
  _jt = new WeakMap();
  _r2 = new WeakMap();
  _Wt = new WeakMap();
  _Gt = new WeakMap();
  _Vt = new WeakMap();
  _$t = new WeakMap();
  _AltText_instances = new WeakSet();
  qt_get = function() {
    return (__privateGet(this, _o2) ? "added" : null === __privateGet(this, _o2) && this.guessedText && "review") || "missing";
  };
  Xt_fn = async function() {
    var _a4, _b2, _c;
    const t2 = __privateGet(this, _Nt);
    if (!t2) return;
    if (__privateGet(this, _Vt)) {
      t2.classList.toggle("done", !!__privateGet(this, _o2));
      t2.setAttribute("data-l10n-id", __privateGet(_AltText, _$t)[__privateGet(this, _AltText_instances, qt_get)]);
      (_a4 = __privateGet(this, _Bt)) == null ? void 0 : _a4.setAttribute("data-l10n-id", __privateGet(_AltText, _$t)[`${__privateGet(this, _AltText_instances, qt_get)}-label`]);
      if (!__privateGet(this, _o2)) {
        (_b2 = __privateGet(this, _Ht)) == null ? void 0 : _b2.remove();
        return;
      }
    } else {
      if (!__privateGet(this, _o2) && !__privateGet(this, _Ot)) {
        t2.classList.remove("done");
        (_c = __privateGet(this, _Ht)) == null ? void 0 : _c.remove();
        return;
      }
      t2.classList.add("done");
      t2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
    }
    let e2 = __privateGet(this, _Ht);
    if (!e2) {
      __privateSet(this, _Ht, e2 = document.createElement("span"));
      e2.className = "tooltip";
      e2.setAttribute("role", "tooltip");
      e2.id = `alt-text-tooltip-${__privateGet(this, _r2).id}`;
      const i3 = 100, s2 = __privateGet(this, _r2)._uiManager._signal;
      s2.addEventListener("abort", () => {
        clearTimeout(__privateGet(this, _Ut));
        __privateSet(this, _Ut, null);
      }, {
        once: true
      });
      t2.addEventListener("mouseenter", () => {
        __privateSet(this, _Ut, setTimeout(() => {
          __privateSet(this, _Ut, null);
          __privateGet(this, _Ht).classList.add("show");
          __privateGet(this, _r2)._reportTelemetry({
            action: "alt_text_tooltip"
          });
        }, i3));
      }, {
        signal: s2
      });
      t2.addEventListener("mouseleave", () => {
        var _a5;
        if (__privateGet(this, _Ut)) {
          clearTimeout(__privateGet(this, _Ut));
          __privateSet(this, _Ut, null);
        }
        (_a5 = __privateGet(this, _Ht)) == null ? void 0 : _a5.classList.remove("show");
      }, {
        signal: s2
      });
    }
    if (__privateGet(this, _Ot)) e2.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
    else {
      e2.removeAttribute("data-l10n-id");
      e2.textContent = __privateGet(this, _o2);
    }
    e2.parentNode || t2.append(e2);
    const i2 = __privateGet(this, _r2).getImageForAltText();
    i2 == null ? void 0 : i2.setAttribute("aria-describedby", e2.id);
  };
  __privateAdd(_AltText, _$t, null);
  __publicField(_AltText, "_l10n", null);
  let AltText = _AltText;
  const _AnnotationEditor = class _AnnotationEditor {
    constructor(t2) {
      __privateAdd(this, _AnnotationEditor_instances);
      __privateAdd(this, _Kt, null);
      __privateAdd(this, _Yt, null);
      __privateAdd(this, _o3, null);
      __privateAdd(this, _Qt, false);
      __privateAdd(this, _Jt, false);
      __privateAdd(this, _Zt, null);
      __privateAdd(this, _te, null);
      __privateAdd(this, _ee, null);
      __privateAdd(this, _ie, "");
      __privateAdd(this, _se, false);
      __privateAdd(this, _ne, null);
      __privateAdd(this, _re, false);
      __privateAdd(this, _ae, false);
      __privateAdd(this, _oe, false);
      __privateAdd(this, _le, null);
      __privateAdd(this, _he, 0);
      __privateAdd(this, _ce, 0);
      __privateAdd(this, _de, null);
      __publicField(this, "_editToolbar", null);
      __publicField(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
      __publicField(this, "_initialData", null);
      __publicField(this, "_isVisible", true);
      __publicField(this, "_uiManager", null);
      __publicField(this, "_focusEventsAllowed", true);
      __privateAdd(this, _ue, false);
      __privateAdd(this, _pe, _AnnotationEditor._zIndex++);
      this.parent = t2.parent;
      this.id = t2.id;
      this.width = this.height = null;
      this.pageIndex = t2.parent.pageIndex;
      this.name = t2.name;
      this.div = null;
      this._uiManager = t2.uiManager;
      this.annotationElementId = null;
      this._willKeepAspectRatio = false;
      this._initialOptions.isCentered = t2.isCentered;
      this._structTreeParentId = null;
      const { rotation: e2, rawDims: { pageWidth: i2, pageHeight: s2, pageX: n2, pageY: r2 } } = this.parent.viewport;
      this.rotation = e2;
      this.pageRotation = (360 + e2 - this._uiManager.viewParameters.rotation) % 360;
      this.pageDimensions = [
        i2,
        s2
      ];
      this.pageTranslation = [
        n2,
        r2
      ];
      const [a2, o2] = this.parentDimensions;
      this.x = t2.x / a2;
      this.y = t2.y / o2;
      this.isAttachedToDOM = false;
      this.deleted = false;
    }
    static get _resizerKeyboardManager() {
      const t2 = _AnnotationEditor.prototype._resizeWithKeyboard, e2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
      return shadow(this, "_resizerKeyboardManager", new KeyboardManager([
        [
          [
            "ArrowLeft",
            "mac+ArrowLeft"
          ],
          t2,
          {
            args: [
              -e2,
              0
            ]
          }
        ],
        [
          [
            "ctrl+ArrowLeft",
            "mac+shift+ArrowLeft"
          ],
          t2,
          {
            args: [
              -i2,
              0
            ]
          }
        ],
        [
          [
            "ArrowRight",
            "mac+ArrowRight"
          ],
          t2,
          {
            args: [
              e2,
              0
            ]
          }
        ],
        [
          [
            "ctrl+ArrowRight",
            "mac+shift+ArrowRight"
          ],
          t2,
          {
            args: [
              i2,
              0
            ]
          }
        ],
        [
          [
            "ArrowUp",
            "mac+ArrowUp"
          ],
          t2,
          {
            args: [
              0,
              -e2
            ]
          }
        ],
        [
          [
            "ctrl+ArrowUp",
            "mac+shift+ArrowUp"
          ],
          t2,
          {
            args: [
              0,
              -i2
            ]
          }
        ],
        [
          [
            "ArrowDown",
            "mac+ArrowDown"
          ],
          t2,
          {
            args: [
              0,
              e2
            ]
          }
        ],
        [
          [
            "ctrl+ArrowDown",
            "mac+shift+ArrowDown"
          ],
          t2,
          {
            args: [
              0,
              i2
            ]
          }
        ],
        [
          [
            "Escape",
            "mac+Escape"
          ],
          _AnnotationEditor.prototype._stopResizingWithKeyboard
        ]
      ]));
    }
    get editorType() {
      return Object.getPrototypeOf(this).constructor._type;
    }
    static get _defaultLineColor() {
      return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
    }
    static deleteAnnotationElement(t2) {
      const e2 = new FakeEditor({
        id: t2.parent.getNextId(),
        parent: t2.parent,
        uiManager: t2._uiManager
      });
      e2.annotationElementId = t2.annotationElementId;
      e2.deleted = true;
      e2._uiManager.addToAnnotationStorage(e2);
    }
    static initialize(t2, e2) {
      _AnnotationEditor._l10n ?? (_AnnotationEditor._l10n = t2);
      _AnnotationEditor._l10nResizer || (_AnnotationEditor._l10nResizer = Object.freeze({
        topLeft: "pdfjs-editor-resizer-top-left",
        topMiddle: "pdfjs-editor-resizer-top-middle",
        topRight: "pdfjs-editor-resizer-top-right",
        middleRight: "pdfjs-editor-resizer-middle-right",
        bottomRight: "pdfjs-editor-resizer-bottom-right",
        bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
        bottomLeft: "pdfjs-editor-resizer-bottom-left",
        middleLeft: "pdfjs-editor-resizer-middle-left"
      }));
      if (-1 !== _AnnotationEditor._borderLineWidth) return;
      const i2 = getComputedStyle(document.documentElement);
      _AnnotationEditor._borderLineWidth = parseFloat(i2.getPropertyValue("--outline-width")) || 0;
    }
    static updateDefaultParams(t2, e2) {
    }
    static get defaultPropertiesToUpdate() {
      return [];
    }
    static isHandlingMimeForPasting(t2) {
      return false;
    }
    static paste(t2, e2) {
      unreachable("Not implemented");
    }
    get propertiesToUpdate() {
      return [];
    }
    get _isDraggable() {
      return __privateGet(this, _ue);
    }
    set _isDraggable(t2) {
      var _a4;
      __privateSet(this, _ue, t2);
      (_a4 = this.div) == null ? void 0 : _a4.classList.toggle("draggable", t2);
    }
    get isEnterHandled() {
      return true;
    }
    center() {
      const [t2, e2] = this.pageDimensions;
      switch (this.parentRotation) {
        case 90:
          this.x -= this.height * e2 / (2 * t2);
          this.y += this.width * t2 / (2 * e2);
          break;
        case 180:
          this.x += this.width / 2;
          this.y += this.height / 2;
          break;
        case 270:
          this.x += this.height * e2 / (2 * t2);
          this.y -= this.width * t2 / (2 * e2);
          break;
        default:
          this.x -= this.width / 2;
          this.y -= this.height / 2;
      }
      this.fixAndSetPosition();
    }
    addCommands(t2) {
      this._uiManager.addCommands(t2);
    }
    get currentLayer() {
      return this._uiManager.currentLayer;
    }
    setInBackground() {
      this.div.style.zIndex = 0;
    }
    setInForeground() {
      this.div.style.zIndex = __privateGet(this, _pe);
    }
    setParent(t2) {
      if (null !== t2) {
        this.pageIndex = t2.pageIndex;
        this.pageDimensions = t2.pageDimensions;
      } else __privateMethod(this, _AnnotationEditor_instances, ge_fn).call(this);
      this.parent = t2;
    }
    focusin(t2) {
      this._focusEventsAllowed && (__privateGet(this, _se) ? __privateSet(this, _se, false) : this.parent.setSelected(this));
    }
    focusout(t2) {
      var _a4;
      if (!this._focusEventsAllowed) return;
      if (!this.isAttachedToDOM) return;
      const e2 = t2.relatedTarget;
      if (!(e2 == null ? void 0 : e2.closest(`#${this.id}`))) {
        t2.preventDefault();
        ((_a4 = this.parent) == null ? void 0 : _a4.isMultipleSelection) || this.commitOrRemove();
      }
    }
    commitOrRemove() {
      this.isEmpty() ? this.remove() : this.commit();
    }
    commit() {
      this.addToAnnotationStorage();
    }
    addToAnnotationStorage() {
      this._uiManager.addToAnnotationStorage(this);
    }
    setAt(t2, e2, i2, s2) {
      const [n2, r2] = this.parentDimensions;
      [i2, s2] = this.screenToPageTranslation(i2, s2);
      this.x = (t2 + i2) / n2;
      this.y = (e2 + s2) / r2;
      this.fixAndSetPosition();
    }
    translate(t2, e2) {
      __privateMethod(this, _AnnotationEditor_instances, fe_fn).call(this, this.parentDimensions, t2, e2);
    }
    translateInPage(t2, e2) {
      __privateGet(this, _ne) || __privateSet(this, _ne, [
        this.x,
        this.y
      ]);
      __privateMethod(this, _AnnotationEditor_instances, fe_fn).call(this, this.pageDimensions, t2, e2);
      this.div.scrollIntoView({
        block: "nearest"
      });
    }
    drag(t2, e2) {
      __privateGet(this, _ne) || __privateSet(this, _ne, [
        this.x,
        this.y
      ]);
      const [i2, s2] = this.parentDimensions;
      this.x += t2 / i2;
      this.y += e2 / s2;
      if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
        const { x: t3, y: e3 } = this.div.getBoundingClientRect();
        if (this.parent.findNewParent(this, t3, e3)) {
          this.x -= Math.floor(this.x);
          this.y -= Math.floor(this.y);
        }
      }
      let { x: n2, y: r2 } = this;
      const [a2, o2] = this.getBaseTranslation();
      n2 += a2;
      r2 += o2;
      this.div.style.left = `${(100 * n2).toFixed(2)}%`;
      this.div.style.top = `${(100 * r2).toFixed(2)}%`;
      this.div.scrollIntoView({
        block: "nearest"
      });
    }
    get _hasBeenMoved() {
      return !!__privateGet(this, _ne) && (__privateGet(this, _ne)[0] !== this.x || __privateGet(this, _ne)[1] !== this.y);
    }
    getBaseTranslation() {
      const [t2, e2] = this.parentDimensions, { _borderLineWidth: i2 } = _AnnotationEditor, s2 = i2 / t2, n2 = i2 / e2;
      switch (this.rotation) {
        case 90:
          return [
            -s2,
            n2
          ];
        case 180:
          return [
            s2,
            n2
          ];
        case 270:
          return [
            s2,
            -n2
          ];
        default:
          return [
            -s2,
            -n2
          ];
      }
    }
    get _mustFixPosition() {
      return true;
    }
    fixAndSetPosition(t2 = this.rotation) {
      const [e2, i2] = this.pageDimensions;
      let { x: s2, y: n2, width: r2, height: a2 } = this;
      r2 *= e2;
      a2 *= i2;
      s2 *= e2;
      n2 *= i2;
      if (this._mustFixPosition) switch (t2) {
        case 0:
          s2 = Math.max(0, Math.min(e2 - r2, s2));
          n2 = Math.max(0, Math.min(i2 - a2, n2));
          break;
        case 90:
          s2 = Math.max(0, Math.min(e2 - a2, s2));
          n2 = Math.min(i2, Math.max(r2, n2));
          break;
        case 180:
          s2 = Math.min(e2, Math.max(r2, s2));
          n2 = Math.min(i2, Math.max(a2, n2));
          break;
        case 270:
          s2 = Math.min(e2, Math.max(a2, s2));
          n2 = Math.max(0, Math.min(i2 - r2, n2));
      }
      this.x = s2 /= e2;
      this.y = n2 /= i2;
      const [o2, l2] = this.getBaseTranslation();
      s2 += o2;
      n2 += l2;
      const { style: h2 } = this.div;
      h2.left = `${(100 * s2).toFixed(2)}%`;
      h2.top = `${(100 * n2).toFixed(2)}%`;
      this.moveInDOM();
    }
    screenToPageTranslation(t2, e2) {
      var _a4;
      return __privateMethod(_a4 = _AnnotationEditor, _AnnotationEditor_static, me_fn).call(_a4, t2, e2, this.parentRotation);
    }
    pageTranslationToScreen(t2, e2) {
      var _a4;
      return __privateMethod(_a4 = _AnnotationEditor, _AnnotationEditor_static, me_fn).call(_a4, t2, e2, 360 - this.parentRotation);
    }
    get parentScale() {
      return this._uiManager.viewParameters.realScale;
    }
    get parentRotation() {
      return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
    }
    get parentDimensions() {
      const { parentScale: t2, pageDimensions: [e2, i2] } = this;
      return [
        e2 * t2,
        i2 * t2
      ];
    }
    setDims(t2, e2) {
      const [i2, s2] = this.parentDimensions;
      this.div.style.width = `${(100 * t2 / i2).toFixed(2)}%`;
      __privateGet(this, _Jt) || (this.div.style.height = `${(100 * e2 / s2).toFixed(2)}%`);
    }
    fixDims() {
      const { style: t2 } = this.div, { height: e2, width: i2 } = t2, s2 = i2.endsWith("%"), n2 = !__privateGet(this, _Jt) && e2.endsWith("%");
      if (s2 && n2) return;
      const [r2, a2] = this.parentDimensions;
      s2 || (t2.width = `${(100 * parseFloat(i2) / r2).toFixed(2)}%`);
      __privateGet(this, _Jt) || n2 || (t2.height = `${(100 * parseFloat(e2) / a2).toFixed(2)}%`);
    }
    getInitialTranslation() {
      return [
        0,
        0
      ];
    }
    altTextFinish() {
      var _a4;
      (_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.finish();
    }
    async addEditToolbar() {
      if (this._editToolbar || __privateGet(this, _ae)) return this._editToolbar;
      this._editToolbar = new EditorToolbar(this);
      this.div.append(this._editToolbar.render());
      __privateGet(this, _o3) && await this._editToolbar.addAltText(__privateGet(this, _o3));
      return this._editToolbar;
    }
    removeEditToolbar() {
      var _a4;
      if (this._editToolbar) {
        this._editToolbar.remove();
        this._editToolbar = null;
        (_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.destroy();
      }
    }
    addContainer(t2) {
      var _a4;
      const e2 = (_a4 = this._editToolbar) == null ? void 0 : _a4.div;
      e2 ? e2.before(t2) : this.div.append(t2);
    }
    getClientDimensions() {
      return this.div.getBoundingClientRect();
    }
    async addAltTextButton() {
      if (!__privateGet(this, _o3)) {
        AltText.initialize(_AnnotationEditor._l10n);
        __privateSet(this, _o3, new AltText(this));
        if (__privateGet(this, _Kt)) {
          __privateGet(this, _o3).data = __privateGet(this, _Kt);
          __privateSet(this, _Kt, null);
        }
        await this.addEditToolbar();
      }
    }
    get altTextData() {
      var _a4;
      return (_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.data;
    }
    set altTextData(t2) {
      __privateGet(this, _o3) && (__privateGet(this, _o3).data = t2);
    }
    get guessedAltText() {
      var _a4;
      return (_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.guessedText;
    }
    async setGuessedAltText(t2) {
      var _a4;
      await ((_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.setGuessedText(t2));
    }
    serializeAltText(t2) {
      var _a4;
      return (_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.serialize(t2);
    }
    hasAltText() {
      return !!__privateGet(this, _o3) && !__privateGet(this, _o3).isEmpty();
    }
    hasAltTextData() {
      var _a4;
      return ((_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.hasData()) ?? false;
    }
    render() {
      this.div = document.createElement("div");
      this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
      this.div.className = this.name;
      this.div.setAttribute("id", this.id);
      this.div.tabIndex = __privateGet(this, _Qt) ? -1 : 0;
      this._isVisible || this.div.classList.add("hidden");
      this.setInForeground();
      __privateMethod(this, _AnnotationEditor_instances, xe_fn).call(this);
      const [t2, e2] = this.parentDimensions;
      if (this.parentRotation % 180 != 0) {
        this.div.style.maxWidth = `${(100 * e2 / t2).toFixed(2)}%`;
        this.div.style.maxHeight = `${(100 * t2 / e2).toFixed(2)}%`;
      }
      const [i2, s2] = this.getInitialTranslation();
      this.translate(i2, s2);
      bindEvents(this, this.div, [
        "pointerdown"
      ]);
      return this.div;
    }
    pointerdown(t2) {
      const { isMac: e2 } = util_FeatureTest.platform;
      if (0 !== t2.button || t2.ctrlKey && e2) t2.preventDefault();
      else {
        __privateSet(this, _se, true);
        this._isDraggable ? __privateMethod(this, _AnnotationEditor_instances, _e_fn).call(this, t2) : __privateMethod(this, _AnnotationEditor_instances, Ee_fn).call(this, t2);
      }
    }
    get isSelected() {
      return this._uiManager.isSelected(this);
    }
    moveInDOM() {
      __privateGet(this, _le) && clearTimeout(__privateGet(this, _le));
      __privateSet(this, _le, setTimeout(() => {
        var _a4;
        __privateSet(this, _le, null);
        (_a4 = this.parent) == null ? void 0 : _a4.moveEditorInDOM(this);
      }, 0));
    }
    _setParentAndPosition(t2, e2, i2) {
      t2.changeParent(this);
      this.x = e2;
      this.y = i2;
      this.fixAndSetPosition();
    }
    getRect(t2, e2, i2 = this.rotation) {
      const s2 = this.parentScale, [n2, r2] = this.pageDimensions, [a2, o2] = this.pageTranslation, l2 = t2 / s2, h2 = e2 / s2, c2 = this.x * n2, d2 = this.y * r2, u2 = this.width * n2, p2 = this.height * r2;
      switch (i2) {
        case 0:
          return [
            c2 + l2 + a2,
            r2 - d2 - h2 - p2 + o2,
            c2 + l2 + u2 + a2,
            r2 - d2 - h2 + o2
          ];
        case 90:
          return [
            c2 + h2 + a2,
            r2 - d2 + l2 + o2,
            c2 + h2 + p2 + a2,
            r2 - d2 + l2 + u2 + o2
          ];
        case 180:
          return [
            c2 - l2 - u2 + a2,
            r2 - d2 + h2 + o2,
            c2 - l2 + a2,
            r2 - d2 + h2 + p2 + o2
          ];
        case 270:
          return [
            c2 - h2 - p2 + a2,
            r2 - d2 - l2 - u2 + o2,
            c2 - h2 + a2,
            r2 - d2 - l2 + o2
          ];
        default:
          throw new Error("Invalid rotation");
      }
    }
    getRectInCurrentCoords(t2, e2) {
      const [i2, s2, n2, r2] = t2, a2 = n2 - i2, o2 = r2 - s2;
      switch (this.rotation) {
        case 0:
          return [
            i2,
            e2 - r2,
            a2,
            o2
          ];
        case 90:
          return [
            i2,
            e2 - s2,
            o2,
            a2
          ];
        case 180:
          return [
            n2,
            e2 - s2,
            a2,
            o2
          ];
        case 270:
          return [
            n2,
            e2 - r2,
            o2,
            a2
          ];
        default:
          throw new Error("Invalid rotation");
      }
    }
    onceAdded() {
    }
    isEmpty() {
      return false;
    }
    enableEditMode() {
      __privateSet(this, _ae, true);
    }
    disableEditMode() {
      __privateSet(this, _ae, false);
    }
    isInEditMode() {
      return __privateGet(this, _ae);
    }
    shouldGetKeyboardEvents() {
      return __privateGet(this, _oe);
    }
    needsToBeRebuilt() {
      return this.div && !this.isAttachedToDOM;
    }
    rebuild() {
      __privateMethod(this, _AnnotationEditor_instances, xe_fn).call(this);
    }
    rotate(t2) {
    }
    serializeDeleted() {
      var _a4;
      return {
        id: this.annotationElementId,
        deleted: true,
        pageIndex: this.pageIndex,
        popupRef: ((_a4 = this._initialData) == null ? void 0 : _a4.popupRef) || ""
      };
    }
    serialize(t2 = false, e2 = null) {
      unreachable("An editor must be serializable");
    }
    static async deserialize(t2, e2, i2) {
      const s2 = new this.prototype.constructor({
        parent: e2,
        id: e2.getNextId(),
        uiManager: i2
      });
      s2.rotation = t2.rotation;
      __privateSet(s2, _Kt, t2.accessibilityData);
      const [n2, r2] = s2.pageDimensions, [a2, o2, l2, h2] = s2.getRectInCurrentCoords(t2.rect, r2);
      s2.x = a2 / n2;
      s2.y = o2 / r2;
      s2.width = l2 / n2;
      s2.height = h2 / r2;
      return s2;
    }
    get hasBeenModified() {
      return !!this.annotationElementId && (this.deleted || null !== this.serialize());
    }
    remove() {
      var _a4;
      (_a4 = __privateGet(this, _ee)) == null ? void 0 : _a4.abort();
      __privateSet(this, _ee, null);
      this.isEmpty() || this.commit();
      this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this);
      if (__privateGet(this, _le)) {
        clearTimeout(__privateGet(this, _le));
        __privateSet(this, _le, null);
      }
      __privateMethod(this, _AnnotationEditor_instances, ge_fn).call(this);
      this.removeEditToolbar();
      if (__privateGet(this, _de)) {
        for (const t2 of __privateGet(this, _de).values()) clearTimeout(t2);
        __privateSet(this, _de, null);
      }
      this.parent = null;
    }
    get isResizable() {
      return false;
    }
    makeResizable() {
      if (this.isResizable) {
        __privateMethod(this, _AnnotationEditor_instances, ve_fn).call(this);
        __privateGet(this, _Zt).classList.remove("hidden");
        bindEvents(this, this.div, [
          "keydown"
        ]);
      }
    }
    get toolbarPosition() {
      return null;
    }
    keydown(t2) {
      if (!this.isResizable || t2.target !== this.div || "Enter" !== t2.key) return;
      this._uiManager.setSelected(this);
      __privateSet(this, _te, {
        savedX: this.x,
        savedY: this.y,
        savedWidth: this.width,
        savedHeight: this.height
      });
      const e2 = __privateGet(this, _Zt).children;
      if (!__privateGet(this, _Yt)) {
        __privateSet(this, _Yt, Array.from(e2));
        const t3 = __privateMethod(this, _AnnotationEditor_instances, Ce_fn).bind(this), i3 = __privateMethod(this, _AnnotationEditor_instances, Se_fn).bind(this), s3 = this._uiManager._signal;
        for (const e3 of __privateGet(this, _Yt)) {
          const n3 = e3.getAttribute("data-resizer-name");
          e3.setAttribute("role", "spinbutton");
          e3.addEventListener("keydown", t3, {
            signal: s3
          });
          e3.addEventListener("blur", i3, {
            signal: s3
          });
          e3.addEventListener("focus", __privateMethod(this, _AnnotationEditor_instances, Te_fn).bind(this, n3), {
            signal: s3
          });
          e3.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[n3]);
        }
      }
      const i2 = __privateGet(this, _Yt)[0];
      let s2 = 0;
      for (const t3 of e2) {
        if (t3 === i2) break;
        s2++;
      }
      const n2 = (360 - this.rotation + this.parentRotation) % 360 / 90 * (__privateGet(this, _Yt).length / 4);
      if (n2 !== s2) {
        if (n2 < s2) for (let t4 = 0; t4 < s2 - n2; t4++) __privateGet(this, _Zt).append(__privateGet(this, _Zt).firstChild);
        else if (n2 > s2) for (let t4 = 0; t4 < n2 - s2; t4++) __privateGet(this, _Zt).firstChild.before(__privateGet(this, _Zt).lastChild);
        let t3 = 0;
        for (const i3 of e2) {
          const e3 = __privateGet(this, _Yt)[t3++].getAttribute("data-resizer-name");
          i3.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[e3]);
        }
      }
      __privateMethod(this, _AnnotationEditor_instances, Me_fn).call(this, 0);
      __privateSet(this, _oe, true);
      __privateGet(this, _Zt).firstChild.focus({
        focusVisible: true
      });
      t2.preventDefault();
      t2.stopImmediatePropagation();
    }
    _resizeWithKeyboard(t2, e2) {
      __privateGet(this, _oe) && __privateMethod(this, _AnnotationEditor_instances, Ae_fn).call(this, __privateGet(this, _ie), {
        movementX: t2,
        movementY: e2
      });
    }
    _stopResizingWithKeyboard() {
      __privateMethod(this, _AnnotationEditor_instances, ge_fn).call(this);
      this.div.focus();
    }
    select() {
      var _a4, _b2, _c;
      this.makeResizable();
      (_a4 = this.div) == null ? void 0 : _a4.classList.add("selectedEditor");
      if (this._editToolbar) {
        (_b2 = this._editToolbar) == null ? void 0 : _b2.show();
        (_c = __privateGet(this, _o3)) == null ? void 0 : _c.toggleAltTextBadge(false);
      } else this.addEditToolbar().then(() => {
        var _a5, _b3;
        ((_a5 = this.div) == null ? void 0 : _a5.classList.contains("selectedEditor")) && ((_b3 = this._editToolbar) == null ? void 0 : _b3.show());
      });
    }
    unselect() {
      var _a4, _b2, _c, _d, _e2;
      (_a4 = __privateGet(this, _Zt)) == null ? void 0 : _a4.classList.add("hidden");
      (_b2 = this.div) == null ? void 0 : _b2.classList.remove("selectedEditor");
      ((_c = this.div) == null ? void 0 : _c.contains(document.activeElement)) && this._uiManager.currentLayer.div.focus({
        preventScroll: true
      });
      (_d = this._editToolbar) == null ? void 0 : _d.hide();
      (_e2 = __privateGet(this, _o3)) == null ? void 0 : _e2.toggleAltTextBadge(true);
    }
    updateParams(t2, e2) {
    }
    disableEditing() {
    }
    enableEditing() {
    }
    enterInEditMode() {
    }
    getImageForAltText() {
      return null;
    }
    get contentDiv() {
      return this.div;
    }
    get isEditing() {
      return __privateGet(this, _re);
    }
    set isEditing(t2) {
      __privateSet(this, _re, t2);
      if (this.parent) if (t2) {
        this.parent.setSelected(this);
        this.parent.setActiveEditor(this);
      } else this.parent.setActiveEditor(null);
    }
    setAspectRatio(t2, e2) {
      __privateSet(this, _Jt, true);
      const i2 = t2 / e2, { style: s2 } = this.div;
      s2.aspectRatio = i2;
      s2.height = "auto";
    }
    static get MIN_SIZE() {
      return 16;
    }
    static canCreateNewEmptyEditor() {
      return true;
    }
    get telemetryInitialData() {
      return {
        action: "added"
      };
    }
    get telemetryFinalData() {
      return null;
    }
    _reportTelemetry(t2, e2 = false) {
      if (e2) {
        __privateGet(this, _de) || __privateSet(this, _de, /* @__PURE__ */ new Map());
        const { action: e3 } = t2;
        let i2 = __privateGet(this, _de).get(e3);
        i2 && clearTimeout(i2);
        i2 = setTimeout(() => {
          this._reportTelemetry(t2);
          __privateGet(this, _de).delete(e3);
          0 === __privateGet(this, _de).size && __privateSet(this, _de, null);
        }, _AnnotationEditor._telemetryTimeout);
        __privateGet(this, _de).set(e3, i2);
      } else {
        t2.type || (t2.type = this.editorType);
        this._uiManager._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data: t2
          }
        });
      }
    }
    show(t2 = this._isVisible) {
      this.div.classList.toggle("hidden", !t2);
      this._isVisible = t2;
    }
    enable() {
      this.div && (this.div.tabIndex = 0);
      __privateSet(this, _Qt, false);
    }
    disable() {
      this.div && (this.div.tabIndex = -1);
      __privateSet(this, _Qt, true);
    }
    renderAnnotationElement(t2) {
      let e2 = t2.container.querySelector(".annotationContent");
      if (e2) {
        if ("CANVAS" === e2.nodeName) {
          const t3 = e2;
          e2 = document.createElement("div");
          e2.classList.add("annotationContent", this.editorType);
          t3.before(e2);
        }
      } else {
        e2 = document.createElement("div");
        e2.classList.add("annotationContent", this.editorType);
        t2.container.prepend(e2);
      }
      return e2;
    }
    resetAnnotationElement(t2) {
      const { firstChild: e2 } = t2.container;
      "DIV" === (e2 == null ? void 0 : e2.nodeName) && e2.classList.contains("annotationContent") && e2.remove();
    }
  };
  _Kt = new WeakMap();
  _Yt = new WeakMap();
  _o3 = new WeakMap();
  _Qt = new WeakMap();
  _Jt = new WeakMap();
  _Zt = new WeakMap();
  _te = new WeakMap();
  _ee = new WeakMap();
  _ie = new WeakMap();
  _se = new WeakMap();
  _ne = new WeakMap();
  _re = new WeakMap();
  _ae = new WeakMap();
  _oe = new WeakMap();
  _le = new WeakMap();
  _he = new WeakMap();
  _ce = new WeakMap();
  _de = new WeakMap();
  _ue = new WeakMap();
  _pe = new WeakMap();
  _AnnotationEditor_instances = new WeakSet();
  fe_fn = function([t2, e2], i2, s2) {
    [i2, s2] = this.screenToPageTranslation(i2, s2);
    this.x += i2 / t2;
    this.y += s2 / e2;
    this.fixAndSetPosition();
  };
  _AnnotationEditor_static = new WeakSet();
  me_fn = function(t2, e2, i2) {
    switch (i2) {
      case 90:
        return [
          e2,
          -t2
        ];
      case 180:
        return [
          -t2,
          -e2
        ];
      case 270:
        return [
          -e2,
          t2
        ];
      default:
        return [
          t2,
          e2
        ];
    }
  };
  be_fn = function(t2) {
    switch (t2) {
      case 90: {
        const [t3, e2] = this.pageDimensions;
        return [
          0,
          -t3 / e2,
          e2 / t3,
          0
        ];
      }
      case 180:
        return [
          -1,
          0,
          0,
          -1
        ];
      case 270: {
        const [t3, e2] = this.pageDimensions;
        return [
          0,
          t3 / e2,
          -e2 / t3,
          0
        ];
      }
      default:
        return [
          1,
          0,
          0,
          1
        ];
    }
  };
  ve_fn = function() {
    if (__privateGet(this, _Zt)) return;
    __privateSet(this, _Zt, document.createElement("div"));
    __privateGet(this, _Zt).classList.add("resizers");
    const t2 = this._willKeepAspectRatio ? [
      "topLeft",
      "topRight",
      "bottomRight",
      "bottomLeft"
    ] : [
      "topLeft",
      "topMiddle",
      "topRight",
      "middleRight",
      "bottomRight",
      "bottomMiddle",
      "bottomLeft",
      "middleLeft"
    ], e2 = this._uiManager._signal;
    for (const i2 of t2) {
      const t3 = document.createElement("div");
      __privateGet(this, _Zt).append(t3);
      t3.classList.add("resizer", i2);
      t3.setAttribute("data-resizer-name", i2);
      t3.addEventListener("pointerdown", __privateMethod(this, _AnnotationEditor_instances, ye_fn).bind(this, i2), {
        signal: e2
      });
      t3.addEventListener("contextmenu", noContextMenu, {
        signal: e2
      });
      t3.tabIndex = -1;
    }
    this.div.prepend(__privateGet(this, _Zt));
  };
  ye_fn = function(t2, e2) {
    var _a4;
    e2.preventDefault();
    const { isMac: i2 } = util_FeatureTest.platform;
    if (0 !== e2.button || e2.ctrlKey && i2) return;
    (_a4 = __privateGet(this, _o3)) == null ? void 0 : _a4.toggle(false);
    const s2 = this._isDraggable;
    this._isDraggable = false;
    const n2 = new AbortController(), r2 = this._uiManager.combinedSignal(n2);
    this.parent.togglePointerEvents(false);
    window.addEventListener("pointermove", __privateMethod(this, _AnnotationEditor_instances, Ae_fn).bind(this, t2), {
      passive: true,
      capture: true,
      signal: r2
    });
    window.addEventListener("contextmenu", noContextMenu, {
      signal: r2
    });
    const a2 = this.x, o2 = this.y, l2 = this.width, h2 = this.height, c2 = this.parent.div.style.cursor, d2 = this.div.style.cursor;
    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(e2.target).cursor;
    const pointerUpCallback = () => {
      var _a5;
      n2.abort();
      this.parent.togglePointerEvents(true);
      (_a5 = __privateGet(this, _o3)) == null ? void 0 : _a5.toggle(true);
      this._isDraggable = s2;
      this.parent.div.style.cursor = c2;
      this.div.style.cursor = d2;
      __privateMethod(this, _AnnotationEditor_instances, we_fn).call(this, a2, o2, l2, h2);
    };
    window.addEventListener("pointerup", pointerUpCallback, {
      signal: r2
    });
    window.addEventListener("blur", pointerUpCallback, {
      signal: r2
    });
  };
  we_fn = function(t2, e2, i2, s2) {
    const n2 = this.x, r2 = this.y, a2 = this.width, o2 = this.height;
    n2 === t2 && r2 === e2 && a2 === i2 && o2 === s2 || this.addCommands({
      cmd: () => {
        this.width = a2;
        this.height = o2;
        this.x = n2;
        this.y = r2;
        const [t3, e3] = this.parentDimensions;
        this.setDims(t3 * a2, e3 * o2);
        this.fixAndSetPosition();
      },
      undo: () => {
        this.width = i2;
        this.height = s2;
        this.x = t2;
        this.y = e2;
        const [n3, r3] = this.parentDimensions;
        this.setDims(n3 * i2, r3 * s2);
        this.fixAndSetPosition();
      },
      mustExec: true
    });
  };
  Ae_fn = function(t2, e2) {
    const [i2, s2] = this.parentDimensions, n2 = this.x, r2 = this.y, a2 = this.width, o2 = this.height, l2 = _AnnotationEditor.MIN_SIZE / i2, h2 = _AnnotationEditor.MIN_SIZE / s2, round = (t3) => Math.round(1e4 * t3) / 1e4, c2 = __privateMethod(this, _AnnotationEditor_instances, be_fn).call(this, this.rotation), transf = (t3, e3) => [
      c2[0] * t3 + c2[2] * e3,
      c2[1] * t3 + c2[3] * e3
    ], d2 = __privateMethod(this, _AnnotationEditor_instances, be_fn).call(this, 360 - this.rotation);
    let u2, p2, g2 = false, f2 = false;
    switch (t2) {
      case "topLeft":
        g2 = true;
        u2 = (t3, e3) => [
          0,
          0
        ];
        p2 = (t3, e3) => [
          t3,
          e3
        ];
        break;
      case "topMiddle":
        u2 = (t3, e3) => [
          t3 / 2,
          0
        ];
        p2 = (t3, e3) => [
          t3 / 2,
          e3
        ];
        break;
      case "topRight":
        g2 = true;
        u2 = (t3, e3) => [
          t3,
          0
        ];
        p2 = (t3, e3) => [
          0,
          e3
        ];
        break;
      case "middleRight":
        f2 = true;
        u2 = (t3, e3) => [
          t3,
          e3 / 2
        ];
        p2 = (t3, e3) => [
          0,
          e3 / 2
        ];
        break;
      case "bottomRight":
        g2 = true;
        u2 = (t3, e3) => [
          t3,
          e3
        ];
        p2 = (t3, e3) => [
          0,
          0
        ];
        break;
      case "bottomMiddle":
        u2 = (t3, e3) => [
          t3 / 2,
          e3
        ];
        p2 = (t3, e3) => [
          t3 / 2,
          0
        ];
        break;
      case "bottomLeft":
        g2 = true;
        u2 = (t3, e3) => [
          0,
          e3
        ];
        p2 = (t3, e3) => [
          t3,
          0
        ];
        break;
      case "middleLeft":
        f2 = true;
        u2 = (t3, e3) => [
          0,
          e3 / 2
        ];
        p2 = (t3, e3) => [
          t3,
          e3 / 2
        ];
    }
    const m2 = u2(a2, o2), b2 = p2(a2, o2);
    let v2 = transf(...b2);
    const y2 = round(n2 + v2[0]), A2 = round(r2 + v2[1]);
    let w2 = 1, x2 = 1, [_2, E2] = this.screenToPageTranslation(e2.movementX, e2.movementY);
    [_2, E2] = (C2 = _2 / i2, S2 = E2 / s2, [
      d2[0] * C2 + d2[2] * S2,
      d2[1] * C2 + d2[3] * S2
    ]);
    var C2, S2;
    if (g2) {
      const t3 = Math.hypot(a2, o2);
      w2 = x2 = Math.max(Math.min(Math.hypot(b2[0] - m2[0] - _2, b2[1] - m2[1] - E2) / t3, 1 / a2, 1 / o2), l2 / a2, h2 / o2);
    } else f2 ? w2 = Math.max(l2, Math.min(1, Math.abs(b2[0] - m2[0] - _2))) / a2 : x2 = Math.max(h2, Math.min(1, Math.abs(b2[1] - m2[1] - E2))) / o2;
    const T2 = round(a2 * w2), M2 = round(o2 * x2);
    v2 = transf(...p2(T2, M2));
    const k2 = y2 - v2[0], P2 = A2 - v2[1];
    this.width = T2;
    this.height = M2;
    this.x = k2;
    this.y = P2;
    this.setDims(i2 * T2, s2 * M2);
    this.fixAndSetPosition();
  };
  Ee_fn = function(t2) {
    const { isMac: e2 } = util_FeatureTest.platform;
    t2.ctrlKey && !e2 || t2.shiftKey || t2.metaKey && e2 ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
  };
  _e_fn = function(t2) {
    const { isSelected: e2 } = this;
    this._uiManager.setUpDragSession();
    const i2 = new AbortController(), s2 = this._uiManager.combinedSignal(i2);
    if (e2) {
      this.div.classList.add("moving");
      __privateSet(this, _he, t2.clientX);
      __privateSet(this, _ce, t2.clientY);
      const pointerMoveCallback = (t3) => {
        const { clientX: e3, clientY: i3 } = t3, [s3, n2] = this.screenToPageTranslation(e3 - __privateGet(this, _he), i3 - __privateGet(this, _ce));
        __privateSet(this, _he, e3);
        __privateSet(this, _ce, i3);
        this._uiManager.dragSelectedEditors(s3, n2);
      };
      window.addEventListener("pointermove", pointerMoveCallback, {
        passive: true,
        capture: true,
        signal: s2
      });
    }
    const pointerUpCallback = () => {
      i2.abort();
      e2 && this.div.classList.remove("moving");
      __privateSet(this, _se, false);
      this._uiManager.endDragSession() || __privateMethod(this, _AnnotationEditor_instances, Ee_fn).call(this, t2);
    };
    window.addEventListener("pointerup", pointerUpCallback, {
      signal: s2
    });
    window.addEventListener("blur", pointerUpCallback, {
      signal: s2
    });
  };
  xe_fn = function() {
    if (__privateGet(this, _ee) || !this.div) return;
    __privateSet(this, _ee, new AbortController());
    const t2 = this._uiManager.combinedSignal(__privateGet(this, _ee));
    this.div.addEventListener("focusin", this.focusin.bind(this), {
      signal: t2
    });
    this.div.addEventListener("focusout", this.focusout.bind(this), {
      signal: t2
    });
  };
  Ce_fn = function(t2) {
    _AnnotationEditor._resizerKeyboardManager.exec(this, t2);
  };
  Se_fn = function(t2) {
    var _a4;
    __privateGet(this, _oe) && ((_a4 = t2.relatedTarget) == null ? void 0 : _a4.parentNode) !== __privateGet(this, _Zt) && __privateMethod(this, _AnnotationEditor_instances, ge_fn).call(this);
  };
  Te_fn = function(t2) {
    __privateSet(this, _ie, __privateGet(this, _oe) ? t2 : "");
  };
  Me_fn = function(t2) {
    if (__privateGet(this, _Yt)) for (const e2 of __privateGet(this, _Yt)) e2.tabIndex = t2;
  };
  ge_fn = function() {
    __privateSet(this, _oe, false);
    __privateMethod(this, _AnnotationEditor_instances, Me_fn).call(this, -1);
    if (__privateGet(this, _te)) {
      const { savedX: t2, savedY: e2, savedWidth: i2, savedHeight: s2 } = __privateGet(this, _te);
      __privateMethod(this, _AnnotationEditor_instances, we_fn).call(this, t2, e2, i2, s2);
      __privateSet(this, _te, null);
    }
  };
  __privateAdd(_AnnotationEditor, _AnnotationEditor_static);
  __publicField(_AnnotationEditor, "_l10n", null);
  __publicField(_AnnotationEditor, "_l10nResizer", null);
  __publicField(_AnnotationEditor, "_borderLineWidth", -1);
  __publicField(_AnnotationEditor, "_colorManager", new ColorManager());
  __publicField(_AnnotationEditor, "_zIndex", 1);
  __publicField(_AnnotationEditor, "_telemetryTimeout", 1e3);
  let AnnotationEditor = _AnnotationEditor;
  class FakeEditor extends AnnotationEditor {
    constructor(t2) {
      super(t2);
      this.annotationElementId = t2.annotationElementId;
      this.deleted = true;
    }
    serialize() {
      return this.serializeDeleted();
    }
  }
  const gt = 3285377520, ft = 4294901760, mt = 65535;
  class MurmurHash3_64 {
    constructor(t2) {
      this.h1 = t2 ? 4294967295 & t2 : gt;
      this.h2 = t2 ? 4294967295 & t2 : gt;
    }
    update(t2) {
      let e2, i2;
      if ("string" == typeof t2) {
        e2 = new Uint8Array(2 * t2.length);
        i2 = 0;
        for (let s3 = 0, n3 = t2.length; s3 < n3; s3++) {
          const n4 = t2.charCodeAt(s3);
          if (n4 <= 255) e2[i2++] = n4;
          else {
            e2[i2++] = n4 >>> 8;
            e2[i2++] = 255 & n4;
          }
        }
      } else {
        if (!ArrayBuffer.isView(t2)) throw new Error("Invalid data format, must be a string or TypedArray.");
        e2 = t2.slice();
        i2 = e2.byteLength;
      }
      const s2 = i2 >> 2, n2 = i2 - 4 * s2, r2 = new Uint32Array(e2.buffer, 0, s2);
      let a2 = 0, o2 = 0, l2 = this.h1, h2 = this.h2;
      const c2 = 3432918353, d2 = 461845907, u2 = 11601, p2 = 13715;
      for (let t3 = 0; t3 < s2; t3++) if (1 & t3) {
        a2 = r2[t3];
        a2 = a2 * c2 & ft | a2 * u2 & mt;
        a2 = a2 << 15 | a2 >>> 17;
        a2 = a2 * d2 & ft | a2 * p2 & mt;
        l2 ^= a2;
        l2 = l2 << 13 | l2 >>> 19;
        l2 = 5 * l2 + 3864292196;
      } else {
        o2 = r2[t3];
        o2 = o2 * c2 & ft | o2 * u2 & mt;
        o2 = o2 << 15 | o2 >>> 17;
        o2 = o2 * d2 & ft | o2 * p2 & mt;
        h2 ^= o2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = 5 * h2 + 3864292196;
      }
      a2 = 0;
      switch (n2) {
        case 3:
          a2 ^= e2[4 * s2 + 2] << 16;
        case 2:
          a2 ^= e2[4 * s2 + 1] << 8;
        case 1:
          a2 ^= e2[4 * s2];
          a2 = a2 * c2 & ft | a2 * u2 & mt;
          a2 = a2 << 15 | a2 >>> 17;
          a2 = a2 * d2 & ft | a2 * p2 & mt;
          1 & s2 ? l2 ^= a2 : h2 ^= a2;
      }
      this.h1 = l2;
      this.h2 = h2;
    }
    hexdigest() {
      let t2 = this.h1, e2 = this.h2;
      t2 ^= e2 >>> 1;
      t2 = 3981806797 * t2 & ft | 36045 * t2 & mt;
      e2 = 4283543511 * e2 & ft | (2950163797 * (e2 << 16 | t2 >>> 16) & ft) >>> 16;
      t2 ^= e2 >>> 1;
      t2 = 444984403 * t2 & ft | 60499 * t2 & mt;
      e2 = 3301882366 * e2 & ft | (3120437893 * (e2 << 16 | t2 >>> 16) & ft) >>> 16;
      t2 ^= e2 >>> 1;
      return (t2 >>> 0).toString(16).padStart(8, "0") + (e2 >>> 0).toString(16).padStart(8, "0");
    }
  }
  const bt = Object.freeze({
    map: null,
    hash: "",
    transfer: void 0
  });
  class AnnotationStorage {
    constructor() {
      __privateAdd(this, _AnnotationStorage_instances);
      __privateAdd(this, _ke, false);
      __privateAdd(this, _Pe, null);
      __privateAdd(this, _Re, /* @__PURE__ */ new Map());
      this.onSetModified = null;
      this.onResetModified = null;
      this.onAnnotationEditor = null;
    }
    getValue(t2, e2) {
      const i2 = __privateGet(this, _Re).get(t2);
      return void 0 === i2 ? e2 : Object.assign(e2, i2);
    }
    getRawValue(t2) {
      return __privateGet(this, _Re).get(t2);
    }
    remove(t2) {
      __privateGet(this, _Re).delete(t2);
      0 === __privateGet(this, _Re).size && this.resetModified();
      if ("function" == typeof this.onAnnotationEditor) {
        for (const t3 of __privateGet(this, _Re).values()) if (t3 instanceof AnnotationEditor) return;
        this.onAnnotationEditor(null);
      }
    }
    setValue(t2, e2) {
      const i2 = __privateGet(this, _Re).get(t2);
      let s2 = false;
      if (void 0 !== i2) {
        for (const [t3, n2] of Object.entries(e2)) if (i2[t3] !== n2) {
          s2 = true;
          i2[t3] = n2;
        }
      } else {
        s2 = true;
        __privateGet(this, _Re).set(t2, e2);
      }
      s2 && __privateMethod(this, _AnnotationStorage_instances, De_fn).call(this);
      e2 instanceof AnnotationEditor && "function" == typeof this.onAnnotationEditor && this.onAnnotationEditor(e2.constructor._type);
    }
    has(t2) {
      return __privateGet(this, _Re).has(t2);
    }
    getAll() {
      return __privateGet(this, _Re).size > 0 ? objectFromMap(__privateGet(this, _Re)) : null;
    }
    setAll(t2) {
      for (const [e2, i2] of Object.entries(t2)) this.setValue(e2, i2);
    }
    get size() {
      return __privateGet(this, _Re).size;
    }
    resetModified() {
      if (__privateGet(this, _ke)) {
        __privateSet(this, _ke, false);
        "function" == typeof this.onResetModified && this.onResetModified();
      }
    }
    get print() {
      return new PrintAnnotationStorage(this);
    }
    get serializable() {
      if (0 === __privateGet(this, _Re).size) return bt;
      const t2 = /* @__PURE__ */ new Map(), e2 = new MurmurHash3_64(), i2 = [], s2 = /* @__PURE__ */ Object.create(null);
      let n2 = false;
      for (const [i3, r2] of __privateGet(this, _Re)) {
        const a2 = r2 instanceof AnnotationEditor ? r2.serialize(false, s2) : r2;
        if (a2) {
          t2.set(i3, a2);
          e2.update(`${i3}:${JSON.stringify(a2)}`);
          n2 || (n2 = !!a2.bitmap);
        }
      }
      if (n2) for (const e3 of t2.values()) e3.bitmap && i2.push(e3.bitmap);
      return t2.size > 0 ? {
        map: t2,
        hash: e2.hexdigest(),
        transfer: i2
      } : bt;
    }
    get editorStats() {
      let t2 = null;
      const e2 = /* @__PURE__ */ new Map();
      for (const i2 of __privateGet(this, _Re).values()) {
        if (!(i2 instanceof AnnotationEditor)) continue;
        const s2 = i2.telemetryFinalData;
        if (!s2) continue;
        const { type: n2 } = s2;
        e2.has(n2) || e2.set(n2, Object.getPrototypeOf(i2).constructor);
        t2 || (t2 = /* @__PURE__ */ Object.create(null));
        const r2 = t2[n2] || (t2[n2] = /* @__PURE__ */ new Map());
        for (const [t3, e3] of Object.entries(s2)) {
          if ("type" === t3) continue;
          let i3 = r2.get(t3);
          if (!i3) {
            i3 = /* @__PURE__ */ new Map();
            r2.set(t3, i3);
          }
          const s3 = i3.get(e3) ?? 0;
          i3.set(e3, s3 + 1);
        }
      }
      for (const [i2, s2] of e2) t2[i2] = s2.computeTelemetryFinalData(t2[i2]);
      return t2;
    }
    resetModifiedIds() {
      __privateSet(this, _Pe, null);
    }
    get modifiedIds() {
      if (__privateGet(this, _Pe)) return __privateGet(this, _Pe);
      const t2 = [];
      for (const e2 of __privateGet(this, _Re).values()) e2 instanceof AnnotationEditor && e2.annotationElementId && e2.serialize() && t2.push(e2.annotationElementId);
      return __privateSet(this, _Pe, {
        ids: new Set(t2),
        hash: t2.join(",")
      });
    }
  }
  _ke = new WeakMap();
  _Pe = new WeakMap();
  _Re = new WeakMap();
  _AnnotationStorage_instances = new WeakSet();
  De_fn = function() {
    if (!__privateGet(this, _ke)) {
      __privateSet(this, _ke, true);
      "function" == typeof this.onSetModified && this.onSetModified();
    }
  };
  class PrintAnnotationStorage extends AnnotationStorage {
    constructor(t2) {
      super();
      __privateAdd(this, _Ie);
      const { map: e2, hash: i2, transfer: s2 } = t2.serializable, n2 = structuredClone(e2, s2 ? {
        transfer: s2
      } : null);
      __privateSet(this, _Ie, {
        map: n2,
        hash: i2,
        transfer: s2
      });
    }
    get print() {
      unreachable("Should not call PrintAnnotationStorage.print");
    }
    get serializable() {
      return __privateGet(this, _Ie);
    }
    get modifiedIds() {
      return shadow(this, "modifiedIds", {
        ids: /* @__PURE__ */ new Set(),
        hash: ""
      });
    }
  }
  _Ie = new WeakMap();
  class FontLoader {
    constructor({ ownerDocument: t2 = globalThis.document, styleElement: e2 = null }) {
      __privateAdd(this, _Fe, /* @__PURE__ */ new Set());
      this._document = t2;
      this.nativeFontFaces = /* @__PURE__ */ new Set();
      this.styleElement = null;
      this.loadingRequests = [];
      this.loadTestFontId = 0;
    }
    addNativeFontFace(t2) {
      this.nativeFontFaces.add(t2);
      this._document.fonts.add(t2);
    }
    removeNativeFontFace(t2) {
      this.nativeFontFaces.delete(t2);
      this._document.fonts.delete(t2);
    }
    insertRule(t2) {
      if (!this.styleElement) {
        this.styleElement = this._document.createElement("style");
        this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
      }
      const e2 = this.styleElement.sheet;
      e2.insertRule(t2, e2.cssRules.length);
    }
    clear() {
      for (const t2 of this.nativeFontFaces) this._document.fonts.delete(t2);
      this.nativeFontFaces.clear();
      __privateGet(this, _Fe).clear();
      if (this.styleElement) {
        this.styleElement.remove();
        this.styleElement = null;
      }
    }
    async loadSystemFont({ systemFontInfo: t2, _inspectFont: e2 }) {
      if (t2 && !__privateGet(this, _Fe).has(t2.loadedName)) {
        assert(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
        if (this.isFontLoadingAPISupported) {
          const { loadedName: i2, src: s2, style: n2 } = t2, r2 = new FontFace(i2, s2, n2);
          this.addNativeFontFace(r2);
          try {
            await r2.load();
            __privateGet(this, _Fe).add(i2);
            e2 == null ? void 0 : e2(t2);
          } catch {
            warn(`Cannot load system font: ${t2.baseFontName}, installing it could help to improve PDF rendering.`);
            this.removeNativeFontFace(r2);
          }
        } else unreachable("Not implemented: loadSystemFont without the Font Loading API.");
      }
    }
    async bind(t2) {
      if (t2.attached || t2.missingFile && !t2.systemFontInfo) return;
      t2.attached = true;
      if (t2.systemFontInfo) {
        await this.loadSystemFont(t2);
        return;
      }
      if (this.isFontLoadingAPISupported) {
        const e3 = t2.createNativeFontFace();
        if (e3) {
          this.addNativeFontFace(e3);
          try {
            await e3.loaded;
          } catch (i2) {
            warn(`Failed to load font '${e3.family}': '${i2}'.`);
            t2.disableFontFace = true;
            throw i2;
          }
        }
        return;
      }
      const e2 = t2.createFontFaceRule();
      if (e2) {
        this.insertRule(e2);
        if (this.isSyncFontLoadingSupported) return;
        await new Promise((e3) => {
          const i2 = this._queueLoadingCallback(e3);
          this._prepareFontLoadEvent(t2, i2);
        });
      }
    }
    get isFontLoadingAPISupported() {
      var _a4;
      return shadow(this, "isFontLoadingAPISupported", !!((_a4 = this._document) == null ? void 0 : _a4.fonts));
    }
    get isSyncFontLoadingSupported() {
      let t2 = false;
      (i || "undefined" != typeof navigator && "string" == typeof (navigator == null ? void 0 : navigator.userAgent) && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (t2 = true);
      return shadow(this, "isSyncFontLoadingSupported", t2);
    }
    _queueLoadingCallback(t2) {
      const { loadingRequests: e2 } = this, i2 = {
        done: false,
        complete: function completeRequest() {
          assert(!i2.done, "completeRequest() cannot be called twice.");
          i2.done = true;
          for (; e2.length > 0 && e2[0].done; ) {
            const t3 = e2.shift();
            setTimeout(t3.callback, 0);
          }
        },
        callback: t2
      };
      e2.push(i2);
      return i2;
    }
    get _loadTestFont() {
      return shadow(this, "_loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="));
    }
    _prepareFontLoadEvent(t2, e2) {
      function int32(t3, e3) {
        return t3.charCodeAt(e3) << 24 | t3.charCodeAt(e3 + 1) << 16 | t3.charCodeAt(e3 + 2) << 8 | 255 & t3.charCodeAt(e3 + 3);
      }
      function spliceString(t3, e3, i3, s3) {
        return t3.substring(0, e3) + s3 + t3.substring(e3 + i3);
      }
      let i2, s2;
      const n2 = this._document.createElement("canvas");
      n2.width = 1;
      n2.height = 1;
      const r2 = n2.getContext("2d");
      let a2 = 0;
      const o2 = `lt${Date.now()}${this.loadTestFontId++}`;
      let l2 = this._loadTestFont;
      l2 = spliceString(l2, 976, o2.length, o2);
      const h2 = 1482184792;
      let c2 = int32(l2, 16);
      for (i2 = 0, s2 = o2.length - 3; i2 < s2; i2 += 4) c2 = c2 - h2 + int32(o2, i2) | 0;
      i2 < o2.length && (c2 = c2 - h2 + int32(o2 + "XXX", i2) | 0);
      l2 = spliceString(l2, 16, 4, function string32(t3) {
        return String.fromCharCode(t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3);
      }(c2));
      const d2 = `@font-face {font-family:"${o2}";src:${`url(data:font/opentype;base64,${btoa(l2)});`}}`;
      this.insertRule(d2);
      const u2 = this._document.createElement("div");
      u2.style.visibility = "hidden";
      u2.style.width = u2.style.height = "10px";
      u2.style.position = "absolute";
      u2.style.top = u2.style.left = "0px";
      for (const e3 of [
        t2.loadedName,
        o2
      ]) {
        const t3 = this._document.createElement("span");
        t3.textContent = "Hi";
        t3.style.fontFamily = e3;
        u2.append(t3);
      }
      this._document.body.append(u2);
      !function isFontReady(t3, e3) {
        if (++a2 > 30) {
          warn("Load test font never loaded.");
          e3();
          return;
        }
        r2.font = "30px " + t3;
        r2.fillText(".", 0, 20);
        r2.getImageData(0, 0, 1, 1).data[3] > 0 ? e3() : setTimeout(isFontReady.bind(null, t3, e3));
      }(o2, () => {
        u2.remove();
        e2.complete();
      });
    }
  }
  _Fe = new WeakMap();
  class FontFaceObject {
    constructor(t2, { disableFontFace: e2 = false, inspectFont: i2 = null }) {
      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
      for (const e3 in t2) this[e3] = t2[e3];
      this.disableFontFace = true === e2;
      this._inspectFont = i2;
    }
    createNativeFontFace() {
      var _a4;
      if (!this.data || this.disableFontFace) return null;
      let t2;
      if (this.cssFontInfo) {
        const e2 = {
          weight: this.cssFontInfo.fontWeight
        };
        this.cssFontInfo.italicAngle && (e2.style = `oblique ${this.cssFontInfo.italicAngle}deg`);
        t2 = new FontFace(this.cssFontInfo.fontFamily, this.data, e2);
      } else t2 = new FontFace(this.loadedName, this.data, {});
      (_a4 = this._inspectFont) == null ? void 0 : _a4.call(this, this);
      return t2;
    }
    createFontFaceRule() {
      var _a4;
      if (!this.data || this.disableFontFace) return null;
      const t2 = `url(data:${this.mimetype};base64,${function toBase64Util(t3) {
        return Uint8Array.prototype.toBase64 ? t3.toBase64() : btoa(bytesToString(t3));
      }(this.data)});`;
      let e2;
      if (this.cssFontInfo) {
        let i2 = `font-weight: ${this.cssFontInfo.fontWeight};`;
        this.cssFontInfo.italicAngle && (i2 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`);
        e2 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i2}src:${t2}}`;
      } else e2 = `@font-face {font-family:"${this.loadedName}";src:${t2}}`;
      (_a4 = this._inspectFont) == null ? void 0 : _a4.call(this, this, t2);
      return e2;
    }
    getPathGenerator(t2, e2) {
      if (void 0 !== this.compiledGlyphs[e2]) return this.compiledGlyphs[e2];
      let i2;
      try {
        i2 = t2.get(this.loadedName + "_path_" + e2);
      } catch (t3) {
        warn(`getPathGenerator - ignoring character: "${t3}".`);
      }
      if (!Array.isArray(i2) || 0 === i2.length) return this.compiledGlyphs[e2] = function(t3, e3) {
      };
      const s2 = [];
      for (let t3 = 0, e3 = i2.length; t3 < e3; ) switch (i2[t3++]) {
        case nt:
          {
            const [e4, n2, r2, a2, o2, l2] = i2.slice(t3, t3 + 6);
            s2.push((t4) => t4.bezierCurveTo(e4, n2, r2, a2, o2, l2));
            t3 += 6;
          }
          break;
        case rt:
          {
            const [e4, n2] = i2.slice(t3, t3 + 2);
            s2.push((t4) => t4.moveTo(e4, n2));
            t3 += 2;
          }
          break;
        case at:
          {
            const [e4, n2] = i2.slice(t3, t3 + 2);
            s2.push((t4) => t4.lineTo(e4, n2));
            t3 += 2;
          }
          break;
        case ot:
          {
            const [e4, n2, r2, a2] = i2.slice(t3, t3 + 4);
            s2.push((t4) => t4.quadraticCurveTo(e4, n2, r2, a2));
            t3 += 4;
          }
          break;
        case lt:
          s2.push((t4) => t4.restore());
          break;
        case ht:
          s2.push((t4) => t4.save());
          break;
        case ct:
          assert(2 === s2.length, "Scale command is only valid at the third position.");
          break;
        case dt:
          {
            const [e4, n2, r2, a2, o2, l2] = i2.slice(t3, t3 + 6);
            s2.push((t4) => t4.transform(e4, n2, r2, a2, o2, l2));
            t3 += 6;
          }
          break;
        case ut: {
          const [e4, n2] = i2.slice(t3, t3 + 2);
          s2.push((t4) => t4.translate(e4, n2));
          t3 += 2;
        }
      }
      return this.compiledGlyphs[e2] = function glyphDrawer(t3, e3) {
        s2[0](t3);
        s2[1](t3);
        t3.scale(e3, -e3);
        for (let e4 = 2, i3 = s2.length; e4 < i3; e4++) s2[e4](t3);
      };
    }
  }
  class BaseCanvasFactory {
    constructor({ enableHWA: t2 = false }) {
      __privateAdd(this, _Le, false);
      __privateSet(this, _Le, t2);
    }
    create(t2, e2) {
      if (t2 <= 0 || e2 <= 0) throw new Error("Invalid canvas size");
      const i2 = this._createCanvas(t2, e2);
      return {
        canvas: i2,
        context: i2.getContext("2d", {
          willReadFrequently: !__privateGet(this, _Le)
        })
      };
    }
    reset(t2, e2, i2) {
      if (!t2.canvas) throw new Error("Canvas is not specified");
      if (e2 <= 0 || i2 <= 0) throw new Error("Invalid canvas size");
      t2.canvas.width = e2;
      t2.canvas.height = i2;
    }
    destroy(t2) {
      if (!t2.canvas) throw new Error("Canvas is not specified");
      t2.canvas.width = 0;
      t2.canvas.height = 0;
      t2.canvas = null;
      t2.context = null;
    }
    _createCanvas(t2, e2) {
      unreachable("Abstract method `_createCanvas` called.");
    }
  }
  _Le = new WeakMap();
  class BaseCMapReaderFactory {
    constructor({ baseUrl: t2 = null, isCompressed: e2 = true }) {
      this.baseUrl = t2;
      this.isCompressed = e2;
    }
    async fetch({ name: t2 }) {
      if (!this.baseUrl) throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
      if (!t2) throw new Error("CMap name must be specified.");
      const e2 = this.baseUrl + t2 + (this.isCompressed ? ".bcmap" : "");
      return this._fetch(e2).then((t3) => ({
        cMapData: t3,
        isCompressed: this.isCompressed
      })).catch((t3) => {
        throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${e2}`);
      });
    }
    async _fetch(t2) {
      unreachable("Abstract method `_fetch` called.");
    }
  }
  class DOMCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(t2) {
      const e2 = await fetchData(t2, this.isCompressed ? "arraybuffer" : "text");
      return e2 instanceof ArrayBuffer ? new Uint8Array(e2) : stringToBytes(e2);
    }
  }
  __webpack_require__(4520);
  class BaseFilterFactory {
    addFilter(t2) {
      return "none";
    }
    addHCMFilter(t2, e2) {
      return "none";
    }
    addAlphaFilter(t2) {
      return "none";
    }
    addLuminosityFilter(t2) {
      return "none";
    }
    addHighlightHCMFilter(t2, e2, i2, s2, n2) {
      return "none";
    }
    destroy(t2 = false) {
    }
  }
  class BaseStandardFontDataFactory {
    constructor({ baseUrl: t2 = null }) {
      this.baseUrl = t2;
    }
    async fetch({ filename: t2 }) {
      if (!this.baseUrl) throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
      if (!t2) throw new Error("Font filename must be specified.");
      const e2 = `${this.baseUrl}${t2}`;
      return this._fetch(e2).catch((t3) => {
        throw new Error(`Unable to load font data at: ${e2}`);
      });
    }
    async _fetch(t2) {
      unreachable("Abstract method `_fetch` called.");
    }
  }
  class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(t2) {
      const e2 = await fetchData(t2, "arraybuffer");
      return new Uint8Array(e2);
    }
  }
  if (i) {
    var vt = Promise.withResolvers(), yt = null;
    (async () => {
      const t2 = await __vitePreload(() => import("./index-Bs2EL0Mm.js").then(async (m2) => {
        await m2.__tla;
        return m2;
      }).then((n3) => n3.aI), true ? __vite__mapDeps([0,1]) : void 0), e2 = await __vitePreload(() => import("./index-Bs2EL0Mm.js").then(async (m2) => {
        await m2.__tla;
        return m2;
      }).then((n3) => n3.aI), true ? __vite__mapDeps([0,1]) : void 0), i2 = await __vitePreload(() => import("./index-Bs2EL0Mm.js").then(async (m2) => {
        await m2.__tla;
        return m2;
      }).then((n3) => n3.aI), true ? __vite__mapDeps([0,1]) : void 0), s2 = await __vitePreload(() => import("./index-Bs2EL0Mm.js").then(async (m2) => {
        await m2.__tla;
        return m2;
      }).then((n3) => n3.aI), true ? __vite__mapDeps([0,1]) : void 0);
      let n2, r2;
      try {
        n2 = await __vitePreload(() => import("./index-Bs2EL0Mm.js").then(async (m2) => {
          await m2.__tla;
          return m2;
        }).then((n3) => n3.aI), true ? __vite__mapDeps([0,1]) : void 0);
      } catch {
      }
      try {
        r2 = await __vitePreload(() => import("./index-CTNSD8Tx.js"), true ? [] : void 0);
      } catch {
      }
      return new Map(Object.entries({
        fs: t2,
        http: e2,
        https: i2,
        url: s2,
        canvas: n2,
        path2d: r2
      }));
    })().then((t2) => {
      var _a4, _b2, _c, _d;
      yt = t2;
      vt.resolve();
      if (!globalThis.DOMMatrix) {
        const e2 = (_a4 = t2.get("canvas")) == null ? void 0 : _a4.DOMMatrix;
        e2 ? globalThis.DOMMatrix = e2 : warn("Cannot polyfill `DOMMatrix`, rendering may be broken.");
      }
      if (!globalThis.Path2D) {
        const e2 = (_b2 = t2.get("canvas")) == null ? void 0 : _b2.CanvasRenderingContext2D, i2 = (_c = t2.get("path2d")) == null ? void 0 : _c.applyPath2DToCanvasRenderingContext, s2 = (_d = t2.get("path2d")) == null ? void 0 : _d.Path2D;
        if (e2 && i2 && s2) {
          try {
            i2(e2);
          } catch (t3) {
            warn(`applyPath2DToCanvasRenderingContext: "${t3}".`);
          }
          globalThis.Path2D = s2;
        } else warn("Cannot polyfill `Path2D`, rendering may be broken.");
      }
    }, (t2) => {
      warn(`loadPackages: ${t2}`);
      yt = /* @__PURE__ */ new Map();
      vt.resolve();
    });
  }
  class NodePackages {
    static get promise() {
      return vt.promise;
    }
    static get(t2) {
      return yt == null ? void 0 : yt.get(t2);
    }
  }
  async function node_utils_fetchData(t2) {
    const e2 = NodePackages.get("fs"), i2 = await e2.promises.readFile(t2);
    return new Uint8Array(i2);
  }
  const At = "Fill", wt = "Stroke", xt = "Shading";
  function applyBoundingBox(t2, e2) {
    if (!e2) return;
    const i2 = e2[2] - e2[0], s2 = e2[3] - e2[1], n2 = new Path2D();
    n2.rect(e2[0], e2[1], i2, s2);
    t2.clip(n2);
  }
  class BaseShadingPattern {
    getPattern() {
      unreachable("Abstract method `getPattern` called.");
    }
  }
  class RadialAxialShadingPattern extends BaseShadingPattern {
    constructor(t2) {
      super();
      this._type = t2[1];
      this._bbox = t2[2];
      this._colorStops = t2[3];
      this._p0 = t2[4];
      this._p1 = t2[5];
      this._r0 = t2[6];
      this._r1 = t2[7];
      this.matrix = null;
    }
    _createGradient(t2) {
      let e2;
      "axial" === this._type ? e2 = t2.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : "radial" === this._type && (e2 = t2.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
      for (const t3 of this._colorStops) e2.addColorStop(t3[0], t3[1]);
      return e2;
    }
    getPattern(t2, e2, i2, s2) {
      let n2;
      if (s2 === wt || s2 === At) {
        const r2 = e2.current.getClippedPathBoundingBox(s2, getCurrentTransform(t2)) || [
          0,
          0,
          0,
          0
        ], a2 = Math.ceil(r2[2] - r2[0]) || 1, o2 = Math.ceil(r2[3] - r2[1]) || 1, l2 = e2.cachedCanvases.getCanvas("pattern", a2, o2), h2 = l2.context;
        h2.clearRect(0, 0, h2.canvas.width, h2.canvas.height);
        h2.beginPath();
        h2.rect(0, 0, h2.canvas.width, h2.canvas.height);
        h2.translate(-r2[0], -r2[1]);
        i2 = Util.transform(i2, [
          1,
          0,
          0,
          1,
          r2[0],
          r2[1]
        ]);
        h2.transform(...e2.baseTransform);
        this.matrix && h2.transform(...this.matrix);
        applyBoundingBox(h2, this._bbox);
        h2.fillStyle = this._createGradient(h2);
        h2.fill();
        n2 = t2.createPattern(l2.canvas, "no-repeat");
        const c2 = new DOMMatrix(i2);
        n2.setTransform(c2);
      } else {
        applyBoundingBox(t2, this._bbox);
        n2 = this._createGradient(t2);
      }
      return n2;
    }
  }
  function drawTriangle(t2, e2, i2, s2, n2, r2, a2, o2) {
    const l2 = e2.coords, h2 = e2.colors, c2 = t2.data, d2 = 4 * t2.width;
    let u2;
    if (l2[i2 + 1] > l2[s2 + 1]) {
      u2 = i2;
      i2 = s2;
      s2 = u2;
      u2 = r2;
      r2 = a2;
      a2 = u2;
    }
    if (l2[s2 + 1] > l2[n2 + 1]) {
      u2 = s2;
      s2 = n2;
      n2 = u2;
      u2 = a2;
      a2 = o2;
      o2 = u2;
    }
    if (l2[i2 + 1] > l2[s2 + 1]) {
      u2 = i2;
      i2 = s2;
      s2 = u2;
      u2 = r2;
      r2 = a2;
      a2 = u2;
    }
    const p2 = (l2[i2] + e2.offsetX) * e2.scaleX, g2 = (l2[i2 + 1] + e2.offsetY) * e2.scaleY, f2 = (l2[s2] + e2.offsetX) * e2.scaleX, m2 = (l2[s2 + 1] + e2.offsetY) * e2.scaleY, b2 = (l2[n2] + e2.offsetX) * e2.scaleX, v2 = (l2[n2 + 1] + e2.offsetY) * e2.scaleY;
    if (g2 >= v2) return;
    const y2 = h2[r2], A2 = h2[r2 + 1], w2 = h2[r2 + 2], x2 = h2[a2], _2 = h2[a2 + 1], E2 = h2[a2 + 2], C2 = h2[o2], S2 = h2[o2 + 1], T2 = h2[o2 + 2], M2 = Math.round(g2), k2 = Math.round(v2);
    let P2, R2, D2, I2, L2, O2, N2, B2;
    for (let t3 = M2; t3 <= k2; t3++) {
      if (t3 < m2) {
        const e4 = t3 < g2 ? 0 : (g2 - t3) / (g2 - m2);
        P2 = p2 - (p2 - f2) * e4;
        R2 = y2 - (y2 - x2) * e4;
        D2 = A2 - (A2 - _2) * e4;
        I2 = w2 - (w2 - E2) * e4;
      } else {
        let e4;
        e4 = t3 > v2 ? 1 : m2 === v2 ? 0 : (m2 - t3) / (m2 - v2);
        P2 = f2 - (f2 - b2) * e4;
        R2 = x2 - (x2 - C2) * e4;
        D2 = _2 - (_2 - S2) * e4;
        I2 = E2 - (E2 - T2) * e4;
      }
      let e3;
      e3 = t3 < g2 ? 0 : t3 > v2 ? 1 : (g2 - t3) / (g2 - v2);
      L2 = p2 - (p2 - b2) * e3;
      O2 = y2 - (y2 - C2) * e3;
      N2 = A2 - (A2 - S2) * e3;
      B2 = w2 - (w2 - T2) * e3;
      const i3 = Math.round(Math.min(P2, L2)), s3 = Math.round(Math.max(P2, L2));
      let n3 = d2 * t3 + 4 * i3;
      for (let t4 = i3; t4 <= s3; t4++) {
        e3 = (P2 - t4) / (P2 - L2);
        e3 < 0 ? e3 = 0 : e3 > 1 && (e3 = 1);
        c2[n3++] = R2 - (R2 - O2) * e3 | 0;
        c2[n3++] = D2 - (D2 - N2) * e3 | 0;
        c2[n3++] = I2 - (I2 - B2) * e3 | 0;
        c2[n3++] = 255;
      }
    }
  }
  function drawFigure(t2, e2, i2) {
    const s2 = e2.coords, n2 = e2.colors;
    let r2, a2;
    switch (e2.type) {
      case "lattice":
        const o2 = e2.verticesPerRow, l2 = Math.floor(s2.length / o2) - 1, h2 = o2 - 1;
        for (r2 = 0; r2 < l2; r2++) {
          let e3 = r2 * o2;
          for (let r3 = 0; r3 < h2; r3++, e3++) {
            drawTriangle(t2, i2, s2[e3], s2[e3 + 1], s2[e3 + o2], n2[e3], n2[e3 + 1], n2[e3 + o2]);
            drawTriangle(t2, i2, s2[e3 + o2 + 1], s2[e3 + 1], s2[e3 + o2], n2[e3 + o2 + 1], n2[e3 + 1], n2[e3 + o2]);
          }
        }
        break;
      case "triangles":
        for (r2 = 0, a2 = s2.length; r2 < a2; r2 += 3) drawTriangle(t2, i2, s2[r2], s2[r2 + 1], s2[r2 + 2], n2[r2], n2[r2 + 1], n2[r2 + 2]);
        break;
      default:
        throw new Error("illegal figure");
    }
  }
  class MeshShadingPattern extends BaseShadingPattern {
    constructor(t2) {
      super();
      this._coords = t2[2];
      this._colors = t2[3];
      this._figures = t2[4];
      this._bounds = t2[5];
      this._bbox = t2[7];
      this._background = t2[8];
      this.matrix = null;
    }
    _createMeshCanvas(t2, e2, i2) {
      const s2 = Math.floor(this._bounds[0]), n2 = Math.floor(this._bounds[1]), r2 = Math.ceil(this._bounds[2]) - s2, a2 = Math.ceil(this._bounds[3]) - n2, o2 = Math.min(Math.ceil(Math.abs(r2 * t2[0] * 1.1)), 3e3), l2 = Math.min(Math.ceil(Math.abs(a2 * t2[1] * 1.1)), 3e3), h2 = r2 / o2, c2 = a2 / l2, d2 = {
        coords: this._coords,
        colors: this._colors,
        offsetX: -s2,
        offsetY: -n2,
        scaleX: 1 / h2,
        scaleY: 1 / c2
      }, u2 = o2 + 4, p2 = l2 + 4, g2 = i2.getCanvas("mesh", u2, p2), f2 = g2.context, m2 = f2.createImageData(o2, l2);
      if (e2) {
        const t3 = m2.data;
        for (let i3 = 0, s3 = t3.length; i3 < s3; i3 += 4) {
          t3[i3] = e2[0];
          t3[i3 + 1] = e2[1];
          t3[i3 + 2] = e2[2];
          t3[i3 + 3] = 255;
        }
      }
      for (const t3 of this._figures) drawFigure(m2, t3, d2);
      f2.putImageData(m2, 2, 2);
      return {
        canvas: g2.canvas,
        offsetX: s2 - 2 * h2,
        offsetY: n2 - 2 * c2,
        scaleX: h2,
        scaleY: c2
      };
    }
    getPattern(t2, e2, i2, s2) {
      applyBoundingBox(t2, this._bbox);
      let n2;
      if (s2 === xt) n2 = Util.singularValueDecompose2dScale(getCurrentTransform(t2));
      else {
        n2 = Util.singularValueDecompose2dScale(e2.baseTransform);
        if (this.matrix) {
          const t3 = Util.singularValueDecompose2dScale(this.matrix);
          n2 = [
            n2[0] * t3[0],
            n2[1] * t3[1]
          ];
        }
      }
      const r2 = this._createMeshCanvas(n2, s2 === xt ? null : this._background, e2.cachedCanvases);
      if (s2 !== xt) {
        t2.setTransform(...e2.baseTransform);
        this.matrix && t2.transform(...this.matrix);
      }
      t2.translate(r2.offsetX, r2.offsetY);
      t2.scale(r2.scaleX, r2.scaleY);
      return t2.createPattern(r2.canvas, "no-repeat");
    }
  }
  class DummyShadingPattern extends BaseShadingPattern {
    getPattern() {
      return "hotpink";
    }
  }
  const _t = 1, Et = 2;
  const _TilingPattern = class _TilingPattern {
    constructor(t2, e2, i2, s2, n2) {
      this.operatorList = t2[2];
      this.matrix = t2[3];
      this.bbox = t2[4];
      this.xstep = t2[5];
      this.ystep = t2[6];
      this.paintType = t2[7];
      this.tilingType = t2[8];
      this.color = e2;
      this.ctx = i2;
      this.canvasGraphicsFactory = s2;
      this.baseTransform = n2;
    }
    createPatternCanvas(t2) {
      const { bbox: e2, operatorList: i2, paintType: s2, tilingType: n2, color: r2, canvasGraphicsFactory: a2 } = this;
      let { xstep: o2, ystep: l2 } = this;
      o2 = Math.abs(o2);
      l2 = Math.abs(l2);
      info("TilingType: " + n2);
      const h2 = e2[0], c2 = e2[1], d2 = e2[2], u2 = e2[3], p2 = d2 - h2, g2 = u2 - c2, f2 = Util.singularValueDecompose2dScale(this.matrix), m2 = Util.singularValueDecompose2dScale(this.baseTransform), b2 = f2[0] * m2[0], v2 = f2[1] * m2[1];
      let y2 = p2, A2 = g2, w2 = false, x2 = false;
      const _2 = Math.ceil(o2 * b2), E2 = Math.ceil(l2 * v2);
      _2 >= Math.ceil(p2 * b2) ? y2 = o2 : w2 = true;
      E2 >= Math.ceil(g2 * v2) ? A2 = l2 : x2 = true;
      const C2 = this.getSizeAndScale(y2, this.ctx.canvas.width, b2), S2 = this.getSizeAndScale(A2, this.ctx.canvas.height, v2), T2 = t2.cachedCanvases.getCanvas("pattern", C2.size, S2.size), M2 = T2.context, k2 = a2.createCanvasGraphics(M2);
      k2.groupLevel = t2.groupLevel;
      this.setFillAndStrokeStyleToContext(k2, s2, r2);
      M2.translate(-C2.scale * h2, -S2.scale * c2);
      k2.transform(C2.scale, 0, 0, S2.scale, 0, 0);
      M2.save();
      this.clipBbox(k2, h2, c2, d2, u2);
      k2.baseTransform = getCurrentTransform(k2.ctx);
      k2.executeOperatorList(i2);
      k2.endDrawing();
      M2.restore();
      if (w2 || x2) {
        const e3 = T2.canvas;
        w2 && (y2 = o2);
        x2 && (A2 = l2);
        const i3 = this.getSizeAndScale(y2, this.ctx.canvas.width, b2), s3 = this.getSizeAndScale(A2, this.ctx.canvas.height, v2), n3 = i3.size, r3 = s3.size, a3 = t2.cachedCanvases.getCanvas("pattern-workaround", n3, r3), d3 = a3.context, u3 = w2 ? Math.floor(p2 / o2) : 0, f3 = x2 ? Math.floor(g2 / l2) : 0;
        for (let t3 = 0; t3 <= u3; t3++) for (let i4 = 0; i4 <= f3; i4++) d3.drawImage(e3, n3 * t3, r3 * i4, n3, r3, 0, 0, n3, r3);
        return {
          canvas: a3.canvas,
          scaleX: i3.scale,
          scaleY: s3.scale,
          offsetX: h2,
          offsetY: c2
        };
      }
      return {
        canvas: T2.canvas,
        scaleX: C2.scale,
        scaleY: S2.scale,
        offsetX: h2,
        offsetY: c2
      };
    }
    getSizeAndScale(t2, e2, i2) {
      const s2 = Math.max(_TilingPattern.MAX_PATTERN_SIZE, e2);
      let n2 = Math.ceil(t2 * i2);
      n2 >= s2 ? n2 = s2 : i2 = n2 / t2;
      return {
        scale: i2,
        size: n2
      };
    }
    clipBbox(t2, e2, i2, s2, n2) {
      const r2 = s2 - e2, a2 = n2 - i2;
      t2.ctx.rect(e2, i2, r2, a2);
      t2.current.updateRectMinMax(getCurrentTransform(t2.ctx), [
        e2,
        i2,
        s2,
        n2
      ]);
      t2.clip();
      t2.endPath();
    }
    setFillAndStrokeStyleToContext(t2, e2, i2) {
      const s2 = t2.ctx, n2 = t2.current;
      switch (e2) {
        case _t:
          const t3 = this.ctx;
          s2.fillStyle = t3.fillStyle;
          s2.strokeStyle = t3.strokeStyle;
          n2.fillColor = t3.fillStyle;
          n2.strokeColor = t3.strokeStyle;
          break;
        case Et:
          const r2 = Util.makeHexColor(i2[0], i2[1], i2[2]);
          s2.fillStyle = r2;
          s2.strokeStyle = r2;
          n2.fillColor = r2;
          n2.strokeColor = r2;
          break;
        default:
          throw new FormatError(`Unsupported paint type: ${e2}`);
      }
    }
    getPattern(t2, e2, i2, s2) {
      let n2 = i2;
      if (s2 !== xt) {
        n2 = Util.transform(n2, e2.baseTransform);
        this.matrix && (n2 = Util.transform(n2, this.matrix));
      }
      const r2 = this.createPatternCanvas(e2);
      let a2 = new DOMMatrix(n2);
      a2 = a2.translate(r2.offsetX, r2.offsetY);
      a2 = a2.scale(1 / r2.scaleX, 1 / r2.scaleY);
      const o2 = t2.createPattern(r2.canvas, "repeat");
      o2.setTransform(a2);
      return o2;
    }
  };
  __publicField(_TilingPattern, "MAX_PATTERN_SIZE", 3e3);
  let TilingPattern = _TilingPattern;
  function convertBlackAndWhiteToRGBA({ src: t2, srcPos: e2 = 0, dest: i2, width: s2, height: n2, nonBlackColor: r2 = 4294967295, inverseDecode: a2 = false }) {
    const o2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255, [l2, h2] = a2 ? [
      r2,
      o2
    ] : [
      o2,
      r2
    ], c2 = s2 >> 3, d2 = 7 & s2, u2 = t2.length;
    i2 = new Uint32Array(i2.buffer);
    let p2 = 0;
    for (let s3 = 0; s3 < n2; s3++) {
      for (const s5 = e2 + c2; e2 < s5; e2++) {
        const s6 = e2 < u2 ? t2[e2] : 255;
        i2[p2++] = 128 & s6 ? h2 : l2;
        i2[p2++] = 64 & s6 ? h2 : l2;
        i2[p2++] = 32 & s6 ? h2 : l2;
        i2[p2++] = 16 & s6 ? h2 : l2;
        i2[p2++] = 8 & s6 ? h2 : l2;
        i2[p2++] = 4 & s6 ? h2 : l2;
        i2[p2++] = 2 & s6 ? h2 : l2;
        i2[p2++] = 1 & s6 ? h2 : l2;
      }
      if (0 === d2) continue;
      const s4 = e2 < u2 ? t2[e2++] : 255;
      for (let t3 = 0; t3 < d2; t3++) i2[p2++] = s4 & 1 << 7 - t3 ? h2 : l2;
    }
    return {
      srcPos: e2,
      destPos: p2
    };
  }
  const Ct = 16;
  class CachedCanvases {
    constructor(t2) {
      this.canvasFactory = t2;
      this.cache = /* @__PURE__ */ Object.create(null);
    }
    getCanvas(t2, e2, i2) {
      let s2;
      if (void 0 !== this.cache[t2]) {
        s2 = this.cache[t2];
        this.canvasFactory.reset(s2, e2, i2);
      } else {
        s2 = this.canvasFactory.create(e2, i2);
        this.cache[t2] = s2;
      }
      return s2;
    }
    delete(t2) {
      delete this.cache[t2];
    }
    clear() {
      for (const t2 in this.cache) {
        const e2 = this.cache[t2];
        this.canvasFactory.destroy(e2);
        delete this.cache[t2];
      }
    }
  }
  function drawImageAtIntegerCoords(t2, e2, i2, s2, n2, r2, a2, o2, l2, h2) {
    const [c2, d2, u2, p2, g2, f2] = getCurrentTransform(t2);
    if (0 === d2 && 0 === u2) {
      const m2 = a2 * c2 + g2, b2 = Math.round(m2), v2 = o2 * p2 + f2, y2 = Math.round(v2), A2 = (a2 + l2) * c2 + g2, w2 = Math.abs(Math.round(A2) - b2) || 1, x2 = (o2 + h2) * p2 + f2, _2 = Math.abs(Math.round(x2) - y2) || 1;
      t2.setTransform(Math.sign(c2), 0, 0, Math.sign(p2), b2, y2);
      t2.drawImage(e2, i2, s2, n2, r2, 0, 0, w2, _2);
      t2.setTransform(c2, d2, u2, p2, g2, f2);
      return [
        w2,
        _2
      ];
    }
    if (0 === c2 && 0 === p2) {
      const m2 = o2 * u2 + g2, b2 = Math.round(m2), v2 = a2 * d2 + f2, y2 = Math.round(v2), A2 = (o2 + h2) * u2 + g2, w2 = Math.abs(Math.round(A2) - b2) || 1, x2 = (a2 + l2) * d2 + f2, _2 = Math.abs(Math.round(x2) - y2) || 1;
      t2.setTransform(0, Math.sign(d2), Math.sign(u2), 0, b2, y2);
      t2.drawImage(e2, i2, s2, n2, r2, 0, 0, _2, w2);
      t2.setTransform(c2, d2, u2, p2, g2, f2);
      return [
        _2,
        w2
      ];
    }
    t2.drawImage(e2, i2, s2, n2, r2, a2, o2, l2, h2);
    return [
      Math.hypot(c2, d2) * l2,
      Math.hypot(u2, p2) * h2
    ];
  }
  class CanvasExtraState {
    constructor(t2, e2) {
      this.alphaIsShape = false;
      this.fontSize = 0;
      this.fontSizeScale = 1;
      this.textMatrix = s;
      this.textMatrixScale = 1;
      this.fontMatrix = n;
      this.leading = 0;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRenderingMode = v;
      this.textRise = 0;
      this.fillColor = "#000000";
      this.strokeColor = "#000000";
      this.patternFill = false;
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.activeSMask = null;
      this.transferMaps = "none";
      this.startNewPathAndClipBox([
        0,
        0,
        t2,
        e2
      ]);
    }
    clone() {
      const t2 = Object.create(this);
      t2.clipBox = this.clipBox.slice();
      return t2;
    }
    setCurrentPoint(t2, e2) {
      this.x = t2;
      this.y = e2;
    }
    updatePathMinMax(t2, e2, i2) {
      [e2, i2] = Util.applyTransform([
        e2,
        i2
      ], t2);
      this.minX = Math.min(this.minX, e2);
      this.minY = Math.min(this.minY, i2);
      this.maxX = Math.max(this.maxX, e2);
      this.maxY = Math.max(this.maxY, i2);
    }
    updateRectMinMax(t2, e2) {
      const i2 = Util.applyTransform(e2, t2), s2 = Util.applyTransform(e2.slice(2), t2), n2 = Util.applyTransform([
        e2[0],
        e2[3]
      ], t2), r2 = Util.applyTransform([
        e2[2],
        e2[1]
      ], t2);
      this.minX = Math.min(this.minX, i2[0], s2[0], n2[0], r2[0]);
      this.minY = Math.min(this.minY, i2[1], s2[1], n2[1], r2[1]);
      this.maxX = Math.max(this.maxX, i2[0], s2[0], n2[0], r2[0]);
      this.maxY = Math.max(this.maxY, i2[1], s2[1], n2[1], r2[1]);
    }
    updateScalingPathMinMax(t2, e2) {
      Util.scaleMinMax(t2, e2);
      this.minX = Math.min(this.minX, e2[0]);
      this.minY = Math.min(this.minY, e2[1]);
      this.maxX = Math.max(this.maxX, e2[2]);
      this.maxY = Math.max(this.maxY, e2[3]);
    }
    updateCurvePathMinMax(t2, e2, i2, s2, n2, r2, a2, o2, l2, h2) {
      const c2 = Util.bezierBoundingBox(e2, i2, s2, n2, r2, a2, o2, l2, h2);
      h2 || this.updateRectMinMax(t2, c2);
    }
    getPathBoundingBox(t2 = At, e2 = null) {
      const i2 = [
        this.minX,
        this.minY,
        this.maxX,
        this.maxY
      ];
      if (t2 === wt) {
        e2 || unreachable("Stroke bounding box must include transform.");
        const t3 = Util.singularValueDecompose2dScale(e2), s2 = t3[0] * this.lineWidth / 2, n2 = t3[1] * this.lineWidth / 2;
        i2[0] -= s2;
        i2[1] -= n2;
        i2[2] += s2;
        i2[3] += n2;
      }
      return i2;
    }
    updateClipFromPath() {
      const t2 = Util.intersect(this.clipBox, this.getPathBoundingBox());
      this.startNewPathAndClipBox(t2 || [
        0,
        0,
        0,
        0
      ]);
    }
    isEmptyClip() {
      return this.minX === 1 / 0;
    }
    startNewPathAndClipBox(t2) {
      this.clipBox = t2;
      this.minX = 1 / 0;
      this.minY = 1 / 0;
      this.maxX = 0;
      this.maxY = 0;
    }
    getClippedPathBoundingBox(t2 = At, e2 = null) {
      return Util.intersect(this.clipBox, this.getPathBoundingBox(t2, e2));
    }
  }
  function putBinaryImageData(t2, e2) {
    if ("undefined" != typeof ImageData && e2 instanceof ImageData) {
      t2.putImageData(e2, 0, 0);
      return;
    }
    const i2 = e2.height, s2 = e2.width, n2 = i2 % Ct, r2 = (i2 - n2) / Ct, a2 = 0 === n2 ? r2 : r2 + 1, o2 = t2.createImageData(s2, Ct);
    let l2, h2 = 0;
    const c2 = e2.data, d2 = o2.data;
    let u2, p2, g2, f2;
    if (e2.kind === E.GRAYSCALE_1BPP) {
      const e3 = c2.byteLength, i3 = new Uint32Array(d2.buffer, 0, d2.byteLength >> 2), f3 = i3.length, m2 = s2 + 7 >> 3, b2 = 4294967295, v2 = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
      for (u2 = 0; u2 < a2; u2++) {
        g2 = u2 < r2 ? Ct : n2;
        l2 = 0;
        for (p2 = 0; p2 < g2; p2++) {
          const t3 = e3 - h2;
          let n3 = 0;
          const r3 = t3 > m2 ? s2 : 8 * t3 - 7, a3 = -8 & r3;
          let o3 = 0, d3 = 0;
          for (; n3 < a3; n3 += 8) {
            d3 = c2[h2++];
            i3[l2++] = 128 & d3 ? b2 : v2;
            i3[l2++] = 64 & d3 ? b2 : v2;
            i3[l2++] = 32 & d3 ? b2 : v2;
            i3[l2++] = 16 & d3 ? b2 : v2;
            i3[l2++] = 8 & d3 ? b2 : v2;
            i3[l2++] = 4 & d3 ? b2 : v2;
            i3[l2++] = 2 & d3 ? b2 : v2;
            i3[l2++] = 1 & d3 ? b2 : v2;
          }
          for (; n3 < r3; n3++) {
            if (0 === o3) {
              d3 = c2[h2++];
              o3 = 128;
            }
            i3[l2++] = d3 & o3 ? b2 : v2;
            o3 >>= 1;
          }
        }
        for (; l2 < f3; ) i3[l2++] = 0;
        t2.putImageData(o2, 0, u2 * Ct);
      }
    } else if (e2.kind === E.RGBA_32BPP) {
      p2 = 0;
      f2 = s2 * Ct * 4;
      for (u2 = 0; u2 < r2; u2++) {
        d2.set(c2.subarray(h2, h2 + f2));
        h2 += f2;
        t2.putImageData(o2, 0, p2);
        p2 += Ct;
      }
      if (u2 < a2) {
        f2 = s2 * n2 * 4;
        d2.set(c2.subarray(h2, h2 + f2));
        t2.putImageData(o2, 0, p2);
      }
    } else {
      if (e2.kind !== E.RGB_24BPP) throw new Error(`bad image kind: ${e2.kind}`);
      g2 = Ct;
      f2 = s2 * g2;
      for (u2 = 0; u2 < a2; u2++) {
        if (u2 >= r2) {
          g2 = n2;
          f2 = s2 * g2;
        }
        l2 = 0;
        for (p2 = f2; p2--; ) {
          d2[l2++] = c2[h2++];
          d2[l2++] = c2[h2++];
          d2[l2++] = c2[h2++];
          d2[l2++] = 255;
        }
        t2.putImageData(o2, 0, u2 * Ct);
      }
    }
  }
  function putBinaryImageMask(t2, e2) {
    if (e2.bitmap) {
      t2.drawImage(e2.bitmap, 0, 0);
      return;
    }
    const i2 = e2.height, s2 = e2.width, n2 = i2 % Ct, r2 = (i2 - n2) / Ct, a2 = 0 === n2 ? r2 : r2 + 1, o2 = t2.createImageData(s2, Ct);
    let l2 = 0;
    const h2 = e2.data, c2 = o2.data;
    for (let e3 = 0; e3 < a2; e3++) {
      const i3 = e3 < r2 ? Ct : n2;
      ({ srcPos: l2 } = convertBlackAndWhiteToRGBA({
        src: h2,
        srcPos: l2,
        dest: c2,
        width: s2,
        height: i3,
        nonBlackColor: 0
      }));
      t2.putImageData(o2, 0, e3 * Ct);
    }
  }
  function copyCtxState(t2, e2) {
    const i2 = [
      "strokeStyle",
      "fillStyle",
      "fillRule",
      "globalAlpha",
      "lineWidth",
      "lineCap",
      "lineJoin",
      "miterLimit",
      "globalCompositeOperation",
      "font",
      "filter"
    ];
    for (const s2 of i2) void 0 !== t2[s2] && (e2[s2] = t2[s2]);
    if (void 0 !== t2.setLineDash) {
      e2.setLineDash(t2.getLineDash());
      e2.lineDashOffset = t2.lineDashOffset;
    }
  }
  function resetCtxToDefault(t2) {
    t2.strokeStyle = t2.fillStyle = "#000000";
    t2.fillRule = "nonzero";
    t2.globalAlpha = 1;
    t2.lineWidth = 1;
    t2.lineCap = "butt";
    t2.lineJoin = "miter";
    t2.miterLimit = 10;
    t2.globalCompositeOperation = "source-over";
    t2.font = "10px sans-serif";
    if (void 0 !== t2.setLineDash) {
      t2.setLineDash([]);
      t2.lineDashOffset = 0;
    }
    if (!i) {
      const { filter: e2 } = t2;
      "none" !== e2 && "" !== e2 && (t2.filter = "none");
    }
  }
  function getImageSmoothingEnabled(t2, e2) {
    if (e2) return true;
    const i2 = Util.singularValueDecompose2dScale(t2);
    i2[0] = Math.fround(i2[0]);
    i2[1] = Math.fround(i2[1]);
    const s2 = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);
    return i2[0] <= s2 && i2[1] <= s2;
  }
  const St = [
    "butt",
    "round",
    "square"
  ], Tt = [
    "miter",
    "round",
    "bevel"
  ], Mt = {}, kt = {};
  const _CanvasGraphics = class _CanvasGraphics {
    constructor(t2, e2, i2, s2, n2, { optionalContentConfig: r2, markedContentStack: a2 = null }, o2, l2) {
      __privateAdd(this, _CanvasGraphics_instances);
      this.ctx = t2;
      this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
      this.stateStack = [];
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.res = null;
      this.xobjs = null;
      this.commonObjs = e2;
      this.objs = i2;
      this.canvasFactory = s2;
      this.filterFactory = n2;
      this.groupStack = [];
      this.processingType3 = null;
      this.baseTransform = null;
      this.baseTransformStack = [];
      this.groupLevel = 0;
      this.smaskStack = [];
      this.smaskCounter = 0;
      this.tempSMask = null;
      this.suspendedCtx = null;
      this.contentVisible = true;
      this.markedContentStack = a2 || [];
      this.optionalContentConfig = r2;
      this.cachedCanvases = new CachedCanvases(this.canvasFactory);
      this.cachedPatterns = /* @__PURE__ */ new Map();
      this.annotationCanvasMap = o2;
      this.viewportScale = 1;
      this.outputScaleX = 1;
      this.outputScaleY = 1;
      this.pageColors = l2;
      this._cachedScaleForStroking = [
        -1,
        0
      ];
      this._cachedGetSinglePixelWidth = null;
      this._cachedBitmapsMap = /* @__PURE__ */ new Map();
    }
    getObject(t2, e2 = null) {
      return "string" == typeof t2 ? t2.startsWith("g_") ? this.commonObjs.get(t2) : this.objs.get(t2) : e2;
    }
    beginDrawing({ transform: t2, viewport: e2, transparency: i2 = false, background: s2 = null }) {
      const n2 = this.ctx.canvas.width, r2 = this.ctx.canvas.height, a2 = this.ctx.fillStyle;
      this.ctx.fillStyle = s2 || "#ffffff";
      this.ctx.fillRect(0, 0, n2, r2);
      this.ctx.fillStyle = a2;
      if (i2) {
        const t3 = this.cachedCanvases.getCanvas("transparent", n2, r2);
        this.compositeCtx = this.ctx;
        this.transparentCanvas = t3.canvas;
        this.ctx = t3.context;
        this.ctx.save();
        this.ctx.transform(...getCurrentTransform(this.compositeCtx));
      }
      this.ctx.save();
      resetCtxToDefault(this.ctx);
      if (t2) {
        this.ctx.transform(...t2);
        this.outputScaleX = t2[0];
        this.outputScaleY = t2[0];
      }
      this.ctx.transform(...e2.transform);
      this.viewportScale = e2.scale;
      this.baseTransform = getCurrentTransform(this.ctx);
    }
    executeOperatorList(t2, e2, i2, s2) {
      const n2 = t2.argsArray, r2 = t2.fnArray;
      let a2 = e2 || 0;
      const o2 = n2.length;
      if (o2 === a2) return a2;
      const l2 = o2 - a2 > 10 && "function" == typeof i2, h2 = l2 ? Date.now() + 15 : 0;
      let c2 = 0;
      const d2 = this.commonObjs, u2 = this.objs;
      let p2;
      for (; ; ) {
        if (void 0 !== s2 && a2 === s2.nextBreakPoint) {
          s2.breakIt(a2, i2);
          return a2;
        }
        p2 = r2[a2];
        if (p2 !== Y.dependency) this[p2].apply(this, n2[a2]);
        else for (const t3 of n2[a2]) {
          const e3 = t3.startsWith("g_") ? d2 : u2;
          if (!e3.has(t3)) {
            e3.get(t3, i2);
            return a2;
          }
        }
        a2++;
        if (a2 === o2) return a2;
        if (l2 && ++c2 > 10) {
          if (Date.now() > h2) {
            i2();
            return a2;
          }
          c2 = 0;
        }
      }
    }
    endDrawing() {
      __privateMethod(this, _CanvasGraphics_instances, Oe_fn).call(this);
      this.cachedCanvases.clear();
      this.cachedPatterns.clear();
      for (const t2 of this._cachedBitmapsMap.values()) {
        for (const e2 of t2.values()) "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement && (e2.width = e2.height = 0);
        t2.clear();
      }
      this._cachedBitmapsMap.clear();
      __privateMethod(this, _CanvasGraphics_instances, Ne_fn).call(this);
    }
    _scaleImage(t2, e2) {
      const i2 = t2.width ?? t2.displayWidth, s2 = t2.height ?? t2.displayHeight;
      let n2, r2, a2 = Math.max(Math.hypot(e2[0], e2[1]), 1), o2 = Math.max(Math.hypot(e2[2], e2[3]), 1), l2 = i2, h2 = s2, c2 = "prescale1";
      for (; a2 > 2 && l2 > 1 || o2 > 2 && h2 > 1; ) {
        let e3 = l2, i3 = h2;
        if (a2 > 2 && l2 > 1) {
          e3 = l2 >= 16384 ? Math.floor(l2 / 2) - 1 || 1 : Math.ceil(l2 / 2);
          a2 /= l2 / e3;
        }
        if (o2 > 2 && h2 > 1) {
          i3 = h2 >= 16384 ? Math.floor(h2 / 2) - 1 || 1 : Math.ceil(h2) / 2;
          o2 /= h2 / i3;
        }
        n2 = this.cachedCanvases.getCanvas(c2, e3, i3);
        r2 = n2.context;
        r2.clearRect(0, 0, e3, i3);
        r2.drawImage(t2, 0, 0, l2, h2, 0, 0, e3, i3);
        t2 = n2.canvas;
        l2 = e3;
        h2 = i3;
        c2 = "prescale1" === c2 ? "prescale2" : "prescale1";
      }
      return {
        img: t2,
        paintWidth: l2,
        paintHeight: h2
      };
    }
    _createMaskCanvas(t2) {
      const e2 = this.ctx, { width: i2, height: s2 } = t2, n2 = this.current.fillColor, r2 = this.current.patternFill, a2 = getCurrentTransform(e2);
      let o2, l2, h2, c2;
      if ((t2.bitmap || t2.data) && t2.count > 1) {
        const e3 = t2.bitmap || t2.data.buffer;
        l2 = JSON.stringify(r2 ? a2 : [
          a2.slice(0, 4),
          n2
        ]);
        o2 = this._cachedBitmapsMap.get(e3);
        if (!o2) {
          o2 = /* @__PURE__ */ new Map();
          this._cachedBitmapsMap.set(e3, o2);
        }
        const i3 = o2.get(l2);
        if (i3 && !r2) {
          return {
            canvas: i3,
            offsetX: Math.round(Math.min(a2[0], a2[2]) + a2[4]),
            offsetY: Math.round(Math.min(a2[1], a2[3]) + a2[5])
          };
        }
        h2 = i3;
      }
      if (!h2) {
        c2 = this.cachedCanvases.getCanvas("maskCanvas", i2, s2);
        putBinaryImageMask(c2.context, t2);
      }
      let d2 = Util.transform(a2, [
        1 / i2,
        0,
        0,
        -1 / s2,
        0,
        0
      ]);
      d2 = Util.transform(d2, [
        1,
        0,
        0,
        1,
        0,
        -s2
      ]);
      const [u2, p2, g2, f2] = Util.getAxialAlignedBoundingBox([
        0,
        0,
        i2,
        s2
      ], d2), m2 = Math.round(g2 - u2) || 1, b2 = Math.round(f2 - p2) || 1, v2 = this.cachedCanvases.getCanvas("fillCanvas", m2, b2), y2 = v2.context, A2 = u2, w2 = p2;
      y2.translate(-A2, -w2);
      y2.transform(...d2);
      if (!h2) {
        h2 = this._scaleImage(c2.canvas, getCurrentTransformInverse(y2));
        h2 = h2.img;
        o2 && r2 && o2.set(l2, h2);
      }
      y2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(y2), t2.interpolate);
      drawImageAtIntegerCoords(y2, h2, 0, 0, h2.width, h2.height, 0, 0, i2, s2);
      y2.globalCompositeOperation = "source-in";
      const x2 = Util.transform(getCurrentTransformInverse(y2), [
        1,
        0,
        0,
        1,
        -A2,
        -w2
      ]);
      y2.fillStyle = r2 ? n2.getPattern(e2, this, x2, At) : n2;
      y2.fillRect(0, 0, i2, s2);
      if (o2 && !r2) {
        this.cachedCanvases.delete("fillCanvas");
        o2.set(l2, v2.canvas);
      }
      return {
        canvas: v2.canvas,
        offsetX: Math.round(A2),
        offsetY: Math.round(w2)
      };
    }
    setLineWidth(t2) {
      t2 !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1);
      this.current.lineWidth = t2;
      this.ctx.lineWidth = t2;
    }
    setLineCap(t2) {
      this.ctx.lineCap = St[t2];
    }
    setLineJoin(t2) {
      this.ctx.lineJoin = Tt[t2];
    }
    setMiterLimit(t2) {
      this.ctx.miterLimit = t2;
    }
    setDash(t2, e2) {
      const i2 = this.ctx;
      if (void 0 !== i2.setLineDash) {
        i2.setLineDash(t2);
        i2.lineDashOffset = e2;
      }
    }
    setRenderingIntent(t2) {
    }
    setFlatness(t2) {
    }
    setGState(t2) {
      for (const [e2, i2] of t2) switch (e2) {
        case "LW":
          this.setLineWidth(i2);
          break;
        case "LC":
          this.setLineCap(i2);
          break;
        case "LJ":
          this.setLineJoin(i2);
          break;
        case "ML":
          this.setMiterLimit(i2);
          break;
        case "D":
          this.setDash(i2[0], i2[1]);
          break;
        case "RI":
          this.setRenderingIntent(i2);
          break;
        case "FL":
          this.setFlatness(i2);
          break;
        case "Font":
          this.setFont(i2[0], i2[1]);
          break;
        case "CA":
          this.current.strokeAlpha = i2;
          break;
        case "ca":
          this.current.fillAlpha = i2;
          this.ctx.globalAlpha = i2;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = i2;
          break;
        case "SMask":
          this.current.activeSMask = i2 ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(i2);
      }
    }
    get inSMaskMode() {
      return !!this.suspendedCtx;
    }
    checkSMaskState() {
      const t2 = this.inSMaskMode;
      this.current.activeSMask && !t2 ? this.beginSMaskMode() : !this.current.activeSMask && t2 && this.endSMaskMode();
    }
    beginSMaskMode() {
      if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode");
      const t2 = this.ctx.canvas.width, e2 = this.ctx.canvas.height, i2 = "smaskGroupAt" + this.groupLevel, s2 = this.cachedCanvases.getCanvas(i2, t2, e2);
      this.suspendedCtx = this.ctx;
      this.ctx = s2.context;
      const n2 = this.ctx;
      n2.setTransform(...getCurrentTransform(this.suspendedCtx));
      copyCtxState(this.suspendedCtx, n2);
      !function mirrorContextOperations(t3, e3) {
        if (t3._removeMirroring) throw new Error("Context is already forwarding operations.");
        t3.__originalSave = t3.save;
        t3.__originalRestore = t3.restore;
        t3.__originalRotate = t3.rotate;
        t3.__originalScale = t3.scale;
        t3.__originalTranslate = t3.translate;
        t3.__originalTransform = t3.transform;
        t3.__originalSetTransform = t3.setTransform;
        t3.__originalResetTransform = t3.resetTransform;
        t3.__originalClip = t3.clip;
        t3.__originalMoveTo = t3.moveTo;
        t3.__originalLineTo = t3.lineTo;
        t3.__originalBezierCurveTo = t3.bezierCurveTo;
        t3.__originalRect = t3.rect;
        t3.__originalClosePath = t3.closePath;
        t3.__originalBeginPath = t3.beginPath;
        t3._removeMirroring = () => {
          t3.save = t3.__originalSave;
          t3.restore = t3.__originalRestore;
          t3.rotate = t3.__originalRotate;
          t3.scale = t3.__originalScale;
          t3.translate = t3.__originalTranslate;
          t3.transform = t3.__originalTransform;
          t3.setTransform = t3.__originalSetTransform;
          t3.resetTransform = t3.__originalResetTransform;
          t3.clip = t3.__originalClip;
          t3.moveTo = t3.__originalMoveTo;
          t3.lineTo = t3.__originalLineTo;
          t3.bezierCurveTo = t3.__originalBezierCurveTo;
          t3.rect = t3.__originalRect;
          t3.closePath = t3.__originalClosePath;
          t3.beginPath = t3.__originalBeginPath;
          delete t3._removeMirroring;
        };
        t3.save = function ctxSave() {
          e3.save();
          this.__originalSave();
        };
        t3.restore = function ctxRestore() {
          e3.restore();
          this.__originalRestore();
        };
        t3.translate = function ctxTranslate(t4, i3) {
          e3.translate(t4, i3);
          this.__originalTranslate(t4, i3);
        };
        t3.scale = function ctxScale(t4, i3) {
          e3.scale(t4, i3);
          this.__originalScale(t4, i3);
        };
        t3.transform = function ctxTransform(t4, i3, s3, n3, r2, a2) {
          e3.transform(t4, i3, s3, n3, r2, a2);
          this.__originalTransform(t4, i3, s3, n3, r2, a2);
        };
        t3.setTransform = function ctxSetTransform(t4, i3, s3, n3, r2, a2) {
          e3.setTransform(t4, i3, s3, n3, r2, a2);
          this.__originalSetTransform(t4, i3, s3, n3, r2, a2);
        };
        t3.resetTransform = function ctxResetTransform() {
          e3.resetTransform();
          this.__originalResetTransform();
        };
        t3.rotate = function ctxRotate(t4) {
          e3.rotate(t4);
          this.__originalRotate(t4);
        };
        t3.clip = function ctxRotate(t4) {
          e3.clip(t4);
          this.__originalClip(t4);
        };
        t3.moveTo = function(t4, i3) {
          e3.moveTo(t4, i3);
          this.__originalMoveTo(t4, i3);
        };
        t3.lineTo = function(t4, i3) {
          e3.lineTo(t4, i3);
          this.__originalLineTo(t4, i3);
        };
        t3.bezierCurveTo = function(t4, i3, s3, n3, r2, a2) {
          e3.bezierCurveTo(t4, i3, s3, n3, r2, a2);
          this.__originalBezierCurveTo(t4, i3, s3, n3, r2, a2);
        };
        t3.rect = function(t4, i3, s3, n3) {
          e3.rect(t4, i3, s3, n3);
          this.__originalRect(t4, i3, s3, n3);
        };
        t3.closePath = function() {
          e3.closePath();
          this.__originalClosePath();
        };
        t3.beginPath = function() {
          e3.beginPath();
          this.__originalBeginPath();
        };
      }(n2, this.suspendedCtx);
      this.setGState([
        [
          "BM",
          "source-over"
        ],
        [
          "ca",
          1
        ],
        [
          "CA",
          1
        ]
      ]);
    }
    endSMaskMode() {
      if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode");
      this.ctx._removeMirroring();
      copyCtxState(this.ctx, this.suspendedCtx);
      this.ctx = this.suspendedCtx;
      this.suspendedCtx = null;
    }
    compose(t2) {
      if (!this.current.activeSMask) return;
      if (t2) {
        t2[0] = Math.floor(t2[0]);
        t2[1] = Math.floor(t2[1]);
        t2[2] = Math.ceil(t2[2]);
        t2[3] = Math.ceil(t2[3]);
      } else t2 = [
        0,
        0,
        this.ctx.canvas.width,
        this.ctx.canvas.height
      ];
      const e2 = this.current.activeSMask, i2 = this.suspendedCtx;
      this.composeSMask(i2, e2, this.ctx, t2);
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
      this.ctx.restore();
    }
    composeSMask(t2, e2, i2, s2) {
      const n2 = s2[0], r2 = s2[1], a2 = s2[2] - n2, o2 = s2[3] - r2;
      if (0 !== a2 && 0 !== o2) {
        this.genericComposeSMask(e2.context, i2, a2, o2, e2.subtype, e2.backdrop, e2.transferMap, n2, r2, e2.offsetX, e2.offsetY);
        t2.save();
        t2.globalAlpha = 1;
        t2.globalCompositeOperation = "source-over";
        t2.setTransform(1, 0, 0, 1, 0, 0);
        t2.drawImage(i2.canvas, 0, 0);
        t2.restore();
      }
    }
    genericComposeSMask(t2, e2, i2, s2, n2, r2, a2, o2, l2, h2, c2) {
      let d2 = t2.canvas, u2 = o2 - h2, p2 = l2 - c2;
      if (r2) {
        const e3 = Util.makeHexColor(...r2);
        if (u2 < 0 || p2 < 0 || u2 + i2 > d2.width || p2 + s2 > d2.height) {
          const t3 = this.cachedCanvases.getCanvas("maskExtension", i2, s2), n3 = t3.context;
          n3.drawImage(d2, -u2, -p2);
          n3.globalCompositeOperation = "destination-atop";
          n3.fillStyle = e3;
          n3.fillRect(0, 0, i2, s2);
          n3.globalCompositeOperation = "source-over";
          d2 = t3.canvas;
          u2 = p2 = 0;
        } else {
          t2.save();
          t2.globalAlpha = 1;
          t2.setTransform(1, 0, 0, 1, 0, 0);
          const n3 = new Path2D();
          n3.rect(u2, p2, i2, s2);
          t2.clip(n3);
          t2.globalCompositeOperation = "destination-atop";
          t2.fillStyle = e3;
          t2.fillRect(u2, p2, i2, s2);
          t2.restore();
        }
      }
      e2.save();
      e2.globalAlpha = 1;
      e2.setTransform(1, 0, 0, 1, 0, 0);
      "Alpha" === n2 && a2 ? e2.filter = this.filterFactory.addAlphaFilter(a2) : "Luminosity" === n2 && (e2.filter = this.filterFactory.addLuminosityFilter(a2));
      const g2 = new Path2D();
      g2.rect(o2, l2, i2, s2);
      e2.clip(g2);
      e2.globalCompositeOperation = "destination-in";
      e2.drawImage(d2, u2, p2, i2, s2, o2, l2, i2, s2);
      e2.restore();
    }
    save() {
      if (this.inSMaskMode) {
        copyCtxState(this.ctx, this.suspendedCtx);
        this.suspendedCtx.save();
      } else this.ctx.save();
      const t2 = this.current;
      this.stateStack.push(t2);
      this.current = t2.clone();
    }
    restore() {
      0 === this.stateStack.length && this.inSMaskMode && this.endSMaskMode();
      if (0 !== this.stateStack.length) {
        this.current = this.stateStack.pop();
        if (this.inSMaskMode) {
          this.suspendedCtx.restore();
          copyCtxState(this.suspendedCtx, this.ctx);
        } else this.ctx.restore();
        this.checkSMaskState();
        this.pendingClip = null;
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
      }
    }
    transform(t2, e2, i2, s2, n2, r2) {
      this.ctx.transform(t2, e2, i2, s2, n2, r2);
      this._cachedScaleForStroking[0] = -1;
      this._cachedGetSinglePixelWidth = null;
    }
    constructPath(t2, e2, i2) {
      const s2 = this.ctx, n2 = this.current;
      let r2, a2, o2 = n2.x, l2 = n2.y;
      const h2 = getCurrentTransform(s2), c2 = 0 === h2[0] && 0 === h2[3] || 0 === h2[1] && 0 === h2[2], d2 = c2 ? i2.slice(0) : null;
      for (let i3 = 0, u2 = 0, p2 = t2.length; i3 < p2; i3++) switch (0 | t2[i3]) {
        case Y.rectangle:
          o2 = e2[u2++];
          l2 = e2[u2++];
          const t3 = e2[u2++], i4 = e2[u2++], p3 = o2 + t3, g2 = l2 + i4;
          s2.moveTo(o2, l2);
          if (0 === t3 || 0 === i4) s2.lineTo(p3, g2);
          else {
            s2.lineTo(p3, l2);
            s2.lineTo(p3, g2);
            s2.lineTo(o2, g2);
          }
          c2 || n2.updateRectMinMax(h2, [
            o2,
            l2,
            p3,
            g2
          ]);
          s2.closePath();
          break;
        case Y.moveTo:
          o2 = e2[u2++];
          l2 = e2[u2++];
          s2.moveTo(o2, l2);
          c2 || n2.updatePathMinMax(h2, o2, l2);
          break;
        case Y.lineTo:
          o2 = e2[u2++];
          l2 = e2[u2++];
          s2.lineTo(o2, l2);
          c2 || n2.updatePathMinMax(h2, o2, l2);
          break;
        case Y.curveTo:
          r2 = o2;
          a2 = l2;
          o2 = e2[u2 + 4];
          l2 = e2[u2 + 5];
          s2.bezierCurveTo(e2[u2], e2[u2 + 1], e2[u2 + 2], e2[u2 + 3], o2, l2);
          n2.updateCurvePathMinMax(h2, r2, a2, e2[u2], e2[u2 + 1], e2[u2 + 2], e2[u2 + 3], o2, l2, d2);
          u2 += 6;
          break;
        case Y.curveTo2:
          r2 = o2;
          a2 = l2;
          s2.bezierCurveTo(o2, l2, e2[u2], e2[u2 + 1], e2[u2 + 2], e2[u2 + 3]);
          n2.updateCurvePathMinMax(h2, r2, a2, o2, l2, e2[u2], e2[u2 + 1], e2[u2 + 2], e2[u2 + 3], d2);
          o2 = e2[u2 + 2];
          l2 = e2[u2 + 3];
          u2 += 4;
          break;
        case Y.curveTo3:
          r2 = o2;
          a2 = l2;
          o2 = e2[u2 + 2];
          l2 = e2[u2 + 3];
          s2.bezierCurveTo(e2[u2], e2[u2 + 1], o2, l2, o2, l2);
          n2.updateCurvePathMinMax(h2, r2, a2, e2[u2], e2[u2 + 1], o2, l2, o2, l2, d2);
          u2 += 4;
          break;
        case Y.closePath:
          s2.closePath();
      }
      c2 && n2.updateScalingPathMinMax(h2, d2);
      n2.setCurrentPoint(o2, l2);
    }
    closePath() {
      this.ctx.closePath();
    }
    stroke(t2 = true) {
      const e2 = this.ctx, i2 = this.current.strokeColor;
      e2.globalAlpha = this.current.strokeAlpha;
      if (this.contentVisible) if ("object" == typeof i2 && (i2 == null ? void 0 : i2.getPattern)) {
        e2.save();
        e2.strokeStyle = i2.getPattern(e2, this, getCurrentTransformInverse(e2), wt);
        this.rescaleAndStroke(false);
        e2.restore();
      } else this.rescaleAndStroke(true);
      t2 && this.consumePath(this.current.getClippedPathBoundingBox());
      e2.globalAlpha = this.current.fillAlpha;
    }
    closeStroke() {
      this.closePath();
      this.stroke();
    }
    fill(t2 = true) {
      const e2 = this.ctx, i2 = this.current.fillColor;
      let s2 = false;
      if (this.current.patternFill) {
        e2.save();
        e2.fillStyle = i2.getPattern(e2, this, getCurrentTransformInverse(e2), At);
        s2 = true;
      }
      const n2 = this.current.getClippedPathBoundingBox();
      if (this.contentVisible && null !== n2) if (this.pendingEOFill) {
        e2.fill("evenodd");
        this.pendingEOFill = false;
      } else e2.fill();
      s2 && e2.restore();
      t2 && this.consumePath(n2);
    }
    eoFill() {
      this.pendingEOFill = true;
      this.fill();
    }
    fillStroke() {
      this.fill(false);
      this.stroke(false);
      this.consumePath();
    }
    eoFillStroke() {
      this.pendingEOFill = true;
      this.fillStroke();
    }
    closeFillStroke() {
      this.closePath();
      this.fillStroke();
    }
    closeEOFillStroke() {
      this.pendingEOFill = true;
      this.closePath();
      this.fillStroke();
    }
    endPath() {
      this.consumePath();
    }
    clip() {
      this.pendingClip = Mt;
    }
    eoClip() {
      this.pendingClip = kt;
    }
    beginText() {
      this.current.textMatrix = s;
      this.current.textMatrixScale = 1;
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    }
    endText() {
      const t2 = this.pendingTextPaths, e2 = this.ctx;
      if (void 0 !== t2) {
        e2.save();
        e2.beginPath();
        for (const i2 of t2) {
          e2.setTransform(...i2.transform);
          e2.translate(i2.x, i2.y);
          i2.addToPath(e2, i2.fontSize);
        }
        e2.restore();
        e2.clip();
        e2.beginPath();
        delete this.pendingTextPaths;
      } else e2.beginPath();
    }
    setCharSpacing(t2) {
      this.current.charSpacing = t2;
    }
    setWordSpacing(t2) {
      this.current.wordSpacing = t2;
    }
    setHScale(t2) {
      this.current.textHScale = t2 / 100;
    }
    setLeading(t2) {
      this.current.leading = -t2;
    }
    setFont(t2, e2) {
      var _a4;
      const i2 = this.commonObjs.get(t2), s2 = this.current;
      if (!i2) throw new Error(`Can't find font for ${t2}`);
      s2.fontMatrix = i2.fontMatrix || n;
      0 !== s2.fontMatrix[0] && 0 !== s2.fontMatrix[3] || warn("Invalid font matrix for font " + t2);
      if (e2 < 0) {
        e2 = -e2;
        s2.fontDirection = -1;
      } else s2.fontDirection = 1;
      this.current.font = i2;
      this.current.fontSize = e2;
      if (i2.isType3Font) return;
      const r2 = i2.loadedName || "sans-serif", a2 = ((_a4 = i2.systemFontInfo) == null ? void 0 : _a4.css) || `"${r2}", ${i2.fallbackName}`;
      let o2 = "normal";
      i2.black ? o2 = "900" : i2.bold && (o2 = "bold");
      const l2 = i2.italic ? "italic" : "normal";
      let h2 = e2;
      e2 < 16 ? h2 = 16 : e2 > 100 && (h2 = 100);
      this.current.fontSizeScale = e2 / h2;
      this.ctx.font = `${l2} ${o2} ${h2}px ${a2}`;
    }
    setTextRenderingMode(t2) {
      this.current.textRenderingMode = t2;
    }
    setTextRise(t2) {
      this.current.textRise = t2;
    }
    moveText(t2, e2) {
      this.current.x = this.current.lineX += t2;
      this.current.y = this.current.lineY += e2;
    }
    setLeadingMoveText(t2, e2) {
      this.setLeading(-e2);
      this.moveText(t2, e2);
    }
    setTextMatrix(t2, e2, i2, s2, n2, r2) {
      this.current.textMatrix = [
        t2,
        e2,
        i2,
        s2,
        n2,
        r2
      ];
      this.current.textMatrixScale = Math.hypot(t2, e2);
      this.current.x = this.current.lineX = 0;
      this.current.y = this.current.lineY = 0;
    }
    nextLine() {
      this.moveText(0, this.current.leading);
    }
    paintChar(t2, e2, i2, s2) {
      const n2 = this.ctx, r2 = this.current, a2 = r2.font, o2 = r2.textRenderingMode, l2 = r2.fontSize / r2.fontSizeScale, h2 = o2 & x, c2 = !!(o2 & _), d2 = r2.patternFill && !a2.missingFile;
      let u2;
      (a2.disableFontFace || c2 || d2) && (u2 = a2.getPathGenerator(this.commonObjs, t2));
      if (a2.disableFontFace || d2) {
        n2.save();
        n2.translate(e2, i2);
        n2.beginPath();
        u2(n2, l2);
        s2 && n2.setTransform(...s2);
        h2 !== v && h2 !== A || n2.fill();
        h2 !== y && h2 !== A || n2.stroke();
        n2.restore();
      } else {
        h2 !== v && h2 !== A || n2.fillText(t2, e2, i2);
        h2 !== y && h2 !== A || n2.strokeText(t2, e2, i2);
      }
      if (c2) {
        (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
          transform: getCurrentTransform(n2),
          x: e2,
          y: i2,
          fontSize: l2,
          addToPath: u2
        });
      }
    }
    get isFontSubpixelAAEnabled() {
      const { context: t2 } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
      t2.scale(1.5, 1);
      t2.fillText("I", 0, 10);
      const e2 = t2.getImageData(0, 0, 10, 10).data;
      let i2 = false;
      for (let t3 = 3; t3 < e2.length; t3 += 4) if (e2[t3] > 0 && e2[t3] < 255) {
        i2 = true;
        break;
      }
      return shadow(this, "isFontSubpixelAAEnabled", i2);
    }
    showText(t2) {
      const e2 = this.current, i2 = e2.font;
      if (i2.isType3Font) return this.showType3Text(t2);
      const s2 = e2.fontSize;
      if (0 === s2) return;
      const n2 = this.ctx, r2 = e2.fontSizeScale, a2 = e2.charSpacing, o2 = e2.wordSpacing, l2 = e2.fontDirection, h2 = e2.textHScale * l2, c2 = t2.length, d2 = i2.vertical, u2 = d2 ? 1 : -1, p2 = i2.defaultVMetrics, g2 = s2 * e2.fontMatrix[0], f2 = e2.textRenderingMode === v && !i2.disableFontFace && !e2.patternFill;
      n2.save();
      n2.transform(...e2.textMatrix);
      n2.translate(e2.x, e2.y + e2.textRise);
      l2 > 0 ? n2.scale(h2, -1) : n2.scale(h2, 1);
      let m2;
      if (e2.patternFill) {
        n2.save();
        const t3 = e2.fillColor.getPattern(n2, this, getCurrentTransformInverse(n2), At);
        m2 = getCurrentTransform(n2);
        n2.restore();
        n2.fillStyle = t3;
      }
      let b2 = e2.lineWidth;
      const w2 = e2.textMatrixScale;
      if (0 === w2 || 0 === b2) {
        const t3 = e2.textRenderingMode & x;
        t3 !== y && t3 !== A || (b2 = this.getSinglePixelWidth());
      } else b2 /= w2;
      if (1 !== r2) {
        n2.scale(r2, r2);
        b2 /= r2;
      }
      n2.lineWidth = b2;
      if (i2.isInvalidPDFjsFont) {
        const i3 = [];
        let s3 = 0;
        for (const e3 of t2) {
          i3.push(e3.unicode);
          s3 += e3.width;
        }
        n2.fillText(i3.join(""), 0, 0);
        e2.x += s3 * g2 * h2;
        n2.restore();
        this.compose();
        return;
      }
      let _2, E2 = 0;
      for (_2 = 0; _2 < c2; ++_2) {
        const e3 = t2[_2];
        if ("number" == typeof e3) {
          E2 += u2 * e3 * s2 / 1e3;
          continue;
        }
        let h3 = false;
        const c3 = (e3.isSpace ? o2 : 0) + a2, b3 = e3.fontChar, v2 = e3.accent;
        let y2, A2, w3 = e3.width;
        if (d2) {
          const t3 = e3.vmetric || p2, i3 = -(e3.vmetric ? t3[1] : 0.5 * w3) * g2, s3 = t3[2] * g2;
          w3 = t3 ? -t3[0] : w3;
          y2 = i3 / r2;
          A2 = (E2 + s3) / r2;
        } else {
          y2 = E2 / r2;
          A2 = 0;
        }
        if (i2.remeasure && w3 > 0) {
          const t3 = 1e3 * n2.measureText(b3).width / s2 * r2;
          if (w3 < t3 && this.isFontSubpixelAAEnabled) {
            const e4 = w3 / t3;
            h3 = true;
            n2.save();
            n2.scale(e4, 1);
            y2 /= e4;
          } else w3 !== t3 && (y2 += (w3 - t3) / 2e3 * s2 / r2);
        }
        if (this.contentVisible && (e3.isInFont || i2.missingFile)) if (f2 && !v2) n2.fillText(b3, y2, A2);
        else {
          this.paintChar(b3, y2, A2, m2);
          if (v2) {
            const t3 = y2 + s2 * v2.offset.x / r2, e4 = A2 - s2 * v2.offset.y / r2;
            this.paintChar(v2.fontChar, t3, e4, m2);
          }
        }
        E2 += d2 ? w3 * g2 - c3 * l2 : w3 * g2 + c3 * l2;
        h3 && n2.restore();
      }
      d2 ? e2.y -= E2 : e2.x += E2 * h2;
      n2.restore();
      this.compose();
    }
    showType3Text(t2) {
      const e2 = this.ctx, i2 = this.current, s2 = i2.font, r2 = i2.fontSize, a2 = i2.fontDirection, o2 = s2.vertical ? 1 : -1, l2 = i2.charSpacing, h2 = i2.wordSpacing, c2 = i2.textHScale * a2, d2 = i2.fontMatrix || n, u2 = t2.length;
      let p2, g2, f2, m2;
      if (!(i2.textRenderingMode === w) && 0 !== r2) {
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
        e2.save();
        e2.transform(...i2.textMatrix);
        e2.translate(i2.x, i2.y);
        e2.scale(c2, a2);
        for (p2 = 0; p2 < u2; ++p2) {
          g2 = t2[p2];
          if ("number" == typeof g2) {
            m2 = o2 * g2 * r2 / 1e3;
            this.ctx.translate(m2, 0);
            i2.x += m2 * c2;
            continue;
          }
          const n2 = (g2.isSpace ? h2 : 0) + l2, a3 = s2.charProcOperatorList[g2.operatorListId];
          if (!a3) {
            warn(`Type3 character "${g2.operatorListId}" is not available.`);
            continue;
          }
          if (this.contentVisible) {
            this.processingType3 = g2;
            this.save();
            e2.scale(r2, r2);
            e2.transform(...d2);
            this.executeOperatorList(a3);
            this.restore();
          }
          f2 = Util.applyTransform([
            g2.width,
            0
          ], d2)[0] * r2 + n2;
          e2.translate(f2, 0);
          i2.x += f2 * c2;
        }
        e2.restore();
        this.processingType3 = null;
      }
    }
    setCharWidth(t2, e2) {
    }
    setCharWidthAndBounds(t2, e2, i2, s2, n2, r2) {
      this.ctx.rect(i2, s2, n2 - i2, r2 - s2);
      this.ctx.clip();
      this.endPath();
    }
    getColorN_Pattern(t2) {
      let e2;
      if ("TilingPattern" === t2[0]) {
        const i2 = t2[1], s2 = this.baseTransform || getCurrentTransform(this.ctx), n2 = {
          createCanvasGraphics: (t3) => new _CanvasGraphics(t3, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
            optionalContentConfig: this.optionalContentConfig,
            markedContentStack: this.markedContentStack
          })
        };
        e2 = new TilingPattern(t2, i2, this.ctx, n2, s2);
      } else e2 = this._getPattern(t2[1], t2[2]);
      return e2;
    }
    setStrokeColorN() {
      this.current.strokeColor = this.getColorN_Pattern(arguments);
    }
    setFillColorN() {
      this.current.fillColor = this.getColorN_Pattern(arguments);
      this.current.patternFill = true;
    }
    setStrokeRGBColor(t2, e2, i2) {
      this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(t2, e2, i2);
    }
    setStrokeTransparent() {
      this.ctx.strokeStyle = this.current.strokeColor = "transparent";
    }
    setFillRGBColor(t2, e2, i2) {
      this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(t2, e2, i2);
      this.current.patternFill = false;
    }
    setFillTransparent() {
      this.ctx.fillStyle = this.current.fillColor = "transparent";
      this.current.patternFill = false;
    }
    _getPattern(t2, e2 = null) {
      let i2;
      if (this.cachedPatterns.has(t2)) i2 = this.cachedPatterns.get(t2);
      else {
        i2 = function getShadingPattern(t3) {
          switch (t3[0]) {
            case "RadialAxial":
              return new RadialAxialShadingPattern(t3);
            case "Mesh":
              return new MeshShadingPattern(t3);
            case "Dummy":
              return new DummyShadingPattern();
          }
          throw new Error(`Unknown IR type: ${t3[0]}`);
        }(this.getObject(t2));
        this.cachedPatterns.set(t2, i2);
      }
      e2 && (i2.matrix = e2);
      return i2;
    }
    shadingFill(t2) {
      if (!this.contentVisible) return;
      const e2 = this.ctx;
      this.save();
      const i2 = this._getPattern(t2);
      e2.fillStyle = i2.getPattern(e2, this, getCurrentTransformInverse(e2), xt);
      const s2 = getCurrentTransformInverse(e2);
      if (s2) {
        const { width: t3, height: i3 } = e2.canvas, [n2, r2, a2, o2] = Util.getAxialAlignedBoundingBox([
          0,
          0,
          t3,
          i3
        ], s2);
        this.ctx.fillRect(n2, r2, a2 - n2, o2 - r2);
      } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
      this.compose(this.current.getClippedPathBoundingBox());
      this.restore();
    }
    beginInlineImage() {
      unreachable("Should not call beginInlineImage");
    }
    beginImageData() {
      unreachable("Should not call beginImageData");
    }
    paintFormXObjectBegin(t2, e2) {
      if (this.contentVisible) {
        this.save();
        this.baseTransformStack.push(this.baseTransform);
        t2 && this.transform(...t2);
        this.baseTransform = getCurrentTransform(this.ctx);
        if (e2) {
          const t3 = e2[2] - e2[0], i2 = e2[3] - e2[1];
          this.ctx.rect(e2[0], e2[1], t3, i2);
          this.current.updateRectMinMax(getCurrentTransform(this.ctx), e2);
          this.clip();
          this.endPath();
        }
      }
    }
    paintFormXObjectEnd() {
      if (this.contentVisible) {
        this.restore();
        this.baseTransform = this.baseTransformStack.pop();
      }
    }
    beginGroup(t2) {
      if (!this.contentVisible) return;
      this.save();
      if (this.inSMaskMode) {
        this.endSMaskMode();
        this.current.activeSMask = null;
      }
      const e2 = this.ctx;
      t2.isolated || info("TODO: Support non-isolated groups.");
      t2.knockout && warn("Knockout groups not supported.");
      const i2 = getCurrentTransform(e2);
      t2.matrix && e2.transform(...t2.matrix);
      if (!t2.bbox) throw new Error("Bounding box is required.");
      let s2 = Util.getAxialAlignedBoundingBox(t2.bbox, getCurrentTransform(e2));
      const n2 = [
        0,
        0,
        e2.canvas.width,
        e2.canvas.height
      ];
      s2 = Util.intersect(s2, n2) || [
        0,
        0,
        0,
        0
      ];
      const r2 = Math.floor(s2[0]), a2 = Math.floor(s2[1]), o2 = Math.max(Math.ceil(s2[2]) - r2, 1), l2 = Math.max(Math.ceil(s2[3]) - a2, 1);
      this.current.startNewPathAndClipBox([
        0,
        0,
        o2,
        l2
      ]);
      let h2 = "groupAt" + this.groupLevel;
      t2.smask && (h2 += "_smask_" + this.smaskCounter++ % 2);
      const c2 = this.cachedCanvases.getCanvas(h2, o2, l2), d2 = c2.context;
      d2.translate(-r2, -a2);
      d2.transform(...i2);
      if (t2.smask) this.smaskStack.push({
        canvas: c2.canvas,
        context: d2,
        offsetX: r2,
        offsetY: a2,
        subtype: t2.smask.subtype,
        backdrop: t2.smask.backdrop,
        transferMap: t2.smask.transferMap || null,
        startTransformInverse: null
      });
      else {
        e2.setTransform(1, 0, 0, 1, 0, 0);
        e2.translate(r2, a2);
        e2.save();
      }
      copyCtxState(e2, d2);
      this.ctx = d2;
      this.setGState([
        [
          "BM",
          "source-over"
        ],
        [
          "ca",
          1
        ],
        [
          "CA",
          1
        ]
      ]);
      this.groupStack.push(e2);
      this.groupLevel++;
    }
    endGroup(t2) {
      if (!this.contentVisible) return;
      this.groupLevel--;
      const e2 = this.ctx, i2 = this.groupStack.pop();
      this.ctx = i2;
      this.ctx.imageSmoothingEnabled = false;
      if (t2.smask) {
        this.tempSMask = this.smaskStack.pop();
        this.restore();
      } else {
        this.ctx.restore();
        const t3 = getCurrentTransform(this.ctx);
        this.restore();
        this.ctx.save();
        this.ctx.setTransform(...t3);
        const i3 = Util.getAxialAlignedBoundingBox([
          0,
          0,
          e2.canvas.width,
          e2.canvas.height
        ], t3);
        this.ctx.drawImage(e2.canvas, 0, 0);
        this.ctx.restore();
        this.compose(i3);
      }
    }
    beginAnnotation(t2, e2, i2, s2, n2) {
      __privateMethod(this, _CanvasGraphics_instances, Oe_fn).call(this);
      resetCtxToDefault(this.ctx);
      this.ctx.save();
      this.save();
      this.baseTransform && this.ctx.setTransform(...this.baseTransform);
      if (e2) {
        const s3 = e2[2] - e2[0], r2 = e2[3] - e2[1];
        if (n2 && this.annotationCanvasMap) {
          (i2 = i2.slice())[4] -= e2[0];
          i2[5] -= e2[1];
          (e2 = e2.slice())[0] = e2[1] = 0;
          e2[2] = s3;
          e2[3] = r2;
          const [n3, a2] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx)), { viewportScale: o2 } = this, l2 = Math.ceil(s3 * this.outputScaleX * o2), h2 = Math.ceil(r2 * this.outputScaleY * o2);
          this.annotationCanvas = this.canvasFactory.create(l2, h2);
          const { canvas: c2, context: d2 } = this.annotationCanvas;
          this.annotationCanvasMap.set(t2, c2);
          this.annotationCanvas.savedCtx = this.ctx;
          this.ctx = d2;
          this.ctx.save();
          this.ctx.setTransform(n3, 0, 0, -a2, 0, r2 * a2);
          resetCtxToDefault(this.ctx);
        } else {
          resetCtxToDefault(this.ctx);
          this.endPath();
          this.ctx.rect(e2[0], e2[1], s3, r2);
          this.ctx.clip();
          this.ctx.beginPath();
        }
      }
      this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
      this.transform(...i2);
      this.transform(...s2);
    }
    endAnnotation() {
      if (this.annotationCanvas) {
        this.ctx.restore();
        __privateMethod(this, _CanvasGraphics_instances, Ne_fn).call(this);
        this.ctx = this.annotationCanvas.savedCtx;
        delete this.annotationCanvas.savedCtx;
        delete this.annotationCanvas;
      }
    }
    paintImageMaskXObject(t2) {
      if (!this.contentVisible) return;
      const e2 = t2.count;
      (t2 = this.getObject(t2.data, t2)).count = e2;
      const i2 = this.ctx, s2 = this.processingType3;
      if (s2) {
        void 0 === s2.compiled && (s2.compiled = function compileType3Glyph(t3) {
          const { width: e3, height: i3 } = t3;
          if (e3 > 1e3 || i3 > 1e3) return null;
          const s3 = new Uint8Array([
            0,
            2,
            4,
            0,
            1,
            0,
            5,
            4,
            8,
            10,
            0,
            8,
            0,
            2,
            1,
            0
          ]), n3 = e3 + 1;
          let r3, a2, o2, l2 = new Uint8Array(n3 * (i3 + 1));
          const h2 = e3 + 7 & -8;
          let c2 = new Uint8Array(h2 * i3), d2 = 0;
          for (const e4 of t3.data) {
            let t4 = 128;
            for (; t4 > 0; ) {
              c2[d2++] = e4 & t4 ? 0 : 255;
              t4 >>= 1;
            }
          }
          let u2 = 0;
          d2 = 0;
          if (0 !== c2[d2]) {
            l2[0] = 1;
            ++u2;
          }
          for (a2 = 1; a2 < e3; a2++) {
            if (c2[d2] !== c2[d2 + 1]) {
              l2[a2] = c2[d2] ? 2 : 1;
              ++u2;
            }
            d2++;
          }
          if (0 !== c2[d2]) {
            l2[a2] = 2;
            ++u2;
          }
          for (r3 = 1; r3 < i3; r3++) {
            d2 = r3 * h2;
            o2 = r3 * n3;
            if (c2[d2 - h2] !== c2[d2]) {
              l2[o2] = c2[d2] ? 1 : 8;
              ++u2;
            }
            let t4 = (c2[d2] ? 4 : 0) + (c2[d2 - h2] ? 8 : 0);
            for (a2 = 1; a2 < e3; a2++) {
              t4 = (t4 >> 2) + (c2[d2 + 1] ? 4 : 0) + (c2[d2 - h2 + 1] ? 8 : 0);
              if (s3[t4]) {
                l2[o2 + a2] = s3[t4];
                ++u2;
              }
              d2++;
            }
            if (c2[d2 - h2] !== c2[d2]) {
              l2[o2 + a2] = c2[d2] ? 2 : 4;
              ++u2;
            }
            if (u2 > 1e3) return null;
          }
          d2 = h2 * (i3 - 1);
          o2 = r3 * n3;
          if (0 !== c2[d2]) {
            l2[o2] = 8;
            ++u2;
          }
          for (a2 = 1; a2 < e3; a2++) {
            if (c2[d2] !== c2[d2 + 1]) {
              l2[o2 + a2] = c2[d2] ? 4 : 8;
              ++u2;
            }
            d2++;
          }
          if (0 !== c2[d2]) {
            l2[o2 + a2] = 4;
            ++u2;
          }
          if (u2 > 1e3) return null;
          const p2 = new Int32Array([
            0,
            n3,
            -1,
            0,
            -n3,
            0,
            0,
            0,
            1
          ]), g2 = new Path2D();
          for (r3 = 0; u2 && r3 <= i3; r3++) {
            let t4 = r3 * n3;
            const i4 = t4 + e3;
            for (; t4 < i4 && !l2[t4]; ) t4++;
            if (t4 === i4) continue;
            g2.moveTo(t4 % n3, r3);
            const s4 = t4;
            let a3 = l2[t4];
            do {
              const e4 = p2[a3];
              do {
                t4 += e4;
              } while (!l2[t4]);
              const i5 = l2[t4];
              if (5 !== i5 && 10 !== i5) {
                a3 = i5;
                l2[t4] = 0;
              } else {
                a3 = i5 & 51 * a3 >> 4;
                l2[t4] &= a3 >> 2 | a3 << 2;
              }
              g2.lineTo(t4 % n3, t4 / n3 | 0);
              l2[t4] || --u2;
            } while (s4 !== t4);
            --r3;
          }
          c2 = null;
          l2 = null;
          return function(t4) {
            t4.save();
            t4.scale(1 / e3, -1 / i3);
            t4.translate(0, -i3);
            t4.fill(g2);
            t4.beginPath();
            t4.restore();
          };
        }(t2));
        if (s2.compiled) {
          s2.compiled(i2);
          return;
        }
      }
      const n2 = this._createMaskCanvas(t2), r2 = n2.canvas;
      i2.save();
      i2.setTransform(1, 0, 0, 1, 0, 0);
      i2.drawImage(r2, n2.offsetX, n2.offsetY);
      i2.restore();
      this.compose();
    }
    paintImageMaskXObjectRepeat(t2, e2, i2 = 0, s2 = 0, n2, r2) {
      if (!this.contentVisible) return;
      t2 = this.getObject(t2.data, t2);
      const a2 = this.ctx;
      a2.save();
      const o2 = getCurrentTransform(a2);
      a2.transform(e2, i2, s2, n2, 0, 0);
      const l2 = this._createMaskCanvas(t2);
      a2.setTransform(1, 0, 0, 1, l2.offsetX - o2[4], l2.offsetY - o2[5]);
      for (let t3 = 0, h2 = r2.length; t3 < h2; t3 += 2) {
        const h3 = Util.transform(o2, [
          e2,
          i2,
          s2,
          n2,
          r2[t3],
          r2[t3 + 1]
        ]), [c2, d2] = Util.applyTransform([
          0,
          0
        ], h3);
        a2.drawImage(l2.canvas, c2, d2);
      }
      a2.restore();
      this.compose();
    }
    paintImageMaskXObjectGroup(t2) {
      if (!this.contentVisible) return;
      const e2 = this.ctx, i2 = this.current.fillColor, s2 = this.current.patternFill;
      for (const n2 of t2) {
        const { data: t3, width: r2, height: a2, transform: o2 } = n2, l2 = this.cachedCanvases.getCanvas("maskCanvas", r2, a2), h2 = l2.context;
        h2.save();
        putBinaryImageMask(h2, this.getObject(t3, n2));
        h2.globalCompositeOperation = "source-in";
        h2.fillStyle = s2 ? i2.getPattern(h2, this, getCurrentTransformInverse(e2), At) : i2;
        h2.fillRect(0, 0, r2, a2);
        h2.restore();
        e2.save();
        e2.transform(...o2);
        e2.scale(1, -1);
        drawImageAtIntegerCoords(e2, l2.canvas, 0, 0, r2, a2, 0, -1, 1, 1);
        e2.restore();
      }
      this.compose();
    }
    paintImageXObject(t2) {
      if (!this.contentVisible) return;
      const e2 = this.getObject(t2);
      e2 ? this.paintInlineImageXObject(e2) : warn("Dependent image isn't ready yet");
    }
    paintImageXObjectRepeat(t2, e2, i2, s2) {
      if (!this.contentVisible) return;
      const n2 = this.getObject(t2);
      if (!n2) {
        warn("Dependent image isn't ready yet");
        return;
      }
      const r2 = n2.width, a2 = n2.height, o2 = [];
      for (let t3 = 0, n3 = s2.length; t3 < n3; t3 += 2) o2.push({
        transform: [
          e2,
          0,
          0,
          i2,
          s2[t3],
          s2[t3 + 1]
        ],
        x: 0,
        y: 0,
        w: r2,
        h: a2
      });
      this.paintInlineImageXObjectGroup(n2, o2);
    }
    applyTransferMapsToCanvas(t2) {
      if ("none" !== this.current.transferMaps) {
        t2.filter = this.current.transferMaps;
        t2.drawImage(t2.canvas, 0, 0);
        t2.filter = "none";
      }
      return t2.canvas;
    }
    applyTransferMapsToBitmap(t2) {
      if ("none" === this.current.transferMaps) return t2.bitmap;
      const { bitmap: e2, width: i2, height: s2 } = t2, n2 = this.cachedCanvases.getCanvas("inlineImage", i2, s2), r2 = n2.context;
      r2.filter = this.current.transferMaps;
      r2.drawImage(e2, 0, 0);
      r2.filter = "none";
      return n2.canvas;
    }
    paintInlineImageXObject(t2) {
      if (!this.contentVisible) return;
      const e2 = t2.width, s2 = t2.height, n2 = this.ctx;
      this.save();
      if (!i) {
        const { filter: t3 } = n2;
        "none" !== t3 && "" !== t3 && (n2.filter = "none");
      }
      n2.scale(1 / e2, -1 / s2);
      let r2;
      if (t2.bitmap) r2 = this.applyTransferMapsToBitmap(t2);
      else if ("function" == typeof HTMLElement && t2 instanceof HTMLElement || !t2.data) r2 = t2;
      else {
        const i2 = this.cachedCanvases.getCanvas("inlineImage", e2, s2).context;
        putBinaryImageData(i2, t2);
        r2 = this.applyTransferMapsToCanvas(i2);
      }
      const a2 = this._scaleImage(r2, getCurrentTransformInverse(n2));
      n2.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(n2), t2.interpolate);
      drawImageAtIntegerCoords(n2, a2.img, 0, 0, a2.paintWidth, a2.paintHeight, 0, -s2, e2, s2);
      this.compose();
      this.restore();
    }
    paintInlineImageXObjectGroup(t2, e2) {
      if (!this.contentVisible) return;
      const i2 = this.ctx;
      let s2;
      if (t2.bitmap) s2 = t2.bitmap;
      else {
        const e3 = t2.width, i3 = t2.height, n2 = this.cachedCanvases.getCanvas("inlineImage", e3, i3).context;
        putBinaryImageData(n2, t2);
        s2 = this.applyTransferMapsToCanvas(n2);
      }
      for (const t3 of e2) {
        i2.save();
        i2.transform(...t3.transform);
        i2.scale(1, -1);
        drawImageAtIntegerCoords(i2, s2, t3.x, t3.y, t3.w, t3.h, 0, -1, 1, 1);
        i2.restore();
      }
      this.compose();
    }
    paintSolidColorImageMask() {
      if (this.contentVisible) {
        this.ctx.fillRect(0, 0, 1, 1);
        this.compose();
      }
    }
    markPoint(t2) {
    }
    markPointProps(t2, e2) {
    }
    beginMarkedContent(t2) {
      this.markedContentStack.push({
        visible: true
      });
    }
    beginMarkedContentProps(t2, e2) {
      "OC" === t2 ? this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(e2)
      }) : this.markedContentStack.push({
        visible: true
      });
      this.contentVisible = this.isContentVisible();
    }
    endMarkedContent() {
      this.markedContentStack.pop();
      this.contentVisible = this.isContentVisible();
    }
    beginCompat() {
    }
    endCompat() {
    }
    consumePath(t2) {
      const e2 = this.current.isEmptyClip();
      this.pendingClip && this.current.updateClipFromPath();
      this.pendingClip || this.compose(t2);
      const i2 = this.ctx;
      if (this.pendingClip) {
        e2 || (this.pendingClip === kt ? i2.clip("evenodd") : i2.clip());
        this.pendingClip = null;
      }
      this.current.startNewPathAndClipBox(this.current.clipBox);
      i2.beginPath();
    }
    getSinglePixelWidth() {
      if (!this._cachedGetSinglePixelWidth) {
        const t2 = getCurrentTransform(this.ctx);
        if (0 === t2[1] && 0 === t2[2]) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(t2[0]), Math.abs(t2[3]));
        else {
          const e2 = Math.abs(t2[0] * t2[3] - t2[2] * t2[1]), i2 = Math.hypot(t2[0], t2[2]), s2 = Math.hypot(t2[1], t2[3]);
          this._cachedGetSinglePixelWidth = Math.max(i2, s2) / e2;
        }
      }
      return this._cachedGetSinglePixelWidth;
    }
    getScaleForStroking() {
      if (-1 === this._cachedScaleForStroking[0]) {
        const { lineWidth: t2 } = this.current, { a: e2, b: i2, c: s2, d: n2 } = this.ctx.getTransform();
        let r2, a2;
        if (0 === i2 && 0 === s2) {
          const i3 = Math.abs(e2), s3 = Math.abs(n2);
          if (i3 === s3) if (0 === t2) r2 = a2 = 1 / i3;
          else {
            const e3 = i3 * t2;
            r2 = a2 = e3 < 1 ? 1 / e3 : 1;
          }
          else if (0 === t2) {
            r2 = 1 / i3;
            a2 = 1 / s3;
          } else {
            const e3 = i3 * t2, n3 = s3 * t2;
            r2 = e3 < 1 ? 1 / e3 : 1;
            a2 = n3 < 1 ? 1 / n3 : 1;
          }
        } else {
          const o2 = Math.abs(e2 * n2 - i2 * s2), l2 = Math.hypot(e2, i2), h2 = Math.hypot(s2, n2);
          if (0 === t2) {
            r2 = h2 / o2;
            a2 = l2 / o2;
          } else {
            const e3 = t2 * o2;
            r2 = h2 > e3 ? h2 / e3 : 1;
            a2 = l2 > e3 ? l2 / e3 : 1;
          }
        }
        this._cachedScaleForStroking[0] = r2;
        this._cachedScaleForStroking[1] = a2;
      }
      return this._cachedScaleForStroking;
    }
    rescaleAndStroke(t2) {
      const { ctx: e2 } = this, { lineWidth: i2 } = this.current, [s2, n2] = this.getScaleForStroking();
      e2.lineWidth = i2 || 1;
      if (1 === s2 && 1 === n2) {
        e2.stroke();
        return;
      }
      const r2 = e2.getLineDash();
      t2 && e2.save();
      e2.scale(s2, n2);
      if (r2.length > 0) {
        const t3 = Math.max(s2, n2);
        e2.setLineDash(r2.map((e3) => e3 / t3));
        e2.lineDashOffset /= t3;
      }
      e2.stroke();
      t2 && e2.restore();
    }
    isContentVisible() {
      for (let t2 = this.markedContentStack.length - 1; t2 >= 0; t2--) if (!this.markedContentStack[t2].visible) return false;
      return true;
    }
  };
  _CanvasGraphics_instances = new WeakSet();
  Oe_fn = function() {
    for (; this.stateStack.length || this.inSMaskMode; ) this.restore();
    this.current.activeSMask = null;
    this.ctx.restore();
    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }
  };
  Ne_fn = function() {
    if (this.pageColors) {
      const t2 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
      if ("none" !== t2) {
        const e2 = this.ctx.filter;
        this.ctx.filter = t2;
        this.ctx.drawImage(this.ctx.canvas, 0, 0);
        this.ctx.filter = e2;
      }
    }
  };
  let CanvasGraphics = _CanvasGraphics;
  for (const t2 in Y) void 0 !== CanvasGraphics.prototype[t2] && (CanvasGraphics.prototype[Y[t2]] = CanvasGraphics.prototype[t2]);
  class GlobalWorkerOptions {
    static get workerPort() {
      return __privateGet(this, _Be);
    }
    static set workerPort(t2) {
      if (!("undefined" != typeof Worker && t2 instanceof Worker) && null !== t2) throw new Error("Invalid `workerPort` type.");
      __privateSet(this, _Be, t2);
    }
    static get workerSrc() {
      return __privateGet(this, _He);
    }
    static set workerSrc(t2) {
      if ("string" != typeof t2) throw new Error("Invalid `workerSrc` type.");
      __privateSet(this, _He, t2);
    }
  }
  _Be = new WeakMap();
  _He = new WeakMap();
  __privateAdd(GlobalWorkerOptions, _Be, null);
  __privateAdd(GlobalWorkerOptions, _He, "");
  const Pt = 1, Rt = 2, Dt = 1, It = 2, Ft = 3, Lt = 4, Ot = 5, Nt = 6, Bt = 7, Ht = 8;
  function wrapReason(t2) {
    t2 instanceof Error || "object" == typeof t2 && null !== t2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    switch (t2.name) {
      case "AbortException":
        return new AbortException(t2.message);
      case "MissingPDFException":
        return new MissingPDFException(t2.message);
      case "PasswordException":
        return new PasswordException(t2.message, t2.code);
      case "UnexpectedResponseException":
        return new UnexpectedResponseException(t2.message, t2.status);
      case "UnknownErrorException":
        return new UnknownErrorException(t2.message, t2.details);
      default:
        return new UnknownErrorException(t2.message, t2.toString());
    }
  }
  class MessageHandler {
    constructor(t2, e2, i2) {
      __privateAdd(this, _MessageHandler_instances);
      __privateAdd(this, _Ue, new AbortController());
      this.sourceName = t2;
      this.targetName = e2;
      this.comObj = i2;
      this.callbackId = 1;
      this.streamId = 1;
      this.streamSinks = /* @__PURE__ */ Object.create(null);
      this.streamControllers = /* @__PURE__ */ Object.create(null);
      this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
      this.actionHandler = /* @__PURE__ */ Object.create(null);
      i2.addEventListener("message", __privateMethod(this, _MessageHandler_instances, ze_fn).bind(this), {
        signal: __privateGet(this, _Ue).signal
      });
    }
    on(t2, e2) {
      const i2 = this.actionHandler;
      if (i2[t2]) throw new Error(`There is already an actionName called "${t2}"`);
      i2[t2] = e2;
    }
    send(t2, e2, i2) {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: t2,
        data: e2
      }, i2);
    }
    sendWithPromise(t2, e2, i2) {
      const s2 = this.callbackId++, n2 = Promise.withResolvers();
      this.callbackCapabilities[s2] = n2;
      try {
        this.comObj.postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: t2,
          callbackId: s2,
          data: e2
        }, i2);
      } catch (t3) {
        n2.reject(t3);
      }
      return n2.promise;
    }
    sendWithStream(t2, e2, i2, s2) {
      const n2 = this.streamId++, r2 = this.sourceName, a2 = this.targetName, o2 = this.comObj;
      return new ReadableStream({
        start: (i3) => {
          const l2 = Promise.withResolvers();
          this.streamControllers[n2] = {
            controller: i3,
            startCall: l2,
            pullCall: null,
            cancelCall: null,
            isClosed: false
          };
          o2.postMessage({
            sourceName: r2,
            targetName: a2,
            action: t2,
            streamId: n2,
            data: e2,
            desiredSize: i3.desiredSize
          }, s2);
          return l2.promise;
        },
        pull: (t3) => {
          const e3 = Promise.withResolvers();
          this.streamControllers[n2].pullCall = e3;
          o2.postMessage({
            sourceName: r2,
            targetName: a2,
            stream: Nt,
            streamId: n2,
            desiredSize: t3.desiredSize
          });
          return e3.promise;
        },
        cancel: (t3) => {
          assert(t3 instanceof Error, "cancel must have a valid reason");
          const e3 = Promise.withResolvers();
          this.streamControllers[n2].cancelCall = e3;
          this.streamControllers[n2].isClosed = true;
          o2.postMessage({
            sourceName: r2,
            targetName: a2,
            stream: Dt,
            streamId: n2,
            reason: wrapReason(t3)
          });
          return e3.promise;
        }
      }, i2);
    }
    destroy() {
      var _a4;
      (_a4 = __privateGet(this, _Ue)) == null ? void 0 : _a4.abort();
      __privateSet(this, _Ue, null);
    }
  }
  _Ue = new WeakMap();
  _MessageHandler_instances = new WeakSet();
  ze_fn = function({ data: t2 }) {
    if (t2.targetName !== this.sourceName) return;
    if (t2.stream) {
      __privateMethod(this, _MessageHandler_instances, je_fn).call(this, t2);
      return;
    }
    if (t2.callback) {
      const e3 = t2.callbackId, i2 = this.callbackCapabilities[e3];
      if (!i2) throw new Error(`Cannot resolve callback ${e3}`);
      delete this.callbackCapabilities[e3];
      if (t2.callback === Pt) i2.resolve(t2.data);
      else {
        if (t2.callback !== Rt) throw new Error("Unexpected callback case");
        i2.reject(wrapReason(t2.reason));
      }
      return;
    }
    const e2 = this.actionHandler[t2.action];
    if (!e2) throw new Error(`Unknown action from worker: ${t2.action}`);
    if (t2.callbackId) {
      const i2 = this.sourceName, s2 = t2.sourceName, n2 = this.comObj;
      new Promise(function(i3) {
        i3(e2(t2.data));
      }).then(function(e3) {
        n2.postMessage({
          sourceName: i2,
          targetName: s2,
          callback: Pt,
          callbackId: t2.callbackId,
          data: e3
        });
      }, function(e3) {
        n2.postMessage({
          sourceName: i2,
          targetName: s2,
          callback: Rt,
          callbackId: t2.callbackId,
          reason: wrapReason(e3)
        });
      });
    } else t2.streamId ? __privateMethod(this, _MessageHandler_instances, We_fn).call(this, t2) : e2(t2.data);
  };
  We_fn = function(t2) {
    const e2 = t2.streamId, i2 = this.sourceName, s2 = t2.sourceName, n2 = this.comObj, r2 = this, a2 = this.actionHandler[t2.action], o2 = {
      enqueue(t3, r3 = 1, a3) {
        if (this.isCancelled) return;
        const o3 = this.desiredSize;
        this.desiredSize -= r3;
        if (o3 > 0 && this.desiredSize <= 0) {
          this.sinkCapability = Promise.withResolvers();
          this.ready = this.sinkCapability.promise;
        }
        n2.postMessage({
          sourceName: i2,
          targetName: s2,
          stream: Lt,
          streamId: e2,
          chunk: t3
        }, a3);
      },
      close() {
        if (!this.isCancelled) {
          this.isCancelled = true;
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: Ft,
            streamId: e2
          });
          delete r2.streamSinks[e2];
        }
      },
      error(t3) {
        assert(t3 instanceof Error, "error must have a valid reason");
        if (!this.isCancelled) {
          this.isCancelled = true;
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: Ot,
            streamId: e2,
            reason: wrapReason(t3)
          });
        }
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: t2.desiredSize,
      ready: null
    };
    o2.sinkCapability.resolve();
    o2.ready = o2.sinkCapability.promise;
    this.streamSinks[e2] = o2;
    new Promise(function(e3) {
      e3(a2(t2.data, o2));
    }).then(function() {
      n2.postMessage({
        sourceName: i2,
        targetName: s2,
        stream: Ht,
        streamId: e2,
        success: true
      });
    }, function(t3) {
      n2.postMessage({
        sourceName: i2,
        targetName: s2,
        stream: Ht,
        streamId: e2,
        reason: wrapReason(t3)
      });
    });
  };
  je_fn = function(t2) {
    const e2 = t2.streamId, i2 = this.sourceName, s2 = t2.sourceName, n2 = this.comObj, r2 = this.streamControllers[e2], a2 = this.streamSinks[e2];
    switch (t2.stream) {
      case Ht:
        t2.success ? r2.startCall.resolve() : r2.startCall.reject(wrapReason(t2.reason));
        break;
      case Bt:
        t2.success ? r2.pullCall.resolve() : r2.pullCall.reject(wrapReason(t2.reason));
        break;
      case Nt:
        if (!a2) {
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: Bt,
            streamId: e2,
            success: true
          });
          break;
        }
        a2.desiredSize <= 0 && t2.desiredSize > 0 && a2.sinkCapability.resolve();
        a2.desiredSize = t2.desiredSize;
        new Promise(function(t3) {
          var _a4;
          t3((_a4 = a2.onPull) == null ? void 0 : _a4.call(a2));
        }).then(function() {
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: Bt,
            streamId: e2,
            success: true
          });
        }, function(t3) {
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: Bt,
            streamId: e2,
            reason: wrapReason(t3)
          });
        });
        break;
      case Lt:
        assert(r2, "enqueue should have stream controller");
        if (r2.isClosed) break;
        r2.controller.enqueue(t2.chunk);
        break;
      case Ft:
        assert(r2, "close should have stream controller");
        if (r2.isClosed) break;
        r2.isClosed = true;
        r2.controller.close();
        __privateMethod(this, _MessageHandler_instances, Ge_fn).call(this, r2, e2);
        break;
      case Ot:
        assert(r2, "error should have stream controller");
        r2.controller.error(wrapReason(t2.reason));
        __privateMethod(this, _MessageHandler_instances, Ge_fn).call(this, r2, e2);
        break;
      case It:
        t2.success ? r2.cancelCall.resolve() : r2.cancelCall.reject(wrapReason(t2.reason));
        __privateMethod(this, _MessageHandler_instances, Ge_fn).call(this, r2, e2);
        break;
      case Dt:
        if (!a2) break;
        new Promise(function(e3) {
          var _a4;
          e3((_a4 = a2.onCancel) == null ? void 0 : _a4.call(a2, wrapReason(t2.reason)));
        }).then(function() {
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: It,
            streamId: e2,
            success: true
          });
        }, function(t3) {
          n2.postMessage({
            sourceName: i2,
            targetName: s2,
            stream: It,
            streamId: e2,
            reason: wrapReason(t3)
          });
        });
        a2.sinkCapability.reject(wrapReason(t2.reason));
        a2.isCancelled = true;
        delete this.streamSinks[e2];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  };
  Ge_fn = async function(t2, e2) {
    var _a4, _b2, _c;
    await Promise.allSettled([
      (_a4 = t2.startCall) == null ? void 0 : _a4.promise,
      (_b2 = t2.pullCall) == null ? void 0 : _b2.promise,
      (_c = t2.cancelCall) == null ? void 0 : _c.promise
    ]);
    delete this.streamControllers[e2];
  };
  class Metadata {
    constructor({ parsedData: t2, rawData: e2 }) {
      __privateAdd(this, _Ve);
      __privateAdd(this, _$e);
      __privateSet(this, _Ve, t2);
      __privateSet(this, _$e, e2);
    }
    getRaw() {
      return __privateGet(this, _$e);
    }
    get(t2) {
      return __privateGet(this, _Ve).get(t2) ?? null;
    }
    getAll() {
      return objectFromMap(__privateGet(this, _Ve));
    }
    has(t2) {
      return __privateGet(this, _Ve).has(t2);
    }
  }
  _Ve = new WeakMap();
  _$e = new WeakMap();
  const Ut = Symbol("INTERNAL");
  class OptionalContentGroup {
    constructor(t2, { name: e2, intent: i2, usage: s2, rbGroups: n2 }) {
      __privateAdd(this, _qe, false);
      __privateAdd(this, _Xe, false);
      __privateAdd(this, _Ke, false);
      __privateAdd(this, _Ye, true);
      __privateSet(this, _qe, !!(t2 & o));
      __privateSet(this, _Xe, !!(t2 & l));
      this.name = e2;
      this.intent = i2;
      this.usage = s2;
      this.rbGroups = n2;
    }
    get visible() {
      if (__privateGet(this, _Ke)) return __privateGet(this, _Ye);
      if (!__privateGet(this, _Ye)) return false;
      const { print: t2, view: e2 } = this.usage;
      return __privateGet(this, _qe) ? "OFF" !== (e2 == null ? void 0 : e2.viewState) : !__privateGet(this, _Xe) || "OFF" !== (t2 == null ? void 0 : t2.printState);
    }
    _setVisible(t2, e2, i2 = false) {
      t2 !== Ut && unreachable("Internal method `_setVisible` called.");
      __privateSet(this, _Ke, i2);
      __privateSet(this, _Ye, e2);
    }
  }
  _qe = new WeakMap();
  _Xe = new WeakMap();
  _Ke = new WeakMap();
  _Ye = new WeakMap();
  class OptionalContentConfig {
    constructor(t2, e2 = o) {
      __privateAdd(this, _OptionalContentConfig_instances);
      __privateAdd(this, _Qe, null);
      __privateAdd(this, _Je, /* @__PURE__ */ new Map());
      __privateAdd(this, _Ze, null);
      __privateAdd(this, _ti, null);
      this.renderingIntent = e2;
      this.name = null;
      this.creator = null;
      if (null !== t2) {
        this.name = t2.name;
        this.creator = t2.creator;
        __privateSet(this, _ti, t2.order);
        for (const i2 of t2.groups) __privateGet(this, _Je).set(i2.id, new OptionalContentGroup(e2, i2));
        if ("OFF" === t2.baseState) for (const t3 of __privateGet(this, _Je).values()) t3._setVisible(Ut, false);
        for (const e3 of t2.on) __privateGet(this, _Je).get(e3)._setVisible(Ut, true);
        for (const e3 of t2.off) __privateGet(this, _Je).get(e3)._setVisible(Ut, false);
        __privateSet(this, _Ze, this.getHash());
      }
    }
    isVisible(t2) {
      if (0 === __privateGet(this, _Je).size) return true;
      if (!t2) {
        info("Optional content group not defined.");
        return true;
      }
      if ("OCG" === t2.type) {
        if (!__privateGet(this, _Je).has(t2.id)) {
          warn(`Optional content group not found: ${t2.id}`);
          return true;
        }
        return __privateGet(this, _Je).get(t2.id).visible;
      }
      if ("OCMD" === t2.type) {
        if (t2.expression) return __privateMethod(this, _OptionalContentConfig_instances, ei_fn).call(this, t2.expression);
        if (!t2.policy || "AnyOn" === t2.policy) {
          for (const e2 of t2.ids) {
            if (!__privateGet(this, _Je).has(e2)) {
              warn(`Optional content group not found: ${e2}`);
              return true;
            }
            if (__privateGet(this, _Je).get(e2).visible) return true;
          }
          return false;
        }
        if ("AllOn" === t2.policy) {
          for (const e2 of t2.ids) {
            if (!__privateGet(this, _Je).has(e2)) {
              warn(`Optional content group not found: ${e2}`);
              return true;
            }
            if (!__privateGet(this, _Je).get(e2).visible) return false;
          }
          return true;
        }
        if ("AnyOff" === t2.policy) {
          for (const e2 of t2.ids) {
            if (!__privateGet(this, _Je).has(e2)) {
              warn(`Optional content group not found: ${e2}`);
              return true;
            }
            if (!__privateGet(this, _Je).get(e2).visible) return true;
          }
          return false;
        }
        if ("AllOff" === t2.policy) {
          for (const e2 of t2.ids) {
            if (!__privateGet(this, _Je).has(e2)) {
              warn(`Optional content group not found: ${e2}`);
              return true;
            }
            if (__privateGet(this, _Je).get(e2).visible) return false;
          }
          return true;
        }
        warn(`Unknown optional content policy ${t2.policy}.`);
        return true;
      }
      warn(`Unknown group type ${t2.type}.`);
      return true;
    }
    setVisibility(t2, e2 = true, i2 = true) {
      var _a4;
      const s2 = __privateGet(this, _Je).get(t2);
      if (s2) {
        if (i2 && e2 && s2.rbGroups.length) for (const e3 of s2.rbGroups) for (const i3 of e3) i3 !== t2 && ((_a4 = __privateGet(this, _Je).get(i3)) == null ? void 0 : _a4._setVisible(Ut, false, true));
        s2._setVisible(Ut, !!e2, true);
        __privateSet(this, _Qe, null);
      } else warn(`Optional content group not found: ${t2}`);
    }
    setOCGState({ state: t2, preserveRB: e2 }) {
      let i2;
      for (const s2 of t2) {
        switch (s2) {
          case "ON":
          case "OFF":
          case "Toggle":
            i2 = s2;
            continue;
        }
        const t3 = __privateGet(this, _Je).get(s2);
        if (t3) switch (i2) {
          case "ON":
            this.setVisibility(s2, true, e2);
            break;
          case "OFF":
            this.setVisibility(s2, false, e2);
            break;
          case "Toggle":
            this.setVisibility(s2, !t3.visible, e2);
        }
      }
      __privateSet(this, _Qe, null);
    }
    get hasInitialVisibility() {
      return null === __privateGet(this, _Ze) || this.getHash() === __privateGet(this, _Ze);
    }
    getOrder() {
      return __privateGet(this, _Je).size ? __privateGet(this, _ti) ? __privateGet(this, _ti).slice() : [
        ...__privateGet(this, _Je).keys()
      ] : null;
    }
    getGroups() {
      return __privateGet(this, _Je).size > 0 ? objectFromMap(__privateGet(this, _Je)) : null;
    }
    getGroup(t2) {
      return __privateGet(this, _Je).get(t2) || null;
    }
    getHash() {
      if (null !== __privateGet(this, _Qe)) return __privateGet(this, _Qe);
      const t2 = new MurmurHash3_64();
      for (const [e2, i2] of __privateGet(this, _Je)) t2.update(`${e2}:${i2.visible}`);
      return __privateSet(this, _Qe, t2.hexdigest());
    }
  }
  _Qe = new WeakMap();
  _Je = new WeakMap();
  _Ze = new WeakMap();
  _ti = new WeakMap();
  _OptionalContentConfig_instances = new WeakSet();
  ei_fn = function(t2) {
    const e2 = t2.length;
    if (e2 < 2) return true;
    const i2 = t2[0];
    for (let s2 = 1; s2 < e2; s2++) {
      const e3 = t2[s2];
      let n2;
      if (Array.isArray(e3)) n2 = __privateMethod(this, _OptionalContentConfig_instances, ei_fn).call(this, e3);
      else {
        if (!__privateGet(this, _Je).has(e3)) {
          warn(`Optional content group not found: ${e3}`);
          return true;
        }
        n2 = __privateGet(this, _Je).get(e3).visible;
      }
      switch (i2) {
        case "And":
          if (!n2) return false;
          break;
        case "Or":
          if (n2) return true;
          break;
        case "Not":
          return !n2;
        default:
          return true;
      }
    }
    return "And" === i2;
  };
  class PDFDataTransportStream {
    constructor(t2, { disableRange: e2 = false, disableStream: i2 = false }) {
      assert(t2, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
      const { length: s2, initialData: n2, progressiveDone: r2, contentDispositionFilename: a2 } = t2;
      this._queuedChunks = [];
      this._progressiveDone = r2;
      this._contentDispositionFilename = a2;
      if ((n2 == null ? void 0 : n2.length) > 0) {
        const t3 = n2 instanceof Uint8Array && n2.byteLength === n2.buffer.byteLength ? n2.buffer : new Uint8Array(n2).buffer;
        this._queuedChunks.push(t3);
      }
      this._pdfDataRangeTransport = t2;
      this._isStreamingSupported = !i2;
      this._isRangeSupported = !e2;
      this._contentLength = s2;
      this._fullRequestReader = null;
      this._rangeReaders = [];
      t2.addRangeListener((t3, e3) => {
        this._onReceiveData({
          begin: t3,
          chunk: e3
        });
      });
      t2.addProgressListener((t3, e3) => {
        this._onProgress({
          loaded: t3,
          total: e3
        });
      });
      t2.addProgressiveReadListener((t3) => {
        this._onReceiveData({
          chunk: t3
        });
      });
      t2.addProgressiveDoneListener(() => {
        this._onProgressiveDone();
      });
      t2.transportReady();
    }
    _onReceiveData({ begin: t2, chunk: e2 }) {
      const i2 = e2 instanceof Uint8Array && e2.byteLength === e2.buffer.byteLength ? e2.buffer : new Uint8Array(e2).buffer;
      if (void 0 === t2) this._fullRequestReader ? this._fullRequestReader._enqueue(i2) : this._queuedChunks.push(i2);
      else {
        assert(this._rangeReaders.some(function(e3) {
          if (e3._begin !== t2) return false;
          e3._enqueue(i2);
          return true;
        }), "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
      }
    }
    get _progressiveDataLength() {
      var _a4;
      return ((_a4 = this._fullRequestReader) == null ? void 0 : _a4._loaded) ?? 0;
    }
    _onProgress(t2) {
      var _a4, _b2, _c, _d;
      void 0 === t2.total ? (_b2 = (_a4 = this._rangeReaders[0]) == null ? void 0 : _a4.onProgress) == null ? void 0 : _b2.call(_a4, {
        loaded: t2.loaded
      }) : (_d = (_c = this._fullRequestReader) == null ? void 0 : _c.onProgress) == null ? void 0 : _d.call(_c, {
        loaded: t2.loaded,
        total: t2.total
      });
    }
    _onProgressiveDone() {
      var _a4;
      (_a4 = this._fullRequestReader) == null ? void 0 : _a4.progressiveDone();
      this._progressiveDone = true;
    }
    _removeRangeReader(t2) {
      const e2 = this._rangeReaders.indexOf(t2);
      e2 >= 0 && this._rangeReaders.splice(e2, 1);
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
      const t2 = this._queuedChunks;
      this._queuedChunks = null;
      return new PDFDataTransportStreamReader(this, t2, this._progressiveDone, this._contentDispositionFilename);
    }
    getRangeReader(t2, e2) {
      if (e2 <= this._progressiveDataLength) return null;
      const i2 = new PDFDataTransportStreamRangeReader(this, t2, e2);
      this._pdfDataRangeTransport.requestDataRange(t2, e2);
      this._rangeReaders.push(i2);
      return i2;
    }
    cancelAllRequests(t2) {
      var _a4;
      (_a4 = this._fullRequestReader) == null ? void 0 : _a4.cancel(t2);
      for (const e2 of this._rangeReaders.slice(0)) e2.cancel(t2);
      this._pdfDataRangeTransport.abort();
    }
  }
  class PDFDataTransportStreamReader {
    constructor(t2, e2, i2 = false, s2 = null) {
      this._stream = t2;
      this._done = i2 || false;
      this._filename = isPdfFile(s2) ? s2 : null;
      this._queuedChunks = e2 || [];
      this._loaded = 0;
      for (const t3 of this._queuedChunks) this._loaded += t3.byteLength;
      this._requests = [];
      this._headersReady = Promise.resolve();
      t2._fullRequestReader = this;
      this.onProgress = null;
    }
    _enqueue(t2) {
      if (!this._done) {
        if (this._requests.length > 0) {
          this._requests.shift().resolve({
            value: t2,
            done: false
          });
        } else this._queuedChunks.push(t2);
        this._loaded += t2.byteLength;
      }
    }
    get headersReady() {
      return this._headersReady;
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._stream._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._stream._isStreamingSupported;
    }
    get contentLength() {
      return this._stream._contentLength;
    }
    async read() {
      if (this._queuedChunks.length > 0) {
        return {
          value: this._queuedChunks.shift(),
          done: false
        };
      }
      if (this._done) return {
        value: void 0,
        done: true
      };
      const t2 = Promise.withResolvers();
      this._requests.push(t2);
      return t2.promise;
    }
    cancel(t2) {
      this._done = true;
      for (const t3 of this._requests) t3.resolve({
        value: void 0,
        done: true
      });
      this._requests.length = 0;
    }
    progressiveDone() {
      this._done || (this._done = true);
    }
  }
  class PDFDataTransportStreamRangeReader {
    constructor(t2, e2, i2) {
      this._stream = t2;
      this._begin = e2;
      this._end = i2;
      this._queuedChunk = null;
      this._requests = [];
      this._done = false;
      this.onProgress = null;
    }
    _enqueue(t2) {
      if (!this._done) {
        if (0 === this._requests.length) this._queuedChunk = t2;
        else {
          this._requests.shift().resolve({
            value: t2,
            done: false
          });
          for (const t3 of this._requests) t3.resolve({
            value: void 0,
            done: true
          });
          this._requests.length = 0;
        }
        this._done = true;
        this._stream._removeRangeReader(this);
      }
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      if (this._queuedChunk) {
        const t3 = this._queuedChunk;
        this._queuedChunk = null;
        return {
          value: t3,
          done: false
        };
      }
      if (this._done) return {
        value: void 0,
        done: true
      };
      const t2 = Promise.withResolvers();
      this._requests.push(t2);
      return t2.promise;
    }
    cancel(t2) {
      this._done = true;
      for (const t3 of this._requests) t3.resolve({
        value: void 0,
        done: true
      });
      this._requests.length = 0;
      this._stream._removeRangeReader(this);
    }
  }
  function createHeaders(t2, e2) {
    const i2 = new Headers();
    if (!t2 || !e2 || "object" != typeof e2) return i2;
    for (const t3 in e2) {
      const s2 = e2[t3];
      void 0 !== s2 && i2.append(t3, s2);
    }
    return i2;
  }
  function validateRangeRequestCapabilities({ responseHeaders: t2, isHttp: e2, rangeChunkSize: i2, disableRange: s2 }) {
    const n2 = {
      allowRangeRequests: false,
      suggestedLength: void 0
    }, r2 = parseInt(t2.get("Content-Length"), 10);
    if (!Number.isInteger(r2)) return n2;
    n2.suggestedLength = r2;
    if (r2 <= 2 * i2) return n2;
    if (s2 || !e2) return n2;
    if ("bytes" !== t2.get("Accept-Ranges")) return n2;
    if ("identity" !== (t2.get("Content-Encoding") || "identity")) return n2;
    n2.allowRangeRequests = true;
    return n2;
  }
  function extractFilenameFromHeader(t2) {
    const e2 = t2.get("Content-Disposition");
    if (e2) {
      let t3 = function getFilenameFromContentDispositionHeader(t4) {
        let e3 = true, i2 = toParamRegExp("filename\\*", "i").exec(t4);
        if (i2) {
          i2 = i2[1];
          let t5 = rfc2616unquote(i2);
          t5 = unescape(t5);
          t5 = rfc5987decode(t5);
          t5 = rfc2047decode(t5);
          return fixupEncoding(t5);
        }
        i2 = function rfc2231getparam(t5) {
          const e4 = [];
          let i3;
          const s2 = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          for (; null !== (i3 = s2.exec(t5)); ) {
            let [, t6, s3, n3] = i3;
            t6 = parseInt(t6, 10);
            if (t6 in e4) {
              if (0 === t6) break;
            } else e4[t6] = [
              s3,
              n3
            ];
          }
          const n2 = [];
          for (let t6 = 0; t6 < e4.length && t6 in e4; ++t6) {
            let [i4, s3] = e4[t6];
            s3 = rfc2616unquote(s3);
            if (i4) {
              s3 = unescape(s3);
              0 === t6 && (s3 = rfc5987decode(s3));
            }
            n2.push(s3);
          }
          return n2.join("");
        }(t4);
        if (i2) return fixupEncoding(rfc2047decode(i2));
        i2 = toParamRegExp("filename", "i").exec(t4);
        if (i2) {
          i2 = i2[1];
          let t5 = rfc2616unquote(i2);
          t5 = rfc2047decode(t5);
          return fixupEncoding(t5);
        }
        function toParamRegExp(t5, e4) {
          return new RegExp("(?:^|;)\\s*" + t5 + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', e4);
        }
        function textdecode(t5, i3) {
          if (t5) {
            if (!/^[\x00-\xFF]+$/.test(i3)) return i3;
            try {
              const s2 = new TextDecoder(t5, {
                fatal: true
              }), n2 = stringToBytes(i3);
              i3 = s2.decode(n2);
              e3 = false;
            } catch {
            }
          }
          return i3;
        }
        function fixupEncoding(t5) {
          if (e3 && /[\x80-\xff]/.test(t5)) {
            t5 = textdecode("utf-8", t5);
            e3 && (t5 = textdecode("iso-8859-1", t5));
          }
          return t5;
        }
        function rfc2616unquote(t5) {
          if (t5.startsWith('"')) {
            const e4 = t5.slice(1).split('\\"');
            for (let t6 = 0; t6 < e4.length; ++t6) {
              const i3 = e4[t6].indexOf('"');
              if (-1 !== i3) {
                e4[t6] = e4[t6].slice(0, i3);
                e4.length = t6 + 1;
              }
              e4[t6] = e4[t6].replaceAll(/\\(.)/g, "$1");
            }
            t5 = e4.join('"');
          }
          return t5;
        }
        function rfc5987decode(t5) {
          const e4 = t5.indexOf("'");
          return -1 === e4 ? t5 : textdecode(t5.slice(0, e4), t5.slice(e4 + 1).replace(/^[^']*'/, ""));
        }
        function rfc2047decode(t5) {
          return !t5.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(t5) ? t5 : t5.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(t6, e4, i3, s2) {
            if ("q" === i3 || "Q" === i3) return textdecode(e4, s2 = (s2 = s2.replaceAll("_", " ")).replaceAll(/=([0-9a-fA-F]{2})/g, function(t7, e5) {
              return String.fromCharCode(parseInt(e5, 16));
            }));
            try {
              s2 = atob(s2);
            } catch {
            }
            return textdecode(e4, s2);
          });
        }
        return "";
      }(e2);
      if (t3.includes("%")) try {
        t3 = decodeURIComponent(t3);
      } catch {
      }
      if (isPdfFile(t3)) return t3;
    }
    return null;
  }
  function createResponseStatusError(t2, e2) {
    return 404 === t2 || 0 === t2 && e2.startsWith("file:") ? new MissingPDFException('Missing PDF "' + e2 + '".') : new UnexpectedResponseException(`Unexpected server response (${t2}) while retrieving PDF "${e2}".`, t2);
  }
  function validateResponseStatus(t2) {
    return 200 === t2 || 206 === t2;
  }
  function createFetchOptions(t2, e2, i2) {
    return {
      method: "GET",
      headers: t2,
      signal: i2.signal,
      mode: "cors",
      credentials: e2 ? "include" : "same-origin",
      redirect: "follow"
    };
  }
  function getArrayBuffer(t2) {
    if (t2 instanceof Uint8Array) return t2.buffer;
    if (t2 instanceof ArrayBuffer) return t2;
    warn(`getArrayBuffer - unexpected data format: ${t2}`);
    return new Uint8Array(t2).buffer;
  }
  class PDFFetchStream {
    constructor(t2) {
      this.source = t2;
      this.isHttp = /^https?:/i.test(t2.url);
      this.headers = createHeaders(this.isHttp, t2.httpHeaders);
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      var _a4;
      return ((_a4 = this._fullRequestReader) == null ? void 0 : _a4._loaded) ?? 0;
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFFetchStreamReader(this);
      return this._fullRequestReader;
    }
    getRangeReader(t2, e2) {
      if (e2 <= this._progressiveDataLength) return null;
      const i2 = new PDFFetchStreamRangeReader(this, t2, e2);
      this._rangeRequestReaders.push(i2);
      return i2;
    }
    cancelAllRequests(t2) {
      var _a4;
      (_a4 = this._fullRequestReader) == null ? void 0 : _a4.cancel(t2);
      for (const e2 of this._rangeRequestReaders.slice(0)) e2.cancel(t2);
    }
  }
  class PDFFetchStreamReader {
    constructor(t2) {
      this._stream = t2;
      this._reader = null;
      this._loaded = 0;
      this._filename = null;
      const e2 = t2.source;
      this._withCredentials = e2.withCredentials || false;
      this._contentLength = e2.length;
      this._headersCapability = Promise.withResolvers();
      this._disableRange = e2.disableRange || false;
      this._rangeChunkSize = e2.rangeChunkSize;
      this._rangeChunkSize || this._disableRange || (this._disableRange = true);
      this._abortController = new AbortController();
      this._isStreamingSupported = !e2.disableStream;
      this._isRangeSupported = !e2.disableRange;
      const i2 = new Headers(t2.headers), s2 = e2.url;
      fetch(s2, createFetchOptions(i2, this._withCredentials, this._abortController)).then((e3) => {
        if (!validateResponseStatus(e3.status)) throw createResponseStatusError(e3.status, s2);
        this._reader = e3.body.getReader();
        this._headersCapability.resolve();
        const i3 = e3.headers, { allowRangeRequests: n2, suggestedLength: r2 } = validateRangeRequestCapabilities({
          responseHeaders: i3,
          isHttp: t2.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = n2;
        this._contentLength = r2 || this._contentLength;
        this._filename = extractFilenameFromHeader(i3);
        !this._isStreamingSupported && this._isRangeSupported && this.cancel(new AbortException("Streaming is disabled."));
      }).catch(this._headersCapability.reject);
      this.onProgress = null;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var _a4;
      await this._headersCapability.promise;
      const { value: t2, done: e2 } = await this._reader.read();
      if (e2) return {
        value: t2,
        done: e2
      };
      this._loaded += t2.byteLength;
      (_a4 = this.onProgress) == null ? void 0 : _a4.call(this, {
        loaded: this._loaded,
        total: this._contentLength
      });
      return {
        value: getArrayBuffer(t2),
        done: false
      };
    }
    cancel(t2) {
      var _a4;
      (_a4 = this._reader) == null ? void 0 : _a4.cancel(t2);
      this._abortController.abort();
    }
  }
  class PDFFetchStreamRangeReader {
    constructor(t2, e2, i2) {
      this._stream = t2;
      this._reader = null;
      this._loaded = 0;
      const s2 = t2.source;
      this._withCredentials = s2.withCredentials || false;
      this._readCapability = Promise.withResolvers();
      this._isStreamingSupported = !s2.disableStream;
      this._abortController = new AbortController();
      const n2 = new Headers(t2.headers);
      n2.append("Range", `bytes=${e2}-${i2 - 1}`);
      const r2 = s2.url;
      fetch(r2, createFetchOptions(n2, this._withCredentials, this._abortController)).then((t3) => {
        if (!validateResponseStatus(t3.status)) throw createResponseStatusError(t3.status, r2);
        this._readCapability.resolve();
        this._reader = t3.body.getReader();
      }).catch(this._readCapability.reject);
      this.onProgress = null;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var _a4;
      await this._readCapability.promise;
      const { value: t2, done: e2 } = await this._reader.read();
      if (e2) return {
        value: t2,
        done: e2
      };
      this._loaded += t2.byteLength;
      (_a4 = this.onProgress) == null ? void 0 : _a4.call(this, {
        loaded: this._loaded
      });
      return {
        value: getArrayBuffer(t2),
        done: false
      };
    }
    cancel(t2) {
      var _a4;
      (_a4 = this._reader) == null ? void 0 : _a4.cancel(t2);
      this._abortController.abort();
    }
  }
  class NetworkManager {
    constructor({ url: t2, httpHeaders: e2, withCredentials: i2 }) {
      this.url = t2;
      this.isHttp = /^https?:/i.test(t2);
      this.headers = createHeaders(this.isHttp, e2);
      this.withCredentials = i2 || false;
      this.currXhrId = 0;
      this.pendingRequests = /* @__PURE__ */ Object.create(null);
    }
    requestRange(t2, e2, i2) {
      const s2 = {
        begin: t2,
        end: e2
      };
      for (const t3 in i2) s2[t3] = i2[t3];
      return this.request(s2);
    }
    requestFull(t2) {
      return this.request(t2);
    }
    request(t2) {
      const e2 = new XMLHttpRequest(), i2 = this.currXhrId++, s2 = this.pendingRequests[i2] = {
        xhr: e2
      };
      e2.open("GET", this.url);
      e2.withCredentials = this.withCredentials;
      for (const [t3, i3] of this.headers) e2.setRequestHeader(t3, i3);
      if (this.isHttp && "begin" in t2 && "end" in t2) {
        e2.setRequestHeader("Range", `bytes=${t2.begin}-${t2.end - 1}`);
        s2.expectedStatus = 206;
      } else s2.expectedStatus = 200;
      e2.responseType = "arraybuffer";
      t2.onError && (e2.onerror = function(i3) {
        t2.onError(e2.status);
      });
      e2.onreadystatechange = this.onStateChange.bind(this, i2);
      e2.onprogress = this.onProgress.bind(this, i2);
      s2.onHeadersReceived = t2.onHeadersReceived;
      s2.onDone = t2.onDone;
      s2.onError = t2.onError;
      s2.onProgress = t2.onProgress;
      e2.send(null);
      return i2;
    }
    onProgress(t2, e2) {
      var _a4;
      const i2 = this.pendingRequests[t2];
      i2 && ((_a4 = i2.onProgress) == null ? void 0 : _a4.call(i2, e2));
    }
    onStateChange(t2, e2) {
      var _a4, _b2, _c;
      const i2 = this.pendingRequests[t2];
      if (!i2) return;
      const s2 = i2.xhr;
      if (s2.readyState >= 2 && i2.onHeadersReceived) {
        i2.onHeadersReceived();
        delete i2.onHeadersReceived;
      }
      if (4 !== s2.readyState) return;
      if (!(t2 in this.pendingRequests)) return;
      delete this.pendingRequests[t2];
      if (0 === s2.status && this.isHttp) {
        (_a4 = i2.onError) == null ? void 0 : _a4.call(i2, s2.status);
        return;
      }
      const n2 = s2.status || 200;
      if (!(200 === n2 && 206 === i2.expectedStatus) && n2 !== i2.expectedStatus) {
        (_b2 = i2.onError) == null ? void 0 : _b2.call(i2, s2.status);
        return;
      }
      const r2 = function network_getArrayBuffer(t3) {
        const e3 = t3.response;
        return "string" != typeof e3 ? e3 : stringToBytes(e3).buffer;
      }(s2);
      if (206 === n2) {
        const t3 = s2.getResponseHeader("Content-Range"), e3 = /bytes (\d+)-(\d+)\/(\d+)/.exec(t3);
        i2.onDone({
          begin: parseInt(e3[1], 10),
          chunk: r2
        });
      } else r2 ? i2.onDone({
        begin: 0,
        chunk: r2
      }) : (_c = i2.onError) == null ? void 0 : _c.call(i2, s2.status);
    }
    getRequestXhr(t2) {
      return this.pendingRequests[t2].xhr;
    }
    isPendingRequest(t2) {
      return t2 in this.pendingRequests;
    }
    abortRequest(t2) {
      const e2 = this.pendingRequests[t2].xhr;
      delete this.pendingRequests[t2];
      e2.abort();
    }
  }
  class PDFNetworkStream {
    constructor(t2) {
      this._source = t2;
      this._manager = new NetworkManager(t2);
      this._rangeChunkSize = t2.rangeChunkSize;
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    _onRangeRequestReaderClosed(t2) {
      const e2 = this._rangeRequestReaders.indexOf(t2);
      e2 >= 0 && this._rangeRequestReaders.splice(e2, 1);
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
      return this._fullRequestReader;
    }
    getRangeReader(t2, e2) {
      const i2 = new PDFNetworkStreamRangeRequestReader(this._manager, t2, e2);
      i2.onClosed = this._onRangeRequestReaderClosed.bind(this);
      this._rangeRequestReaders.push(i2);
      return i2;
    }
    cancelAllRequests(t2) {
      var _a4;
      (_a4 = this._fullRequestReader) == null ? void 0 : _a4.cancel(t2);
      for (const e2 of this._rangeRequestReaders.slice(0)) e2.cancel(t2);
    }
  }
  class PDFNetworkStreamFullRequestReader {
    constructor(t2, e2) {
      this._manager = t2;
      const i2 = {
        onHeadersReceived: this._onHeadersReceived.bind(this),
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      };
      this._url = e2.url;
      this._fullRequestId = t2.requestFull(i2);
      this._headersCapability = Promise.withResolvers();
      this._disableRange = e2.disableRange || false;
      this._contentLength = e2.length;
      this._rangeChunkSize = e2.rangeChunkSize;
      this._rangeChunkSize || this._disableRange || (this._disableRange = true);
      this._isStreamingSupported = false;
      this._isRangeSupported = false;
      this._cachedChunks = [];
      this._requests = [];
      this._done = false;
      this._storedError = void 0;
      this._filename = null;
      this.onProgress = null;
    }
    _onHeadersReceived() {
      const t2 = this._fullRequestId, e2 = this._manager.getRequestXhr(t2), i2 = new Headers(e2.getAllResponseHeaders().trim().split(/[\r\n]+/).map((t3) => {
        const [e3, ...i3] = t3.split(": ");
        return [
          e3,
          i3.join(": ")
        ];
      })), { allowRangeRequests: s2, suggestedLength: n2 } = validateRangeRequestCapabilities({
        responseHeaders: i2,
        isHttp: this._manager.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      s2 && (this._isRangeSupported = true);
      this._contentLength = n2 || this._contentLength;
      this._filename = extractFilenameFromHeader(i2);
      this._isRangeSupported && this._manager.abortRequest(t2);
      this._headersCapability.resolve();
    }
    _onDone(t2) {
      if (t2) if (this._requests.length > 0) {
        this._requests.shift().resolve({
          value: t2.chunk,
          done: false
        });
      } else this._cachedChunks.push(t2.chunk);
      this._done = true;
      if (!(this._cachedChunks.length > 0)) {
        for (const t3 of this._requests) t3.resolve({
          value: void 0,
          done: true
        });
        this._requests.length = 0;
      }
    }
    _onError(t2) {
      this._storedError = createResponseStatusError(t2, this._url);
      this._headersCapability.reject(this._storedError);
      for (const t3 of this._requests) t3.reject(this._storedError);
      this._requests.length = 0;
      this._cachedChunks.length = 0;
    }
    _onProgress(t2) {
      var _a4;
      (_a4 = this.onProgress) == null ? void 0 : _a4.call(this, {
        loaded: t2.loaded,
        total: t2.lengthComputable ? t2.total : this._contentLength
      });
    }
    get filename() {
      return this._filename;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    get contentLength() {
      return this._contentLength;
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    async read() {
      if (this._storedError) throw this._storedError;
      if (this._cachedChunks.length > 0) {
        return {
          value: this._cachedChunks.shift(),
          done: false
        };
      }
      if (this._done) return {
        value: void 0,
        done: true
      };
      const t2 = Promise.withResolvers();
      this._requests.push(t2);
      return t2.promise;
    }
    cancel(t2) {
      this._done = true;
      this._headersCapability.reject(t2);
      for (const t3 of this._requests) t3.resolve({
        value: void 0,
        done: true
      });
      this._requests.length = 0;
      this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId);
      this._fullRequestReader = null;
    }
  }
  class PDFNetworkStreamRangeRequestReader {
    constructor(t2, e2, i2) {
      this._manager = t2;
      const s2 = {
        onDone: this._onDone.bind(this),
        onError: this._onError.bind(this),
        onProgress: this._onProgress.bind(this)
      };
      this._url = t2.url;
      this._requestId = t2.requestRange(e2, i2, s2);
      this._requests = [];
      this._queuedChunk = null;
      this._done = false;
      this._storedError = void 0;
      this.onProgress = null;
      this.onClosed = null;
    }
    _close() {
      var _a4;
      (_a4 = this.onClosed) == null ? void 0 : _a4.call(this, this);
    }
    _onDone(t2) {
      const e2 = t2.chunk;
      if (this._requests.length > 0) {
        this._requests.shift().resolve({
          value: e2,
          done: false
        });
      } else this._queuedChunk = e2;
      this._done = true;
      for (const t3 of this._requests) t3.resolve({
        value: void 0,
        done: true
      });
      this._requests.length = 0;
      this._close();
    }
    _onError(t2) {
      this._storedError = createResponseStatusError(t2, this._url);
      for (const t3 of this._requests) t3.reject(this._storedError);
      this._requests.length = 0;
      this._queuedChunk = null;
    }
    _onProgress(t2) {
      var _a4;
      this.isStreamingSupported || ((_a4 = this.onProgress) == null ? void 0 : _a4.call(this, {
        loaded: t2.loaded
      }));
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      if (this._storedError) throw this._storedError;
      if (null !== this._queuedChunk) {
        const t3 = this._queuedChunk;
        this._queuedChunk = null;
        return {
          value: t3,
          done: false
        };
      }
      if (this._done) return {
        value: void 0,
        done: true
      };
      const t2 = Promise.withResolvers();
      this._requests.push(t2);
      return t2.promise;
    }
    cancel(t2) {
      this._done = true;
      for (const t3 of this._requests) t3.resolve({
        value: void 0,
        done: true
      });
      this._requests.length = 0;
      this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId);
      this._close();
    }
  }
  const zt = /^[a-z][a-z0-9\-+.]+:/i;
  function createRequest(t2, e2, i2) {
    if ("http:" === t2.protocol) {
      return NodePackages.get("http").request(t2, {
        headers: e2
      }, i2);
    }
    return NodePackages.get("https").request(t2, {
      headers: e2
    }, i2);
  }
  class PDFNodeStream {
    constructor(t2) {
      this.source = t2;
      this.url = function parseUrlOrPath(t3) {
        if (zt.test(t3)) return new URL(t3);
        const e2 = NodePackages.get("url");
        return new URL(e2.pathToFileURL(t3));
      }(t2.url);
      this.isHttp = "http:" === this.url.protocol || "https:" === this.url.protocol;
      this.isFsUrl = "file:" === this.url.protocol;
      this.headers = createHeaders(this.isHttp, t2.httpHeaders);
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    get _progressiveDataLength() {
      var _a4;
      return ((_a4 = this._fullRequestReader) == null ? void 0 : _a4._loaded) ?? 0;
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
      this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
      return this._fullRequestReader;
    }
    getRangeReader(t2, e2) {
      if (e2 <= this._progressiveDataLength) return null;
      const i2 = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, t2, e2) : new PDFNodeStreamRangeReader(this, t2, e2);
      this._rangeRequestReaders.push(i2);
      return i2;
    }
    cancelAllRequests(t2) {
      var _a4;
      (_a4 = this._fullRequestReader) == null ? void 0 : _a4.cancel(t2);
      for (const e2 of this._rangeRequestReaders.slice(0)) e2.cancel(t2);
    }
  }
  class BaseFullReader {
    constructor(t2) {
      this._url = t2.url;
      this._done = false;
      this._storedError = null;
      this.onProgress = null;
      const e2 = t2.source;
      this._contentLength = e2.length;
      this._loaded = 0;
      this._filename = null;
      this._disableRange = e2.disableRange || false;
      this._rangeChunkSize = e2.rangeChunkSize;
      this._rangeChunkSize || this._disableRange || (this._disableRange = true);
      this._isStreamingSupported = !e2.disableStream;
      this._isRangeSupported = !e2.disableRange;
      this._readableStream = null;
      this._readCapability = Promise.withResolvers();
      this._headersCapability = Promise.withResolvers();
    }
    get headersReady() {
      return this._headersCapability.promise;
    }
    get filename() {
      return this._filename;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var _a4;
      await this._readCapability.promise;
      if (this._done) return {
        value: void 0,
        done: true
      };
      if (this._storedError) throw this._storedError;
      const t2 = this._readableStream.read();
      if (null === t2) {
        this._readCapability = Promise.withResolvers();
        return this.read();
      }
      this._loaded += t2.length;
      (_a4 = this.onProgress) == null ? void 0 : _a4.call(this, {
        loaded: this._loaded,
        total: this._contentLength
      });
      return {
        value: new Uint8Array(t2).buffer,
        done: false
      };
    }
    cancel(t2) {
      this._readableStream ? this._readableStream.destroy(t2) : this._error(t2);
    }
    _error(t2) {
      this._storedError = t2;
      this._readCapability.resolve();
    }
    _setReadableStream(t2) {
      this._readableStream = t2;
      t2.on("readable", () => {
        this._readCapability.resolve();
      });
      t2.on("end", () => {
        t2.destroy();
        this._done = true;
        this._readCapability.resolve();
      });
      t2.on("error", (t3) => {
        this._error(t3);
      });
      !this._isStreamingSupported && this._isRangeSupported && this._error(new AbortException("streaming is disabled"));
      this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class BaseRangeReader {
    constructor(t2) {
      this._url = t2.url;
      this._done = false;
      this._storedError = null;
      this.onProgress = null;
      this._loaded = 0;
      this._readableStream = null;
      this._readCapability = Promise.withResolvers();
      const e2 = t2.source;
      this._isStreamingSupported = !e2.disableStream;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    async read() {
      var _a4;
      await this._readCapability.promise;
      if (this._done) return {
        value: void 0,
        done: true
      };
      if (this._storedError) throw this._storedError;
      const t2 = this._readableStream.read();
      if (null === t2) {
        this._readCapability = Promise.withResolvers();
        return this.read();
      }
      this._loaded += t2.length;
      (_a4 = this.onProgress) == null ? void 0 : _a4.call(this, {
        loaded: this._loaded
      });
      return {
        value: new Uint8Array(t2).buffer,
        done: false
      };
    }
    cancel(t2) {
      this._readableStream ? this._readableStream.destroy(t2) : this._error(t2);
    }
    _error(t2) {
      this._storedError = t2;
      this._readCapability.resolve();
    }
    _setReadableStream(t2) {
      this._readableStream = t2;
      t2.on("readable", () => {
        this._readCapability.resolve();
      });
      t2.on("end", () => {
        t2.destroy();
        this._done = true;
        this._readCapability.resolve();
      });
      t2.on("error", (t3) => {
        this._error(t3);
      });
      this._storedError && this._readableStream.destroy(this._storedError);
    }
  }
  class PDFNodeStreamFullReader extends BaseFullReader {
    constructor(t2) {
      super(t2);
      const e2 = Object.fromEntries(t2.headers);
      this._request = createRequest(this._url, e2, (e3) => {
        if (404 === e3.statusCode) {
          const t3 = new MissingPDFException(`Missing PDF "${this._url}".`);
          this._storedError = t3;
          this._headersCapability.reject(t3);
          return;
        }
        this._headersCapability.resolve();
        this._setReadableStream(e3);
        const i2 = new Headers(this._readableStream.headers), { allowRangeRequests: s2, suggestedLength: n2 } = validateRangeRequestCapabilities({
          responseHeaders: i2,
          isHttp: t2.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        this._isRangeSupported = s2;
        this._contentLength = n2 || this._contentLength;
        this._filename = extractFilenameFromHeader(i2);
      });
      this._request.on("error", (t3) => {
        this._storedError = t3;
        this._headersCapability.reject(t3);
      });
      this._request.end();
    }
  }
  class PDFNodeStreamRangeReader extends BaseRangeReader {
    constructor(t2, e2, i2) {
      super(t2);
      const s2 = Object.fromEntries(t2.headers);
      s2.Range = `bytes=${e2}-${i2 - 1}`;
      this._request = createRequest(this._url, s2, (t3) => {
        if (404 !== t3.statusCode) this._setReadableStream(t3);
        else {
          const t4 = new MissingPDFException(`Missing PDF "${this._url}".`);
          this._storedError = t4;
        }
      });
      this._request.on("error", (t3) => {
        this._storedError = t3;
      });
      this._request.end();
    }
  }
  class PDFNodeStreamFsFullReader extends BaseFullReader {
    constructor(t2) {
      super(t2);
      const e2 = NodePackages.get("fs");
      e2.promises.lstat(this._url).then((t3) => {
        this._contentLength = t3.size;
        this._setReadableStream(e2.createReadStream(this._url));
        this._headersCapability.resolve();
      }, (t3) => {
        "ENOENT" === t3.code && (t3 = new MissingPDFException(`Missing PDF "${this._url}".`));
        this._storedError = t3;
        this._headersCapability.reject(t3);
      });
    }
  }
  class PDFNodeStreamFsRangeReader extends BaseRangeReader {
    constructor(t2, e2, i2) {
      super(t2);
      const s2 = NodePackages.get("fs");
      this._setReadableStream(s2.createReadStream(this._url, {
        start: e2,
        end: i2 - 1
      }));
    }
  }
  const jt = 30;
  const _TextLayer = class _TextLayer {
    constructor({ textContentSource: t2, container: e2, viewport: i2 }) {
      __privateAdd(this, _TextLayer_instances);
      __privateAdd(this, _ii, Promise.withResolvers());
      __privateAdd(this, _ut2, null);
      __privateAdd(this, _si, false);
      __privateAdd(this, _ni, !!((_a3 = globalThis.FontInspector) == null ? void 0 : _a3.enabled));
      __privateAdd(this, _ri, null);
      __privateAdd(this, _ai, null);
      __privateAdd(this, _oi, 0);
      __privateAdd(this, _li, 0);
      __privateAdd(this, _hi, null);
      __privateAdd(this, _ci, null);
      __privateAdd(this, _di, 0);
      __privateAdd(this, _ui, 0);
      __privateAdd(this, _pi, /* @__PURE__ */ Object.create(null));
      __privateAdd(this, _gi, []);
      __privateAdd(this, _fi, null);
      __privateAdd(this, _mi, []);
      __privateAdd(this, _bi, /* @__PURE__ */ new WeakMap());
      __privateAdd(this, _vi, null);
      var _a4;
      if (t2 instanceof ReadableStream) __privateSet(this, _fi, t2);
      else {
        if ("object" != typeof t2) throw new Error('No "textContentSource" parameter specified.');
        __privateSet(this, _fi, new ReadableStream({
          start(e3) {
            e3.enqueue(t2);
            e3.close();
          }
        }));
      }
      __privateSet(this, _ut2, __privateSet(this, _ci, e2));
      __privateSet(this, _ui, i2.scale * (globalThis.devicePixelRatio || 1));
      __privateSet(this, _di, i2.rotation);
      __privateSet(this, _ai, {
        div: null,
        properties: null,
        ctx: null
      });
      const { pageWidth: s2, pageHeight: n2, pageX: r2, pageY: a2 } = i2.rawDims;
      __privateSet(this, _vi, [
        1,
        0,
        0,
        -1,
        -r2,
        a2 + n2
      ]);
      __privateSet(this, _li, s2);
      __privateSet(this, _oi, n2);
      __privateMethod(_a4 = _TextLayer, _TextLayer_static, Ei_fn).call(_a4);
      setLayerDimensions(e2, i2);
      __privateGet(this, _ii).promise.finally(() => {
        __privateGet(_TextLayer, __i).delete(this);
        __privateSet(this, _ai, null);
        __privateSet(this, _pi, null);
      }).catch(() => {
      });
    }
    static get fontFamilyMap() {
      const { isWindows: t2, isFirefox: e2 } = util_FeatureTest.platform;
      return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([
        [
          "sans-serif",
          (t2 && e2 ? "Calibri, " : "") + "sans-serif"
        ],
        [
          "monospace",
          (t2 && e2 ? "Lucida Console, " : "") + "monospace"
        ]
      ]));
    }
    render() {
      const pump = () => {
        __privateGet(this, _hi).read().then(({ value: t2, done: e2 }) => {
          if (e2) __privateGet(this, _ii).resolve();
          else {
            __privateGet(this, _ri) ?? __privateSet(this, _ri, t2.lang);
            Object.assign(__privateGet(this, _pi), t2.styles);
            __privateMethod(this, _TextLayer_instances, Ci_fn).call(this, t2.items);
            pump();
          }
        }, __privateGet(this, _ii).reject);
      };
      __privateSet(this, _hi, __privateGet(this, _fi).getReader());
      __privateGet(_TextLayer, __i).add(this);
      pump();
      return __privateGet(this, _ii).promise;
    }
    update({ viewport: t2, onBefore: e2 = null }) {
      var _a4;
      const i2 = t2.scale * (globalThis.devicePixelRatio || 1), s2 = t2.rotation;
      if (s2 !== __privateGet(this, _di)) {
        e2 == null ? void 0 : e2();
        __privateSet(this, _di, s2);
        setLayerDimensions(__privateGet(this, _ci), {
          rotation: s2
        });
      }
      if (i2 !== __privateGet(this, _ui)) {
        e2 == null ? void 0 : e2();
        __privateSet(this, _ui, i2);
        const t3 = {
          div: null,
          properties: null,
          ctx: __privateMethod(_a4 = _TextLayer, _TextLayer_static, Si_fn).call(_a4, __privateGet(this, _ri))
        };
        for (const e3 of __privateGet(this, _mi)) {
          t3.properties = __privateGet(this, _bi).get(e3);
          t3.div = e3;
          __privateMethod(this, _TextLayer_instances, Ti_fn).call(this, t3);
        }
      }
    }
    cancel() {
      var _a4;
      const t2 = new AbortException("TextLayer task cancelled.");
      (_a4 = __privateGet(this, _hi)) == null ? void 0 : _a4.cancel(t2).catch(() => {
      });
      __privateSet(this, _hi, null);
      __privateGet(this, _ii).reject(t2);
    }
    get textDivs() {
      return __privateGet(this, _mi);
    }
    get textContentItemsStr() {
      return __privateGet(this, _gi);
    }
    static cleanup() {
      if (!(__privateGet(this, __i).size > 0)) {
        __privateGet(this, _yi).clear();
        for (const { canvas: t2 } of __privateGet(this, _Ai).values()) t2.remove();
        __privateGet(this, _Ai).clear();
      }
    }
  };
  _ii = new WeakMap();
  _ut2 = new WeakMap();
  _si = new WeakMap();
  _ni = new WeakMap();
  _ri = new WeakMap();
  _ai = new WeakMap();
  _oi = new WeakMap();
  _li = new WeakMap();
  _hi = new WeakMap();
  _ci = new WeakMap();
  _di = new WeakMap();
  _ui = new WeakMap();
  _pi = new WeakMap();
  _gi = new WeakMap();
  _fi = new WeakMap();
  _mi = new WeakMap();
  _bi = new WeakMap();
  _vi = new WeakMap();
  _yi = new WeakMap();
  _Ai = new WeakMap();
  _wi = new WeakMap();
  _xi = new WeakMap();
  __i = new WeakMap();
  _TextLayer_instances = new WeakSet();
  Ci_fn = function(t2) {
    var _a4, _b2;
    if (__privateGet(this, _si)) return;
    (_b2 = __privateGet(this, _ai)).ctx ?? (_b2.ctx = __privateMethod(_a4 = _TextLayer, _TextLayer_static, Si_fn).call(_a4, __privateGet(this, _ri)));
    const e2 = __privateGet(this, _mi), i2 = __privateGet(this, _gi);
    for (const s2 of t2) {
      if (e2.length > 1e5) {
        warn("Ignoring additional textDivs for performance reasons.");
        __privateSet(this, _si, true);
        return;
      }
      if (void 0 !== s2.str) {
        i2.push(s2.str);
        __privateMethod(this, _TextLayer_instances, Mi_fn).call(this, s2);
      } else if ("beginMarkedContentProps" === s2.type || "beginMarkedContent" === s2.type) {
        const t3 = __privateGet(this, _ut2);
        __privateSet(this, _ut2, document.createElement("span"));
        __privateGet(this, _ut2).classList.add("markedContent");
        null !== s2.id && __privateGet(this, _ut2).setAttribute("id", `${s2.id}`);
        t3.append(__privateGet(this, _ut2));
      } else "endMarkedContent" === s2.type && __privateSet(this, _ut2, __privateGet(this, _ut2).parentNode);
    }
  };
  Mi_fn = function(t2) {
    var _a4;
    const e2 = document.createElement("span"), i2 = {
      angle: 0,
      canvasWidth: 0,
      hasText: "" !== t2.str,
      hasEOL: t2.hasEOL,
      fontSize: 0
    };
    __privateGet(this, _mi).push(e2);
    const s2 = Util.transform(__privateGet(this, _vi), t2.transform);
    let n2 = Math.atan2(s2[1], s2[0]);
    const r2 = __privateGet(this, _pi)[t2.fontName];
    r2.vertical && (n2 += Math.PI / 2);
    let a2 = __privateGet(this, _ni) && r2.fontSubstitution || r2.fontFamily;
    a2 = _TextLayer.fontFamilyMap.get(a2) || a2;
    const o2 = Math.hypot(s2[2], s2[3]), l2 = o2 * __privateMethod(_a4 = _TextLayer, _TextLayer_static, ki_fn).call(_a4, a2, __privateGet(this, _ri));
    let h2, c2;
    if (0 === n2) {
      h2 = s2[4];
      c2 = s2[5] - l2;
    } else {
      h2 = s2[4] + l2 * Math.sin(n2);
      c2 = s2[5] - l2 * Math.cos(n2);
    }
    const d2 = "calc(var(--scale-factor)*", u2 = e2.style;
    if (__privateGet(this, _ut2) === __privateGet(this, _ci)) {
      u2.left = `${(100 * h2 / __privateGet(this, _li)).toFixed(2)}%`;
      u2.top = `${(100 * c2 / __privateGet(this, _oi)).toFixed(2)}%`;
    } else {
      u2.left = `${d2}${h2.toFixed(2)}px)`;
      u2.top = `${d2}${c2.toFixed(2)}px)`;
    }
    u2.fontSize = `${d2}${(__privateGet(_TextLayer, _xi) * o2).toFixed(2)}px)`;
    u2.fontFamily = a2;
    i2.fontSize = o2;
    e2.setAttribute("role", "presentation");
    e2.textContent = t2.str;
    e2.dir = t2.dir;
    __privateGet(this, _ni) && (e2.dataset.fontName = r2.fontSubstitutionLoadedName || t2.fontName);
    0 !== n2 && (i2.angle = n2 * (180 / Math.PI));
    let p2 = false;
    if (t2.str.length > 1) p2 = true;
    else if (" " !== t2.str && t2.transform[0] !== t2.transform[3]) {
      const e3 = Math.abs(t2.transform[0]), i3 = Math.abs(t2.transform[3]);
      e3 !== i3 && Math.max(e3, i3) / Math.min(e3, i3) > 1.5 && (p2 = true);
    }
    p2 && (i2.canvasWidth = r2.vertical ? t2.height : t2.width);
    __privateGet(this, _bi).set(e2, i2);
    __privateGet(this, _ai).div = e2;
    __privateGet(this, _ai).properties = i2;
    __privateMethod(this, _TextLayer_instances, Ti_fn).call(this, __privateGet(this, _ai));
    i2.hasText && __privateGet(this, _ut2).append(e2);
    if (i2.hasEOL) {
      const t3 = document.createElement("br");
      t3.setAttribute("role", "presentation");
      __privateGet(this, _ut2).append(t3);
    }
  };
  Ti_fn = function(t2) {
    var _a4;
    const { div: e2, properties: i2, ctx: s2 } = t2, { style: n2 } = e2;
    let r2 = "";
    __privateGet(_TextLayer, _xi) > 1 && (r2 = `scale(${1 / __privateGet(_TextLayer, _xi)})`);
    if (0 !== i2.canvasWidth && i2.hasText) {
      const { fontFamily: t3 } = n2, { canvasWidth: a2, fontSize: o2 } = i2;
      __privateMethod(_a4 = _TextLayer, _TextLayer_static, Pi_fn).call(_a4, s2, o2 * __privateGet(this, _ui), t3);
      const { width: l2 } = s2.measureText(e2.textContent);
      l2 > 0 && (r2 = `scaleX(${a2 * __privateGet(this, _ui) / l2}) ${r2}`);
    }
    0 !== i2.angle && (r2 = `rotate(${i2.angle}deg) ${r2}`);
    r2.length > 0 && (n2.transform = r2);
  };
  _TextLayer_static = new WeakSet();
  Si_fn = function(t2 = null) {
    let e2 = __privateGet(this, _Ai).get(t2 || (t2 = ""));
    if (!e2) {
      const i2 = document.createElement("canvas");
      i2.className = "hiddenCanvasElement";
      i2.lang = t2;
      document.body.append(i2);
      e2 = i2.getContext("2d", {
        alpha: false,
        willReadFrequently: true
      });
      __privateGet(this, _Ai).set(t2, e2);
      __privateGet(this, _wi).set(e2, {
        size: 0,
        family: ""
      });
    }
    return e2;
  };
  Pi_fn = function(t2, e2, i2) {
    const s2 = __privateGet(this, _wi).get(t2);
    if (e2 !== s2.size || i2 !== s2.family) {
      t2.font = `${e2}px ${i2}`;
      s2.size = e2;
      s2.family = i2;
    }
  };
  Ei_fn = function() {
    if (null !== __privateGet(this, _xi)) return;
    const t2 = document.createElement("div");
    t2.style.opacity = 0;
    t2.style.lineHeight = 1;
    t2.style.fontSize = "1px";
    t2.style.position = "absolute";
    t2.textContent = "X";
    document.body.append(t2);
    __privateSet(this, _xi, t2.getBoundingClientRect().height);
    t2.remove();
  };
  ki_fn = function(t2, e2) {
    const i2 = __privateGet(this, _yi).get(t2);
    if (i2) return i2;
    const s2 = __privateMethod(this, _TextLayer_static, Si_fn).call(this, e2);
    s2.canvas.width = s2.canvas.height = jt;
    __privateMethod(this, _TextLayer_static, Pi_fn).call(this, s2, jt, t2);
    const n2 = s2.measureText("");
    let r2 = n2.fontBoundingBoxAscent, a2 = Math.abs(n2.fontBoundingBoxDescent);
    if (r2) {
      const e3 = r2 / (r2 + a2);
      __privateGet(this, _yi).set(t2, e3);
      s2.canvas.width = s2.canvas.height = 0;
      return e3;
    }
    s2.strokeStyle = "red";
    s2.clearRect(0, 0, jt, jt);
    s2.strokeText("g", 0, 0);
    let o2 = s2.getImageData(0, 0, jt, jt).data;
    a2 = 0;
    for (let t3 = o2.length - 1 - 3; t3 >= 0; t3 -= 4) if (o2[t3] > 0) {
      a2 = Math.ceil(t3 / 4 / jt);
      break;
    }
    s2.clearRect(0, 0, jt, jt);
    s2.strokeText("A", 0, jt);
    o2 = s2.getImageData(0, 0, jt, jt).data;
    r2 = 0;
    for (let t3 = 0, e3 = o2.length; t3 < e3; t3 += 4) if (o2[t3] > 0) {
      r2 = jt - Math.floor(t3 / 4 / jt);
      break;
    }
    s2.canvas.width = s2.canvas.height = 0;
    const l2 = r2 ? r2 / (r2 + a2) : 0.8;
    __privateGet(this, _yi).set(t2, l2);
    return l2;
  };
  __privateAdd(_TextLayer, _TextLayer_static);
  __privateAdd(_TextLayer, _yi, /* @__PURE__ */ new Map());
  __privateAdd(_TextLayer, _Ai, /* @__PURE__ */ new Map());
  __privateAdd(_TextLayer, _wi, /* @__PURE__ */ new WeakMap());
  __privateAdd(_TextLayer, _xi, null);
  __privateAdd(_TextLayer, __i, /* @__PURE__ */ new Set());
  let TextLayer = _TextLayer;
  class XfaText {
    static textContent(t2) {
      const e2 = [], i2 = {
        items: e2,
        styles: /* @__PURE__ */ Object.create(null)
      };
      !function walk(t3) {
        var _a4;
        if (!t3) return;
        let i3 = null;
        const s2 = t3.name;
        if ("#text" === s2) i3 = t3.value;
        else {
          if (!XfaText.shouldBuildText(s2)) return;
          ((_a4 = t3 == null ? void 0 : t3.attributes) == null ? void 0 : _a4.textContent) ? i3 = t3.attributes.textContent : t3.value && (i3 = t3.value);
        }
        null !== i3 && e2.push({
          str: i3
        });
        if (t3.children) for (const e3 of t3.children) walk(e3);
      }(t2);
      return i2;
    }
    static shouldBuildText(t2) {
      return !("textarea" === t2 || "input" === t2 || "option" === t2 || "select" === t2);
    }
  }
  const Wt = 65536, Gt = i ? class NodeCanvasFactory extends BaseCanvasFactory {
    _createCanvas(t2, e2) {
      return NodePackages.get("canvas").createCanvas(t2, e2);
    }
  } : class DOMCanvasFactory extends BaseCanvasFactory {
    constructor({ ownerDocument: t2 = globalThis.document, enableHWA: e2 = false }) {
      super({
        enableHWA: e2
      });
      this._document = t2;
    }
    _createCanvas(t2, e2) {
      const i2 = this._document.createElement("canvas");
      i2.width = t2;
      i2.height = e2;
      return i2;
    }
  }, Vt = i ? class NodeCMapReaderFactory extends BaseCMapReaderFactory {
    async _fetch(t2) {
      return node_utils_fetchData(t2);
    }
  } : DOMCMapReaderFactory, $t = i ? class NodeFilterFactory extends BaseFilterFactory {
  } : (_b = class extends BaseFilterFactory {
    constructor({ docId: t2, ownerDocument: e2 = globalThis.document }) {
      super();
      __privateAdd(this, _DOMFilterFactory_instances);
      __privateAdd(this, _Ri);
      __privateAdd(this, _Di);
      __privateAdd(this, _Ii);
      __privateAdd(this, _Fi);
      __privateAdd(this, _Li);
      __privateAdd(this, _Oi);
      __privateAdd(this, _y3, 0);
      __privateSet(this, _Fi, t2);
      __privateSet(this, _Li, e2);
    }
    addFilter(t2) {
      if (!t2) return "none";
      let e2 = __privateGet(this, _DOMFilterFactory_instances, w_get).get(t2);
      if (e2) return e2;
      const [i2, s2, n2] = __privateMethod(this, _DOMFilterFactory_instances, Hi_fn).call(this, t2), r2 = 1 === t2.length ? i2 : `${i2}${s2}${n2}`;
      e2 = __privateGet(this, _DOMFilterFactory_instances, w_get).get(r2);
      if (e2) {
        __privateGet(this, _DOMFilterFactory_instances, w_get).set(t2, e2);
        return e2;
      }
      const a2 = `g_${__privateGet(this, _Fi)}_transfer_map_${__privateWrapper(this, _y3)._++}`, o2 = __privateMethod(this, _DOMFilterFactory_instances, Ui_fn).call(this, a2);
      __privateGet(this, _DOMFilterFactory_instances, w_get).set(t2, o2);
      __privateGet(this, _DOMFilterFactory_instances, w_get).set(r2, o2);
      const l2 = __privateMethod(this, _DOMFilterFactory_instances, zi_fn).call(this, a2);
      __privateMethod(this, _DOMFilterFactory_instances, ji_fn).call(this, i2, s2, n2, l2);
      return o2;
    }
    addHCMFilter(t2, e2) {
      var _a4;
      const i2 = `${t2}-${e2}`, s2 = "base";
      let n2 = __privateGet(this, _DOMFilterFactory_instances, Ni_get).get(s2);
      if ((n2 == null ? void 0 : n2.key) === i2) return n2.url;
      if (n2) {
        (_a4 = n2.filter) == null ? void 0 : _a4.remove();
        n2.key = i2;
        n2.url = "none";
        n2.filter = null;
      } else {
        n2 = {
          key: i2,
          url: "none",
          filter: null
        };
        __privateGet(this, _DOMFilterFactory_instances, Ni_get).set(s2, n2);
      }
      if (!t2 || !e2) return n2.url;
      const r2 = __privateMethod(this, _DOMFilterFactory_instances, Wi_fn).call(this, t2);
      t2 = Util.makeHexColor(...r2);
      const a2 = __privateMethod(this, _DOMFilterFactory_instances, Wi_fn).call(this, e2);
      e2 = Util.makeHexColor(...a2);
      __privateGet(this, _DOMFilterFactory_instances, Bi_get).style.color = "";
      if ("#000000" === t2 && "#ffffff" === e2 || t2 === e2) return n2.url;
      const o2 = new Array(256);
      for (let t3 = 0; t3 <= 255; t3++) {
        const e3 = t3 / 255;
        o2[t3] = e3 <= 0.03928 ? e3 / 12.92 : ((e3 + 0.055) / 1.055) ** 2.4;
      }
      const l2 = o2.join(","), h2 = `g_${__privateGet(this, _Fi)}_hcm_filter`, c2 = n2.filter = __privateMethod(this, _DOMFilterFactory_instances, zi_fn).call(this, h2);
      __privateMethod(this, _DOMFilterFactory_instances, ji_fn).call(this, l2, l2, l2, c2);
      __privateMethod(this, _DOMFilterFactory_instances, Gi_fn).call(this, c2);
      const getSteps = (t3, e3) => {
        const i3 = r2[t3] / 255, s3 = a2[t3] / 255, n3 = new Array(e3 + 1);
        for (let t4 = 0; t4 <= e3; t4++) n3[t4] = i3 + t4 / e3 * (s3 - i3);
        return n3.join(",");
      };
      __privateMethod(this, _DOMFilterFactory_instances, ji_fn).call(this, getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), c2);
      n2.url = __privateMethod(this, _DOMFilterFactory_instances, Ui_fn).call(this, h2);
      return n2.url;
    }
    addAlphaFilter(t2) {
      let e2 = __privateGet(this, _DOMFilterFactory_instances, w_get).get(t2);
      if (e2) return e2;
      const [i2] = __privateMethod(this, _DOMFilterFactory_instances, Hi_fn).call(this, [
        t2
      ]), s2 = `alpha_${i2}`;
      e2 = __privateGet(this, _DOMFilterFactory_instances, w_get).get(s2);
      if (e2) {
        __privateGet(this, _DOMFilterFactory_instances, w_get).set(t2, e2);
        return e2;
      }
      const n2 = `g_${__privateGet(this, _Fi)}_alpha_map_${__privateWrapper(this, _y3)._++}`, r2 = __privateMethod(this, _DOMFilterFactory_instances, Ui_fn).call(this, n2);
      __privateGet(this, _DOMFilterFactory_instances, w_get).set(t2, r2);
      __privateGet(this, _DOMFilterFactory_instances, w_get).set(s2, r2);
      const a2 = __privateMethod(this, _DOMFilterFactory_instances, zi_fn).call(this, n2);
      __privateMethod(this, _DOMFilterFactory_instances, Vi_fn).call(this, i2, a2);
      return r2;
    }
    addLuminosityFilter(t2) {
      let e2, i2, s2 = __privateGet(this, _DOMFilterFactory_instances, w_get).get(t2 || "luminosity");
      if (s2) return s2;
      if (t2) {
        [e2] = __privateMethod(this, _DOMFilterFactory_instances, Hi_fn).call(this, [
          t2
        ]);
        i2 = `luminosity_${e2}`;
      } else i2 = "luminosity";
      s2 = __privateGet(this, _DOMFilterFactory_instances, w_get).get(i2);
      if (s2) {
        __privateGet(this, _DOMFilterFactory_instances, w_get).set(t2, s2);
        return s2;
      }
      const n2 = `g_${__privateGet(this, _Fi)}_luminosity_map_${__privateWrapper(this, _y3)._++}`, r2 = __privateMethod(this, _DOMFilterFactory_instances, Ui_fn).call(this, n2);
      __privateGet(this, _DOMFilterFactory_instances, w_get).set(t2, r2);
      __privateGet(this, _DOMFilterFactory_instances, w_get).set(i2, r2);
      const a2 = __privateMethod(this, _DOMFilterFactory_instances, zi_fn).call(this, n2);
      __privateMethod(this, _DOMFilterFactory_instances, $i_fn).call(this, a2);
      t2 && __privateMethod(this, _DOMFilterFactory_instances, Vi_fn).call(this, e2, a2);
      return r2;
    }
    addHighlightHCMFilter(t2, e2, i2, s2, n2) {
      var _a4;
      const r2 = `${e2}-${i2}-${s2}-${n2}`;
      let a2 = __privateGet(this, _DOMFilterFactory_instances, Ni_get).get(t2);
      if ((a2 == null ? void 0 : a2.key) === r2) return a2.url;
      if (a2) {
        (_a4 = a2.filter) == null ? void 0 : _a4.remove();
        a2.key = r2;
        a2.url = "none";
        a2.filter = null;
      } else {
        a2 = {
          key: r2,
          url: "none",
          filter: null
        };
        __privateGet(this, _DOMFilterFactory_instances, Ni_get).set(t2, a2);
      }
      if (!e2 || !i2) return a2.url;
      const [o2, l2] = [
        e2,
        i2
      ].map(__privateMethod(this, _DOMFilterFactory_instances, Wi_fn).bind(this));
      let h2 = Math.round(0.2126 * o2[0] + 0.7152 * o2[1] + 0.0722 * o2[2]), c2 = Math.round(0.2126 * l2[0] + 0.7152 * l2[1] + 0.0722 * l2[2]), [d2, u2] = [
        s2,
        n2
      ].map(__privateMethod(this, _DOMFilterFactory_instances, Wi_fn).bind(this));
      c2 < h2 && ([h2, c2, d2, u2] = [
        c2,
        h2,
        u2,
        d2
      ]);
      __privateGet(this, _DOMFilterFactory_instances, Bi_get).style.color = "";
      const getSteps = (t3, e3, i3) => {
        const s3 = new Array(256), n3 = (c2 - h2) / i3, r3 = t3 / 255, a3 = (e3 - t3) / (255 * i3);
        let o3 = 0;
        for (let t4 = 0; t4 <= i3; t4++) {
          const e4 = Math.round(h2 + t4 * n3), i4 = r3 + t4 * a3;
          for (let t5 = o3; t5 <= e4; t5++) s3[t5] = i4;
          o3 = e4 + 1;
        }
        for (let t4 = o3; t4 < 256; t4++) s3[t4] = s3[o3 - 1];
        return s3.join(",");
      }, p2 = `g_${__privateGet(this, _Fi)}_hcm_${t2}_filter`, g2 = a2.filter = __privateMethod(this, _DOMFilterFactory_instances, zi_fn).call(this, p2);
      __privateMethod(this, _DOMFilterFactory_instances, Gi_fn).call(this, g2);
      __privateMethod(this, _DOMFilterFactory_instances, ji_fn).call(this, getSteps(d2[0], u2[0], 5), getSteps(d2[1], u2[1], 5), getSteps(d2[2], u2[2], 5), g2);
      a2.url = __privateMethod(this, _DOMFilterFactory_instances, Ui_fn).call(this, p2);
      return a2.url;
    }
    destroy(t2 = false) {
      if (!t2 || 0 === __privateGet(this, _DOMFilterFactory_instances, Ni_get).size) {
        if (__privateGet(this, _Ii)) {
          __privateGet(this, _Ii).parentNode.parentNode.remove();
          __privateSet(this, _Ii, null);
        }
        if (__privateGet(this, _Di)) {
          __privateGet(this, _Di).clear();
          __privateSet(this, _Di, null);
        }
        __privateSet(this, _y3, 0);
      }
    }
  }, _Ri = new WeakMap(), _Di = new WeakMap(), _Ii = new WeakMap(), _Fi = new WeakMap(), _Li = new WeakMap(), _Oi = new WeakMap(), _y3 = new WeakMap(), _DOMFilterFactory_instances = new WeakSet(), w_get = function() {
    return __privateGet(this, _Di) || __privateSet(this, _Di, /* @__PURE__ */ new Map());
  }, Ni_get = function() {
    return __privateGet(this, _Oi) || __privateSet(this, _Oi, /* @__PURE__ */ new Map());
  }, Bi_get = function() {
    if (!__privateGet(this, _Ii)) {
      const t2 = __privateGet(this, _Li).createElement("div"), { style: e2 } = t2;
      e2.visibility = "hidden";
      e2.contain = "strict";
      e2.width = e2.height = 0;
      e2.position = "absolute";
      e2.top = e2.left = 0;
      e2.zIndex = -1;
      const i2 = __privateGet(this, _Li).createElementNS(pt, "svg");
      i2.setAttribute("width", 0);
      i2.setAttribute("height", 0);
      __privateSet(this, _Ii, __privateGet(this, _Li).createElementNS(pt, "defs"));
      t2.append(i2);
      i2.append(__privateGet(this, _Ii));
      __privateGet(this, _Li).body.append(t2);
    }
    return __privateGet(this, _Ii);
  }, Hi_fn = function(t2) {
    if (1 === t2.length) {
      const e3 = t2[0], i3 = new Array(256);
      for (let t3 = 0; t3 < 256; t3++) i3[t3] = e3[t3] / 255;
      const s3 = i3.join(",");
      return [
        s3,
        s3,
        s3
      ];
    }
    const [e2, i2, s2] = t2, n2 = new Array(256), r2 = new Array(256), a2 = new Array(256);
    for (let t3 = 0; t3 < 256; t3++) {
      n2[t3] = e2[t3] / 255;
      r2[t3] = i2[t3] / 255;
      a2[t3] = s2[t3] / 255;
    }
    return [
      n2.join(","),
      r2.join(","),
      a2.join(",")
    ];
  }, Ui_fn = function(t2) {
    if (void 0 === __privateGet(this, _Ri)) {
      __privateSet(this, _Ri, "");
      const t3 = __privateGet(this, _Li).URL;
      t3 !== __privateGet(this, _Li).baseURI && (isDataScheme(t3) ? warn('#createUrl: ignore "data:"-URL for performance reasons.') : __privateSet(this, _Ri, t3.split("#", 1)[0]));
    }
    return `url(${__privateGet(this, _Ri)}#${t2})`;
  }, $i_fn = function(t2) {
    const e2 = __privateGet(this, _Li).createElementNS(pt, "feColorMatrix");
    e2.setAttribute("type", "matrix");
    e2.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
    t2.append(e2);
  }, Gi_fn = function(t2) {
    const e2 = __privateGet(this, _Li).createElementNS(pt, "feColorMatrix");
    e2.setAttribute("type", "matrix");
    e2.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
    t2.append(e2);
  }, zi_fn = function(t2) {
    const e2 = __privateGet(this, _Li).createElementNS(pt, "filter");
    e2.setAttribute("color-interpolation-filters", "sRGB");
    e2.setAttribute("id", t2);
    __privateGet(this, _DOMFilterFactory_instances, Bi_get).append(e2);
    return e2;
  }, qi_fn = function(t2, e2, i2) {
    const s2 = __privateGet(this, _Li).createElementNS(pt, e2);
    s2.setAttribute("type", "discrete");
    s2.setAttribute("tableValues", i2);
    t2.append(s2);
  }, ji_fn = function(t2, e2, i2, s2) {
    const n2 = __privateGet(this, _Li).createElementNS(pt, "feComponentTransfer");
    s2.append(n2);
    __privateMethod(this, _DOMFilterFactory_instances, qi_fn).call(this, n2, "feFuncR", t2);
    __privateMethod(this, _DOMFilterFactory_instances, qi_fn).call(this, n2, "feFuncG", e2);
    __privateMethod(this, _DOMFilterFactory_instances, qi_fn).call(this, n2, "feFuncB", i2);
  }, Vi_fn = function(t2, e2) {
    const i2 = __privateGet(this, _Li).createElementNS(pt, "feComponentTransfer");
    e2.append(i2);
    __privateMethod(this, _DOMFilterFactory_instances, qi_fn).call(this, i2, "feFuncA", t2);
  }, Wi_fn = function(t2) {
    __privateGet(this, _DOMFilterFactory_instances, Bi_get).style.color = t2;
    return getRGB(getComputedStyle(__privateGet(this, _DOMFilterFactory_instances, Bi_get)).getPropertyValue("color"));
  }, _b), qt = i ? class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
    async _fetch(t2) {
      return node_utils_fetchData(t2);
    }
  } : DOMStandardFontDataFactory;
  function getDocument(t2 = {}) {
    "string" == typeof t2 || t2 instanceof URL ? t2 = {
      url: t2
    } : (t2 instanceof ArrayBuffer || ArrayBuffer.isView(t2)) && (t2 = {
      data: t2
    });
    const e2 = new PDFDocumentLoadingTask(), { docId: s2 } = e2, n2 = t2.url ? function getUrlProp(t3) {
      if (t3 instanceof URL) return t3.href;
      try {
        return new URL(t3, window.location).href;
      } catch {
        if (i && "string" == typeof t3) return t3;
      }
      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
    }(t2.url) : null, r2 = t2.data ? function getDataProp(t3) {
      if (i && "undefined" != typeof Buffer2 && t3 instanceof Buffer2) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
      if (t3 instanceof Uint8Array && t3.byteLength === t3.buffer.byteLength) return t3;
      if ("string" == typeof t3) return stringToBytes(t3);
      if (t3 instanceof ArrayBuffer || ArrayBuffer.isView(t3) || "object" == typeof t3 && !isNaN(t3 == null ? void 0 : t3.length)) return new Uint8Array(t3);
      throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
    }(t2.data) : null, a2 = t2.httpHeaders || null, o2 = true === t2.withCredentials, l2 = t2.password ?? null, h2 = t2.range instanceof PDFDataRangeTransport ? t2.range : null, c2 = Number.isInteger(t2.rangeChunkSize) && t2.rangeChunkSize > 0 ? t2.rangeChunkSize : Wt;
    let d2 = t2.worker instanceof PDFWorker ? t2.worker : null;
    const u2 = t2.verbosity, p2 = "string" != typeof t2.docBaseUrl || isDataScheme(t2.docBaseUrl) ? null : t2.docBaseUrl, g2 = "string" == typeof t2.cMapUrl ? t2.cMapUrl : null, f2 = false !== t2.cMapPacked, m2 = t2.CMapReaderFactory || Vt, b2 = "string" == typeof t2.standardFontDataUrl ? t2.standardFontDataUrl : null, v2 = t2.StandardFontDataFactory || qt, y2 = true !== t2.stopAtErrors, A2 = Number.isInteger(t2.maxImageSize) && t2.maxImageSize > -1 ? t2.maxImageSize : -1, w2 = false !== t2.isEvalSupported, x2 = "boolean" == typeof t2.isOffscreenCanvasSupported ? t2.isOffscreenCanvasSupported : !i, _2 = "boolean" == typeof t2.isChrome ? t2.isChrome : !util_FeatureTest.platform.isFirefox && "undefined" != typeof window && !!(window == null ? void 0 : window.chrome), E2 = Number.isInteger(t2.canvasMaxAreaInBytes) ? t2.canvasMaxAreaInBytes : -1, C2 = "boolean" == typeof t2.disableFontFace ? t2.disableFontFace : i, S2 = true === t2.fontExtraProperties, T2 = true === t2.enableXfa, M2 = t2.ownerDocument || globalThis.document, k2 = true === t2.disableRange, P2 = true === t2.disableStream, R2 = true === t2.disableAutoFetch, D2 = true === t2.pdfBug, I2 = t2.CanvasFactory || Gt, L2 = t2.FilterFactory || $t, O2 = true === t2.enableHWA, N2 = h2 ? h2.length : t2.length ?? NaN, B2 = "boolean" == typeof t2.useSystemFonts ? t2.useSystemFonts : !i && !C2, H2 = "boolean" == typeof t2.useWorkerFetch ? t2.useWorkerFetch : m2 === DOMCMapReaderFactory && v2 === DOMStandardFontDataFactory && g2 && b2 && isValidFetchUrl(g2, document.baseURI) && isValidFetchUrl(b2, document.baseURI);
    t2.canvasFactory && deprecated("`canvasFactory`-instance option, please use `CanvasFactory` instead.");
    t2.filterFactory && deprecated("`filterFactory`-instance option, please use `FilterFactory` instead.");
    setVerbosityLevel(u2);
    const U2 = {
      canvasFactory: new I2({
        ownerDocument: M2,
        enableHWA: O2
      }),
      filterFactory: new L2({
        docId: s2,
        ownerDocument: M2
      }),
      cMapReaderFactory: H2 ? null : new m2({
        baseUrl: g2,
        isCompressed: f2
      }),
      standardFontDataFactory: H2 ? null : new v2({
        baseUrl: b2
      })
    };
    if (!d2) {
      const t3 = {
        verbosity: u2,
        port: GlobalWorkerOptions.workerPort
      };
      d2 = t3.port ? PDFWorker.fromPort(t3) : new PDFWorker(t3);
      e2._worker = d2;
    }
    const z2 = {
      docId: s2,
      apiVersion: "4.8.69",
      data: r2,
      password: l2,
      disableAutoFetch: R2,
      rangeChunkSize: c2,
      length: N2,
      docBaseUrl: p2,
      enableXfa: T2,
      evaluatorOptions: {
        maxImageSize: A2,
        disableFontFace: C2,
        ignoreErrors: y2,
        isEvalSupported: w2,
        isOffscreenCanvasSupported: x2,
        isChrome: _2,
        canvasMaxAreaInBytes: E2,
        fontExtraProperties: S2,
        useSystemFonts: B2,
        cMapUrl: H2 ? g2 : null,
        standardFontDataUrl: H2 ? b2 : null
      }
    }, j2 = {
      disableFontFace: C2,
      fontExtraProperties: S2,
      ownerDocument: M2,
      pdfBug: D2,
      styleElement: null,
      loadingParams: {
        disableAutoFetch: R2,
        enableXfa: T2
      }
    };
    d2.promise.then(function() {
      if (e2.destroyed) throw new Error("Loading aborted");
      if (d2.destroyed) throw new Error("Worker was destroyed");
      const t3 = d2.messageHandler.sendWithPromise("GetDocRequest", z2, r2 ? [
        r2.buffer
      ] : null);
      let l3;
      if (h2) l3 = new PDFDataTransportStream(h2, {
        disableRange: k2,
        disableStream: P2
      });
      else if (!r2) {
        if (!n2) throw new Error("getDocument - no `url` parameter provided.");
        let t4;
        if (i) {
          t4 = "undefined" != typeof fetch && "undefined" != typeof Response && "body" in Response.prototype && isValidFetchUrl(n2) ? PDFFetchStream : PDFNodeStream;
        } else t4 = isValidFetchUrl(n2) ? PDFFetchStream : PDFNetworkStream;
        l3 = new t4({
          url: n2,
          length: N2,
          httpHeaders: a2,
          withCredentials: o2,
          rangeChunkSize: c2,
          disableRange: k2,
          disableStream: P2
        });
      }
      return t3.then((t4) => {
        if (e2.destroyed) throw new Error("Loading aborted");
        if (d2.destroyed) throw new Error("Worker was destroyed");
        const i2 = new MessageHandler(s2, t4, d2.port), n3 = new WorkerTransport(i2, e2, l3, j2, U2);
        e2._transport = n3;
        i2.send("Ready", null);
      });
    }).catch(e2._capability.reject);
    return e2;
  }
  function isRefProxy(t2) {
    return "object" == typeof t2 && Number.isInteger(t2 == null ? void 0 : t2.num) && t2.num >= 0 && Number.isInteger(t2 == null ? void 0 : t2.gen) && t2.gen >= 0;
  }
  const _PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
    constructor() {
      this._capability = Promise.withResolvers();
      this._transport = null;
      this._worker = null;
      this.docId = "d" + __privateWrapper(_PDFDocumentLoadingTask, _Fi2)._++;
      this.destroyed = false;
      this.onPassword = null;
      this.onProgress = null;
    }
    get promise() {
      return this._capability.promise;
    }
    async destroy() {
      var _a4, _b2, _c;
      this.destroyed = true;
      try {
        ((_a4 = this._worker) == null ? void 0 : _a4.port) && (this._worker._pendingDestroy = true);
        await ((_b2 = this._transport) == null ? void 0 : _b2.destroy());
      } catch (t2) {
        ((_c = this._worker) == null ? void 0 : _c.port) && delete this._worker._pendingDestroy;
        throw t2;
      }
      this._transport = null;
      if (this._worker) {
        this._worker.destroy();
        this._worker = null;
      }
    }
  };
  _Fi2 = new WeakMap();
  __privateAdd(_PDFDocumentLoadingTask, _Fi2, 0);
  let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
  class PDFDataRangeTransport {
    constructor(t2, e2, i2 = false, s2 = null) {
      this.length = t2;
      this.initialData = e2;
      this.progressiveDone = i2;
      this.contentDispositionFilename = s2;
      this._rangeListeners = [];
      this._progressListeners = [];
      this._progressiveReadListeners = [];
      this._progressiveDoneListeners = [];
      this._readyCapability = Promise.withResolvers();
    }
    addRangeListener(t2) {
      this._rangeListeners.push(t2);
    }
    addProgressListener(t2) {
      this._progressListeners.push(t2);
    }
    addProgressiveReadListener(t2) {
      this._progressiveReadListeners.push(t2);
    }
    addProgressiveDoneListener(t2) {
      this._progressiveDoneListeners.push(t2);
    }
    onDataRange(t2, e2) {
      for (const i2 of this._rangeListeners) i2(t2, e2);
    }
    onDataProgress(t2, e2) {
      this._readyCapability.promise.then(() => {
        for (const i2 of this._progressListeners) i2(t2, e2);
      });
    }
    onDataProgressiveRead(t2) {
      this._readyCapability.promise.then(() => {
        for (const e2 of this._progressiveReadListeners) e2(t2);
      });
    }
    onDataProgressiveDone() {
      this._readyCapability.promise.then(() => {
        for (const t2 of this._progressiveDoneListeners) t2();
      });
    }
    transportReady() {
      this._readyCapability.resolve();
    }
    requestDataRange(t2, e2) {
      unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
    }
    abort() {
    }
  }
  class PDFDocumentProxy {
    constructor(t2, e2) {
      this._pdfInfo = t2;
      this._transport = e2;
    }
    get annotationStorage() {
      return this._transport.annotationStorage;
    }
    get canvasFactory() {
      return this._transport.canvasFactory;
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get numPages() {
      return this._pdfInfo.numPages;
    }
    get fingerprints() {
      return this._pdfInfo.fingerprints;
    }
    get isPureXfa() {
      return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    get allXfaHtml() {
      return this._transport._htmlForXfa;
    }
    getPage(t2) {
      return this._transport.getPage(t2);
    }
    getPageIndex(t2) {
      return this._transport.getPageIndex(t2);
    }
    getDestinations() {
      return this._transport.getDestinations();
    }
    getDestination(t2) {
      return this._transport.getDestination(t2);
    }
    getPageLabels() {
      return this._transport.getPageLabels();
    }
    getPageLayout() {
      return this._transport.getPageLayout();
    }
    getPageMode() {
      return this._transport.getPageMode();
    }
    getViewerPreferences() {
      return this._transport.getViewerPreferences();
    }
    getOpenAction() {
      return this._transport.getOpenAction();
    }
    getAttachments() {
      return this._transport.getAttachments();
    }
    getJSActions() {
      return this._transport.getDocJSActions();
    }
    getOutline() {
      return this._transport.getOutline();
    }
    getOptionalContentConfig({ intent: t2 = "display" } = {}) {
      const { renderingIntent: e2 } = this._transport.getRenderingIntent(t2);
      return this._transport.getOptionalContentConfig(e2);
    }
    getPermissions() {
      return this._transport.getPermissions();
    }
    getMetadata() {
      return this._transport.getMetadata();
    }
    getMarkInfo() {
      return this._transport.getMarkInfo();
    }
    getData() {
      return this._transport.getData();
    }
    saveDocument() {
      return this._transport.saveDocument();
    }
    getDownloadInfo() {
      return this._transport.downloadInfoCapability.promise;
    }
    cleanup(t2 = false) {
      return this._transport.startCleanup(t2 || this.isPureXfa);
    }
    destroy() {
      return this.loadingTask.destroy();
    }
    cachedPageNumber(t2) {
      return this._transport.cachedPageNumber(t2);
    }
    get loadingParams() {
      return this._transport.loadingParams;
    }
    get loadingTask() {
      return this._transport.loadingTask;
    }
    getFieldObjects() {
      return this._transport.getFieldObjects();
    }
    hasJSActions() {
      return this._transport.hasJSActions();
    }
    getCalculationOrderIds() {
      return this._transport.getCalculationOrderIds();
    }
  }
  class PDFPageProxy {
    constructor(t2, e2, i2, s2 = false) {
      __privateAdd(this, _PDFPageProxy_instances);
      __privateAdd(this, _Xi, null);
      __privateAdd(this, _Ki, false);
      this._pageIndex = t2;
      this._pageInfo = e2;
      this._transport = i2;
      this._stats = s2 ? new StatTimer() : null;
      this._pdfBug = s2;
      this.commonObjs = i2.commonObjs;
      this.objs = new PDFObjects();
      this._maybeCleanupAfterRender = false;
      this._intentStates = /* @__PURE__ */ new Map();
      this.destroyed = false;
    }
    get pageNumber() {
      return this._pageIndex + 1;
    }
    get rotate() {
      return this._pageInfo.rotate;
    }
    get ref() {
      return this._pageInfo.ref;
    }
    get userUnit() {
      return this._pageInfo.userUnit;
    }
    get view() {
      return this._pageInfo.view;
    }
    getViewport({ scale: t2, rotation: e2 = this.rotate, offsetX: i2 = 0, offsetY: s2 = 0, dontFlip: n2 = false } = {}) {
      return new PageViewport({
        viewBox: this.view,
        scale: t2,
        rotation: e2,
        offsetX: i2,
        offsetY: s2,
        dontFlip: n2
      });
    }
    getAnnotations({ intent: t2 = "display" } = {}) {
      const { renderingIntent: e2 } = this._transport.getRenderingIntent(t2);
      return this._transport.getAnnotations(this._pageIndex, e2);
    }
    getJSActions() {
      return this._transport.getPageJSActions(this._pageIndex);
    }
    get filterFactory() {
      return this._transport.filterFactory;
    }
    get isPureXfa() {
      return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
    }
    async getXfa() {
      var _a4;
      return ((_a4 = this._transport._htmlForXfa) == null ? void 0 : _a4.children[this._pageIndex]) || null;
    }
    render({ canvasContext: t2, viewport: e2, intent: i2 = "display", annotationMode: s2 = g.ENABLE, transform: n2 = null, background: r2 = null, optionalContentConfigPromise: a2 = null, annotationCanvasMap: o2 = null, pageColors: h2 = null, printAnnotationStorage: c2 = null, isEditing: d2 = false }) {
      var _a4, _b2;
      (_a4 = this._stats) == null ? void 0 : _a4.time("Overall");
      const u2 = this._transport.getRenderingIntent(i2, s2, c2, d2), { renderingIntent: p2, cacheKey: f2 } = u2;
      __privateSet(this, _Ki, false);
      __privateMethod(this, _PDFPageProxy_instances, Yi_fn).call(this);
      a2 || (a2 = this._transport.getOptionalContentConfig(p2));
      let m2 = this._intentStates.get(f2);
      if (!m2) {
        m2 = /* @__PURE__ */ Object.create(null);
        this._intentStates.set(f2, m2);
      }
      if (m2.streamReaderCancelTimeout) {
        clearTimeout(m2.streamReaderCancelTimeout);
        m2.streamReaderCancelTimeout = null;
      }
      const b2 = !!(p2 & l);
      if (!m2.displayReadyCapability) {
        m2.displayReadyCapability = Promise.withResolvers();
        m2.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false,
          separateAnnots: null
        };
        (_b2 = this._stats) == null ? void 0 : _b2.time("Page Request");
        this._pumpOperatorList(u2);
      }
      const complete = (t3) => {
        var _a5;
        m2.renderTasks.delete(v2);
        (this._maybeCleanupAfterRender || b2) && __privateSet(this, _Ki, true);
        __privateMethod(this, _PDFPageProxy_instances, Qi_fn).call(this, !b2);
        if (t3) {
          v2.capability.reject(t3);
          this._abortOperatorList({
            intentState: m2,
            reason: t3 instanceof Error ? t3 : new Error(t3)
          });
        } else v2.capability.resolve();
        if (this._stats) {
          this._stats.timeEnd("Rendering");
          this._stats.timeEnd("Overall");
          ((_a5 = globalThis.Stats) == null ? void 0 : _a5.enabled) && globalThis.Stats.add(this.pageNumber, this._stats);
        }
      }, v2 = new InternalRenderTask({
        callback: complete,
        params: {
          canvasContext: t2,
          viewport: e2,
          transform: n2,
          background: r2
        },
        objs: this.objs,
        commonObjs: this.commonObjs,
        annotationCanvasMap: o2,
        operatorList: m2.operatorList,
        pageIndex: this._pageIndex,
        canvasFactory: this._transport.canvasFactory,
        filterFactory: this._transport.filterFactory,
        useRequestAnimationFrame: !b2,
        pdfBug: this._pdfBug,
        pageColors: h2
      });
      (m2.renderTasks || (m2.renderTasks = /* @__PURE__ */ new Set())).add(v2);
      const y2 = v2.task;
      Promise.all([
        m2.displayReadyCapability.promise,
        a2
      ]).then(([t3, e3]) => {
        var _a5;
        if (this.destroyed) complete();
        else {
          (_a5 = this._stats) == null ? void 0 : _a5.time("Rendering");
          if (!(e3.renderingIntent & p2)) throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
          v2.initializeGraphics({
            transparency: t3,
            optionalContentConfig: e3
          });
          v2.operatorListChanged();
        }
      }).catch(complete);
      return y2;
    }
    getOperatorList({ intent: t2 = "display", annotationMode: e2 = g.ENABLE, printAnnotationStorage: i2 = null, isEditing: s2 = false } = {}) {
      var _a4;
      const n2 = this._transport.getRenderingIntent(t2, e2, i2, s2, true);
      let r2, a2 = this._intentStates.get(n2.cacheKey);
      if (!a2) {
        a2 = /* @__PURE__ */ Object.create(null);
        this._intentStates.set(n2.cacheKey, a2);
      }
      if (!a2.opListReadCapability) {
        r2 = /* @__PURE__ */ Object.create(null);
        r2.operatorListChanged = function operatorListChanged() {
          if (a2.operatorList.lastChunk) {
            a2.opListReadCapability.resolve(a2.operatorList);
            a2.renderTasks.delete(r2);
          }
        };
        a2.opListReadCapability = Promise.withResolvers();
        (a2.renderTasks || (a2.renderTasks = /* @__PURE__ */ new Set())).add(r2);
        a2.operatorList = {
          fnArray: [],
          argsArray: [],
          lastChunk: false,
          separateAnnots: null
        };
        (_a4 = this._stats) == null ? void 0 : _a4.time("Page Request");
        this._pumpOperatorList(n2);
      }
      return a2.opListReadCapability.promise;
    }
    streamTextContent({ includeMarkedContent: t2 = false, disableNormalization: e2 = false } = {}) {
      return this._transport.messageHandler.sendWithStream("GetTextContent", {
        pageIndex: this._pageIndex,
        includeMarkedContent: true === t2,
        disableNormalization: true === e2
      }, {
        highWaterMark: 100,
        size: (t3) => t3.items.length
      });
    }
    getTextContent(t2 = {}) {
      if (this._transport._htmlForXfa) return this.getXfa().then((t3) => XfaText.textContent(t3));
      const e2 = this.streamTextContent(t2);
      return new Promise(function(t3, i2) {
        const s2 = e2.getReader(), n2 = {
          items: [],
          styles: /* @__PURE__ */ Object.create(null),
          lang: null
        };
        !function pump() {
          s2.read().then(function({ value: e3, done: i3 }) {
            if (i3) t3(n2);
            else {
              n2.lang ?? (n2.lang = e3.lang);
              Object.assign(n2.styles, e3.styles);
              n2.items.push(...e3.items);
              pump();
            }
          }, i2);
        }();
      });
    }
    getStructTree() {
      return this._transport.getStructTree(this._pageIndex);
    }
    _destroy() {
      this.destroyed = true;
      const t2 = [];
      for (const e2 of this._intentStates.values()) {
        this._abortOperatorList({
          intentState: e2,
          reason: new Error("Page was destroyed."),
          force: true
        });
        if (!e2.opListReadCapability) for (const i2 of e2.renderTasks) {
          t2.push(i2.completed);
          i2.cancel();
        }
      }
      this.objs.clear();
      __privateSet(this, _Ki, false);
      __privateMethod(this, _PDFPageProxy_instances, Yi_fn).call(this);
      return Promise.all(t2);
    }
    cleanup(t2 = false) {
      __privateSet(this, _Ki, true);
      const e2 = __privateMethod(this, _PDFPageProxy_instances, Qi_fn).call(this, false);
      t2 && e2 && (this._stats && (this._stats = new StatTimer()));
      return e2;
    }
    _startRenderPage(t2, e2) {
      var _a4, _b2;
      const i2 = this._intentStates.get(e2);
      if (i2) {
        (_a4 = this._stats) == null ? void 0 : _a4.timeEnd("Page Request");
        (_b2 = i2.displayReadyCapability) == null ? void 0 : _b2.resolve(t2);
      }
    }
    _renderPageChunk(t2, e2) {
      for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
        e2.operatorList.fnArray.push(t2.fnArray[i2]);
        e2.operatorList.argsArray.push(t2.argsArray[i2]);
      }
      e2.operatorList.lastChunk = t2.lastChunk;
      e2.operatorList.separateAnnots = t2.separateAnnots;
      for (const t3 of e2.renderTasks) t3.operatorListChanged();
      t2.lastChunk && __privateMethod(this, _PDFPageProxy_instances, Qi_fn).call(this, true);
    }
    _pumpOperatorList({ renderingIntent: t2, cacheKey: e2, annotationStorageSerializable: i2, modifiedIds: s2 }) {
      const { map: n2, transfer: r2 } = i2, a2 = this._transport.messageHandler.sendWithStream("GetOperatorList", {
        pageIndex: this._pageIndex,
        intent: t2,
        cacheKey: e2,
        annotationStorage: n2,
        modifiedIds: s2
      }, r2).getReader(), o2 = this._intentStates.get(e2);
      o2.streamReader = a2;
      const pump = () => {
        a2.read().then(({ value: t3, done: e3 }) => {
          if (e3) o2.streamReader = null;
          else if (!this._transport.destroyed) {
            this._renderPageChunk(t3, o2);
            pump();
          }
        }, (t3) => {
          o2.streamReader = null;
          if (!this._transport.destroyed) {
            if (o2.operatorList) {
              o2.operatorList.lastChunk = true;
              for (const t4 of o2.renderTasks) t4.operatorListChanged();
              __privateMethod(this, _PDFPageProxy_instances, Qi_fn).call(this, true);
            }
            if (o2.displayReadyCapability) o2.displayReadyCapability.reject(t3);
            else {
              if (!o2.opListReadCapability) throw t3;
              o2.opListReadCapability.reject(t3);
            }
          }
        });
      };
      pump();
    }
    _abortOperatorList({ intentState: t2, reason: e2, force: i2 = false }) {
      if (t2.streamReader) {
        if (t2.streamReaderCancelTimeout) {
          clearTimeout(t2.streamReaderCancelTimeout);
          t2.streamReaderCancelTimeout = null;
        }
        if (!i2) {
          if (t2.renderTasks.size > 0) return;
          if (e2 instanceof RenderingCancelledException) {
            let i3 = 100;
            e2.extraDelay > 0 && e2.extraDelay < 1e3 && (i3 += e2.extraDelay);
            t2.streamReaderCancelTimeout = setTimeout(() => {
              t2.streamReaderCancelTimeout = null;
              this._abortOperatorList({
                intentState: t2,
                reason: e2,
                force: true
              });
            }, i3);
            return;
          }
        }
        t2.streamReader.cancel(new AbortException(e2.message)).catch(() => {
        });
        t2.streamReader = null;
        if (!this._transport.destroyed) {
          for (const [e3, i3] of this._intentStates) if (i3 === t2) {
            this._intentStates.delete(e3);
            break;
          }
          this.cleanup();
        }
      }
    }
    get stats() {
      return this._stats;
    }
  }
  _Xi = new WeakMap();
  _Ki = new WeakMap();
  _PDFPageProxy_instances = new WeakSet();
  Qi_fn = function(t2 = false) {
    __privateMethod(this, _PDFPageProxy_instances, Yi_fn).call(this);
    if (!__privateGet(this, _Ki) || this.destroyed) return false;
    if (t2) {
      __privateSet(this, _Xi, setTimeout(() => {
        __privateSet(this, _Xi, null);
        __privateMethod(this, _PDFPageProxy_instances, Qi_fn).call(this, false);
      }, 5e3));
      return false;
    }
    for (const { renderTasks: t3, operatorList: e2 } of this._intentStates.values()) if (t3.size > 0 || !e2.lastChunk) return false;
    this._intentStates.clear();
    this.objs.clear();
    __privateSet(this, _Ki, false);
    return true;
  };
  Yi_fn = function() {
    if (__privateGet(this, _Xi)) {
      clearTimeout(__privateGet(this, _Xi));
      __privateSet(this, _Xi, null);
    }
  };
  class LoopbackPort {
    constructor() {
      __privateAdd(this, _Ji, /* @__PURE__ */ new Map());
      __privateAdd(this, _Zi, Promise.resolve());
    }
    postMessage(t2, e2) {
      const i2 = {
        data: structuredClone(t2, e2 ? {
          transfer: e2
        } : null)
      };
      __privateGet(this, _Zi).then(() => {
        for (const [t3] of __privateGet(this, _Ji)) t3.call(this, i2);
      });
    }
    addEventListener(t2, e2, i2 = null) {
      let s2 = null;
      if ((i2 == null ? void 0 : i2.signal) instanceof AbortSignal) {
        const { signal: n2 } = i2;
        if (n2.aborted) {
          warn("LoopbackPort - cannot use an `aborted` signal.");
          return;
        }
        const onAbort = () => this.removeEventListener(t2, e2);
        s2 = () => n2.removeEventListener("abort", onAbort);
        n2.addEventListener("abort", onAbort);
      }
      __privateGet(this, _Ji).set(e2, s2);
    }
    removeEventListener(t2, e2) {
      const i2 = __privateGet(this, _Ji).get(e2);
      i2 == null ? void 0 : i2();
      __privateGet(this, _Ji).delete(e2);
    }
    terminate() {
      for (const [, t2] of __privateGet(this, _Ji)) t2 == null ? void 0 : t2();
      __privateGet(this, _Ji).clear();
    }
  }
  _Ji = new WeakMap();
  _Zi = new WeakMap();
  const _PDFWorker = class _PDFWorker {
    constructor({ name: t2 = null, port: e2 = null, verbosity: i2 = getVerbosityLevel() } = {}) {
      __privateAdd(this, _PDFWorker_instances);
      var _a4;
      this.name = t2;
      this.destroyed = false;
      this.verbosity = i2;
      this._readyCapability = Promise.withResolvers();
      this._port = null;
      this._webWorker = null;
      this._messageHandler = null;
      if (e2) {
        if ((_a4 = __privateGet(_PDFWorker, _is)) == null ? void 0 : _a4.has(e2)) throw new Error("Cannot use more than one PDFWorker per port.");
        (__privateGet(_PDFWorker, _is) || __privateSet(_PDFWorker, _is, /* @__PURE__ */ new WeakMap())).set(e2, this);
        this._initializeFromPort(e2);
      } else this._initialize();
    }
    get promise() {
      return i ? Promise.all([
        NodePackages.promise,
        this._readyCapability.promise
      ]) : this._readyCapability.promise;
    }
    get port() {
      return this._port;
    }
    get messageHandler() {
      return this._messageHandler;
    }
    _initializeFromPort(t2) {
      this._port = t2;
      this._messageHandler = new MessageHandler("main", "worker", t2);
      this._messageHandler.on("ready", function() {
      });
      __privateMethod(this, _PDFWorker_instances, ss_fn).call(this);
    }
    _initialize() {
      if (__privateGet(_PDFWorker, _es) || __privateGet(_PDFWorker, _PDFWorker_static, ns_get)) {
        this._setupFakeWorker();
        return;
      }
      let { workerSrc: t2 } = _PDFWorker;
      try {
        _PDFWorker._isSameOrigin(window.location.href, t2) || (t2 = _PDFWorker._createCDNWrapper(new URL(t2, window.location).href));
        const e2 = new Worker(t2, {
          type: "module"
        }), i2 = new MessageHandler("main", "worker", e2), terminateEarly = () => {
          s2.abort();
          i2.destroy();
          e2.terminate();
          this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
        }, s2 = new AbortController();
        e2.addEventListener("error", () => {
          this._webWorker || terminateEarly();
        }, {
          signal: s2.signal
        });
        i2.on("test", (t3) => {
          s2.abort();
          if (!this.destroyed && t3) {
            this._messageHandler = i2;
            this._port = e2;
            this._webWorker = e2;
            __privateMethod(this, _PDFWorker_instances, ss_fn).call(this);
          } else terminateEarly();
        });
        i2.on("ready", (t3) => {
          s2.abort();
          if (this.destroyed) terminateEarly();
          else try {
            sendTest();
          } catch {
            this._setupFakeWorker();
          }
        });
        const sendTest = () => {
          const t3 = new Uint8Array();
          i2.send("test", t3, [
            t3.buffer
          ]);
        };
        sendTest();
        return;
      } catch {
        info("The worker has been disabled.");
      }
      this._setupFakeWorker();
    }
    _setupFakeWorker() {
      if (!__privateGet(_PDFWorker, _es)) {
        warn("Setting up fake worker.");
        __privateSet(_PDFWorker, _es, true);
      }
      _PDFWorker._setupFakeWorkerGlobal.then((t2) => {
        if (this.destroyed) {
          this._readyCapability.reject(new Error("Worker was destroyed"));
          return;
        }
        const e2 = new LoopbackPort();
        this._port = e2;
        const i2 = "fake" + __privateWrapper(_PDFWorker, _ts)._++, s2 = new MessageHandler(i2 + "_worker", i2, e2);
        t2.setup(s2, e2);
        this._messageHandler = new MessageHandler(i2, i2 + "_worker", e2);
        __privateMethod(this, _PDFWorker_instances, ss_fn).call(this);
      }).catch((t2) => {
        this._readyCapability.reject(new Error(`Setting up fake worker failed: "${t2.message}".`));
      });
    }
    destroy() {
      var _a4;
      this.destroyed = true;
      if (this._webWorker) {
        this._webWorker.terminate();
        this._webWorker = null;
      }
      (_a4 = __privateGet(_PDFWorker, _is)) == null ? void 0 : _a4.delete(this._port);
      this._port = null;
      if (this._messageHandler) {
        this._messageHandler.destroy();
        this._messageHandler = null;
      }
    }
    static fromPort(t2) {
      var _a4;
      if (!(t2 == null ? void 0 : t2.port)) throw new Error("PDFWorker.fromPort - invalid method signature.");
      const e2 = (_a4 = __privateGet(this, _is)) == null ? void 0 : _a4.get(t2.port);
      if (e2) {
        if (e2._pendingDestroy) throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
        return e2;
      }
      return new _PDFWorker(t2);
    }
    static get workerSrc() {
      if (GlobalWorkerOptions.workerSrc) return GlobalWorkerOptions.workerSrc;
      throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
    }
    static get _setupFakeWorkerGlobal() {
      return shadow(this, "_setupFakeWorkerGlobal", (async () => {
        if (__privateGet(this, _PDFWorker_static, ns_get)) return __privateGet(this, _PDFWorker_static, ns_get);
        return (await import(this.workerSrc).then(async (m2) => {
          await m2.__tla;
          return m2;
        })).WorkerMessageHandler;
      })());
    }
  };
  _ts = new WeakMap();
  _es = new WeakMap();
  _is = new WeakMap();
  _PDFWorker_instances = new WeakSet();
  ss_fn = function() {
    this._readyCapability.resolve();
    this._messageHandler.send("configure", {
      verbosity: this.verbosity
    });
  };
  _PDFWorker_static = new WeakSet();
  ns_get = function() {
    var _a4;
    try {
      return ((_a4 = globalThis.pdfjsWorker) == null ? void 0 : _a4.WorkerMessageHandler) || null;
    } catch {
      return null;
    }
  };
  __privateAdd(_PDFWorker, _PDFWorker_static);
  __privateAdd(_PDFWorker, _ts, 0);
  __privateAdd(_PDFWorker, _es, false);
  __privateAdd(_PDFWorker, _is);
  (() => {
    if (i) {
      __privateSet(_PDFWorker, _es, true);
      GlobalWorkerOptions.workerSrc || (GlobalWorkerOptions.workerSrc = "./pdf.worker.mjs");
    }
    _PDFWorker._isSameOrigin = (t2, e2) => {
      let i2;
      try {
        i2 = new URL(t2);
        if (!i2.origin || "null" === i2.origin) return false;
      } catch {
        return false;
      }
      const s2 = new URL(e2, i2);
      return i2.origin === s2.origin;
    };
    _PDFWorker._createCDNWrapper = (t2) => {
      const e2 = `await import("${t2}");`;
      return URL.createObjectURL(new Blob([
        e2
      ], {
        type: "text/javascript"
      }));
    };
  })();
  let PDFWorker = _PDFWorker;
  class WorkerTransport {
    constructor(t2, e2, i2, s2, n2) {
      __privateAdd(this, _WorkerTransport_instances);
      __privateAdd(this, _rs, /* @__PURE__ */ new Map());
      __privateAdd(this, _as, /* @__PURE__ */ new Map());
      __privateAdd(this, _os, /* @__PURE__ */ new Map());
      __privateAdd(this, _ls, /* @__PURE__ */ new Map());
      __privateAdd(this, _hs, null);
      this.messageHandler = t2;
      this.loadingTask = e2;
      this.commonObjs = new PDFObjects();
      this.fontLoader = new FontLoader({
        ownerDocument: s2.ownerDocument,
        styleElement: s2.styleElement
      });
      this.loadingParams = s2.loadingParams;
      this._params = s2;
      this.canvasFactory = n2.canvasFactory;
      this.filterFactory = n2.filterFactory;
      this.cMapReaderFactory = n2.cMapReaderFactory;
      this.standardFontDataFactory = n2.standardFontDataFactory;
      this.destroyed = false;
      this.destroyCapability = null;
      this._networkStream = i2;
      this._fullReader = null;
      this._lastProgress = null;
      this.downloadInfoCapability = Promise.withResolvers();
      this.setupMessageHandler();
    }
    get annotationStorage() {
      return shadow(this, "annotationStorage", new AnnotationStorage());
    }
    getRenderingIntent(t2, e2 = g.ENABLE, i2 = null, s2 = false, n2 = false) {
      let r2 = o, f2 = bt;
      switch (t2) {
        case "any":
          r2 = a;
          break;
        case "display":
          break;
        case "print":
          r2 = l;
          break;
        default:
          warn(`getRenderingIntent - invalid intent: ${t2}`);
      }
      const m2 = r2 & l && i2 instanceof PrintAnnotationStorage ? i2 : this.annotationStorage;
      switch (e2) {
        case g.DISABLE:
          r2 += d;
          break;
        case g.ENABLE:
          break;
        case g.ENABLE_FORMS:
          r2 += h;
          break;
        case g.ENABLE_STORAGE:
          r2 += c;
          f2 = m2.serializable;
          break;
        default:
          warn(`getRenderingIntent - invalid annotationMode: ${e2}`);
      }
      s2 && (r2 += u);
      n2 && (r2 += p);
      const { ids: b2, hash: v2 } = m2.modifiedIds;
      return {
        renderingIntent: r2,
        cacheKey: [
          r2,
          f2.hash,
          v2
        ].join("_"),
        annotationStorageSerializable: f2,
        modifiedIds: b2
      };
    }
    destroy() {
      var _a4;
      if (this.destroyCapability) return this.destroyCapability.promise;
      this.destroyed = true;
      this.destroyCapability = Promise.withResolvers();
      (_a4 = __privateGet(this, _hs)) == null ? void 0 : _a4.reject(new Error("Worker was destroyed during onPassword callback"));
      const t2 = [];
      for (const e3 of __privateGet(this, _as).values()) t2.push(e3._destroy());
      __privateGet(this, _as).clear();
      __privateGet(this, _os).clear();
      __privateGet(this, _ls).clear();
      this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
      const e2 = this.messageHandler.sendWithPromise("Terminate", null);
      t2.push(e2);
      Promise.all(t2).then(() => {
        var _a5;
        this.commonObjs.clear();
        this.fontLoader.clear();
        __privateGet(this, _rs).clear();
        this.filterFactory.destroy();
        TextLayer.cleanup();
        (_a5 = this._networkStream) == null ? void 0 : _a5.cancelAllRequests(new AbortException("Worker was terminated."));
        if (this.messageHandler) {
          this.messageHandler.destroy();
          this.messageHandler = null;
        }
        this.destroyCapability.resolve();
      }, this.destroyCapability.reject);
      return this.destroyCapability.promise;
    }
    setupMessageHandler() {
      const { messageHandler: t2, loadingTask: e2 } = this;
      t2.on("GetReader", (t3, e3) => {
        assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
        this._fullReader = this._networkStream.getFullReader();
        this._fullReader.onProgress = (t4) => {
          this._lastProgress = {
            loaded: t4.loaded,
            total: t4.total
          };
        };
        e3.onPull = () => {
          this._fullReader.read().then(function({ value: t4, done: i2 }) {
            if (i2) e3.close();
            else {
              assert(t4 instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
              e3.enqueue(new Uint8Array(t4), 1, [
                t4
              ]);
            }
          }).catch((t4) => {
            e3.error(t4);
          });
        };
        e3.onCancel = (t4) => {
          this._fullReader.cancel(t4);
          e3.ready.catch((t5) => {
            if (!this.destroyed) throw t5;
          });
        };
      });
      t2.on("ReaderHeadersReady", async (t3) => {
        var _a4;
        await this._fullReader.headersReady;
        const { isStreamingSupported: i2, isRangeSupported: s2, contentLength: n2 } = this._fullReader;
        if (!i2 || !s2) {
          this._lastProgress && ((_a4 = e2.onProgress) == null ? void 0 : _a4.call(e2, this._lastProgress));
          this._fullReader.onProgress = (t4) => {
            var _a5;
            (_a5 = e2.onProgress) == null ? void 0 : _a5.call(e2, {
              loaded: t4.loaded,
              total: t4.total
            });
          };
        }
        return {
          isStreamingSupported: i2,
          isRangeSupported: s2,
          contentLength: n2
        };
      });
      t2.on("GetRangeReader", (t3, e3) => {
        assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
        const i2 = this._networkStream.getRangeReader(t3.begin, t3.end);
        if (i2) {
          e3.onPull = () => {
            i2.read().then(function({ value: t4, done: i3 }) {
              if (i3) e3.close();
              else {
                assert(t4 instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                e3.enqueue(new Uint8Array(t4), 1, [
                  t4
                ]);
              }
            }).catch((t4) => {
              e3.error(t4);
            });
          };
          e3.onCancel = (t4) => {
            i2.cancel(t4);
            e3.ready.catch((t5) => {
              if (!this.destroyed) throw t5;
            });
          };
        } else e3.close();
      });
      t2.on("GetDoc", ({ pdfInfo: t3 }) => {
        this._numPages = t3.numPages;
        this._htmlForXfa = t3.htmlForXfa;
        delete t3.htmlForXfa;
        e2._capability.resolve(new PDFDocumentProxy(t3, this));
      });
      t2.on("DocException", function(t3) {
        let i2;
        switch (t3.name) {
          case "PasswordException":
            i2 = new PasswordException(t3.message, t3.code);
            break;
          case "InvalidPDFException":
            i2 = new InvalidPDFException(t3.message);
            break;
          case "MissingPDFException":
            i2 = new MissingPDFException(t3.message);
            break;
          case "UnexpectedResponseException":
            i2 = new UnexpectedResponseException(t3.message, t3.status);
            break;
          case "UnknownErrorException":
            i2 = new UnknownErrorException(t3.message, t3.details);
            break;
          default:
            unreachable("DocException - expected a valid Error.");
        }
        e2._capability.reject(i2);
      });
      t2.on("PasswordRequest", (t3) => {
        __privateSet(this, _hs, Promise.withResolvers());
        if (e2.onPassword) {
          const updatePassword = (t4) => {
            t4 instanceof Error ? __privateGet(this, _hs).reject(t4) : __privateGet(this, _hs).resolve({
              password: t4
            });
          };
          try {
            e2.onPassword(updatePassword, t3.code);
          } catch (t4) {
            __privateGet(this, _hs).reject(t4);
          }
        } else __privateGet(this, _hs).reject(new PasswordException(t3.message, t3.code));
        return __privateGet(this, _hs).promise;
      });
      t2.on("DataLoaded", (t3) => {
        var _a4;
        (_a4 = e2.onProgress) == null ? void 0 : _a4.call(e2, {
          loaded: t3.length,
          total: t3.length
        });
        this.downloadInfoCapability.resolve(t3);
      });
      t2.on("StartRenderPage", (t3) => {
        if (this.destroyed) return;
        __privateGet(this, _as).get(t3.pageIndex)._startRenderPage(t3.transparency, t3.cacheKey);
      });
      t2.on("commonobj", ([e3, i2, s2]) => {
        var _a4;
        if (this.destroyed) return null;
        if (this.commonObjs.has(e3)) return null;
        switch (i2) {
          case "Font":
            const { disableFontFace: n2, fontExtraProperties: r2, pdfBug: a2 } = this._params;
            if ("error" in s2) {
              const t3 = s2.error;
              warn(`Error during font loading: ${t3}`);
              this.commonObjs.resolve(e3, t3);
              break;
            }
            const o2 = a2 && ((_a4 = globalThis.FontInspector) == null ? void 0 : _a4.enabled) ? (t3, e4) => globalThis.FontInspector.fontAdded(t3, e4) : null, l2 = new FontFaceObject(s2, {
              disableFontFace: n2,
              inspectFont: o2
            });
            this.fontLoader.bind(l2).catch(() => t2.sendWithPromise("FontFallback", {
              id: e3
            })).finally(() => {
              !r2 && l2.data && (l2.data = null);
              this.commonObjs.resolve(e3, l2);
            });
            break;
          case "CopyLocalImage":
            const { imageRef: h2 } = s2;
            assert(h2, "The imageRef must be defined.");
            for (const t3 of __privateGet(this, _as).values()) for (const [, i3] of t3.objs) if ((i3 == null ? void 0 : i3.ref) === h2) {
              if (!i3.dataLen) return null;
              this.commonObjs.resolve(e3, structuredClone(i3));
              return i3.dataLen;
            }
            break;
          case "FontPath":
          case "Image":
          case "Pattern":
            this.commonObjs.resolve(e3, s2);
            break;
          default:
            throw new Error(`Got unknown common object type ${i2}`);
        }
        return null;
      });
      t2.on("obj", ([t3, e3, i2, s2]) => {
        var _a4;
        if (this.destroyed) return;
        const n2 = __privateGet(this, _as).get(e3);
        if (!n2.objs.has(t3)) if (0 !== n2._intentStates.size) switch (i2) {
          case "Image":
            n2.objs.resolve(t3, s2);
            (s2 == null ? void 0 : s2.dataLen) > 1e7 && (n2._maybeCleanupAfterRender = true);
            break;
          case "Pattern":
            n2.objs.resolve(t3, s2);
            break;
          default:
            throw new Error(`Got unknown object type ${i2}`);
        }
        else (_a4 = s2 == null ? void 0 : s2.bitmap) == null ? void 0 : _a4.close();
      });
      t2.on("DocProgress", (t3) => {
        var _a4;
        this.destroyed || ((_a4 = e2.onProgress) == null ? void 0 : _a4.call(e2, {
          loaded: t3.loaded,
          total: t3.total
        }));
      });
      t2.on("FetchBuiltInCMap", async (t3) => {
        if (this.destroyed) throw new Error("Worker was destroyed.");
        if (!this.cMapReaderFactory) throw new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.");
        return this.cMapReaderFactory.fetch(t3);
      });
      t2.on("FetchStandardFontData", async (t3) => {
        if (this.destroyed) throw new Error("Worker was destroyed.");
        if (!this.standardFontDataFactory) throw new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.");
        return this.standardFontDataFactory.fetch(t3);
      });
    }
    getData() {
      return this.messageHandler.sendWithPromise("GetData", null);
    }
    saveDocument() {
      var _a4;
      this.annotationStorage.size <= 0 && warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
      const { map: t2, transfer: e2 } = this.annotationStorage.serializable;
      return this.messageHandler.sendWithPromise("SaveDocument", {
        isPureXfa: !!this._htmlForXfa,
        numPages: this._numPages,
        annotationStorage: t2,
        filename: ((_a4 = this._fullReader) == null ? void 0 : _a4.filename) ?? null
      }, e2).finally(() => {
        this.annotationStorage.resetModified();
      });
    }
    getPage(t2) {
      if (!Number.isInteger(t2) || t2 <= 0 || t2 > this._numPages) return Promise.reject(new Error("Invalid page request."));
      const e2 = t2 - 1, i2 = __privateGet(this, _os).get(e2);
      if (i2) return i2;
      const s2 = this.messageHandler.sendWithPromise("GetPage", {
        pageIndex: e2
      }).then((i3) => {
        if (this.destroyed) throw new Error("Transport destroyed");
        i3.refStr && __privateGet(this, _ls).set(i3.refStr, t2);
        const s3 = new PDFPageProxy(e2, i3, this, this._params.pdfBug);
        __privateGet(this, _as).set(e2, s3);
        return s3;
      });
      __privateGet(this, _os).set(e2, s2);
      return s2;
    }
    getPageIndex(t2) {
      return isRefProxy(t2) ? this.messageHandler.sendWithPromise("GetPageIndex", {
        num: t2.num,
        gen: t2.gen
      }) : Promise.reject(new Error("Invalid pageIndex request."));
    }
    getAnnotations(t2, e2) {
      return this.messageHandler.sendWithPromise("GetAnnotations", {
        pageIndex: t2,
        intent: e2
      });
    }
    getFieldObjects() {
      return __privateMethod(this, _WorkerTransport_instances, cs_fn).call(this, "GetFieldObjects");
    }
    hasJSActions() {
      return __privateMethod(this, _WorkerTransport_instances, cs_fn).call(this, "HasJSActions");
    }
    getCalculationOrderIds() {
      return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
    }
    getDestinations() {
      return this.messageHandler.sendWithPromise("GetDestinations", null);
    }
    getDestination(t2) {
      return "string" != typeof t2 ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
        id: t2
      });
    }
    getPageLabels() {
      return this.messageHandler.sendWithPromise("GetPageLabels", null);
    }
    getPageLayout() {
      return this.messageHandler.sendWithPromise("GetPageLayout", null);
    }
    getPageMode() {
      return this.messageHandler.sendWithPromise("GetPageMode", null);
    }
    getViewerPreferences() {
      return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
    }
    getOpenAction() {
      return this.messageHandler.sendWithPromise("GetOpenAction", null);
    }
    getAttachments() {
      return this.messageHandler.sendWithPromise("GetAttachments", null);
    }
    getDocJSActions() {
      return __privateMethod(this, _WorkerTransport_instances, cs_fn).call(this, "GetDocJSActions");
    }
    getPageJSActions(t2) {
      return this.messageHandler.sendWithPromise("GetPageJSActions", {
        pageIndex: t2
      });
    }
    getStructTree(t2) {
      return this.messageHandler.sendWithPromise("GetStructTree", {
        pageIndex: t2
      });
    }
    getOutline() {
      return this.messageHandler.sendWithPromise("GetOutline", null);
    }
    getOptionalContentConfig(t2) {
      return __privateMethod(this, _WorkerTransport_instances, cs_fn).call(this, "GetOptionalContentConfig").then((e2) => new OptionalContentConfig(e2, t2));
    }
    getPermissions() {
      return this.messageHandler.sendWithPromise("GetPermissions", null);
    }
    getMetadata() {
      const t2 = "GetMetadata", e2 = __privateGet(this, _rs).get(t2);
      if (e2) return e2;
      const i2 = this.messageHandler.sendWithPromise(t2, null).then((t3) => {
        var _a4, _b2;
        return {
          info: t3[0],
          metadata: t3[1] ? new Metadata(t3[1]) : null,
          contentDispositionFilename: ((_a4 = this._fullReader) == null ? void 0 : _a4.filename) ?? null,
          contentLength: ((_b2 = this._fullReader) == null ? void 0 : _b2.contentLength) ?? null
        };
      });
      __privateGet(this, _rs).set(t2, i2);
      return i2;
    }
    getMarkInfo() {
      return this.messageHandler.sendWithPromise("GetMarkInfo", null);
    }
    async startCleanup(t2 = false) {
      if (!this.destroyed) {
        await this.messageHandler.sendWithPromise("Cleanup", null);
        for (const t3 of __privateGet(this, _as).values()) {
          if (!t3.cleanup()) throw new Error(`startCleanup: Page ${t3.pageNumber} is currently rendering.`);
        }
        this.commonObjs.clear();
        t2 || this.fontLoader.clear();
        __privateGet(this, _rs).clear();
        this.filterFactory.destroy(true);
        TextLayer.cleanup();
      }
    }
    cachedPageNumber(t2) {
      if (!isRefProxy(t2)) return null;
      const e2 = 0 === t2.gen ? `${t2.num}R` : `${t2.num}R${t2.gen}`;
      return __privateGet(this, _ls).get(e2) ?? null;
    }
  }
  _rs = new WeakMap();
  _as = new WeakMap();
  _os = new WeakMap();
  _ls = new WeakMap();
  _hs = new WeakMap();
  _WorkerTransport_instances = new WeakSet();
  cs_fn = function(t2, e2 = null) {
    const i2 = __privateGet(this, _rs).get(t2);
    if (i2) return i2;
    const s2 = this.messageHandler.sendWithPromise(t2, e2);
    __privateGet(this, _rs).set(t2, s2);
    return s2;
  };
  const Xt = Symbol("INITIAL_DATA");
  class PDFObjects {
    constructor() {
      __privateAdd(this, _PDFObjects_instances);
      __privateAdd(this, _ds, /* @__PURE__ */ Object.create(null));
    }
    get(t2, e2 = null) {
      if (e2) {
        const i3 = __privateMethod(this, _PDFObjects_instances, us_fn).call(this, t2);
        i3.promise.then(() => e2(i3.data));
        return null;
      }
      const i2 = __privateGet(this, _ds)[t2];
      if (!i2 || i2.data === Xt) throw new Error(`Requesting object that isn't resolved yet ${t2}.`);
      return i2.data;
    }
    has(t2) {
      const e2 = __privateGet(this, _ds)[t2];
      return !!e2 && e2.data !== Xt;
    }
    resolve(t2, e2 = null) {
      const i2 = __privateMethod(this, _PDFObjects_instances, us_fn).call(this, t2);
      i2.data = e2;
      i2.resolve();
    }
    clear() {
      var _a4;
      for (const t2 in __privateGet(this, _ds)) {
        const { data: e2 } = __privateGet(this, _ds)[t2];
        (_a4 = e2 == null ? void 0 : e2.bitmap) == null ? void 0 : _a4.close();
      }
      __privateSet(this, _ds, /* @__PURE__ */ Object.create(null));
    }
    *[Symbol.iterator]() {
      for (const t2 in __privateGet(this, _ds)) {
        const { data: e2 } = __privateGet(this, _ds)[t2];
        e2 !== Xt && (yield [
          t2,
          e2
        ]);
      }
    }
  }
  _ds = new WeakMap();
  _PDFObjects_instances = new WeakSet();
  us_fn = function(t2) {
    var _a4;
    return (_a4 = __privateGet(this, _ds))[t2] || (_a4[t2] = {
      ...Promise.withResolvers(),
      data: Xt
    });
  };
  class RenderTask {
    constructor(t2) {
      __privateAdd(this, _ps, null);
      __privateSet(this, _ps, t2);
      this.onContinue = null;
    }
    get promise() {
      return __privateGet(this, _ps).capability.promise;
    }
    cancel(t2 = 0) {
      __privateGet(this, _ps).cancel(null, t2);
    }
    get separateAnnots() {
      const { separateAnnots: t2 } = __privateGet(this, _ps).operatorList;
      if (!t2) return false;
      const { annotationCanvasMap: e2 } = __privateGet(this, _ps);
      return t2.form || t2.canvas && (e2 == null ? void 0 : e2.size) > 0;
    }
  }
  _ps = new WeakMap();
  const _InternalRenderTask = class _InternalRenderTask {
    constructor({ callback: t2, params: e2, objs: i2, commonObjs: s2, annotationCanvasMap: n2, operatorList: r2, pageIndex: a2, canvasFactory: o2, filterFactory: l2, useRequestAnimationFrame: h2 = false, pdfBug: c2 = false, pageColors: d2 = null }) {
      __privateAdd(this, _gs, null);
      this.callback = t2;
      this.params = e2;
      this.objs = i2;
      this.commonObjs = s2;
      this.annotationCanvasMap = n2;
      this.operatorListIdx = null;
      this.operatorList = r2;
      this._pageIndex = a2;
      this.canvasFactory = o2;
      this.filterFactory = l2;
      this._pdfBug = c2;
      this.pageColors = d2;
      this.running = false;
      this.graphicsReadyCallback = null;
      this.graphicsReady = false;
      this._useRequestAnimationFrame = true === h2 && "undefined" != typeof window;
      this.cancelled = false;
      this.capability = Promise.withResolvers();
      this.task = new RenderTask(this);
      this._cancelBound = this.cancel.bind(this);
      this._continueBound = this._continue.bind(this);
      this._scheduleNextBound = this._scheduleNext.bind(this);
      this._nextBound = this._next.bind(this);
      this._canvas = e2.canvasContext.canvas;
    }
    get completed() {
      return this.capability.promise.catch(function() {
      });
    }
    initializeGraphics({ transparency: t2 = false, optionalContentConfig: e2 }) {
      var _a4, _b2;
      if (this.cancelled) return;
      if (this._canvas) {
        if (__privateGet(_InternalRenderTask, _fs).has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
        __privateGet(_InternalRenderTask, _fs).add(this._canvas);
      }
      if (this._pdfBug && ((_a4 = globalThis.StepperManager) == null ? void 0 : _a4.enabled)) {
        this.stepper = globalThis.StepperManager.create(this._pageIndex);
        this.stepper.init(this.operatorList);
        this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
      }
      const { canvasContext: i2, viewport: s2, transform: n2, background: r2 } = this.params;
      this.gfx = new CanvasGraphics(i2, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
        optionalContentConfig: e2
      }, this.annotationCanvasMap, this.pageColors);
      this.gfx.beginDrawing({
        transform: n2,
        viewport: s2,
        transparency: t2,
        background: r2
      });
      this.operatorListIdx = 0;
      this.graphicsReady = true;
      (_b2 = this.graphicsReadyCallback) == null ? void 0 : _b2.call(this);
    }
    cancel(t2 = null, e2 = 0) {
      var _a4;
      this.running = false;
      this.cancelled = true;
      (_a4 = this.gfx) == null ? void 0 : _a4.endDrawing();
      if (__privateGet(this, _gs)) {
        window.cancelAnimationFrame(__privateGet(this, _gs));
        __privateSet(this, _gs, null);
      }
      __privateGet(_InternalRenderTask, _fs).delete(this._canvas);
      this.callback(t2 || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, e2));
    }
    operatorListChanged() {
      var _a4;
      if (this.graphicsReady) {
        (_a4 = this.stepper) == null ? void 0 : _a4.updateOperatorList(this.operatorList);
        this.running || this._continue();
      } else this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
    }
    _continue() {
      this.running = true;
      this.cancelled || (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
    }
    _scheduleNext() {
      this._useRequestAnimationFrame ? __privateSet(this, _gs, window.requestAnimationFrame(() => {
        __privateSet(this, _gs, null);
        this._nextBound().catch(this._cancelBound);
      })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
    async _next() {
      if (!this.cancelled) {
        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
        if (this.operatorListIdx === this.operatorList.argsArray.length) {
          this.running = false;
          if (this.operatorList.lastChunk) {
            this.gfx.endDrawing();
            __privateGet(_InternalRenderTask, _fs).delete(this._canvas);
            this.callback();
          }
        }
      }
    }
  };
  _gs = new WeakMap();
  _fs = new WeakMap();
  __privateAdd(_InternalRenderTask, _fs, /* @__PURE__ */ new WeakSet());
  let InternalRenderTask = _InternalRenderTask;
  const Kt = "4.8.69", Yt = "3634dab10";
  __webpack_require__(670);
  function makeColorComp(t2) {
    return Math.floor(255 * Math.max(0, Math.min(1, t2))).toString(16).padStart(2, "0");
  }
  function scaleAndClamp(t2) {
    return Math.max(0, Math.min(255, 255 * t2));
  }
  class ColorConverters {
    static CMYK_G([t2, e2, i2, s2]) {
      return [
        "G",
        1 - Math.min(1, 0.3 * t2 + 0.59 * i2 + 0.11 * e2 + s2)
      ];
    }
    static G_CMYK([t2]) {
      return [
        "CMYK",
        0,
        0,
        0,
        1 - t2
      ];
    }
    static G_RGB([t2]) {
      return [
        "RGB",
        t2,
        t2,
        t2
      ];
    }
    static G_rgb([t2]) {
      return [
        t2 = scaleAndClamp(t2),
        t2,
        t2
      ];
    }
    static G_HTML([t2]) {
      const e2 = makeColorComp(t2);
      return `#${e2}${e2}${e2}`;
    }
    static RGB_G([t2, e2, i2]) {
      return [
        "G",
        0.3 * t2 + 0.59 * e2 + 0.11 * i2
      ];
    }
    static RGB_rgb(t2) {
      return t2.map(scaleAndClamp);
    }
    static RGB_HTML(t2) {
      return `#${t2.map(makeColorComp).join("")}`;
    }
    static T_HTML() {
      return "#00000000";
    }
    static T_rgb() {
      return [
        null
      ];
    }
    static CMYK_RGB([t2, e2, i2, s2]) {
      return [
        "RGB",
        1 - Math.min(1, t2 + s2),
        1 - Math.min(1, i2 + s2),
        1 - Math.min(1, e2 + s2)
      ];
    }
    static CMYK_rgb([t2, e2, i2, s2]) {
      return [
        scaleAndClamp(1 - Math.min(1, t2 + s2)),
        scaleAndClamp(1 - Math.min(1, i2 + s2)),
        scaleAndClamp(1 - Math.min(1, e2 + s2))
      ];
    }
    static CMYK_HTML(t2) {
      const e2 = this.CMYK_RGB(t2).slice(1);
      return this.RGB_HTML(e2);
    }
    static RGB_CMYK([t2, e2, i2]) {
      const s2 = 1 - t2, n2 = 1 - e2, r2 = 1 - i2;
      return [
        "CMYK",
        s2,
        n2,
        r2,
        Math.min(s2, n2, r2)
      ];
    }
  }
  class BaseSVGFactory {
    create(t2, e2, i2 = false) {
      if (t2 <= 0 || e2 <= 0) throw new Error("Invalid SVG dimensions");
      const s2 = this._createSVG("svg:svg");
      s2.setAttribute("version", "1.1");
      if (!i2) {
        s2.setAttribute("width", `${t2}px`);
        s2.setAttribute("height", `${e2}px`);
      }
      s2.setAttribute("preserveAspectRatio", "none");
      s2.setAttribute("viewBox", `0 0 ${t2} ${e2}`);
      return s2;
    }
    createElement(t2) {
      if ("string" != typeof t2) throw new Error("Invalid SVG element type");
      return this._createSVG(t2);
    }
    _createSVG(t2) {
      unreachable("Abstract method `_createSVG` called.");
    }
  }
  class DOMSVGFactory extends BaseSVGFactory {
    _createSVG(t2) {
      return document.createElementNS(pt, t2);
    }
  }
  class XfaLayer {
    static setupStorage(t2, e2, i2, s2, n2) {
      const r2 = s2.getValue(e2, {
        value: null
      });
      switch (i2.name) {
        case "textarea":
          null !== r2.value && (t2.textContent = r2.value);
          if ("print" === n2) break;
          t2.addEventListener("input", (t3) => {
            s2.setValue(e2, {
              value: t3.target.value
            });
          });
          break;
        case "input":
          if ("radio" === i2.attributes.type || "checkbox" === i2.attributes.type) {
            r2.value === i2.attributes.xfaOn ? t2.setAttribute("checked", true) : r2.value === i2.attributes.xfaOff && t2.removeAttribute("checked");
            if ("print" === n2) break;
            t2.addEventListener("change", (t3) => {
              s2.setValue(e2, {
                value: t3.target.checked ? t3.target.getAttribute("xfaOn") : t3.target.getAttribute("xfaOff")
              });
            });
          } else {
            null !== r2.value && t2.setAttribute("value", r2.value);
            if ("print" === n2) break;
            t2.addEventListener("input", (t3) => {
              s2.setValue(e2, {
                value: t3.target.value
              });
            });
          }
          break;
        case "select":
          if (null !== r2.value) {
            t2.setAttribute("value", r2.value);
            for (const t3 of i2.children) t3.attributes.value === r2.value ? t3.attributes.selected = true : t3.attributes.hasOwnProperty("selected") && delete t3.attributes.selected;
          }
          t2.addEventListener("input", (t3) => {
            const i3 = t3.target.options, n3 = -1 === i3.selectedIndex ? "" : i3[i3.selectedIndex].value;
            s2.setValue(e2, {
              value: n3
            });
          });
      }
    }
    static setAttributes({ html: t2, element: e2, storage: i2 = null, intent: s2, linkService: n2 }) {
      const { attributes: r2 } = e2, a2 = t2 instanceof HTMLAnchorElement;
      "radio" === r2.type && (r2.name = `${r2.name}-${s2}`);
      for (const [e3, i3] of Object.entries(r2)) if (null != i3) switch (e3) {
        case "class":
          i3.length && t2.setAttribute(e3, i3.join(" "));
          break;
        case "dataId":
          break;
        case "id":
          t2.setAttribute("data-element-id", i3);
          break;
        case "style":
          Object.assign(t2.style, i3);
          break;
        case "textContent":
          t2.textContent = i3;
          break;
        default:
          (!a2 || "href" !== e3 && "newWindow" !== e3) && t2.setAttribute(e3, i3);
      }
      a2 && n2.addLinkAttributes(t2, r2.href, r2.newWindow);
      i2 && r2.dataId && this.setupStorage(t2, r2.dataId, e2, i2);
    }
    static render(t2) {
      var _a4, _b2;
      const e2 = t2.annotationStorage, i2 = t2.linkService, s2 = t2.xfaHtml, n2 = t2.intent || "display", r2 = document.createElement(s2.name);
      s2.attributes && this.setAttributes({
        html: r2,
        element: s2,
        intent: n2,
        linkService: i2
      });
      const a2 = "richText" !== n2, o2 = t2.div;
      o2.append(r2);
      if (t2.viewport) {
        const e3 = `matrix(${t2.viewport.transform.join(",")})`;
        o2.style.transform = e3;
      }
      a2 && o2.setAttribute("class", "xfaLayer xfaFont");
      const l2 = [];
      if (0 === s2.children.length) {
        if (s2.value) {
          const t3 = document.createTextNode(s2.value);
          r2.append(t3);
          a2 && XfaText.shouldBuildText(s2.name) && l2.push(t3);
        }
        return {
          textDivs: l2
        };
      }
      const h2 = [
        [
          s2,
          -1,
          r2
        ]
      ];
      for (; h2.length > 0; ) {
        const [t3, s3, r3] = h2.at(-1);
        if (s3 + 1 === t3.children.length) {
          h2.pop();
          continue;
        }
        const o3 = t3.children[++h2.at(-1)[1]];
        if (null === o3) continue;
        const { name: c2 } = o3;
        if ("#text" === c2) {
          const t4 = document.createTextNode(o3.value);
          l2.push(t4);
          r3.append(t4);
          continue;
        }
        const d2 = ((_a4 = o3 == null ? void 0 : o3.attributes) == null ? void 0 : _a4.xmlns) ? document.createElementNS(o3.attributes.xmlns, c2) : document.createElement(c2);
        r3.append(d2);
        o3.attributes && this.setAttributes({
          html: d2,
          element: o3,
          storage: e2,
          intent: n2,
          linkService: i2
        });
        if (((_b2 = o3.children) == null ? void 0 : _b2.length) > 0) h2.push([
          o3,
          -1,
          d2
        ]);
        else if (o3.value) {
          const t4 = document.createTextNode(o3.value);
          a2 && XfaText.shouldBuildText(c2) && l2.push(t4);
          d2.append(t4);
        }
      }
      for (const t3 of o2.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) t3.setAttribute("readOnly", true);
      return {
        textDivs: l2
      };
    }
    static update(t2) {
      const e2 = `matrix(${t2.viewport.transform.join(",")})`;
      t2.div.style.transform = e2;
      t2.div.hidden = false;
    }
  }
  const Qt = 1e3, Jt = /* @__PURE__ */ new WeakSet();
  function getRectDims(t2) {
    return {
      width: t2[2] - t2[0],
      height: t2[3] - t2[1]
    };
  }
  class AnnotationElementFactory {
    static create(t2) {
      switch (t2.data.annotationType) {
        case S:
          return new LinkAnnotationElement(t2);
        case C:
          return new TextAnnotationElement(t2);
        case W:
          switch (t2.data.fieldType) {
            case "Tx":
              return new TextWidgetAnnotationElement(t2);
            case "Btn":
              return t2.data.radioButton ? new RadioButtonWidgetAnnotationElement(t2) : t2.data.checkBox ? new CheckboxWidgetAnnotationElement(t2) : new PushButtonWidgetAnnotationElement(t2);
            case "Ch":
              return new ChoiceWidgetAnnotationElement(t2);
            case "Sig":
              return new SignatureWidgetAnnotationElement(t2);
          }
          return new WidgetAnnotationElement(t2);
        case z:
          return new PopupAnnotationElement(t2);
        case T:
          return new FreeTextAnnotationElement(t2);
        case M:
          return new LineAnnotationElement(t2);
        case k:
          return new SquareAnnotationElement(t2);
        case P:
          return new CircleAnnotationElement(t2);
        case D:
          return new PolylineAnnotationElement(t2);
        case H:
          return new CaretAnnotationElement(t2);
        case U:
          return new InkAnnotationElement(t2);
        case R:
          return new PolygonAnnotationElement(t2);
        case I:
          return new HighlightAnnotationElement(t2);
        case L:
          return new UnderlineAnnotationElement(t2);
        case O:
          return new SquigglyAnnotationElement(t2);
        case N:
          return new StrikeOutAnnotationElement(t2);
        case B:
          return new StampAnnotationElement(t2);
        case j:
          return new FileAttachmentAnnotationElement(t2);
        default:
          return new AnnotationElement(t2);
      }
    }
  }
  const _AnnotationElement = class _AnnotationElement {
    constructor(t2, { isRenderable: e2 = false, ignoreBorder: i2 = false, createQuadrilaterals: s2 = false } = {}) {
      __privateAdd(this, _AnnotationElement_instances);
      __privateAdd(this, _ms, null);
      __privateAdd(this, _bs, false);
      __privateAdd(this, _vs, null);
      this.isRenderable = e2;
      this.data = t2.data;
      this.layer = t2.layer;
      this.linkService = t2.linkService;
      this.downloadManager = t2.downloadManager;
      this.imageResourcesPath = t2.imageResourcesPath;
      this.renderForms = t2.renderForms;
      this.svgFactory = t2.svgFactory;
      this.annotationStorage = t2.annotationStorage;
      this.enableScripting = t2.enableScripting;
      this.hasJSActions = t2.hasJSActions;
      this._fieldObjects = t2.fieldObjects;
      this.parent = t2.parent;
      e2 && (this.container = this._createContainer(i2));
      s2 && this._createQuadrilaterals();
    }
    static _hasPopupData({ titleObj: t2, contentsObj: e2, richText: i2 }) {
      return !!((t2 == null ? void 0 : t2.str) || (e2 == null ? void 0 : e2.str) || (i2 == null ? void 0 : i2.str));
    }
    get _isEditable() {
      return this.data.isEditable;
    }
    get hasPopupData() {
      return _AnnotationElement._hasPopupData(this.data);
    }
    updateEdited(t2) {
      var _a4;
      if (!this.container) return;
      __privateGet(this, _ms) || __privateSet(this, _ms, {
        rect: this.data.rect.slice(0)
      });
      const { rect: e2 } = t2;
      e2 && __privateMethod(this, _AnnotationElement_instances, ys_fn).call(this, e2);
      (_a4 = __privateGet(this, _vs)) == null ? void 0 : _a4.popup.updateEdited(t2);
    }
    resetEdited() {
      var _a4;
      if (__privateGet(this, _ms)) {
        __privateMethod(this, _AnnotationElement_instances, ys_fn).call(this, __privateGet(this, _ms).rect);
        (_a4 = __privateGet(this, _vs)) == null ? void 0 : _a4.popup.resetEdited();
        __privateSet(this, _ms, null);
      }
    }
    _createContainer(t2) {
      const { data: e2, parent: { page: i2, viewport: s2 } } = this, n2 = document.createElement("section");
      n2.setAttribute("data-annotation-id", e2.id);
      this instanceof WidgetAnnotationElement || (n2.tabIndex = Qt);
      const { style: r2 } = n2;
      r2.zIndex = this.parent.zIndex++;
      e2.alternativeText && (n2.title = e2.alternativeText);
      e2.noRotate && n2.classList.add("norotate");
      if (!e2.rect || this instanceof PopupAnnotationElement) {
        const { rotation: t3 } = e2;
        e2.hasOwnCanvas || 0 === t3 || this.setRotation(t3, n2);
        return n2;
      }
      const { width: a2, height: o2 } = getRectDims(e2.rect);
      if (!t2 && e2.borderStyle.width > 0) {
        r2.borderWidth = `${e2.borderStyle.width}px`;
        const t3 = e2.borderStyle.horizontalCornerRadius, i3 = e2.borderStyle.verticalCornerRadius;
        if (t3 > 0 || i3 > 0) {
          const e3 = `calc(${t3}px * var(--scale-factor)) / calc(${i3}px * var(--scale-factor))`;
          r2.borderRadius = e3;
        } else if (this instanceof RadioButtonWidgetAnnotationElement) {
          const t4 = `calc(${a2}px * var(--scale-factor)) / calc(${o2}px * var(--scale-factor))`;
          r2.borderRadius = t4;
        }
        switch (e2.borderStyle.style) {
          case G:
            r2.borderStyle = "solid";
            break;
          case V:
            r2.borderStyle = "dashed";
            break;
          case $:
            warn("Unimplemented border style: beveled");
            break;
          case q:
            warn("Unimplemented border style: inset");
            break;
          case X:
            r2.borderBottomStyle = "solid";
        }
        const s3 = e2.borderColor || null;
        if (s3) {
          __privateSet(this, _bs, true);
          r2.borderColor = Util.makeHexColor(0 | s3[0], 0 | s3[1], 0 | s3[2]);
        } else r2.borderWidth = 0;
      }
      const l2 = Util.normalizeRect([
        e2.rect[0],
        i2.view[3] - e2.rect[1] + i2.view[1],
        e2.rect[2],
        i2.view[3] - e2.rect[3] + i2.view[1]
      ]), { pageWidth: h2, pageHeight: c2, pageX: d2, pageY: u2 } = s2.rawDims;
      r2.left = 100 * (l2[0] - d2) / h2 + "%";
      r2.top = 100 * (l2[1] - u2) / c2 + "%";
      const { rotation: p2 } = e2;
      if (e2.hasOwnCanvas || 0 === p2) {
        r2.width = 100 * a2 / h2 + "%";
        r2.height = 100 * o2 / c2 + "%";
      } else this.setRotation(p2, n2);
      return n2;
    }
    setRotation(t2, e2 = this.container) {
      if (!this.data.rect) return;
      const { pageWidth: i2, pageHeight: s2 } = this.parent.viewport.rawDims, { width: n2, height: r2 } = getRectDims(this.data.rect);
      let a2, o2;
      if (t2 % 180 == 0) {
        a2 = 100 * n2 / i2;
        o2 = 100 * r2 / s2;
      } else {
        a2 = 100 * r2 / i2;
        o2 = 100 * n2 / s2;
      }
      e2.style.width = `${a2}%`;
      e2.style.height = `${o2}%`;
      e2.setAttribute("data-main-rotation", (360 - t2) % 360);
    }
    get _commonActions() {
      const setColor = (t2, e2, i2) => {
        const s2 = i2.detail[t2], n2 = s2[0], r2 = s2.slice(1);
        i2.target.style[e2] = ColorConverters[`${n2}_HTML`](r2);
        this.annotationStorage.setValue(this.data.id, {
          [e2]: ColorConverters[`${n2}_rgb`](r2)
        });
      };
      return shadow(this, "_commonActions", {
        display: (t2) => {
          const { display: e2 } = t2.detail, i2 = e2 % 2 == 1;
          this.container.style.visibility = i2 ? "hidden" : "visible";
          this.annotationStorage.setValue(this.data.id, {
            noView: i2,
            noPrint: 1 === e2 || 2 === e2
          });
        },
        print: (t2) => {
          this.annotationStorage.setValue(this.data.id, {
            noPrint: !t2.detail.print
          });
        },
        hidden: (t2) => {
          const { hidden: e2 } = t2.detail;
          this.container.style.visibility = e2 ? "hidden" : "visible";
          this.annotationStorage.setValue(this.data.id, {
            noPrint: e2,
            noView: e2
          });
        },
        focus: (t2) => {
          setTimeout(() => t2.target.focus({
            preventScroll: false
          }), 0);
        },
        userName: (t2) => {
          t2.target.title = t2.detail.userName;
        },
        readonly: (t2) => {
          t2.target.disabled = t2.detail.readonly;
        },
        required: (t2) => {
          this._setRequired(t2.target, t2.detail.required);
        },
        bgColor: (t2) => {
          setColor("bgColor", "backgroundColor", t2);
        },
        fillColor: (t2) => {
          setColor("fillColor", "backgroundColor", t2);
        },
        fgColor: (t2) => {
          setColor("fgColor", "color", t2);
        },
        textColor: (t2) => {
          setColor("textColor", "color", t2);
        },
        borderColor: (t2) => {
          setColor("borderColor", "borderColor", t2);
        },
        strokeColor: (t2) => {
          setColor("strokeColor", "borderColor", t2);
        },
        rotation: (t2) => {
          const e2 = t2.detail.rotation;
          this.setRotation(e2);
          this.annotationStorage.setValue(this.data.id, {
            rotation: e2
          });
        }
      });
    }
    _dispatchEventFromSandbox(t2, e2) {
      const i2 = this._commonActions;
      for (const s2 of Object.keys(e2.detail)) {
        const n2 = t2[s2] || i2[s2];
        n2 == null ? void 0 : n2(e2);
      }
    }
    _setDefaultPropertiesFromJS(t2) {
      if (!this.enableScripting) return;
      const e2 = this.annotationStorage.getRawValue(this.data.id);
      if (!e2) return;
      const i2 = this._commonActions;
      for (const [s2, n2] of Object.entries(e2)) {
        const r2 = i2[s2];
        if (r2) {
          r2({
            detail: {
              [s2]: n2
            },
            target: t2
          });
          delete e2[s2];
        }
      }
    }
    _createQuadrilaterals() {
      if (!this.container) return;
      const { quadPoints: t2 } = this.data;
      if (!t2) return;
      const [e2, i2, s2, n2] = this.data.rect.map((t3) => Math.fround(t3));
      if (8 === t2.length) {
        const [r3, a3, o3, l3] = t2.subarray(2, 6);
        if (s2 === r3 && n2 === a3 && e2 === o3 && i2 === l3) return;
      }
      const { style: r2 } = this.container;
      let a2;
      if (__privateGet(this, _bs)) {
        const { borderColor: t3, borderWidth: e3 } = r2;
        r2.borderWidth = 0;
        a2 = [
          "url('data:image/svg+xml;utf8,",
          '<svg xmlns="http://www.w3.org/2000/svg"',
          ' preserveAspectRatio="none" viewBox="0 0 1 1">',
          `<g fill="transparent" stroke="${t3}" stroke-width="${e3}">`
        ];
        this.container.classList.add("hasBorder");
      }
      const o2 = s2 - e2, l2 = n2 - i2, { svgFactory: h2 } = this, c2 = h2.createElement("svg");
      c2.classList.add("quadrilateralsContainer");
      c2.setAttribute("width", 0);
      c2.setAttribute("height", 0);
      const d2 = h2.createElement("defs");
      c2.append(d2);
      const u2 = h2.createElement("clipPath"), p2 = `clippath_${this.data.id}`;
      u2.setAttribute("id", p2);
      u2.setAttribute("clipPathUnits", "objectBoundingBox");
      d2.append(u2);
      for (let i3 = 2, s3 = t2.length; i3 < s3; i3 += 8) {
        const s4 = t2[i3], r3 = t2[i3 + 1], c3 = t2[i3 + 2], d3 = t2[i3 + 3], p3 = h2.createElement("rect"), g2 = (c3 - e2) / o2, f2 = (n2 - r3) / l2, m2 = (s4 - c3) / o2, b2 = (r3 - d3) / l2;
        p3.setAttribute("x", g2);
        p3.setAttribute("y", f2);
        p3.setAttribute("width", m2);
        p3.setAttribute("height", b2);
        u2.append(p3);
        a2 == null ? void 0 : a2.push(`<rect vector-effect="non-scaling-stroke" x="${g2}" y="${f2}" width="${m2}" height="${b2}"/>`);
      }
      if (__privateGet(this, _bs)) {
        a2.push("</g></svg>')");
        r2.backgroundImage = a2.join("");
      }
      this.container.append(c2);
      this.container.style.clipPath = `url(#${p2})`;
    }
    _createPopup() {
      const { data: t2 } = this, e2 = __privateSet(this, _vs, new PopupAnnotationElement({
        data: {
          color: t2.color,
          titleObj: t2.titleObj,
          modificationDate: t2.modificationDate,
          contentsObj: t2.contentsObj,
          richText: t2.richText,
          parentRect: t2.rect,
          borderStyle: 0,
          id: `popup_${t2.id}`,
          rotation: t2.rotation
        },
        parent: this.parent,
        elements: [
          this
        ]
      }));
      this.parent.div.append(e2.render());
    }
    render() {
      unreachable("Abstract method `AnnotationElement.render` called");
    }
    _getElementsByName(t2, e2 = null) {
      const i2 = [];
      if (this._fieldObjects) {
        const s2 = this._fieldObjects[t2];
        if (s2) for (const { page: t3, id: n2, exportValues: r2 } of s2) {
          if (-1 === t3) continue;
          if (n2 === e2) continue;
          const s3 = "string" == typeof r2 ? r2 : null, a2 = document.querySelector(`[data-element-id="${n2}"]`);
          !a2 || Jt.has(a2) ? i2.push({
            id: n2,
            exportValue: s3,
            domElement: a2
          }) : warn(`_getElementsByName - element not allowed: ${n2}`);
        }
        return i2;
      }
      for (const s2 of document.getElementsByName(t2)) {
        const { exportValue: t3 } = s2, n2 = s2.getAttribute("data-element-id");
        n2 !== e2 && (Jt.has(s2) && i2.push({
          id: n2,
          exportValue: t3,
          domElement: s2
        }));
      }
      return i2;
    }
    show() {
      var _a4;
      this.container && (this.container.hidden = false);
      (_a4 = this.popup) == null ? void 0 : _a4.maybeShow();
    }
    hide() {
      var _a4;
      this.container && (this.container.hidden = true);
      (_a4 = this.popup) == null ? void 0 : _a4.forceHide();
    }
    getElementsToTriggerPopup() {
      return this.container;
    }
    addHighlightArea() {
      const t2 = this.getElementsToTriggerPopup();
      if (Array.isArray(t2)) for (const e2 of t2) e2.classList.add("highlightArea");
      else t2.classList.add("highlightArea");
    }
    _editOnDoubleClick() {
      if (!this._isEditable) return;
      const { annotationEditorType: t2, data: { id: e2 } } = this;
      this.container.addEventListener("dblclick", () => {
        var _a4;
        (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("switchannotationeditormode", {
          source: this,
          mode: t2,
          editId: e2
        });
      });
    }
  };
  _ms = new WeakMap();
  _bs = new WeakMap();
  _vs = new WeakMap();
  _AnnotationElement_instances = new WeakSet();
  ys_fn = function(t2) {
    const { container: { style: e2 }, data: { rect: i2, rotation: s2 }, parent: { viewport: { rawDims: { pageWidth: n2, pageHeight: r2, pageX: a2, pageY: o2 } } } } = this;
    i2 == null ? void 0 : i2.splice(0, 4, ...t2);
    const { width: l2, height: h2 } = getRectDims(t2);
    e2.left = 100 * (t2[0] - a2) / n2 + "%";
    e2.top = 100 * (r2 - t2[3] + o2) / r2 + "%";
    if (0 === s2) {
      e2.width = 100 * l2 / n2 + "%";
      e2.height = 100 * h2 / r2 + "%";
    } else this.setRotation(s2);
  };
  let AnnotationElement = _AnnotationElement;
  class LinkAnnotationElement extends AnnotationElement {
    constructor(t2, e2 = null) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: !!(e2 == null ? void 0 : e2.ignoreBorder),
        createQuadrilaterals: true
      });
      __privateAdd(this, _LinkAnnotationElement_instances);
      this.isTooltipOnly = t2.data.isTooltipOnly;
    }
    render() {
      const { data: t2, linkService: e2 } = this, i2 = document.createElement("a");
      i2.setAttribute("data-element-id", t2.id);
      let s2 = false;
      if (t2.url) {
        e2.addLinkAttributes(i2, t2.url, t2.newWindow);
        s2 = true;
      } else if (t2.action) {
        this._bindNamedAction(i2, t2.action);
        s2 = true;
      } else if (t2.attachment) {
        __privateMethod(this, _LinkAnnotationElement_instances, As_fn).call(this, i2, t2.attachment, t2.attachmentDest);
        s2 = true;
      } else if (t2.setOCGState) {
        __privateMethod(this, _LinkAnnotationElement_instances, ws_fn).call(this, i2, t2.setOCGState);
        s2 = true;
      } else if (t2.dest) {
        this._bindLink(i2, t2.dest);
        s2 = true;
      } else {
        if (t2.actions && (t2.actions.Action || t2.actions["Mouse Up"] || t2.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
          this._bindJSAction(i2, t2);
          s2 = true;
        }
        if (t2.resetForm) {
          this._bindResetFormAction(i2, t2.resetForm);
          s2 = true;
        } else if (this.isTooltipOnly && !s2) {
          this._bindLink(i2, "");
          s2 = true;
        }
      }
      this.container.classList.add("linkAnnotation");
      s2 && this.container.append(i2);
      return this.container;
    }
    _bindLink(t2, e2) {
      t2.href = this.linkService.getDestinationHash(e2);
      t2.onclick = () => {
        e2 && this.linkService.goToDestination(e2);
        return false;
      };
      (e2 || "" === e2) && __privateMethod(this, _LinkAnnotationElement_instances, xs_fn).call(this);
    }
    _bindNamedAction(t2, e2) {
      t2.href = this.linkService.getAnchorUrl("");
      t2.onclick = () => {
        this.linkService.executeNamedAction(e2);
        return false;
      };
      __privateMethod(this, _LinkAnnotationElement_instances, xs_fn).call(this);
    }
    _bindJSAction(t2, e2) {
      t2.href = this.linkService.getAnchorUrl("");
      const i2 = /* @__PURE__ */ new Map([
        [
          "Action",
          "onclick"
        ],
        [
          "Mouse Up",
          "onmouseup"
        ],
        [
          "Mouse Down",
          "onmousedown"
        ]
      ]);
      for (const s2 of Object.keys(e2.actions)) {
        const n2 = i2.get(s2);
        n2 && (t2[n2] = () => {
          var _a4;
          (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e2.id,
              name: s2
            }
          });
          return false;
        });
      }
      t2.onclick || (t2.onclick = () => false);
      __privateMethod(this, _LinkAnnotationElement_instances, xs_fn).call(this);
    }
    _bindResetFormAction(t2, e2) {
      const i2 = t2.onclick;
      i2 || (t2.href = this.linkService.getAnchorUrl(""));
      __privateMethod(this, _LinkAnnotationElement_instances, xs_fn).call(this);
      if (this._fieldObjects) t2.onclick = () => {
        var _a4;
        i2 == null ? void 0 : i2();
        const { fields: t3, refs: s2, include: n2 } = e2, r2 = [];
        if (0 !== t3.length || 0 !== s2.length) {
          const e3 = new Set(s2);
          for (const i3 of t3) {
            const t4 = this._fieldObjects[i3] || [];
            for (const { id: i4 } of t4) e3.add(i4);
          }
          for (const t4 of Object.values(this._fieldObjects)) for (const i3 of t4) e3.has(i3.id) === n2 && r2.push(i3);
        } else for (const t4 of Object.values(this._fieldObjects)) r2.push(...t4);
        const a2 = this.annotationStorage, o2 = [];
        for (const t4 of r2) {
          const { id: e3 } = t4;
          o2.push(e3);
          switch (t4.type) {
            case "text": {
              const i4 = t4.defaultValue || "";
              a2.setValue(e3, {
                value: i4
              });
              break;
            }
            case "checkbox":
            case "radiobutton": {
              const i4 = t4.defaultValue === t4.exportValues;
              a2.setValue(e3, {
                value: i4
              });
              break;
            }
            case "combobox":
            case "listbox": {
              const i4 = t4.defaultValue || "";
              a2.setValue(e3, {
                value: i4
              });
              break;
            }
            default:
              continue;
          }
          const i3 = document.querySelector(`[data-element-id="${e3}"]`);
          i3 && (Jt.has(i3) ? i3.dispatchEvent(new Event("resetform")) : warn(`_bindResetFormAction - element not allowed: ${e3}`));
        }
        this.enableScripting && ((_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: o2,
            name: "ResetForm"
          }
        }));
        return false;
      };
      else {
        warn('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.');
        i2 || (t2.onclick = () => false);
      }
    }
  }
  _LinkAnnotationElement_instances = new WeakSet();
  xs_fn = function() {
    this.container.setAttribute("data-internal-link", "");
  };
  As_fn = function(t2, e2, i2 = null) {
    t2.href = this.linkService.getAnchorUrl("");
    e2.description && (t2.title = e2.description);
    t2.onclick = () => {
      var _a4;
      (_a4 = this.downloadManager) == null ? void 0 : _a4.openOrDownloadData(e2.content, e2.filename, i2);
      return false;
    };
    __privateMethod(this, _LinkAnnotationElement_instances, xs_fn).call(this);
  };
  ws_fn = function(t2, e2) {
    t2.href = this.linkService.getAnchorUrl("");
    t2.onclick = () => {
      this.linkService.executeSetOCGState(e2);
      return false;
    };
    __privateMethod(this, _LinkAnnotationElement_instances, xs_fn).call(this);
  };
  class TextAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true
      });
    }
    render() {
      this.container.classList.add("textAnnotation");
      const t2 = document.createElement("img");
      t2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
      t2.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
      t2.setAttribute("data-l10n-args", JSON.stringify({
        type: this.data.name
      }));
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this.container.append(t2);
      return this.container;
    }
  }
  class WidgetAnnotationElement extends AnnotationElement {
    render() {
      return this.container;
    }
    showElementAndHideCanvas(t2) {
      var _a4;
      if (this.data.hasOwnCanvas) {
        "CANVAS" === ((_a4 = t2.previousSibling) == null ? void 0 : _a4.nodeName) && (t2.previousSibling.hidden = true);
        t2.hidden = false;
      }
    }
    _getKeyModifier(t2) {
      return util_FeatureTest.platform.isMac ? t2.metaKey : t2.ctrlKey;
    }
    _setEventListener(t2, e2, i2, s2, n2) {
      i2.includes("mouse") ? t2.addEventListener(i2, (t3) => {
        var _a4;
        (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: s2,
            value: n2(t3),
            shift: t3.shiftKey,
            modifier: this._getKeyModifier(t3)
          }
        });
      }) : t2.addEventListener(i2, (t3) => {
        var _a4;
        if ("blur" === i2) {
          if (!e2.focused || !t3.relatedTarget) return;
          e2.focused = false;
        } else if ("focus" === i2) {
          if (e2.focused) return;
          e2.focused = true;
        }
        n2 && ((_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: s2,
            value: n2(t3)
          }
        }));
      });
    }
    _setEventListeners(t2, e2, i2, s2) {
      var _a4, _b2, _c;
      for (const [n2, r2] of i2) if ("Action" === r2 || ((_a4 = this.data.actions) == null ? void 0 : _a4[r2])) {
        "Focus" !== r2 && "Blur" !== r2 || (e2 || (e2 = {
          focused: false
        }));
        this._setEventListener(t2, e2, n2, r2, s2);
        "Focus" !== r2 || ((_b2 = this.data.actions) == null ? void 0 : _b2.Blur) ? "Blur" !== r2 || ((_c = this.data.actions) == null ? void 0 : _c.Focus) || this._setEventListener(t2, e2, "focus", "Focus", null) : this._setEventListener(t2, e2, "blur", "Blur", null);
      }
    }
    _setBackgroundColor(t2) {
      const e2 = this.data.backgroundColor || null;
      t2.style.backgroundColor = null === e2 ? "transparent" : Util.makeHexColor(e2[0], e2[1], e2[2]);
    }
    _setTextStyle(t2) {
      const e2 = [
        "left",
        "center",
        "right"
      ], { fontColor: i2 } = this.data.defaultAppearanceData, s2 = this.data.defaultAppearanceData.fontSize || 9, n2 = t2.style;
      let a2;
      const roundToOneDecimal = (t3) => Math.round(10 * t3) / 10;
      if (this.data.multiLine) {
        const t3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2), e3 = t3 / (Math.round(t3 / (r * s2)) || 1);
        a2 = Math.min(s2, roundToOneDecimal(e3 / r));
      } else {
        const t3 = Math.abs(this.data.rect[3] - this.data.rect[1] - 2);
        a2 = Math.min(s2, roundToOneDecimal(t3 / r));
      }
      n2.fontSize = `calc(${a2}px * var(--scale-factor))`;
      n2.color = Util.makeHexColor(i2[0], i2[1], i2[2]);
      null !== this.data.textAlignment && (n2.textAlign = e2[this.data.textAlignment]);
    }
    _setRequired(t2, e2) {
      e2 ? t2.setAttribute("required", true) : t2.removeAttribute("required");
      t2.setAttribute("aria-required", e2);
    }
  }
  class TextWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: t2.renderForms || t2.data.hasOwnCanvas || !t2.data.hasAppearance && !!t2.data.fieldValue
      });
    }
    setPropertyOnSiblings(t2, e2, i2, s2) {
      const n2 = this.annotationStorage;
      for (const r2 of this._getElementsByName(t2.name, t2.id)) {
        r2.domElement && (r2.domElement[e2] = i2);
        n2.setValue(r2.id, {
          [s2]: i2
        });
      }
    }
    render() {
      var _a4, _b2;
      const t2 = this.annotationStorage, e2 = this.data.id;
      this.container.classList.add("textWidgetAnnotation");
      let i2 = null;
      if (this.renderForms) {
        const s2 = t2.getValue(e2, {
          value: this.data.fieldValue
        });
        let n2 = s2.value || "";
        const r2 = t2.getValue(e2, {
          charLimit: this.data.maxLen
        }).charLimit;
        r2 && n2.length > r2 && (n2 = n2.slice(0, r2));
        let a2 = s2.formattedValue || ((_a4 = this.data.textContent) == null ? void 0 : _a4.join("\n")) || null;
        a2 && this.data.comb && (a2 = a2.replaceAll(/\s+/g, ""));
        const o2 = {
          userValue: n2,
          formattedValue: a2,
          lastCommittedValue: null,
          commitKey: 1,
          focused: false
        };
        if (this.data.multiLine) {
          i2 = document.createElement("textarea");
          i2.textContent = a2 ?? n2;
          this.data.doNotScroll && (i2.style.overflowY = "hidden");
        } else {
          i2 = document.createElement("input");
          i2.type = "text";
          i2.setAttribute("value", a2 ?? n2);
          this.data.doNotScroll && (i2.style.overflowX = "hidden");
        }
        this.data.hasOwnCanvas && (i2.hidden = true);
        Jt.add(i2);
        i2.setAttribute("data-element-id", e2);
        i2.disabled = this.data.readOnly;
        i2.name = this.data.fieldName;
        i2.tabIndex = Qt;
        this._setRequired(i2, this.data.required);
        r2 && (i2.maxLength = r2);
        i2.addEventListener("input", (s3) => {
          t2.setValue(e2, {
            value: s3.target.value
          });
          this.setPropertyOnSiblings(i2, "value", s3.target.value, "value");
          o2.formattedValue = null;
        });
        i2.addEventListener("resetform", (t3) => {
          const e3 = this.data.defaultFieldValue ?? "";
          i2.value = o2.userValue = e3;
          o2.formattedValue = null;
        });
        let blurListener = (t3) => {
          const { formattedValue: e3 } = o2;
          null != e3 && (t3.target.value = e3);
          t3.target.scrollLeft = 0;
        };
        if (this.enableScripting && this.hasJSActions) {
          i2.addEventListener("focus", (t3) => {
            var _a5;
            if (o2.focused) return;
            const { target: e3 } = t3;
            o2.userValue && (e3.value = o2.userValue);
            o2.lastCommittedValue = e3.value;
            o2.commitKey = 1;
            ((_a5 = this.data.actions) == null ? void 0 : _a5.Focus) || (o2.focused = true);
          });
          i2.addEventListener("updatefromsandbox", (i3) => {
            this.showElementAndHideCanvas(i3.target);
            const s4 = {
              value(i4) {
                o2.userValue = i4.detail.value ?? "";
                t2.setValue(e2, {
                  value: o2.userValue.toString()
                });
                i4.target.value = o2.userValue;
              },
              formattedValue(i4) {
                const { formattedValue: s5 } = i4.detail;
                o2.formattedValue = s5;
                null != s5 && i4.target !== document.activeElement && (i4.target.value = s5);
                t2.setValue(e2, {
                  formattedValue: s5
                });
              },
              selRange(t3) {
                t3.target.setSelectionRange(...t3.detail.selRange);
              },
              charLimit: (i4) => {
                var _a5;
                const { charLimit: s5 } = i4.detail, { target: n3 } = i4;
                if (0 === s5) {
                  n3.removeAttribute("maxLength");
                  return;
                }
                n3.setAttribute("maxLength", s5);
                let r3 = o2.userValue;
                if (r3 && !(r3.length <= s5)) {
                  r3 = r3.slice(0, s5);
                  n3.value = o2.userValue = r3;
                  t2.setValue(e2, {
                    value: r3
                  });
                  (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: e2,
                      name: "Keystroke",
                      value: r3,
                      willCommit: true,
                      commitKey: 1,
                      selStart: n3.selectionStart,
                      selEnd: n3.selectionEnd
                    }
                  });
                }
              }
            };
            this._dispatchEventFromSandbox(s4, i3);
          });
          i2.addEventListener("keydown", (t3) => {
            var _a5;
            o2.commitKey = 1;
            let i3 = -1;
            "Escape" === t3.key ? i3 = 0 : "Enter" !== t3.key || this.data.multiLine ? "Tab" === t3.key && (o2.commitKey = 3) : i3 = 2;
            if (-1 === i3) return;
            const { value: s4 } = t3.target;
            if (o2.lastCommittedValue !== s4) {
              o2.lastCommittedValue = s4;
              o2.userValue = s4;
              (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: e2,
                  name: "Keystroke",
                  value: s4,
                  willCommit: true,
                  commitKey: i3,
                  selStart: t3.target.selectionStart,
                  selEnd: t3.target.selectionEnd
                }
              });
            }
          });
          const s3 = blurListener;
          blurListener = null;
          i2.addEventListener("blur", (t3) => {
            var _a5, _b3;
            if (!o2.focused || !t3.relatedTarget) return;
            ((_a5 = this.data.actions) == null ? void 0 : _a5.Blur) || (o2.focused = false);
            const { value: i3 } = t3.target;
            o2.userValue = i3;
            o2.lastCommittedValue !== i3 && ((_b3 = this.linkService.eventBus) == null ? void 0 : _b3.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: e2,
                name: "Keystroke",
                value: i3,
                willCommit: true,
                commitKey: o2.commitKey,
                selStart: t3.target.selectionStart,
                selEnd: t3.target.selectionEnd
              }
            }));
            s3(t3);
          });
          ((_b2 = this.data.actions) == null ? void 0 : _b2.Keystroke) && i2.addEventListener("beforeinput", (t3) => {
            var _a5;
            o2.lastCommittedValue = null;
            const { data: i3, target: s4 } = t3, { value: n3, selectionStart: r3, selectionEnd: a3 } = s4;
            let l2 = r3, h2 = a3;
            switch (t3.inputType) {
              case "deleteWordBackward": {
                const t4 = n3.substring(0, r3).match(/\w*[^\w]*$/);
                t4 && (l2 -= t4[0].length);
                break;
              }
              case "deleteWordForward": {
                const t4 = n3.substring(r3).match(/^[^\w]*\w*/);
                t4 && (h2 += t4[0].length);
                break;
              }
              case "deleteContentBackward":
                r3 === a3 && (l2 -= 1);
                break;
              case "deleteContentForward":
                r3 === a3 && (h2 += 1);
            }
            t3.preventDefault();
            (_a5 = this.linkService.eventBus) == null ? void 0 : _a5.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: e2,
                name: "Keystroke",
                value: n3,
                change: i3 || "",
                willCommit: false,
                selStart: l2,
                selEnd: h2
              }
            });
          });
          this._setEventListeners(i2, o2, [
            [
              "focus",
              "Focus"
            ],
            [
              "blur",
              "Blur"
            ],
            [
              "mousedown",
              "Mouse Down"
            ],
            [
              "mouseenter",
              "Mouse Enter"
            ],
            [
              "mouseleave",
              "Mouse Exit"
            ],
            [
              "mouseup",
              "Mouse Up"
            ]
          ], (t3) => t3.target.value);
        }
        blurListener && i2.addEventListener("blur", blurListener);
        if (this.data.comb) {
          const t3 = (this.data.rect[2] - this.data.rect[0]) / r2;
          i2.classList.add("comb");
          i2.style.letterSpacing = `calc(${t3}px * var(--scale-factor) - 1ch)`;
        }
      } else {
        i2 = document.createElement("div");
        i2.textContent = this.data.fieldValue;
        i2.style.verticalAlign = "middle";
        i2.style.display = "table-cell";
        this.data.hasOwnCanvas && (i2.hidden = true);
      }
      this._setTextStyle(i2);
      this._setBackgroundColor(i2);
      this._setDefaultPropertiesFromJS(i2);
      this.container.append(i2);
      return this.container;
    }
  }
  class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: !!t2.data.hasOwnCanvas
      });
    }
  }
  class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: t2.renderForms
      });
    }
    render() {
      const t2 = this.annotationStorage, e2 = this.data, i2 = e2.id;
      let s2 = t2.getValue(i2, {
        value: e2.exportValue === e2.fieldValue
      }).value;
      if ("string" == typeof s2) {
        s2 = "Off" !== s2;
        t2.setValue(i2, {
          value: s2
        });
      }
      this.container.classList.add("buttonWidgetAnnotation", "checkBox");
      const n2 = document.createElement("input");
      Jt.add(n2);
      n2.setAttribute("data-element-id", i2);
      n2.disabled = e2.readOnly;
      this._setRequired(n2, this.data.required);
      n2.type = "checkbox";
      n2.name = e2.fieldName;
      s2 && n2.setAttribute("checked", true);
      n2.setAttribute("exportValue", e2.exportValue);
      n2.tabIndex = Qt;
      n2.addEventListener("change", (s3) => {
        const { name: n3, checked: r2 } = s3.target;
        for (const s4 of this._getElementsByName(n3, i2)) {
          const i3 = r2 && s4.exportValue === e2.exportValue;
          s4.domElement && (s4.domElement.checked = i3);
          t2.setValue(s4.id, {
            value: i3
          });
        }
        t2.setValue(i2, {
          value: r2
        });
      });
      n2.addEventListener("resetform", (t3) => {
        const i3 = e2.defaultFieldValue || "Off";
        t3.target.checked = i3 === e2.exportValue;
      });
      if (this.enableScripting && this.hasJSActions) {
        n2.addEventListener("updatefromsandbox", (e3) => {
          const s3 = {
            value(e4) {
              e4.target.checked = "Off" !== e4.detail.value;
              t2.setValue(i2, {
                value: e4.target.checked
              });
            }
          };
          this._dispatchEventFromSandbox(s3, e3);
        });
        this._setEventListeners(n2, null, [
          [
            "change",
            "Validate"
          ],
          [
            "change",
            "Action"
          ],
          [
            "focus",
            "Focus"
          ],
          [
            "blur",
            "Blur"
          ],
          [
            "mousedown",
            "Mouse Down"
          ],
          [
            "mouseenter",
            "Mouse Enter"
          ],
          [
            "mouseleave",
            "Mouse Exit"
          ],
          [
            "mouseup",
            "Mouse Up"
          ]
        ], (t3) => t3.target.checked);
      }
      this._setBackgroundColor(n2);
      this._setDefaultPropertiesFromJS(n2);
      this.container.append(n2);
      return this.container;
    }
  }
  class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: t2.renderForms
      });
    }
    render() {
      this.container.classList.add("buttonWidgetAnnotation", "radioButton");
      const t2 = this.annotationStorage, e2 = this.data, i2 = e2.id;
      let s2 = t2.getValue(i2, {
        value: e2.fieldValue === e2.buttonValue
      }).value;
      if ("string" == typeof s2) {
        s2 = s2 !== e2.buttonValue;
        t2.setValue(i2, {
          value: s2
        });
      }
      if (s2) for (const s3 of this._getElementsByName(e2.fieldName, i2)) t2.setValue(s3.id, {
        value: false
      });
      const n2 = document.createElement("input");
      Jt.add(n2);
      n2.setAttribute("data-element-id", i2);
      n2.disabled = e2.readOnly;
      this._setRequired(n2, this.data.required);
      n2.type = "radio";
      n2.name = e2.fieldName;
      s2 && n2.setAttribute("checked", true);
      n2.tabIndex = Qt;
      n2.addEventListener("change", (e3) => {
        const { name: s3, checked: n3 } = e3.target;
        for (const e4 of this._getElementsByName(s3, i2)) t2.setValue(e4.id, {
          value: false
        });
        t2.setValue(i2, {
          value: n3
        });
      });
      n2.addEventListener("resetform", (t3) => {
        const i3 = e2.defaultFieldValue;
        t3.target.checked = null != i3 && i3 === e2.buttonValue;
      });
      if (this.enableScripting && this.hasJSActions) {
        const s3 = e2.buttonValue;
        n2.addEventListener("updatefromsandbox", (e3) => {
          const n3 = {
            value: (e4) => {
              const n4 = s3 === e4.detail.value;
              for (const s4 of this._getElementsByName(e4.target.name)) {
                const e5 = n4 && s4.id === i2;
                s4.domElement && (s4.domElement.checked = e5);
                t2.setValue(s4.id, {
                  value: e5
                });
              }
            }
          };
          this._dispatchEventFromSandbox(n3, e3);
        });
        this._setEventListeners(n2, null, [
          [
            "change",
            "Validate"
          ],
          [
            "change",
            "Action"
          ],
          [
            "focus",
            "Focus"
          ],
          [
            "blur",
            "Blur"
          ],
          [
            "mousedown",
            "Mouse Down"
          ],
          [
            "mouseenter",
            "Mouse Enter"
          ],
          [
            "mouseleave",
            "Mouse Exit"
          ],
          [
            "mouseup",
            "Mouse Up"
          ]
        ], (t3) => t3.target.checked);
      }
      this._setBackgroundColor(n2);
      this._setDefaultPropertiesFromJS(n2);
      this.container.append(n2);
      return this.container;
    }
  }
  class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
    constructor(t2) {
      super(t2, {
        ignoreBorder: t2.data.hasAppearance
      });
    }
    render() {
      const t2 = super.render();
      t2.classList.add("buttonWidgetAnnotation", "pushButton");
      const e2 = t2.lastChild;
      if (this.enableScripting && this.hasJSActions && e2) {
        this._setDefaultPropertiesFromJS(e2);
        e2.addEventListener("updatefromsandbox", (t3) => {
          this._dispatchEventFromSandbox({}, t3);
        });
      }
      return t2;
    }
  }
  class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: t2.renderForms
      });
    }
    render() {
      this.container.classList.add("choiceWidgetAnnotation");
      const t2 = this.annotationStorage, e2 = this.data.id, i2 = t2.getValue(e2, {
        value: this.data.fieldValue
      }), s2 = document.createElement("select");
      Jt.add(s2);
      s2.setAttribute("data-element-id", e2);
      s2.disabled = this.data.readOnly;
      this._setRequired(s2, this.data.required);
      s2.name = this.data.fieldName;
      s2.tabIndex = Qt;
      let n2 = this.data.combo && this.data.options.length > 0;
      if (!this.data.combo) {
        s2.size = this.data.options.length;
        this.data.multiSelect && (s2.multiple = true);
      }
      s2.addEventListener("resetform", (t3) => {
        const e3 = this.data.defaultFieldValue;
        for (const t4 of s2.options) t4.selected = t4.value === e3;
      });
      for (const t3 of this.data.options) {
        const e3 = document.createElement("option");
        e3.textContent = t3.displayValue;
        e3.value = t3.exportValue;
        if (i2.value.includes(t3.exportValue)) {
          e3.setAttribute("selected", true);
          n2 = false;
        }
        s2.append(e3);
      }
      let r2 = null;
      if (n2) {
        const t3 = document.createElement("option");
        t3.value = " ";
        t3.setAttribute("hidden", true);
        t3.setAttribute("selected", true);
        s2.prepend(t3);
        r2 = () => {
          t3.remove();
          s2.removeEventListener("input", r2);
          r2 = null;
        };
        s2.addEventListener("input", r2);
      }
      const getValue = (t3) => {
        const e3 = t3 ? "value" : "textContent", { options: i3, multiple: n3 } = s2;
        return n3 ? Array.prototype.filter.call(i3, (t4) => t4.selected).map((t4) => t4[e3]) : -1 === i3.selectedIndex ? null : i3[i3.selectedIndex][e3];
      };
      let a2 = getValue(false);
      const getItems = (t3) => {
        const e3 = t3.target.options;
        return Array.prototype.map.call(e3, (t4) => ({
          displayValue: t4.textContent,
          exportValue: t4.value
        }));
      };
      if (this.enableScripting && this.hasJSActions) {
        s2.addEventListener("updatefromsandbox", (i3) => {
          const n3 = {
            value(i4) {
              r2 == null ? void 0 : r2();
              const n4 = i4.detail.value, o2 = new Set(Array.isArray(n4) ? n4 : [
                n4
              ]);
              for (const t3 of s2.options) t3.selected = o2.has(t3.value);
              t2.setValue(e2, {
                value: getValue(true)
              });
              a2 = getValue(false);
            },
            multipleSelection(t3) {
              s2.multiple = true;
            },
            remove(i4) {
              const n4 = s2.options, r3 = i4.detail.remove;
              n4[r3].selected = false;
              s2.remove(r3);
              if (n4.length > 0) {
                -1 === Array.prototype.findIndex.call(n4, (t3) => t3.selected) && (n4[0].selected = true);
              }
              t2.setValue(e2, {
                value: getValue(true),
                items: getItems(i4)
              });
              a2 = getValue(false);
            },
            clear(i4) {
              for (; 0 !== s2.length; ) s2.remove(0);
              t2.setValue(e2, {
                value: null,
                items: []
              });
              a2 = getValue(false);
            },
            insert(i4) {
              const { index: n4, displayValue: r3, exportValue: o2 } = i4.detail.insert, l2 = s2.children[n4], h2 = document.createElement("option");
              h2.textContent = r3;
              h2.value = o2;
              l2 ? l2.before(h2) : s2.append(h2);
              t2.setValue(e2, {
                value: getValue(true),
                items: getItems(i4)
              });
              a2 = getValue(false);
            },
            items(i4) {
              const { items: n4 } = i4.detail;
              for (; 0 !== s2.length; ) s2.remove(0);
              for (const t3 of n4) {
                const { displayValue: e3, exportValue: i5 } = t3, n5 = document.createElement("option");
                n5.textContent = e3;
                n5.value = i5;
                s2.append(n5);
              }
              s2.options.length > 0 && (s2.options[0].selected = true);
              t2.setValue(e2, {
                value: getValue(true),
                items: getItems(i4)
              });
              a2 = getValue(false);
            },
            indices(i4) {
              const s3 = new Set(i4.detail.indices);
              for (const t3 of i4.target.options) t3.selected = s3.has(t3.index);
              t2.setValue(e2, {
                value: getValue(true)
              });
              a2 = getValue(false);
            },
            editable(t3) {
              t3.target.disabled = !t3.detail.editable;
            }
          };
          this._dispatchEventFromSandbox(n3, i3);
        });
        s2.addEventListener("input", (i3) => {
          var _a4;
          const s3 = getValue(true), n3 = getValue(false);
          t2.setValue(e2, {
            value: s3
          });
          i3.preventDefault();
          (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: e2,
              name: "Keystroke",
              value: a2,
              change: n3,
              changeEx: s3,
              willCommit: false,
              commitKey: 1,
              keyDown: false
            }
          });
        });
        this._setEventListeners(s2, null, [
          [
            "focus",
            "Focus"
          ],
          [
            "blur",
            "Blur"
          ],
          [
            "mousedown",
            "Mouse Down"
          ],
          [
            "mouseenter",
            "Mouse Enter"
          ],
          [
            "mouseleave",
            "Mouse Exit"
          ],
          [
            "mouseup",
            "Mouse Up"
          ],
          [
            "input",
            "Action"
          ],
          [
            "input",
            "Validate"
          ]
        ], (t3) => t3.target.value);
      } else s2.addEventListener("input", function(i3) {
        t2.setValue(e2, {
          value: getValue(true)
        });
      });
      this.data.combo && this._setTextStyle(s2);
      this._setBackgroundColor(s2);
      this._setDefaultPropertiesFromJS(s2);
      this.container.append(s2);
      return this.container;
    }
  }
  class PopupAnnotationElement extends AnnotationElement {
    constructor(t2) {
      const { data: e2, elements: i2 } = t2;
      super(t2, {
        isRenderable: AnnotationElement._hasPopupData(e2)
      });
      this.elements = i2;
      this.popup = null;
    }
    render() {
      this.container.classList.add("popupAnnotation");
      const t2 = this.popup = new PopupElement({
        container: this.container,
        color: this.data.color,
        titleObj: this.data.titleObj,
        modificationDate: this.data.modificationDate,
        contentsObj: this.data.contentsObj,
        richText: this.data.richText,
        rect: this.data.rect,
        parentRect: this.data.parentRect || null,
        parent: this.parent,
        elements: this.elements,
        open: this.data.open
      }), e2 = [];
      for (const i2 of this.elements) {
        i2.popup = t2;
        i2.container.ariaHasPopup = "dialog";
        e2.push(i2.data.id);
        i2.addHighlightArea();
      }
      this.container.setAttribute("aria-controls", e2.map((t3) => `${st}${t3}`).join(","));
      return this.container;
    }
  }
  class PopupElement {
    constructor({ container: t2, color: e2, elements: i2, titleObj: s2, modificationDate: n2, contentsObj: r2, richText: a2, parent: o2, rect: l2, parentRect: h2, open: c2 }) {
      __privateAdd(this, _PopupElement_instances);
      __privateAdd(this, __s, __privateMethod(this, _PopupElement_instances, Es_fn).bind(this));
      __privateAdd(this, _Cs, __privateMethod(this, _PopupElement_instances, Ss_fn).bind(this));
      __privateAdd(this, _Ts, __privateMethod(this, _PopupElement_instances, Ms_fn).bind(this));
      __privateAdd(this, _ks, __privateMethod(this, _PopupElement_instances, Ps_fn).bind(this));
      __privateAdd(this, _Rs, null);
      __privateAdd(this, _ut3, null);
      __privateAdd(this, _Ds, null);
      __privateAdd(this, _Is, null);
      __privateAdd(this, _Fs, null);
      __privateAdd(this, _Ls, null);
      __privateAdd(this, _Os, null);
      __privateAdd(this, _Ns, false);
      __privateAdd(this, _Bs, null);
      __privateAdd(this, _S2, null);
      __privateAdd(this, _Hs, null);
      __privateAdd(this, _Us, null);
      __privateAdd(this, _zs, null);
      __privateAdd(this, _ms2, null);
      __privateAdd(this, _js, false);
      var _a4;
      __privateSet(this, _ut3, t2);
      __privateSet(this, _zs, s2);
      __privateSet(this, _Ds, r2);
      __privateSet(this, _Us, a2);
      __privateSet(this, _Ls, o2);
      __privateSet(this, _Rs, e2);
      __privateSet(this, _Hs, l2);
      __privateSet(this, _Os, h2);
      __privateSet(this, _Fs, i2);
      __privateSet(this, _Is, PDFDateString.toDateObject(n2));
      this.trigger = i2.flatMap((t3) => t3.getElementsToTriggerPopup());
      for (const t3 of this.trigger) {
        t3.addEventListener("click", __privateGet(this, _ks));
        t3.addEventListener("mouseenter", __privateGet(this, _Ts));
        t3.addEventListener("mouseleave", __privateGet(this, _Cs));
        t3.classList.add("popupTriggerArea");
      }
      for (const t3 of i2) (_a4 = t3.container) == null ? void 0 : _a4.addEventListener("keydown", __privateGet(this, __s));
      __privateGet(this, _ut3).hidden = true;
      c2 && __privateMethod(this, _PopupElement_instances, Ps_fn).call(this);
    }
    render() {
      if (__privateGet(this, _Bs)) return;
      const t2 = __privateSet(this, _Bs, document.createElement("div"));
      t2.className = "popup";
      if (__privateGet(this, _Rs)) {
        const e3 = t2.style.outlineColor = Util.makeHexColor(...__privateGet(this, _Rs));
        if (CSS.supports("background-color", "color-mix(in srgb, red 30%, white)")) t2.style.backgroundColor = `color-mix(in srgb, ${e3} 30%, white)`;
        else {
          const e4 = 0.7;
          t2.style.backgroundColor = Util.makeHexColor(...__privateGet(this, _Rs).map((t3) => Math.floor(e4 * (255 - t3) + t3)));
        }
      }
      const e2 = document.createElement("span");
      e2.className = "header";
      const i2 = document.createElement("h1");
      e2.append(i2);
      ({ dir: i2.dir, str: i2.textContent } = __privateGet(this, _zs));
      t2.append(e2);
      if (__privateGet(this, _Is)) {
        const t3 = document.createElement("span");
        t3.classList.add("popupDate");
        t3.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
        t3.setAttribute("data-l10n-args", JSON.stringify({
          dateObj: __privateGet(this, _Is).valueOf()
        }));
        e2.append(t3);
      }
      const s2 = __privateGet(this, _PopupElement_instances, Ws_get);
      if (s2) {
        XfaLayer.render({
          xfaHtml: s2,
          intent: "richText",
          div: t2
        });
        t2.lastChild.classList.add("richText", "popupContent");
      } else {
        const e3 = this._formatContents(__privateGet(this, _Ds));
        t2.append(e3);
      }
      __privateGet(this, _ut3).append(t2);
    }
    _formatContents({ str: t2, dir: e2 }) {
      const i2 = document.createElement("p");
      i2.classList.add("popupContent");
      i2.dir = e2;
      const s2 = t2.split(/(?:\r\n?|\n)/);
      for (let t3 = 0, e3 = s2.length; t3 < e3; ++t3) {
        const n2 = s2[t3];
        i2.append(document.createTextNode(n2));
        t3 < e3 - 1 && i2.append(document.createElement("br"));
      }
      return i2;
    }
    updateEdited({ rect: t2, popupContent: e2 }) {
      var _a4;
      __privateGet(this, _ms2) || __privateSet(this, _ms2, {
        contentsObj: __privateGet(this, _Ds),
        richText: __privateGet(this, _Us)
      });
      t2 && __privateSet(this, _S2, null);
      if (e2) {
        __privateSet(this, _Us, __privateMethod(this, _PopupElement_instances, $s_fn).call(this, e2));
        __privateSet(this, _Ds, null);
      }
      (_a4 = __privateGet(this, _Bs)) == null ? void 0 : _a4.remove();
      __privateSet(this, _Bs, null);
    }
    resetEdited() {
      var _a4;
      if (__privateGet(this, _ms2)) {
        ({ contentsObj: __privateWrapper(this, _Ds)._, richText: __privateWrapper(this, _Us)._ } = __privateGet(this, _ms2));
        __privateSet(this, _ms2, null);
        (_a4 = __privateGet(this, _Bs)) == null ? void 0 : _a4.remove();
        __privateSet(this, _Bs, null);
        __privateSet(this, _S2, null);
      }
    }
    forceHide() {
      __privateSet(this, _js, this.isVisible);
      __privateGet(this, _js) && (__privateGet(this, _ut3).hidden = true);
    }
    maybeShow() {
      if (__privateGet(this, _js)) {
        __privateGet(this, _Bs) || __privateMethod(this, _PopupElement_instances, Ms_fn).call(this);
        __privateSet(this, _js, false);
        __privateGet(this, _ut3).hidden = false;
      }
    }
    get isVisible() {
      return false === __privateGet(this, _ut3).hidden;
    }
  }
  __s = new WeakMap();
  _Cs = new WeakMap();
  _Ts = new WeakMap();
  _ks = new WeakMap();
  _Rs = new WeakMap();
  _ut3 = new WeakMap();
  _Ds = new WeakMap();
  _Is = new WeakMap();
  _Fs = new WeakMap();
  _Ls = new WeakMap();
  _Os = new WeakMap();
  _Ns = new WeakMap();
  _Bs = new WeakMap();
  _S2 = new WeakMap();
  _Hs = new WeakMap();
  _Us = new WeakMap();
  _zs = new WeakMap();
  _ms2 = new WeakMap();
  _js = new WeakMap();
  _PopupElement_instances = new WeakSet();
  Ws_get = function() {
    const t2 = __privateGet(this, _Us), e2 = __privateGet(this, _Ds);
    return !(t2 == null ? void 0 : t2.str) || (e2 == null ? void 0 : e2.str) && e2.str !== t2.str ? null : __privateGet(this, _Us).html || null;
  };
  Gs_get = function() {
    var _a4, _b2, _c;
    return ((_c = (_b2 = (_a4 = __privateGet(this, _PopupElement_instances, Ws_get)) == null ? void 0 : _a4.attributes) == null ? void 0 : _b2.style) == null ? void 0 : _c.fontSize) || 0;
  };
  Vs_get = function() {
    var _a4, _b2, _c;
    return ((_c = (_b2 = (_a4 = __privateGet(this, _PopupElement_instances, Ws_get)) == null ? void 0 : _a4.attributes) == null ? void 0 : _b2.style) == null ? void 0 : _c.color) || null;
  };
  $s_fn = function(t2) {
    const e2 = [], i2 = {
      str: t2,
      html: {
        name: "div",
        attributes: {
          dir: "auto"
        },
        children: [
          {
            name: "p",
            children: e2
          }
        ]
      }
    }, s2 = {
      style: {
        color: __privateGet(this, _PopupElement_instances, Vs_get),
        fontSize: __privateGet(this, _PopupElement_instances, Gs_get) ? `calc(${__privateGet(this, _PopupElement_instances, Gs_get)}px * var(--scale-factor))` : ""
      }
    };
    for (const i3 of t2.split("\n")) e2.push({
      name: "span",
      value: i3,
      attributes: s2
    });
    return i2;
  };
  Es_fn = function(t2) {
    t2.altKey || t2.shiftKey || t2.ctrlKey || t2.metaKey || ("Enter" === t2.key || "Escape" === t2.key && __privateGet(this, _Ns)) && __privateMethod(this, _PopupElement_instances, Ps_fn).call(this);
  };
  qs_fn = function() {
    if (null !== __privateGet(this, _S2)) return;
    const { page: { view: t2 }, viewport: { rawDims: { pageWidth: e2, pageHeight: i2, pageX: s2, pageY: n2 } } } = __privateGet(this, _Ls);
    let r2 = !!__privateGet(this, _Os), a2 = r2 ? __privateGet(this, _Os) : __privateGet(this, _Hs);
    for (const t3 of __privateGet(this, _Fs)) if (!a2 || null !== Util.intersect(t3.data.rect, a2)) {
      a2 = t3.data.rect;
      r2 = true;
      break;
    }
    const o2 = Util.normalizeRect([
      a2[0],
      t2[3] - a2[1] + t2[1],
      a2[2],
      t2[3] - a2[3] + t2[1]
    ]), l2 = r2 ? a2[2] - a2[0] + 5 : 0, h2 = o2[0] + l2, c2 = o2[1];
    __privateSet(this, _S2, [
      100 * (h2 - s2) / e2,
      100 * (c2 - n2) / i2
    ]);
    const { style: d2 } = __privateGet(this, _ut3);
    d2.left = `${__privateGet(this, _S2)[0]}%`;
    d2.top = `${__privateGet(this, _S2)[1]}%`;
  };
  Ps_fn = function() {
    __privateSet(this, _Ns, !__privateGet(this, _Ns));
    if (__privateGet(this, _Ns)) {
      __privateMethod(this, _PopupElement_instances, Ms_fn).call(this);
      __privateGet(this, _ut3).addEventListener("click", __privateGet(this, _ks));
      __privateGet(this, _ut3).addEventListener("keydown", __privateGet(this, __s));
    } else {
      __privateMethod(this, _PopupElement_instances, Ss_fn).call(this);
      __privateGet(this, _ut3).removeEventListener("click", __privateGet(this, _ks));
      __privateGet(this, _ut3).removeEventListener("keydown", __privateGet(this, __s));
    }
  };
  Ms_fn = function() {
    __privateGet(this, _Bs) || this.render();
    if (this.isVisible) __privateGet(this, _Ns) && __privateGet(this, _ut3).classList.add("focused");
    else {
      __privateMethod(this, _PopupElement_instances, qs_fn).call(this);
      __privateGet(this, _ut3).hidden = false;
      __privateGet(this, _ut3).style.zIndex = parseInt(__privateGet(this, _ut3).style.zIndex) + 1e3;
    }
  };
  Ss_fn = function() {
    __privateGet(this, _ut3).classList.remove("focused");
    if (!__privateGet(this, _Ns) && this.isVisible) {
      __privateGet(this, _ut3).hidden = true;
      __privateGet(this, _ut3).style.zIndex = parseInt(__privateGet(this, _ut3).style.zIndex) - 1e3;
    }
  };
  class FreeTextAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      this.textContent = t2.data.textContent;
      this.textPosition = t2.data.textPosition;
      this.annotationEditorType = f.FREETEXT;
    }
    render() {
      this.container.classList.add("freeTextAnnotation");
      if (this.textContent) {
        const t2 = document.createElement("div");
        t2.classList.add("annotationTextContent");
        t2.setAttribute("role", "comment");
        for (const e2 of this.textContent) {
          const i2 = document.createElement("span");
          i2.textContent = e2;
          t2.append(i2);
        }
        this.container.append(t2);
      }
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this._editOnDoubleClick();
      return this.container;
    }
  }
  class LineAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      __privateAdd(this, _Xs, null);
    }
    render() {
      this.container.classList.add("lineAnnotation");
      const t2 = this.data, { width: e2, height: i2 } = getRectDims(t2.rect), s2 = this.svgFactory.create(e2, i2, true), n2 = __privateSet(this, _Xs, this.svgFactory.createElement("svg:line"));
      n2.setAttribute("x1", t2.rect[2] - t2.lineCoordinates[0]);
      n2.setAttribute("y1", t2.rect[3] - t2.lineCoordinates[1]);
      n2.setAttribute("x2", t2.rect[2] - t2.lineCoordinates[2]);
      n2.setAttribute("y2", t2.rect[3] - t2.lineCoordinates[3]);
      n2.setAttribute("stroke-width", t2.borderStyle.width || 1);
      n2.setAttribute("stroke", "transparent");
      n2.setAttribute("fill", "transparent");
      s2.append(n2);
      this.container.append(s2);
      !t2.popupRef && this.hasPopupData && this._createPopup();
      return this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Xs);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Xs = new WeakMap();
  class SquareAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      __privateAdd(this, _Ks, null);
    }
    render() {
      this.container.classList.add("squareAnnotation");
      const t2 = this.data, { width: e2, height: i2 } = getRectDims(t2.rect), s2 = this.svgFactory.create(e2, i2, true), n2 = t2.borderStyle.width, r2 = __privateSet(this, _Ks, this.svgFactory.createElement("svg:rect"));
      r2.setAttribute("x", n2 / 2);
      r2.setAttribute("y", n2 / 2);
      r2.setAttribute("width", e2 - n2);
      r2.setAttribute("height", i2 - n2);
      r2.setAttribute("stroke-width", n2 || 1);
      r2.setAttribute("stroke", "transparent");
      r2.setAttribute("fill", "transparent");
      s2.append(r2);
      this.container.append(s2);
      !t2.popupRef && this.hasPopupData && this._createPopup();
      return this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Ks);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Ks = new WeakMap();
  class CircleAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      __privateAdd(this, _Ys, null);
    }
    render() {
      this.container.classList.add("circleAnnotation");
      const t2 = this.data, { width: e2, height: i2 } = getRectDims(t2.rect), s2 = this.svgFactory.create(e2, i2, true), n2 = t2.borderStyle.width, r2 = __privateSet(this, _Ys, this.svgFactory.createElement("svg:ellipse"));
      r2.setAttribute("cx", e2 / 2);
      r2.setAttribute("cy", i2 / 2);
      r2.setAttribute("rx", e2 / 2 - n2 / 2);
      r2.setAttribute("ry", i2 / 2 - n2 / 2);
      r2.setAttribute("stroke-width", n2 || 1);
      r2.setAttribute("stroke", "transparent");
      r2.setAttribute("fill", "transparent");
      s2.append(r2);
      this.container.append(s2);
      !t2.popupRef && this.hasPopupData && this._createPopup();
      return this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Ys);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Ys = new WeakMap();
  class PolylineAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      __privateAdd(this, _Qs, null);
      this.containerClassName = "polylineAnnotation";
      this.svgElementName = "svg:polyline";
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const { data: { rect: t2, vertices: e2, borderStyle: i2, popupRef: s2 } } = this;
      if (!e2) return this.container;
      const { width: n2, height: r2 } = getRectDims(t2), a2 = this.svgFactory.create(n2, r2, true);
      let o2 = [];
      for (let i3 = 0, s3 = e2.length; i3 < s3; i3 += 2) {
        const s4 = e2[i3] - t2[0], n3 = t2[3] - e2[i3 + 1];
        o2.push(`${s4},${n3}`);
      }
      o2 = o2.join(" ");
      const l2 = __privateSet(this, _Qs, this.svgFactory.createElement(this.svgElementName));
      l2.setAttribute("points", o2);
      l2.setAttribute("stroke-width", i2.width || 1);
      l2.setAttribute("stroke", "transparent");
      l2.setAttribute("fill", "transparent");
      a2.append(l2);
      this.container.append(a2);
      !s2 && this.hasPopupData && this._createPopup();
      return this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Qs);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Qs = new WeakMap();
  class PolygonAnnotationElement extends PolylineAnnotationElement {
    constructor(t2) {
      super(t2);
      this.containerClassName = "polygonAnnotation";
      this.svgElementName = "svg:polygon";
    }
  }
  class CaretAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
    }
    render() {
      this.container.classList.add("caretAnnotation");
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      return this.container;
    }
  }
  class InkAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      __privateAdd(this, _Js, []);
      this.containerClassName = "inkAnnotation";
      this.svgElementName = "svg:polyline";
      this.annotationEditorType = "InkHighlight" === this.data.it ? f.HIGHLIGHT : f.INK;
    }
    render() {
      this.container.classList.add(this.containerClassName);
      const { data: { rect: t2, inkLists: e2, borderStyle: i2, popupRef: s2 } } = this, { width: n2, height: r2 } = getRectDims(t2), a2 = this.svgFactory.create(n2, r2, true);
      for (const s3 of e2) {
        let e3 = [];
        for (let i3 = 0, n4 = s3.length; i3 < n4; i3 += 2) {
          const n5 = s3[i3] - t2[0], r3 = t2[3] - s3[i3 + 1];
          e3.push(`${n5},${r3}`);
        }
        e3 = e3.join(" ");
        const n3 = this.svgFactory.createElement(this.svgElementName);
        __privateGet(this, _Js).push(n3);
        n3.setAttribute("points", e3);
        n3.setAttribute("stroke-width", i2.width || 1);
        n3.setAttribute("stroke", "transparent");
        n3.setAttribute("fill", "transparent");
        a2.append(n3);
      }
      !s2 && this.hasPopupData && this._createPopup();
      this.container.append(a2);
      this._editOnDoubleClick();
      return this.container;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Js);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Js = new WeakMap();
  class HighlightAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
      this.annotationEditorType = f.HIGHLIGHT;
    }
    render() {
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this.container.classList.add("highlightAnnotation");
      this._editOnDoubleClick();
      return this.container;
    }
  }
  class UnderlineAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }
    render() {
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this.container.classList.add("underlineAnnotation");
      return this.container;
    }
  }
  class SquigglyAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }
    render() {
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this.container.classList.add("squigglyAnnotation");
      return this.container;
    }
  }
  class StrikeOutAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true,
        createQuadrilaterals: true
      });
    }
    render() {
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this.container.classList.add("strikeoutAnnotation");
      return this.container;
    }
  }
  class StampAnnotationElement extends AnnotationElement {
    constructor(t2) {
      super(t2, {
        isRenderable: true,
        ignoreBorder: true
      });
      this.annotationEditorType = f.STAMP;
    }
    render() {
      this.container.classList.add("stampAnnotation");
      this.container.setAttribute("role", "img");
      !this.data.popupRef && this.hasPopupData && this._createPopup();
      this._editOnDoubleClick();
      return this.container;
    }
  }
  class FileAttachmentAnnotationElement extends AnnotationElement {
    constructor(t2) {
      var _a4;
      super(t2, {
        isRenderable: true
      });
      __privateAdd(this, _FileAttachmentAnnotationElement_instances);
      __privateAdd(this, _Zs, null);
      const { file: e2 } = this.data;
      this.filename = e2.filename;
      this.content = e2.content;
      (_a4 = this.linkService.eventBus) == null ? void 0 : _a4.dispatch("fileattachmentannotation", {
        source: this,
        ...e2
      });
    }
    render() {
      this.container.classList.add("fileAttachmentAnnotation");
      const { container: t2, data: e2 } = this;
      let i2;
      if (e2.hasAppearance || 0 === e2.fillAlpha) i2 = document.createElement("div");
      else {
        i2 = document.createElement("img");
        i2.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(e2.name) ? "paperclip" : "pushpin"}.svg`;
        e2.fillAlpha && e2.fillAlpha < 1 && (i2.style = `filter: opacity(${Math.round(100 * e2.fillAlpha)}%);`);
      }
      i2.addEventListener("dblclick", __privateMethod(this, _FileAttachmentAnnotationElement_instances, tn_fn).bind(this));
      __privateSet(this, _Zs, i2);
      const { isMac: s2 } = util_FeatureTest.platform;
      t2.addEventListener("keydown", (t3) => {
        "Enter" === t3.key && (s2 ? t3.metaKey : t3.ctrlKey) && __privateMethod(this, _FileAttachmentAnnotationElement_instances, tn_fn).call(this);
      });
      !e2.popupRef && this.hasPopupData ? this._createPopup() : i2.classList.add("popupTriggerArea");
      t2.append(i2);
      return t2;
    }
    getElementsToTriggerPopup() {
      return __privateGet(this, _Zs);
    }
    addHighlightArea() {
      this.container.classList.add("highlightArea");
    }
  }
  _Zs = new WeakMap();
  _FileAttachmentAnnotationElement_instances = new WeakSet();
  tn_fn = function() {
    var _a4;
    (_a4 = this.downloadManager) == null ? void 0 : _a4.openOrDownloadData(this.content, this.filename);
  };
  class AnnotationLayer {
    constructor({ div: t2, accessibilityManager: e2, annotationCanvasMap: i2, annotationEditorUIManager: s2, page: n2, viewport: r2, structTreeLayer: a2 }) {
      __privateAdd(this, _AnnotationLayer_instances);
      __privateAdd(this, _en, null);
      __privateAdd(this, _in, null);
      __privateAdd(this, _sn, /* @__PURE__ */ new Map());
      __privateAdd(this, _nn, null);
      this.div = t2;
      __privateSet(this, _en, e2);
      __privateSet(this, _in, i2);
      __privateSet(this, _nn, a2 || null);
      this.page = n2;
      this.viewport = r2;
      this.zIndex = 0;
      this._annotationEditorUIManager = s2;
    }
    hasEditableAnnotations() {
      return __privateGet(this, _sn).size > 0;
    }
    async render(t2) {
      var _a4;
      const { annotations: e2 } = t2, i2 = this.div;
      setLayerDimensions(i2, this.viewport);
      const s2 = /* @__PURE__ */ new Map(), n2 = {
        data: null,
        layer: i2,
        linkService: t2.linkService,
        downloadManager: t2.downloadManager,
        imageResourcesPath: t2.imageResourcesPath || "",
        renderForms: false !== t2.renderForms,
        svgFactory: new DOMSVGFactory(),
        annotationStorage: t2.annotationStorage || new AnnotationStorage(),
        enableScripting: true === t2.enableScripting,
        hasJSActions: t2.hasJSActions,
        fieldObjects: t2.fieldObjects,
        parent: this,
        elements: null
      };
      for (const t3 of e2) {
        if (t3.noHTML) continue;
        const e3 = t3.annotationType === z;
        if (e3) {
          const e4 = s2.get(t3.id);
          if (!e4) continue;
          n2.elements = e4;
        } else {
          const { width: e4, height: i4 } = getRectDims(t3.rect);
          if (e4 <= 0 || i4 <= 0) continue;
        }
        n2.data = t3;
        const i3 = AnnotationElementFactory.create(n2);
        if (!i3.isRenderable) continue;
        if (!e3 && t3.popupRef) {
          const e4 = s2.get(t3.popupRef);
          e4 ? e4.push(i3) : s2.set(t3.popupRef, [
            i3
          ]);
        }
        const r2 = i3.render();
        t3.hidden && (r2.style.visibility = "hidden");
        await __privateMethod(this, _AnnotationLayer_instances, rn_fn).call(this, r2, t3.id);
        if (i3._isEditable) {
          __privateGet(this, _sn).set(i3.data.id, i3);
          (_a4 = this._annotationEditorUIManager) == null ? void 0 : _a4.renderAnnotationElement(i3);
        }
      }
      __privateMethod(this, _AnnotationLayer_instances, an_fn).call(this);
    }
    update({ viewport: t2 }) {
      const e2 = this.div;
      this.viewport = t2;
      setLayerDimensions(e2, {
        rotation: t2.rotation
      });
      __privateMethod(this, _AnnotationLayer_instances, an_fn).call(this);
      e2.hidden = false;
    }
    getEditableAnnotations() {
      return Array.from(__privateGet(this, _sn).values());
    }
    getEditableAnnotation(t2) {
      return __privateGet(this, _sn).get(t2);
    }
  }
  _en = new WeakMap();
  _in = new WeakMap();
  _sn = new WeakMap();
  _nn = new WeakMap();
  _AnnotationLayer_instances = new WeakSet();
  rn_fn = async function(t2, e2) {
    var _a4, _b2;
    const i2 = t2.firstChild || t2, s2 = i2.id = `${st}${e2}`, n2 = await ((_a4 = __privateGet(this, _nn)) == null ? void 0 : _a4.getAriaAttributes(s2));
    if (n2) for (const [t3, e3] of n2) i2.setAttribute(t3, e3);
    this.div.append(t2);
    (_b2 = __privateGet(this, _en)) == null ? void 0 : _b2.moveElementInDOM(this.div, t2, i2, false);
  };
  an_fn = function() {
    if (!__privateGet(this, _in)) return;
    const t2 = this.div;
    for (const [e2, i2] of __privateGet(this, _in)) {
      const s2 = t2.querySelector(`[data-annotation-id="${e2}"]`);
      if (!s2) continue;
      i2.className = "annotationContent";
      const { firstChild: n2 } = s2;
      n2 ? "CANVAS" === n2.nodeName ? n2.replaceWith(i2) : n2.classList.contains("annotationContent") ? n2.after(i2) : n2.before(i2) : s2.append(i2);
    }
    __privateGet(this, _in).clear();
  };
  const Zt = /\r\n?|\n/g;
  const _FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
    constructor(t2) {
      super({
        ...t2,
        name: "freeTextEditor"
      });
      __privateAdd(this, _FreeTextEditor_instances);
      __privateAdd(this, _Rs2);
      __privateAdd(this, _on, "");
      __privateAdd(this, _ln, `${this.id}-editor`);
      __privateAdd(this, _hn, null);
      __privateAdd(this, _Gs);
      __privateSet(this, _Rs2, t2.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor);
      __privateSet(this, _Gs, t2.fontSize || _FreeTextEditor._defaultFontSize);
    }
    static get _keyboardManager() {
      const t2 = _FreeTextEditor.prototype, arrowChecker = (t3) => t3.isEmpty(), e2 = AnnotationEditorUIManager.TRANSLATE_SMALL, i2 = AnnotationEditorUIManager.TRANSLATE_BIG;
      return shadow(this, "_keyboardManager", new KeyboardManager([
        [
          [
            "ctrl+s",
            "mac+meta+s",
            "ctrl+p",
            "mac+meta+p"
          ],
          t2.commitOrRemove,
          {
            bubbles: true
          }
        ],
        [
          [
            "ctrl+Enter",
            "mac+meta+Enter",
            "Escape",
            "mac+Escape"
          ],
          t2.commitOrRemove
        ],
        [
          [
            "ArrowLeft",
            "mac+ArrowLeft"
          ],
          t2._translateEmpty,
          {
            args: [
              -e2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowLeft",
            "mac+shift+ArrowLeft"
          ],
          t2._translateEmpty,
          {
            args: [
              -i2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ArrowRight",
            "mac+ArrowRight"
          ],
          t2._translateEmpty,
          {
            args: [
              e2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowRight",
            "mac+shift+ArrowRight"
          ],
          t2._translateEmpty,
          {
            args: [
              i2,
              0
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ArrowUp",
            "mac+ArrowUp"
          ],
          t2._translateEmpty,
          {
            args: [
              0,
              -e2
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowUp",
            "mac+shift+ArrowUp"
          ],
          t2._translateEmpty,
          {
            args: [
              0,
              -i2
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ArrowDown",
            "mac+ArrowDown"
          ],
          t2._translateEmpty,
          {
            args: [
              0,
              e2
            ],
            checker: arrowChecker
          }
        ],
        [
          [
            "ctrl+ArrowDown",
            "mac+shift+ArrowDown"
          ],
          t2._translateEmpty,
          {
            args: [
              0,
              i2
            ],
            checker: arrowChecker
          }
        ]
      ]));
    }
    static initialize(t2, e2) {
      AnnotationEditor.initialize(t2, e2);
      const i2 = getComputedStyle(document.documentElement);
      this._internalPadding = parseFloat(i2.getPropertyValue("--freetext-padding"));
    }
    static updateDefaultParams(t2, e2) {
      switch (t2) {
        case m.FREETEXT_SIZE:
          _FreeTextEditor._defaultFontSize = e2;
          break;
        case m.FREETEXT_COLOR:
          _FreeTextEditor._defaultColor = e2;
      }
    }
    updateParams(t2, e2) {
      switch (t2) {
        case m.FREETEXT_SIZE:
          __privateMethod(this, _FreeTextEditor_instances, cn_fn).call(this, e2);
          break;
        case m.FREETEXT_COLOR:
          __privateMethod(this, _FreeTextEditor_instances, dn_fn).call(this, e2);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [
        [
          m.FREETEXT_SIZE,
          _FreeTextEditor._defaultFontSize
        ],
        [
          m.FREETEXT_COLOR,
          _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor
        ]
      ];
    }
    get propertiesToUpdate() {
      return [
        [
          m.FREETEXT_SIZE,
          __privateGet(this, _Gs)
        ],
        [
          m.FREETEXT_COLOR,
          __privateGet(this, _Rs2)
        ]
      ];
    }
    _translateEmpty(t2, e2) {
      this._uiManager.translateSelectedEditors(t2, e2, true);
    }
    getInitialTranslation() {
      const t2 = this.parentScale;
      return [
        -_FreeTextEditor._internalPadding * t2,
        -(_FreeTextEditor._internalPadding + __privateGet(this, _Gs)) * t2
      ];
    }
    rebuild() {
      if (this.parent) {
        super.rebuild();
        null !== this.div && (this.isAttachedToDOM || this.parent.add(this));
      }
    }
    enableEditMode() {
      if (this.isInEditMode()) return;
      this.parent.setEditingState(false);
      this.parent.updateToolbar(f.FREETEXT);
      super.enableEditMode();
      this.overlayDiv.classList.remove("enabled");
      this.editorDiv.contentEditable = true;
      this._isDraggable = false;
      this.div.removeAttribute("aria-activedescendant");
      __privateSet(this, _hn, new AbortController());
      const t2 = this._uiManager.combinedSignal(__privateGet(this, _hn));
      this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
        signal: t2
      });
      this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
        signal: t2
      });
      this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
        signal: t2
      });
      this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
        signal: t2
      });
      this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
        signal: t2
      });
    }
    disableEditMode() {
      var _a4;
      if (this.isInEditMode()) {
        this.parent.setEditingState(true);
        super.disableEditMode();
        this.overlayDiv.classList.add("enabled");
        this.editorDiv.contentEditable = false;
        this.div.setAttribute("aria-activedescendant", __privateGet(this, _ln));
        this._isDraggable = true;
        (_a4 = __privateGet(this, _hn)) == null ? void 0 : _a4.abort();
        __privateSet(this, _hn, null);
        this.div.focus({
          preventScroll: true
        });
        this.isEditing = false;
        this.parent.div.classList.add("freetextEditing");
      }
    }
    focusin(t2) {
      if (this._focusEventsAllowed) {
        super.focusin(t2);
        t2.target !== this.editorDiv && this.editorDiv.focus();
      }
    }
    onceAdded() {
      var _a4;
      if (!this.width) {
        this.enableEditMode();
        this.editorDiv.focus();
        ((_a4 = this._initialOptions) == null ? void 0 : _a4.isCentered) && this.center();
        this._initialOptions = null;
      }
    }
    isEmpty() {
      return !this.editorDiv || "" === this.editorDiv.innerText.trim();
    }
    remove() {
      this.isEditing = false;
      if (this.parent) {
        this.parent.setEditingState(true);
        this.parent.div.classList.add("freetextEditing");
      }
      super.remove();
    }
    commit() {
      if (!this.isInEditMode()) return;
      super.commit();
      this.disableEditMode();
      const t2 = __privateGet(this, _on), e2 = __privateSet(this, _on, __privateMethod(this, _FreeTextEditor_instances, pn_fn).call(this).trimEnd());
      if (t2 === e2) return;
      const setText = (t3) => {
        __privateSet(this, _on, t3);
        if (t3) {
          __privateMethod(this, _FreeTextEditor_instances, fn_fn).call(this);
          this._uiManager.rebuild(this);
          __privateMethod(this, _FreeTextEditor_instances, un_fn).call(this);
        } else this.remove();
      };
      this.addCommands({
        cmd: () => {
          setText(e2);
        },
        undo: () => {
          setText(t2);
        },
        mustExec: false
      });
      __privateMethod(this, _FreeTextEditor_instances, un_fn).call(this);
    }
    shouldGetKeyboardEvents() {
      return this.isInEditMode();
    }
    enterInEditMode() {
      this.enableEditMode();
      this.editorDiv.focus();
    }
    dblclick(t2) {
      this.enterInEditMode();
    }
    keydown(t2) {
      if (t2.target === this.div && "Enter" === t2.key) {
        this.enterInEditMode();
        t2.preventDefault();
      }
    }
    editorDivKeydown(t2) {
      _FreeTextEditor._keyboardManager.exec(this, t2);
    }
    editorDivFocus(t2) {
      this.isEditing = true;
    }
    editorDivBlur(t2) {
      this.isEditing = false;
    }
    editorDivInput(t2) {
      this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
    }
    disableEditing() {
      this.editorDiv.setAttribute("role", "comment");
      this.editorDiv.removeAttribute("aria-multiline");
    }
    enableEditing() {
      this.editorDiv.setAttribute("role", "textbox");
      this.editorDiv.setAttribute("aria-multiline", true);
    }
    render() {
      if (this.div) return this.div;
      let t2, e2;
      if (this.width) {
        t2 = this.x;
        e2 = this.y;
      }
      super.render();
      this.editorDiv = document.createElement("div");
      this.editorDiv.className = "internal";
      this.editorDiv.setAttribute("id", __privateGet(this, _ln));
      this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
      this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
      this.enableEditing();
      this.editorDiv.contentEditable = true;
      const { style: i2 } = this.editorDiv;
      i2.fontSize = `calc(${__privateGet(this, _Gs)}px * var(--scale-factor))`;
      i2.color = __privateGet(this, _Rs2);
      this.div.append(this.editorDiv);
      this.overlayDiv = document.createElement("div");
      this.overlayDiv.classList.add("overlay", "enabled");
      this.div.append(this.overlayDiv);
      bindEvents(this, this.div, [
        "dblclick",
        "keydown"
      ]);
      if (this.width) {
        const [i3, s2] = this.parentDimensions;
        if (this.annotationElementId) {
          const { position: n2 } = this._initialData;
          let [r2, a2] = this.getInitialTranslation();
          [r2, a2] = this.pageTranslationToScreen(r2, a2);
          const [o2, l2] = this.pageDimensions, [h2, c2] = this.pageTranslation;
          let d2, u2;
          switch (this.rotation) {
            case 0:
              d2 = t2 + (n2[0] - h2) / o2;
              u2 = e2 + this.height - (n2[1] - c2) / l2;
              break;
            case 90:
              d2 = t2 + (n2[0] - h2) / o2;
              u2 = e2 - (n2[1] - c2) / l2;
              [r2, a2] = [
                a2,
                -r2
              ];
              break;
            case 180:
              d2 = t2 - this.width + (n2[0] - h2) / o2;
              u2 = e2 - (n2[1] - c2) / l2;
              [r2, a2] = [
                -r2,
                -a2
              ];
              break;
            case 270:
              d2 = t2 + (n2[0] - h2 - this.height * l2) / o2;
              u2 = e2 + (n2[1] - c2 - this.width * o2) / l2;
              [r2, a2] = [
                -a2,
                r2
              ];
          }
          this.setAt(d2 * i3, u2 * s2, r2, a2);
        } else this.setAt(t2 * i3, e2 * s2, this.width * i3, this.height * s2);
        __privateMethod(this, _FreeTextEditor_instances, fn_fn).call(this);
        this._isDraggable = true;
        this.editorDiv.contentEditable = false;
      } else {
        this._isDraggable = false;
        this.editorDiv.contentEditable = true;
      }
      return this.div;
    }
    editorDivPaste(t2) {
      var _a4, _b2, _c;
      const e2 = t2.clipboardData || window.clipboardData, { types: i2 } = e2;
      if (1 === i2.length && "text/plain" === i2[0]) return;
      t2.preventDefault();
      const s2 = __privateMethod(_a4 = _FreeTextEditor, _FreeTextEditor_static, mn_fn).call(_a4, e2.getData("text") || "").replaceAll(Zt, "\n");
      if (!s2) return;
      const n2 = window.getSelection();
      if (!n2.rangeCount) return;
      this.editorDiv.normalize();
      n2.deleteFromDocument();
      const r2 = n2.getRangeAt(0);
      if (!s2.includes("\n")) {
        r2.insertNode(document.createTextNode(s2));
        this.editorDiv.normalize();
        n2.collapseToStart();
        return;
      }
      const { startContainer: a2, startOffset: o2 } = r2, l2 = [], h2 = [];
      if (a2.nodeType === Node.TEXT_NODE) {
        const t3 = a2.parentElement;
        h2.push(a2.nodeValue.slice(o2).replaceAll(Zt, ""));
        if (t3 !== this.editorDiv) {
          let e3 = l2;
          for (const i3 of this.editorDiv.childNodes) i3 !== t3 ? e3.push(__privateMethod(_b2 = _FreeTextEditor, _FreeTextEditor_static, gn_fn).call(_b2, i3)) : e3 = h2;
        }
        l2.push(a2.nodeValue.slice(0, o2).replaceAll(Zt, ""));
      } else if (a2 === this.editorDiv) {
        let t3 = l2, e3 = 0;
        for (const i3 of this.editorDiv.childNodes) {
          e3++ === o2 && (t3 = h2);
          t3.push(__privateMethod(_c = _FreeTextEditor, _FreeTextEditor_static, gn_fn).call(_c, i3));
        }
      }
      __privateSet(this, _on, `${l2.join("\n")}${s2}${h2.join("\n")}`);
      __privateMethod(this, _FreeTextEditor_instances, fn_fn).call(this);
      const c2 = new Range();
      let d2 = l2.reduce((t3, e3) => t3 + e3.length, 0);
      for (const { firstChild: t3 } of this.editorDiv.childNodes) if (t3.nodeType === Node.TEXT_NODE) {
        const e3 = t3.nodeValue.length;
        if (d2 <= e3) {
          c2.setStart(t3, d2);
          c2.setEnd(t3, d2);
          break;
        }
        d2 -= e3;
      }
      n2.removeAllRanges();
      n2.addRange(c2);
    }
    get contentDiv() {
      return this.editorDiv;
    }
    static async deserialize(t2, e2, i2) {
      var _a4;
      let s2 = null;
      if (t2 instanceof FreeTextAnnotationElement) {
        const { data: { defaultAppearanceData: { fontSize: e3, fontColor: i3 }, rect: n3, rotation: r2, id: a2, popupRef: o2 }, textContent: l2, textPosition: h2, parent: { page: { pageNumber: c2 } } } = t2;
        if (!l2 || 0 === l2.length) return null;
        s2 = t2 = {
          annotationType: f.FREETEXT,
          color: Array.from(i3),
          fontSize: e3,
          value: l2.join("\n"),
          position: h2,
          pageIndex: c2 - 1,
          rect: n3.slice(0),
          rotation: r2,
          id: a2,
          deleted: false,
          popupRef: o2
        };
      }
      const n2 = await super.deserialize(t2, e2, i2);
      __privateSet(n2, _Gs, t2.fontSize);
      __privateSet(n2, _Rs2, Util.makeHexColor(...t2.color));
      __privateSet(n2, _on, __privateMethod(_a4 = _FreeTextEditor, _FreeTextEditor_static, mn_fn).call(_a4, t2.value));
      n2.annotationElementId = t2.id || null;
      n2._initialData = s2;
      return n2;
    }
    serialize(t2 = false) {
      if (this.isEmpty()) return null;
      if (this.deleted) return this.serializeDeleted();
      const e2 = _FreeTextEditor._internalPadding * this.parentScale, i2 = this.getRect(e2, e2), s2 = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : __privateGet(this, _Rs2)), n2 = {
        annotationType: f.FREETEXT,
        color: s2,
        fontSize: __privateGet(this, _Gs),
        value: __privateMethod(this, _FreeTextEditor_instances, bn_fn).call(this),
        pageIndex: this.pageIndex,
        rect: i2,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
      if (t2) return n2;
      if (this.annotationElementId && !__privateMethod(this, _FreeTextEditor_instances, vn_fn).call(this, n2)) return null;
      n2.id = this.annotationElementId;
      return n2;
    }
    renderAnnotationElement(t2) {
      const e2 = super.renderAnnotationElement(t2);
      if (this.deleted) return e2;
      const { style: i2 } = e2;
      i2.fontSize = `calc(${__privateGet(this, _Gs)}px * var(--scale-factor))`;
      i2.color = __privateGet(this, _Rs2);
      e2.replaceChildren();
      for (const t3 of __privateGet(this, _on).split("\n")) {
        const i3 = document.createElement("div");
        i3.append(t3 ? document.createTextNode(t3) : document.createElement("br"));
        e2.append(i3);
      }
      const s2 = _FreeTextEditor._internalPadding * this.parentScale;
      t2.updateEdited({
        rect: this.getRect(s2, s2),
        popupContent: __privateGet(this, _on)
      });
      return e2;
    }
    resetAnnotationElement(t2) {
      super.resetAnnotationElement(t2);
      t2.resetEdited();
    }
  };
  _Rs2 = new WeakMap();
  _on = new WeakMap();
  _ln = new WeakMap();
  _hn = new WeakMap();
  _Gs = new WeakMap();
  _FreeTextEditor_instances = new WeakSet();
  cn_fn = function(t2) {
    const setFontsize = (t3) => {
      this.editorDiv.style.fontSize = `calc(${t3}px * var(--scale-factor))`;
      this.translate(0, -(t3 - __privateGet(this, _Gs)) * this.parentScale);
      __privateSet(this, _Gs, t3);
      __privateMethod(this, _FreeTextEditor_instances, un_fn).call(this);
    }, e2 = __privateGet(this, _Gs);
    this.addCommands({
      cmd: setFontsize.bind(this, t2),
      undo: setFontsize.bind(this, e2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.FREETEXT_SIZE,
      overwriteIfSameType: true,
      keepUndo: true
    });
  };
  dn_fn = function(t2) {
    const setColor = (t3) => {
      __privateSet(this, _Rs2, this.editorDiv.style.color = t3);
    }, e2 = __privateGet(this, _Rs2);
    this.addCommands({
      cmd: setColor.bind(this, t2),
      undo: setColor.bind(this, e2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.FREETEXT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  };
  pn_fn = function() {
    var _a4;
    const t2 = [];
    this.editorDiv.normalize();
    let e2 = null;
    for (const i2 of this.editorDiv.childNodes) if ((e2 == null ? void 0 : e2.nodeType) !== Node.TEXT_NODE || "BR" !== i2.nodeName) {
      t2.push(__privateMethod(_a4 = _FreeTextEditor, _FreeTextEditor_static, gn_fn).call(_a4, i2));
      e2 = i2;
    }
    return t2.join("\n");
  };
  un_fn = function() {
    const [t2, e2] = this.parentDimensions;
    let i2;
    if (this.isAttachedToDOM) i2 = this.div.getBoundingClientRect();
    else {
      const { currentLayer: t3, div: e3 } = this, s2 = e3.style.display, n2 = e3.classList.contains("hidden");
      e3.classList.remove("hidden");
      e3.style.display = "hidden";
      t3.div.append(this.div);
      i2 = e3.getBoundingClientRect();
      e3.remove();
      e3.style.display = s2;
      e3.classList.toggle("hidden", n2);
    }
    if (this.rotation % 180 == this.parentRotation % 180) {
      this.width = i2.width / t2;
      this.height = i2.height / e2;
    } else {
      this.width = i2.height / t2;
      this.height = i2.width / e2;
    }
    this.fixAndSetPosition();
  };
  _FreeTextEditor_static = new WeakSet();
  gn_fn = function(t2) {
    return (t2.nodeType === Node.TEXT_NODE ? t2.nodeValue : t2.innerText).replaceAll(Zt, "");
  };
  fn_fn = function() {
    this.editorDiv.replaceChildren();
    if (__privateGet(this, _on)) for (const t2 of __privateGet(this, _on).split("\n")) {
      const e2 = document.createElement("div");
      e2.append(t2 ? document.createTextNode(t2) : document.createElement("br"));
      this.editorDiv.append(e2);
    }
  };
  bn_fn = function() {
    return __privateGet(this, _on).replaceAll("\xA0", " ");
  };
  mn_fn = function(t2) {
    return t2.replaceAll(" ", "\xA0");
  };
  vn_fn = function(t2) {
    const { value: e2, fontSize: i2, color: s2, pageIndex: n2 } = this._initialData;
    return this._hasBeenMoved || t2.value !== e2 || t2.fontSize !== i2 || t2.color.some((t3, e3) => t3 !== s2[e3]) || t2.pageIndex !== n2;
  };
  __privateAdd(_FreeTextEditor, _FreeTextEditor_static);
  __publicField(_FreeTextEditor, "_freeTextDefaultContent", "");
  __publicField(_FreeTextEditor, "_internalPadding", 0);
  __publicField(_FreeTextEditor, "_defaultColor", null);
  __publicField(_FreeTextEditor, "_defaultFontSize", 10);
  __publicField(_FreeTextEditor, "_type", "freetext");
  __publicField(_FreeTextEditor, "_editorType", f.FREETEXT);
  let FreeTextEditor = _FreeTextEditor;
  class Outline {
    toSVGPath() {
      unreachable("Abstract method `toSVGPath` must be implemented.");
    }
    get box() {
      unreachable("Abstract getter `box` must be implemented.");
    }
    serialize(t2, e2) {
      unreachable("Abstract method `serialize` must be implemented.");
    }
    get classNamesForDrawing() {
      unreachable("Abstract getter `classNamesForDrawing` must be implemented.");
    }
    get classNamesForOutlining() {
      unreachable("Abstract getter `classNamesForOutlining` must be implemented.");
    }
    get mustRemoveSelfIntersections() {
      return false;
    }
  }
  const _FreeDrawOutliner = class _FreeDrawOutliner {
    constructor({ x: t2, y: e2 }, i2, s2, n2, r2, a2 = 0) {
      __privateAdd(this, _FreeDrawOutliner_instances);
      __privateAdd(this, _yn);
      __privateAdd(this, _An, []);
      __privateAdd(this, _wn);
      __privateAdd(this, _xn);
      __privateAdd(this, __n, []);
      __privateAdd(this, _En, new Float64Array(18));
      __privateAdd(this, _Cn);
      __privateAdd(this, _Sn);
      __privateAdd(this, _Tn);
      __privateAdd(this, _Mn);
      __privateAdd(this, _kn);
      __privateAdd(this, _Pn);
      __privateAdd(this, _Rn, []);
      __privateSet(this, _yn, i2);
      __privateSet(this, _Pn, n2 * s2);
      __privateSet(this, _xn, r2);
      __privateGet(this, _En).set([
        NaN,
        NaN,
        NaN,
        NaN,
        t2,
        e2
      ], 6);
      __privateSet(this, _wn, a2);
      __privateSet(this, _Mn, __privateGet(_FreeDrawOutliner, _Dn) * s2);
      __privateSet(this, _Tn, __privateGet(_FreeDrawOutliner, _Fn) * s2);
      __privateSet(this, _kn, s2);
      __privateGet(this, _Rn).push(t2, e2);
    }
    isEmpty() {
      return isNaN(__privateGet(this, _En)[8]);
    }
    add({ x: t2, y: e2 }) {
      var _a4;
      __privateSet(this, _Cn, t2);
      __privateSet(this, _Sn, e2);
      const [i2, s2, n2, r2] = __privateGet(this, _yn);
      let [a2, o2, l2, h2] = __privateGet(this, _En).subarray(8, 12);
      const c2 = t2 - l2, d2 = e2 - h2, u2 = Math.hypot(c2, d2);
      if (u2 < __privateGet(this, _Tn)) return false;
      const p2 = u2 - __privateGet(this, _Mn), g2 = p2 / u2, f2 = g2 * c2, m2 = g2 * d2;
      let b2 = a2, v2 = o2;
      a2 = l2;
      o2 = h2;
      l2 += f2;
      h2 += m2;
      (_a4 = __privateGet(this, _Rn)) == null ? void 0 : _a4.push(t2, e2);
      const y2 = f2 / p2, A2 = -m2 / p2 * __privateGet(this, _Pn), w2 = y2 * __privateGet(this, _Pn);
      __privateGet(this, _En).set(__privateGet(this, _En).subarray(2, 8), 0);
      __privateGet(this, _En).set([
        l2 + A2,
        h2 + w2
      ], 4);
      __privateGet(this, _En).set(__privateGet(this, _En).subarray(14, 18), 12);
      __privateGet(this, _En).set([
        l2 - A2,
        h2 - w2
      ], 16);
      if (isNaN(__privateGet(this, _En)[6])) {
        if (0 === __privateGet(this, __n).length) {
          __privateGet(this, _En).set([
            a2 + A2,
            o2 + w2
          ], 2);
          __privateGet(this, __n).push(NaN, NaN, NaN, NaN, (a2 + A2 - i2) / n2, (o2 + w2 - s2) / r2);
          __privateGet(this, _En).set([
            a2 - A2,
            o2 - w2
          ], 14);
          __privateGet(this, _An).push(NaN, NaN, NaN, NaN, (a2 - A2 - i2) / n2, (o2 - w2 - s2) / r2);
        }
        __privateGet(this, _En).set([
          b2,
          v2,
          a2,
          o2,
          l2,
          h2
        ], 6);
        return !this.isEmpty();
      }
      __privateGet(this, _En).set([
        b2,
        v2,
        a2,
        o2,
        l2,
        h2
      ], 6);
      if (Math.abs(Math.atan2(v2 - o2, b2 - a2) - Math.atan2(m2, f2)) < Math.PI / 2) {
        [a2, o2, l2, h2] = __privateGet(this, _En).subarray(2, 6);
        __privateGet(this, __n).push(NaN, NaN, NaN, NaN, ((a2 + l2) / 2 - i2) / n2, ((o2 + h2) / 2 - s2) / r2);
        [a2, o2, b2, v2] = __privateGet(this, _En).subarray(14, 18);
        __privateGet(this, _An).push(NaN, NaN, NaN, NaN, ((b2 + a2) / 2 - i2) / n2, ((v2 + o2) / 2 - s2) / r2);
        return true;
      }
      [b2, v2, a2, o2, l2, h2] = __privateGet(this, _En).subarray(0, 6);
      __privateGet(this, __n).push(((b2 + 5 * a2) / 6 - i2) / n2, ((v2 + 5 * o2) / 6 - s2) / r2, ((5 * a2 + l2) / 6 - i2) / n2, ((5 * o2 + h2) / 6 - s2) / r2, ((a2 + l2) / 2 - i2) / n2, ((o2 + h2) / 2 - s2) / r2);
      [l2, h2, a2, o2, b2, v2] = __privateGet(this, _En).subarray(12, 18);
      __privateGet(this, _An).push(((b2 + 5 * a2) / 6 - i2) / n2, ((v2 + 5 * o2) / 6 - s2) / r2, ((5 * a2 + l2) / 6 - i2) / n2, ((5 * o2 + h2) / 6 - s2) / r2, ((a2 + l2) / 2 - i2) / n2, ((o2 + h2) / 2 - s2) / r2);
      return true;
    }
    toSVGPath() {
      if (this.isEmpty()) return "";
      const t2 = __privateGet(this, __n), e2 = __privateGet(this, _An);
      if (isNaN(__privateGet(this, _En)[6]) && !this.isEmpty()) return __privateMethod(this, _FreeDrawOutliner_instances, On_fn).call(this);
      const i2 = [];
      i2.push(`M${t2[4]} ${t2[5]}`);
      for (let e3 = 6; e3 < t2.length; e3 += 6) isNaN(t2[e3]) ? i2.push(`L${t2[e3 + 4]} ${t2[e3 + 5]}`) : i2.push(`C${t2[e3]} ${t2[e3 + 1]} ${t2[e3 + 2]} ${t2[e3 + 3]} ${t2[e3 + 4]} ${t2[e3 + 5]}`);
      __privateMethod(this, _FreeDrawOutliner_instances, Nn_fn).call(this, i2);
      for (let t3 = e2.length - 6; t3 >= 6; t3 -= 6) isNaN(e2[t3]) ? i2.push(`L${e2[t3 + 4]} ${e2[t3 + 5]}`) : i2.push(`C${e2[t3]} ${e2[t3 + 1]} ${e2[t3 + 2]} ${e2[t3 + 3]} ${e2[t3 + 4]} ${e2[t3 + 5]}`);
      __privateMethod(this, _FreeDrawOutliner_instances, Bn_fn).call(this, i2);
      return i2.join(" ");
    }
    newFreeDrawOutline(t2, e2, i2, s2, n2, r2) {
      return new FreeDrawOutline(t2, e2, i2, s2, n2, r2);
    }
    getOutlines() {
      var _a4;
      const t2 = __privateGet(this, __n), e2 = __privateGet(this, _An), i2 = __privateGet(this, _En), [s2, n2, r2, a2] = __privateGet(this, _yn), o2 = new Float64Array((((_a4 = __privateGet(this, _Rn)) == null ? void 0 : _a4.length) ?? 0) + 2);
      for (let t3 = 0, e3 = o2.length - 2; t3 < e3; t3 += 2) {
        o2[t3] = (__privateGet(this, _Rn)[t3] - s2) / r2;
        o2[t3 + 1] = (__privateGet(this, _Rn)[t3 + 1] - n2) / a2;
      }
      o2[o2.length - 2] = (__privateGet(this, _Cn) - s2) / r2;
      o2[o2.length - 1] = (__privateGet(this, _Sn) - n2) / a2;
      if (isNaN(i2[6]) && !this.isEmpty()) return __privateMethod(this, _FreeDrawOutliner_instances, Hn_fn).call(this, o2);
      const l2 = new Float64Array(__privateGet(this, __n).length + 24 + __privateGet(this, _An).length);
      let h2 = t2.length;
      for (let e3 = 0; e3 < h2; e3 += 2) if (isNaN(t2[e3])) l2[e3] = l2[e3 + 1] = NaN;
      else {
        l2[e3] = t2[e3];
        l2[e3 + 1] = t2[e3 + 1];
      }
      h2 = __privateMethod(this, _FreeDrawOutliner_instances, Un_fn).call(this, l2, h2);
      for (let t3 = e2.length - 6; t3 >= 6; t3 -= 6) for (let i3 = 0; i3 < 6; i3 += 2) if (isNaN(e2[t3 + i3])) {
        l2[h2] = l2[h2 + 1] = NaN;
        h2 += 2;
      } else {
        l2[h2] = e2[t3 + i3];
        l2[h2 + 1] = e2[t3 + i3 + 1];
        h2 += 2;
      }
      __privateMethod(this, _FreeDrawOutliner_instances, zn_fn).call(this, l2, h2);
      return this.newFreeDrawOutline(l2, o2, __privateGet(this, _yn), __privateGet(this, _kn), __privateGet(this, _wn), __privateGet(this, _xn));
    }
  };
  _yn = new WeakMap();
  _An = new WeakMap();
  _wn = new WeakMap();
  _xn = new WeakMap();
  __n = new WeakMap();
  _En = new WeakMap();
  _Cn = new WeakMap();
  _Sn = new WeakMap();
  _Tn = new WeakMap();
  _Mn = new WeakMap();
  _kn = new WeakMap();
  _Pn = new WeakMap();
  _Rn = new WeakMap();
  _Dn = new WeakMap();
  _In = new WeakMap();
  _Fn = new WeakMap();
  _FreeDrawOutliner_instances = new WeakSet();
  Ln_fn = function() {
    const t2 = __privateGet(this, _En).subarray(4, 6), e2 = __privateGet(this, _En).subarray(16, 18), [i2, s2, n2, r2] = __privateGet(this, _yn);
    return [
      (__privateGet(this, _Cn) + (t2[0] - e2[0]) / 2 - i2) / n2,
      (__privateGet(this, _Sn) + (t2[1] - e2[1]) / 2 - s2) / r2,
      (__privateGet(this, _Cn) + (e2[0] - t2[0]) / 2 - i2) / n2,
      (__privateGet(this, _Sn) + (e2[1] - t2[1]) / 2 - s2) / r2
    ];
  };
  On_fn = function() {
    const [t2, e2, i2, s2] = __privateGet(this, _yn), [n2, r2, a2, o2] = __privateMethod(this, _FreeDrawOutliner_instances, Ln_fn).call(this);
    return `M${(__privateGet(this, _En)[2] - t2) / i2} ${(__privateGet(this, _En)[3] - e2) / s2} L${(__privateGet(this, _En)[4] - t2) / i2} ${(__privateGet(this, _En)[5] - e2) / s2} L${n2} ${r2} L${a2} ${o2} L${(__privateGet(this, _En)[16] - t2) / i2} ${(__privateGet(this, _En)[17] - e2) / s2} L${(__privateGet(this, _En)[14] - t2) / i2} ${(__privateGet(this, _En)[15] - e2) / s2} Z`;
  };
  Bn_fn = function(t2) {
    const e2 = __privateGet(this, _An);
    t2.push(`L${e2[4]} ${e2[5]} Z`);
  };
  Nn_fn = function(t2) {
    const [e2, i2, s2, n2] = __privateGet(this, _yn), r2 = __privateGet(this, _En).subarray(4, 6), a2 = __privateGet(this, _En).subarray(16, 18), [o2, l2, h2, c2] = __privateMethod(this, _FreeDrawOutliner_instances, Ln_fn).call(this);
    t2.push(`L${(r2[0] - e2) / s2} ${(r2[1] - i2) / n2} L${o2} ${l2} L${h2} ${c2} L${(a2[0] - e2) / s2} ${(a2[1] - i2) / n2}`);
  };
  Hn_fn = function(t2) {
    const e2 = __privateGet(this, _En), [i2, s2, n2, r2] = __privateGet(this, _yn), [a2, o2, l2, h2] = __privateMethod(this, _FreeDrawOutliner_instances, Ln_fn).call(this), c2 = new Float64Array(36);
    c2.set([
      NaN,
      NaN,
      NaN,
      NaN,
      (e2[2] - i2) / n2,
      (e2[3] - s2) / r2,
      NaN,
      NaN,
      NaN,
      NaN,
      (e2[4] - i2) / n2,
      (e2[5] - s2) / r2,
      NaN,
      NaN,
      NaN,
      NaN,
      a2,
      o2,
      NaN,
      NaN,
      NaN,
      NaN,
      l2,
      h2,
      NaN,
      NaN,
      NaN,
      NaN,
      (e2[16] - i2) / n2,
      (e2[17] - s2) / r2,
      NaN,
      NaN,
      NaN,
      NaN,
      (e2[14] - i2) / n2,
      (e2[15] - s2) / r2
    ], 0);
    return this.newFreeDrawOutline(c2, t2, __privateGet(this, _yn), __privateGet(this, _kn), __privateGet(this, _wn), __privateGet(this, _xn));
  };
  zn_fn = function(t2, e2) {
    const i2 = __privateGet(this, _An);
    t2.set([
      NaN,
      NaN,
      NaN,
      NaN,
      i2[4],
      i2[5]
    ], e2);
    return e2 + 6;
  };
  Un_fn = function(t2, e2) {
    const i2 = __privateGet(this, _En).subarray(4, 6), s2 = __privateGet(this, _En).subarray(16, 18), [n2, r2, a2, o2] = __privateGet(this, _yn), [l2, h2, c2, d2] = __privateMethod(this, _FreeDrawOutliner_instances, Ln_fn).call(this);
    t2.set([
      NaN,
      NaN,
      NaN,
      NaN,
      (i2[0] - n2) / a2,
      (i2[1] - r2) / o2,
      NaN,
      NaN,
      NaN,
      NaN,
      l2,
      h2,
      NaN,
      NaN,
      NaN,
      NaN,
      c2,
      d2,
      NaN,
      NaN,
      NaN,
      NaN,
      (s2[0] - n2) / a2,
      (s2[1] - r2) / o2
    ], e2);
    return e2 + 24;
  };
  __privateAdd(_FreeDrawOutliner, _Dn, 8);
  __privateAdd(_FreeDrawOutliner, _In, 2);
  __privateAdd(_FreeDrawOutliner, _Fn, __privateGet(_FreeDrawOutliner, _Dn) + __privateGet(_FreeDrawOutliner, _In));
  let FreeDrawOutliner = _FreeDrawOutliner;
  class FreeDrawOutline extends Outline {
    constructor(t2, e2, i2, s2, n2, r2) {
      super();
      __privateAdd(this, _FreeDrawOutline_instances);
      __privateAdd(this, _yn2);
      __privateAdd(this, _jn, null);
      __privateAdd(this, _wn2);
      __privateAdd(this, _xn2);
      __privateAdd(this, _Rn2);
      __privateAdd(this, _kn2);
      __privateAdd(this, _Wn);
      __privateSet(this, _Wn, t2);
      __privateSet(this, _Rn2, e2);
      __privateSet(this, _yn2, i2);
      __privateSet(this, _kn2, s2);
      __privateSet(this, _wn2, n2);
      __privateSet(this, _xn2, r2);
      __privateMethod(this, _FreeDrawOutline_instances, Gn_fn).call(this, r2);
      const { x: a2, y: o2, width: l2, height: h2 } = __privateGet(this, _jn);
      for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
        t2[e3] = (t2[e3] - a2) / l2;
        t2[e3 + 1] = (t2[e3 + 1] - o2) / h2;
      }
      for (let t3 = 0, i3 = e2.length; t3 < i3; t3 += 2) {
        e2[t3] = (e2[t3] - a2) / l2;
        e2[t3 + 1] = (e2[t3 + 1] - o2) / h2;
      }
    }
    toSVGPath() {
      const t2 = [
        `M${__privateGet(this, _Wn)[4]} ${__privateGet(this, _Wn)[5]}`
      ];
      for (let e2 = 6, i2 = __privateGet(this, _Wn).length; e2 < i2; e2 += 6) isNaN(__privateGet(this, _Wn)[e2]) ? t2.push(`L${__privateGet(this, _Wn)[e2 + 4]} ${__privateGet(this, _Wn)[e2 + 5]}`) : t2.push(`C${__privateGet(this, _Wn)[e2]} ${__privateGet(this, _Wn)[e2 + 1]} ${__privateGet(this, _Wn)[e2 + 2]} ${__privateGet(this, _Wn)[e2 + 3]} ${__privateGet(this, _Wn)[e2 + 4]} ${__privateGet(this, _Wn)[e2 + 5]}`);
      t2.push("Z");
      return t2.join(" ");
    }
    serialize([t2, e2, i2, s2], n2) {
      const r2 = i2 - t2, a2 = s2 - e2;
      let o2, l2;
      switch (n2) {
        case 0:
          o2 = __privateMethod(this, _FreeDrawOutline_instances, Vn_fn).call(this, __privateGet(this, _Wn), t2, s2, r2, -a2);
          l2 = __privateMethod(this, _FreeDrawOutline_instances, Vn_fn).call(this, __privateGet(this, _Rn2), t2, s2, r2, -a2);
          break;
        case 90:
          o2 = __privateMethod(this, _FreeDrawOutline_instances, $n_fn).call(this, __privateGet(this, _Wn), t2, e2, r2, a2);
          l2 = __privateMethod(this, _FreeDrawOutline_instances, $n_fn).call(this, __privateGet(this, _Rn2), t2, e2, r2, a2);
          break;
        case 180:
          o2 = __privateMethod(this, _FreeDrawOutline_instances, Vn_fn).call(this, __privateGet(this, _Wn), i2, e2, -r2, a2);
          l2 = __privateMethod(this, _FreeDrawOutline_instances, Vn_fn).call(this, __privateGet(this, _Rn2), i2, e2, -r2, a2);
          break;
        case 270:
          o2 = __privateMethod(this, _FreeDrawOutline_instances, $n_fn).call(this, __privateGet(this, _Wn), i2, s2, -r2, -a2);
          l2 = __privateMethod(this, _FreeDrawOutline_instances, $n_fn).call(this, __privateGet(this, _Rn2), i2, s2, -r2, -a2);
      }
      return {
        outline: Array.from(o2),
        points: [
          Array.from(l2)
        ]
      };
    }
    get box() {
      return __privateGet(this, _jn);
    }
    newOutliner(t2, e2, i2, s2, n2, r2 = 0) {
      return new FreeDrawOutliner(t2, e2, i2, s2, n2, r2);
    }
    getNewOutline(t2, e2) {
      const { x: i2, y: s2, width: n2, height: r2 } = __privateGet(this, _jn), [a2, o2, l2, h2] = __privateGet(this, _yn2), c2 = n2 * l2, d2 = r2 * h2, u2 = i2 * l2 + a2, p2 = s2 * h2 + o2, g2 = this.newOutliner({
        x: __privateGet(this, _Rn2)[0] * c2 + u2,
        y: __privateGet(this, _Rn2)[1] * d2 + p2
      }, __privateGet(this, _yn2), __privateGet(this, _kn2), t2, __privateGet(this, _xn2), e2 ?? __privateGet(this, _wn2));
      for (let t3 = 2; t3 < __privateGet(this, _Rn2).length; t3 += 2) g2.add({
        x: __privateGet(this, _Rn2)[t3] * c2 + u2,
        y: __privateGet(this, _Rn2)[t3 + 1] * d2 + p2
      });
      return g2.getOutlines();
    }
    get mustRemoveSelfIntersections() {
      return true;
    }
  }
  _yn2 = new WeakMap();
  _jn = new WeakMap();
  _wn2 = new WeakMap();
  _xn2 = new WeakMap();
  _Rn2 = new WeakMap();
  _kn2 = new WeakMap();
  _Wn = new WeakMap();
  _FreeDrawOutline_instances = new WeakSet();
  Vn_fn = function(t2, e2, i2, s2, n2) {
    const r2 = new Float64Array(t2.length);
    for (let a2 = 0, o2 = t2.length; a2 < o2; a2 += 2) {
      r2[a2] = e2 + t2[a2] * s2;
      r2[a2 + 1] = i2 + t2[a2 + 1] * n2;
    }
    return r2;
  };
  $n_fn = function(t2, e2, i2, s2, n2) {
    const r2 = new Float64Array(t2.length);
    for (let a2 = 0, o2 = t2.length; a2 < o2; a2 += 2) {
      r2[a2] = e2 + t2[a2 + 1] * s2;
      r2[a2 + 1] = i2 + t2[a2] * n2;
    }
    return r2;
  };
  Gn_fn = function(t2) {
    const e2 = __privateGet(this, _Wn);
    let i2 = e2[4], s2 = e2[5], n2 = i2, r2 = s2, a2 = i2, o2 = s2, l2 = i2, h2 = s2;
    const c2 = t2 ? Math.max : Math.min;
    for (let t3 = 6, d3 = e2.length; t3 < d3; t3 += 6) {
      if (isNaN(e2[t3])) {
        n2 = Math.min(n2, e2[t3 + 4]);
        r2 = Math.min(r2, e2[t3 + 5]);
        a2 = Math.max(a2, e2[t3 + 4]);
        o2 = Math.max(o2, e2[t3 + 5]);
        if (h2 < e2[t3 + 5]) {
          l2 = e2[t3 + 4];
          h2 = e2[t3 + 5];
        } else h2 === e2[t3 + 5] && (l2 = c2(l2, e2[t3 + 4]));
      } else {
        const d4 = Util.bezierBoundingBox(i2, s2, ...e2.slice(t3, t3 + 6));
        n2 = Math.min(n2, d4[0]);
        r2 = Math.min(r2, d4[1]);
        a2 = Math.max(a2, d4[2]);
        o2 = Math.max(o2, d4[3]);
        if (h2 < d4[3]) {
          l2 = d4[2];
          h2 = d4[3];
        } else h2 === d4[3] && (l2 = c2(l2, d4[2]));
      }
      i2 = e2[t3 + 4];
      s2 = e2[t3 + 5];
    }
    const d2 = n2 - __privateGet(this, _wn2), u2 = r2 - __privateGet(this, _wn2), p2 = a2 - n2 + 2 * __privateGet(this, _wn2), g2 = o2 - r2 + 2 * __privateGet(this, _wn2);
    __privateSet(this, _jn, {
      x: d2,
      y: u2,
      width: p2,
      height: g2,
      lastPoint: [
        l2,
        h2
      ]
    });
  };
  class HighlightOutliner {
    constructor(t2, e2 = 0, i2 = 0, s2 = true) {
      __privateAdd(this, _HighlightOutliner_instances);
      __privateAdd(this, _yn3);
      __privateAdd(this, _qn, []);
      __privateAdd(this, _Xn, []);
      let n2 = 1 / 0, r2 = -1 / 0, a2 = 1 / 0, o2 = -1 / 0;
      const l2 = 10 ** -4;
      for (const { x: i3, y: s3, width: h3, height: c3 } of t2) {
        const t3 = Math.floor((i3 - e2) / l2) * l2, d3 = Math.ceil((i3 + h3 + e2) / l2) * l2, u3 = Math.floor((s3 - e2) / l2) * l2, p3 = Math.ceil((s3 + c3 + e2) / l2) * l2, g3 = [
          t3,
          u3,
          p3,
          true
        ], f2 = [
          d3,
          u3,
          p3,
          false
        ];
        __privateGet(this, _qn).push(g3, f2);
        n2 = Math.min(n2, t3);
        r2 = Math.max(r2, d3);
        a2 = Math.min(a2, u3);
        o2 = Math.max(o2, p3);
      }
      const h2 = r2 - n2 + 2 * i2, c2 = o2 - a2 + 2 * i2, d2 = n2 - i2, u2 = a2 - i2, p2 = __privateGet(this, _qn).at(s2 ? -1 : -2), g2 = [
        p2[0],
        p2[2]
      ];
      for (const t3 of __privateGet(this, _qn)) {
        const [e3, i3, s3] = t3;
        t3[0] = (e3 - d2) / h2;
        t3[1] = (i3 - u2) / c2;
        t3[2] = (s3 - u2) / c2;
      }
      __privateSet(this, _yn3, {
        x: d2,
        y: u2,
        width: h2,
        height: c2,
        lastPoint: g2
      });
    }
    getOutlines() {
      __privateGet(this, _qn).sort((t3, e2) => t3[0] - e2[0] || t3[1] - e2[1] || t3[2] - e2[2]);
      const t2 = [];
      for (const e2 of __privateGet(this, _qn)) if (e2[3]) {
        t2.push(...__privateMethod(this, _HighlightOutliner_instances, Kn_fn).call(this, e2));
        __privateMethod(this, _HighlightOutliner_instances, Yn_fn).call(this, e2);
      } else {
        __privateMethod(this, _HighlightOutliner_instances, Qn_fn).call(this, e2);
        t2.push(...__privateMethod(this, _HighlightOutliner_instances, Kn_fn).call(this, e2));
      }
      return __privateMethod(this, _HighlightOutliner_instances, Jn_fn).call(this, t2);
    }
  }
  _yn3 = new WeakMap();
  _qn = new WeakMap();
  _Xn = new WeakMap();
  _HighlightOutliner_instances = new WeakSet();
  Jn_fn = function(t2) {
    const e2 = [], i2 = /* @__PURE__ */ new Set();
    for (const i3 of t2) {
      const [t3, s3, n3] = i3;
      e2.push([
        t3,
        s3,
        i3
      ], [
        t3,
        n3,
        i3
      ]);
    }
    e2.sort((t3, e3) => t3[1] - e3[1] || t3[0] - e3[0]);
    for (let t3 = 0, s3 = e2.length; t3 < s3; t3 += 2) {
      const s4 = e2[t3][2], n3 = e2[t3 + 1][2];
      s4.push(n3);
      n3.push(s4);
      i2.add(s4);
      i2.add(n3);
    }
    const s2 = [];
    let n2;
    for (; i2.size > 0; ) {
      const t3 = i2.values().next().value;
      let [e3, r2, a2, o2, l2] = t3;
      i2.delete(t3);
      let h2 = e3, c2 = r2;
      n2 = [
        e3,
        a2
      ];
      s2.push(n2);
      for (; ; ) {
        let t4;
        if (i2.has(o2)) t4 = o2;
        else {
          if (!i2.has(l2)) break;
          t4 = l2;
        }
        i2.delete(t4);
        [e3, r2, a2, o2, l2] = t4;
        if (h2 !== e3) {
          n2.push(h2, c2, e3, c2 === r2 ? r2 : a2);
          h2 = e3;
        }
        c2 = c2 === r2 ? a2 : r2;
      }
      n2.push(h2, c2);
    }
    return new HighlightOutline(s2, __privateGet(this, _yn3));
  };
  Zn_fn = function(t2) {
    const e2 = __privateGet(this, _Xn);
    let i2 = 0, s2 = e2.length - 1;
    for (; i2 <= s2; ) {
      const n2 = i2 + s2 >> 1, r2 = e2[n2][0];
      if (r2 === t2) return n2;
      r2 < t2 ? i2 = n2 + 1 : s2 = n2 - 1;
    }
    return s2 + 1;
  };
  Yn_fn = function([, t2, e2]) {
    const i2 = __privateMethod(this, _HighlightOutliner_instances, Zn_fn).call(this, t2);
    __privateGet(this, _Xn).splice(i2, 0, [
      t2,
      e2
    ]);
  };
  Qn_fn = function([, t2, e2]) {
    const i2 = __privateMethod(this, _HighlightOutliner_instances, Zn_fn).call(this, t2);
    for (let s2 = i2; s2 < __privateGet(this, _Xn).length; s2++) {
      const [i3, n2] = __privateGet(this, _Xn)[s2];
      if (i3 !== t2) break;
      if (i3 === t2 && n2 === e2) {
        __privateGet(this, _Xn).splice(s2, 1);
        return;
      }
    }
    for (let s2 = i2 - 1; s2 >= 0; s2--) {
      const [i3, n2] = __privateGet(this, _Xn)[s2];
      if (i3 !== t2) break;
      if (i3 === t2 && n2 === e2) {
        __privateGet(this, _Xn).splice(s2, 1);
        return;
      }
    }
  };
  Kn_fn = function(t2) {
    const [e2, i2, s2] = t2, n2 = [
      [
        e2,
        i2,
        s2
      ]
    ], r2 = __privateMethod(this, _HighlightOutliner_instances, Zn_fn).call(this, s2);
    for (let t3 = 0; t3 < r2; t3++) {
      const [i3, s3] = __privateGet(this, _Xn)[t3];
      for (let t4 = 0, r3 = n2.length; t4 < r3; t4++) {
        const [, a2, o2] = n2[t4];
        if (!(s3 <= a2 || o2 <= i3)) if (a2 >= i3) if (o2 > s3) n2[t4][1] = s3;
        else {
          if (1 === r3) return [];
          n2.splice(t4, 1);
          t4--;
          r3--;
        }
        else {
          n2[t4][2] = i3;
          o2 > s3 && n2.push([
            e2,
            s3,
            o2
          ]);
        }
      }
    }
    return n2;
  };
  class HighlightOutline extends Outline {
    constructor(t2, e2) {
      super();
      __privateAdd(this, _yn4);
      __privateAdd(this, _tr);
      __privateSet(this, _tr, t2);
      __privateSet(this, _yn4, e2);
    }
    toSVGPath() {
      const t2 = [];
      for (const e2 of __privateGet(this, _tr)) {
        let [i2, s2] = e2;
        t2.push(`M${i2} ${s2}`);
        for (let n2 = 2; n2 < e2.length; n2 += 2) {
          const r2 = e2[n2], a2 = e2[n2 + 1];
          if (r2 === i2) {
            t2.push(`V${a2}`);
            s2 = a2;
          } else if (a2 === s2) {
            t2.push(`H${r2}`);
            i2 = r2;
          }
        }
        t2.push("Z");
      }
      return t2.join(" ");
    }
    serialize([t2, e2, i2, s2], n2) {
      const r2 = [], a2 = i2 - t2, o2 = s2 - e2;
      for (const e3 of __privateGet(this, _tr)) {
        const i3 = new Array(e3.length);
        for (let n3 = 0; n3 < e3.length; n3 += 2) {
          i3[n3] = t2 + e3[n3] * a2;
          i3[n3 + 1] = s2 - e3[n3 + 1] * o2;
        }
        r2.push(i3);
      }
      return r2;
    }
    get box() {
      return __privateGet(this, _yn4);
    }
    get classNamesForDrawing() {
      return [
        "highlight"
      ];
    }
    get classNamesForOutlining() {
      return [
        "highlightOutline"
      ];
    }
  }
  _yn4 = new WeakMap();
  _tr = new WeakMap();
  class FreeHighlightOutliner extends FreeDrawOutliner {
    newFreeDrawOutline(t2, e2, i2, s2, n2, r2) {
      return new FreeHighlightOutline(t2, e2, i2, s2, n2, r2);
    }
    get classNamesForDrawing() {
      return [
        "highlight",
        "free"
      ];
    }
  }
  class FreeHighlightOutline extends FreeDrawOutline {
    get classNamesForDrawing() {
      return [
        "highlight",
        "free"
      ];
    }
    get classNamesForOutlining() {
      return [
        "highlightOutline",
        "free"
      ];
    }
    newOutliner(t2, e2, i2, s2, n2, r2 = 0) {
      return new FreeHighlightOutliner(t2, e2, i2, s2, n2, r2);
    }
  }
  const _ColorPicker = class _ColorPicker {
    constructor({ editor: t2 = null, uiManager: e2 = null }) {
      __privateAdd(this, _ColorPicker_instances);
      __privateAdd(this, _er, null);
      __privateAdd(this, _ir, null);
      __privateAdd(this, _sr);
      __privateAdd(this, _nr, null);
      __privateAdd(this, _rr, false);
      __privateAdd(this, _ar, false);
      __privateAdd(this, _r3, null);
      __privateAdd(this, _or);
      __privateAdd(this, _lr, null);
      __privateAdd(this, _f2, null);
      __privateAdd(this, _hr);
      var _a4;
      if (t2) {
        __privateSet(this, _ar, false);
        __privateSet(this, _hr, m.HIGHLIGHT_COLOR);
        __privateSet(this, _r3, t2);
      } else {
        __privateSet(this, _ar, true);
        __privateSet(this, _hr, m.HIGHLIGHT_DEFAULT_COLOR);
      }
      __privateSet(this, _f2, (t2 == null ? void 0 : t2._uiManager) || e2);
      __privateSet(this, _or, __privateGet(this, _f2)._eventBus);
      __privateSet(this, _sr, (t2 == null ? void 0 : t2.color) || ((_a4 = __privateGet(this, _f2)) == null ? void 0 : _a4.highlightColors.values().next().value) || "#FFFF98");
      __privateGet(_ColorPicker, _cr) || __privateSet(_ColorPicker, _cr, Object.freeze({
        blue: "pdfjs-editor-colorpicker-blue",
        green: "pdfjs-editor-colorpicker-green",
        pink: "pdfjs-editor-colorpicker-pink",
        red: "pdfjs-editor-colorpicker-red",
        yellow: "pdfjs-editor-colorpicker-yellow"
      }));
    }
    static get _keyboardManager() {
      return shadow(this, "_keyboardManager", new KeyboardManager([
        [
          [
            "Escape",
            "mac+Escape"
          ],
          _ColorPicker.prototype._hideDropdownFromKeyboard
        ],
        [
          [
            " ",
            "mac+ "
          ],
          _ColorPicker.prototype._colorSelectFromKeyboard
        ],
        [
          [
            "ArrowDown",
            "ArrowRight",
            "mac+ArrowDown",
            "mac+ArrowRight"
          ],
          _ColorPicker.prototype._moveToNext
        ],
        [
          [
            "ArrowUp",
            "ArrowLeft",
            "mac+ArrowUp",
            "mac+ArrowLeft"
          ],
          _ColorPicker.prototype._moveToPrevious
        ],
        [
          [
            "Home",
            "mac+Home"
          ],
          _ColorPicker.prototype._moveToBeginning
        ],
        [
          [
            "End",
            "mac+End"
          ],
          _ColorPicker.prototype._moveToEnd
        ]
      ]));
    }
    renderButton() {
      const t2 = __privateSet(this, _er, document.createElement("button"));
      t2.className = "colorPicker";
      t2.tabIndex = "0";
      t2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
      t2.setAttribute("aria-haspopup", true);
      const e2 = __privateGet(this, _f2)._signal;
      t2.addEventListener("click", __privateMethod(this, _ColorPicker_instances, dr_fn).bind(this), {
        signal: e2
      });
      t2.addEventListener("keydown", __privateMethod(this, _ColorPicker_instances, Es_fn2).bind(this), {
        signal: e2
      });
      const i2 = __privateSet(this, _ir, document.createElement("span"));
      i2.className = "swatch";
      i2.setAttribute("aria-hidden", true);
      i2.style.backgroundColor = __privateGet(this, _sr);
      t2.append(i2);
      return t2;
    }
    renderMainDropdown() {
      const t2 = __privateSet(this, _nr, __privateMethod(this, _ColorPicker_instances, ur_fn).call(this));
      t2.setAttribute("aria-orientation", "horizontal");
      t2.setAttribute("aria-labelledby", "highlightColorPickerLabel");
      return t2;
    }
    _colorSelectFromKeyboard(t2) {
      if (t2.target === __privateGet(this, _er)) {
        __privateMethod(this, _ColorPicker_instances, dr_fn).call(this, t2);
        return;
      }
      const e2 = t2.target.getAttribute("data-color");
      e2 && __privateMethod(this, _ColorPicker_instances, pr_fn).call(this, e2, t2);
    }
    _moveToNext(t2) {
      var _a4, _b2;
      __privateGet(this, _ColorPicker_instances, gr_get) ? t2.target !== __privateGet(this, _er) ? (_a4 = t2.target.nextSibling) == null ? void 0 : _a4.focus() : (_b2 = __privateGet(this, _nr).firstChild) == null ? void 0 : _b2.focus() : __privateMethod(this, _ColorPicker_instances, dr_fn).call(this, t2);
    }
    _moveToPrevious(t2) {
      var _a4, _b2;
      if (t2.target !== ((_a4 = __privateGet(this, _nr)) == null ? void 0 : _a4.firstChild) && t2.target !== __privateGet(this, _er)) {
        __privateGet(this, _ColorPicker_instances, gr_get) || __privateMethod(this, _ColorPicker_instances, dr_fn).call(this, t2);
        (_b2 = t2.target.previousSibling) == null ? void 0 : _b2.focus();
      } else __privateGet(this, _ColorPicker_instances, gr_get) && this._hideDropdownFromKeyboard();
    }
    _moveToBeginning(t2) {
      var _a4;
      __privateGet(this, _ColorPicker_instances, gr_get) ? (_a4 = __privateGet(this, _nr).firstChild) == null ? void 0 : _a4.focus() : __privateMethod(this, _ColorPicker_instances, dr_fn).call(this, t2);
    }
    _moveToEnd(t2) {
      var _a4;
      __privateGet(this, _ColorPicker_instances, gr_get) ? (_a4 = __privateGet(this, _nr).lastChild) == null ? void 0 : _a4.focus() : __privateMethod(this, _ColorPicker_instances, dr_fn).call(this, t2);
    }
    hideDropdown() {
      var _a4, _b2;
      (_a4 = __privateGet(this, _nr)) == null ? void 0 : _a4.classList.add("hidden");
      (_b2 = __privateGet(this, _lr)) == null ? void 0 : _b2.abort();
      __privateSet(this, _lr, null);
    }
    _hideDropdownFromKeyboard() {
      var _a4;
      if (!__privateGet(this, _ar)) if (__privateGet(this, _ColorPicker_instances, gr_get)) {
        this.hideDropdown();
        __privateGet(this, _er).focus({
          preventScroll: true,
          focusVisible: __privateGet(this, _rr)
        });
      } else (_a4 = __privateGet(this, _r3)) == null ? void 0 : _a4.unselect();
    }
    updateColor(t2) {
      __privateGet(this, _ir) && (__privateGet(this, _ir).style.backgroundColor = t2);
      if (!__privateGet(this, _nr)) return;
      const e2 = __privateGet(this, _f2).highlightColors.values();
      for (const i2 of __privateGet(this, _nr).children) i2.setAttribute("aria-selected", e2.next().value === t2);
    }
    destroy() {
      var _a4, _b2;
      (_a4 = __privateGet(this, _er)) == null ? void 0 : _a4.remove();
      __privateSet(this, _er, null);
      __privateSet(this, _ir, null);
      (_b2 = __privateGet(this, _nr)) == null ? void 0 : _b2.remove();
      __privateSet(this, _nr, null);
    }
  };
  _er = new WeakMap();
  _ir = new WeakMap();
  _sr = new WeakMap();
  _nr = new WeakMap();
  _rr = new WeakMap();
  _ar = new WeakMap();
  _r3 = new WeakMap();
  _or = new WeakMap();
  _lr = new WeakMap();
  _f2 = new WeakMap();
  _hr = new WeakMap();
  _cr = new WeakMap();
  _ColorPicker_instances = new WeakSet();
  ur_fn = function() {
    const t2 = document.createElement("div"), e2 = __privateGet(this, _f2)._signal;
    t2.addEventListener("contextmenu", noContextMenu, {
      signal: e2
    });
    t2.className = "dropdown";
    t2.role = "listbox";
    t2.setAttribute("aria-multiselectable", false);
    t2.setAttribute("aria-orientation", "vertical");
    t2.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
    for (const [i2, s2] of __privateGet(this, _f2).highlightColors) {
      const n2 = document.createElement("button");
      n2.tabIndex = "0";
      n2.role = "option";
      n2.setAttribute("data-color", s2);
      n2.title = i2;
      n2.setAttribute("data-l10n-id", __privateGet(_ColorPicker, _cr)[i2]);
      const r2 = document.createElement("span");
      n2.append(r2);
      r2.className = "swatch";
      r2.style.backgroundColor = s2;
      n2.setAttribute("aria-selected", s2 === __privateGet(this, _sr));
      n2.addEventListener("click", __privateMethod(this, _ColorPicker_instances, pr_fn).bind(this, s2), {
        signal: e2
      });
      t2.append(n2);
    }
    t2.addEventListener("keydown", __privateMethod(this, _ColorPicker_instances, Es_fn2).bind(this), {
      signal: e2
    });
    return t2;
  };
  pr_fn = function(t2, e2) {
    e2.stopPropagation();
    __privateGet(this, _or).dispatch("switchannotationeditorparams", {
      source: this,
      type: __privateGet(this, _hr),
      value: t2
    });
  };
  Es_fn2 = function(t2) {
    _ColorPicker._keyboardManager.exec(this, t2);
  };
  dr_fn = function(t2) {
    if (__privateGet(this, _ColorPicker_instances, gr_get)) {
      this.hideDropdown();
      return;
    }
    __privateSet(this, _rr, 0 === t2.detail);
    if (!__privateGet(this, _lr)) {
      __privateSet(this, _lr, new AbortController());
      window.addEventListener("pointerdown", __privateMethod(this, _ColorPicker_instances, h_fn2).bind(this), {
        signal: __privateGet(this, _f2).combinedSignal(__privateGet(this, _lr))
      });
    }
    if (__privateGet(this, _nr)) {
      __privateGet(this, _nr).classList.remove("hidden");
      return;
    }
    const e2 = __privateSet(this, _nr, __privateMethod(this, _ColorPicker_instances, ur_fn).call(this));
    __privateGet(this, _er).append(e2);
  };
  h_fn2 = function(t2) {
    var _a4;
    ((_a4 = __privateGet(this, _nr)) == null ? void 0 : _a4.contains(t2.target)) || this.hideDropdown();
  };
  gr_get = function() {
    return __privateGet(this, _nr) && !__privateGet(this, _nr).classList.contains("hidden");
  };
  __privateAdd(_ColorPicker, _cr, null);
  let ColorPicker = _ColorPicker;
  const _HighlightEditor = class _HighlightEditor extends AnnotationEditor {
    constructor(t2) {
      super({
        ...t2,
        name: "highlightEditor"
      });
      __privateAdd(this, _HighlightEditor_instances);
      __privateAdd(this, _fr, null);
      __privateAdd(this, _mr, 0);
      __privateAdd(this, _br);
      __privateAdd(this, _vr, null);
      __privateAdd(this, _n2, null);
      __privateAdd(this, _yr, null);
      __privateAdd(this, _Ar, null);
      __privateAdd(this, _wr, 0);
      __privateAdd(this, _xr, null);
      __privateAdd(this, __r, null);
      __privateAdd(this, _y4, null);
      __privateAdd(this, _Er, false);
      __privateAdd(this, _Cr, null);
      __privateAdd(this, _Sr);
      __privateAdd(this, _Tr, null);
      __privateAdd(this, _Mr, "");
      __privateAdd(this, _Pn2);
      __privateAdd(this, _kr, "");
      this.color = t2.color || _HighlightEditor._defaultColor;
      __privateSet(this, _Pn2, t2.thickness || _HighlightEditor._defaultThickness);
      __privateSet(this, _Sr, t2.opacity || _HighlightEditor._defaultOpacity);
      __privateSet(this, _br, t2.boxes || null);
      __privateSet(this, _kr, t2.methodOfCreation || "");
      __privateSet(this, _Mr, t2.text || "");
      this._isDraggable = false;
      if (t2.highlightId > -1) {
        __privateSet(this, _Er, true);
        __privateMethod(this, _HighlightEditor_instances, Pr_fn).call(this, t2);
        __privateMethod(this, _HighlightEditor_instances, Rr_fn).call(this);
      } else if (__privateGet(this, _br)) {
        __privateSet(this, _fr, t2.anchorNode);
        __privateSet(this, _mr, t2.anchorOffset);
        __privateSet(this, _Ar, t2.focusNode);
        __privateSet(this, _wr, t2.focusOffset);
        __privateMethod(this, _HighlightEditor_instances, Dr_fn).call(this);
        __privateMethod(this, _HighlightEditor_instances, Rr_fn).call(this);
        this.rotate(this.rotation);
      }
    }
    static get _keyboardManager() {
      const t2 = _HighlightEditor.prototype;
      return shadow(this, "_keyboardManager", new KeyboardManager([
        [
          [
            "ArrowLeft",
            "mac+ArrowLeft"
          ],
          t2._moveCaret,
          {
            args: [
              0
            ]
          }
        ],
        [
          [
            "ArrowRight",
            "mac+ArrowRight"
          ],
          t2._moveCaret,
          {
            args: [
              1
            ]
          }
        ],
        [
          [
            "ArrowUp",
            "mac+ArrowUp"
          ],
          t2._moveCaret,
          {
            args: [
              2
            ]
          }
        ],
        [
          [
            "ArrowDown",
            "mac+ArrowDown"
          ],
          t2._moveCaret,
          {
            args: [
              3
            ]
          }
        ]
      ]));
    }
    get telemetryInitialData() {
      return {
        action: "added",
        type: __privateGet(this, _Er) ? "free_highlight" : "highlight",
        color: this._uiManager.highlightColorNames.get(this.color),
        thickness: __privateGet(this, _Pn2),
        methodOfCreation: __privateGet(this, _kr)
      };
    }
    get telemetryFinalData() {
      return {
        type: "highlight",
        color: this._uiManager.highlightColorNames.get(this.color)
      };
    }
    static computeTelemetryFinalData(t2) {
      return {
        numberOfColors: t2.get("color").size
      };
    }
    static initialize(t2, e2) {
      var _a4;
      AnnotationEditor.initialize(t2, e2);
      _HighlightEditor._defaultColor || (_HighlightEditor._defaultColor = ((_a4 = e2.highlightColors) == null ? void 0 : _a4.values().next().value) || "#fff066");
    }
    static updateDefaultParams(t2, e2) {
      switch (t2) {
        case m.HIGHLIGHT_DEFAULT_COLOR:
          _HighlightEditor._defaultColor = e2;
          break;
        case m.HIGHLIGHT_THICKNESS:
          _HighlightEditor._defaultThickness = e2;
      }
    }
    translateInPage(t2, e2) {
    }
    get toolbarPosition() {
      return __privateGet(this, _Cr);
    }
    updateParams(t2, e2) {
      switch (t2) {
        case m.HIGHLIGHT_COLOR:
          __privateMethod(this, _HighlightEditor_instances, dn_fn2).call(this, e2);
          break;
        case m.HIGHLIGHT_THICKNESS:
          __privateMethod(this, _HighlightEditor_instances, Fr_fn).call(this, e2);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [
        [
          m.HIGHLIGHT_DEFAULT_COLOR,
          _HighlightEditor._defaultColor
        ],
        [
          m.HIGHLIGHT_THICKNESS,
          _HighlightEditor._defaultThickness
        ]
      ];
    }
    get propertiesToUpdate() {
      return [
        [
          m.HIGHLIGHT_COLOR,
          this.color || _HighlightEditor._defaultColor
        ],
        [
          m.HIGHLIGHT_THICKNESS,
          __privateGet(this, _Pn2) || _HighlightEditor._defaultThickness
        ],
        [
          m.HIGHLIGHT_FREE,
          __privateGet(this, _Er)
        ]
      ];
    }
    async addEditToolbar() {
      const t2 = await super.addEditToolbar();
      if (!t2) return null;
      if (this._uiManager.highlightColors) {
        __privateSet(this, _n2, new ColorPicker({
          editor: this
        }));
        t2.addColorPicker(__privateGet(this, _n2));
      }
      return t2;
    }
    disableEditing() {
      super.disableEditing();
      this.div.classList.toggle("disabled", true);
    }
    enableEditing() {
      super.enableEditing();
      this.div.classList.toggle("disabled", false);
    }
    fixAndSetPosition() {
      return super.fixAndSetPosition(__privateMethod(this, _HighlightEditor_instances, Or_fn).call(this));
    }
    getBaseTranslation() {
      return [
        0,
        0
      ];
    }
    getRect(t2, e2) {
      return super.getRect(t2, e2, __privateMethod(this, _HighlightEditor_instances, Or_fn).call(this));
    }
    onceAdded() {
      this.annotationElementId || this.parent.addUndoableEditor(this);
      this.div.focus();
    }
    remove() {
      __privateMethod(this, _HighlightEditor_instances, Nr_fn).call(this);
      this._reportTelemetry({
        action: "deleted"
      });
      super.remove();
    }
    rebuild() {
      if (this.parent) {
        super.rebuild();
        if (null !== this.div) {
          __privateMethod(this, _HighlightEditor_instances, Rr_fn).call(this);
          this.isAttachedToDOM || this.parent.add(this);
        }
      }
    }
    setParent(t2) {
      var _a4;
      let e2 = false;
      if (this.parent && !t2) __privateMethod(this, _HighlightEditor_instances, Nr_fn).call(this);
      else if (t2) {
        __privateMethod(this, _HighlightEditor_instances, Rr_fn).call(this, t2);
        e2 = !this.parent && ((_a4 = this.div) == null ? void 0 : _a4.classList.contains("selectedEditor"));
      }
      super.setParent(t2);
      this.show(this._isVisible);
      e2 && this.select();
    }
    rotate(t2) {
      var _a4, _b2, _c;
      const { drawLayer: e2 } = this.parent;
      let i2;
      if (__privateGet(this, _Er)) {
        t2 = (t2 - this.rotation + 360) % 360;
        i2 = __privateMethod(_a4 = _HighlightEditor, _HighlightEditor_static, Ir_fn).call(_a4, __privateGet(this, __r).box, t2);
      } else i2 = __privateMethod(_b2 = _HighlightEditor, _HighlightEditor_static, Ir_fn).call(_b2, this, t2);
      e2.rotate(__privateGet(this, _y4), t2);
      e2.rotate(__privateGet(this, _Tr), t2);
      e2.updateBox(__privateGet(this, _y4), i2);
      e2.updateBox(__privateGet(this, _Tr), __privateMethod(_c = _HighlightEditor, _HighlightEditor_static, Ir_fn).call(_c, __privateGet(this, _yr).box, t2));
    }
    render() {
      if (this.div) return this.div;
      const t2 = super.render();
      if (__privateGet(this, _Mr)) {
        t2.setAttribute("aria-label", __privateGet(this, _Mr));
        t2.setAttribute("role", "mark");
      }
      __privateGet(this, _Er) ? t2.classList.add("free") : this.div.addEventListener("keydown", __privateMethod(this, _HighlightEditor_instances, Br_fn).bind(this), {
        signal: this._uiManager._signal
      });
      const e2 = __privateSet(this, _xr, document.createElement("div"));
      t2.append(e2);
      e2.setAttribute("aria-hidden", "true");
      e2.className = "internal";
      e2.style.clipPath = __privateGet(this, _vr);
      const [i2, s2] = this.parentDimensions;
      this.setDims(this.width * i2, this.height * s2);
      bindEvents(this, __privateGet(this, _xr), [
        "pointerover",
        "pointerleave"
      ]);
      this.enableEditing();
      return t2;
    }
    pointerover() {
      this.isSelected || this.parent.drawLayer.addClass(__privateGet(this, _Tr), "hovered");
    }
    pointerleave() {
      this.isSelected || this.parent.drawLayer.removeClass(__privateGet(this, _Tr), "hovered");
    }
    _moveCaret(t2) {
      this.parent.unselect(this);
      switch (t2) {
        case 0:
        case 2:
          __privateMethod(this, _HighlightEditor_instances, Hr_fn).call(this, true);
          break;
        case 1:
        case 3:
          __privateMethod(this, _HighlightEditor_instances, Hr_fn).call(this, false);
      }
    }
    select() {
      var _a4, _b2;
      super.select();
      if (__privateGet(this, _Tr)) {
        (_a4 = this.parent) == null ? void 0 : _a4.drawLayer.removeClass(__privateGet(this, _Tr), "hovered");
        (_b2 = this.parent) == null ? void 0 : _b2.drawLayer.addClass(__privateGet(this, _Tr), "selected");
      }
    }
    unselect() {
      var _a4;
      super.unselect();
      if (__privateGet(this, _Tr)) {
        (_a4 = this.parent) == null ? void 0 : _a4.drawLayer.removeClass(__privateGet(this, _Tr), "selected");
        __privateGet(this, _Er) || __privateMethod(this, _HighlightEditor_instances, Hr_fn).call(this, false);
      }
    }
    get _mustFixPosition() {
      return !__privateGet(this, _Er);
    }
    show(t2 = this._isVisible) {
      super.show(t2);
      if (this.parent) {
        this.parent.drawLayer.show(__privateGet(this, _y4), t2);
        this.parent.drawLayer.show(__privateGet(this, _Tr), t2);
      }
    }
    static startHighlighting(t2, e2, { target: i2, x: s2, y: n2 }) {
      const { x: r2, y: a2, width: o2, height: l2 } = i2.getBoundingClientRect(), h2 = new AbortController(), c2 = t2.combinedSignal(h2), pointerUpCallback = (e3) => {
        h2.abort();
        __privateMethod(this, _HighlightEditor_static, jr_fn).call(this, t2, e3);
      };
      window.addEventListener("blur", pointerUpCallback, {
        signal: c2
      });
      window.addEventListener("pointerup", pointerUpCallback, {
        signal: c2
      });
      window.addEventListener("pointerdown", (t3) => {
        t3.preventDefault();
        t3.stopPropagation();
      }, {
        capture: true,
        passive: false,
        signal: c2
      });
      window.addEventListener("contextmenu", noContextMenu, {
        signal: c2
      });
      i2.addEventListener("pointermove", __privateMethod(this, _HighlightEditor_static, Wr_fn).bind(this, t2), {
        signal: c2
      });
      this._freeHighlight = new FreeHighlightOutliner({
        x: s2,
        y: n2
      }, [
        r2,
        a2,
        o2,
        l2
      ], t2.scale, this._defaultThickness / 2, e2, 1e-3);
      ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = t2.drawLayer.draw(this._freeHighlight, this._defaultColor, this._defaultOpacity, true));
    }
    static async deserialize(t2, e2, i2) {
      var _a4, _b2, _c, _d;
      let s2 = null;
      if (t2 instanceof HighlightAnnotationElement) {
        const { data: { quadPoints: e3, rect: i3, rotation: n3, id: r3, color: a3, opacity: o3, popupRef: l3 }, parent: { page: { pageNumber: h3 } } } = t2;
        s2 = t2 = {
          annotationType: f.HIGHLIGHT,
          color: Array.from(a3),
          opacity: o3,
          quadPoints: e3,
          boxes: null,
          pageIndex: h3 - 1,
          rect: i3.slice(0),
          rotation: n3,
          id: r3,
          deleted: false,
          popupRef: l3
        };
      } else if (t2 instanceof InkAnnotationElement) {
        const { data: { inkLists: e3, rect: i3, rotation: n3, id: r3, color: a3, borderStyle: { rawWidth: o3 }, popupRef: l3 }, parent: { page: { pageNumber: h3 } } } = t2;
        s2 = t2 = {
          annotationType: f.HIGHLIGHT,
          color: Array.from(a3),
          thickness: o3,
          inkLists: e3,
          boxes: null,
          pageIndex: h3 - 1,
          rect: i3.slice(0),
          rotation: n3,
          id: r3,
          deleted: false,
          popupRef: l3
        };
      }
      const { color: n2, quadPoints: r2, inkLists: a2, opacity: o2 } = t2, l2 = await super.deserialize(t2, e2, i2);
      l2.color = Util.makeHexColor(...n2);
      __privateSet(l2, _Sr, o2 || 1);
      a2 && __privateSet(l2, _Pn2, t2.thickness);
      l2.annotationElementId = t2.id || null;
      l2._initialData = s2;
      const [h2, c2] = l2.pageDimensions, [d2, u2] = l2.pageTranslation;
      if (r2) {
        const t3 = __privateSet(l2, _br, []);
        for (let e3 = 0; e3 < r2.length; e3 += 8) t3.push({
          x: (r2[e3] - d2) / h2,
          y: 1 - (r2[e3 + 1] - u2) / c2,
          width: (r2[e3 + 2] - r2[e3]) / h2,
          height: (r2[e3 + 1] - r2[e3 + 5]) / c2
        });
        __privateMethod(_a4 = l2, _HighlightEditor_instances, Dr_fn).call(_a4);
        __privateMethod(_b2 = l2, _HighlightEditor_instances, Rr_fn).call(_b2);
        l2.rotate(l2.rotation);
      } else if (a2) {
        __privateSet(l2, _Er, true);
        const t3 = a2[0], i3 = {
          x: t3[0] - d2,
          y: c2 - (t3[1] - u2)
        }, s3 = new FreeHighlightOutliner(i3, [
          0,
          0,
          h2,
          c2
        ], 1, __privateGet(l2, _Pn2) / 2, true, 1e-3);
        for (let e3 = 0, n4 = t3.length; e3 < n4; e3 += 2) {
          i3.x = t3[e3] - d2;
          i3.y = c2 - (t3[e3 + 1] - u2);
          s3.add(i3);
        }
        const { id: n3, clipPathId: r3 } = e2.drawLayer.draw(s3, l2.color, l2._defaultOpacity, true);
        __privateMethod(_c = l2, _HighlightEditor_instances, Pr_fn).call(_c, {
          highlightOutlines: s3.getOutlines(),
          highlightId: n3,
          clipPathId: r3
        });
        __privateMethod(_d = l2, _HighlightEditor_instances, Rr_fn).call(_d);
      }
      return l2;
    }
    serialize(t2 = false) {
      if (this.isEmpty() || t2) return null;
      if (this.deleted) return this.serializeDeleted();
      const e2 = this.getRect(0, 0), i2 = AnnotationEditor._colorManager.convert(this.color), s2 = {
        annotationType: f.HIGHLIGHT,
        color: i2,
        opacity: __privateGet(this, _Sr),
        thickness: __privateGet(this, _Pn2),
        quadPoints: __privateMethod(this, _HighlightEditor_instances, Ur_fn).call(this),
        outlines: __privateMethod(this, _HighlightEditor_instances, zr_fn).call(this, e2),
        pageIndex: this.pageIndex,
        rect: e2,
        rotation: __privateMethod(this, _HighlightEditor_instances, Or_fn).call(this),
        structTreeParentId: this._structTreeParentId
      };
      if (this.annotationElementId && !__privateMethod(this, _HighlightEditor_instances, vn_fn2).call(this, s2)) return null;
      s2.id = this.annotationElementId;
      return s2;
    }
    renderAnnotationElement(t2) {
      t2.updateEdited({
        rect: this.getRect(0, 0)
      });
      return null;
    }
    static canCreateNewEmptyEditor() {
      return false;
    }
  };
  _fr = new WeakMap();
  _mr = new WeakMap();
  _br = new WeakMap();
  _vr = new WeakMap();
  _n2 = new WeakMap();
  _yr = new WeakMap();
  _Ar = new WeakMap();
  _wr = new WeakMap();
  _xr = new WeakMap();
  __r = new WeakMap();
  _y4 = new WeakMap();
  _Er = new WeakMap();
  _Cr = new WeakMap();
  _Sr = new WeakMap();
  _Tr = new WeakMap();
  _Mr = new WeakMap();
  _Pn2 = new WeakMap();
  _kr = new WeakMap();
  _HighlightEditor_instances = new WeakSet();
  Dr_fn = function() {
    const t2 = new HighlightOutliner(__privateGet(this, _br), 1e-3);
    __privateSet(this, __r, t2.getOutlines());
    ({ x: this.x, y: this.y, width: this.width, height: this.height } = __privateGet(this, __r).box);
    const e2 = new HighlightOutliner(__privateGet(this, _br), 25e-4, 1e-3, "ltr" === this._uiManager.direction);
    __privateSet(this, _yr, e2.getOutlines());
    const { lastPoint: i2 } = __privateGet(this, _yr).box;
    __privateSet(this, _Cr, [
      (i2[0] - this.x) / this.width,
      (i2[1] - this.y) / this.height
    ]);
  };
  Pr_fn = function({ highlightOutlines: t2, highlightId: e2, clipPathId: i2 }) {
    var _a4, _b2;
    __privateSet(this, __r, t2);
    __privateSet(this, _yr, t2.getNewOutline(__privateGet(this, _Pn2) / 2 + 1.5, 25e-4));
    if (e2 >= 0) {
      __privateSet(this, _y4, e2);
      __privateSet(this, _vr, i2);
      this.parent.drawLayer.finalizeLine(e2, t2);
      __privateSet(this, _Tr, this.parent.drawLayer.drawOutline(__privateGet(this, _yr)));
    } else if (this.parent) {
      const e3 = this.parent.viewport.rotation;
      this.parent.drawLayer.updateLine(__privateGet(this, _y4), t2);
      this.parent.drawLayer.updateBox(__privateGet(this, _y4), __privateMethod(_a4 = _HighlightEditor, _HighlightEditor_static, Ir_fn).call(_a4, __privateGet(this, __r).box, (e3 - this.rotation + 360) % 360));
      this.parent.drawLayer.updateLine(__privateGet(this, _Tr), __privateGet(this, _yr));
      this.parent.drawLayer.updateBox(__privateGet(this, _Tr), __privateMethod(_b2 = _HighlightEditor, _HighlightEditor_static, Ir_fn).call(_b2, __privateGet(this, _yr).box, e3));
    }
    const { x: s2, y: n2, width: r2, height: a2 } = t2.box;
    switch (this.rotation) {
      case 0:
        this.x = s2;
        this.y = n2;
        this.width = r2;
        this.height = a2;
        break;
      case 90: {
        const [t3, e3] = this.parentDimensions;
        this.x = n2;
        this.y = 1 - s2;
        this.width = r2 * e3 / t3;
        this.height = a2 * t3 / e3;
        break;
      }
      case 180:
        this.x = 1 - s2;
        this.y = 1 - n2;
        this.width = r2;
        this.height = a2;
        break;
      case 270: {
        const [t3, e3] = this.parentDimensions;
        this.x = 1 - n2;
        this.y = s2;
        this.width = r2 * e3 / t3;
        this.height = a2 * t3 / e3;
        break;
      }
    }
    const { lastPoint: o2 } = __privateGet(this, _yr).box;
    __privateSet(this, _Cr, [
      (o2[0] - s2) / r2,
      (o2[1] - n2) / a2
    ]);
  };
  dn_fn2 = function(t2) {
    const setColorAndOpacity = (t3, e3) => {
      var _a4, _b2, _c;
      this.color = t3;
      (_a4 = this.parent) == null ? void 0 : _a4.drawLayer.changeColor(__privateGet(this, _y4), t3);
      (_b2 = __privateGet(this, _n2)) == null ? void 0 : _b2.updateColor(t3);
      __privateSet(this, _Sr, e3);
      (_c = this.parent) == null ? void 0 : _c.drawLayer.changeOpacity(__privateGet(this, _y4), e3);
    }, e2 = this.color, i2 = __privateGet(this, _Sr);
    this.addCommands({
      cmd: setColorAndOpacity.bind(this, t2, _HighlightEditor._defaultOpacity),
      undo: setColorAndOpacity.bind(this, e2, i2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.HIGHLIGHT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "color_changed",
      color: this._uiManager.highlightColorNames.get(t2)
    }, true);
  };
  Fr_fn = function(t2) {
    const e2 = __privateGet(this, _Pn2), setThickness = (t3) => {
      __privateSet(this, _Pn2, t3);
      __privateMethod(this, _HighlightEditor_instances, Lr_fn).call(this, t3);
    };
    this.addCommands({
      cmd: setThickness.bind(this, t2),
      undo: setThickness.bind(this, e2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
    this._reportTelemetry({
      action: "thickness_changed",
      thickness: t2
    }, true);
  };
  Lr_fn = function(t2) {
    if (!__privateGet(this, _Er)) return;
    __privateMethod(this, _HighlightEditor_instances, Pr_fn).call(this, {
      highlightOutlines: __privateGet(this, __r).getNewOutline(t2 / 2)
    });
    this.fixAndSetPosition();
    const [e2, i2] = this.parentDimensions;
    this.setDims(this.width * e2, this.height * i2);
  };
  Nr_fn = function() {
    if (null !== __privateGet(this, _y4) && this.parent) {
      this.parent.drawLayer.remove(__privateGet(this, _y4));
      __privateSet(this, _y4, null);
      this.parent.drawLayer.remove(__privateGet(this, _Tr));
      __privateSet(this, _Tr, null);
    }
  };
  Rr_fn = function(t2 = this.parent) {
    if (null === __privateGet(this, _y4)) {
      ({ id: __privateWrapper(this, _y4)._, clipPathId: __privateWrapper(this, _vr)._ } = t2.drawLayer.draw(__privateGet(this, __r), this.color, __privateGet(this, _Sr)));
      __privateSet(this, _Tr, t2.drawLayer.drawOutline(__privateGet(this, _yr)));
      __privateGet(this, _xr) && (__privateGet(this, _xr).style.clipPath = __privateGet(this, _vr));
    }
  };
  _HighlightEditor_static = new WeakSet();
  Ir_fn = function({ x: t2, y: e2, width: i2, height: s2 }, n2) {
    switch (n2) {
      case 90:
        return {
          x: 1 - e2 - s2,
          y: t2,
          width: s2,
          height: i2
        };
      case 180:
        return {
          x: 1 - t2 - i2,
          y: 1 - e2 - s2,
          width: i2,
          height: s2
        };
      case 270:
        return {
          x: e2,
          y: 1 - t2 - i2,
          width: s2,
          height: i2
        };
    }
    return {
      x: t2,
      y: e2,
      width: i2,
      height: s2
    };
  };
  Br_fn = function(t2) {
    _HighlightEditor._keyboardManager.exec(this, t2);
  };
  Hr_fn = function(t2) {
    if (!__privateGet(this, _fr)) return;
    const e2 = window.getSelection();
    t2 ? e2.setPosition(__privateGet(this, _fr), __privateGet(this, _mr)) : e2.setPosition(__privateGet(this, _Ar), __privateGet(this, _wr));
  };
  Or_fn = function() {
    return __privateGet(this, _Er) ? this.rotation : 0;
  };
  Ur_fn = function() {
    if (__privateGet(this, _Er)) return null;
    const [t2, e2] = this.pageDimensions, [i2, s2] = this.pageTranslation, n2 = __privateGet(this, _br), r2 = new Float32Array(8 * n2.length);
    let a2 = 0;
    for (const { x: o2, y: l2, width: h2, height: c2 } of n2) {
      const n3 = o2 * t2 + i2, d2 = (1 - l2 - c2) * e2 + s2;
      r2[a2] = r2[a2 + 4] = n3;
      r2[a2 + 1] = r2[a2 + 3] = d2;
      r2[a2 + 2] = r2[a2 + 6] = n3 + h2 * t2;
      r2[a2 + 5] = r2[a2 + 7] = d2 + c2 * e2;
      a2 += 8;
    }
    return r2;
  };
  zr_fn = function(t2) {
    return __privateGet(this, __r).serialize(t2, __privateMethod(this, _HighlightEditor_instances, Or_fn).call(this));
  };
  Wr_fn = function(t2, e2) {
    this._freeHighlight.add(e2) && t2.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
  };
  jr_fn = function(t2, e2) {
    this._freeHighlight.isEmpty() ? t2.drawLayer.remove(this._freeHighlightId) : t2.createAndAddNewEditor(e2, false, {
      highlightId: this._freeHighlightId,
      highlightOutlines: this._freeHighlight.getOutlines(),
      clipPathId: this._freeHighlightClipId,
      methodOfCreation: "main_toolbar"
    });
    this._freeHighlightId = -1;
    this._freeHighlight = null;
    this._freeHighlightClipId = "";
  };
  vn_fn2 = function(t2) {
    const { color: e2 } = this._initialData;
    return t2.color.some((t3, i2) => t3 !== e2[i2]);
  };
  __privateAdd(_HighlightEditor, _HighlightEditor_static);
  __publicField(_HighlightEditor, "_defaultColor", null);
  __publicField(_HighlightEditor, "_defaultOpacity", 1);
  __publicField(_HighlightEditor, "_defaultThickness", 12);
  __publicField(_HighlightEditor, "_type", "highlight");
  __publicField(_HighlightEditor, "_editorType", f.HIGHLIGHT);
  __publicField(_HighlightEditor, "_freeHighlightId", -1);
  __publicField(_HighlightEditor, "_freeHighlight", null);
  __publicField(_HighlightEditor, "_freeHighlightClipId", "");
  let HighlightEditor = _HighlightEditor;
  const _InkEditor = class _InkEditor extends AnnotationEditor {
    constructor(t2) {
      super({
        ...t2,
        name: "inkEditor"
      });
      __privateAdd(this, _InkEditor_instances);
      __privateAdd(this, _Gr, 0);
      __privateAdd(this, _Vr, 0);
      __privateAdd(this, _$r, null);
      __privateAdd(this, _qr, new Path2D());
      __privateAdd(this, _Xr, false);
      __privateAdd(this, _Kr, null);
      __privateAdd(this, _Yr, false);
      __privateAdd(this, _Qr, false);
      __privateAdd(this, _Jr, null);
      __privateAdd(this, _Zr, null);
      __privateAdd(this, _ta, 0);
      __privateAdd(this, _ea, 0);
      __privateAdd(this, _ia, null);
      this.color = t2.color || null;
      this.thickness = t2.thickness || null;
      this.opacity = t2.opacity || null;
      this.paths = [];
      this.bezierPath2D = [];
      this.allRawPaths = [];
      this.currentPath = [];
      this.scaleFactor = 1;
      this.translationX = this.translationY = 0;
      this.x = 0;
      this.y = 0;
      this._willKeepAspectRatio = true;
    }
    static initialize(t2, e2) {
      AnnotationEditor.initialize(t2, e2);
    }
    static updateDefaultParams(t2, e2) {
      switch (t2) {
        case m.INK_THICKNESS:
          _InkEditor._defaultThickness = e2;
          break;
        case m.INK_COLOR:
          _InkEditor._defaultColor = e2;
          break;
        case m.INK_OPACITY:
          _InkEditor._defaultOpacity = e2 / 100;
      }
    }
    updateParams(t2, e2) {
      switch (t2) {
        case m.INK_THICKNESS:
          __privateMethod(this, _InkEditor_instances, Fr_fn2).call(this, e2);
          break;
        case m.INK_COLOR:
          __privateMethod(this, _InkEditor_instances, dn_fn3).call(this, e2);
          break;
        case m.INK_OPACITY:
          __privateMethod(this, _InkEditor_instances, sa_fn).call(this, e2);
      }
    }
    static get defaultPropertiesToUpdate() {
      return [
        [
          m.INK_THICKNESS,
          _InkEditor._defaultThickness
        ],
        [
          m.INK_COLOR,
          _InkEditor._defaultColor || AnnotationEditor._defaultLineColor
        ],
        [
          m.INK_OPACITY,
          Math.round(100 * _InkEditor._defaultOpacity)
        ]
      ];
    }
    get propertiesToUpdate() {
      return [
        [
          m.INK_THICKNESS,
          this.thickness || _InkEditor._defaultThickness
        ],
        [
          m.INK_COLOR,
          this.color || _InkEditor._defaultColor || AnnotationEditor._defaultLineColor
        ],
        [
          m.INK_OPACITY,
          Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))
        ]
      ];
    }
    rebuild() {
      if (this.parent) {
        super.rebuild();
        if (null !== this.div) {
          if (!this.canvas) {
            __privateMethod(this, _InkEditor_instances, aa_fn).call(this);
            __privateMethod(this, _InkEditor_instances, oa_fn).call(this);
          }
          if (!this.isAttachedToDOM) {
            this.parent.add(this);
            __privateMethod(this, _InkEditor_instances, la_fn).call(this);
          }
          __privateMethod(this, _InkEditor_instances, na_fn).call(this);
        }
      }
    }
    remove() {
      var _a4;
      if (null !== this.canvas) {
        this.isEmpty() || this.commit();
        this.canvas.width = this.canvas.height = 0;
        this.canvas.remove();
        this.canvas = null;
        if (__privateGet(this, _$r)) {
          clearTimeout(__privateGet(this, _$r));
          __privateSet(this, _$r, null);
        }
        (_a4 = __privateGet(this, _Jr)) == null ? void 0 : _a4.disconnect();
        __privateSet(this, _Jr, null);
        super.remove();
      }
    }
    setParent(t2) {
      !this.parent && t2 ? this._uiManager.removeShouldRescale(this) : this.parent && null === t2 && this._uiManager.addShouldRescale(this);
      super.setParent(t2);
    }
    onScaleChanging() {
      const [t2, e2] = this.parentDimensions, i2 = this.width * t2, s2 = this.height * e2;
      this.setDimensions(i2, s2);
    }
    enableEditMode() {
      if (!__privateGet(this, _Xr) && null !== this.canvas) {
        super.enableEditMode();
        this._isDraggable = false;
        __privateMethod(this, _InkEditor_instances, ha_fn).call(this);
      }
    }
    disableEditMode() {
      if (this.isInEditMode() && null !== this.canvas) {
        super.disableEditMode();
        this._isDraggable = !this.isEmpty();
        this.div.classList.remove("editing");
        __privateMethod(this, _InkEditor_instances, ca_fn).call(this);
      }
    }
    onceAdded() {
      this._isDraggable = !this.isEmpty();
    }
    isEmpty() {
      return 0 === this.paths.length || 1 === this.paths.length && 0 === this.paths[0].length;
    }
    commit() {
      if (!__privateGet(this, _Xr)) {
        super.commit();
        this.isEditing = false;
        this.disableEditMode();
        this.setInForeground();
        __privateSet(this, _Xr, true);
        this.div.classList.add("disabled");
        __privateMethod(this, _InkEditor_instances, na_fn).call(this, true);
        this.select();
        this.parent.addInkEditorIfNeeded(true);
        this.moveInDOM();
        this.div.focus({
          preventScroll: true
        });
      }
    }
    focusin(t2) {
      if (this._focusEventsAllowed) {
        super.focusin(t2);
        this.enableEditMode();
      }
    }
    canvasPointerdown(t2) {
      if (0 === t2.button && this.isInEditMode() && !__privateGet(this, _Xr)) {
        this.setInForeground();
        t2.preventDefault();
        this.div.contains(document.activeElement) || this.div.focus({
          preventScroll: true
        });
        __privateMethod(this, _InkEditor_instances, pa_fn).call(this, t2.offsetX, t2.offsetY);
      }
    }
    canvasPointermove(t2) {
      t2.preventDefault();
      __privateMethod(this, _InkEditor_instances, fa_fn).call(this, t2.offsetX, t2.offsetY);
    }
    canvasPointerup(t2) {
      t2.preventDefault();
      __privateMethod(this, _InkEditor_instances, wa_fn).call(this, t2);
    }
    canvasPointerleave(t2) {
      __privateMethod(this, _InkEditor_instances, wa_fn).call(this, t2);
    }
    get isResizable() {
      return !this.isEmpty() && __privateGet(this, _Xr);
    }
    render() {
      if (this.div) return this.div;
      let t2, e2;
      if (this.width) {
        t2 = this.x;
        e2 = this.y;
      }
      super.render();
      this.div.setAttribute("data-l10n-id", "pdfjs-ink");
      const [i2, s2, n2, r2] = __privateMethod(this, _InkEditor_instances, da_fn).call(this);
      this.setAt(i2, s2, 0, 0);
      this.setDims(n2, r2);
      __privateMethod(this, _InkEditor_instances, aa_fn).call(this);
      if (this.width) {
        const [i3, s3] = this.parentDimensions;
        this.setAspectRatio(this.width * i3, this.height * s3);
        this.setAt(t2 * i3, e2 * s3, this.width * i3, this.height * s3);
        __privateSet(this, _Qr, true);
        __privateMethod(this, _InkEditor_instances, la_fn).call(this);
        this.setDims(this.width * i3, this.height * s3);
        __privateMethod(this, _InkEditor_instances, ra_fn).call(this);
        this.div.classList.add("disabled");
      } else {
        this.div.classList.add("editing");
        this.enableEditMode();
      }
      __privateMethod(this, _InkEditor_instances, oa_fn).call(this);
      return this.div;
    }
    setDimensions(t2, e2) {
      const i2 = Math.round(t2), s2 = Math.round(e2);
      if (__privateGet(this, _ta) === i2 && __privateGet(this, _ea) === s2) return;
      __privateSet(this, _ta, i2);
      __privateSet(this, _ea, s2);
      this.canvas.style.visibility = "hidden";
      const [n2, r2] = this.parentDimensions;
      this.width = t2 / n2;
      this.height = e2 / r2;
      this.fixAndSetPosition();
      __privateGet(this, _Xr) && __privateMethod(this, _InkEditor_instances, xa_fn).call(this, t2, e2);
      __privateMethod(this, _InkEditor_instances, la_fn).call(this);
      __privateMethod(this, _InkEditor_instances, ra_fn).call(this);
      this.canvas.style.visibility = "visible";
      this.fixDims();
    }
    static async deserialize(t2, e2, i2) {
      var _a4, _b2, _c;
      if (t2 instanceof InkAnnotationElement) return null;
      const s2 = await super.deserialize(t2, e2, i2);
      s2.thickness = t2.thickness;
      s2.color = Util.makeHexColor(...t2.color);
      s2.opacity = t2.opacity;
      const [n2, r2] = s2.pageDimensions, a2 = s2.width * n2, o2 = s2.height * r2, l2 = s2.parentScale, h2 = t2.thickness / 2;
      __privateSet(s2, _Xr, true);
      __privateSet(s2, _ta, Math.round(a2));
      __privateSet(s2, _ea, Math.round(o2));
      const { paths: c2, rect: d2, rotation: u2 } = t2;
      for (let { bezier: t3 } of c2) {
        t3 = __privateMethod(_a4 = _InkEditor, _InkEditor_static, Sa_fn).call(_a4, t3, d2, u2);
        const e3 = [];
        s2.paths.push(e3);
        let i3 = l2 * (t3[0] - h2), n3 = l2 * (t3[1] - h2);
        for (let s3 = 2, r4 = t3.length; s3 < r4; s3 += 6) {
          const r5 = l2 * (t3[s3] - h2), a3 = l2 * (t3[s3 + 1] - h2), o3 = l2 * (t3[s3 + 2] - h2), c3 = l2 * (t3[s3 + 3] - h2), d3 = l2 * (t3[s3 + 4] - h2), u3 = l2 * (t3[s3 + 5] - h2);
          e3.push([
            [
              i3,
              n3
            ],
            [
              r5,
              a3
            ],
            [
              o3,
              c3
            ],
            [
              d3,
              u3
            ]
          ]);
          i3 = d3;
          n3 = u3;
        }
        const r3 = __privateMethod(this, _InkEditor_static, Ea_fn).call(this, e3);
        s2.bezierPath2D.push(r3);
      }
      const p2 = __privateMethod(_b2 = s2, _InkEditor_instances, Ma_fn).call(_b2);
      __privateSet(s2, _Vr, Math.max(AnnotationEditor.MIN_SIZE, p2[2] - p2[0]));
      __privateSet(s2, _Gr, Math.max(AnnotationEditor.MIN_SIZE, p2[3] - p2[1]));
      __privateMethod(_c = s2, _InkEditor_instances, xa_fn).call(_c, a2, o2);
      return s2;
    }
    serialize() {
      if (this.isEmpty()) return null;
      const t2 = this.getRect(0, 0), e2 = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
      return {
        annotationType: f.INK,
        color: e2,
        thickness: this.thickness,
        opacity: this.opacity,
        paths: __privateMethod(this, _InkEditor_instances, Ta_fn).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, t2),
        pageIndex: this.pageIndex,
        rect: t2,
        rotation: this.rotation,
        structTreeParentId: this._structTreeParentId
      };
    }
  };
  _Gr = new WeakMap();
  _Vr = new WeakMap();
  _$r = new WeakMap();
  _qr = new WeakMap();
  _Xr = new WeakMap();
  _Kr = new WeakMap();
  _Yr = new WeakMap();
  _Qr = new WeakMap();
  _Jr = new WeakMap();
  _Zr = new WeakMap();
  _ta = new WeakMap();
  _ea = new WeakMap();
  _ia = new WeakMap();
  _InkEditor_instances = new WeakSet();
  Fr_fn2 = function(t2) {
    const setThickness = (t3) => {
      this.thickness = t3;
      __privateMethod(this, _InkEditor_instances, na_fn).call(this);
    }, e2 = this.thickness;
    this.addCommands({
      cmd: setThickness.bind(this, t2),
      undo: setThickness.bind(this, e2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
  };
  dn_fn3 = function(t2) {
    const setColor = (t3) => {
      this.color = t3;
      __privateMethod(this, _InkEditor_instances, ra_fn).call(this);
    }, e2 = this.color;
    this.addCommands({
      cmd: setColor.bind(this, t2),
      undo: setColor.bind(this, e2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.INK_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  };
  sa_fn = function(t2) {
    const setOpacity = (t3) => {
      this.opacity = t3;
      __privateMethod(this, _InkEditor_instances, ra_fn).call(this);
    };
    t2 /= 100;
    const e2 = this.opacity;
    this.addCommands({
      cmd: setOpacity.bind(this, t2),
      undo: setOpacity.bind(this, e2),
      post: this._uiManager.updateUI.bind(this._uiManager, this),
      mustExec: true,
      type: m.INK_OPACITY,
      overwriteIfSameType: true,
      keepUndo: true
    });
  };
  da_fn = function() {
    const { parentRotation: t2, parentDimensions: [e2, i2] } = this;
    switch (t2) {
      case 90:
        return [
          0,
          i2,
          i2,
          e2
        ];
      case 180:
        return [
          e2,
          i2,
          e2,
          i2
        ];
      case 270:
        return [
          e2,
          0,
          i2,
          e2
        ];
      default:
        return [
          0,
          0,
          e2,
          i2
        ];
    }
  };
  ua_fn = function() {
    const { ctx: t2, color: e2, opacity: i2, thickness: s2, parentScale: n2, scaleFactor: r2 } = this;
    t2.lineWidth = s2 * n2 / r2;
    t2.lineCap = "round";
    t2.lineJoin = "round";
    t2.miterLimit = 10;
    t2.strokeStyle = `${e2}${function opacityToHex(t3) {
      return Math.round(Math.min(255, Math.max(1, 255 * t3))).toString(16).padStart(2, "0");
    }(i2)}`;
  };
  pa_fn = function(t2, e2) {
    this.canvas.addEventListener("contextmenu", noContextMenu, {
      signal: this._uiManager._signal
    });
    __privateMethod(this, _InkEditor_instances, ca_fn).call(this);
    __privateSet(this, _Kr, new AbortController());
    const i2 = this._uiManager.combinedSignal(__privateGet(this, _Kr));
    this.canvas.addEventListener("pointerleave", this.canvasPointerleave.bind(this), {
      signal: i2
    });
    this.canvas.addEventListener("pointermove", this.canvasPointermove.bind(this), {
      signal: i2
    });
    this.canvas.addEventListener("pointerup", this.canvasPointerup.bind(this), {
      signal: i2
    });
    this.isEditing = true;
    if (!__privateGet(this, _Qr)) {
      __privateSet(this, _Qr, true);
      __privateMethod(this, _InkEditor_instances, la_fn).call(this);
      this.thickness || (this.thickness = _InkEditor._defaultThickness);
      this.color || (this.color = _InkEditor._defaultColor || AnnotationEditor._defaultLineColor);
      this.opacity ?? (this.opacity = _InkEditor._defaultOpacity);
    }
    this.currentPath.push([
      t2,
      e2
    ]);
    __privateSet(this, _Yr, false);
    __privateMethod(this, _InkEditor_instances, ua_fn).call(this);
    __privateSet(this, _ia, () => {
      __privateMethod(this, _InkEditor_instances, ga_fn).call(this);
      __privateGet(this, _ia) && window.requestAnimationFrame(__privateGet(this, _ia));
    });
    window.requestAnimationFrame(__privateGet(this, _ia));
  };
  fa_fn = function(t2, e2) {
    const [i2, s2] = this.currentPath.at(-1);
    if (this.currentPath.length > 1 && t2 === i2 && e2 === s2) return;
    const n2 = this.currentPath;
    let r2 = __privateGet(this, _qr);
    n2.push([
      t2,
      e2
    ]);
    __privateSet(this, _Yr, true);
    if (n2.length <= 2) {
      r2.moveTo(...n2[0]);
      r2.lineTo(t2, e2);
    } else {
      if (3 === n2.length) {
        __privateSet(this, _qr, r2 = new Path2D());
        r2.moveTo(...n2[0]);
      }
      __privateMethod(this, _InkEditor_instances, ma_fn).call(this, r2, ...n2.at(-3), ...n2.at(-2), t2, e2);
    }
  };
  ba_fn = function() {
    if (0 === this.currentPath.length) return;
    const t2 = this.currentPath.at(-1);
    __privateGet(this, _qr).lineTo(...t2);
  };
  va_fn = function(t2, e2) {
    __privateSet(this, _ia, null);
    t2 = Math.min(Math.max(t2, 0), this.canvas.width);
    e2 = Math.min(Math.max(e2, 0), this.canvas.height);
    __privateMethod(this, _InkEditor_instances, fa_fn).call(this, t2, e2);
    __privateMethod(this, _InkEditor_instances, ba_fn).call(this);
    let i2;
    if (1 !== this.currentPath.length) i2 = __privateMethod(this, _InkEditor_instances, ya_fn).call(this);
    else {
      const s3 = [
        t2,
        e2
      ];
      i2 = [
        [
          s3,
          s3.slice(),
          s3.slice(),
          s3
        ]
      ];
    }
    const s2 = __privateGet(this, _qr), n2 = this.currentPath;
    this.currentPath = [];
    __privateSet(this, _qr, new Path2D());
    this.addCommands({
      cmd: () => {
        this.allRawPaths.push(n2);
        this.paths.push(i2);
        this.bezierPath2D.push(s2);
        this._uiManager.rebuild(this);
      },
      undo: () => {
        this.allRawPaths.pop();
        this.paths.pop();
        this.bezierPath2D.pop();
        if (0 === this.paths.length) this.remove();
        else {
          if (!this.canvas) {
            __privateMethod(this, _InkEditor_instances, aa_fn).call(this);
            __privateMethod(this, _InkEditor_instances, oa_fn).call(this);
          }
          __privateMethod(this, _InkEditor_instances, na_fn).call(this);
        }
      },
      mustExec: true
    });
  };
  ga_fn = function() {
    if (!__privateGet(this, _Yr)) return;
    __privateSet(this, _Yr, false);
    Math.ceil(this.thickness * this.parentScale);
    const e2 = this.currentPath.slice(-3), i2 = e2.map((t2) => t2[0]), s2 = e2.map((t2) => t2[1]), { ctx: n2 } = (Math.min(...i2), Math.max(...i2), Math.min(...s2), Math.max(...s2), this);
    n2.save();
    n2.clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const t2 of this.bezierPath2D) n2.stroke(t2);
    n2.stroke(__privateGet(this, _qr));
    n2.restore();
  };
  ma_fn = function(t2, e2, i2, s2, n2, r2, a2) {
    const o2 = (e2 + s2) / 2, l2 = (i2 + n2) / 2, h2 = (s2 + r2) / 2, c2 = (n2 + a2) / 2;
    t2.bezierCurveTo(o2 + 2 * (s2 - o2) / 3, l2 + 2 * (n2 - l2) / 3, h2 + 2 * (s2 - h2) / 3, c2 + 2 * (n2 - c2) / 3, h2, c2);
  };
  ya_fn = function() {
    const t2 = this.currentPath;
    if (t2.length <= 2) return [
      [
        t2[0],
        t2[0],
        t2.at(-1),
        t2.at(-1)
      ]
    ];
    const e2 = [];
    let i2, [s2, n2] = t2[0];
    for (i2 = 1; i2 < t2.length - 2; i2++) {
      const [r3, a3] = t2[i2], [o3, l3] = t2[i2 + 1], h3 = (r3 + o3) / 2, c3 = (a3 + l3) / 2, d2 = [
        s2 + 2 * (r3 - s2) / 3,
        n2 + 2 * (a3 - n2) / 3
      ], u2 = [
        h3 + 2 * (r3 - h3) / 3,
        c3 + 2 * (a3 - c3) / 3
      ];
      e2.push([
        [
          s2,
          n2
        ],
        d2,
        u2,
        [
          h3,
          c3
        ]
      ]);
      [s2, n2] = [
        h3,
        c3
      ];
    }
    const [r2, a2] = t2[i2], [o2, l2] = t2[i2 + 1], h2 = [
      s2 + 2 * (r2 - s2) / 3,
      n2 + 2 * (a2 - n2) / 3
    ], c2 = [
      o2 + 2 * (r2 - o2) / 3,
      l2 + 2 * (a2 - l2) / 3
    ];
    e2.push([
      [
        s2,
        n2
      ],
      h2,
      c2,
      [
        o2,
        l2
      ]
    ]);
    return e2;
  };
  ra_fn = function() {
    if (this.isEmpty()) {
      __privateMethod(this, _InkEditor_instances, Aa_fn).call(this);
      return;
    }
    __privateMethod(this, _InkEditor_instances, ua_fn).call(this);
    const { canvas: t2, ctx: e2 } = this;
    e2.setTransform(1, 0, 0, 1, 0, 0);
    e2.clearRect(0, 0, t2.width, t2.height);
    __privateMethod(this, _InkEditor_instances, Aa_fn).call(this);
    for (const t3 of this.bezierPath2D) e2.stroke(t3);
  };
  ha_fn = function() {
    if (__privateGet(this, _Zr)) return;
    __privateSet(this, _Zr, new AbortController());
    const t2 = this._uiManager.combinedSignal(__privateGet(this, _Zr));
    this.canvas.addEventListener("pointerdown", this.canvasPointerdown.bind(this), {
      signal: t2
    });
  };
  ca_fn = function() {
    var _a4;
    (_a4 = this.pointerdownAC) == null ? void 0 : _a4.abort();
    this.pointerdownAC = null;
  };
  wa_fn = function(t2) {
    var _a4;
    (_a4 = __privateGet(this, _Kr)) == null ? void 0 : _a4.abort();
    __privateSet(this, _Kr, null);
    __privateMethod(this, _InkEditor_instances, ha_fn).call(this);
    __privateGet(this, _$r) && clearTimeout(__privateGet(this, _$r));
    __privateSet(this, _$r, setTimeout(() => {
      __privateSet(this, _$r, null);
      this.canvas.removeEventListener("contextmenu", noContextMenu);
    }, 10));
    __privateMethod(this, _InkEditor_instances, va_fn).call(this, t2.offsetX, t2.offsetY);
    this.addToAnnotationStorage();
    this.setInBackground();
  };
  aa_fn = function() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.canvas.height = 0;
    this.canvas.className = "inkEditorCanvas";
    this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas");
    this.div.append(this.canvas);
    this.ctx = this.canvas.getContext("2d");
  };
  oa_fn = function() {
    __privateSet(this, _Jr, new ResizeObserver((t2) => {
      const e2 = t2[0].contentRect;
      e2.width && e2.height && this.setDimensions(e2.width, e2.height);
    }));
    __privateGet(this, _Jr).observe(this.div);
    this._uiManager._signal.addEventListener("abort", () => {
      var _a4;
      (_a4 = __privateGet(this, _Jr)) == null ? void 0 : _a4.disconnect();
      __privateSet(this, _Jr, null);
    }, {
      once: true
    });
  };
  la_fn = function() {
    if (!__privateGet(this, _Qr)) return;
    const [t2, e2] = this.parentDimensions;
    this.canvas.width = Math.ceil(this.width * t2);
    this.canvas.height = Math.ceil(this.height * e2);
    __privateMethod(this, _InkEditor_instances, Aa_fn).call(this);
  };
  xa_fn = function(t2, e2) {
    const i2 = __privateMethod(this, _InkEditor_instances, _a_fn).call(this), s2 = (t2 - i2) / __privateGet(this, _Vr), n2 = (e2 - i2) / __privateGet(this, _Gr);
    this.scaleFactor = Math.min(s2, n2);
  };
  Aa_fn = function() {
    const t2 = __privateMethod(this, _InkEditor_instances, _a_fn).call(this) / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + t2, this.translationY * this.scaleFactor + t2);
  };
  _InkEditor_static = new WeakSet();
  Ea_fn = function(t2) {
    const e2 = new Path2D();
    for (let i2 = 0, s2 = t2.length; i2 < s2; i2++) {
      const [s3, n2, r2, a2] = t2[i2];
      0 === i2 && e2.moveTo(...s3);
      e2.bezierCurveTo(n2[0], n2[1], r2[0], r2[1], a2[0], a2[1]);
    }
    return e2;
  };
  Ca_fn = function(t2, e2, i2) {
    const [s2, n2, r2, a2] = e2;
    switch (i2) {
      case 0:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          t2[e3] += s2;
          t2[e3 + 1] = a2 - t2[e3 + 1];
        }
        break;
      case 90:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          const i4 = t2[e3];
          t2[e3] = t2[e3 + 1] + s2;
          t2[e3 + 1] = i4 + n2;
        }
        break;
      case 180:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          t2[e3] = r2 - t2[e3];
          t2[e3 + 1] += n2;
        }
        break;
      case 270:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          const i4 = t2[e3];
          t2[e3] = r2 - t2[e3 + 1];
          t2[e3 + 1] = a2 - i4;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return t2;
  };
  Sa_fn = function(t2, e2, i2) {
    const [s2, n2, r2, a2] = e2;
    switch (i2) {
      case 0:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          t2[e3] -= s2;
          t2[e3 + 1] = a2 - t2[e3 + 1];
        }
        break;
      case 90:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          const i4 = t2[e3];
          t2[e3] = t2[e3 + 1] - n2;
          t2[e3 + 1] = i4 - s2;
        }
        break;
      case 180:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          t2[e3] = r2 - t2[e3];
          t2[e3 + 1] -= n2;
        }
        break;
      case 270:
        for (let e3 = 0, i3 = t2.length; e3 < i3; e3 += 2) {
          const i4 = t2[e3];
          t2[e3] = a2 - t2[e3 + 1];
          t2[e3 + 1] = r2 - i4;
        }
        break;
      default:
        throw new Error("Invalid rotation");
    }
    return t2;
  };
  Ta_fn = function(t2, e2, i2, s2) {
    var _a4, _b2;
    const n2 = [], r2 = this.thickness / 2, a2 = t2 * e2 + r2, o2 = t2 * i2 + r2;
    for (const e3 of this.paths) {
      const i3 = [], r3 = [];
      for (let s3 = 0, n3 = e3.length; s3 < n3; s3++) {
        const [l2, h2, c2, d2] = e3[s3];
        if (l2[0] === d2[0] && l2[1] === d2[1] && 1 === n3) {
          const e4 = t2 * l2[0] + a2, s4 = t2 * l2[1] + o2;
          i3.push(e4, s4);
          r3.push(e4, s4);
          break;
        }
        const u2 = t2 * l2[0] + a2, p2 = t2 * l2[1] + o2, g2 = t2 * h2[0] + a2, f2 = t2 * h2[1] + o2, m2 = t2 * c2[0] + a2, b2 = t2 * c2[1] + o2, v2 = t2 * d2[0] + a2, y2 = t2 * d2[1] + o2;
        if (0 === s3) {
          i3.push(u2, p2);
          r3.push(u2, p2);
        }
        i3.push(g2, f2, m2, b2, v2, y2);
        r3.push(g2, f2);
        s3 === n3 - 1 && r3.push(v2, y2);
      }
      n2.push({
        bezier: __privateMethod(_a4 = _InkEditor, _InkEditor_static, Ca_fn).call(_a4, i3, s2, this.rotation),
        points: __privateMethod(_b2 = _InkEditor, _InkEditor_static, Ca_fn).call(_b2, r3, s2, this.rotation)
      });
    }
    return n2;
  };
  Ma_fn = function() {
    let t2 = 1 / 0, e2 = -1 / 0, i2 = 1 / 0, s2 = -1 / 0;
    for (const n2 of this.paths) for (const [r2, a2, o2, l2] of n2) {
      const n3 = Util.bezierBoundingBox(...r2, ...a2, ...o2, ...l2);
      t2 = Math.min(t2, n3[0]);
      i2 = Math.min(i2, n3[1]);
      e2 = Math.max(e2, n3[2]);
      s2 = Math.max(s2, n3[3]);
    }
    return [
      t2,
      i2,
      e2,
      s2
    ];
  };
  _a_fn = function() {
    return __privateGet(this, _Xr) ? Math.ceil(this.thickness * this.parentScale) : 0;
  };
  na_fn = function(t2 = false) {
    if (this.isEmpty()) return;
    if (!__privateGet(this, _Xr)) {
      __privateMethod(this, _InkEditor_instances, ra_fn).call(this);
      return;
    }
    const e2 = __privateMethod(this, _InkEditor_instances, Ma_fn).call(this), i2 = __privateMethod(this, _InkEditor_instances, _a_fn).call(this);
    __privateSet(this, _Vr, Math.max(AnnotationEditor.MIN_SIZE, e2[2] - e2[0]));
    __privateSet(this, _Gr, Math.max(AnnotationEditor.MIN_SIZE, e2[3] - e2[1]));
    const s2 = Math.ceil(i2 + __privateGet(this, _Vr) * this.scaleFactor), n2 = Math.ceil(i2 + __privateGet(this, _Gr) * this.scaleFactor), [r2, a2] = this.parentDimensions;
    this.width = s2 / r2;
    this.height = n2 / a2;
    this.setAspectRatio(s2, n2);
    const o2 = this.translationX, l2 = this.translationY;
    this.translationX = -e2[0];
    this.translationY = -e2[1];
    __privateMethod(this, _InkEditor_instances, la_fn).call(this);
    __privateMethod(this, _InkEditor_instances, ra_fn).call(this);
    __privateSet(this, _ta, s2);
    __privateSet(this, _ea, n2);
    this.setDims(s2, n2);
    const h2 = t2 ? i2 / this.scaleFactor / 2 : 0;
    this.translate(o2 - this.translationX - h2, l2 - this.translationY - h2);
  };
  __privateAdd(_InkEditor, _InkEditor_static);
  __publicField(_InkEditor, "_defaultColor", null);
  __publicField(_InkEditor, "_defaultOpacity", 1);
  __publicField(_InkEditor, "_defaultThickness", 1);
  __publicField(_InkEditor, "_type", "ink");
  __publicField(_InkEditor, "_editorType", f.INK);
  let InkEditor = _InkEditor;
  const _StampEditor = class _StampEditor extends AnnotationEditor {
    constructor(t2) {
      super({
        ...t2,
        name: "stampEditor"
      });
      __privateAdd(this, _StampEditor_instances);
      __privateAdd(this, _ka, null);
      __privateAdd(this, _Pa, null);
      __privateAdd(this, _Ra, null);
      __privateAdd(this, _Da, null);
      __privateAdd(this, _Ia, null);
      __privateAdd(this, _Fa, "");
      __privateAdd(this, _La, null);
      __privateAdd(this, _Jr2, null);
      __privateAdd(this, _Oa, null);
      __privateAdd(this, _Na, false);
      __privateAdd(this, _Ba, false);
      __privateSet(this, _Da, t2.bitmapUrl);
      __privateSet(this, _Ia, t2.bitmapFile);
    }
    static initialize(t2, e2) {
      AnnotationEditor.initialize(t2, e2);
    }
    static get supportedTypes() {
      return shadow(this, "supportedTypes", [
        "apng",
        "avif",
        "bmp",
        "gif",
        "jpeg",
        "png",
        "svg+xml",
        "webp",
        "x-icon"
      ].map((t2) => `image/${t2}`));
    }
    static get supportedTypesStr() {
      return shadow(this, "supportedTypesStr", this.supportedTypes.join(","));
    }
    static isHandlingMimeForPasting(t2) {
      return this.supportedTypes.includes(t2);
    }
    static paste(t2, e2) {
      e2.pasteEditor(f.STAMP, {
        bitmapFile: t2.getAsFile()
      });
    }
    altTextFinish() {
      this._uiManager.useNewAltTextFlow && (this.div.hidden = false);
      super.altTextFinish();
    }
    get telemetryFinalData() {
      var _a4;
      return {
        type: "stamp",
        hasAltText: !!((_a4 = this.altTextData) == null ? void 0 : _a4.altText)
      };
    }
    static computeTelemetryFinalData(t2) {
      const e2 = t2.get("hasAltText");
      return {
        hasAltText: e2.get(true) ?? 0,
        hasNoAltText: e2.get(false) ?? 0
      };
    }
    async mlGuessAltText(t2 = null, e2 = true) {
      if (this.hasAltTextData()) return null;
      const { mlManager: i2 } = this._uiManager;
      if (!i2) throw new Error("No ML.");
      if (!await i2.isEnabledFor("altText")) throw new Error("ML isn't enabled for alt text.");
      const { data: s2, width: n2, height: r2 } = t2 || this.copyCanvas(null, null, true).imageData, a2 = await i2.guess({
        name: "altText",
        request: {
          data: s2,
          width: n2,
          height: r2,
          channels: s2.length / (n2 * r2)
        }
      });
      if (!a2) throw new Error("No response from the AI service.");
      if (a2.error) throw new Error("Error from the AI service.");
      if (a2.cancel) return null;
      if (!a2.output) throw new Error("No valid response from the AI service.");
      const o2 = a2.output;
      await this.setGuessedAltText(o2);
      e2 && !this.hasAltTextData() && (this.altTextData = {
        alt: o2,
        decorative: false
      });
      return o2;
    }
    remove() {
      var _a4, _b2;
      if (__privateGet(this, _Pa)) {
        __privateSet(this, _ka, null);
        this._uiManager.imageManager.deleteId(__privateGet(this, _Pa));
        (_a4 = __privateGet(this, _La)) == null ? void 0 : _a4.remove();
        __privateSet(this, _La, null);
        (_b2 = __privateGet(this, _Jr2)) == null ? void 0 : _b2.disconnect();
        __privateSet(this, _Jr2, null);
        if (__privateGet(this, _Oa)) {
          clearTimeout(__privateGet(this, _Oa));
          __privateSet(this, _Oa, null);
        }
      }
      super.remove();
    }
    rebuild() {
      if (this.parent) {
        super.rebuild();
        if (null !== this.div) {
          __privateGet(this, _Pa) && null === __privateGet(this, _La) && __privateMethod(this, _StampEditor_instances, za_fn).call(this);
          this.isAttachedToDOM || this.parent.add(this);
        }
      } else __privateGet(this, _Pa) && __privateMethod(this, _StampEditor_instances, za_fn).call(this);
    }
    onceAdded() {
      this._isDraggable = true;
      this.div.focus();
    }
    isEmpty() {
      return !(__privateGet(this, _Ra) || __privateGet(this, _ka) || __privateGet(this, _Da) || __privateGet(this, _Ia) || __privateGet(this, _Pa));
    }
    get isResizable() {
      return true;
    }
    render() {
      if (this.div) return this.div;
      let t2, e2;
      if (this.width) {
        t2 = this.x;
        e2 = this.y;
      }
      super.render();
      this.div.hidden = true;
      this.div.setAttribute("role", "figure");
      this.addAltTextButton();
      __privateGet(this, _ka) ? __privateMethod(this, _StampEditor_instances, aa_fn2).call(this) : __privateMethod(this, _StampEditor_instances, za_fn).call(this);
      if (this.width && !this.annotationElementId) {
        const [i2, s2] = this.parentDimensions;
        this.setAt(t2 * i2, e2 * s2, this.width * i2, this.height * s2);
      }
      return this.div;
    }
    copyCanvas(t2, e2, i2 = false) {
      var _a4;
      t2 || (t2 = 224);
      const { width: s2, height: n2 } = __privateGet(this, _ka), r2 = new OutputScale();
      let a2 = __privateGet(this, _ka), o2 = s2, l2 = n2, h2 = null;
      if (e2) {
        if (s2 > e2 || n2 > e2) {
          const t4 = Math.min(e2 / s2, e2 / n2);
          o2 = Math.floor(s2 * t4);
          l2 = Math.floor(n2 * t4);
        }
        h2 = document.createElement("canvas");
        const t3 = h2.width = Math.ceil(o2 * r2.sx), i3 = h2.height = Math.ceil(l2 * r2.sy);
        __privateGet(this, _Na) || (a2 = __privateMethod(this, _StampEditor_instances, Wa_fn).call(this, t3, i3));
        const c3 = h2.getContext("2d");
        c3.filter = this._uiManager.hcmFilter;
        let d2 = "white", u2 = "#cfcfd8";
        if ("none" !== this._uiManager.hcmFilter) u2 = "black";
        else if ((_a4 = window.matchMedia) == null ? void 0 : _a4.call(window, "(prefers-color-scheme: dark)").matches) {
          d2 = "#8f8f9d";
          u2 = "#42414d";
        }
        const p2 = 15, g2 = p2 * r2.sx, f2 = p2 * r2.sy, m2 = new OffscreenCanvas(2 * g2, 2 * f2), b2 = m2.getContext("2d");
        b2.fillStyle = d2;
        b2.fillRect(0, 0, 2 * g2, 2 * f2);
        b2.fillStyle = u2;
        b2.fillRect(0, 0, g2, f2);
        b2.fillRect(g2, f2, g2, f2);
        c3.fillStyle = c3.createPattern(m2, "repeat");
        c3.fillRect(0, 0, t3, i3);
        c3.drawImage(a2, 0, 0, a2.width, a2.height, 0, 0, t3, i3);
      }
      let c2 = null;
      if (i2) {
        let e3, i3;
        if (r2.symmetric && a2.width < t2 && a2.height < t2) {
          e3 = a2.width;
          i3 = a2.height;
        } else {
          a2 = __privateGet(this, _ka);
          if (s2 > t2 || n2 > t2) {
            const r3 = Math.min(t2 / s2, t2 / n2);
            e3 = Math.floor(s2 * r3);
            i3 = Math.floor(n2 * r3);
            __privateGet(this, _Na) || (a2 = __privateMethod(this, _StampEditor_instances, Wa_fn).call(this, e3, i3));
          }
        }
        const o3 = new OffscreenCanvas(e3, i3).getContext("2d", {
          willReadFrequently: true
        });
        o3.drawImage(a2, 0, 0, a2.width, a2.height, 0, 0, e3, i3);
        c2 = {
          width: e3,
          height: i3,
          data: o3.getImageData(0, 0, e3, i3).data
        };
      }
      return {
        canvas: h2,
        width: o2,
        height: l2,
        imageData: c2
      };
    }
    getImageForAltText() {
      return __privateGet(this, _La);
    }
    static async deserialize(t2, e2, i2) {
      var _a4;
      let s2 = null;
      if (t2 instanceof StampAnnotationElement) {
        const { data: { rect: n3, rotation: r3, id: a3, structParent: o3, popupRef: l3 }, container: h3, parent: { page: { pageNumber: c3 } } } = t2, d3 = h3.querySelector("canvas"), u3 = i2.imageManager.getFromCanvas(h3.id, d3);
        d3.remove();
        const p2 = ((_a4 = await e2._structTree.getAriaAttributes(`${st}${a3}`)) == null ? void 0 : _a4.get("aria-label")) || "";
        s2 = t2 = {
          annotationType: f.STAMP,
          bitmapId: u3.id,
          bitmap: u3.bitmap,
          pageIndex: c3 - 1,
          rect: n3.slice(0),
          rotation: r3,
          id: a3,
          deleted: false,
          accessibilityData: {
            decorative: false,
            altText: p2
          },
          isSvg: false,
          structParent: o3,
          popupRef: l3
        };
      }
      const n2 = await super.deserialize(t2, e2, i2), { rect: r2, bitmap: a2, bitmapUrl: o2, bitmapId: l2, isSvg: h2, accessibilityData: c2 } = t2;
      if (l2 && i2.imageManager.isValidId(l2)) {
        __privateSet(n2, _Pa, l2);
        a2 && __privateSet(n2, _ka, a2);
      } else __privateSet(n2, _Da, o2);
      __privateSet(n2, _Na, h2);
      const [d2, u2] = n2.pageDimensions;
      n2.width = (r2[2] - r2[0]) / d2;
      n2.height = (r2[3] - r2[1]) / u2;
      n2.annotationElementId = t2.id || null;
      c2 && (n2.altTextData = c2);
      n2._initialData = s2;
      __privateSet(n2, _Ba, !!s2);
      return n2;
    }
    serialize(t2 = false, e2 = null) {
      if (this.isEmpty()) return null;
      if (this.deleted) return this.serializeDeleted();
      const i2 = {
        annotationType: f.STAMP,
        bitmapId: __privateGet(this, _Pa),
        pageIndex: this.pageIndex,
        rect: this.getRect(0, 0),
        rotation: this.rotation,
        isSvg: __privateGet(this, _Na),
        structTreeParentId: this._structTreeParentId
      };
      if (t2) {
        i2.bitmapUrl = __privateMethod(this, _StampEditor_instances, Va_fn).call(this, true);
        i2.accessibilityData = this.serializeAltText(true);
        return i2;
      }
      const { decorative: s2, altText: n2 } = this.serializeAltText(false);
      !s2 && n2 && (i2.accessibilityData = {
        type: "Figure",
        alt: n2
      });
      if (this.annotationElementId) {
        const t3 = __privateMethod(this, _StampEditor_instances, vn_fn3).call(this, i2);
        if (t3.isSame) return null;
        t3.isSameAltText ? delete i2.accessibilityData : i2.accessibilityData.structParent = this._initialData.structParent ?? -1;
      }
      i2.id = this.annotationElementId;
      if (null === e2) return i2;
      e2.stamps || (e2.stamps = /* @__PURE__ */ new Map());
      const r2 = __privateGet(this, _Na) ? (i2.rect[2] - i2.rect[0]) * (i2.rect[3] - i2.rect[1]) : null;
      if (e2.stamps.has(__privateGet(this, _Pa))) {
        if (__privateGet(this, _Na)) {
          const t3 = e2.stamps.get(__privateGet(this, _Pa));
          if (r2 > t3.area) {
            t3.area = r2;
            t3.serialized.bitmap.close();
            t3.serialized.bitmap = __privateMethod(this, _StampEditor_instances, Va_fn).call(this, false);
          }
        }
      } else {
        e2.stamps.set(__privateGet(this, _Pa), {
          area: r2,
          serialized: i2
        });
        i2.bitmap = __privateMethod(this, _StampEditor_instances, Va_fn).call(this, false);
      }
      return i2;
    }
    renderAnnotationElement(t2) {
      t2.updateEdited({
        rect: this.getRect(0, 0)
      });
      return null;
    }
  };
  _ka = new WeakMap();
  _Pa = new WeakMap();
  _Ra = new WeakMap();
  _Da = new WeakMap();
  _Ia = new WeakMap();
  _Fa = new WeakMap();
  _La = new WeakMap();
  _Jr2 = new WeakMap();
  _Oa = new WeakMap();
  _Na = new WeakMap();
  _Ba = new WeakMap();
  _StampEditor_instances = new WeakSet();
  Ha_fn = function(t2, e2 = false) {
    if (t2) {
      __privateSet(this, _ka, t2.bitmap);
      if (!e2) {
        __privateSet(this, _Pa, t2.id);
        __privateSet(this, _Na, t2.isSvg);
      }
      t2.file && __privateSet(this, _Fa, t2.file.name);
      __privateMethod(this, _StampEditor_instances, aa_fn2).call(this);
    } else this.remove();
  };
  Ua_fn = function() {
    __privateSet(this, _Ra, null);
    this._uiManager.enableWaiting(false);
    if (__privateGet(this, _La)) if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _ka)) {
      this._editToolbar.hide();
      this._uiManager.editAltText(this, true);
    } else {
      if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && __privateGet(this, _ka)) {
        this._reportTelemetry({
          action: "pdfjs.image.image_added",
          data: {
            alt_text_modal: false,
            alt_text_type: "empty"
          }
        });
        try {
          this.mlGuessAltText();
        } catch {
        }
      }
      this.div.focus();
    }
  };
  za_fn = function() {
    if (__privateGet(this, _Pa)) {
      this._uiManager.enableWaiting(true);
      this._uiManager.imageManager.getFromId(__privateGet(this, _Pa)).then((t3) => __privateMethod(this, _StampEditor_instances, Ha_fn).call(this, t3, true)).finally(() => __privateMethod(this, _StampEditor_instances, Ua_fn).call(this));
      return;
    }
    if (__privateGet(this, _Da)) {
      const t3 = __privateGet(this, _Da);
      __privateSet(this, _Da, null);
      this._uiManager.enableWaiting(true);
      __privateSet(this, _Ra, this._uiManager.imageManager.getFromUrl(t3).then((t4) => __privateMethod(this, _StampEditor_instances, Ha_fn).call(this, t4)).finally(() => __privateMethod(this, _StampEditor_instances, Ua_fn).call(this)));
      return;
    }
    if (__privateGet(this, _Ia)) {
      const t3 = __privateGet(this, _Ia);
      __privateSet(this, _Ia, null);
      this._uiManager.enableWaiting(true);
      __privateSet(this, _Ra, this._uiManager.imageManager.getFromFile(t3).then((t4) => __privateMethod(this, _StampEditor_instances, Ha_fn).call(this, t4)).finally(() => __privateMethod(this, _StampEditor_instances, Ua_fn).call(this)));
      return;
    }
    const t2 = document.createElement("input");
    t2.type = "file";
    t2.accept = _StampEditor.supportedTypesStr;
    const e2 = this._uiManager._signal;
    __privateSet(this, _Ra, new Promise((i2) => {
      t2.addEventListener("change", async () => {
        if (t2.files && 0 !== t2.files.length) {
          this._uiManager.enableWaiting(true);
          const e3 = await this._uiManager.imageManager.getFromFile(t2.files[0]);
          this._reportTelemetry({
            action: "pdfjs.image.image_selected",
            data: {
              alt_text_modal: this._uiManager.useNewAltTextFlow
            }
          });
          __privateMethod(this, _StampEditor_instances, Ha_fn).call(this, e3);
        } else this.remove();
        i2();
      }, {
        signal: e2
      });
      t2.addEventListener("cancel", () => {
        this.remove();
        i2();
      }, {
        signal: e2
      });
    }).finally(() => __privateMethod(this, _StampEditor_instances, Ua_fn).call(this)));
    t2.click();
  };
  aa_fn2 = function() {
    const { div: t2 } = this;
    let { width: e2, height: i2 } = __privateGet(this, _ka);
    const [s2, n2] = this.pageDimensions, r2 = 0.75;
    if (this.width) {
      e2 = this.width * s2;
      i2 = this.height * n2;
    } else if (e2 > r2 * s2 || i2 > r2 * n2) {
      const t3 = Math.min(r2 * s2 / e2, r2 * n2 / i2);
      e2 *= t3;
      i2 *= t3;
    }
    const [a2, o2] = this.parentDimensions;
    this.setDims(e2 * a2 / s2, i2 * o2 / n2);
    this._uiManager.enableWaiting(false);
    const l2 = __privateSet(this, _La, document.createElement("canvas"));
    l2.setAttribute("role", "img");
    this.addContainer(l2);
    this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && !this.annotationElementId || (t2.hidden = false);
    __privateMethod(this, _StampEditor_instances, ja_fn).call(this, e2, i2);
    __privateMethod(this, _StampEditor_instances, oa_fn2).call(this);
    if (!__privateGet(this, _Ba)) {
      this.parent.addUndoableEditor(this);
      __privateSet(this, _Ba, true);
    }
    this._reportTelemetry({
      action: "inserted_image"
    });
    __privateGet(this, _Fa) && l2.setAttribute("aria-label", __privateGet(this, _Fa));
  };
  Ga_fn = function(t2, e2) {
    var _a4;
    const [i2, s2] = this.parentDimensions;
    this.width = t2 / i2;
    this.height = e2 / s2;
    ((_a4 = this._initialOptions) == null ? void 0 : _a4.isCentered) ? this.center() : this.fixAndSetPosition();
    this._initialOptions = null;
    null !== __privateGet(this, _Oa) && clearTimeout(__privateGet(this, _Oa));
    __privateSet(this, _Oa, setTimeout(() => {
      __privateSet(this, _Oa, null);
      __privateMethod(this, _StampEditor_instances, ja_fn).call(this, t2, e2);
    }, 200));
  };
  Wa_fn = function(t2, e2) {
    const { width: i2, height: s2 } = __privateGet(this, _ka);
    let n2 = i2, r2 = s2, a2 = __privateGet(this, _ka);
    for (; n2 > 2 * t2 || r2 > 2 * e2; ) {
      const i3 = n2, s3 = r2;
      n2 > 2 * t2 && (n2 = n2 >= 16384 ? Math.floor(n2 / 2) - 1 : Math.ceil(n2 / 2));
      r2 > 2 * e2 && (r2 = r2 >= 16384 ? Math.floor(r2 / 2) - 1 : Math.ceil(r2 / 2));
      const o2 = new OffscreenCanvas(n2, r2);
      o2.getContext("2d").drawImage(a2, 0, 0, i3, s3, 0, 0, n2, r2);
      a2 = o2.transferToImageBitmap();
    }
    return a2;
  };
  ja_fn = function(t2, e2) {
    const i2 = new OutputScale(), s2 = Math.ceil(t2 * i2.sx), n2 = Math.ceil(e2 * i2.sy), r2 = __privateGet(this, _La);
    if (!r2 || r2.width === s2 && r2.height === n2) return;
    r2.width = s2;
    r2.height = n2;
    const a2 = __privateGet(this, _Na) ? __privateGet(this, _ka) : __privateMethod(this, _StampEditor_instances, Wa_fn).call(this, s2, n2), o2 = r2.getContext("2d");
    o2.filter = this._uiManager.hcmFilter;
    o2.drawImage(a2, 0, 0, a2.width, a2.height, 0, 0, s2, n2);
  };
  Va_fn = function(t2) {
    if (t2) {
      if (__privateGet(this, _Na)) {
        const t4 = this._uiManager.imageManager.getSvgUrl(__privateGet(this, _Pa));
        if (t4) return t4;
      }
      const t3 = document.createElement("canvas");
      ({ width: t3.width, height: t3.height } = __privateGet(this, _ka));
      t3.getContext("2d").drawImage(__privateGet(this, _ka), 0, 0);
      return t3.toDataURL();
    }
    if (__privateGet(this, _Na)) {
      const [t3, e2] = this.pageDimensions, i2 = Math.round(this.width * t3 * PixelsPerInch.PDF_TO_CSS_UNITS), s2 = Math.round(this.height * e2 * PixelsPerInch.PDF_TO_CSS_UNITS), n2 = new OffscreenCanvas(i2, s2);
      n2.getContext("2d").drawImage(__privateGet(this, _ka), 0, 0, __privateGet(this, _ka).width, __privateGet(this, _ka).height, 0, 0, i2, s2);
      return n2.transferToImageBitmap();
    }
    return structuredClone(__privateGet(this, _ka));
  };
  oa_fn2 = function() {
    if (this._uiManager._signal) {
      __privateSet(this, _Jr2, new ResizeObserver((t2) => {
        const e2 = t2[0].contentRect;
        e2.width && e2.height && __privateMethod(this, _StampEditor_instances, Ga_fn).call(this, e2.width, e2.height);
      }));
      __privateGet(this, _Jr2).observe(this.div);
      this._uiManager._signal.addEventListener("abort", () => {
        var _a4;
        (_a4 = __privateGet(this, _Jr2)) == null ? void 0 : _a4.disconnect();
        __privateSet(this, _Jr2, null);
      }, {
        once: true
      });
    }
  };
  vn_fn3 = function(t2) {
    var _a4;
    const { rect: e2, pageIndex: i2, accessibilityData: { altText: s2 } } = this._initialData, n2 = t2.rect.every((t3, i3) => Math.abs(t3 - e2[i3]) < 1), r2 = t2.pageIndex === i2, a2 = (((_a4 = t2.accessibilityData) == null ? void 0 : _a4.alt) || "") === s2;
    return {
      isSame: n2 && r2 && a2,
      isSameAltText: a2
    };
  };
  __publicField(_StampEditor, "_type", "stamp");
  __publicField(_StampEditor, "_editorType", f.STAMP);
  let StampEditor = _StampEditor;
  const _AnnotationEditorLayer = class _AnnotationEditorLayer {
    constructor({ uiManager: t2, pageIndex: e2, div: i2, structTreeLayer: s2, accessibilityManager: n2, annotationLayer: r2, drawLayer: a2, textLayer: o2, viewport: l2, l10n: h2 }) {
      __privateAdd(this, _AnnotationEditorLayer_instances);
      __privateAdd(this, _en2);
      __privateAdd(this, _$a, false);
      __privateAdd(this, _qa, null);
      __privateAdd(this, _Xa, null);
      __privateAdd(this, _Ka, null);
      __privateAdd(this, _Ya, /* @__PURE__ */ new Map());
      __privateAdd(this, _Qa, false);
      __privateAdd(this, _Ja, false);
      __privateAdd(this, _Za, false);
      __privateAdd(this, _to, null);
      __privateAdd(this, _eo, null);
      __privateAdd(this, _f3);
      const c2 = [
        ...__privateGet(_AnnotationEditorLayer, _U2).values()
      ];
      if (!_AnnotationEditorLayer._initialized) {
        _AnnotationEditorLayer._initialized = true;
        for (const e3 of c2) e3.initialize(h2, t2);
      }
      t2.registerEditorTypes(c2);
      __privateSet(this, _f3, t2);
      this.pageIndex = e2;
      this.div = i2;
      __privateSet(this, _en2, n2);
      __privateSet(this, _qa, r2);
      this.viewport = l2;
      __privateSet(this, _to, o2);
      this.drawLayer = a2;
      this._structTree = s2;
      __privateGet(this, _f3).addLayer(this);
    }
    get isEmpty() {
      return 0 === __privateGet(this, _Ya).size;
    }
    get isInvisible() {
      return this.isEmpty && __privateGet(this, _f3).getMode() === f.NONE;
    }
    updateToolbar(t2) {
      __privateGet(this, _f3).updateToolbar(t2);
    }
    updateMode(t2 = __privateGet(this, _f3).getMode()) {
      __privateMethod(this, _AnnotationEditorLayer_instances, io_fn).call(this);
      switch (t2) {
        case f.NONE:
          this.disableTextSelection();
          this.togglePointerEvents(false);
          this.toggleAnnotationLayerPointerEvents(true);
          this.disableClick();
          return;
        case f.INK:
          this.addInkEditorIfNeeded(false);
          this.disableTextSelection();
          this.togglePointerEvents(true);
          this.disableClick();
          break;
        case f.HIGHLIGHT:
          this.enableTextSelection();
          this.togglePointerEvents(false);
          this.disableClick();
          break;
        default:
          this.disableTextSelection();
          this.togglePointerEvents(true);
          this.enableClick();
      }
      this.toggleAnnotationLayerPointerEvents(false);
      const { classList: e2 } = this.div;
      for (const i2 of __privateGet(_AnnotationEditorLayer, _U2).values()) e2.toggle(`${i2._type}Editing`, t2 === i2._editorType);
      this.div.hidden = false;
    }
    hasTextLayer(t2) {
      var _a4;
      return t2 === ((_a4 = __privateGet(this, _to)) == null ? void 0 : _a4.div);
    }
    addInkEditorIfNeeded(t2) {
      if (__privateGet(this, _f3).getMode() !== f.INK) return;
      if (!t2) {
        for (const t3 of __privateGet(this, _Ya).values()) if (t3.isEmpty()) {
          t3.setInBackground();
          return;
        }
      }
      this.createAndAddNewEditor({
        offsetX: 0,
        offsetY: 0
      }, false).setInBackground();
    }
    setEditingState(t2) {
      __privateGet(this, _f3).setEditingState(t2);
    }
    addCommands(t2) {
      __privateGet(this, _f3).addCommands(t2);
    }
    toggleDrawing(t2 = false) {
      this.div.classList.toggle("drawing", !t2);
    }
    togglePointerEvents(t2 = false) {
      this.div.classList.toggle("disabled", !t2);
    }
    toggleAnnotationLayerPointerEvents(t2 = false) {
      var _a4;
      (_a4 = __privateGet(this, _qa)) == null ? void 0 : _a4.div.classList.toggle("disabled", !t2);
    }
    async enable() {
      this.div.tabIndex = 0;
      this.togglePointerEvents(true);
      const t2 = /* @__PURE__ */ new Set();
      for (const e3 of __privateGet(this, _Ya).values()) {
        e3.enableEditing();
        e3.show(true);
        if (e3.annotationElementId) {
          __privateGet(this, _f3).removeChangedExistingAnnotation(e3);
          t2.add(e3.annotationElementId);
        }
      }
      if (!__privateGet(this, _qa)) return;
      const e2 = __privateGet(this, _qa).getEditableAnnotations();
      for (const i2 of e2) {
        i2.hide();
        if (__privateGet(this, _f3).isDeletedAnnotationElement(i2.data.id)) continue;
        if (t2.has(i2.data.id)) continue;
        const e3 = await this.deserialize(i2);
        if (e3) {
          this.addOrRebuild(e3);
          e3.enableEditing();
        }
      }
    }
    disable() {
      var _a4;
      __privateSet(this, _Za, true);
      this.div.tabIndex = -1;
      this.togglePointerEvents(false);
      const t2 = /* @__PURE__ */ new Map(), e2 = /* @__PURE__ */ new Map();
      for (const i3 of __privateGet(this, _Ya).values()) {
        i3.disableEditing();
        if (i3.annotationElementId) if (null === i3.serialize()) {
          e2.set(i3.annotationElementId, i3);
          (_a4 = this.getEditableAnnotation(i3.annotationElementId)) == null ? void 0 : _a4.show();
          i3.remove();
        } else t2.set(i3.annotationElementId, i3);
      }
      if (__privateGet(this, _qa)) {
        const i3 = __privateGet(this, _qa).getEditableAnnotations();
        for (const s2 of i3) {
          const { id: i4 } = s2.data;
          if (__privateGet(this, _f3).isDeletedAnnotationElement(i4)) continue;
          let n2 = e2.get(i4);
          if (n2) {
            n2.resetAnnotationElement(s2);
            n2.show(false);
            s2.show();
          } else {
            n2 = t2.get(i4);
            if (n2) {
              __privateGet(this, _f3).addChangedExistingAnnotation(n2);
              n2.renderAnnotationElement(s2) && n2.show(false);
            }
            s2.show();
          }
        }
      }
      __privateMethod(this, _AnnotationEditorLayer_instances, io_fn).call(this);
      this.isEmpty && (this.div.hidden = true);
      const { classList: i2 } = this.div;
      for (const t3 of __privateGet(_AnnotationEditorLayer, _U2).values()) i2.remove(`${t3._type}Editing`);
      this.disableTextSelection();
      this.toggleAnnotationLayerPointerEvents(true);
      __privateSet(this, _Za, false);
    }
    getEditableAnnotation(t2) {
      var _a4;
      return ((_a4 = __privateGet(this, _qa)) == null ? void 0 : _a4.getEditableAnnotation(t2)) || null;
    }
    setActiveEditor(t2) {
      __privateGet(this, _f3).getActive() !== t2 && __privateGet(this, _f3).setActiveEditor(t2);
    }
    enableTextSelection() {
      var _a4;
      this.div.tabIndex = -1;
      if (((_a4 = __privateGet(this, _to)) == null ? void 0 : _a4.div) && !__privateGet(this, _eo)) {
        __privateSet(this, _eo, new AbortController());
        const t2 = __privateGet(this, _f3).combinedSignal(__privateGet(this, _eo));
        __privateGet(this, _to).div.addEventListener("pointerdown", __privateMethod(this, _AnnotationEditorLayer_instances, so_fn).bind(this), {
          signal: t2
        });
        __privateGet(this, _to).div.classList.add("highlighting");
      }
    }
    disableTextSelection() {
      var _a4;
      this.div.tabIndex = 0;
      if (((_a4 = __privateGet(this, _to)) == null ? void 0 : _a4.div) && __privateGet(this, _eo)) {
        __privateGet(this, _eo).abort();
        __privateSet(this, _eo, null);
        __privateGet(this, _to).div.classList.remove("highlighting");
      }
    }
    enableClick() {
      if (__privateGet(this, _Xa)) return;
      __privateSet(this, _Xa, new AbortController());
      const t2 = __privateGet(this, _f3).combinedSignal(__privateGet(this, _Xa));
      this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
        signal: t2
      });
      this.div.addEventListener("pointerup", this.pointerup.bind(this), {
        signal: t2
      });
    }
    disableClick() {
      var _a4;
      (_a4 = __privateGet(this, _Xa)) == null ? void 0 : _a4.abort();
      __privateSet(this, _Xa, null);
    }
    attach(t2) {
      __privateGet(this, _Ya).set(t2.id, t2);
      const { annotationElementId: e2 } = t2;
      e2 && __privateGet(this, _f3).isDeletedAnnotationElement(e2) && __privateGet(this, _f3).removeDeletedAnnotationElement(t2);
    }
    detach(t2) {
      var _a4;
      __privateGet(this, _Ya).delete(t2.id);
      (_a4 = __privateGet(this, _en2)) == null ? void 0 : _a4.removePointerInTextLayer(t2.contentDiv);
      !__privateGet(this, _Za) && t2.annotationElementId && __privateGet(this, _f3).addDeletedAnnotationElement(t2);
    }
    remove(t2) {
      this.detach(t2);
      __privateGet(this, _f3).removeEditor(t2);
      t2.div.remove();
      t2.isAttachedToDOM = false;
      __privateGet(this, _Ja) || this.addInkEditorIfNeeded(false);
    }
    changeParent(t2) {
      var _a4;
      if (t2.parent !== this) {
        if (t2.parent && t2.annotationElementId) {
          __privateGet(this, _f3).addDeletedAnnotationElement(t2.annotationElementId);
          AnnotationEditor.deleteAnnotationElement(t2);
          t2.annotationElementId = null;
        }
        this.attach(t2);
        (_a4 = t2.parent) == null ? void 0 : _a4.detach(t2);
        t2.setParent(this);
        if (t2.div && t2.isAttachedToDOM) {
          t2.div.remove();
          this.div.append(t2.div);
        }
      }
    }
    add(t2) {
      if (t2.parent !== this || !t2.isAttachedToDOM) {
        this.changeParent(t2);
        __privateGet(this, _f3).addEditor(t2);
        this.attach(t2);
        if (!t2.isAttachedToDOM) {
          const e2 = t2.render();
          this.div.append(e2);
          t2.isAttachedToDOM = true;
        }
        t2.fixAndSetPosition();
        t2.onceAdded();
        __privateGet(this, _f3).addToAnnotationStorage(t2);
        t2._reportTelemetry(t2.telemetryInitialData);
      }
    }
    moveEditorInDOM(t2) {
      var _a4;
      if (!t2.isAttachedToDOM) return;
      const { activeElement: e2 } = document;
      if (t2.div.contains(e2) && !__privateGet(this, _Ka)) {
        t2._focusEventsAllowed = false;
        __privateSet(this, _Ka, setTimeout(() => {
          __privateSet(this, _Ka, null);
          if (t2.div.contains(document.activeElement)) t2._focusEventsAllowed = true;
          else {
            t2.div.addEventListener("focusin", () => {
              t2._focusEventsAllowed = true;
            }, {
              once: true,
              signal: __privateGet(this, _f3)._signal
            });
            e2.focus();
          }
        }, 0));
      }
      t2._structTreeParentId = (_a4 = __privateGet(this, _en2)) == null ? void 0 : _a4.moveElementInDOM(this.div, t2.div, t2.contentDiv, true);
    }
    addOrRebuild(t2) {
      if (t2.needsToBeRebuilt()) {
        t2.parent || (t2.parent = this);
        t2.rebuild();
        t2.show();
      } else this.add(t2);
    }
    addUndoableEditor(t2) {
      this.addCommands({
        cmd: () => t2._uiManager.rebuild(t2),
        undo: () => {
          t2.remove();
        },
        mustExec: false
      });
    }
    getNextId() {
      return __privateGet(this, _f3).getId();
    }
    combinedSignal(t2) {
      return __privateGet(this, _f3).combinedSignal(t2);
    }
    canCreateNewEmptyEditor() {
      var _a4;
      return (_a4 = __privateGet(this, _AnnotationEditorLayer_instances, no_get)) == null ? void 0 : _a4.canCreateNewEmptyEditor();
    }
    pasteEditor(t2, e2) {
      __privateGet(this, _f3).updateToolbar(t2);
      __privateGet(this, _f3).updateMode(t2);
      const { offsetX: i2, offsetY: s2 } = __privateMethod(this, _AnnotationEditorLayer_instances, ao_fn).call(this), n2 = this.getNextId(), r2 = __privateMethod(this, _AnnotationEditorLayer_instances, ro_fn).call(this, {
        parent: this,
        id: n2,
        x: i2,
        y: s2,
        uiManager: __privateGet(this, _f3),
        isCentered: true,
        ...e2
      });
      r2 && this.add(r2);
    }
    async deserialize(t2) {
      var _a4;
      return await ((_a4 = __privateGet(_AnnotationEditorLayer, _U2).get(t2.annotationType ?? t2.annotationEditorType)) == null ? void 0 : _a4.deserialize(t2, this, __privateGet(this, _f3))) || null;
    }
    createAndAddNewEditor(t2, e2, i2 = {}) {
      const s2 = this.getNextId(), n2 = __privateMethod(this, _AnnotationEditorLayer_instances, ro_fn).call(this, {
        parent: this,
        id: s2,
        x: t2.offsetX,
        y: t2.offsetY,
        uiManager: __privateGet(this, _f3),
        isCentered: e2,
        ...i2
      });
      n2 && this.add(n2);
      return n2;
    }
    addNewEditor() {
      this.createAndAddNewEditor(__privateMethod(this, _AnnotationEditorLayer_instances, ao_fn).call(this), true);
    }
    setSelected(t2) {
      __privateGet(this, _f3).setSelected(t2);
    }
    toggleSelected(t2) {
      __privateGet(this, _f3).toggleSelected(t2);
    }
    unselect(t2) {
      __privateGet(this, _f3).unselect(t2);
    }
    pointerup(t2) {
      const { isMac: e2 } = util_FeatureTest.platform;
      if (!(0 !== t2.button || t2.ctrlKey && e2) && t2.target === this.div && __privateGet(this, _Qa)) {
        __privateSet(this, _Qa, false);
        __privateGet(this, _$a) ? __privateGet(this, _f3).getMode() !== f.STAMP ? this.createAndAddNewEditor(t2, false) : __privateGet(this, _f3).unselectAll() : __privateSet(this, _$a, true);
      }
    }
    pointerdown(t2) {
      __privateGet(this, _f3).getMode() === f.HIGHLIGHT && this.enableTextSelection();
      if (__privateGet(this, _Qa)) {
        __privateSet(this, _Qa, false);
        return;
      }
      const { isMac: e2 } = util_FeatureTest.platform;
      if (0 !== t2.button || t2.ctrlKey && e2) return;
      if (t2.target !== this.div) return;
      __privateSet(this, _Qa, true);
      const i2 = __privateGet(this, _f3).getActive();
      __privateSet(this, _$a, !i2 || i2.isEmpty());
    }
    findNewParent(t2, e2, i2) {
      const s2 = __privateGet(this, _f3).findParent(e2, i2);
      if (null === s2 || s2 === this) return false;
      s2.changeParent(t2);
      return true;
    }
    destroy() {
      var _a4, _b2;
      if (((_a4 = __privateGet(this, _f3).getActive()) == null ? void 0 : _a4.parent) === this) {
        __privateGet(this, _f3).commitOrRemove();
        __privateGet(this, _f3).setActiveEditor(null);
      }
      if (__privateGet(this, _Ka)) {
        clearTimeout(__privateGet(this, _Ka));
        __privateSet(this, _Ka, null);
      }
      for (const t2 of __privateGet(this, _Ya).values()) {
        (_b2 = __privateGet(this, _en2)) == null ? void 0 : _b2.removePointerInTextLayer(t2.contentDiv);
        t2.setParent(null);
        t2.isAttachedToDOM = false;
        t2.div.remove();
      }
      this.div = null;
      __privateGet(this, _Ya).clear();
      __privateGet(this, _f3).removeLayer(this);
    }
    render({ viewport: t2 }) {
      this.viewport = t2;
      setLayerDimensions(this.div, t2);
      for (const t3 of __privateGet(this, _f3).getEditors(this.pageIndex)) {
        this.add(t3);
        t3.rebuild();
      }
      this.updateMode();
    }
    update({ viewport: t2 }) {
      __privateGet(this, _f3).commitOrRemove();
      __privateMethod(this, _AnnotationEditorLayer_instances, io_fn).call(this);
      const e2 = this.viewport.rotation, i2 = t2.rotation;
      this.viewport = t2;
      setLayerDimensions(this.div, {
        rotation: i2
      });
      if (e2 !== i2) for (const t3 of __privateGet(this, _Ya).values()) t3.rotate(i2);
      this.addInkEditorIfNeeded(false);
    }
    get pageDimensions() {
      const { pageWidth: t2, pageHeight: e2 } = this.viewport.rawDims;
      return [
        t2,
        e2
      ];
    }
    get scale() {
      return __privateGet(this, _f3).viewParameters.realScale;
    }
  };
  _en2 = new WeakMap();
  _$a = new WeakMap();
  _qa = new WeakMap();
  _Xa = new WeakMap();
  _Ka = new WeakMap();
  _Ya = new WeakMap();
  _Qa = new WeakMap();
  _Ja = new WeakMap();
  _Za = new WeakMap();
  _to = new WeakMap();
  _eo = new WeakMap();
  _f3 = new WeakMap();
  _U2 = new WeakMap();
  _AnnotationEditorLayer_instances = new WeakSet();
  so_fn = function(t2) {
    __privateGet(this, _f3).unselectAll();
    const { target: e2 } = t2;
    if (e2 === __privateGet(this, _to).div || ("img" === e2.getAttribute("role") || e2.classList.contains("endOfContent")) && __privateGet(this, _to).div.contains(e2)) {
      const { isMac: e3 } = util_FeatureTest.platform;
      if (0 !== t2.button || t2.ctrlKey && e3) return;
      __privateGet(this, _f3).showAllEditors("highlight", true, true);
      __privateGet(this, _to).div.classList.add("free");
      this.toggleDrawing();
      HighlightEditor.startHighlighting(this, "ltr" === __privateGet(this, _f3).direction, {
        target: __privateGet(this, _to).div,
        x: t2.x,
        y: t2.y
      });
      __privateGet(this, _to).div.addEventListener("pointerup", () => {
        __privateGet(this, _to).div.classList.remove("free");
        this.toggleDrawing(true);
      }, {
        once: true,
        signal: __privateGet(this, _f3)._signal
      });
      t2.preventDefault();
    }
  };
  no_get = function() {
    return __privateGet(_AnnotationEditorLayer, _U2).get(__privateGet(this, _f3).getMode());
  };
  ro_fn = function(t2) {
    const e2 = __privateGet(this, _AnnotationEditorLayer_instances, no_get);
    return e2 ? new e2.prototype.constructor(t2) : null;
  };
  ao_fn = function() {
    const { x: t2, y: e2, width: i2, height: s2 } = this.div.getBoundingClientRect(), n2 = Math.max(0, t2), r2 = Math.max(0, e2), a2 = (n2 + Math.min(window.innerWidth, t2 + i2)) / 2 - t2, o2 = (r2 + Math.min(window.innerHeight, e2 + s2)) / 2 - e2, [l2, h2] = this.viewport.rotation % 180 == 0 ? [
      a2,
      o2
    ] : [
      o2,
      a2
    ];
    return {
      offsetX: l2,
      offsetY: h2
    };
  };
  io_fn = function() {
    __privateSet(this, _Ja, true);
    for (const t2 of __privateGet(this, _Ya).values()) t2.isEmpty() && t2.remove();
    __privateSet(this, _Ja, false);
  };
  __publicField(_AnnotationEditorLayer, "_initialized", false);
  __privateAdd(_AnnotationEditorLayer, _U2, new Map([
    FreeTextEditor,
    InkEditor,
    StampEditor,
    HighlightEditor
  ].map((t2) => [
    t2._editorType,
    t2
  ])));
  let AnnotationEditorLayer = _AnnotationEditorLayer;
  const _DrawLayer = class _DrawLayer {
    constructor({ pageIndex: t2 }) {
      __privateAdd(this, _DrawLayer_instances);
      __privateAdd(this, _Ls2, null);
      __privateAdd(this, _y5, 0);
      __privateAdd(this, _oo, /* @__PURE__ */ new Map());
      __privateAdd(this, _lo, /* @__PURE__ */ new Map());
      this.pageIndex = t2;
    }
    setParent(t2) {
      if (__privateGet(this, _Ls2)) {
        if (__privateGet(this, _Ls2) !== t2) {
          if (__privateGet(this, _oo).size > 0) for (const e2 of __privateGet(this, _oo).values()) {
            e2.remove();
            t2.append(e2);
          }
          __privateSet(this, _Ls2, t2);
        }
      } else __privateSet(this, _Ls2, t2);
    }
    static get _svgFactory() {
      return shadow(this, "_svgFactory", new DOMSVGFactory());
    }
    draw(t2, e2, i2, s2 = false) {
      const n2 = __privateWrapper(this, _y5)._++, r2 = __privateMethod(this, _DrawLayer_instances, co_fn).call(this, t2.box);
      r2.classList.add(...t2.classNamesForDrawing);
      const a2 = _DrawLayer._svgFactory.createElement("defs");
      r2.append(a2);
      const o2 = _DrawLayer._svgFactory.createElement("path");
      a2.append(o2);
      const l2 = `path_p${this.pageIndex}_${n2}`;
      o2.setAttribute("id", l2);
      o2.setAttribute("d", t2.toSVGPath());
      s2 && __privateGet(this, _lo).set(n2, o2);
      const h2 = __privateMethod(this, _DrawLayer_instances, do_fn).call(this, a2, l2), c2 = _DrawLayer._svgFactory.createElement("use");
      r2.append(c2);
      r2.setAttribute("fill", e2);
      r2.setAttribute("fill-opacity", i2);
      c2.setAttribute("href", `#${l2}`);
      __privateGet(this, _oo).set(n2, r2);
      return {
        id: n2,
        clipPathId: `url(#${h2})`
      };
    }
    drawOutline(t2) {
      const e2 = __privateWrapper(this, _y5)._++, i2 = __privateMethod(this, _DrawLayer_instances, co_fn).call(this, t2.box);
      i2.classList.add(...t2.classNamesForOutlining);
      const s2 = _DrawLayer._svgFactory.createElement("defs");
      i2.append(s2);
      const n2 = _DrawLayer._svgFactory.createElement("path");
      s2.append(n2);
      const r2 = `path_p${this.pageIndex}_${e2}`;
      n2.setAttribute("id", r2);
      n2.setAttribute("d", t2.toSVGPath());
      n2.setAttribute("vector-effect", "non-scaling-stroke");
      let a2;
      if (t2.mustRemoveSelfIntersections) {
        const t3 = _DrawLayer._svgFactory.createElement("mask");
        s2.append(t3);
        a2 = `mask_p${this.pageIndex}_${e2}`;
        t3.setAttribute("id", a2);
        t3.setAttribute("maskUnits", "objectBoundingBox");
        const i3 = _DrawLayer._svgFactory.createElement("rect");
        t3.append(i3);
        i3.setAttribute("width", "1");
        i3.setAttribute("height", "1");
        i3.setAttribute("fill", "white");
        const n3 = _DrawLayer._svgFactory.createElement("use");
        t3.append(n3);
        n3.setAttribute("href", `#${r2}`);
        n3.setAttribute("stroke", "none");
        n3.setAttribute("fill", "black");
        n3.setAttribute("fill-rule", "nonzero");
        n3.classList.add("mask");
      }
      const o2 = _DrawLayer._svgFactory.createElement("use");
      i2.append(o2);
      o2.setAttribute("href", `#${r2}`);
      a2 && o2.setAttribute("mask", `url(#${a2})`);
      const l2 = o2.cloneNode();
      i2.append(l2);
      o2.classList.add("mainOutline");
      l2.classList.add("secondaryOutline");
      __privateGet(this, _oo).set(e2, i2);
      return e2;
    }
    finalizeLine(t2, e2) {
      const i2 = __privateGet(this, _lo).get(t2);
      __privateGet(this, _lo).delete(t2);
      this.updateBox(t2, e2.box);
      i2.setAttribute("d", e2.toSVGPath());
    }
    updateLine(t2, e2) {
      __privateGet(this, _oo).get(t2).firstChild.firstChild.setAttribute("d", e2.toSVGPath());
    }
    updatePath(t2, e2) {
      __privateGet(this, _lo).get(t2).setAttribute("d", e2.toSVGPath());
    }
    updateBox(t2, e2) {
      var _a4;
      __privateMethod(_a4 = _DrawLayer, _DrawLayer_static, ho_fn).call(_a4, __privateGet(this, _oo).get(t2), e2);
    }
    show(t2, e2) {
      __privateGet(this, _oo).get(t2).classList.toggle("hidden", !e2);
    }
    rotate(t2, e2) {
      __privateGet(this, _oo).get(t2).setAttribute("data-main-rotation", e2);
    }
    changeColor(t2, e2) {
      __privateGet(this, _oo).get(t2).setAttribute("fill", e2);
    }
    changeOpacity(t2, e2) {
      __privateGet(this, _oo).get(t2).setAttribute("fill-opacity", e2);
    }
    addClass(t2, e2) {
      __privateGet(this, _oo).get(t2).classList.add(e2);
    }
    removeClass(t2, e2) {
      __privateGet(this, _oo).get(t2).classList.remove(e2);
    }
    getSVGRoot(t2) {
      return __privateGet(this, _oo).get(t2);
    }
    remove(t2) {
      __privateGet(this, _lo).delete(t2);
      if (null !== __privateGet(this, _Ls2)) {
        __privateGet(this, _oo).get(t2).remove();
        __privateGet(this, _oo).delete(t2);
      }
    }
    destroy() {
      __privateSet(this, _Ls2, null);
      for (const t2 of __privateGet(this, _oo).values()) t2.remove();
      __privateGet(this, _oo).clear();
      __privateGet(this, _lo).clear();
    }
  };
  _Ls2 = new WeakMap();
  _y5 = new WeakMap();
  _oo = new WeakMap();
  _lo = new WeakMap();
  _DrawLayer_static = new WeakSet();
  ho_fn = function(t2, { x: e2 = 0, y: i2 = 0, width: s2 = 1, height: n2 = 1 } = {}) {
    const { style: r2 } = t2;
    r2.top = 100 * i2 + "%";
    r2.left = 100 * e2 + "%";
    r2.width = 100 * s2 + "%";
    r2.height = 100 * n2 + "%";
  };
  _DrawLayer_instances = new WeakSet();
  co_fn = function(t2) {
    var _a4;
    const e2 = _DrawLayer._svgFactory.create(1, 1, true);
    __privateGet(this, _Ls2).append(e2);
    e2.setAttribute("aria-hidden", true);
    __privateMethod(_a4 = _DrawLayer, _DrawLayer_static, ho_fn).call(_a4, e2, t2);
    return e2;
  };
  do_fn = function(t2, e2) {
    const i2 = _DrawLayer._svgFactory.createElement("clipPath");
    t2.append(i2);
    const s2 = `clip_${e2}`;
    i2.setAttribute("id", s2);
    i2.setAttribute("clipPathUnits", "objectBoundingBox");
    const n2 = _DrawLayer._svgFactory.createElement("use");
    i2.append(n2);
    n2.setAttribute("href", `#${e2}`);
    n2.classList.add("clip");
    return s2;
  };
  __privateAdd(_DrawLayer, _DrawLayer_static);
  let DrawLayer = _DrawLayer;
  te = __webpack_exports__.AbortException;
  ee = __webpack_exports__.AnnotationEditorLayer;
  ie = __webpack_exports__.AnnotationEditorParamsType;
  se = __webpack_exports__.AnnotationEditorType;
  ne = __webpack_exports__.AnnotationEditorUIManager;
  re = __webpack_exports__.AnnotationLayer;
  ae = __webpack_exports__.AnnotationMode;
  oe = __webpack_exports__.ColorPicker;
  le = __webpack_exports__.DOMSVGFactory;
  he = __webpack_exports__.DrawLayer;
  ce = __webpack_exports__.FeatureTest;
  de = __webpack_exports__.GlobalWorkerOptions;
  ue = __webpack_exports__.ImageKind;
  pe = __webpack_exports__.InvalidPDFException;
  ge = __webpack_exports__.MissingPDFException;
  fe = __webpack_exports__.OPS;
  me = __webpack_exports__.OutputScale;
  be = __webpack_exports__.PDFDataRangeTransport;
  ve = __webpack_exports__.PDFDateString;
  ye = __webpack_exports__.PDFWorker;
  Ae = __webpack_exports__.PasswordResponses;
  we = __webpack_exports__.PermissionFlag;
  xe = __webpack_exports__.PixelsPerInch;
  _e = __webpack_exports__.RenderingCancelledException;
  Ee = __webpack_exports__.TextLayer;
  Ce = __webpack_exports__.UnexpectedResponseException;
  Se = __webpack_exports__.Util;
  Te = __webpack_exports__.VerbosityLevel;
  Me = __webpack_exports__.XfaLayer;
  ke = __webpack_exports__.build;
  Pe = __webpack_exports__.createValidAbsoluteUrl;
  Re = __webpack_exports__.fetchData;
  De = __webpack_exports__.getDocument;
  Ie = __webpack_exports__.getFilenameFromUrl;
  Fe = __webpack_exports__.getPdfFilenameFromUrl;
  Le = __webpack_exports__.getXfaPageViewport;
  Oe = __webpack_exports__.isDataScheme;
  Ne = __webpack_exports__.isPdfFile;
  Be = __webpack_exports__.noContextMenu;
  He = __webpack_exports__.normalizeUnicode;
  Ue = __webpack_exports__.setLayerDimensions;
  ze = __webpack_exports__.shadow;
  je = __webpack_exports__.version;
});
export {
  te as AbortException,
  ee as AnnotationEditorLayer,
  ie as AnnotationEditorParamsType,
  se as AnnotationEditorType,
  ne as AnnotationEditorUIManager,
  re as AnnotationLayer,
  ae as AnnotationMode,
  oe as ColorPicker,
  le as DOMSVGFactory,
  he as DrawLayer,
  ce as FeatureTest,
  de as GlobalWorkerOptions,
  ue as ImageKind,
  pe as InvalidPDFException,
  ge as MissingPDFException,
  fe as OPS,
  me as OutputScale,
  be as PDFDataRangeTransport,
  ve as PDFDateString,
  ye as PDFWorker,
  Ae as PasswordResponses,
  we as PermissionFlag,
  xe as PixelsPerInch,
  _e as RenderingCancelledException,
  Ee as TextLayer,
  Ce as UnexpectedResponseException,
  Se as Util,
  Te as VerbosityLevel,
  Me as XfaLayer,
  __tla,
  ke as build,
  Pe as createValidAbsoluteUrl,
  Re as fetchData,
  De as getDocument,
  Ie as getFilenameFromUrl,
  Fe as getPdfFilenameFromUrl,
  Le as getXfaPageViewport,
  Oe as isDataScheme,
  Ne as isPdfFile,
  Be as noContextMenu,
  He as normalizeUnicode,
  Ue as setLayerDimensions,
  ze as shadow,
  je as version
};
