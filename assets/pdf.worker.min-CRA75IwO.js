var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
import { aq as global, __tla as __tla_0 } from "./use-llm-Kc_COJca.js";
import { aA as process$1, __tla as __tla_1 } from "./index-Bs2EL0Mm.js";
import { __tla as __tla_2 } from "./routes-Q3DgWzwS.js";
let bo;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_2;
    } catch {
    }
  })()
]).then(async () => {
  var _Util_static, A_fn, e_fn, _DeviceCmykCS_instances, t_fn, _CalGrayCS_instances, t_fn2, _i2, _a2, _r2, _s2, _n2, _o, _g, _I, _CalRGBCS_instances, c_fn, C_fn, h_fn, l_fn, B_fn, Q_fn, E_fn, u_fn, d_fn, t_fn3, _LabCS_instances, f_fn, p_fn, t_fn4, _FlateStream_instances, m_fn, _JpegStream_instances, y_fn, _a3, _w, _Parser_instances, b_fn, _D, _GlobalImageCache_instances, F_get, S_get, _k, _R, _PDFImage_instances, N_fn, _G, _x, _CipherTransformFactory_instances, U_fn, M_fn, L_fn, H_fn, J_fn, _StructTreeRoot_instances, v_fn, _StructTreeRoot_static, Y_fn, K_fn, T_fn, q_fn, _Catalog_instances, O_fn, P_fn, _W, _j, _Page_instances, X_fn, _PDFDocument_instances, Z_fn, _V, _MessageHandler_instances, __fn, $_fn, z_fn, AA_fn;
  var e = {
    9306: (e2, t2, i2) => {
      var a2 = i2(4901), r2 = i2(6823), s2 = TypeError;
      e2.exports = function(e3) {
        if (a2(e3)) return e3;
        throw new s2(r2(e3) + " is not a function");
      };
    },
    3506: (e2, t2, i2) => {
      var a2 = i2(3925), r2 = String, s2 = TypeError;
      e2.exports = function(e3) {
        if (a2(e3)) return e3;
        throw new s2("Can't set " + r2(e3) + " as a prototype");
      };
    },
    7080: (e2, t2, i2) => {
      var a2 = i2(4402).has;
      e2.exports = function(e3) {
        a2(e3);
        return e3;
      };
    },
    679: (e2, t2, i2) => {
      var a2 = i2(1625), r2 = TypeError;
      e2.exports = function(e3, t3) {
        if (a2(t3, e3)) return e3;
        throw new r2("Incorrect invocation");
      };
    },
    8551: (e2, t2, i2) => {
      var a2 = i2(34), r2 = String, s2 = TypeError;
      e2.exports = function(e3) {
        if (a2(e3)) return e3;
        throw new s2(r2(e3) + " is not an object");
      };
    },
    7811: (e2) => {
      e2.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
    },
    7394: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(6706), s2 = i2(2195), n2 = a2.ArrayBuffer, o2 = a2.TypeError;
      e2.exports = n2 && r2(n2.prototype, "byteLength", "get") || function(e3) {
        if ("ArrayBuffer" !== s2(e3)) throw new o2("ArrayBuffer expected");
        return e3.byteLength;
      };
    },
    3238: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(7476), s2 = i2(7394), n2 = a2.ArrayBuffer, o2 = n2 && n2.prototype, g2 = o2 && r2(o2.slice);
      e2.exports = function(e3) {
        if (0 !== s2(e3)) return false;
        if (!g2) return false;
        try {
          g2(e3, 0, 0);
          return false;
        } catch (e4) {
          return true;
        }
      };
    },
    5169: (e2, t2, i2) => {
      var a2 = i2(3238), r2 = TypeError;
      e2.exports = function(e3) {
        if (a2(e3)) throw new r2("ArrayBuffer is detached");
        return e3;
      };
    },
    5636: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(9504), s2 = i2(6706), n2 = i2(7696), o2 = i2(5169), g2 = i2(7394), c2 = i2(4483), C2 = i2(1548), h2 = a2.structuredClone, l2 = a2.ArrayBuffer, Q2 = a2.DataView, E2 = Math.min, u2 = l2.prototype, d2 = Q2.prototype, f2 = r2(u2.slice), p2 = s2(u2, "resizable", "get"), m2 = s2(u2, "maxByteLength", "get"), y2 = r2(d2.getInt8), w2 = r2(d2.setInt8);
      e2.exports = (C2 || c2) && function(e3, t3, i3) {
        var a3, r3 = g2(e3), s3 = void 0 === t3 ? r3 : n2(t3), u3 = !p2 || !p2(e3);
        o2(e3);
        if (C2) {
          e3 = h2(e3, {
            transfer: [
              e3
            ]
          });
          if (r3 === s3 && (i3 || u3)) return e3;
        }
        if (r3 >= s3 && (!i3 || u3)) a3 = f2(e3, 0, s3);
        else {
          var d3 = i3 && !u3 && m2 ? {
            maxByteLength: m2(e3)
          } : void 0;
          a3 = new l2(s3, d3);
          for (var b2 = new Q2(e3), D2 = new Q2(a3), S2 = E2(s3, r3), k2 = 0; k2 < S2; k2++) w2(D2, k2, y2(b2, k2));
        }
        C2 || c2(e3);
        return a3;
      };
    },
    4644: (e2, t2, i2) => {
      var a2, r2, s2, n2 = i2(7811), o2 = i2(3724), g2 = i2(4576), c2 = i2(4901), C2 = i2(34), h2 = i2(9297), l2 = i2(6955), Q2 = i2(6823), E2 = i2(6699), u2 = i2(6840), d2 = i2(2106), f2 = i2(1625), p2 = i2(2787), m2 = i2(2967), y2 = i2(8227), w2 = i2(3392), b2 = i2(1181), D2 = b2.enforce, S2 = b2.get, k2 = g2.Int8Array, R2 = k2 && k2.prototype, N2 = g2.Uint8ClampedArray, G2 = N2 && N2.prototype, x2 = k2 && p2(k2), U2 = R2 && p2(R2), M2 = Object.prototype, L2 = g2.TypeError, H2 = y2("toStringTag"), J2 = w2("TYPED_ARRAY_TAG"), v2 = "TypedArrayConstructor", Y2 = n2 && !!m2 && "Opera" !== l2(g2.opera), T2 = false, K2 = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      }, q2 = {
        BigInt64Array: 8,
        BigUint64Array: 8
      }, getTypedArrayConstructor = function(e3) {
        var t3 = p2(e3);
        if (C2(t3)) {
          var i3 = S2(t3);
          return i3 && h2(i3, v2) ? i3[v2] : getTypedArrayConstructor(t3);
        }
      }, isTypedArray = function(e3) {
        if (!C2(e3)) return false;
        var t3 = l2(e3);
        return h2(K2, t3) || h2(q2, t3);
      };
      for (a2 in K2) (s2 = (r2 = g2[a2]) && r2.prototype) ? D2(s2)[v2] = r2 : Y2 = false;
      for (a2 in q2) (s2 = (r2 = g2[a2]) && r2.prototype) && (D2(s2)[v2] = r2);
      if (!Y2 || !c2(x2) || x2 === Function.prototype) {
        x2 = function TypedArray() {
          throw new L2("Incorrect invocation");
        };
        if (Y2) for (a2 in K2) g2[a2] && m2(g2[a2], x2);
      }
      if (!Y2 || !U2 || U2 === M2) {
        U2 = x2.prototype;
        if (Y2) for (a2 in K2) g2[a2] && m2(g2[a2].prototype, U2);
      }
      Y2 && p2(G2) !== U2 && m2(G2, U2);
      if (o2 && !h2(U2, H2)) {
        T2 = true;
        d2(U2, H2, {
          configurable: true,
          get: function() {
            return C2(this) ? this[J2] : void 0;
          }
        });
        for (a2 in K2) g2[a2] && E2(g2[a2], J2, a2);
      }
      e2.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS: Y2,
        TYPED_ARRAY_TAG: T2 && J2,
        aTypedArray: function(e3) {
          if (isTypedArray(e3)) return e3;
          throw new L2("Target is not a typed array");
        },
        aTypedArrayConstructor: function(e3) {
          if (c2(e3) && (!m2 || f2(x2, e3))) return e3;
          throw new L2(Q2(e3) + " is not a typed array constructor");
        },
        exportTypedArrayMethod: function(e3, t3, i3, a3) {
          if (o2) {
            if (i3) for (var r3 in K2) {
              var s3 = g2[r3];
              if (s3 && h2(s3.prototype, e3)) try {
                delete s3.prototype[e3];
              } catch (i4) {
                try {
                  s3.prototype[e3] = t3;
                } catch (e4) {
                }
              }
            }
            U2[e3] && !i3 || u2(U2, e3, i3 ? t3 : Y2 && R2[e3] || t3, a3);
          }
        },
        exportTypedArrayStaticMethod: function(e3, t3, i3) {
          var a3, r3;
          if (o2) {
            if (m2) {
              if (i3) {
                for (a3 in K2) if ((r3 = g2[a3]) && h2(r3, e3)) try {
                  delete r3[e3];
                } catch (e4) {
                }
              }
              if (x2[e3] && !i3) return;
              try {
                return u2(x2, e3, i3 ? t3 : Y2 && x2[e3] || t3);
              } catch (e4) {
              }
            }
            for (a3 in K2) !(r3 = g2[a3]) || r3[e3] && !i3 || u2(r3, e3, t3);
          }
        },
        getTypedArrayConstructor,
        isView: function isView(e3) {
          if (!C2(e3)) return false;
          var t3 = l2(e3);
          return "DataView" === t3 || h2(K2, t3) || h2(q2, t3);
        },
        isTypedArray,
        TypedArray: x2,
        TypedArrayPrototype: U2
      };
    },
    5370: (e2, t2, i2) => {
      var a2 = i2(6198);
      e2.exports = function(e3, t3, i3) {
        for (var r2 = 0, s2 = arguments.length > 2 ? i3 : a2(t3), n2 = new e3(s2); s2 > r2; ) n2[r2] = t3[r2++];
        return n2;
      };
    },
    9617: (e2, t2, i2) => {
      var a2 = i2(5397), r2 = i2(5610), s2 = i2(6198), createMethod = function(e3) {
        return function(t3, i3, n2) {
          var o2 = a2(t3), g2 = s2(o2);
          if (0 === g2) return !e3 && -1;
          var c2, C2 = r2(n2, g2);
          if (e3 && i3 != i3) {
            for (; g2 > C2; ) if ((c2 = o2[C2++]) != c2) return true;
          } else for (; g2 > C2; C2++) if ((e3 || C2 in o2) && o2[C2] === i3) return e3 || C2 || 0;
          return !e3 && -1;
        };
      };
      e2.exports = {
        includes: createMethod(true),
        indexOf: createMethod(false)
      };
    },
    4527: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(4376), s2 = TypeError, n2 = Object.getOwnPropertyDescriptor, o2 = a2 && !function() {
        if (void 0 !== this) return true;
        try {
          Object.defineProperty([], "length", {
            writable: false
          }).length = 1;
        } catch (e3) {
          return e3 instanceof TypeError;
        }
      }();
      e2.exports = o2 ? function(e3, t3) {
        if (r2(e3) && !n2(e3, "length").writable) throw new s2("Cannot set read only .length");
        return e3.length = t3;
      } : function(e3, t3) {
        return e3.length = t3;
      };
    },
    7628: (e2, t2, i2) => {
      var a2 = i2(6198);
      e2.exports = function(e3, t3) {
        for (var i3 = a2(e3), r2 = new t3(i3), s2 = 0; s2 < i3; s2++) r2[s2] = e3[i3 - s2 - 1];
        return r2;
      };
    },
    9928: (e2, t2, i2) => {
      var a2 = i2(6198), r2 = i2(1291), s2 = RangeError;
      e2.exports = function(e3, t3, i3, n2) {
        var o2 = a2(e3), g2 = r2(i3), c2 = g2 < 0 ? o2 + g2 : g2;
        if (c2 >= o2 || c2 < 0) throw new s2("Incorrect index");
        for (var C2 = new t3(o2), h2 = 0; h2 < o2; h2++) C2[h2] = h2 === c2 ? n2 : e3[h2];
        return C2;
      };
    },
    6319: (e2, t2, i2) => {
      var a2 = i2(8551), r2 = i2(9539);
      e2.exports = function(e3, t3, i3, s2) {
        try {
          return s2 ? t3(a2(i3)[0], i3[1]) : t3(i3);
        } catch (t4) {
          r2(e3, "throw", t4);
        }
      };
    },
    2195: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = a2({}.toString), s2 = a2("".slice);
      e2.exports = function(e3) {
        return s2(r2(e3), 8, -1);
      };
    },
    6955: (e2, t2, i2) => {
      var a2 = i2(2140), r2 = i2(4901), s2 = i2(2195), n2 = i2(8227)("toStringTag"), o2 = Object, g2 = "Arguments" === s2(/* @__PURE__ */ function() {
        return arguments;
      }());
      e2.exports = a2 ? s2 : function(e3) {
        var t3, i3, a3;
        return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (i3 = function(e4, t4) {
          try {
            return e4[t4];
          } catch (e5) {
          }
        }(t3 = o2(e3), n2)) ? i3 : g2 ? s2(t3) : "Object" === (a3 = s2(t3)) && r2(t3.callee) ? "Arguments" : a3;
      };
    },
    7740: (e2, t2, i2) => {
      var a2 = i2(9297), r2 = i2(5031), s2 = i2(7347), n2 = i2(4913);
      e2.exports = function(e3, t3, i3) {
        for (var o2 = r2(t3), g2 = n2.f, c2 = s2.f, C2 = 0; C2 < o2.length; C2++) {
          var h2 = o2[C2];
          a2(e3, h2) || i3 && a2(i3, h2) || g2(e3, h2, c2(t3, h2));
        }
      };
    },
    2211: (e2, t2, i2) => {
      var a2 = i2(9039);
      e2.exports = !a2(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    },
    2529: (e2) => {
      e2.exports = function(e3, t2) {
        return {
          value: e3,
          done: t2
        };
      };
    },
    6699: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(4913), s2 = i2(6980);
      e2.exports = a2 ? function(e3, t3, i3) {
        return r2.f(e3, t3, s2(1, i3));
      } : function(e3, t3, i3) {
        e3[t3] = i3;
        return e3;
      };
    },
    6980: (e2) => {
      e2.exports = function(e3, t2) {
        return {
          enumerable: !(1 & e3),
          configurable: !(2 & e3),
          writable: !(4 & e3),
          value: t2
        };
      };
    },
    4659: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(4913), s2 = i2(6980);
      e2.exports = function(e3, t3, i3) {
        a2 ? r2.f(e3, t3, s2(0, i3)) : e3[t3] = i3;
      };
    },
    2106: (e2, t2, i2) => {
      var a2 = i2(283), r2 = i2(4913);
      e2.exports = function(e3, t3, i3) {
        i3.get && a2(i3.get, t3, {
          getter: true
        });
        i3.set && a2(i3.set, t3, {
          setter: true
        });
        return r2.f(e3, t3, i3);
      };
    },
    6840: (e2, t2, i2) => {
      var a2 = i2(4901), r2 = i2(4913), s2 = i2(283), n2 = i2(9433);
      e2.exports = function(e3, t3, i3, o2) {
        o2 || (o2 = {});
        var g2 = o2.enumerable, c2 = void 0 !== o2.name ? o2.name : t3;
        a2(i3) && s2(i3, c2, o2);
        if (o2.global) g2 ? e3[t3] = i3 : n2(t3, i3);
        else {
          try {
            o2.unsafe ? e3[t3] && (g2 = true) : delete e3[t3];
          } catch (e4) {
          }
          g2 ? e3[t3] = i3 : r2.f(e3, t3, {
            value: i3,
            enumerable: false,
            configurable: !o2.nonConfigurable,
            writable: !o2.nonWritable
          });
        }
        return e3;
      };
    },
    6279: (e2, t2, i2) => {
      var a2 = i2(6840);
      e2.exports = function(e3, t3, i3) {
        for (var r2 in t3) a2(e3, r2, t3[r2], i3);
        return e3;
      };
    },
    9433: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = Object.defineProperty;
      e2.exports = function(e3, t3) {
        try {
          r2(a2, e3, {
            value: t3,
            configurable: true,
            writable: true
          });
        } catch (i3) {
          a2[e3] = t3;
        }
        return t3;
      };
    },
    3724: (e2, t2, i2) => {
      var a2 = i2(9039);
      e2.exports = !a2(function() {
        return 7 !== Object.defineProperty({}, 1, {
          get: function() {
            return 7;
          }
        })[1];
      });
    },
    4483: (e2, t2, i2) => {
      var a2, r2, s2, n2, o2 = i2(4576), g2 = i2(9429), c2 = i2(1548), C2 = o2.structuredClone, h2 = o2.ArrayBuffer, l2 = o2.MessageChannel, Q2 = false;
      if (c2) Q2 = function(e3) {
        C2(e3, {
          transfer: [
            e3
          ]
        });
      };
      else if (h2) try {
        l2 || (a2 = g2("worker_threads")) && (l2 = a2.MessageChannel);
        if (l2) {
          r2 = new l2();
          s2 = new h2(2);
          n2 = function(e3) {
            r2.port1.postMessage(null, [
              e3
            ]);
          };
          if (2 === s2.byteLength) {
            n2(s2);
            0 === s2.byteLength && (Q2 = n2);
          }
        }
      } catch (e3) {
      }
      e2.exports = Q2;
    },
    4055: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(34), s2 = a2.document, n2 = r2(s2) && r2(s2.createElement);
      e2.exports = function(e3) {
        return n2 ? s2.createElement(e3) : {};
      };
    },
    6837: (e2) => {
      var t2 = TypeError;
      e2.exports = function(e3) {
        if (e3 > 9007199254740991) throw t2("Maximum allowed index exceeded");
        return e3;
      };
    },
    5002: (e2) => {
      e2.exports = {
        IndexSizeError: {
          s: "INDEX_SIZE_ERR",
          c: 1,
          m: 1
        },
        DOMStringSizeError: {
          s: "DOMSTRING_SIZE_ERR",
          c: 2,
          m: 0
        },
        HierarchyRequestError: {
          s: "HIERARCHY_REQUEST_ERR",
          c: 3,
          m: 1
        },
        WrongDocumentError: {
          s: "WRONG_DOCUMENT_ERR",
          c: 4,
          m: 1
        },
        InvalidCharacterError: {
          s: "INVALID_CHARACTER_ERR",
          c: 5,
          m: 1
        },
        NoDataAllowedError: {
          s: "NO_DATA_ALLOWED_ERR",
          c: 6,
          m: 0
        },
        NoModificationAllowedError: {
          s: "NO_MODIFICATION_ALLOWED_ERR",
          c: 7,
          m: 1
        },
        NotFoundError: {
          s: "NOT_FOUND_ERR",
          c: 8,
          m: 1
        },
        NotSupportedError: {
          s: "NOT_SUPPORTED_ERR",
          c: 9,
          m: 1
        },
        InUseAttributeError: {
          s: "INUSE_ATTRIBUTE_ERR",
          c: 10,
          m: 1
        },
        InvalidStateError: {
          s: "INVALID_STATE_ERR",
          c: 11,
          m: 1
        },
        SyntaxError: {
          s: "SYNTAX_ERR",
          c: 12,
          m: 1
        },
        InvalidModificationError: {
          s: "INVALID_MODIFICATION_ERR",
          c: 13,
          m: 1
        },
        NamespaceError: {
          s: "NAMESPACE_ERR",
          c: 14,
          m: 1
        },
        InvalidAccessError: {
          s: "INVALID_ACCESS_ERR",
          c: 15,
          m: 1
        },
        ValidationError: {
          s: "VALIDATION_ERR",
          c: 16,
          m: 0
        },
        TypeMismatchError: {
          s: "TYPE_MISMATCH_ERR",
          c: 17,
          m: 1
        },
        SecurityError: {
          s: "SECURITY_ERR",
          c: 18,
          m: 1
        },
        NetworkError: {
          s: "NETWORK_ERR",
          c: 19,
          m: 1
        },
        AbortError: {
          s: "ABORT_ERR",
          c: 20,
          m: 1
        },
        URLMismatchError: {
          s: "URL_MISMATCH_ERR",
          c: 21,
          m: 1
        },
        QuotaExceededError: {
          s: "QUOTA_EXCEEDED_ERR",
          c: 22,
          m: 1
        },
        TimeoutError: {
          s: "TIMEOUT_ERR",
          c: 23,
          m: 1
        },
        InvalidNodeTypeError: {
          s: "INVALID_NODE_TYPE_ERR",
          c: 24,
          m: 1
        },
        DataCloneError: {
          s: "DATA_CLONE_ERR",
          c: 25,
          m: 1
        }
      };
    },
    8727: (e2) => {
      e2.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    },
    6193: (e2, t2, i2) => {
      var a2 = i2(4215);
      e2.exports = "NODE" === a2;
    },
    2839: (e2, t2, i2) => {
      var a2 = i2(4576).navigator, r2 = a2 && a2.userAgent;
      e2.exports = r2 ? String(r2) : "";
    },
    9519: (e2, t2, i2) => {
      var a2, r2, s2 = i2(4576), n2 = i2(2839), o2 = s2.process, g2 = s2.Deno, c2 = o2 && o2.versions || g2 && g2.version, C2 = c2 && c2.v8;
      C2 && (r2 = (a2 = C2.split("."))[0] > 0 && a2[0] < 4 ? 1 : +(a2[0] + a2[1]));
      !r2 && n2 && (!(a2 = n2.match(/Edge\/(\d+)/)) || a2[1] >= 74) && (a2 = n2.match(/Chrome\/(\d+)/)) && (r2 = +a2[1]);
      e2.exports = r2;
    },
    4215: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(2839), s2 = i2(2195), userAgentStartsWith = function(e3) {
        return r2.slice(0, e3.length) === e3;
      };
      e2.exports = userAgentStartsWith("Bun/") ? "BUN" : userAgentStartsWith("Cloudflare-Workers") ? "CLOUDFLARE" : userAgentStartsWith("Deno/") ? "DENO" : userAgentStartsWith("Node.js/") ? "NODE" : a2.Bun && "string" == typeof Bun.version ? "BUN" : a2.Deno && "object" == typeof Deno.version ? "DENO" : "process" === s2(a2.process) ? "NODE" : a2.window && a2.document ? "BROWSER" : "REST";
    },
    8574: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = Error, s2 = a2("".replace), n2 = String(new r2("zxcasd").stack), o2 = /\n\s*at [^:]*:[^\n]*/, g2 = o2.test(n2);
      e2.exports = function(e3, t3) {
        if (g2 && "string" == typeof e3 && !r2.prepareStackTrace) for (; t3--; ) e3 = s2(e3, o2, "");
        return e3;
      };
    },
    6518: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(7347).f, s2 = i2(6699), n2 = i2(6840), o2 = i2(9433), g2 = i2(7740), c2 = i2(2796);
      e2.exports = function(e3, t3) {
        var i3, C2, h2, l2, Q2, E2 = e3.target, u2 = e3.global, d2 = e3.stat;
        if (i3 = u2 ? a2 : d2 ? a2[E2] || o2(E2, {}) : a2[E2] && a2[E2].prototype) for (C2 in t3) {
          l2 = t3[C2];
          h2 = e3.dontCallGetSet ? (Q2 = r2(i3, C2)) && Q2.value : i3[C2];
          if (!c2(u2 ? C2 : E2 + (d2 ? "." : "#") + C2, e3.forced) && void 0 !== h2) {
            if (typeof l2 == typeof h2) continue;
            g2(l2, h2);
          }
          (e3.sham || h2 && h2.sham) && s2(l2, "sham", true);
          n2(i3, C2, l2, e3);
        }
      };
    },
    9039: (e2) => {
      e2.exports = function(e3) {
        try {
          return !!e3();
        } catch (e4) {
          return true;
        }
      };
    },
    6080: (e2, t2, i2) => {
      var a2 = i2(7476), r2 = i2(9306), s2 = i2(616), n2 = a2(a2.bind);
      e2.exports = function(e3, t3) {
        r2(e3);
        return void 0 === t3 ? e3 : s2 ? n2(e3, t3) : function() {
          return e3.apply(t3, arguments);
        };
      };
    },
    616: (e2, t2, i2) => {
      var a2 = i2(9039);
      e2.exports = !a2(function() {
        var e3 = (function() {
        }).bind();
        return "function" != typeof e3 || e3.hasOwnProperty("prototype");
      });
    },
    9565: (e2, t2, i2) => {
      var a2 = i2(616), r2 = Function.prototype.call;
      e2.exports = a2 ? r2.bind(r2) : function() {
        return r2.apply(r2, arguments);
      };
    },
    350: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(9297), s2 = Function.prototype, n2 = a2 && Object.getOwnPropertyDescriptor, o2 = r2(s2, "name"), g2 = o2 && "something" === (function something() {
      }).name, c2 = o2 && (!a2 || a2 && n2(s2, "name").configurable);
      e2.exports = {
        EXISTS: o2,
        PROPER: g2,
        CONFIGURABLE: c2
      };
    },
    6706: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(9306);
      e2.exports = function(e3, t3, i3) {
        try {
          return a2(r2(Object.getOwnPropertyDescriptor(e3, t3)[i3]));
        } catch (e4) {
        }
      };
    },
    7476: (e2, t2, i2) => {
      var a2 = i2(2195), r2 = i2(9504);
      e2.exports = function(e3) {
        if ("Function" === a2(e3)) return r2(e3);
      };
    },
    9504: (e2, t2, i2) => {
      var a2 = i2(616), r2 = Function.prototype, s2 = r2.call, n2 = a2 && r2.bind.bind(s2, s2);
      e2.exports = a2 ? n2 : function(e3) {
        return function() {
          return s2.apply(e3, arguments);
        };
      };
    },
    9429: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(6193);
      e2.exports = function(e3) {
        if (r2) {
          try {
            return a2.process.getBuiltinModule(e3);
          } catch (e4) {
          }
          try {
            return Function('return require("' + e3 + '")')();
          } catch (e4) {
          }
        }
      };
    },
    7751: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(4901);
      e2.exports = function(e3, t3) {
        return arguments.length < 2 ? (i3 = a2[e3], r2(i3) ? i3 : void 0) : a2[e3] && a2[e3][t3];
        var i3;
      };
    },
    1767: (e2) => {
      e2.exports = function(e3) {
        return {
          iterator: e3,
          next: e3.next,
          done: false
        };
      };
    },
    851: (e2, t2, i2) => {
      var a2 = i2(6955), r2 = i2(5966), s2 = i2(4117), n2 = i2(6269), o2 = i2(8227)("iterator");
      e2.exports = function(e3) {
        if (!s2(e3)) return r2(e3, o2) || r2(e3, "@@iterator") || n2[a2(e3)];
      };
    },
    81: (e2, t2, i2) => {
      var a2 = i2(9565), r2 = i2(9306), s2 = i2(8551), n2 = i2(6823), o2 = i2(851), g2 = TypeError;
      e2.exports = function(e3, t3) {
        var i3 = arguments.length < 2 ? o2(e3) : t3;
        if (r2(i3)) return s2(a2(i3, e3));
        throw new g2(n2(e3) + " is not iterable");
      };
    },
    5966: (e2, t2, i2) => {
      var a2 = i2(9306), r2 = i2(4117);
      e2.exports = function(e3, t3) {
        var i3 = e3[t3];
        return r2(i3) ? void 0 : a2(i3);
      };
    },
    3789: (e2, t2, i2) => {
      var a2 = i2(9306), r2 = i2(8551), s2 = i2(9565), n2 = i2(1291), o2 = i2(1767), g2 = "Invalid size", c2 = RangeError, C2 = TypeError, h2 = Math.max, SetRecord = function(e3, t3) {
        this.set = e3;
        this.size = h2(t3, 0);
        this.has = a2(e3.has);
        this.keys = a2(e3.keys);
      };
      SetRecord.prototype = {
        getIterator: function() {
          return o2(r2(s2(this.keys, this.set)));
        },
        includes: function(e3) {
          return s2(this.has, this.set, e3);
        }
      };
      e2.exports = function(e3) {
        r2(e3);
        var t3 = +e3.size;
        if (t3 != t3) throw new C2(g2);
        var i3 = n2(t3);
        if (i3 < 0) throw new c2(g2);
        return new SetRecord(e3, i3);
      };
    },
    4576: function(e2) {
      var check = function(e3) {
        return e3 && e3.Math === Math && e3;
      };
      e2.exports = check("object" == typeof globalThis && globalThis) || check("object" == typeof window && window) || check("object" == typeof self && self) || check("object" == typeof global && global) || check("object" == typeof this && this) || /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")();
    },
    9297: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(8981), s2 = a2({}.hasOwnProperty);
      e2.exports = Object.hasOwn || function hasOwn(e3, t3) {
        return s2(r2(e3), t3);
      };
    },
    421: (e2) => {
      e2.exports = {};
    },
    397: (e2, t2, i2) => {
      var a2 = i2(7751);
      e2.exports = a2("document", "documentElement");
    },
    5917: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(9039), s2 = i2(4055);
      e2.exports = !a2 && !r2(function() {
        return 7 !== Object.defineProperty(s2("div"), "a", {
          get: function() {
            return 7;
          }
        }).a;
      });
    },
    7055: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(9039), s2 = i2(2195), n2 = Object, o2 = a2("".split);
      e2.exports = r2(function() {
        return !n2("z").propertyIsEnumerable(0);
      }) ? function(e3) {
        return "String" === s2(e3) ? o2(e3, "") : n2(e3);
      } : n2;
    },
    3167: (e2, t2, i2) => {
      var a2 = i2(4901), r2 = i2(34), s2 = i2(2967);
      e2.exports = function(e3, t3, i3) {
        var n2, o2;
        s2 && a2(n2 = t3.constructor) && n2 !== i3 && r2(o2 = n2.prototype) && o2 !== i3.prototype && s2(e3, o2);
        return e3;
      };
    },
    3706: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(4901), s2 = i2(7629), n2 = a2(Function.toString);
      r2(s2.inspectSource) || (s2.inspectSource = function(e3) {
        return n2(e3);
      });
      e2.exports = s2.inspectSource;
    },
    1181: (e2, t2, i2) => {
      var a2, r2, s2, n2 = i2(8622), o2 = i2(4576), g2 = i2(34), c2 = i2(6699), C2 = i2(9297), h2 = i2(7629), l2 = i2(6119), Q2 = i2(421), E2 = "Object already initialized", u2 = o2.TypeError, d2 = o2.WeakMap;
      if (n2 || h2.state) {
        var f2 = h2.state || (h2.state = new d2());
        f2.get = f2.get;
        f2.has = f2.has;
        f2.set = f2.set;
        a2 = function(e3, t3) {
          if (f2.has(e3)) throw new u2(E2);
          t3.facade = e3;
          f2.set(e3, t3);
          return t3;
        };
        r2 = function(e3) {
          return f2.get(e3) || {};
        };
        s2 = function(e3) {
          return f2.has(e3);
        };
      } else {
        var p2 = l2("state");
        Q2[p2] = true;
        a2 = function(e3, t3) {
          if (C2(e3, p2)) throw new u2(E2);
          t3.facade = e3;
          c2(e3, p2, t3);
          return t3;
        };
        r2 = function(e3) {
          return C2(e3, p2) ? e3[p2] : {};
        };
        s2 = function(e3) {
          return C2(e3, p2);
        };
      }
      e2.exports = {
        set: a2,
        get: r2,
        has: s2,
        enforce: function(e3) {
          return s2(e3) ? r2(e3) : a2(e3, {});
        },
        getterFor: function(e3) {
          return function(t3) {
            var i3;
            if (!g2(t3) || (i3 = r2(t3)).type !== e3) throw new u2("Incompatible receiver, " + e3 + " required");
            return i3;
          };
        }
      };
    },
    4209: (e2, t2, i2) => {
      var a2 = i2(8227), r2 = i2(6269), s2 = a2("iterator"), n2 = Array.prototype;
      e2.exports = function(e3) {
        return void 0 !== e3 && (r2.Array === e3 || n2[s2] === e3);
      };
    },
    4376: (e2, t2, i2) => {
      var a2 = i2(2195);
      e2.exports = Array.isArray || function isArray(e3) {
        return "Array" === a2(e3);
      };
    },
    1108: (e2, t2, i2) => {
      var a2 = i2(6955);
      e2.exports = function(e3) {
        var t3 = a2(e3);
        return "BigInt64Array" === t3 || "BigUint64Array" === t3;
      };
    },
    4901: (e2) => {
      var t2 = "object" == typeof document && document.all;
      e2.exports = void 0 === t2 && void 0 !== t2 ? function(e3) {
        return "function" == typeof e3 || e3 === t2;
      } : function(e3) {
        return "function" == typeof e3;
      };
    },
    2796: (e2, t2, i2) => {
      var a2 = i2(9039), r2 = i2(4901), s2 = /#|\.prototype\./, isForced = function(e3, t3) {
        var i3 = o2[n2(e3)];
        return i3 === c2 || i3 !== g2 && (r2(t3) ? a2(t3) : !!t3);
      }, n2 = isForced.normalize = function(e3) {
        return String(e3).replace(s2, ".").toLowerCase();
      }, o2 = isForced.data = {}, g2 = isForced.NATIVE = "N", c2 = isForced.POLYFILL = "P";
      e2.exports = isForced;
    },
    4117: (e2) => {
      e2.exports = function(e3) {
        return null == e3;
      };
    },
    34: (e2, t2, i2) => {
      var a2 = i2(4901);
      e2.exports = function(e3) {
        return "object" == typeof e3 ? null !== e3 : a2(e3);
      };
    },
    3925: (e2, t2, i2) => {
      var a2 = i2(34);
      e2.exports = function(e3) {
        return a2(e3) || null === e3;
      };
    },
    6395: (e2) => {
      e2.exports = false;
    },
    757: (e2, t2, i2) => {
      var a2 = i2(7751), r2 = i2(4901), s2 = i2(1625), n2 = i2(7040), o2 = Object;
      e2.exports = n2 ? function(e3) {
        return "symbol" == typeof e3;
      } : function(e3) {
        var t3 = a2("Symbol");
        return r2(t3) && s2(t3.prototype, o2(e3));
      };
    },
    507: (e2, t2, i2) => {
      var a2 = i2(9565);
      e2.exports = function(e3, t3, i3) {
        for (var r2, s2, n2 = i3 ? e3 : e3.iterator, o2 = e3.next; !(r2 = a2(o2, n2)).done; ) if (void 0 !== (s2 = t3(r2.value))) return s2;
      };
    },
    2652: (e2, t2, i2) => {
      var a2 = i2(6080), r2 = i2(9565), s2 = i2(8551), n2 = i2(6823), o2 = i2(4209), g2 = i2(6198), c2 = i2(1625), C2 = i2(81), h2 = i2(851), l2 = i2(9539), Q2 = TypeError, Result = function(e3, t3) {
        this.stopped = e3;
        this.result = t3;
      }, E2 = Result.prototype;
      e2.exports = function(e3, t3, i3) {
        var u2, d2, f2, p2, m2, y2, w2, b2 = i3 && i3.that, D2 = !(!i3 || !i3.AS_ENTRIES), S2 = !(!i3 || !i3.IS_RECORD), k2 = !(!i3 || !i3.IS_ITERATOR), R2 = !(!i3 || !i3.INTERRUPTED), N2 = a2(t3, b2), stop = function(e4) {
          u2 && l2(u2, "normal", e4);
          return new Result(true, e4);
        }, callFn = function(e4) {
          if (D2) {
            s2(e4);
            return R2 ? N2(e4[0], e4[1], stop) : N2(e4[0], e4[1]);
          }
          return R2 ? N2(e4, stop) : N2(e4);
        };
        if (S2) u2 = e3.iterator;
        else if (k2) u2 = e3;
        else {
          if (!(d2 = h2(e3))) throw new Q2(n2(e3) + " is not iterable");
          if (o2(d2)) {
            for (f2 = 0, p2 = g2(e3); p2 > f2; f2++) if ((m2 = callFn(e3[f2])) && c2(E2, m2)) return m2;
            return new Result(false);
          }
          u2 = C2(e3, d2);
        }
        y2 = S2 ? e3.next : u2.next;
        for (; !(w2 = r2(y2, u2)).done; ) {
          try {
            m2 = callFn(w2.value);
          } catch (e4) {
            l2(u2, "throw", e4);
          }
          if ("object" == typeof m2 && m2 && c2(E2, m2)) return m2;
        }
        return new Result(false);
      };
    },
    9539: (e2, t2, i2) => {
      var a2 = i2(9565), r2 = i2(8551), s2 = i2(5966);
      e2.exports = function(e3, t3, i3) {
        var n2, o2;
        r2(e3);
        try {
          if (!(n2 = s2(e3, "return"))) {
            if ("throw" === t3) throw i3;
            return i3;
          }
          n2 = a2(n2, e3);
        } catch (e4) {
          o2 = true;
          n2 = e4;
        }
        if ("throw" === t3) throw i3;
        if (o2) throw n2;
        r2(n2);
        return i3;
      };
    },
    9462: (e2, t2, i2) => {
      var a2 = i2(9565), r2 = i2(2360), s2 = i2(6699), n2 = i2(6279), o2 = i2(8227), g2 = i2(1181), c2 = i2(5966), C2 = i2(7657).IteratorPrototype, h2 = i2(2529), l2 = i2(9539), Q2 = o2("toStringTag"), E2 = "IteratorHelper", u2 = "WrapForValidIterator", d2 = g2.set, createIteratorProxyPrototype = function(e3) {
        var t3 = g2.getterFor(e3 ? u2 : E2);
        return n2(r2(C2), {
          next: function next() {
            var i3 = t3(this);
            if (e3) return i3.nextHandler();
            try {
              var a3 = i3.done ? void 0 : i3.nextHandler();
              return h2(a3, i3.done);
            } catch (e4) {
              i3.done = true;
              throw e4;
            }
          },
          return: function() {
            var i3 = t3(this), r3 = i3.iterator;
            i3.done = true;
            if (e3) {
              var s3 = c2(r3, "return");
              return s3 ? a2(s3, r3) : h2(void 0, true);
            }
            if (i3.inner) try {
              l2(i3.inner.iterator, "normal");
            } catch (e4) {
              return l2(r3, "throw", e4);
            }
            l2(r3, "normal");
            return h2(void 0, true);
          }
        });
      }, f2 = createIteratorProxyPrototype(true), p2 = createIteratorProxyPrototype(false);
      s2(p2, Q2, "Iterator Helper");
      e2.exports = function(e3, t3) {
        var i3 = function Iterator(i4, a3) {
          if (a3) {
            a3.iterator = i4.iterator;
            a3.next = i4.next;
          } else a3 = i4;
          a3.type = t3 ? u2 : E2;
          a3.nextHandler = e3;
          a3.counter = 0;
          a3.done = false;
          d2(this, a3);
        };
        i3.prototype = t3 ? f2 : p2;
        return i3;
      };
    },
    713: (e2, t2, i2) => {
      var a2 = i2(9565), r2 = i2(9306), s2 = i2(8551), n2 = i2(1767), o2 = i2(9462), g2 = i2(6319), c2 = o2(function() {
        var e3 = this.iterator, t3 = s2(a2(this.next, e3));
        if (!(this.done = !!t3.done)) return g2(e3, this.mapper, [
          t3.value,
          this.counter++
        ], true);
      });
      e2.exports = function map(e3) {
        s2(this);
        r2(e3);
        return new c2(n2(this), {
          mapper: e3
        });
      };
    },
    7657: (e2, t2, i2) => {
      var a2, r2, s2, n2 = i2(9039), o2 = i2(4901), g2 = i2(34), c2 = i2(2360), C2 = i2(2787), h2 = i2(6840), l2 = i2(8227), Q2 = i2(6395), E2 = l2("iterator"), u2 = false;
      [].keys && ("next" in (s2 = [].keys()) ? (r2 = C2(C2(s2))) !== Object.prototype && (a2 = r2) : u2 = true);
      !g2(a2) || n2(function() {
        var e3 = {};
        return a2[E2].call(e3) !== e3;
      }) ? a2 = {} : Q2 && (a2 = c2(a2));
      o2(a2[E2]) || h2(a2, E2, function() {
        return this;
      });
      e2.exports = {
        IteratorPrototype: a2,
        BUGGY_SAFARI_ITERATORS: u2
      };
    },
    6269: (e2) => {
      e2.exports = {};
    },
    6198: (e2, t2, i2) => {
      var a2 = i2(8014);
      e2.exports = function(e3) {
        return a2(e3.length);
      };
    },
    283: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(9039), s2 = i2(4901), n2 = i2(9297), o2 = i2(3724), g2 = i2(350).CONFIGURABLE, c2 = i2(3706), C2 = i2(1181), h2 = C2.enforce, l2 = C2.get, Q2 = String, E2 = Object.defineProperty, u2 = a2("".slice), d2 = a2("".replace), f2 = a2([].join), p2 = o2 && !r2(function() {
        return 8 !== E2(function() {
        }, "length", {
          value: 8
        }).length;
      }), m2 = String(String).split("String"), y2 = e2.exports = function(e3, t3, i3) {
        "Symbol(" === u2(Q2(t3), 0, 7) && (t3 = "[" + d2(Q2(t3), /^Symbol\(([^)]*)\).*$/, "$1") + "]");
        i3 && i3.getter && (t3 = "get " + t3);
        i3 && i3.setter && (t3 = "set " + t3);
        (!n2(e3, "name") || g2 && e3.name !== t3) && (o2 ? E2(e3, "name", {
          value: t3,
          configurable: true
        }) : e3.name = t3);
        p2 && i3 && n2(i3, "arity") && e3.length !== i3.arity && E2(e3, "length", {
          value: i3.arity
        });
        try {
          i3 && n2(i3, "constructor") && i3.constructor ? o2 && E2(e3, "prototype", {
            writable: false
          }) : e3.prototype && (e3.prototype = void 0);
        } catch (e4) {
        }
        var a3 = h2(e3);
        n2(a3, "source") || (a3.source = f2(m2, "string" == typeof t3 ? t3 : ""));
        return e3;
      };
      Function.prototype.toString = y2(function toString() {
        return s2(this) && l2(this).source || c2(this);
      }, "toString");
    },
    741: (e2) => {
      var t2 = Math.ceil, i2 = Math.floor;
      e2.exports = Math.trunc || function trunc(e3) {
        var a2 = +e3;
        return (a2 > 0 ? i2 : t2)(a2);
      };
    },
    6043: (e2, t2, i2) => {
      var a2 = i2(9306), r2 = TypeError, PromiseCapability = function(e3) {
        var t3, i3;
        this.promise = new e3(function(e4, a3) {
          if (void 0 !== t3 || void 0 !== i3) throw new r2("Bad Promise constructor");
          t3 = e4;
          i3 = a3;
        });
        this.resolve = a2(t3);
        this.reject = a2(i3);
      };
      e2.exports.f = function(e3) {
        return new PromiseCapability(e3);
      };
    },
    2603: (e2, t2, i2) => {
      var a2 = i2(655);
      e2.exports = function(e3, t3) {
        return void 0 === e3 ? arguments.length < 2 ? "" : t3 : a2(e3);
      };
    },
    2360: (e2, t2, i2) => {
      var a2, r2 = i2(8551), s2 = i2(6801), n2 = i2(8727), o2 = i2(421), g2 = i2(397), c2 = i2(4055), C2 = i2(6119), h2 = "prototype", l2 = "script", Q2 = C2("IE_PROTO"), EmptyConstructor = function() {
      }, scriptTag = function(e3) {
        return "<" + l2 + ">" + e3 + "</" + l2 + ">";
      }, NullProtoObjectViaActiveX = function(e3) {
        e3.write(scriptTag(""));
        e3.close();
        var t3 = e3.parentWindow.Object;
        e3 = null;
        return t3;
      }, NullProtoObject = function() {
        try {
          a2 = new ActiveXObject("htmlfile");
        } catch (e4) {
        }
        NullProtoObject = "undefined" != typeof document ? document.domain && a2 ? NullProtoObjectViaActiveX(a2) : function() {
          var e4, t3 = c2("iframe"), i3 = "java" + l2 + ":";
          t3.style.display = "none";
          g2.appendChild(t3);
          t3.src = String(i3);
          (e4 = t3.contentWindow.document).open();
          e4.write(scriptTag("document.F=Object"));
          e4.close();
          return e4.F;
        }() : NullProtoObjectViaActiveX(a2);
        for (var e3 = n2.length; e3--; ) delete NullProtoObject[h2][n2[e3]];
        return NullProtoObject();
      };
      o2[Q2] = true;
      e2.exports = Object.create || function create(e3, t3) {
        var i3;
        if (null !== e3) {
          EmptyConstructor[h2] = r2(e3);
          i3 = new EmptyConstructor();
          EmptyConstructor[h2] = null;
          i3[Q2] = e3;
        } else i3 = NullProtoObject();
        return void 0 === t3 ? i3 : s2.f(i3, t3);
      };
    },
    6801: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(8686), s2 = i2(4913), n2 = i2(8551), o2 = i2(5397), g2 = i2(1072);
      t2.f = a2 && !r2 ? Object.defineProperties : function defineProperties(e3, t3) {
        n2(e3);
        for (var i3, a3 = o2(t3), r3 = g2(t3), c2 = r3.length, C2 = 0; c2 > C2; ) s2.f(e3, i3 = r3[C2++], a3[i3]);
        return e3;
      };
    },
    4913: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(5917), s2 = i2(8686), n2 = i2(8551), o2 = i2(6969), g2 = TypeError, c2 = Object.defineProperty, C2 = Object.getOwnPropertyDescriptor, h2 = "enumerable", l2 = "configurable", Q2 = "writable";
      t2.f = a2 ? s2 ? function defineProperty(e3, t3, i3) {
        n2(e3);
        t3 = o2(t3);
        n2(i3);
        if ("function" == typeof e3 && "prototype" === t3 && "value" in i3 && Q2 in i3 && !i3[Q2]) {
          var a3 = C2(e3, t3);
          if (a3 && a3[Q2]) {
            e3[t3] = i3.value;
            i3 = {
              configurable: l2 in i3 ? i3[l2] : a3[l2],
              enumerable: h2 in i3 ? i3[h2] : a3[h2],
              writable: false
            };
          }
        }
        return c2(e3, t3, i3);
      } : c2 : function defineProperty(e3, t3, i3) {
        n2(e3);
        t3 = o2(t3);
        n2(i3);
        if (r2) try {
          return c2(e3, t3, i3);
        } catch (e4) {
        }
        if ("get" in i3 || "set" in i3) throw new g2("Accessors not supported");
        "value" in i3 && (e3[t3] = i3.value);
        return e3;
      };
    },
    7347: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(9565), s2 = i2(8773), n2 = i2(6980), o2 = i2(5397), g2 = i2(6969), c2 = i2(9297), C2 = i2(5917), h2 = Object.getOwnPropertyDescriptor;
      t2.f = a2 ? h2 : function getOwnPropertyDescriptor(e3, t3) {
        e3 = o2(e3);
        t3 = g2(t3);
        if (C2) try {
          return h2(e3, t3);
        } catch (e4) {
        }
        if (c2(e3, t3)) return n2(!r2(s2.f, e3, t3), e3[t3]);
      };
    },
    8480: (e2, t2, i2) => {
      var a2 = i2(1828), r2 = i2(8727).concat("length", "prototype");
      t2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(e3) {
        return a2(e3, r2);
      };
    },
    3717: (e2, t2) => {
      t2.f = Object.getOwnPropertySymbols;
    },
    2787: (e2, t2, i2) => {
      var a2 = i2(9297), r2 = i2(4901), s2 = i2(8981), n2 = i2(6119), o2 = i2(2211), g2 = n2("IE_PROTO"), c2 = Object, C2 = c2.prototype;
      e2.exports = o2 ? c2.getPrototypeOf : function(e3) {
        var t3 = s2(e3);
        if (a2(t3, g2)) return t3[g2];
        var i3 = t3.constructor;
        return r2(i3) && t3 instanceof i3 ? i3.prototype : t3 instanceof c2 ? C2 : null;
      };
    },
    1625: (e2, t2, i2) => {
      var a2 = i2(9504);
      e2.exports = a2({}.isPrototypeOf);
    },
    1828: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(9297), s2 = i2(5397), n2 = i2(9617).indexOf, o2 = i2(421), g2 = a2([].push);
      e2.exports = function(e3, t3) {
        var i3, a3 = s2(e3), c2 = 0, C2 = [];
        for (i3 in a3) !r2(o2, i3) && r2(a3, i3) && g2(C2, i3);
        for (; t3.length > c2; ) r2(a3, i3 = t3[c2++]) && (~n2(C2, i3) || g2(C2, i3));
        return C2;
      };
    },
    1072: (e2, t2, i2) => {
      var a2 = i2(1828), r2 = i2(8727);
      e2.exports = Object.keys || function keys(e3) {
        return a2(e3, r2);
      };
    },
    8773: (e2, t2) => {
      var i2 = {}.propertyIsEnumerable, a2 = Object.getOwnPropertyDescriptor, r2 = a2 && !i2.call({
        1: 2
      }, 1);
      t2.f = r2 ? function propertyIsEnumerable(e3) {
        var t3 = a2(this, e3);
        return !!t3 && t3.enumerable;
      } : i2;
    },
    2967: (e2, t2, i2) => {
      var a2 = i2(6706), r2 = i2(34), s2 = i2(7750), n2 = i2(3506);
      e2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e3, t3 = false, i3 = {};
        try {
          (e3 = a2(Object.prototype, "__proto__", "set"))(i3, []);
          t3 = i3 instanceof Array;
        } catch (e4) {
        }
        return function setPrototypeOf(i4, a3) {
          s2(i4);
          n2(a3);
          if (!r2(i4)) return i4;
          t3 ? e3(i4, a3) : i4.__proto__ = a3;
          return i4;
        };
      }() : void 0);
    },
    4270: (e2, t2, i2) => {
      var a2 = i2(9565), r2 = i2(4901), s2 = i2(34), n2 = TypeError;
      e2.exports = function(e3, t3) {
        var i3, o2;
        if ("string" === t3 && r2(i3 = e3.toString) && !s2(o2 = a2(i3, e3))) return o2;
        if (r2(i3 = e3.valueOf) && !s2(o2 = a2(i3, e3))) return o2;
        if ("string" !== t3 && r2(i3 = e3.toString) && !s2(o2 = a2(i3, e3))) return o2;
        throw new n2("Can't convert object to primitive value");
      };
    },
    5031: (e2, t2, i2) => {
      var a2 = i2(7751), r2 = i2(9504), s2 = i2(8480), n2 = i2(3717), o2 = i2(8551), g2 = r2([].concat);
      e2.exports = a2("Reflect", "ownKeys") || function ownKeys(e3) {
        var t3 = s2.f(o2(e3)), i3 = n2.f;
        return i3 ? g2(t3, i3(e3)) : t3;
      };
    },
    7979: (e2, t2, i2) => {
      var a2 = i2(8551);
      e2.exports = function() {
        var e3 = a2(this), t3 = "";
        e3.hasIndices && (t3 += "d");
        e3.global && (t3 += "g");
        e3.ignoreCase && (t3 += "i");
        e3.multiline && (t3 += "m");
        e3.dotAll && (t3 += "s");
        e3.unicode && (t3 += "u");
        e3.unicodeSets && (t3 += "v");
        e3.sticky && (t3 += "y");
        return t3;
      };
    },
    7750: (e2, t2, i2) => {
      var a2 = i2(4117), r2 = TypeError;
      e2.exports = function(e3) {
        if (a2(e3)) throw new r2("Can't call method on " + e3);
        return e3;
      };
    },
    9286: (e2, t2, i2) => {
      var a2 = i2(4402), r2 = i2(8469), s2 = a2.Set, n2 = a2.add;
      e2.exports = function(e3) {
        var t3 = new s2();
        r2(e3, function(e4) {
          n2(t3, e4);
        });
        return t3;
      };
    },
    3440: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(4402), s2 = i2(9286), n2 = i2(5170), o2 = i2(3789), g2 = i2(8469), c2 = i2(507), C2 = r2.has, h2 = r2.remove;
      e2.exports = function difference(e3) {
        var t3 = a2(this), i3 = o2(e3), r3 = s2(t3);
        n2(t3) <= i3.size ? g2(t3, function(e4) {
          i3.includes(e4) && h2(r3, e4);
        }) : c2(i3.getIterator(), function(e4) {
          C2(t3, e4) && h2(r3, e4);
        });
        return r3;
      };
    },
    4402: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = Set.prototype;
      e2.exports = {
        Set,
        add: a2(r2.add),
        has: a2(r2.has),
        remove: a2(r2.delete),
        proto: r2
      };
    },
    8750: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(4402), s2 = i2(5170), n2 = i2(3789), o2 = i2(8469), g2 = i2(507), c2 = r2.Set, C2 = r2.add, h2 = r2.has;
      e2.exports = function intersection(e3) {
        var t3 = a2(this), i3 = n2(e3), r3 = new c2();
        s2(t3) > i3.size ? g2(i3.getIterator(), function(e4) {
          h2(t3, e4) && C2(r3, e4);
        }) : o2(t3, function(e4) {
          i3.includes(e4) && C2(r3, e4);
        });
        return r3;
      };
    },
    4449: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(4402).has, s2 = i2(5170), n2 = i2(3789), o2 = i2(8469), g2 = i2(507), c2 = i2(9539);
      e2.exports = function isDisjointFrom(e3) {
        var t3 = a2(this), i3 = n2(e3);
        if (s2(t3) <= i3.size) return false !== o2(t3, function(e4) {
          if (i3.includes(e4)) return false;
        }, true);
        var C2 = i3.getIterator();
        return false !== g2(C2, function(e4) {
          if (r2(t3, e4)) return c2(C2, "normal", false);
        });
      };
    },
    3838: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(5170), s2 = i2(8469), n2 = i2(3789);
      e2.exports = function isSubsetOf(e3) {
        var t3 = a2(this), i3 = n2(e3);
        return !(r2(t3) > i3.size) && false !== s2(t3, function(e4) {
          if (!i3.includes(e4)) return false;
        }, true);
      };
    },
    8527: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(4402).has, s2 = i2(5170), n2 = i2(3789), o2 = i2(507), g2 = i2(9539);
      e2.exports = function isSupersetOf(e3) {
        var t3 = a2(this), i3 = n2(e3);
        if (s2(t3) < i3.size) return false;
        var c2 = i3.getIterator();
        return false !== o2(c2, function(e4) {
          if (!r2(t3, e4)) return g2(c2, "normal", false);
        });
      };
    },
    8469: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = i2(507), s2 = i2(4402), n2 = s2.Set, o2 = s2.proto, g2 = a2(o2.forEach), c2 = a2(o2.keys), C2 = c2(new n2()).next;
      e2.exports = function(e3, t3, i3) {
        return i3 ? r2({
          iterator: c2(e3),
          next: C2
        }, t3) : g2(e3, t3);
      };
    },
    4916: (e2, t2, i2) => {
      var a2 = i2(7751), createSetLike = function(e3) {
        return {
          size: e3,
          has: function() {
            return false;
          },
          keys: function() {
            return {
              next: function() {
                return {
                  done: true
                };
              }
            };
          }
        };
      };
      e2.exports = function(e3) {
        var t3 = a2("Set");
        try {
          new t3()[e3](createSetLike(0));
          try {
            new t3()[e3](createSetLike(-1));
            return false;
          } catch (e4) {
            return true;
          }
        } catch (e4) {
          return false;
        }
      };
    },
    5170: (e2, t2, i2) => {
      var a2 = i2(6706), r2 = i2(4402);
      e2.exports = a2(r2.proto, "size", "get") || function(e3) {
        return e3.size;
      };
    },
    3650: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(4402), s2 = i2(9286), n2 = i2(3789), o2 = i2(507), g2 = r2.add, c2 = r2.has, C2 = r2.remove;
      e2.exports = function symmetricDifference(e3) {
        var t3 = a2(this), i3 = n2(e3).getIterator(), r3 = s2(t3);
        o2(i3, function(e4) {
          c2(t3, e4) ? C2(r3, e4) : g2(r3, e4);
        });
        return r3;
      };
    },
    4204: (e2, t2, i2) => {
      var a2 = i2(7080), r2 = i2(4402).add, s2 = i2(9286), n2 = i2(3789), o2 = i2(507);
      e2.exports = function union(e3) {
        var t3 = a2(this), i3 = n2(e3).getIterator(), g2 = s2(t3);
        o2(i3, function(e4) {
          r2(g2, e4);
        });
        return g2;
      };
    },
    6119: (e2, t2, i2) => {
      var a2 = i2(5745), r2 = i2(3392), s2 = a2("keys");
      e2.exports = function(e3) {
        return s2[e3] || (s2[e3] = r2(e3));
      };
    },
    7629: (e2, t2, i2) => {
      var a2 = i2(6395), r2 = i2(4576), s2 = i2(9433), n2 = "__core-js_shared__", o2 = e2.exports = r2[n2] || s2(n2, {});
      (o2.versions || (o2.versions = [])).push({
        version: "3.38.1",
        mode: a2 ? "pure" : "global",
        copyright: "\xA9 2014-2024 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    },
    5745: (e2, t2, i2) => {
      var a2 = i2(7629);
      e2.exports = function(e3, t3) {
        return a2[e3] || (a2[e3] = t3 || {});
      };
    },
    1548: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(9039), s2 = i2(9519), n2 = i2(4215), o2 = a2.structuredClone;
      e2.exports = !!o2 && !r2(function() {
        if ("DENO" === n2 && s2 > 92 || "NODE" === n2 && s2 > 94 || "BROWSER" === n2 && s2 > 97) return false;
        var e3 = new ArrayBuffer(8), t3 = o2(e3, {
          transfer: [
            e3
          ]
        });
        return 0 !== e3.byteLength || 8 !== t3.byteLength;
      });
    },
    4495: (e2, t2, i2) => {
      var a2 = i2(9519), r2 = i2(9039), s2 = i2(4576).String;
      e2.exports = !!Object.getOwnPropertySymbols && !r2(function() {
        var e3 = Symbol("symbol detection");
        return !s2(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && a2 && a2 < 41;
      });
    },
    5610: (e2, t2, i2) => {
      var a2 = i2(1291), r2 = Math.max, s2 = Math.min;
      e2.exports = function(e3, t3) {
        var i3 = a2(e3);
        return i3 < 0 ? r2(i3 + t3, 0) : s2(i3, t3);
      };
    },
    5854: (e2, t2, i2) => {
      var a2 = i2(2777), r2 = TypeError;
      e2.exports = function(e3) {
        var t3 = a2(e3, "number");
        if ("number" == typeof t3) throw new r2("Can't convert number to bigint");
        return BigInt(t3);
      };
    },
    7696: (e2, t2, i2) => {
      var a2 = i2(1291), r2 = i2(8014), s2 = RangeError;
      e2.exports = function(e3) {
        if (void 0 === e3) return 0;
        var t3 = a2(e3), i3 = r2(t3);
        if (t3 !== i3) throw new s2("Wrong length or index");
        return i3;
      };
    },
    5397: (e2, t2, i2) => {
      var a2 = i2(7055), r2 = i2(7750);
      e2.exports = function(e3) {
        return a2(r2(e3));
      };
    },
    1291: (e2, t2, i2) => {
      var a2 = i2(741);
      e2.exports = function(e3) {
        var t3 = +e3;
        return t3 != t3 || 0 === t3 ? 0 : a2(t3);
      };
    },
    8014: (e2, t2, i2) => {
      var a2 = i2(1291), r2 = Math.min;
      e2.exports = function(e3) {
        var t3 = a2(e3);
        return t3 > 0 ? r2(t3, 9007199254740991) : 0;
      };
    },
    8981: (e2, t2, i2) => {
      var a2 = i2(7750), r2 = Object;
      e2.exports = function(e3) {
        return r2(a2(e3));
      };
    },
    2777: (e2, t2, i2) => {
      var a2 = i2(9565), r2 = i2(34), s2 = i2(757), n2 = i2(5966), o2 = i2(4270), g2 = i2(8227), c2 = TypeError, C2 = g2("toPrimitive");
      e2.exports = function(e3, t3) {
        if (!r2(e3) || s2(e3)) return e3;
        var i3, g3 = n2(e3, C2);
        if (g3) {
          void 0 === t3 && (t3 = "default");
          i3 = a2(g3, e3, t3);
          if (!r2(i3) || s2(i3)) return i3;
          throw new c2("Can't convert object to primitive value");
        }
        void 0 === t3 && (t3 = "number");
        return o2(e3, t3);
      };
    },
    6969: (e2, t2, i2) => {
      var a2 = i2(2777), r2 = i2(757);
      e2.exports = function(e3) {
        var t3 = a2(e3, "string");
        return r2(t3) ? t3 : t3 + "";
      };
    },
    2140: (e2, t2, i2) => {
      var a2 = {};
      a2[i2(8227)("toStringTag")] = "z";
      e2.exports = "[object z]" === String(a2);
    },
    655: (e2, t2, i2) => {
      var a2 = i2(6955), r2 = String;
      e2.exports = function(e3) {
        if ("Symbol" === a2(e3)) throw new TypeError("Cannot convert a Symbol value to a string");
        return r2(e3);
      };
    },
    6823: (e2) => {
      var t2 = String;
      e2.exports = function(e3) {
        try {
          return t2(e3);
        } catch (e4) {
          return "Object";
        }
      };
    },
    3392: (e2, t2, i2) => {
      var a2 = i2(9504), r2 = 0, s2 = Math.random(), n2 = a2(1 .toString);
      e2.exports = function(e3) {
        return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + n2(++r2 + s2, 36);
      };
    },
    7040: (e2, t2, i2) => {
      var a2 = i2(4495);
      e2.exports = a2 && !Symbol.sham && "symbol" == typeof Symbol.iterator;
    },
    8686: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(9039);
      e2.exports = a2 && r2(function() {
        return 42 !== Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype;
      });
    },
    2812: (e2) => {
      var t2 = TypeError;
      e2.exports = function(e3, i2) {
        if (e3 < i2) throw new t2("Not enough arguments");
        return e3;
      };
    },
    8622: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(4901), s2 = a2.WeakMap;
      e2.exports = r2(s2) && /native code/.test(String(s2));
    },
    8227: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(5745), s2 = i2(9297), n2 = i2(3392), o2 = i2(4495), g2 = i2(7040), c2 = a2.Symbol, C2 = r2("wks"), h2 = g2 ? c2.for || c2 : c2 && c2.withoutSetter || n2;
      e2.exports = function(e3) {
        s2(C2, e3) || (C2[e3] = o2 && s2(c2, e3) ? c2[e3] : h2("Symbol." + e3));
        return C2[e3];
      };
    },
    6573: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(2106), s2 = i2(3238), n2 = ArrayBuffer.prototype;
      a2 && !("detached" in n2) && r2(n2, "detached", {
        configurable: true,
        get: function detached() {
          return s2(this);
        }
      });
    },
    7936: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(5636);
      r2 && a2({
        target: "ArrayBuffer",
        proto: true
      }, {
        transferToFixedLength: function transferToFixedLength() {
          return r2(this, arguments.length ? arguments[0] : void 0, false);
        }
      });
    },
    8100: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(5636);
      r2 && a2({
        target: "ArrayBuffer",
        proto: true
      }, {
        transfer: function transfer() {
          return r2(this, arguments.length ? arguments[0] : void 0, true);
        }
      });
    },
    4114: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(8981), s2 = i2(6198), n2 = i2(4527), o2 = i2(6837);
      a2({
        target: "Array",
        proto: true,
        arity: 1,
        forced: i2(9039)(function() {
          return 4294967297 !== [].push.call({
            length: 4294967296
          }, 1);
        }) || !function() {
          try {
            Object.defineProperty([], "length", {
              writable: false
            }).push();
          } catch (e3) {
            return e3 instanceof TypeError;
          }
        }()
      }, {
        push: function push(e3) {
          var t3 = r2(this), i3 = s2(t3), a3 = arguments.length;
          o2(i3 + a3);
          for (var g2 = 0; g2 < a3; g2++) {
            t3[i3] = arguments[g2];
            i3++;
          }
          n2(t3, i3);
          return i3;
        }
      });
    },
    4628: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(6043);
      a2({
        target: "Promise",
        stat: true
      }, {
        withResolvers: function withResolvers() {
          var e3 = r2.f(this);
          return {
            promise: e3.promise,
            resolve: e3.resolve,
            reject: e3.reject
          };
        }
      });
    },
    9479: (e2, t2, i2) => {
      var a2 = i2(4576), r2 = i2(3724), s2 = i2(2106), n2 = i2(7979), o2 = i2(9039), g2 = a2.RegExp, c2 = g2.prototype;
      r2 && o2(function() {
        var e3 = true;
        try {
          g2(".", "d");
        } catch (t4) {
          e3 = false;
        }
        var t3 = {}, i3 = "", a3 = e3 ? "dgimsy" : "gimsy", addGetter = function(e4, a4) {
          Object.defineProperty(t3, e4, {
            get: function() {
              i3 += a4;
              return true;
            }
          });
        }, r3 = {
          dotAll: "s",
          global: "g",
          ignoreCase: "i",
          multiline: "m",
          sticky: "y"
        };
        e3 && (r3.hasIndices = "d");
        for (var s3 in r3) addGetter(s3, r3[s3]);
        return Object.getOwnPropertyDescriptor(c2, "flags").get.call(t3) !== a3 || i3 !== a3;
      }) && s2(c2, "flags", {
        configurable: true,
        get: n2
      });
    },
    7642: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(3440);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("difference")
      }, {
        difference: r2
      });
    },
    8004: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(9039), s2 = i2(8750);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("intersection") || r2(function() {
          return "3,2" !== String(Array.from((/* @__PURE__ */ new Set([
            1,
            2,
            3
          ])).intersection(/* @__PURE__ */ new Set([
            3,
            2
          ]))));
        })
      }, {
        intersection: s2
      });
    },
    3853: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(4449);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("isDisjointFrom")
      }, {
        isDisjointFrom: r2
      });
    },
    5876: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(3838);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("isSubsetOf")
      }, {
        isSubsetOf: r2
      });
    },
    2475: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(8527);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("isSupersetOf")
      }, {
        isSupersetOf: r2
      });
    },
    5024: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(3650);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("symmetricDifference")
      }, {
        symmetricDifference: r2
      });
    },
    1698: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(4204);
      a2({
        target: "Set",
        proto: true,
        real: true,
        forced: !i2(4916)("union")
      }, {
        union: r2
      });
    },
    7467: (e2, t2, i2) => {
      var a2 = i2(7628), r2 = i2(4644), s2 = r2.aTypedArray, n2 = r2.exportTypedArrayMethod, o2 = r2.getTypedArrayConstructor;
      n2("toReversed", function toReversed() {
        return a2(s2(this), o2(this));
      });
    },
    4732: (e2, t2, i2) => {
      var a2 = i2(4644), r2 = i2(9504), s2 = i2(9306), n2 = i2(5370), o2 = a2.aTypedArray, g2 = a2.getTypedArrayConstructor, c2 = a2.exportTypedArrayMethod, C2 = r2(a2.TypedArrayPrototype.sort);
      c2("toSorted", function toSorted(e3) {
        void 0 !== e3 && s2(e3);
        var t3 = o2(this), i3 = n2(g2(t3), t3);
        return C2(i3, e3);
      });
    },
    9577: (e2, t2, i2) => {
      var a2 = i2(9928), r2 = i2(4644), s2 = i2(1108), n2 = i2(1291), o2 = i2(5854), g2 = r2.aTypedArray, c2 = r2.getTypedArrayConstructor, C2 = r2.exportTypedArrayMethod, h2 = !!function() {
        try {
          new Int8Array(1).with(2, {
            valueOf: function() {
              throw 8;
            }
          });
        } catch (e3) {
          return 8 === e3;
        }
      }();
      C2("with", {
        with: function(e3, t3) {
          var i3 = g2(this), r3 = n2(e3), C3 = s2(i3) ? o2(t3) : +t3;
          return a2(i3, c2(i3), r3, C3);
        }
      }.with, !h2);
    },
    8992: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(4576), s2 = i2(679), n2 = i2(8551), o2 = i2(4901), g2 = i2(2787), c2 = i2(2106), C2 = i2(4659), h2 = i2(9039), l2 = i2(9297), Q2 = i2(8227), E2 = i2(7657).IteratorPrototype, u2 = i2(3724), d2 = i2(6395), f2 = "constructor", p2 = "Iterator", m2 = Q2("toStringTag"), y2 = TypeError, w2 = r2[p2], b2 = d2 || !o2(w2) || w2.prototype !== E2 || !h2(function() {
        w2({});
      }), D2 = function Iterator() {
        s2(this, E2);
        if (g2(this) === E2) throw new y2("Abstract class Iterator not directly constructable");
      }, defineIteratorPrototypeAccessor = function(e3, t3) {
        u2 ? c2(E2, e3, {
          configurable: true,
          get: function() {
            return t3;
          },
          set: function(t4) {
            n2(this);
            if (this === E2) throw new y2("You can't redefine this property");
            l2(this, e3) ? this[e3] = t4 : C2(this, e3, t4);
          }
        }) : E2[e3] = t3;
      };
      l2(E2, m2) || defineIteratorPrototypeAccessor(m2, p2);
      !b2 && l2(E2, f2) && E2[f2] !== Object || defineIteratorPrototypeAccessor(f2, D2);
      D2.prototype = E2;
      a2({
        global: true,
        constructor: true,
        forced: b2
      }, {
        Iterator: D2
      });
    },
    3215: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(2652), s2 = i2(9306), n2 = i2(8551), o2 = i2(1767);
      a2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        every: function every(e3) {
          n2(this);
          s2(e3);
          var t3 = o2(this), i3 = 0;
          return !r2(t3, function(t4, a3) {
            if (!e3(t4, i3++)) return a3();
          }, {
            IS_RECORD: true,
            INTERRUPTED: true
          }).stopped;
        }
      });
    },
    4520: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(9565), s2 = i2(9306), n2 = i2(8551), o2 = i2(1767), g2 = i2(9462), c2 = i2(6319), C2 = i2(6395), h2 = g2(function() {
        for (var e3, t3, i3 = this.iterator, a3 = this.predicate, s3 = this.next; ; ) {
          e3 = n2(r2(s3, i3));
          if (this.done = !!e3.done) return;
          t3 = e3.value;
          if (c2(i3, a3, [
            t3,
            this.counter++
          ], true)) return t3;
        }
      });
      a2({
        target: "Iterator",
        proto: true,
        real: true,
        forced: C2
      }, {
        filter: function filter(e3) {
          n2(this);
          s2(e3);
          return new h2(o2(this), {
            predicate: e3
          });
        }
      });
    },
    2577: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(2652), s2 = i2(9306), n2 = i2(8551), o2 = i2(1767);
      a2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        find: function find2(e3) {
          n2(this);
          s2(e3);
          var t3 = o2(this), i3 = 0;
          return r2(t3, function(t4, a3) {
            if (e3(t4, i3++)) return a3(t4);
          }, {
            IS_RECORD: true,
            INTERRUPTED: true
          }).result;
        }
      });
    },
    3949: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(2652), s2 = i2(9306), n2 = i2(8551), o2 = i2(1767);
      a2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        forEach: function forEach(e3) {
          n2(this);
          s2(e3);
          var t3 = o2(this), i3 = 0;
          r2(t3, function(t4) {
            e3(t4, i3++);
          }, {
            IS_RECORD: true
          });
        }
      });
    },
    1454: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(713);
      a2({
        target: "Iterator",
        proto: true,
        real: true,
        forced: i2(6395)
      }, {
        map: r2
      });
    },
    8872: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(2652), s2 = i2(9306), n2 = i2(8551), o2 = i2(1767), g2 = TypeError;
      a2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        reduce: function reduce(e3) {
          n2(this);
          s2(e3);
          var t3 = o2(this), i3 = arguments.length < 2, a3 = i3 ? void 0 : arguments[1], c2 = 0;
          r2(t3, function(t4) {
            if (i3) {
              i3 = false;
              a3 = t4;
            } else a3 = e3(a3, t4, c2);
            c2++;
          }, {
            IS_RECORD: true
          });
          if (i3) throw new g2("Reduce of empty iterator with no initial value");
          return a3;
        }
      });
    },
    7550: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(2652), s2 = i2(9306), n2 = i2(8551), o2 = i2(1767);
      a2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        some: function some(e3) {
          n2(this);
          s2(e3);
          var t3 = o2(this), i3 = 0;
          return r2(t3, function(t4, a3) {
            if (e3(t4, i3++)) return a3();
          }, {
            IS_RECORD: true,
            INTERRUPTED: true
          }).stopped;
        }
      });
    },
    1795: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(8551), s2 = i2(2652), n2 = i2(1767), o2 = [].push;
      a2({
        target: "Iterator",
        proto: true,
        real: true
      }, {
        toArray: function toArray() {
          var e3 = [];
          s2(n2(r2(this)), o2, {
            that: e3,
            IS_RECORD: true
          });
          return e3;
        }
      });
    },
    4979: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(4576), s2 = i2(7751), n2 = i2(6980), o2 = i2(4913).f, g2 = i2(9297), c2 = i2(679), C2 = i2(3167), h2 = i2(2603), l2 = i2(5002), Q2 = i2(8574), E2 = i2(3724), u2 = i2(6395), d2 = "DOMException", f2 = s2("Error"), p2 = s2(d2), m2 = function DOMException() {
        c2(this, y2);
        var e3 = arguments.length, t3 = h2(e3 < 1 ? void 0 : arguments[0]), i3 = h2(e3 < 2 ? void 0 : arguments[1], "Error"), a3 = new p2(t3, i3), r3 = new f2(t3);
        r3.name = d2;
        o2(a3, "stack", n2(1, Q2(r3.stack, 1)));
        C2(a3, this, m2);
        return a3;
      }, y2 = m2.prototype = p2.prototype, w2 = "stack" in new f2(d2), b2 = "stack" in new p2(1, 2), D2 = p2 && E2 && Object.getOwnPropertyDescriptor(r2, d2), S2 = !(!D2 || D2.writable && D2.configurable), k2 = w2 && !S2 && !b2;
      a2({
        global: true,
        constructor: true,
        forced: u2 || k2
      }, {
        DOMException: k2 ? m2 : p2
      });
      var R2 = s2(d2), N2 = R2.prototype;
      if (N2.constructor !== R2) {
        u2 || o2(N2, "constructor", n2(1, R2));
        for (var G2 in l2) if (g2(l2, G2)) {
          var x2 = l2[G2], U2 = x2.s;
          g2(R2, U2) || o2(R2, U2, n2(6, x2.c));
        }
      }
    },
    3611: (e2, t2, i2) => {
      var a2 = i2(6518), r2 = i2(4576), s2 = i2(2106), n2 = i2(3724), o2 = TypeError, g2 = Object.defineProperty, c2 = r2.self !== r2;
      try {
        if (n2) {
          var C2 = Object.getOwnPropertyDescriptor(r2, "self");
          !c2 && C2 && C2.get && C2.enumerable || s2(r2, "self", {
            get: function self2() {
              return r2;
            },
            set: function self2(e3) {
              if (this !== r2) throw new o2("Illegal invocation");
              g2(r2, "self", {
                value: e3,
                writable: true,
                configurable: true,
                enumerable: true
              });
            },
            configurable: true,
            enumerable: true
          });
        } else a2({
          global: true,
          simple: true,
          forced: c2
        }, {
          self: r2
        });
      } catch (e3) {
      }
    },
    4603: (e2, t2, i2) => {
      var a2 = i2(6840), r2 = i2(9504), s2 = i2(655), n2 = i2(2812), o2 = URLSearchParams, g2 = o2.prototype, c2 = r2(g2.append), C2 = r2(g2.delete), h2 = r2(g2.forEach), l2 = r2([].push), Q2 = new o2("a=1&a=2&b=3");
      Q2.delete("a", 1);
      Q2.delete("b", void 0);
      Q2 + "" != "a=2" && a2(g2, "delete", function(e3) {
        var t3 = arguments.length, i3 = t3 < 2 ? void 0 : arguments[1];
        if (t3 && void 0 === i3) return C2(this, e3);
        var a3 = [];
        h2(this, function(e4, t4) {
          l2(a3, {
            key: t4,
            value: e4
          });
        });
        n2(t3, 1);
        for (var r3, o3 = s2(e3), g3 = s2(i3), Q3 = 0, E2 = 0, u2 = false, d2 = a3.length; Q3 < d2; ) {
          r3 = a3[Q3++];
          if (u2 || r3.key === o3) {
            u2 = true;
            C2(this, r3.key);
          } else E2++;
        }
        for (; E2 < d2; ) (r3 = a3[E2++]).key === o3 && r3.value === g3 || c2(this, r3.key, r3.value);
      }, {
        enumerable: true,
        unsafe: true
      });
    },
    7566: (e2, t2, i2) => {
      var a2 = i2(6840), r2 = i2(9504), s2 = i2(655), n2 = i2(2812), o2 = URLSearchParams, g2 = o2.prototype, c2 = r2(g2.getAll), C2 = r2(g2.has), h2 = new o2("a=1");
      !h2.has("a", 2) && h2.has("a", void 0) || a2(g2, "has", function has(e3) {
        var t3 = arguments.length, i3 = t3 < 2 ? void 0 : arguments[1];
        if (t3 && void 0 === i3) return C2(this, e3);
        var a3 = c2(this, e3);
        n2(t3, 1);
        for (var r3 = s2(i3), o3 = 0; o3 < a3.length; ) if (a3[o3++] === r3) return true;
        return false;
      }, {
        enumerable: true,
        unsafe: true
      });
    },
    8721: (e2, t2, i2) => {
      var a2 = i2(3724), r2 = i2(9504), s2 = i2(2106), n2 = URLSearchParams.prototype, o2 = r2(n2.forEach);
      a2 && !("size" in n2) && s2(n2, "size", {
        get: function size() {
          var e3 = 0;
          o2(this, function() {
            e3++;
          });
          return e3;
        },
        configurable: true,
        enumerable: true
      });
    }
  }, t = {};
  function __webpack_require__(i2) {
    var a2 = t[i2];
    if (void 0 !== a2) return a2.exports;
    var r2 = t[i2] = {
      exports: {}
    };
    e[i2].call(r2.exports, r2, r2.exports, __webpack_require__);
    return r2.exports;
  }
  __webpack_require__.d = (e2, t2) => {
    for (var i2 in t2) __webpack_require__.o(t2, i2) && !__webpack_require__.o(e2, i2) && Object.defineProperty(e2, i2, {
      enumerable: true,
      get: t2[i2]
    });
  };
  __webpack_require__.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
  var __webpack_exports__ = globalThis.pdfjsWorker = {};
  __webpack_require__.d(__webpack_exports__, {
    WorkerMessageHandler: () => WorkerMessageHandler
  });
  __webpack_require__(4114), __webpack_require__(6573), __webpack_require__(8100), __webpack_require__(7936), __webpack_require__(4628), __webpack_require__(7642), __webpack_require__(8004), __webpack_require__(3853), __webpack_require__(5876), __webpack_require__(2475), __webpack_require__(5024), __webpack_require__(1698), __webpack_require__(7467), __webpack_require__(4732), __webpack_require__(9577), __webpack_require__(8992), __webpack_require__(3949), __webpack_require__(1454), __webpack_require__(7550), __webpack_require__(3611), __webpack_require__(4979), __webpack_require__(4603), __webpack_require__(7566), __webpack_require__(8721);
  const i = !("object" != typeof process$1 || process$1 + "" != "[object process]" || process$1.versions.nw || process$1.versions.electron && process$1.type && "browser" !== process$1.type), a = [
    1,
    0,
    0,
    1,
    0,
    0
  ], r = [
    1e-3,
    0,
    0,
    1e-3,
    0,
    0
  ], s = 1.35, n = 0.35, o = 0.25925925925925924, g = 1, c = 2, C = 4, h = 8, l = 16, Q = 64, E = 128, u = 256, d = "pdfjs_internal_editor_", f = 3, p = 9, m = 13, y = 15, w = {
    PRINT: 4,
    MODIFY_CONTENTS: 8,
    COPY: 16,
    MODIFY_ANNOTATIONS: 32,
    FILL_INTERACTIVE_FORMS: 256,
    COPY_FOR_ACCESSIBILITY: 512,
    ASSEMBLE: 1024,
    PRINT_HIGH_QUALITY: 2048
  }, b = 0, D = 4, S = 1, k = 2, R = 3, N = 1, G = 2, x = 3, U = 4, M = 5, L = 6, H = 7, J = 8, v = 9, Y = 10, T = 11, K = 12, q = 13, O = 14, W = 15, j = 16, X = 17, Z = 20, V = "Group", _ = "R", z = 1, $ = 2, AA = 4, eA = 16, tA = 32, iA = 128, aA = 512, rA = 1, sA = 2, nA = 4096, oA = 8192, gA = 32768, IA = 65536, cA = 131072, CA = 1048576, hA = 2097152, lA = 8388608, BA = 16777216, QA = 1, EA = 2, uA = 3, dA = 4, fA = 5, pA = {
    E: "Mouse Enter",
    X: "Mouse Exit",
    D: "Mouse Down",
    U: "Mouse Up",
    Fo: "Focus",
    Bl: "Blur",
    PO: "PageOpen",
    PC: "PageClose",
    PV: "PageVisible",
    PI: "PageInvisible",
    K: "Keystroke",
    F: "Format",
    V: "Validate",
    C: "Calculate"
  }, mA = {
    WC: "WillClose",
    WS: "WillSave",
    DS: "DidSave",
    WP: "WillPrint",
    DP: "DidPrint"
  }, yA = {
    O: "PageOpen",
    C: "PageClose"
  }, wA = {
    ERRORS: 0,
    WARNINGS: 1,
    INFOS: 5
  }, bA = 1, DA = 2, FA = 3, SA = 4, kA = 5, RA = 6, NA = 7, GA = 8, xA = 9, UA = 10, MA = 11, LA = 12, HA = 13, JA = 14, vA = 15, YA = 16, TA = 17, KA = 18, qA = 19, OA = 20, PA = 21, WA = 22, jA = 23, XA = 24, ZA = 25, VA = 26, _A = 27, zA = 28, $A = 29, Ae = 30, ee = 31, te = 32, ie = 33, ae = 34, re = 35, se = 36, ne = 37, oe = 38, ge = 39, Ie = 40, ce = 41, Ce = 42, he = 43, le = 44, Be = 45, Qe = 46, Ee = 47, ue = 48, de = 49, fe = 50, pe = 51, me = 52, ye = 53, we = 54, be = 55, De = 56, Fe = 57, Se = 58, ke = 59, Re = 60, Ne = 61, Ge = 62, xe = 63, Ue = 64, Me = 65, Le = 66, He = 67, Je = 68, ve = 69, Ye = 70, Te = 71, Ke = 72, qe = 73, Oe = 74, Pe = 75, We = 76, je = 77, Xe = 80, Ze = 81, Ve = 83, _e = 84, ze = 85, $e = 86, At = 87, et = 88, tt = 89, it = 90, at = 91, rt = 92, st = 93, nt = 1, ot = 2;
  let gt = wA.WARNINGS;
  function getVerbosityLevel() {
    return gt;
  }
  function info(e2) {
    gt >= wA.INFOS && console.log(`Info: ${e2}`);
  }
  function warn(e2) {
    gt >= wA.WARNINGS && console.log(`Warning: ${e2}`);
  }
  function unreachable(e2) {
    throw new Error(e2);
  }
  function assert(e2, t2) {
    e2 || unreachable(t2);
  }
  function createValidAbsoluteUrl(e2, t2 = null, i2 = null) {
    if (!e2) return null;
    try {
      if (i2 && "string" == typeof e2) {
        if (i2.addDefaultProtocol && e2.startsWith("www.")) {
          const t3 = e2.match(/\./g);
          (t3 == null ? void 0 : t3.length) >= 2 && (e2 = `http://${e2}`);
        }
        if (i2.tryConvertEncoding) try {
          e2 = stringToUTF8String(e2);
        } catch {
        }
      }
      const a2 = t2 ? new URL(e2, t2) : new URL(e2);
      if (function _isValidProtocol(e3) {
        switch (e3 == null ? void 0 : e3.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return true;
          default:
            return false;
        }
      }(a2)) return a2;
    } catch {
    }
    return null;
  }
  function shadow(e2, t2, i2, a2 = false) {
    Object.defineProperty(e2, t2, {
      value: i2,
      enumerable: !a2,
      configurable: true,
      writable: false
    });
    return i2;
  }
  const It = function BaseExceptionClosure() {
    function BaseException(e2, t2) {
      this.message = e2;
      this.name = t2;
    }
    BaseException.prototype = new Error();
    BaseException.constructor = BaseException;
    return BaseException;
  }();
  class PasswordException extends It {
    constructor(e2, t2) {
      super(e2, "PasswordException");
      this.code = t2;
    }
  }
  class UnknownErrorException extends It {
    constructor(e2, t2) {
      super(e2, "UnknownErrorException");
      this.details = t2;
    }
  }
  class InvalidPDFException extends It {
    constructor(e2) {
      super(e2, "InvalidPDFException");
    }
  }
  class MissingPDFException extends It {
    constructor(e2) {
      super(e2, "MissingPDFException");
    }
  }
  class UnexpectedResponseException extends It {
    constructor(e2, t2) {
      super(e2, "UnexpectedResponseException");
      this.status = t2;
    }
  }
  class FormatError extends It {
    constructor(e2) {
      super(e2, "FormatError");
    }
  }
  class AbortException extends It {
    constructor(e2) {
      super(e2, "AbortException");
    }
  }
  function bytesToString(e2) {
    "object" == typeof e2 && void 0 !== (e2 == null ? void 0 : e2.length) || unreachable("Invalid argument for bytesToString");
    const t2 = e2.length, i2 = 8192;
    if (t2 < i2) return String.fromCharCode.apply(null, e2);
    const a2 = [];
    for (let r2 = 0; r2 < t2; r2 += i2) {
      const s2 = Math.min(r2 + i2, t2), n2 = e2.subarray(r2, s2);
      a2.push(String.fromCharCode.apply(null, n2));
    }
    return a2.join("");
  }
  function stringToBytes(e2) {
    "string" != typeof e2 && unreachable("Invalid argument for stringToBytes");
    const t2 = e2.length, i2 = new Uint8Array(t2);
    for (let a2 = 0; a2 < t2; ++a2) i2[a2] = 255 & e2.charCodeAt(a2);
    return i2;
  }
  function string32(e2) {
    return String.fromCharCode(e2 >> 24 & 255, e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2);
  }
  function objectSize(e2) {
    return Object.keys(e2).length;
  }
  class FeatureTest {
    static get isLittleEndian() {
      return shadow(this, "isLittleEndian", function isLittleEndian() {
        const e2 = new Uint8Array(4);
        e2[0] = 1;
        return 1 === new Uint32Array(e2.buffer, 0, 1)[0];
      }());
    }
    static get isEvalSupported() {
      return shadow(this, "isEvalSupported", function isEvalSupported() {
        try {
          new Function("");
          return true;
        } catch {
          return false;
        }
      }());
    }
    static get isOffscreenCanvasSupported() {
      return shadow(this, "isOffscreenCanvasSupported", "undefined" != typeof OffscreenCanvas);
    }
    static get platform() {
      return "undefined" != typeof navigator && "string" == typeof (navigator == null ? void 0 : navigator.platform) ? shadow(this, "platform", {
        isMac: navigator.platform.includes("Mac"),
        isWindows: navigator.platform.includes("Win"),
        isFirefox: "string" == typeof (navigator == null ? void 0 : navigator.userAgent) && navigator.userAgent.includes("Firefox")
      }) : shadow(this, "platform", {
        isMac: false,
        isWindows: false,
        isFirefox: false
      });
    }
    static get isCSSRoundSupported() {
      var _a4, _b;
      return shadow(this, "isCSSRoundSupported", (_b = (_a4 = globalThis.CSS) == null ? void 0 : _a4.supports) == null ? void 0 : _b.call(_a4, "width: round(1.5px, 1px)"));
    }
  }
  const ct = Array.from(Array(256).keys(), (e2) => e2.toString(16).padStart(2, "0"));
  class Util {
    static makeHexColor(e2, t2, i2) {
      return `#${ct[e2]}${ct[t2]}${ct[i2]}`;
    }
    static scaleMinMax(e2, t2) {
      let i2;
      if (e2[0]) {
        if (e2[0] < 0) {
          i2 = t2[0];
          t2[0] = t2[2];
          t2[2] = i2;
        }
        t2[0] *= e2[0];
        t2[2] *= e2[0];
        if (e2[3] < 0) {
          i2 = t2[1];
          t2[1] = t2[3];
          t2[3] = i2;
        }
        t2[1] *= e2[3];
        t2[3] *= e2[3];
      } else {
        i2 = t2[0];
        t2[0] = t2[1];
        t2[1] = i2;
        i2 = t2[2];
        t2[2] = t2[3];
        t2[3] = i2;
        if (e2[1] < 0) {
          i2 = t2[1];
          t2[1] = t2[3];
          t2[3] = i2;
        }
        t2[1] *= e2[1];
        t2[3] *= e2[1];
        if (e2[2] < 0) {
          i2 = t2[0];
          t2[0] = t2[2];
          t2[2] = i2;
        }
        t2[0] *= e2[2];
        t2[2] *= e2[2];
      }
      t2[0] += e2[4];
      t2[1] += e2[5];
      t2[2] += e2[4];
      t2[3] += e2[5];
    }
    static transform(e2, t2) {
      return [
        e2[0] * t2[0] + e2[2] * t2[1],
        e2[1] * t2[0] + e2[3] * t2[1],
        e2[0] * t2[2] + e2[2] * t2[3],
        e2[1] * t2[2] + e2[3] * t2[3],
        e2[0] * t2[4] + e2[2] * t2[5] + e2[4],
        e2[1] * t2[4] + e2[3] * t2[5] + e2[5]
      ];
    }
    static applyTransform(e2, t2) {
      return [
        e2[0] * t2[0] + e2[1] * t2[2] + t2[4],
        e2[0] * t2[1] + e2[1] * t2[3] + t2[5]
      ];
    }
    static applyInverseTransform(e2, t2) {
      const i2 = t2[0] * t2[3] - t2[1] * t2[2];
      return [
        (e2[0] * t2[3] - e2[1] * t2[2] + t2[2] * t2[5] - t2[4] * t2[3]) / i2,
        (-e2[0] * t2[1] + e2[1] * t2[0] + t2[4] * t2[1] - t2[5] * t2[0]) / i2
      ];
    }
    static getAxialAlignedBoundingBox(e2, t2) {
      const i2 = this.applyTransform(e2, t2), a2 = this.applyTransform(e2.slice(2, 4), t2), r2 = this.applyTransform([
        e2[0],
        e2[3]
      ], t2), s2 = this.applyTransform([
        e2[2],
        e2[1]
      ], t2);
      return [
        Math.min(i2[0], a2[0], r2[0], s2[0]),
        Math.min(i2[1], a2[1], r2[1], s2[1]),
        Math.max(i2[0], a2[0], r2[0], s2[0]),
        Math.max(i2[1], a2[1], r2[1], s2[1])
      ];
    }
    static inverseTransform(e2) {
      const t2 = e2[0] * e2[3] - e2[1] * e2[2];
      return [
        e2[3] / t2,
        -e2[1] / t2,
        -e2[2] / t2,
        e2[0] / t2,
        (e2[2] * e2[5] - e2[4] * e2[3]) / t2,
        (e2[4] * e2[1] - e2[5] * e2[0]) / t2
      ];
    }
    static singularValueDecompose2dScale(e2) {
      const t2 = [
        e2[0],
        e2[2],
        e2[1],
        e2[3]
      ], i2 = e2[0] * t2[0] + e2[1] * t2[2], a2 = e2[0] * t2[1] + e2[1] * t2[3], r2 = e2[2] * t2[0] + e2[3] * t2[2], s2 = e2[2] * t2[1] + e2[3] * t2[3], n2 = (i2 + s2) / 2, o2 = Math.sqrt((i2 + s2) ** 2 - 4 * (i2 * s2 - r2 * a2)) / 2, g2 = n2 + o2 || 1, c2 = n2 - o2 || 1;
      return [
        Math.sqrt(g2),
        Math.sqrt(c2)
      ];
    }
    static normalizeRect(e2) {
      const t2 = e2.slice(0);
      if (e2[0] > e2[2]) {
        t2[0] = e2[2];
        t2[2] = e2[0];
      }
      if (e2[1] > e2[3]) {
        t2[1] = e2[3];
        t2[3] = e2[1];
      }
      return t2;
    }
    static intersect(e2, t2) {
      const i2 = Math.max(Math.min(e2[0], e2[2]), Math.min(t2[0], t2[2])), a2 = Math.min(Math.max(e2[0], e2[2]), Math.max(t2[0], t2[2]));
      if (i2 > a2) return null;
      const r2 = Math.max(Math.min(e2[1], e2[3]), Math.min(t2[1], t2[3])), s2 = Math.min(Math.max(e2[1], e2[3]), Math.max(t2[1], t2[3]));
      return r2 > s2 ? null : [
        i2,
        r2,
        a2,
        s2
      ];
    }
    static bezierBoundingBox(e2, t2, i2, a2, r2, s2, n2, o2, g2) {
      if (g2) {
        g2[0] = Math.min(g2[0], e2, n2);
        g2[1] = Math.min(g2[1], t2, o2);
        g2[2] = Math.max(g2[2], e2, n2);
        g2[3] = Math.max(g2[3], t2, o2);
      } else g2 = [
        Math.min(e2, n2),
        Math.min(t2, o2),
        Math.max(e2, n2),
        Math.max(t2, o2)
      ];
      __privateMethod(this, _Util_static, e_fn).call(this, e2, i2, r2, n2, t2, a2, s2, o2, 3 * (3 * (i2 - r2) - e2 + n2), 6 * (e2 - 2 * i2 + r2), 3 * (i2 - e2), g2);
      __privateMethod(this, _Util_static, e_fn).call(this, e2, i2, r2, n2, t2, a2, s2, o2, 3 * (3 * (a2 - s2) - t2 + o2), 6 * (t2 - 2 * a2 + s2), 3 * (a2 - t2), g2);
      return g2;
    }
  }
  _Util_static = new WeakSet();
  A_fn = function(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2) {
    if (g2 <= 0 || g2 >= 1) return;
    const C2 = 1 - g2, h2 = g2 * g2, l2 = h2 * g2, Q2 = C2 * (C2 * (C2 * e2 + 3 * g2 * t2) + 3 * h2 * i2) + l2 * a2, E2 = C2 * (C2 * (C2 * r2 + 3 * g2 * s2) + 3 * h2 * n2) + l2 * o2;
    c2[0] = Math.min(c2[0], Q2);
    c2[1] = Math.min(c2[1], E2);
    c2[2] = Math.max(c2[2], Q2);
    c2[3] = Math.max(c2[3], E2);
  };
  e_fn = function(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2, C2, h2) {
    if (Math.abs(g2) < 1e-12) {
      Math.abs(c2) >= 1e-12 && __privateMethod(this, _Util_static, A_fn).call(this, e2, t2, i2, a2, r2, s2, n2, o2, -C2 / c2, h2);
      return;
    }
    const l2 = c2 ** 2 - 4 * C2 * g2;
    if (l2 < 0) return;
    const Q2 = Math.sqrt(l2), E2 = 2 * g2;
    __privateMethod(this, _Util_static, A_fn).call(this, e2, t2, i2, a2, r2, s2, n2, o2, (-c2 + Q2) / E2, h2);
    __privateMethod(this, _Util_static, A_fn).call(this, e2, t2, i2, a2, r2, s2, n2, o2, (-c2 - Q2) / E2, h2);
  };
  __privateAdd(Util, _Util_static);
  const Ct = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    728,
    711,
    710,
    729,
    733,
    731,
    730,
    732,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8226,
    8224,
    8225,
    8230,
    8212,
    8211,
    402,
    8260,
    8249,
    8250,
    8722,
    8240,
    8222,
    8220,
    8221,
    8216,
    8217,
    8218,
    8482,
    64257,
    64258,
    321,
    338,
    352,
    376,
    381,
    305,
    322,
    339,
    353,
    382,
    0,
    8364
  ];
  function stringToPDFString(e2) {
    if (e2[0] >= "\xEF") {
      let t3;
      if ("\xFE" === e2[0] && "\xFF" === e2[1]) {
        t3 = "utf-16be";
        e2.length % 2 == 1 && (e2 = e2.slice(0, -1));
      } else if ("\xFF" === e2[0] && "\xFE" === e2[1]) {
        t3 = "utf-16le";
        e2.length % 2 == 1 && (e2 = e2.slice(0, -1));
      } else "\xEF" === e2[0] && "\xBB" === e2[1] && "\xBF" === e2[2] && (t3 = "utf-8");
      if (t3) try {
        const i2 = new TextDecoder(t3, {
          fatal: true
        }), a2 = stringToBytes(e2), r2 = i2.decode(a2);
        return r2.includes("\x1B") ? r2.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "") : r2;
      } catch (e3) {
        warn(`stringToPDFString: "${e3}".`);
      }
    }
    const t2 = [];
    for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
      const r2 = e2.charCodeAt(i2);
      if (27 === r2) {
        for (; ++i2 < a2 && 27 !== e2.charCodeAt(i2); ) ;
        continue;
      }
      const s2 = Ct[r2];
      t2.push(s2 ? String.fromCharCode(s2) : e2.charAt(i2));
    }
    return t2.join("");
  }
  function stringToUTF8String(e2) {
    return decodeURIComponent(escape(e2));
  }
  function utf8StringToString(e2) {
    return unescape(encodeURIComponent(e2));
  }
  function isArrayEqual(e2, t2) {
    if (e2.length !== t2.length) return false;
    for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) if (e2[i2] !== t2[i2]) return false;
    return true;
  }
  function getModificationDate(e2 = /* @__PURE__ */ new Date()) {
    return [
      e2.getUTCFullYear().toString(),
      (e2.getUTCMonth() + 1).toString().padStart(2, "0"),
      e2.getUTCDate().toString().padStart(2, "0"),
      e2.getUTCHours().toString().padStart(2, "0"),
      e2.getUTCMinutes().toString().padStart(2, "0"),
      e2.getUTCSeconds().toString().padStart(2, "0")
    ].join("");
  }
  let ht = null, lt = null;
  const Bt = 0, Qt = 1, Et = 2, ut = 3, dt = 4, ft = 5, pt = 6, mt = 7, yt = 8;
  function toHexUtil(e2) {
    return Uint8Array.prototype.toHex ? e2.toHex() : Array.from(e2, (e3) => ct[e3]).join("");
  }
  __webpack_require__(3215);
  const wt = Symbol("CIRCULAR_REF"), bt = Symbol("EOF");
  let Dt = /* @__PURE__ */ Object.create(null), Ft = /* @__PURE__ */ Object.create(null), St = /* @__PURE__ */ Object.create(null);
  class Name {
    constructor(e2) {
      this.name = e2;
    }
    static get(e2) {
      return Ft[e2] || (Ft[e2] = new Name(e2));
    }
  }
  class Cmd {
    constructor(e2) {
      this.cmd = e2;
    }
    static get(e2) {
      return Dt[e2] || (Dt[e2] = new Cmd(e2));
    }
  }
  const kt = function nonSerializableClosure() {
    return kt;
  };
  class Dict {
    constructor(e2 = null) {
      this._map = /* @__PURE__ */ Object.create(null);
      this.xref = e2;
      this.objId = null;
      this.suppressEncryption = false;
      this.__nonSerializable__ = kt;
    }
    assignXref(e2) {
      this.xref = e2;
    }
    get size() {
      return Object.keys(this._map).length;
    }
    get(e2, t2, i2) {
      let a2 = this._map[e2];
      if (void 0 === a2 && void 0 !== t2) {
        a2 = this._map[t2];
        void 0 === a2 && void 0 !== i2 && (a2 = this._map[i2]);
      }
      return a2 instanceof Ref && this.xref ? this.xref.fetch(a2, this.suppressEncryption) : a2;
    }
    async getAsync(e2, t2, i2) {
      let a2 = this._map[e2];
      if (void 0 === a2 && void 0 !== t2) {
        a2 = this._map[t2];
        void 0 === a2 && void 0 !== i2 && (a2 = this._map[i2]);
      }
      return a2 instanceof Ref && this.xref ? this.xref.fetchAsync(a2, this.suppressEncryption) : a2;
    }
    getArray(e2, t2, i2) {
      let a2 = this._map[e2];
      if (void 0 === a2 && void 0 !== t2) {
        a2 = this._map[t2];
        void 0 === a2 && void 0 !== i2 && (a2 = this._map[i2]);
      }
      a2 instanceof Ref && this.xref && (a2 = this.xref.fetch(a2, this.suppressEncryption));
      if (Array.isArray(a2)) {
        a2 = a2.slice();
        for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) a2[e3] instanceof Ref && this.xref && (a2[e3] = this.xref.fetch(a2[e3], this.suppressEncryption));
      }
      return a2;
    }
    getRaw(e2) {
      return this._map[e2];
    }
    getKeys() {
      return Object.keys(this._map);
    }
    getRawValues() {
      return Object.values(this._map);
    }
    set(e2, t2) {
      this._map[e2] = t2;
    }
    has(e2) {
      return void 0 !== this._map[e2];
    }
    forEach(e2) {
      for (const t2 in this._map) e2(t2, this.get(t2));
    }
    static get empty() {
      const e2 = new Dict(null);
      e2.set = (e3, t2) => {
        unreachable("Should not call `set` on the empty dictionary.");
      };
      return shadow(this, "empty", e2);
    }
    static merge({ xref: e2, dictArray: t2, mergeSubDicts: i2 = false }) {
      const a2 = new Dict(e2), r2 = /* @__PURE__ */ new Map();
      for (const e3 of t2) if (e3 instanceof Dict) for (const [t3, a3] of Object.entries(e3._map)) {
        let e4 = r2.get(t3);
        if (void 0 === e4) {
          e4 = [];
          r2.set(t3, e4);
        } else if (!(i2 && a3 instanceof Dict)) continue;
        e4.push(a3);
      }
      for (const [t3, i3] of r2) {
        if (1 === i3.length || !(i3[0] instanceof Dict)) {
          a2._map[t3] = i3[0];
          continue;
        }
        const r3 = new Dict(e2);
        for (const e3 of i3) for (const [t4, i4] of Object.entries(e3._map)) void 0 === r3._map[t4] && (r3._map[t4] = i4);
        r3.size > 0 && (a2._map[t3] = r3);
      }
      r2.clear();
      return a2.size > 0 ? a2 : Dict.empty;
    }
    clone() {
      const e2 = new Dict(this.xref);
      for (const t2 of this.getKeys()) e2.set(t2, this.getRaw(t2));
      return e2;
    }
    delete(e2) {
      delete this._map[e2];
    }
  }
  class Ref {
    constructor(e2, t2) {
      this.num = e2;
      this.gen = t2;
    }
    toString() {
      return 0 === this.gen ? `${this.num}R` : `${this.num}R${this.gen}`;
    }
    static fromString(e2) {
      const t2 = St[e2];
      if (t2) return t2;
      const i2 = /^(\d+)R(\d*)$/.exec(e2);
      return i2 && "0" !== i2[1] ? St[e2] = new Ref(parseInt(i2[1]), i2[2] ? parseInt(i2[2]) : 0) : null;
    }
    static get(e2, t2) {
      const i2 = 0 === t2 ? `${e2}R` : `${e2}R${t2}`;
      return St[i2] || (St[i2] = new Ref(e2, t2));
    }
  }
  class RefSet {
    constructor(e2 = null) {
      this._set = new Set(e2 == null ? void 0 : e2._set);
    }
    has(e2) {
      return this._set.has(e2.toString());
    }
    put(e2) {
      this._set.add(e2.toString());
    }
    remove(e2) {
      this._set.delete(e2.toString());
    }
    [Symbol.iterator]() {
      return this._set.values();
    }
    clear() {
      this._set.clear();
    }
  }
  class RefSetCache {
    constructor() {
      this._map = /* @__PURE__ */ new Map();
    }
    get size() {
      return this._map.size;
    }
    get(e2) {
      return this._map.get(e2.toString());
    }
    has(e2) {
      return this._map.has(e2.toString());
    }
    put(e2, t2) {
      this._map.set(e2.toString(), t2);
    }
    putAlias(e2, t2) {
      this._map.set(e2.toString(), this.get(t2));
    }
    [Symbol.iterator]() {
      return this._map.values();
    }
    clear() {
      this._map.clear();
    }
    *items() {
      for (const [e2, t2] of this._map) yield [
        Ref.fromString(e2),
        t2
      ];
    }
  }
  function isName(e2, t2) {
    return e2 instanceof Name && (void 0 === t2 || e2.name === t2);
  }
  function isCmd(e2, t2) {
    return e2 instanceof Cmd && (void 0 === t2 || e2.cmd === t2);
  }
  function isDict(e2, t2) {
    return e2 instanceof Dict && (void 0 === t2 || isName(e2.get("Type"), t2));
  }
  function isRefsEqual(e2, t2) {
    return e2.num === t2.num && e2.gen === t2.gen;
  }
  class BaseStream {
    get length() {
      unreachable("Abstract getter `length` accessed");
    }
    get isEmpty() {
      unreachable("Abstract getter `isEmpty` accessed");
    }
    get isDataLoaded() {
      return shadow(this, "isDataLoaded", true);
    }
    getByte() {
      unreachable("Abstract method `getByte` called");
    }
    getBytes(e2) {
      unreachable("Abstract method `getBytes` called");
    }
    async getImageData(e2, t2) {
      return this.getBytes(e2, t2);
    }
    async asyncGetBytes() {
      unreachable("Abstract method `asyncGetBytes` called");
    }
    get isAsync() {
      return false;
    }
    get canAsyncDecodeImageFromBuffer() {
      return false;
    }
    async getTransferableImage() {
      return null;
    }
    peekByte() {
      const e2 = this.getByte();
      -1 !== e2 && this.pos--;
      return e2;
    }
    peekBytes(e2) {
      const t2 = this.getBytes(e2);
      this.pos -= t2.length;
      return t2;
    }
    getUint16() {
      const e2 = this.getByte(), t2 = this.getByte();
      return -1 === e2 || -1 === t2 ? -1 : (e2 << 8) + t2;
    }
    getInt32() {
      return (this.getByte() << 24) + (this.getByte() << 16) + (this.getByte() << 8) + this.getByte();
    }
    getByteRange(e2, t2) {
      unreachable("Abstract method `getByteRange` called");
    }
    getString(e2) {
      return bytesToString(this.getBytes(e2));
    }
    skip(e2) {
      this.pos += e2 || 1;
    }
    reset() {
      unreachable("Abstract method `reset` called");
    }
    moveStart() {
      unreachable("Abstract method `moveStart` called");
    }
    makeSubStream(e2, t2, i2 = null) {
      unreachable("Abstract method `makeSubStream` called");
    }
    getBaseStreams() {
      return null;
    }
  }
  const Rt = /^[1-9]\.\d$/;
  function getLookupTableFactory(e2) {
    let t2;
    return function() {
      if (e2) {
        t2 = /* @__PURE__ */ Object.create(null);
        e2(t2);
        e2 = null;
      }
      return t2;
    };
  }
  class MissingDataException extends It {
    constructor(e2, t2) {
      super(`Missing data [${e2}, ${t2})`, "MissingDataException");
      this.begin = e2;
      this.end = t2;
    }
  }
  class ParserEOFException extends It {
    constructor(e2) {
      super(e2, "ParserEOFException");
    }
  }
  class XRefEntryException extends It {
    constructor(e2) {
      super(e2, "XRefEntryException");
    }
  }
  class XRefParseException extends It {
    constructor(e2) {
      super(e2, "XRefParseException");
    }
  }
  function arrayBuffersToBytes(e2) {
    const t2 = e2.length;
    if (0 === t2) return new Uint8Array(0);
    if (1 === t2) return new Uint8Array(e2[0]);
    let i2 = 0;
    for (let a3 = 0; a3 < t2; a3++) i2 += e2[a3].byteLength;
    const a2 = new Uint8Array(i2);
    let r2 = 0;
    for (let i3 = 0; i3 < t2; i3++) {
      const t3 = new Uint8Array(e2[i3]);
      a2.set(t3, r2);
      r2 += t3.byteLength;
    }
    return a2;
  }
  function getInheritableProperty({ dict: e2, key: t2, getArray: i2 = false, stopWhenFound: a2 = true }) {
    let r2;
    const s2 = new RefSet();
    for (; e2 instanceof Dict && (!e2.objId || !s2.has(e2.objId)); ) {
      e2.objId && s2.put(e2.objId);
      const n2 = i2 ? e2.getArray(t2) : e2.get(t2);
      if (void 0 !== n2) {
        if (a2) return n2;
        (r2 || (r2 = [])).push(n2);
      }
      e2 = e2.get("Parent");
    }
    return r2;
  }
  const Nt = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
  ];
  function toRomanNumerals(e2, t2 = false) {
    assert(Number.isInteger(e2) && e2 > 0, "The number should be a positive integer.");
    const i2 = [];
    let a2;
    for (; e2 >= 1e3; ) {
      e2 -= 1e3;
      i2.push("M");
    }
    a2 = e2 / 100 | 0;
    e2 %= 100;
    i2.push(Nt[a2]);
    a2 = e2 / 10 | 0;
    e2 %= 10;
    i2.push(Nt[10 + a2]);
    i2.push(Nt[20 + e2]);
    const r2 = i2.join("");
    return t2 ? r2.toLowerCase() : r2;
  }
  function log2(e2) {
    return e2 <= 0 ? 0 : Math.ceil(Math.log2(e2));
  }
  function readInt8(e2, t2) {
    return e2[t2] << 24 >> 24;
  }
  function readUint16(e2, t2) {
    return e2[t2] << 8 | e2[t2 + 1];
  }
  function readUint32(e2, t2) {
    return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
  }
  function isWhiteSpace(e2) {
    return 32 === e2 || 9 === e2 || 13 === e2 || 10 === e2;
  }
  function isNumberArray(e2, t2) {
    return Array.isArray(e2) ? (null === t2 || e2.length === t2) && e2.every((e3) => "number" == typeof e3) : ArrayBuffer.isView(e2) && (0 === e2.length || "number" == typeof e2[0]) && (null === t2 || e2.length === t2);
  }
  function lookupMatrix(e2, t2) {
    return isNumberArray(e2, 6) ? e2 : t2;
  }
  function lookupRect(e2, t2) {
    return isNumberArray(e2, 4) ? e2 : t2;
  }
  function lookupNormalRect(e2, t2) {
    return isNumberArray(e2, 4) ? Util.normalizeRect(e2) : t2;
  }
  function parseXFAPath(e2) {
    const t2 = /(.+)\[(\d+)\]$/;
    return e2.split(".").map((e3) => {
      const i2 = e3.match(t2);
      return i2 ? {
        name: i2[1],
        pos: parseInt(i2[2], 10)
      } : {
        name: e3,
        pos: 0
      };
    });
  }
  function escapePDFName(e2) {
    const t2 = [];
    let i2 = 0;
    for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) {
      const r3 = e2.charCodeAt(a2);
      if (r3 < 33 || r3 > 126 || 35 === r3 || 40 === r3 || 41 === r3 || 60 === r3 || 62 === r3 || 91 === r3 || 93 === r3 || 123 === r3 || 125 === r3 || 47 === r3 || 37 === r3) {
        i2 < a2 && t2.push(e2.substring(i2, a2));
        t2.push(`#${r3.toString(16)}`);
        i2 = a2 + 1;
      }
    }
    if (0 === t2.length) return e2;
    i2 < e2.length && t2.push(e2.substring(i2, e2.length));
    return t2.join("");
  }
  function escapeString(e2) {
    return e2.replaceAll(/([()\\\n\r])/g, (e3) => "\n" === e3 ? "\\n" : "\r" === e3 ? "\\r" : `\\${e3}`);
  }
  function _collectJS(e2, t2, i2, a2) {
    if (!e2) return;
    let r2 = null;
    if (e2 instanceof Ref) {
      if (a2.has(e2)) return;
      r2 = e2;
      a2.put(r2);
      e2 = t2.fetch(e2);
    }
    if (Array.isArray(e2)) for (const r3 of e2) _collectJS(r3, t2, i2, a2);
    else if (e2 instanceof Dict) {
      if (isName(e2.get("S"), "JavaScript")) {
        const t3 = e2.get("JS");
        let a3;
        t3 instanceof BaseStream ? a3 = t3.getString() : "string" == typeof t3 && (a3 = t3);
        a3 && (a3 = stringToPDFString(a3).replaceAll("\0", ""));
        a3 && i2.push(a3);
      }
      _collectJS(e2.getRaw("Next"), t2, i2, a2);
    }
    r2 && a2.remove(r2);
  }
  function collectActions(e2, t2, i2) {
    const a2 = /* @__PURE__ */ Object.create(null), r2 = getInheritableProperty({
      dict: t2,
      key: "AA",
      stopWhenFound: false
    });
    if (r2) for (let t3 = r2.length - 1; t3 >= 0; t3--) {
      const s2 = r2[t3];
      if (s2 instanceof Dict) for (const t4 of s2.getKeys()) {
        const r3 = i2[t4];
        if (!r3) continue;
        const n2 = [];
        _collectJS(s2.getRaw(t4), e2, n2, new RefSet());
        n2.length > 0 && (a2[r3] = n2);
      }
    }
    if (t2.has("A")) {
      const i3 = [];
      _collectJS(t2.get("A"), e2, i3, new RefSet());
      i3.length > 0 && (a2.Action = i3);
    }
    return objectSize(a2) > 0 ? a2 : null;
  }
  const Gt = {
    60: "&lt;",
    62: "&gt;",
    38: "&amp;",
    34: "&quot;",
    39: "&apos;"
  };
  function* codePointIter(e2) {
    for (let t2 = 0, i2 = e2.length; t2 < i2; t2++) {
      const i3 = e2.codePointAt(t2);
      i3 > 55295 && (i3 < 57344 || i3 > 65533) && t2++;
      yield i3;
    }
  }
  function encodeToXmlString(e2) {
    const t2 = [];
    let i2 = 0;
    for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) {
      const r3 = e2.codePointAt(a2);
      if (32 <= r3 && r3 <= 126) {
        const s2 = Gt[r3];
        if (s2) {
          i2 < a2 && t2.push(e2.substring(i2, a2));
          t2.push(s2);
          i2 = a2 + 1;
        }
      } else {
        i2 < a2 && t2.push(e2.substring(i2, a2));
        t2.push(`&#x${r3.toString(16).toUpperCase()};`);
        r3 > 55295 && (r3 < 57344 || r3 > 65533) && a2++;
        i2 = a2 + 1;
      }
    }
    if (0 === t2.length) return e2;
    i2 < e2.length && t2.push(e2.substring(i2, e2.length));
    return t2.join("");
  }
  function validateFontName(e2, t2 = false) {
    const i2 = /^("|').*("|')$/.exec(e2);
    if (i2 && i2[1] === i2[2]) {
      if (new RegExp(`[^\\\\]${i2[1]}`).test(e2.slice(1, -1))) {
        t2 && warn(`FontFamily contains unescaped ${i2[1]}: ${e2}.`);
        return false;
      }
    } else for (const i3 of e2.split(/[ \t]+/)) if (/^(\d|(-(\d|-)))/.test(i3) || !/^[\w-\\]+$/.test(i3)) {
      t2 && warn(`FontFamily contains invalid <custom-ident>: ${e2}.`);
      return false;
    }
    return true;
  }
  function validateCSSFont(e2) {
    const t2 = /* @__PURE__ */ new Set([
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
      "1000",
      "normal",
      "bold",
      "bolder",
      "lighter"
    ]), { fontFamily: i2, fontWeight: a2, italicAngle: r2 } = e2;
    if (!validateFontName(i2, true)) return false;
    const s2 = a2 ? a2.toString() : "";
    e2.fontWeight = t2.has(s2) ? s2 : "400";
    const n2 = parseFloat(r2);
    e2.italicAngle = isNaN(n2) || n2 < -90 || n2 > 90 ? "14" : r2.toString();
    return true;
  }
  function recoverJsURL(e2) {
    const t2 = new RegExp("^\\s*(" + [
      "app.launchURL",
      "window.open",
      "xfa.host.gotoURL"
    ].join("|").replaceAll(".", "\\.") + `)\\((?:'|")([^'"]*)(?:'|")(?:,\\s*(\\w+)\\)|\\))`, "i").exec(e2);
    if (t2 == null ? void 0 : t2[2]) {
      const e3 = t2[2];
      let i2 = false;
      "true" === t2[3] && "app.launchURL" === t2[1] && (i2 = true);
      return {
        url: e3,
        newWindow: i2
      };
    }
    return null;
  }
  function numberToString(e2) {
    if (Number.isInteger(e2)) return e2.toString();
    const t2 = Math.round(100 * e2);
    return t2 % 100 == 0 ? (t2 / 100).toString() : t2 % 10 == 0 ? e2.toFixed(1) : e2.toFixed(2);
  }
  function getNewAnnotationsMap(e2) {
    if (!e2) return null;
    const t2 = /* @__PURE__ */ new Map();
    for (const [i2, a2] of e2) {
      if (!i2.startsWith(d)) continue;
      let e3 = t2.get(a2.pageIndex);
      if (!e3) {
        e3 = [];
        t2.set(a2.pageIndex, e3);
      }
      e3.push(a2);
    }
    return t2.size > 0 ? t2 : null;
  }
  function stringToAsciiOrUTF16BE(e2) {
    return function isAscii(e3) {
      return /^[\x00-\x7F]*$/.test(e3);
    }(e2) ? e2 : stringToUTF16String(e2, true);
  }
  function stringToUTF16HexString(e2) {
    const t2 = [];
    for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
      const a3 = e2.charCodeAt(i2);
      t2.push(ct[a3 >> 8 & 255], ct[255 & a3]);
    }
    return t2.join("");
  }
  function stringToUTF16String(e2, t2 = false) {
    const i2 = [];
    t2 && i2.push("\xFE\xFF");
    for (let t3 = 0, a2 = e2.length; t3 < a2; t3++) {
      const a3 = e2.charCodeAt(t3);
      i2.push(String.fromCharCode(a3 >> 8 & 255), String.fromCharCode(255 & a3));
    }
    return i2.join("");
  }
  function getRotationMatrix(e2, t2, i2) {
    switch (e2) {
      case 90:
        return [
          0,
          1,
          -1,
          0,
          t2,
          0
        ];
      case 180:
        return [
          -1,
          0,
          0,
          -1,
          t2,
          i2
        ];
      case 270:
        return [
          0,
          -1,
          1,
          0,
          0,
          i2
        ];
      default:
        throw new Error("Invalid rotation");
    }
  }
  function getSizeInBytes(e2) {
    return Math.ceil(Math.ceil(Math.log2(1 + e2)) / 8);
  }
  class Stream extends BaseStream {
    constructor(e2, t2, i2, a2) {
      super();
      this.bytes = e2 instanceof Uint8Array ? e2 : new Uint8Array(e2);
      this.start = t2 || 0;
      this.pos = this.start;
      this.end = t2 + i2 || this.bytes.length;
      this.dict = a2;
    }
    get length() {
      return this.end - this.start;
    }
    get isEmpty() {
      return 0 === this.length;
    }
    getByte() {
      return this.pos >= this.end ? -1 : this.bytes[this.pos++];
    }
    getBytes(e2) {
      const t2 = this.bytes, i2 = this.pos, a2 = this.end;
      if (!e2) return t2.subarray(i2, a2);
      let r2 = i2 + e2;
      r2 > a2 && (r2 = a2);
      this.pos = r2;
      return t2.subarray(i2, r2);
    }
    getByteRange(e2, t2) {
      e2 < 0 && (e2 = 0);
      t2 > this.end && (t2 = this.end);
      return this.bytes.subarray(e2, t2);
    }
    reset() {
      this.pos = this.start;
    }
    moveStart() {
      this.start = this.pos;
    }
    makeSubStream(e2, t2, i2 = null) {
      return new Stream(this.bytes.buffer, e2, t2, i2);
    }
  }
  class StringStream extends Stream {
    constructor(e2) {
      super(stringToBytes(e2));
    }
  }
  class NullStream extends Stream {
    constructor() {
      super(new Uint8Array(0));
    }
  }
  class ChunkedStream extends Stream {
    constructor(e2, t2, i2) {
      super(new Uint8Array(e2), 0, e2, null);
      this.chunkSize = t2;
      this._loadedChunks = /* @__PURE__ */ new Set();
      this.numChunks = Math.ceil(e2 / t2);
      this.manager = i2;
      this.progressiveDataLength = 0;
      this.lastSuccessfulEnsureByteChunk = -1;
    }
    getMissingChunks() {
      const e2 = [];
      for (let t2 = 0, i2 = this.numChunks; t2 < i2; ++t2) this._loadedChunks.has(t2) || e2.push(t2);
      return e2;
    }
    get numChunksLoaded() {
      return this._loadedChunks.size;
    }
    get isDataLoaded() {
      return this.numChunksLoaded === this.numChunks;
    }
    onReceiveData(e2, t2) {
      const i2 = this.chunkSize;
      if (e2 % i2 != 0) throw new Error(`Bad begin offset: ${e2}`);
      const a2 = e2 + t2.byteLength;
      if (a2 % i2 != 0 && a2 !== this.bytes.length) throw new Error(`Bad end offset: ${a2}`);
      this.bytes.set(new Uint8Array(t2), e2);
      const r2 = Math.floor(e2 / i2), s2 = Math.floor((a2 - 1) / i2) + 1;
      for (let e3 = r2; e3 < s2; ++e3) this._loadedChunks.add(e3);
    }
    onReceiveProgressiveData(e2) {
      let t2 = this.progressiveDataLength;
      const i2 = Math.floor(t2 / this.chunkSize);
      this.bytes.set(new Uint8Array(e2), t2);
      t2 += e2.byteLength;
      this.progressiveDataLength = t2;
      const a2 = t2 >= this.end ? this.numChunks : Math.floor(t2 / this.chunkSize);
      for (let e3 = i2; e3 < a2; ++e3) this._loadedChunks.add(e3);
    }
    ensureByte(e2) {
      if (e2 < this.progressiveDataLength) return;
      const t2 = Math.floor(e2 / this.chunkSize);
      if (!(t2 > this.numChunks) && t2 !== this.lastSuccessfulEnsureByteChunk) {
        if (!this._loadedChunks.has(t2)) throw new MissingDataException(e2, e2 + 1);
        this.lastSuccessfulEnsureByteChunk = t2;
      }
    }
    ensureRange(e2, t2) {
      if (e2 >= t2) return;
      if (t2 <= this.progressiveDataLength) return;
      const i2 = Math.floor(e2 / this.chunkSize);
      if (i2 > this.numChunks) return;
      const a2 = Math.min(Math.floor((t2 - 1) / this.chunkSize) + 1, this.numChunks);
      for (let r2 = i2; r2 < a2; ++r2) if (!this._loadedChunks.has(r2)) throw new MissingDataException(e2, t2);
    }
    nextEmptyChunk(e2) {
      const t2 = this.numChunks;
      for (let i2 = 0; i2 < t2; ++i2) {
        const a2 = (e2 + i2) % t2;
        if (!this._loadedChunks.has(a2)) return a2;
      }
      return null;
    }
    hasChunk(e2) {
      return this._loadedChunks.has(e2);
    }
    getByte() {
      const e2 = this.pos;
      if (e2 >= this.end) return -1;
      e2 >= this.progressiveDataLength && this.ensureByte(e2);
      return this.bytes[this.pos++];
    }
    getBytes(e2) {
      const t2 = this.bytes, i2 = this.pos, a2 = this.end;
      if (!e2) {
        a2 > this.progressiveDataLength && this.ensureRange(i2, a2);
        return t2.subarray(i2, a2);
      }
      let r2 = i2 + e2;
      r2 > a2 && (r2 = a2);
      r2 > this.progressiveDataLength && this.ensureRange(i2, r2);
      this.pos = r2;
      return t2.subarray(i2, r2);
    }
    getByteRange(e2, t2) {
      e2 < 0 && (e2 = 0);
      t2 > this.end && (t2 = this.end);
      t2 > this.progressiveDataLength && this.ensureRange(e2, t2);
      return this.bytes.subarray(e2, t2);
    }
    makeSubStream(e2, t2, i2 = null) {
      t2 ? e2 + t2 > this.progressiveDataLength && this.ensureRange(e2, e2 + t2) : e2 >= this.progressiveDataLength && this.ensureByte(e2);
      function ChunkedStreamSubstream() {
      }
      ChunkedStreamSubstream.prototype = Object.create(this);
      ChunkedStreamSubstream.prototype.getMissingChunks = function() {
        const e3 = this.chunkSize, t3 = Math.floor(this.start / e3), i3 = Math.floor((this.end - 1) / e3) + 1, a3 = [];
        for (let e4 = t3; e4 < i3; ++e4) this._loadedChunks.has(e4) || a3.push(e4);
        return a3;
      };
      Object.defineProperty(ChunkedStreamSubstream.prototype, "isDataLoaded", {
        get() {
          return this.numChunksLoaded === this.numChunks || 0 === this.getMissingChunks().length;
        },
        configurable: true
      });
      const a2 = new ChunkedStreamSubstream();
      a2.pos = a2.start = e2;
      a2.end = e2 + t2 || this.end;
      a2.dict = i2;
      return a2;
    }
    getBaseStreams() {
      return [
        this
      ];
    }
  }
  class ChunkedStreamManager {
    constructor(e2, t2) {
      this.length = t2.length;
      this.chunkSize = t2.rangeChunkSize;
      this.stream = new ChunkedStream(this.length, this.chunkSize, this);
      this.pdfNetworkStream = e2;
      this.disableAutoFetch = t2.disableAutoFetch;
      this.msgHandler = t2.msgHandler;
      this.currRequestId = 0;
      this._chunksNeededByRequest = /* @__PURE__ */ new Map();
      this._requestsByChunk = /* @__PURE__ */ new Map();
      this._promisesByRequest = /* @__PURE__ */ new Map();
      this.progressiveDataLength = 0;
      this.aborted = false;
      this._loadedStreamCapability = Promise.withResolvers();
    }
    sendRequest(e2, t2) {
      const i2 = this.pdfNetworkStream.getRangeReader(e2, t2);
      i2.isStreamingSupported || (i2.onProgress = this.onProgress.bind(this));
      let a2 = [], r2 = 0;
      return new Promise((e3, t3) => {
        const readChunk = ({ value: s2, done: n2 }) => {
          try {
            if (n2) {
              const t4 = arrayBuffersToBytes(a2);
              a2 = null;
              e3(t4);
              return;
            }
            r2 += s2.byteLength;
            i2.isStreamingSupported && this.onProgress({
              loaded: r2
            });
            a2.push(s2);
            i2.read().then(readChunk, t3);
          } catch (e4) {
            t3(e4);
          }
        };
        i2.read().then(readChunk, t3);
      }).then((t3) => {
        this.aborted || this.onReceiveData({
          chunk: t3,
          begin: e2
        });
      });
    }
    requestAllChunks(e2 = false) {
      if (!e2) {
        const e3 = this.stream.getMissingChunks();
        this._requestChunks(e3);
      }
      return this._loadedStreamCapability.promise;
    }
    _requestChunks(e2) {
      const t2 = this.currRequestId++, i2 = /* @__PURE__ */ new Set();
      this._chunksNeededByRequest.set(t2, i2);
      for (const t3 of e2) this.stream.hasChunk(t3) || i2.add(t3);
      if (0 === i2.size) return Promise.resolve();
      const a2 = Promise.withResolvers();
      this._promisesByRequest.set(t2, a2);
      const r2 = [];
      for (const e3 of i2) {
        let i3 = this._requestsByChunk.get(e3);
        if (!i3) {
          i3 = [];
          this._requestsByChunk.set(e3, i3);
          r2.push(e3);
        }
        i3.push(t2);
      }
      if (r2.length > 0) {
        const e3 = this.groupChunks(r2);
        for (const t3 of e3) {
          const e4 = t3.beginChunk * this.chunkSize, i3 = Math.min(t3.endChunk * this.chunkSize, this.length);
          this.sendRequest(e4, i3).catch(a2.reject);
        }
      }
      return a2.promise.catch((e3) => {
        if (!this.aborted) throw e3;
      });
    }
    getStream() {
      return this.stream;
    }
    requestRange(e2, t2) {
      t2 = Math.min(t2, this.length);
      const i2 = this.getBeginChunk(e2), a2 = this.getEndChunk(t2), r2 = [];
      for (let e3 = i2; e3 < a2; ++e3) r2.push(e3);
      return this._requestChunks(r2);
    }
    requestRanges(e2 = []) {
      const t2 = [];
      for (const i2 of e2) {
        const e3 = this.getBeginChunk(i2.begin), a2 = this.getEndChunk(i2.end);
        for (let i3 = e3; i3 < a2; ++i3) t2.includes(i3) || t2.push(i3);
      }
      t2.sort(function(e3, t3) {
        return e3 - t3;
      });
      return this._requestChunks(t2);
    }
    groupChunks(e2) {
      const t2 = [];
      let i2 = -1, a2 = -1;
      for (let r2 = 0, s2 = e2.length; r2 < s2; ++r2) {
        const s3 = e2[r2];
        i2 < 0 && (i2 = s3);
        if (a2 >= 0 && a2 + 1 !== s3) {
          t2.push({
            beginChunk: i2,
            endChunk: a2 + 1
          });
          i2 = s3;
        }
        r2 + 1 === e2.length && t2.push({
          beginChunk: i2,
          endChunk: s3 + 1
        });
        a2 = s3;
      }
      return t2;
    }
    onProgress(e2) {
      this.msgHandler.send("DocProgress", {
        loaded: this.stream.numChunksLoaded * this.chunkSize + e2.loaded,
        total: this.length
      });
    }
    onReceiveData(e2) {
      const t2 = e2.chunk, i2 = void 0 === e2.begin, a2 = i2 ? this.progressiveDataLength : e2.begin, r2 = a2 + t2.byteLength, s2 = Math.floor(a2 / this.chunkSize), n2 = r2 < this.length ? Math.floor(r2 / this.chunkSize) : Math.ceil(r2 / this.chunkSize);
      if (i2) {
        this.stream.onReceiveProgressiveData(t2);
        this.progressiveDataLength = r2;
      } else this.stream.onReceiveData(a2, t2);
      this.stream.isDataLoaded && this._loadedStreamCapability.resolve(this.stream);
      const o2 = [];
      for (let e3 = s2; e3 < n2; ++e3) {
        const t3 = this._requestsByChunk.get(e3);
        if (t3) {
          this._requestsByChunk.delete(e3);
          for (const i3 of t3) {
            const t4 = this._chunksNeededByRequest.get(i3);
            t4.has(e3) && t4.delete(e3);
            t4.size > 0 || o2.push(i3);
          }
        }
      }
      if (!this.disableAutoFetch && 0 === this._requestsByChunk.size) {
        let e3;
        if (1 === this.stream.numChunksLoaded) {
          const t3 = this.stream.numChunks - 1;
          this.stream.hasChunk(t3) || (e3 = t3);
        } else e3 = this.stream.nextEmptyChunk(n2);
        Number.isInteger(e3) && this._requestChunks([
          e3
        ]);
      }
      for (const e3 of o2) {
        const t3 = this._promisesByRequest.get(e3);
        this._promisesByRequest.delete(e3);
        t3.resolve();
      }
      this.msgHandler.send("DocProgress", {
        loaded: this.stream.numChunksLoaded * this.chunkSize,
        total: this.length
      });
    }
    onError(e2) {
      this._loadedStreamCapability.reject(e2);
    }
    getBeginChunk(e2) {
      return Math.floor(e2 / this.chunkSize);
    }
    getEndChunk(e2) {
      return Math.floor((e2 - 1) / this.chunkSize) + 1;
    }
    abort(e2) {
      var _a4;
      this.aborted = true;
      (_a4 = this.pdfNetworkStream) == null ? void 0 : _a4.cancelAllRequests(e2);
      for (const t2 of this._promisesByRequest.values()) t2.reject(e2);
    }
  }
  __webpack_require__(4520), __webpack_require__(9479), __webpack_require__(2577), __webpack_require__(8872);
  class ColorSpace {
    constructor(e2, t2) {
      this.name = e2;
      this.numComps = t2;
    }
    getRgb(e2, t2) {
      const i2 = new Uint8ClampedArray(3);
      this.getRgbItem(e2, t2, i2, 0);
      return i2;
    }
    getRgbItem(e2, t2, i2, a2) {
      unreachable("Should not call ColorSpace.getRgbItem");
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      unreachable("Should not call ColorSpace.getRgbBuffer");
    }
    getOutputLength(e2, t2) {
      unreachable("Should not call ColorSpace.getOutputLength");
    }
    isPassthrough(e2) {
      return false;
    }
    isDefaultDecode(e2, t2) {
      return ColorSpace.isDefaultDecode(e2, this.numComps);
    }
    fillRgb(e2, t2, i2, a2, r2, s2, n2, o2, g2) {
      const c2 = t2 * i2;
      let C2 = null;
      const h2 = 1 << n2, l2 = i2 !== r2 || t2 !== a2;
      if (this.isPassthrough(n2)) C2 = o2;
      else if (1 === this.numComps && c2 > h2 && "DeviceGray" !== this.name && "DeviceRGB" !== this.name) {
        const t3 = n2 <= 8 ? new Uint8Array(h2) : new Uint16Array(h2);
        for (let e3 = 0; e3 < h2; e3++) t3[e3] = e3;
        const i3 = new Uint8ClampedArray(3 * h2);
        this.getRgbBuffer(t3, 0, h2, i3, 0, n2, 0);
        if (l2) {
          C2 = new Uint8Array(3 * c2);
          let e3 = 0;
          for (let t4 = 0; t4 < c2; ++t4) {
            const a3 = 3 * o2[t4];
            C2[e3++] = i3[a3];
            C2[e3++] = i3[a3 + 1];
            C2[e3++] = i3[a3 + 2];
          }
        } else {
          let t4 = 0;
          for (let a3 = 0; a3 < c2; ++a3) {
            const r3 = 3 * o2[a3];
            e2[t4++] = i3[r3];
            e2[t4++] = i3[r3 + 1];
            e2[t4++] = i3[r3 + 2];
            t4 += g2;
          }
        }
      } else if (l2) {
        C2 = new Uint8ClampedArray(3 * c2);
        this.getRgbBuffer(o2, 0, c2, C2, 0, n2, 0);
      } else this.getRgbBuffer(o2, 0, a2 * s2, e2, 0, n2, g2);
      if (C2) if (l2) !function resizeRgbImage(e3, t3, i3, a3, r3, s3, n3) {
        n3 = 1 !== n3 ? 0 : n3;
        const o3 = i3 / r3, g3 = a3 / s3;
        let c3, C3 = 0;
        const h3 = new Uint16Array(r3), l3 = 3 * i3;
        for (let e4 = 0; e4 < r3; e4++) h3[e4] = 3 * Math.floor(e4 * o3);
        for (let i4 = 0; i4 < s3; i4++) {
          const a4 = Math.floor(i4 * g3) * l3;
          for (let i5 = 0; i5 < r3; i5++) {
            c3 = a4 + h3[i5];
            t3[C3++] = e3[c3++];
            t3[C3++] = e3[c3++];
            t3[C3++] = e3[c3++];
            C3 += n3;
          }
        }
      }(C2, e2, t2, i2, a2, r2, g2);
      else {
        let t3 = 0, i3 = 0;
        for (let r3 = 0, n3 = a2 * s2; r3 < n3; r3++) {
          e2[t3++] = C2[i3++];
          e2[t3++] = C2[i3++];
          e2[t3++] = C2[i3++];
          t3 += g2;
        }
      }
    }
    get usesZeroToOneRange() {
      return shadow(this, "usesZeroToOneRange", true);
    }
    static _cache(e2, t2, i2, a2) {
      if (!i2) throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');
      if (!a2) throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');
      let r2, s2;
      if (e2 instanceof Ref) {
        s2 = e2;
        e2 = t2.fetch(e2);
      }
      e2 instanceof Name && (r2 = e2.name);
      (r2 || s2) && i2.set(r2, s2, a2);
    }
    static getCached(e2, t2, i2) {
      if (!i2) throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');
      if (e2 instanceof Ref) {
        const a2 = i2.getByRef(e2);
        if (a2) return a2;
        try {
          e2 = t2.fetch(e2);
        } catch (e3) {
          if (e3 instanceof MissingDataException) throw e3;
        }
      }
      if (e2 instanceof Name) {
        const t3 = i2.getByName(e2.name);
        if (t3) return t3;
      }
      return null;
    }
    static async parseAsync({ cs: e2, xref: t2, resources: i2 = null, pdfFunctionFactory: a2, localColorSpaceCache: r2 }) {
      const s2 = this._parse(e2, t2, i2, a2);
      this._cache(e2, t2, r2, s2);
      return s2;
    }
    static parse({ cs: e2, xref: t2, resources: i2 = null, pdfFunctionFactory: a2, localColorSpaceCache: r2 }) {
      const s2 = this.getCached(e2, t2, r2);
      if (s2) return s2;
      const n2 = this._parse(e2, t2, i2, a2);
      this._cache(e2, t2, r2, n2);
      return n2;
    }
    static _parse(e2, t2, i2 = null, a2) {
      if ((e2 = t2.fetchIfRef(e2)) instanceof Name) switch (e2.name) {
        case "G":
        case "DeviceGray":
          return this.singletons.gray;
        case "RGB":
        case "DeviceRGB":
          return this.singletons.rgb;
        case "DeviceRGBA":
          return this.singletons.rgba;
        case "CMYK":
        case "DeviceCMYK":
          return this.singletons.cmyk;
        case "Pattern":
          return new PatternCS(null);
        default:
          if (i2 instanceof Dict) {
            const r2 = i2.get("ColorSpace");
            if (r2 instanceof Dict) {
              const s2 = r2.get(e2.name);
              if (s2) {
                if (s2 instanceof Name) return this._parse(s2, t2, i2, a2);
                e2 = s2;
                break;
              }
            }
          }
          warn(`Unrecognized ColorSpace: ${e2.name}`);
          return this.singletons.gray;
      }
      if (Array.isArray(e2)) {
        const r2 = t2.fetchIfRef(e2[0]).name;
        let s2, n2, o2, g2, c2, C2;
        switch (r2) {
          case "G":
          case "DeviceGray":
            return this.singletons.gray;
          case "RGB":
          case "DeviceRGB":
            return this.singletons.rgb;
          case "CMYK":
          case "DeviceCMYK":
            return this.singletons.cmyk;
          case "CalGray":
            s2 = t2.fetchIfRef(e2[1]);
            g2 = s2.getArray("WhitePoint");
            c2 = s2.getArray("BlackPoint");
            C2 = s2.get("Gamma");
            return new CalGrayCS(g2, c2, C2);
          case "CalRGB":
            s2 = t2.fetchIfRef(e2[1]);
            g2 = s2.getArray("WhitePoint");
            c2 = s2.getArray("BlackPoint");
            C2 = s2.getArray("Gamma");
            const h2 = s2.getArray("Matrix");
            return new CalRGBCS(g2, c2, C2, h2);
          case "ICCBased":
            const l2 = t2.fetchIfRef(e2[1]).dict;
            n2 = l2.get("N");
            const Q2 = l2.get("Alternate");
            if (Q2) {
              const e3 = this._parse(Q2, t2, i2, a2);
              if (e3.numComps === n2) return e3;
              warn("ICCBased color space: Ignoring incorrect /Alternate entry.");
            }
            if (1 === n2) return this.singletons.gray;
            if (3 === n2) return this.singletons.rgb;
            if (4 === n2) return this.singletons.cmyk;
            break;
          case "Pattern":
            o2 = e2[1] || null;
            o2 && (o2 = this._parse(o2, t2, i2, a2));
            return new PatternCS(o2);
          case "I":
          case "Indexed":
            o2 = this._parse(e2[1], t2, i2, a2);
            const E2 = Math.max(0, Math.min(t2.fetchIfRef(e2[2]), 255)), u2 = t2.fetchIfRef(e2[3]);
            return new IndexedCS(o2, E2, u2);
          case "Separation":
          case "DeviceN":
            const d2 = t2.fetchIfRef(e2[1]);
            n2 = Array.isArray(d2) ? d2.length : 1;
            o2 = this._parse(e2[2], t2, i2, a2);
            const f2 = a2.create(e2[3]);
            return new AlternateCS(n2, o2, f2);
          case "Lab":
            s2 = t2.fetchIfRef(e2[1]);
            g2 = s2.getArray("WhitePoint");
            c2 = s2.getArray("BlackPoint");
            const p2 = s2.getArray("Range");
            return new LabCS(g2, c2, p2);
          default:
            warn(`Unimplemented ColorSpace object: ${r2}`);
            return this.singletons.gray;
        }
      }
      warn(`Unrecognized ColorSpace object: ${e2}`);
      return this.singletons.gray;
    }
    static isDefaultDecode(e2, t2) {
      if (!Array.isArray(e2)) return true;
      if (2 * t2 !== e2.length) {
        warn("The decode map is not the correct length");
        return true;
      }
      for (let t3 = 0, i2 = e2.length; t3 < i2; t3 += 2) if (0 !== e2[t3] || 1 !== e2[t3 + 1]) return false;
      return true;
    }
    static get singletons() {
      return shadow(this, "singletons", {
        get gray() {
          return shadow(this, "gray", new DeviceGrayCS());
        },
        get rgb() {
          return shadow(this, "rgb", new DeviceRgbCS());
        },
        get rgba() {
          return shadow(this, "rgba", new DeviceRgbaCS());
        },
        get cmyk() {
          return shadow(this, "cmyk", new DeviceCmykCS());
        }
      });
    }
  }
  class AlternateCS extends ColorSpace {
    constructor(e2, t2, i2) {
      super("Alternate", e2);
      this.base = t2;
      this.tintFn = i2;
      this.tmpBuf = new Float32Array(t2.numComps);
    }
    getRgbItem(e2, t2, i2, a2) {
      const r2 = this.tmpBuf;
      this.tintFn(e2, t2, r2, 0);
      this.base.getRgbItem(r2, 0, i2, a2);
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = this.tintFn, g2 = this.base, c2 = 1 / ((1 << s2) - 1), C2 = g2.numComps, h2 = g2.usesZeroToOneRange, l2 = (g2.isPassthrough(8) || !h2) && 0 === n2;
      let Q2 = l2 ? r2 : 0;
      const E2 = l2 ? a2 : new Uint8ClampedArray(C2 * i2), u2 = this.numComps, d2 = new Float32Array(u2), f2 = new Float32Array(C2);
      let p2, m2;
      for (p2 = 0; p2 < i2; p2++) {
        for (m2 = 0; m2 < u2; m2++) d2[m2] = e2[t2++] * c2;
        o2(d2, 0, f2, 0);
        if (h2) for (m2 = 0; m2 < C2; m2++) E2[Q2++] = 255 * f2[m2];
        else {
          g2.getRgbItem(f2, 0, E2, Q2);
          Q2 += C2;
        }
      }
      l2 || g2.getRgbBuffer(E2, 0, i2, a2, r2, 8, n2);
    }
    getOutputLength(e2, t2) {
      return this.base.getOutputLength(e2 * this.base.numComps / this.numComps, t2);
    }
  }
  class PatternCS extends ColorSpace {
    constructor(e2) {
      super("Pattern", null);
      this.base = e2;
    }
    isDefaultDecode(e2, t2) {
      unreachable("Should not call PatternCS.isDefaultDecode");
    }
  }
  class IndexedCS extends ColorSpace {
    constructor(e2, t2, i2) {
      super("Indexed", 1);
      this.base = e2;
      const a2 = e2.numComps * (t2 + 1);
      this.lookup = new Uint8Array(a2);
      if (i2 instanceof BaseStream) {
        const e3 = i2.getBytes(a2);
        this.lookup.set(e3);
      } else {
        if ("string" != typeof i2) throw new FormatError(`IndexedCS - unrecognized lookup table: ${i2}`);
        for (let e3 = 0; e3 < a2; ++e3) this.lookup[e3] = 255 & i2.charCodeAt(e3);
      }
    }
    getRgbItem(e2, t2, i2, a2) {
      const r2 = this.base.numComps, s2 = e2[t2] * r2;
      this.base.getRgbBuffer(this.lookup, s2, 1, i2, a2, 8, 0);
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = this.base, g2 = o2.numComps, c2 = o2.getOutputLength(g2, n2), C2 = this.lookup;
      for (let s3 = 0; s3 < i2; ++s3) {
        const i3 = e2[t2++] * g2;
        o2.getRgbBuffer(C2, i3, 1, a2, r2, 8, n2);
        r2 += c2;
      }
    }
    getOutputLength(e2, t2) {
      return this.base.getOutputLength(e2 * this.base.numComps, t2);
    }
    isDefaultDecode(e2, t2) {
      if (!Array.isArray(e2)) return true;
      if (2 !== e2.length) {
        warn("Decode map length is not correct");
        return true;
      }
      if (!Number.isInteger(t2) || t2 < 1) {
        warn("Bits per component is not correct");
        return true;
      }
      return 0 === e2[0] && e2[1] === (1 << t2) - 1;
    }
  }
  class DeviceGrayCS extends ColorSpace {
    constructor() {
      super("DeviceGray", 1);
    }
    getRgbItem(e2, t2, i2, a2) {
      const r2 = 255 * e2[t2];
      i2[a2] = i2[a2 + 1] = i2[a2 + 2] = r2;
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = 255 / ((1 << s2) - 1);
      let g2 = t2, c2 = r2;
      for (let t3 = 0; t3 < i2; ++t3) {
        const t4 = o2 * e2[g2++];
        a2[c2++] = t4;
        a2[c2++] = t4;
        a2[c2++] = t4;
        c2 += n2;
      }
    }
    getOutputLength(e2, t2) {
      return e2 * (3 + t2);
    }
  }
  class DeviceRgbCS extends ColorSpace {
    constructor() {
      super("DeviceRGB", 3);
    }
    getRgbItem(e2, t2, i2, a2) {
      i2[a2] = 255 * e2[t2];
      i2[a2 + 1] = 255 * e2[t2 + 1];
      i2[a2 + 2] = 255 * e2[t2 + 2];
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      if (8 === s2 && 0 === n2) {
        a2.set(e2.subarray(t2, t2 + 3 * i2), r2);
        return;
      }
      const o2 = 255 / ((1 << s2) - 1);
      let g2 = t2, c2 = r2;
      for (let t3 = 0; t3 < i2; ++t3) {
        a2[c2++] = o2 * e2[g2++];
        a2[c2++] = o2 * e2[g2++];
        a2[c2++] = o2 * e2[g2++];
        c2 += n2;
      }
    }
    getOutputLength(e2, t2) {
      return e2 * (3 + t2) / 3 | 0;
    }
    isPassthrough(e2) {
      return 8 === e2;
    }
  }
  class DeviceRgbaCS extends ColorSpace {
    constructor() {
      super("DeviceRGBA", 4);
    }
    getOutputLength(e2, t2) {
      return 4 * e2;
    }
    isPassthrough(e2) {
      return 8 === e2;
    }
    fillRgb(e2, t2, i2, a2, r2, s2, n2, o2, g2) {
      i2 !== r2 || t2 !== a2 ? function resizeRgbaImage(e3, t3, i3, a3, r3, s3, n3) {
        const o3 = i3 / r3, g3 = a3 / s3;
        let c2 = 0;
        const C2 = new Uint16Array(r3);
        if (1 === n3) {
          for (let e4 = 0; e4 < r3; e4++) C2[e4] = Math.floor(e4 * o3);
          const a4 = new Uint32Array(e3.buffer), n4 = new Uint32Array(t3.buffer), h2 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
          for (let e4 = 0; e4 < s3; e4++) {
            const t4 = a4.subarray(Math.floor(e4 * g3) * i3);
            for (let e5 = 0; e5 < r3; e5++) n4[c2++] |= t4[C2[e5]] & h2;
          }
        } else {
          const a4 = 4, n4 = i3 * a4;
          for (let e4 = 0; e4 < r3; e4++) C2[e4] = Math.floor(e4 * o3) * a4;
          for (let i4 = 0; i4 < s3; i4++) {
            const a5 = e3.subarray(Math.floor(i4 * g3) * n4);
            for (let e4 = 0; e4 < r3; e4++) {
              const i5 = C2[e4];
              t3[c2++] = a5[i5];
              t3[c2++] = a5[i5 + 1];
              t3[c2++] = a5[i5 + 2];
            }
          }
        }
      }(o2, e2, t2, i2, a2, r2, g2) : function copyRgbaImage(e3, t3, i3) {
        if (1 === i3) {
          const i4 = new Uint32Array(e3.buffer), a3 = new Uint32Array(t3.buffer), r3 = FeatureTest.isLittleEndian ? 16777215 : 4294967040;
          for (let e4 = 0, t4 = i4.length; e4 < t4; e4++) a3[e4] |= i4[e4] & r3;
        } else {
          let i4 = 0;
          for (let a3 = 0, r3 = e3.length; a3 < r3; a3 += 4) {
            t3[i4++] = e3[a3];
            t3[i4++] = e3[a3 + 1];
            t3[i4++] = e3[a3 + 2];
          }
        }
      }(o2, e2, g2);
    }
  }
  class DeviceCmykCS extends ColorSpace {
    constructor() {
      super("DeviceCMYK", 4);
      __privateAdd(this, _DeviceCmykCS_instances);
    }
    getRgbItem(e2, t2, i2, a2) {
      __privateMethod(this, _DeviceCmykCS_instances, t_fn).call(this, e2, t2, 1, i2, a2);
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = 1 / ((1 << s2) - 1);
      for (let s3 = 0; s3 < i2; s3++) {
        __privateMethod(this, _DeviceCmykCS_instances, t_fn).call(this, e2, t2, o2, a2, r2);
        t2 += 4;
        r2 += 3 + n2;
      }
    }
    getOutputLength(e2, t2) {
      return e2 / 4 * (3 + t2) | 0;
    }
  }
  _DeviceCmykCS_instances = new WeakSet();
  t_fn = function(e2, t2, i2, a2, r2) {
    const s2 = e2[t2] * i2, n2 = e2[t2 + 1] * i2, o2 = e2[t2 + 2] * i2, g2 = e2[t2 + 3] * i2;
    a2[r2] = 255 + s2 * (-4.387332384609988 * s2 + 54.48615194189176 * n2 + 18.82290502165302 * o2 + 212.25662451639585 * g2 - 285.2331026137004) + n2 * (1.7149763477362134 * n2 - 5.6096736904047315 * o2 + -17.873870861415444 * g2 - 5.497006427196366) + o2 * (-2.5217340131683033 * o2 - 21.248923337353073 * g2 + 17.5119270841813) + g2 * (-21.86122147463605 * g2 - 189.48180835922747);
    a2[r2 + 1] = 255 + s2 * (8.841041422036149 * s2 + 60.118027045597366 * n2 + 6.871425592049007 * o2 + 31.159100130055922 * g2 - 79.2970844816548) + n2 * (-15.310361306967817 * n2 + 17.575251261109482 * o2 + 131.35250912493976 * g2 - 190.9453302588951) + o2 * (4.444339102852739 * o2 + 9.8632861493405 * g2 - 24.86741582555878) + g2 * (-20.737325471181034 * g2 - 187.80453709719578);
    a2[r2 + 2] = 255 + s2 * (0.8842522430003296 * s2 + 8.078677503112928 * n2 + 30.89978309703729 * o2 - 0.23883238689178934 * g2 - 14.183576799673286) + n2 * (10.49593273432072 * n2 + 63.02378494754052 * o2 + 50.606957656360734 * g2 - 112.23884253719248) + o2 * (0.03296041114873217 * o2 + 115.60384449646641 * g2 - 193.58209356861505) + g2 * (-22.33816807309886 * g2 - 180.12613974708367);
  };
  class CalGrayCS extends ColorSpace {
    constructor(e2, t2, i2) {
      super("CalGray", 1);
      __privateAdd(this, _CalGrayCS_instances);
      if (!e2) throw new FormatError("WhitePoint missing - required for color space CalGray");
      [this.XW, this.YW, this.ZW] = e2;
      [this.XB, this.YB, this.ZB] = t2 || [
        0,
        0,
        0
      ];
      this.G = i2 || 1;
      if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
        info(`Invalid BlackPoint for ${this.name}, falling back to default.`);
        this.XB = this.YB = this.ZB = 0;
      }
      0 === this.XB && 0 === this.YB && 0 === this.ZB || warn(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`);
      if (this.G < 1) {
        info(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`);
        this.G = 1;
      }
    }
    getRgbItem(e2, t2, i2, a2) {
      __privateMethod(this, _CalGrayCS_instances, t_fn2).call(this, e2, t2, i2, a2, 1);
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = 1 / ((1 << s2) - 1);
      for (let s3 = 0; s3 < i2; ++s3) {
        __privateMethod(this, _CalGrayCS_instances, t_fn2).call(this, e2, t2, a2, r2, o2);
        t2 += 1;
        r2 += 3 + n2;
      }
    }
    getOutputLength(e2, t2) {
      return e2 * (3 + t2);
    }
  }
  _CalGrayCS_instances = new WeakSet();
  t_fn2 = function(e2, t2, i2, a2, r2) {
    const s2 = (e2[t2] * r2) ** this.G, n2 = this.YW * s2, o2 = Math.max(295.8 * n2 ** 0.3333333333333333 - 40.8, 0);
    i2[a2] = o2;
    i2[a2 + 1] = o2;
    i2[a2 + 2] = o2;
  };
  const _CalRGBCS = class _CalRGBCS extends ColorSpace {
    constructor(e2, t2, i2, a2) {
      super("CalRGB", 3);
      __privateAdd(this, _CalRGBCS_instances);
      if (!e2) throw new FormatError("WhitePoint missing - required for color space CalRGB");
      const [r2, s2, n2] = this.whitePoint = e2, [o2, g2, c2] = this.blackPoint = t2 || new Float32Array(3);
      [this.GR, this.GG, this.GB] = i2 || new Float32Array([
        1,
        1,
        1
      ]);
      [this.MXA, this.MYA, this.MZA, this.MXB, this.MYB, this.MZB, this.MXC, this.MYC, this.MZC] = a2 || new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
      if (r2 < 0 || n2 < 0 || 1 !== s2) throw new FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);
      if (o2 < 0 || g2 < 0 || c2 < 0) {
        info(`Invalid BlackPoint for ${this.name} [${o2}, ${g2}, ${c2}], falling back to default.`);
        this.blackPoint = new Float32Array(3);
      }
      if (this.GR < 0 || this.GG < 0 || this.GB < 0) {
        info(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`);
        this.GR = this.GG = this.GB = 1;
      }
    }
    getRgbItem(e2, t2, i2, a2) {
      __privateMethod(this, _CalRGBCS_instances, t_fn3).call(this, e2, t2, i2, a2, 1);
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = 1 / ((1 << s2) - 1);
      for (let s3 = 0; s3 < i2; ++s3) {
        __privateMethod(this, _CalRGBCS_instances, t_fn3).call(this, e2, t2, a2, r2, o2);
        t2 += 3;
        r2 += 3 + n2;
      }
    }
    getOutputLength(e2, t2) {
      return e2 * (3 + t2) / 3 | 0;
    }
  };
  _i2 = new WeakMap();
  _a2 = new WeakMap();
  _r2 = new WeakMap();
  _s2 = new WeakMap();
  _n2 = new WeakMap();
  _o = new WeakMap();
  _g = new WeakMap();
  _I = new WeakMap();
  _CalRGBCS_instances = new WeakSet();
  c_fn = function(e2, t2, i2) {
    i2[0] = e2[0] * t2[0] + e2[1] * t2[1] + e2[2] * t2[2];
    i2[1] = e2[3] * t2[0] + e2[4] * t2[1] + e2[5] * t2[2];
    i2[2] = e2[6] * t2[0] + e2[7] * t2[1] + e2[8] * t2[2];
  };
  C_fn = function(e2, t2, i2) {
    i2[0] = 1 * t2[0] / e2[0];
    i2[1] = 1 * t2[1] / e2[1];
    i2[2] = 1 * t2[2] / e2[2];
  };
  h_fn = function(e2, t2, i2) {
    i2[0] = 0.95047 * t2[0] / e2[0];
    i2[1] = 1 * t2[1] / e2[1];
    i2[2] = 1.08883 * t2[2] / e2[2];
  };
  l_fn = function(e2) {
    return e2 <= 31308e-7 ? __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, 0, 1, 12.92 * e2) : e2 >= 0.99554525 ? 1 : __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, 0, 1, 1.055 * e2 ** (1 / 2.4) - 0.055);
  };
  B_fn = function(e2, t2, i2) {
    return Math.max(e2, Math.min(t2, i2));
  };
  Q_fn = function(e2) {
    return e2 < 0 ? -__privateMethod(this, _CalRGBCS_instances, Q_fn).call(this, -e2) : e2 > 8 ? ((e2 + 16) / 116) ** 3 : e2 * __privateGet(_CalRGBCS, _I);
  };
  E_fn = function(e2, t2, i2) {
    if (0 === e2[0] && 0 === e2[1] && 0 === e2[2]) {
      i2[0] = t2[0];
      i2[1] = t2[1];
      i2[2] = t2[2];
      return;
    }
    const a2 = __privateMethod(this, _CalRGBCS_instances, Q_fn).call(this, 0), r2 = (1 - a2) / (1 - __privateMethod(this, _CalRGBCS_instances, Q_fn).call(this, e2[0])), s2 = 1 - r2, n2 = (1 - a2) / (1 - __privateMethod(this, _CalRGBCS_instances, Q_fn).call(this, e2[1])), o2 = 1 - n2, g2 = (1 - a2) / (1 - __privateMethod(this, _CalRGBCS_instances, Q_fn).call(this, e2[2])), c2 = 1 - g2;
    i2[0] = t2[0] * r2 + s2;
    i2[1] = t2[1] * n2 + o2;
    i2[2] = t2[2] * g2 + c2;
  };
  u_fn = function(e2, t2, i2) {
    if (1 === e2[0] && 1 === e2[2]) {
      i2[0] = t2[0];
      i2[1] = t2[1];
      i2[2] = t2[2];
      return;
    }
    const a2 = i2;
    __privateMethod(this, _CalRGBCS_instances, c_fn).call(this, __privateGet(_CalRGBCS, _i2), t2, a2);
    const r2 = __privateGet(_CalRGBCS, _n2);
    __privateMethod(this, _CalRGBCS_instances, C_fn).call(this, e2, a2, r2);
    __privateMethod(this, _CalRGBCS_instances, c_fn).call(this, __privateGet(_CalRGBCS, _a2), r2, i2);
  };
  d_fn = function(e2, t2, i2) {
    const a2 = i2;
    __privateMethod(this, _CalRGBCS_instances, c_fn).call(this, __privateGet(_CalRGBCS, _i2), t2, a2);
    const r2 = __privateGet(_CalRGBCS, _n2);
    __privateMethod(this, _CalRGBCS_instances, h_fn).call(this, e2, a2, r2);
    __privateMethod(this, _CalRGBCS_instances, c_fn).call(this, __privateGet(_CalRGBCS, _a2), r2, i2);
  };
  t_fn3 = function(e2, t2, i2, a2, r2) {
    const s2 = __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, 0, 1, e2[t2] * r2), n2 = __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, 0, 1, e2[t2 + 1] * r2), o2 = __privateMethod(this, _CalRGBCS_instances, B_fn).call(this, 0, 1, e2[t2 + 2] * r2), g2 = 1 === s2 ? 1 : s2 ** this.GR, c2 = 1 === n2 ? 1 : n2 ** this.GG, C2 = 1 === o2 ? 1 : o2 ** this.GB, h2 = this.MXA * g2 + this.MXB * c2 + this.MXC * C2, l2 = this.MYA * g2 + this.MYB * c2 + this.MYC * C2, Q2 = this.MZA * g2 + this.MZB * c2 + this.MZC * C2, E2 = __privateGet(_CalRGBCS, _o);
    E2[0] = h2;
    E2[1] = l2;
    E2[2] = Q2;
    const u2 = __privateGet(_CalRGBCS, _g);
    __privateMethod(this, _CalRGBCS_instances, u_fn).call(this, this.whitePoint, E2, u2);
    const d2 = __privateGet(_CalRGBCS, _o);
    __privateMethod(this, _CalRGBCS_instances, E_fn).call(this, this.blackPoint, u2, d2);
    const f2 = __privateGet(_CalRGBCS, _g);
    __privateMethod(this, _CalRGBCS_instances, d_fn).call(this, __privateGet(_CalRGBCS, _s2), d2, f2);
    const p2 = __privateGet(_CalRGBCS, _o);
    __privateMethod(this, _CalRGBCS_instances, c_fn).call(this, __privateGet(_CalRGBCS, _r2), f2, p2);
    i2[a2] = 255 * __privateMethod(this, _CalRGBCS_instances, l_fn).call(this, p2[0]);
    i2[a2 + 1] = 255 * __privateMethod(this, _CalRGBCS_instances, l_fn).call(this, p2[1]);
    i2[a2 + 2] = 255 * __privateMethod(this, _CalRGBCS_instances, l_fn).call(this, p2[2]);
  };
  __privateAdd(_CalRGBCS, _i2, new Float32Array([
    0.8951,
    0.2664,
    -0.1614,
    -0.7502,
    1.7135,
    0.0367,
    0.0389,
    -0.0685,
    1.0296
  ]));
  __privateAdd(_CalRGBCS, _a2, new Float32Array([
    0.9869929,
    -0.1470543,
    0.1599627,
    0.4323053,
    0.5183603,
    0.0492912,
    -85287e-7,
    0.0400428,
    0.9684867
  ]));
  __privateAdd(_CalRGBCS, _r2, new Float32Array([
    3.2404542,
    -1.5371385,
    -0.4985314,
    -0.969266,
    1.8760108,
    0.041556,
    0.0556434,
    -0.2040259,
    1.0572252
  ]));
  __privateAdd(_CalRGBCS, _s2, new Float32Array([
    1,
    1,
    1
  ]));
  __privateAdd(_CalRGBCS, _n2, new Float32Array(3));
  __privateAdd(_CalRGBCS, _o, new Float32Array(3));
  __privateAdd(_CalRGBCS, _g, new Float32Array(3));
  __privateAdd(_CalRGBCS, _I, (24 / 116) ** 3 / 8);
  let CalRGBCS = _CalRGBCS;
  class LabCS extends ColorSpace {
    constructor(e2, t2, i2) {
      super("Lab", 3);
      __privateAdd(this, _LabCS_instances);
      if (!e2) throw new FormatError("WhitePoint missing - required for color space Lab");
      [this.XW, this.YW, this.ZW] = e2;
      [this.amin, this.amax, this.bmin, this.bmax] = i2 || [
        -100,
        100,
        -100,
        100
      ];
      [this.XB, this.YB, this.ZB] = t2 || [
        0,
        0,
        0
      ];
      if (this.XW < 0 || this.ZW < 0 || 1 !== this.YW) throw new FormatError("Invalid WhitePoint components, no fallback available");
      if (this.XB < 0 || this.YB < 0 || this.ZB < 0) {
        info("Invalid BlackPoint, falling back to default");
        this.XB = this.YB = this.ZB = 0;
      }
      if (this.amin > this.amax || this.bmin > this.bmax) {
        info("Invalid Range, falling back to defaults");
        this.amin = -100;
        this.amax = 100;
        this.bmin = -100;
        this.bmax = 100;
      }
    }
    getRgbItem(e2, t2, i2, a2) {
      __privateMethod(this, _LabCS_instances, t_fn4).call(this, e2, t2, false, i2, a2);
    }
    getRgbBuffer(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = (1 << s2) - 1;
      for (let s3 = 0; s3 < i2; s3++) {
        __privateMethod(this, _LabCS_instances, t_fn4).call(this, e2, t2, o2, a2, r2);
        t2 += 3;
        r2 += 3 + n2;
      }
    }
    getOutputLength(e2, t2) {
      return e2 * (3 + t2) / 3 | 0;
    }
    isDefaultDecode(e2, t2) {
      return true;
    }
    get usesZeroToOneRange() {
      return shadow(this, "usesZeroToOneRange", false);
    }
  }
  _LabCS_instances = new WeakSet();
  f_fn = function(e2) {
    return e2 >= 6 / 29 ? e2 ** 3 : 108 / 841 * (e2 - 4 / 29);
  };
  p_fn = function(e2, t2, i2, a2) {
    return i2 + e2 * (a2 - i2) / t2;
  };
  t_fn4 = function(e2, t2, i2, a2, r2) {
    let s2 = e2[t2], n2 = e2[t2 + 1], o2 = e2[t2 + 2];
    if (false !== i2) {
      s2 = __privateMethod(this, _LabCS_instances, p_fn).call(this, s2, i2, 0, 100);
      n2 = __privateMethod(this, _LabCS_instances, p_fn).call(this, n2, i2, this.amin, this.amax);
      o2 = __privateMethod(this, _LabCS_instances, p_fn).call(this, o2, i2, this.bmin, this.bmax);
    }
    n2 > this.amax ? n2 = this.amax : n2 < this.amin && (n2 = this.amin);
    o2 > this.bmax ? o2 = this.bmax : o2 < this.bmin && (o2 = this.bmin);
    const g2 = (s2 + 16) / 116, c2 = g2 + n2 / 500, C2 = g2 - o2 / 200, h2 = this.XW * __privateMethod(this, _LabCS_instances, f_fn).call(this, c2), l2 = this.YW * __privateMethod(this, _LabCS_instances, f_fn).call(this, g2), Q2 = this.ZW * __privateMethod(this, _LabCS_instances, f_fn).call(this, C2);
    let E2, u2, d2;
    if (this.ZW < 1) {
      E2 = 3.1339 * h2 + -1.617 * l2 + -0.4906 * Q2;
      u2 = -0.9785 * h2 + 1.916 * l2 + 0.0333 * Q2;
      d2 = 0.072 * h2 + -0.229 * l2 + 1.4057 * Q2;
    } else {
      E2 = 3.2406 * h2 + -1.5372 * l2 + -0.4986 * Q2;
      u2 = -0.9689 * h2 + 1.8758 * l2 + 0.0415 * Q2;
      d2 = 0.0557 * h2 + -0.204 * l2 + 1.057 * Q2;
    }
    a2[r2] = 255 * Math.sqrt(E2);
    a2[r2 + 1] = 255 * Math.sqrt(u2);
    a2[r2 + 2] = 255 * Math.sqrt(d2);
  };
  function hexToInt(e2, t2) {
    let i2 = 0;
    for (let a2 = 0; a2 <= t2; a2++) i2 = i2 << 8 | e2[a2];
    return i2 >>> 0;
  }
  function hexToStr(e2, t2) {
    return 1 === t2 ? String.fromCharCode(e2[0], e2[1]) : 3 === t2 ? String.fromCharCode(e2[0], e2[1], e2[2], e2[3]) : String.fromCharCode(...e2.subarray(0, t2 + 1));
  }
  function addHex(e2, t2, i2) {
    let a2 = 0;
    for (let r2 = i2; r2 >= 0; r2--) {
      a2 += e2[r2] + t2[r2];
      e2[r2] = 255 & a2;
      a2 >>= 8;
    }
  }
  function incHex(e2, t2) {
    let i2 = 1;
    for (let a2 = t2; a2 >= 0 && i2 > 0; a2--) {
      i2 += e2[a2];
      e2[a2] = 255 & i2;
      i2 >>= 8;
    }
  }
  const xt = 16;
  class BinaryCMapStream {
    constructor(e2) {
      this.buffer = e2;
      this.pos = 0;
      this.end = e2.length;
      this.tmpBuf = new Uint8Array(19);
    }
    readByte() {
      return this.pos >= this.end ? -1 : this.buffer[this.pos++];
    }
    readNumber() {
      let e2, t2 = 0;
      do {
        const i2 = this.readByte();
        if (i2 < 0) throw new FormatError("unexpected EOF in bcmap");
        e2 = !(128 & i2);
        t2 = t2 << 7 | 127 & i2;
      } while (!e2);
      return t2;
    }
    readSigned() {
      const e2 = this.readNumber();
      return 1 & e2 ? ~(e2 >>> 1) : e2 >>> 1;
    }
    readHex(e2, t2) {
      e2.set(this.buffer.subarray(this.pos, this.pos + t2 + 1));
      this.pos += t2 + 1;
    }
    readHexNumber(e2, t2) {
      let i2;
      const a2 = this.tmpBuf;
      let r2 = 0;
      do {
        const e3 = this.readByte();
        if (e3 < 0) throw new FormatError("unexpected EOF in bcmap");
        i2 = !(128 & e3);
        a2[r2++] = 127 & e3;
      } while (!i2);
      let s2 = t2, n2 = 0, o2 = 0;
      for (; s2 >= 0; ) {
        for (; o2 < 8 && a2.length > 0; ) {
          n2 |= a2[--r2] << o2;
          o2 += 7;
        }
        e2[s2] = 255 & n2;
        s2--;
        n2 >>= 8;
        o2 -= 8;
      }
    }
    readHexSigned(e2, t2) {
      this.readHexNumber(e2, t2);
      const i2 = 1 & e2[t2] ? 255 : 0;
      let a2 = 0;
      for (let r2 = 0; r2 <= t2; r2++) {
        a2 = (1 & a2) << 8 | e2[r2];
        e2[r2] = a2 >> 1 ^ i2;
      }
    }
    readString() {
      const e2 = this.readNumber(), t2 = new Array(e2);
      for (let i2 = 0; i2 < e2; i2++) t2[i2] = this.readNumber();
      return String.fromCharCode(...t2);
    }
  }
  class BinaryCMapReader {
    async process(e2, t2, i2) {
      const a2 = new BinaryCMapStream(e2), r2 = a2.readByte();
      t2.vertical = !!(1 & r2);
      let s2 = null;
      const n2 = new Uint8Array(xt), o2 = new Uint8Array(xt), g2 = new Uint8Array(xt), c2 = new Uint8Array(xt), C2 = new Uint8Array(xt);
      let h2, l2;
      for (; (l2 = a2.readByte()) >= 0; ) {
        const e3 = l2 >> 5;
        if (7 === e3) {
          switch (31 & l2) {
            case 0:
              a2.readString();
              break;
            case 1:
              s2 = a2.readString();
          }
          continue;
        }
        const i3 = !!(16 & l2), r3 = 15 & l2;
        if (r3 + 1 > xt) throw new Error("BinaryCMapReader.process: Invalid dataSize.");
        const Q2 = 1, E2 = a2.readNumber();
        switch (e3) {
          case 0:
            a2.readHex(n2, r3);
            a2.readHexNumber(o2, r3);
            addHex(o2, n2, r3);
            t2.addCodespaceRange(r3 + 1, hexToInt(n2, r3), hexToInt(o2, r3));
            for (let e4 = 1; e4 < E2; e4++) {
              incHex(o2, r3);
              a2.readHexNumber(n2, r3);
              addHex(n2, o2, r3);
              a2.readHexNumber(o2, r3);
              addHex(o2, n2, r3);
              t2.addCodespaceRange(r3 + 1, hexToInt(n2, r3), hexToInt(o2, r3));
            }
            break;
          case 1:
            a2.readHex(n2, r3);
            a2.readHexNumber(o2, r3);
            addHex(o2, n2, r3);
            a2.readNumber();
            for (let e4 = 1; e4 < E2; e4++) {
              incHex(o2, r3);
              a2.readHexNumber(n2, r3);
              addHex(n2, o2, r3);
              a2.readHexNumber(o2, r3);
              addHex(o2, n2, r3);
              a2.readNumber();
            }
            break;
          case 2:
            a2.readHex(g2, r3);
            h2 = a2.readNumber();
            t2.mapOne(hexToInt(g2, r3), h2);
            for (let e4 = 1; e4 < E2; e4++) {
              incHex(g2, r3);
              if (!i3) {
                a2.readHexNumber(C2, r3);
                addHex(g2, C2, r3);
              }
              h2 = a2.readSigned() + (h2 + 1);
              t2.mapOne(hexToInt(g2, r3), h2);
            }
            break;
          case 3:
            a2.readHex(n2, r3);
            a2.readHexNumber(o2, r3);
            addHex(o2, n2, r3);
            h2 = a2.readNumber();
            t2.mapCidRange(hexToInt(n2, r3), hexToInt(o2, r3), h2);
            for (let e4 = 1; e4 < E2; e4++) {
              incHex(o2, r3);
              if (i3) n2.set(o2);
              else {
                a2.readHexNumber(n2, r3);
                addHex(n2, o2, r3);
              }
              a2.readHexNumber(o2, r3);
              addHex(o2, n2, r3);
              h2 = a2.readNumber();
              t2.mapCidRange(hexToInt(n2, r3), hexToInt(o2, r3), h2);
            }
            break;
          case 4:
            a2.readHex(g2, Q2);
            a2.readHex(c2, r3);
            t2.mapOne(hexToInt(g2, Q2), hexToStr(c2, r3));
            for (let e4 = 1; e4 < E2; e4++) {
              incHex(g2, Q2);
              if (!i3) {
                a2.readHexNumber(C2, Q2);
                addHex(g2, C2, Q2);
              }
              incHex(c2, r3);
              a2.readHexSigned(C2, r3);
              addHex(c2, C2, r3);
              t2.mapOne(hexToInt(g2, Q2), hexToStr(c2, r3));
            }
            break;
          case 5:
            a2.readHex(n2, Q2);
            a2.readHexNumber(o2, Q2);
            addHex(o2, n2, Q2);
            a2.readHex(c2, r3);
            t2.mapBfRange(hexToInt(n2, Q2), hexToInt(o2, Q2), hexToStr(c2, r3));
            for (let e4 = 1; e4 < E2; e4++) {
              incHex(o2, Q2);
              if (i3) n2.set(o2);
              else {
                a2.readHexNumber(n2, Q2);
                addHex(n2, o2, Q2);
              }
              a2.readHexNumber(o2, Q2);
              addHex(o2, n2, Q2);
              a2.readHex(c2, r3);
              t2.mapBfRange(hexToInt(n2, Q2), hexToInt(o2, Q2), hexToStr(c2, r3));
            }
            break;
          default:
            throw new Error(`BinaryCMapReader.process - unknown type: ${e3}`);
        }
      }
      return s2 ? i2(s2) : t2;
    }
  }
  const Ut = new Uint8Array(0);
  class DecodeStream extends BaseStream {
    constructor(e2) {
      super();
      this._rawMinBufferLength = e2 || 0;
      this.pos = 0;
      this.bufferLength = 0;
      this.eof = false;
      this.buffer = Ut;
      this.minBufferLength = 512;
      if (e2) for (; this.minBufferLength < e2; ) this.minBufferLength *= 2;
    }
    get isEmpty() {
      for (; !this.eof && 0 === this.bufferLength; ) this.readBlock();
      return 0 === this.bufferLength;
    }
    ensureBuffer(e2) {
      const t2 = this.buffer;
      if (e2 <= t2.byteLength) return t2;
      let i2 = this.minBufferLength;
      for (; i2 < e2; ) i2 *= 2;
      const a2 = new Uint8Array(i2);
      a2.set(t2);
      return this.buffer = a2;
    }
    getByte() {
      const e2 = this.pos;
      for (; this.bufferLength <= e2; ) {
        if (this.eof) return -1;
        this.readBlock();
      }
      return this.buffer[this.pos++];
    }
    getBytes(e2, t2 = null) {
      const i2 = this.pos;
      let a2;
      if (e2) {
        this.ensureBuffer(i2 + e2);
        a2 = i2 + e2;
        for (; !this.eof && this.bufferLength < a2; ) this.readBlock(t2);
        const r2 = this.bufferLength;
        a2 > r2 && (a2 = r2);
      } else {
        for (; !this.eof; ) this.readBlock(t2);
        a2 = this.bufferLength;
      }
      this.pos = a2;
      return this.buffer.subarray(i2, a2);
    }
    async getImageData(e2, t2 = null) {
      if (!this.canAsyncDecodeImageFromBuffer) return this.getBytes(e2, t2);
      const i2 = await this.stream.asyncGetBytes();
      return this.decodeImage(i2, t2);
    }
    reset() {
      this.pos = 0;
    }
    makeSubStream(e2, t2, i2 = null) {
      if (void 0 === t2) for (; !this.eof; ) this.readBlock();
      else {
        const i3 = e2 + t2;
        for (; this.bufferLength <= i3 && !this.eof; ) this.readBlock();
      }
      return new Stream(this.buffer, e2, t2, i2);
    }
    getBaseStreams() {
      return this.str ? this.str.getBaseStreams() : null;
    }
  }
  class StreamsSequenceStream extends DecodeStream {
    constructor(e2, t2 = null) {
      e2 = e2.filter((e3) => e3 instanceof BaseStream);
      let i2 = 0;
      for (const t3 of e2) i2 += t3 instanceof DecodeStream ? t3._rawMinBufferLength : t3.length;
      super(i2);
      this.streams = e2;
      this._onError = t2;
    }
    readBlock() {
      var _a4;
      const e2 = this.streams;
      if (0 === e2.length) {
        this.eof = true;
        return;
      }
      const t2 = e2.shift();
      let i2;
      try {
        i2 = t2.getBytes();
      } catch (e3) {
        if (this._onError) {
          this._onError(e3, (_a4 = t2.dict) == null ? void 0 : _a4.objId);
          return;
        }
        throw e3;
      }
      const a2 = this.bufferLength, r2 = a2 + i2.length;
      this.ensureBuffer(r2).set(i2, a2);
      this.bufferLength = r2;
    }
    getBaseStreams() {
      const e2 = [];
      for (const t2 of this.streams) {
        const i2 = t2.getBaseStreams();
        i2 && e2.push(...i2);
      }
      return e2.length > 0 ? e2 : null;
    }
  }
  class Ascii85Stream extends DecodeStream {
    constructor(e2, t2) {
      t2 && (t2 *= 0.8);
      super(t2);
      this.str = e2;
      this.dict = e2.dict;
      this.input = new Uint8Array(5);
    }
    readBlock() {
      const e2 = this.str;
      let t2 = e2.getByte();
      for (; isWhiteSpace(t2); ) t2 = e2.getByte();
      if (-1 === t2 || 126 === t2) {
        this.eof = true;
        return;
      }
      const i2 = this.bufferLength;
      let a2, r2;
      if (122 === t2) {
        a2 = this.ensureBuffer(i2 + 4);
        for (r2 = 0; r2 < 4; ++r2) a2[i2 + r2] = 0;
        this.bufferLength += 4;
      } else {
        const s2 = this.input;
        s2[0] = t2;
        for (r2 = 1; r2 < 5; ++r2) {
          t2 = e2.getByte();
          for (; isWhiteSpace(t2); ) t2 = e2.getByte();
          s2[r2] = t2;
          if (-1 === t2 || 126 === t2) break;
        }
        a2 = this.ensureBuffer(i2 + r2 - 1);
        this.bufferLength += r2 - 1;
        if (r2 < 5) {
          for (; r2 < 5; ++r2) s2[r2] = 117;
          this.eof = true;
        }
        let n2 = 0;
        for (r2 = 0; r2 < 5; ++r2) n2 = 85 * n2 + (s2[r2] - 33);
        for (r2 = 3; r2 >= 0; --r2) {
          a2[i2 + r2] = 255 & n2;
          n2 >>= 8;
        }
      }
    }
  }
  class AsciiHexStream extends DecodeStream {
    constructor(e2, t2) {
      t2 && (t2 *= 0.5);
      super(t2);
      this.str = e2;
      this.dict = e2.dict;
      this.firstDigit = -1;
    }
    readBlock() {
      const e2 = this.str.getBytes(8e3);
      if (!e2.length) {
        this.eof = true;
        return;
      }
      const t2 = e2.length + 1 >> 1, i2 = this.ensureBuffer(this.bufferLength + t2);
      let a2 = this.bufferLength, r2 = this.firstDigit;
      for (const t3 of e2) {
        let e3;
        if (t3 >= 48 && t3 <= 57) e3 = 15 & t3;
        else {
          if (!(t3 >= 65 && t3 <= 70 || t3 >= 97 && t3 <= 102)) {
            if (62 === t3) {
              this.eof = true;
              break;
            }
            continue;
          }
          e3 = 9 + (15 & t3);
        }
        if (r2 < 0) r2 = e3;
        else {
          i2[a2++] = r2 << 4 | e3;
          r2 = -1;
        }
      }
      if (r2 >= 0 && this.eof) {
        i2[a2++] = r2 << 4;
        r2 = -1;
      }
      this.firstDigit = r2;
      this.bufferLength = a2;
    }
  }
  const Mt = -1, Lt = [
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      7,
      8
    ],
    [
      7,
      7
    ],
    [
      6,
      6
    ],
    [
      6,
      6
    ],
    [
      6,
      5
    ],
    [
      6,
      5
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      4,
      0
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      3,
      3
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ],
    [
      1,
      2
    ]
  ], Ht = [
    [
      -1,
      -1
    ],
    [
      12,
      -2
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      11,
      1792
    ],
    [
      11,
      1792
    ],
    [
      12,
      1984
    ],
    [
      12,
      2048
    ],
    [
      12,
      2112
    ],
    [
      12,
      2176
    ],
    [
      12,
      2240
    ],
    [
      12,
      2304
    ],
    [
      11,
      1856
    ],
    [
      11,
      1856
    ],
    [
      11,
      1920
    ],
    [
      11,
      1920
    ],
    [
      12,
      2368
    ],
    [
      12,
      2432
    ],
    [
      12,
      2496
    ],
    [
      12,
      2560
    ]
  ], Jt = [
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      8,
      29
    ],
    [
      8,
      29
    ],
    [
      8,
      30
    ],
    [
      8,
      30
    ],
    [
      8,
      45
    ],
    [
      8,
      45
    ],
    [
      8,
      46
    ],
    [
      8,
      46
    ],
    [
      7,
      22
    ],
    [
      7,
      22
    ],
    [
      7,
      22
    ],
    [
      7,
      22
    ],
    [
      7,
      23
    ],
    [
      7,
      23
    ],
    [
      7,
      23
    ],
    [
      7,
      23
    ],
    [
      8,
      47
    ],
    [
      8,
      47
    ],
    [
      8,
      48
    ],
    [
      8,
      48
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      6,
      13
    ],
    [
      7,
      20
    ],
    [
      7,
      20
    ],
    [
      7,
      20
    ],
    [
      7,
      20
    ],
    [
      8,
      33
    ],
    [
      8,
      33
    ],
    [
      8,
      34
    ],
    [
      8,
      34
    ],
    [
      8,
      35
    ],
    [
      8,
      35
    ],
    [
      8,
      36
    ],
    [
      8,
      36
    ],
    [
      8,
      37
    ],
    [
      8,
      37
    ],
    [
      8,
      38
    ],
    [
      8,
      38
    ],
    [
      7,
      19
    ],
    [
      7,
      19
    ],
    [
      7,
      19
    ],
    [
      7,
      19
    ],
    [
      8,
      31
    ],
    [
      8,
      31
    ],
    [
      8,
      32
    ],
    [
      8,
      32
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      1
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      6,
      12
    ],
    [
      8,
      53
    ],
    [
      8,
      53
    ],
    [
      8,
      54
    ],
    [
      8,
      54
    ],
    [
      7,
      26
    ],
    [
      7,
      26
    ],
    [
      7,
      26
    ],
    [
      7,
      26
    ],
    [
      8,
      39
    ],
    [
      8,
      39
    ],
    [
      8,
      40
    ],
    [
      8,
      40
    ],
    [
      8,
      41
    ],
    [
      8,
      41
    ],
    [
      8,
      42
    ],
    [
      8,
      42
    ],
    [
      8,
      43
    ],
    [
      8,
      43
    ],
    [
      8,
      44
    ],
    [
      8,
      44
    ],
    [
      7,
      21
    ],
    [
      7,
      21
    ],
    [
      7,
      21
    ],
    [
      7,
      21
    ],
    [
      7,
      28
    ],
    [
      7,
      28
    ],
    [
      7,
      28
    ],
    [
      7,
      28
    ],
    [
      8,
      61
    ],
    [
      8,
      61
    ],
    [
      8,
      62
    ],
    [
      8,
      62
    ],
    [
      8,
      63
    ],
    [
      8,
      63
    ],
    [
      8,
      0
    ],
    [
      8,
      0
    ],
    [
      8,
      320
    ],
    [
      8,
      320
    ],
    [
      8,
      384
    ],
    [
      8,
      384
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      10
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      5,
      11
    ],
    [
      7,
      27
    ],
    [
      7,
      27
    ],
    [
      7,
      27
    ],
    [
      7,
      27
    ],
    [
      8,
      59
    ],
    [
      8,
      59
    ],
    [
      8,
      60
    ],
    [
      8,
      60
    ],
    [
      9,
      1472
    ],
    [
      9,
      1536
    ],
    [
      9,
      1600
    ],
    [
      9,
      1728
    ],
    [
      7,
      18
    ],
    [
      7,
      18
    ],
    [
      7,
      18
    ],
    [
      7,
      18
    ],
    [
      7,
      24
    ],
    [
      7,
      24
    ],
    [
      7,
      24
    ],
    [
      7,
      24
    ],
    [
      8,
      49
    ],
    [
      8,
      49
    ],
    [
      8,
      50
    ],
    [
      8,
      50
    ],
    [
      8,
      51
    ],
    [
      8,
      51
    ],
    [
      8,
      52
    ],
    [
      8,
      52
    ],
    [
      7,
      25
    ],
    [
      7,
      25
    ],
    [
      7,
      25
    ],
    [
      7,
      25
    ],
    [
      8,
      55
    ],
    [
      8,
      55
    ],
    [
      8,
      56
    ],
    [
      8,
      56
    ],
    [
      8,
      57
    ],
    [
      8,
      57
    ],
    [
      8,
      58
    ],
    [
      8,
      58
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      192
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      6,
      1664
    ],
    [
      8,
      448
    ],
    [
      8,
      448
    ],
    [
      8,
      512
    ],
    [
      8,
      512
    ],
    [
      9,
      704
    ],
    [
      9,
      768
    ],
    [
      8,
      640
    ],
    [
      8,
      640
    ],
    [
      8,
      576
    ],
    [
      8,
      576
    ],
    [
      9,
      832
    ],
    [
      9,
      896
    ],
    [
      9,
      960
    ],
    [
      9,
      1024
    ],
    [
      9,
      1088
    ],
    [
      9,
      1152
    ],
    [
      9,
      1216
    ],
    [
      9,
      1280
    ],
    [
      9,
      1344
    ],
    [
      9,
      1408
    ],
    [
      7,
      256
    ],
    [
      7,
      256
    ],
    [
      7,
      256
    ],
    [
      7,
      256
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      2
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      4,
      3
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      128
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      8
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      5,
      9
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      16
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      6,
      17
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      4
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      14
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      6,
      15
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      5,
      64
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ],
    [
      4,
      7
    ]
  ], vt = [
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      12,
      -2
    ],
    [
      12,
      -2
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      11,
      1792
    ],
    [
      11,
      1792
    ],
    [
      11,
      1792
    ],
    [
      11,
      1792
    ],
    [
      12,
      1984
    ],
    [
      12,
      1984
    ],
    [
      12,
      2048
    ],
    [
      12,
      2048
    ],
    [
      12,
      2112
    ],
    [
      12,
      2112
    ],
    [
      12,
      2176
    ],
    [
      12,
      2176
    ],
    [
      12,
      2240
    ],
    [
      12,
      2240
    ],
    [
      12,
      2304
    ],
    [
      12,
      2304
    ],
    [
      11,
      1856
    ],
    [
      11,
      1856
    ],
    [
      11,
      1856
    ],
    [
      11,
      1856
    ],
    [
      11,
      1920
    ],
    [
      11,
      1920
    ],
    [
      11,
      1920
    ],
    [
      11,
      1920
    ],
    [
      12,
      2368
    ],
    [
      12,
      2368
    ],
    [
      12,
      2432
    ],
    [
      12,
      2432
    ],
    [
      12,
      2496
    ],
    [
      12,
      2496
    ],
    [
      12,
      2560
    ],
    [
      12,
      2560
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      10,
      18
    ],
    [
      12,
      52
    ],
    [
      12,
      52
    ],
    [
      13,
      640
    ],
    [
      13,
      704
    ],
    [
      13,
      768
    ],
    [
      13,
      832
    ],
    [
      12,
      55
    ],
    [
      12,
      55
    ],
    [
      12,
      56
    ],
    [
      12,
      56
    ],
    [
      13,
      1280
    ],
    [
      13,
      1344
    ],
    [
      13,
      1408
    ],
    [
      13,
      1472
    ],
    [
      12,
      59
    ],
    [
      12,
      59
    ],
    [
      12,
      60
    ],
    [
      12,
      60
    ],
    [
      13,
      1536
    ],
    [
      13,
      1600
    ],
    [
      11,
      24
    ],
    [
      11,
      24
    ],
    [
      11,
      24
    ],
    [
      11,
      24
    ],
    [
      11,
      25
    ],
    [
      11,
      25
    ],
    [
      11,
      25
    ],
    [
      11,
      25
    ],
    [
      13,
      1664
    ],
    [
      13,
      1728
    ],
    [
      12,
      320
    ],
    [
      12,
      320
    ],
    [
      12,
      384
    ],
    [
      12,
      384
    ],
    [
      12,
      448
    ],
    [
      12,
      448
    ],
    [
      13,
      512
    ],
    [
      13,
      576
    ],
    [
      12,
      53
    ],
    [
      12,
      53
    ],
    [
      12,
      54
    ],
    [
      12,
      54
    ],
    [
      13,
      896
    ],
    [
      13,
      960
    ],
    [
      13,
      1024
    ],
    [
      13,
      1088
    ],
    [
      13,
      1152
    ],
    [
      13,
      1216
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ],
    [
      10,
      64
    ]
  ], Yt = [
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      8,
      13
    ],
    [
      11,
      23
    ],
    [
      11,
      23
    ],
    [
      12,
      50
    ],
    [
      12,
      51
    ],
    [
      12,
      44
    ],
    [
      12,
      45
    ],
    [
      12,
      46
    ],
    [
      12,
      47
    ],
    [
      12,
      57
    ],
    [
      12,
      58
    ],
    [
      12,
      61
    ],
    [
      12,
      256
    ],
    [
      10,
      16
    ],
    [
      10,
      16
    ],
    [
      10,
      16
    ],
    [
      10,
      16
    ],
    [
      10,
      17
    ],
    [
      10,
      17
    ],
    [
      10,
      17
    ],
    [
      10,
      17
    ],
    [
      12,
      48
    ],
    [
      12,
      49
    ],
    [
      12,
      62
    ],
    [
      12,
      63
    ],
    [
      12,
      30
    ],
    [
      12,
      31
    ],
    [
      12,
      32
    ],
    [
      12,
      33
    ],
    [
      12,
      40
    ],
    [
      12,
      41
    ],
    [
      11,
      22
    ],
    [
      11,
      22
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      8,
      14
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      10
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      7,
      11
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      9,
      15
    ],
    [
      12,
      128
    ],
    [
      12,
      192
    ],
    [
      12,
      26
    ],
    [
      12,
      27
    ],
    [
      12,
      28
    ],
    [
      12,
      29
    ],
    [
      11,
      19
    ],
    [
      11,
      19
    ],
    [
      11,
      20
    ],
    [
      11,
      20
    ],
    [
      12,
      34
    ],
    [
      12,
      35
    ],
    [
      12,
      36
    ],
    [
      12,
      37
    ],
    [
      12,
      38
    ],
    [
      12,
      39
    ],
    [
      11,
      21
    ],
    [
      11,
      21
    ],
    [
      12,
      42
    ],
    [
      12,
      43
    ],
    [
      10,
      0
    ],
    [
      10,
      0
    ],
    [
      10,
      0
    ],
    [
      10,
      0
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ],
    [
      7,
      12
    ]
  ], Tt = [
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      -1,
      -1
    ],
    [
      6,
      9
    ],
    [
      6,
      8
    ],
    [
      5,
      7
    ],
    [
      5,
      7
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      6
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      4,
      5
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      1
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      3,
      4
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      3
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ],
    [
      2,
      2
    ]
  ];
  class CCITTFaxDecoder {
    constructor(e2, t2 = {}) {
      if (!e2 || "function" != typeof e2.next) throw new Error('CCITTFaxDecoder - invalid "source" parameter.');
      this.source = e2;
      this.eof = false;
      this.encoding = t2.K || 0;
      this.eoline = t2.EndOfLine || false;
      this.byteAlign = t2.EncodedByteAlign || false;
      this.columns = t2.Columns || 1728;
      this.rows = t2.Rows || 0;
      this.eoblock = t2.EndOfBlock ?? true;
      this.black = t2.BlackIs1 || false;
      this.codingLine = new Uint32Array(this.columns + 1);
      this.refLine = new Uint32Array(this.columns + 2);
      this.codingLine[0] = this.columns;
      this.codingPos = 0;
      this.row = 0;
      this.nextLine2D = this.encoding < 0;
      this.inputBits = 0;
      this.inputBuf = 0;
      this.outputBits = 0;
      this.rowsDone = false;
      let i2;
      for (; 0 === (i2 = this._lookBits(12)); ) this._eatBits(1);
      1 === i2 && this._eatBits(12);
      if (this.encoding > 0) {
        this.nextLine2D = !this._lookBits(1);
        this._eatBits(1);
      }
    }
    readNextChar() {
      if (this.eof) return -1;
      const e2 = this.refLine, t2 = this.codingLine, i2 = this.columns;
      let a2, r2, s2, n2, o2;
      if (0 === this.outputBits) {
        this.rowsDone && (this.eof = true);
        if (this.eof) return -1;
        this.err = false;
        let s3, o3, g2;
        if (this.nextLine2D) {
          for (n2 = 0; t2[n2] < i2; ++n2) e2[n2] = t2[n2];
          e2[n2++] = i2;
          e2[n2] = i2;
          t2[0] = 0;
          this.codingPos = 0;
          a2 = 0;
          r2 = 0;
          for (; t2[this.codingPos] < i2; ) {
            s3 = this._getTwoDimCode();
            switch (s3) {
              case 0:
                this._addPixels(e2[a2 + 1], r2);
                e2[a2 + 1] < i2 && (a2 += 2);
                break;
              case 1:
                s3 = o3 = 0;
                if (r2) {
                  do {
                    s3 += g2 = this._getBlackCode();
                  } while (g2 >= 64);
                  do {
                    o3 += g2 = this._getWhiteCode();
                  } while (g2 >= 64);
                } else {
                  do {
                    s3 += g2 = this._getWhiteCode();
                  } while (g2 >= 64);
                  do {
                    o3 += g2 = this._getBlackCode();
                  } while (g2 >= 64);
                }
                this._addPixels(t2[this.codingPos] + s3, r2);
                t2[this.codingPos] < i2 && this._addPixels(t2[this.codingPos] + o3, 1 ^ r2);
                for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                break;
              case 7:
                this._addPixels(e2[a2] + 3, r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case 5:
                this._addPixels(e2[a2] + 2, r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case 3:
                this._addPixels(e2[a2] + 1, r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case 2:
                this._addPixels(e2[a2], r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case 8:
                this._addPixelsNeg(e2[a2] - 3, r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  a2 > 0 ? --a2 : ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case 6:
                this._addPixelsNeg(e2[a2] - 2, r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  a2 > 0 ? --a2 : ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case 4:
                this._addPixelsNeg(e2[a2] - 1, r2);
                r2 ^= 1;
                if (t2[this.codingPos] < i2) {
                  a2 > 0 ? --a2 : ++a2;
                  for (; e2[a2] <= t2[this.codingPos] && e2[a2] < i2; ) a2 += 2;
                }
                break;
              case Mt:
                this._addPixels(i2, 0);
                this.eof = true;
                break;
              default:
                info("bad 2d code");
                this._addPixels(i2, 0);
                this.err = true;
            }
          }
        } else {
          t2[0] = 0;
          this.codingPos = 0;
          r2 = 0;
          for (; t2[this.codingPos] < i2; ) {
            s3 = 0;
            if (r2) do {
              s3 += g2 = this._getBlackCode();
            } while (g2 >= 64);
            else do {
              s3 += g2 = this._getWhiteCode();
            } while (g2 >= 64);
            this._addPixels(t2[this.codingPos] + s3, r2);
            r2 ^= 1;
          }
        }
        let c2 = false;
        this.byteAlign && (this.inputBits &= -8);
        if (this.eoblock || this.row !== this.rows - 1) {
          s3 = this._lookBits(12);
          if (this.eoline) for (; s3 !== Mt && 1 !== s3; ) {
            this._eatBits(1);
            s3 = this._lookBits(12);
          }
          else for (; 0 === s3; ) {
            this._eatBits(1);
            s3 = this._lookBits(12);
          }
          if (1 === s3) {
            this._eatBits(12);
            c2 = true;
          } else s3 === Mt && (this.eof = true);
        } else this.rowsDone = true;
        if (!this.eof && this.encoding > 0 && !this.rowsDone) {
          this.nextLine2D = !this._lookBits(1);
          this._eatBits(1);
        }
        if (this.eoblock && c2 && this.byteAlign) {
          s3 = this._lookBits(12);
          if (1 === s3) {
            this._eatBits(12);
            if (this.encoding > 0) {
              this._lookBits(1);
              this._eatBits(1);
            }
            if (this.encoding >= 0) for (n2 = 0; n2 < 4; ++n2) {
              s3 = this._lookBits(12);
              1 !== s3 && info("bad rtc code: " + s3);
              this._eatBits(12);
              if (this.encoding > 0) {
                this._lookBits(1);
                this._eatBits(1);
              }
            }
            this.eof = true;
          }
        } else if (this.err && this.eoline) {
          for (; ; ) {
            s3 = this._lookBits(13);
            if (s3 === Mt) {
              this.eof = true;
              return -1;
            }
            if (s3 >> 1 == 1) break;
            this._eatBits(1);
          }
          this._eatBits(12);
          if (this.encoding > 0) {
            this._eatBits(1);
            this.nextLine2D = !(1 & s3);
          }
        }
        this.outputBits = t2[0] > 0 ? t2[this.codingPos = 0] : t2[this.codingPos = 1];
        this.row++;
      }
      if (this.outputBits >= 8) {
        o2 = 1 & this.codingPos ? 0 : 255;
        this.outputBits -= 8;
        if (0 === this.outputBits && t2[this.codingPos] < i2) {
          this.codingPos++;
          this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1];
        }
      } else {
        s2 = 8;
        o2 = 0;
        do {
          if ("number" != typeof this.outputBits) throw new FormatError('Invalid /CCITTFaxDecode data, "outputBits" must be a number.');
          if (this.outputBits > s2) {
            o2 <<= s2;
            1 & this.codingPos || (o2 |= 255 >> 8 - s2);
            this.outputBits -= s2;
            s2 = 0;
          } else {
            o2 <<= this.outputBits;
            1 & this.codingPos || (o2 |= 255 >> 8 - this.outputBits);
            s2 -= this.outputBits;
            this.outputBits = 0;
            if (t2[this.codingPos] < i2) {
              this.codingPos++;
              this.outputBits = t2[this.codingPos] - t2[this.codingPos - 1];
            } else if (s2 > 0) {
              o2 <<= s2;
              s2 = 0;
            }
          }
        } while (s2);
      }
      this.black && (o2 ^= 255);
      return o2;
    }
    _addPixels(e2, t2) {
      const i2 = this.codingLine;
      let a2 = this.codingPos;
      if (e2 > i2[a2]) {
        if (e2 > this.columns) {
          info("row is wrong length");
          this.err = true;
          e2 = this.columns;
        }
        1 & a2 ^ t2 && ++a2;
        i2[a2] = e2;
      }
      this.codingPos = a2;
    }
    _addPixelsNeg(e2, t2) {
      const i2 = this.codingLine;
      let a2 = this.codingPos;
      if (e2 > i2[a2]) {
        if (e2 > this.columns) {
          info("row is wrong length");
          this.err = true;
          e2 = this.columns;
        }
        1 & a2 ^ t2 && ++a2;
        i2[a2] = e2;
      } else if (e2 < i2[a2]) {
        if (e2 < 0) {
          info("invalid code");
          this.err = true;
          e2 = 0;
        }
        for (; a2 > 0 && e2 < i2[a2 - 1]; ) --a2;
        i2[a2] = e2;
      }
      this.codingPos = a2;
    }
    _findTableCode(e2, t2, i2, a2) {
      const r2 = a2 || 0;
      for (let a3 = e2; a3 <= t2; ++a3) {
        let e3 = this._lookBits(a3);
        if (e3 === Mt) return [
          true,
          1,
          false
        ];
        a3 < t2 && (e3 <<= t2 - a3);
        if (!r2 || e3 >= r2) {
          const t3 = i2[e3 - r2];
          if (t3[0] === a3) {
            this._eatBits(a3);
            return [
              true,
              t3[1],
              true
            ];
          }
        }
      }
      return [
        false,
        0,
        false
      ];
    }
    _getTwoDimCode() {
      let e2, t2 = 0;
      if (this.eoblock) {
        t2 = this._lookBits(7);
        e2 = Lt[t2];
        if ((e2 == null ? void 0 : e2[0]) > 0) {
          this._eatBits(e2[0]);
          return e2[1];
        }
      } else {
        const e3 = this._findTableCode(1, 7, Lt);
        if (e3[0] && e3[2]) return e3[1];
      }
      info("Bad two dim code");
      return Mt;
    }
    _getWhiteCode() {
      let e2, t2 = 0;
      if (this.eoblock) {
        t2 = this._lookBits(12);
        if (t2 === Mt) return 1;
        e2 = t2 >> 5 == 0 ? Ht[t2] : Jt[t2 >> 3];
        if (e2[0] > 0) {
          this._eatBits(e2[0]);
          return e2[1];
        }
      } else {
        let e3 = this._findTableCode(1, 9, Jt);
        if (e3[0]) return e3[1];
        e3 = this._findTableCode(11, 12, Ht);
        if (e3[0]) return e3[1];
      }
      info("bad white code");
      this._eatBits(1);
      return 1;
    }
    _getBlackCode() {
      let e2, t2;
      if (this.eoblock) {
        e2 = this._lookBits(13);
        if (e2 === Mt) return 1;
        t2 = e2 >> 7 == 0 ? vt[e2] : e2 >> 9 == 0 && e2 >> 7 != 0 ? Yt[(e2 >> 1) - 64] : Tt[e2 >> 7];
        if (t2[0] > 0) {
          this._eatBits(t2[0]);
          return t2[1];
        }
      } else {
        let e3 = this._findTableCode(2, 6, Tt);
        if (e3[0]) return e3[1];
        e3 = this._findTableCode(7, 12, Yt, 64);
        if (e3[0]) return e3[1];
        e3 = this._findTableCode(10, 13, vt);
        if (e3[0]) return e3[1];
      }
      info("bad black code");
      this._eatBits(1);
      return 1;
    }
    _lookBits(e2) {
      let t2;
      for (; this.inputBits < e2; ) {
        if (-1 === (t2 = this.source.next())) return 0 === this.inputBits ? Mt : this.inputBuf << e2 - this.inputBits & 65535 >> 16 - e2;
        this.inputBuf = this.inputBuf << 8 | t2;
        this.inputBits += 8;
      }
      return this.inputBuf >> this.inputBits - e2 & 65535 >> 16 - e2;
    }
    _eatBits(e2) {
      (this.inputBits -= e2) < 0 && (this.inputBits = 0);
    }
  }
  class CCITTFaxStream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      this.str = e2;
      this.dict = e2.dict;
      i2 instanceof Dict || (i2 = Dict.empty);
      const a2 = {
        next: () => e2.getByte()
      };
      this.ccittFaxDecoder = new CCITTFaxDecoder(a2, {
        K: i2.get("K"),
        EndOfLine: i2.get("EndOfLine"),
        EncodedByteAlign: i2.get("EncodedByteAlign"),
        Columns: i2.get("Columns"),
        Rows: i2.get("Rows"),
        EndOfBlock: i2.get("EndOfBlock"),
        BlackIs1: i2.get("BlackIs1")
      });
    }
    readBlock() {
      for (; !this.eof; ) {
        const e2 = this.ccittFaxDecoder.readNextChar();
        if (-1 === e2) {
          this.eof = true;
          return;
        }
        this.ensureBuffer(this.bufferLength + 1);
        this.buffer[this.bufferLength++] = e2;
      }
    }
  }
  const Kt = new Int32Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
  ]), qt = new Int32Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    65547,
    65549,
    65551,
    65553,
    131091,
    131095,
    131099,
    131103,
    196643,
    196651,
    196659,
    196667,
    262211,
    262227,
    262243,
    262259,
    327811,
    327843,
    327875,
    327907,
    258,
    258,
    258
  ]), Ot = new Int32Array([
    1,
    2,
    3,
    4,
    65541,
    65543,
    131081,
    131085,
    196625,
    196633,
    262177,
    262193,
    327745,
    327777,
    393345,
    393409,
    459009,
    459137,
    524801,
    525057,
    590849,
    591361,
    657409,
    658433,
    724993,
    727041,
    794625,
    798721,
    868353,
    876545
  ]), Pt = [
    new Int32Array([
      459008,
      524368,
      524304,
      524568,
      459024,
      524400,
      524336,
      590016,
      459016,
      524384,
      524320,
      589984,
      524288,
      524416,
      524352,
      590048,
      459012,
      524376,
      524312,
      589968,
      459028,
      524408,
      524344,
      590032,
      459020,
      524392,
      524328,
      59e4,
      524296,
      524424,
      524360,
      590064,
      459010,
      524372,
      524308,
      524572,
      459026,
      524404,
      524340,
      590024,
      459018,
      524388,
      524324,
      589992,
      524292,
      524420,
      524356,
      590056,
      459014,
      524380,
      524316,
      589976,
      459030,
      524412,
      524348,
      590040,
      459022,
      524396,
      524332,
      590008,
      524300,
      524428,
      524364,
      590072,
      459009,
      524370,
      524306,
      524570,
      459025,
      524402,
      524338,
      590020,
      459017,
      524386,
      524322,
      589988,
      524290,
      524418,
      524354,
      590052,
      459013,
      524378,
      524314,
      589972,
      459029,
      524410,
      524346,
      590036,
      459021,
      524394,
      524330,
      590004,
      524298,
      524426,
      524362,
      590068,
      459011,
      524374,
      524310,
      524574,
      459027,
      524406,
      524342,
      590028,
      459019,
      524390,
      524326,
      589996,
      524294,
      524422,
      524358,
      590060,
      459015,
      524382,
      524318,
      589980,
      459031,
      524414,
      524350,
      590044,
      459023,
      524398,
      524334,
      590012,
      524302,
      524430,
      524366,
      590076,
      459008,
      524369,
      524305,
      524569,
      459024,
      524401,
      524337,
      590018,
      459016,
      524385,
      524321,
      589986,
      524289,
      524417,
      524353,
      590050,
      459012,
      524377,
      524313,
      589970,
      459028,
      524409,
      524345,
      590034,
      459020,
      524393,
      524329,
      590002,
      524297,
      524425,
      524361,
      590066,
      459010,
      524373,
      524309,
      524573,
      459026,
      524405,
      524341,
      590026,
      459018,
      524389,
      524325,
      589994,
      524293,
      524421,
      524357,
      590058,
      459014,
      524381,
      524317,
      589978,
      459030,
      524413,
      524349,
      590042,
      459022,
      524397,
      524333,
      590010,
      524301,
      524429,
      524365,
      590074,
      459009,
      524371,
      524307,
      524571,
      459025,
      524403,
      524339,
      590022,
      459017,
      524387,
      524323,
      589990,
      524291,
      524419,
      524355,
      590054,
      459013,
      524379,
      524315,
      589974,
      459029,
      524411,
      524347,
      590038,
      459021,
      524395,
      524331,
      590006,
      524299,
      524427,
      524363,
      590070,
      459011,
      524375,
      524311,
      524575,
      459027,
      524407,
      524343,
      590030,
      459019,
      524391,
      524327,
      589998,
      524295,
      524423,
      524359,
      590062,
      459015,
      524383,
      524319,
      589982,
      459031,
      524415,
      524351,
      590046,
      459023,
      524399,
      524335,
      590014,
      524303,
      524431,
      524367,
      590078,
      459008,
      524368,
      524304,
      524568,
      459024,
      524400,
      524336,
      590017,
      459016,
      524384,
      524320,
      589985,
      524288,
      524416,
      524352,
      590049,
      459012,
      524376,
      524312,
      589969,
      459028,
      524408,
      524344,
      590033,
      459020,
      524392,
      524328,
      590001,
      524296,
      524424,
      524360,
      590065,
      459010,
      524372,
      524308,
      524572,
      459026,
      524404,
      524340,
      590025,
      459018,
      524388,
      524324,
      589993,
      524292,
      524420,
      524356,
      590057,
      459014,
      524380,
      524316,
      589977,
      459030,
      524412,
      524348,
      590041,
      459022,
      524396,
      524332,
      590009,
      524300,
      524428,
      524364,
      590073,
      459009,
      524370,
      524306,
      524570,
      459025,
      524402,
      524338,
      590021,
      459017,
      524386,
      524322,
      589989,
      524290,
      524418,
      524354,
      590053,
      459013,
      524378,
      524314,
      589973,
      459029,
      524410,
      524346,
      590037,
      459021,
      524394,
      524330,
      590005,
      524298,
      524426,
      524362,
      590069,
      459011,
      524374,
      524310,
      524574,
      459027,
      524406,
      524342,
      590029,
      459019,
      524390,
      524326,
      589997,
      524294,
      524422,
      524358,
      590061,
      459015,
      524382,
      524318,
      589981,
      459031,
      524414,
      524350,
      590045,
      459023,
      524398,
      524334,
      590013,
      524302,
      524430,
      524366,
      590077,
      459008,
      524369,
      524305,
      524569,
      459024,
      524401,
      524337,
      590019,
      459016,
      524385,
      524321,
      589987,
      524289,
      524417,
      524353,
      590051,
      459012,
      524377,
      524313,
      589971,
      459028,
      524409,
      524345,
      590035,
      459020,
      524393,
      524329,
      590003,
      524297,
      524425,
      524361,
      590067,
      459010,
      524373,
      524309,
      524573,
      459026,
      524405,
      524341,
      590027,
      459018,
      524389,
      524325,
      589995,
      524293,
      524421,
      524357,
      590059,
      459014,
      524381,
      524317,
      589979,
      459030,
      524413,
      524349,
      590043,
      459022,
      524397,
      524333,
      590011,
      524301,
      524429,
      524365,
      590075,
      459009,
      524371,
      524307,
      524571,
      459025,
      524403,
      524339,
      590023,
      459017,
      524387,
      524323,
      589991,
      524291,
      524419,
      524355,
      590055,
      459013,
      524379,
      524315,
      589975,
      459029,
      524411,
      524347,
      590039,
      459021,
      524395,
      524331,
      590007,
      524299,
      524427,
      524363,
      590071,
      459011,
      524375,
      524311,
      524575,
      459027,
      524407,
      524343,
      590031,
      459019,
      524391,
      524327,
      589999,
      524295,
      524423,
      524359,
      590063,
      459015,
      524383,
      524319,
      589983,
      459031,
      524415,
      524351,
      590047,
      459023,
      524399,
      524335,
      590015,
      524303,
      524431,
      524367,
      590079
    ]),
    9
  ], Wt = [
    new Int32Array([
      327680,
      327696,
      327688,
      327704,
      327684,
      327700,
      327692,
      327708,
      327682,
      327698,
      327690,
      327706,
      327686,
      327702,
      327694,
      0,
      327681,
      327697,
      327689,
      327705,
      327685,
      327701,
      327693,
      327709,
      327683,
      327699,
      327691,
      327707,
      327687,
      327703,
      327695,
      0
    ]),
    5
  ];
  class FlateStream extends DecodeStream {
    constructor(e2, t2) {
      super(t2);
      __privateAdd(this, _FlateStream_instances);
      this.str = e2;
      this.dict = e2.dict;
      const i2 = e2.getByte(), a2 = e2.getByte();
      if (-1 === i2 || -1 === a2) throw new FormatError(`Invalid header in flate stream: ${i2}, ${a2}`);
      if (8 != (15 & i2)) throw new FormatError(`Unknown compression method in flate stream: ${i2}, ${a2}`);
      if (((i2 << 8) + a2) % 31 != 0) throw new FormatError(`Bad FCHECK in flate stream: ${i2}, ${a2}`);
      if (32 & a2) throw new FormatError(`FDICT bit set in flate stream: ${i2}, ${a2}`);
      this.codeSize = 0;
      this.codeBuf = 0;
    }
    async getImageData(e2, t2) {
      const i2 = await this.asyncGetBytes();
      return (i2 == null ? void 0 : i2.subarray(0, e2)) || this.getBytes(e2);
    }
    async asyncGetBytes() {
      this.str.reset();
      const e2 = this.str.getBytes();
      try {
        const { readable: t2, writable: i2 } = new DecompressionStream("deflate"), a2 = i2.getWriter();
        await a2.ready;
        a2.write(e2).then(async () => {
          await a2.ready;
          await a2.close();
        }).catch(() => {
        });
        const r2 = [];
        let s2 = 0;
        for await (const e3 of t2) {
          r2.push(e3);
          s2 += e3.byteLength;
        }
        const n2 = new Uint8Array(s2);
        let o2 = 0;
        for (const e3 of r2) {
          n2.set(e3, o2);
          o2 += e3.byteLength;
        }
        return n2;
      } catch {
        this.str = new Stream(e2, 2, e2.length, this.str.dict);
        this.reset();
        return null;
      }
    }
    get isAsync() {
      return true;
    }
    getBits(e2) {
      const t2 = this.str;
      let i2, a2 = this.codeSize, r2 = this.codeBuf;
      for (; a2 < e2; ) {
        if (-1 === (i2 = t2.getByte())) throw new FormatError("Bad encoding in flate stream");
        r2 |= i2 << a2;
        a2 += 8;
      }
      i2 = r2 & (1 << e2) - 1;
      this.codeBuf = r2 >> e2;
      this.codeSize = a2 -= e2;
      return i2;
    }
    getCode(e2) {
      const t2 = this.str, i2 = e2[0], a2 = e2[1];
      let r2, s2 = this.codeSize, n2 = this.codeBuf;
      for (; s2 < a2 && -1 !== (r2 = t2.getByte()); ) {
        n2 |= r2 << s2;
        s2 += 8;
      }
      const o2 = i2[n2 & (1 << a2) - 1], g2 = o2 >> 16, c2 = 65535 & o2;
      if (g2 < 1 || s2 < g2) throw new FormatError("Bad encoding in flate stream");
      this.codeBuf = n2 >> g2;
      this.codeSize = s2 - g2;
      return c2;
    }
    generateHuffmanTable(e2) {
      const t2 = e2.length;
      let i2, a2 = 0;
      for (i2 = 0; i2 < t2; ++i2) e2[i2] > a2 && (a2 = e2[i2]);
      const r2 = 1 << a2, s2 = new Int32Array(r2);
      for (let n2 = 1, o2 = 0, g2 = 2; n2 <= a2; ++n2, o2 <<= 1, g2 <<= 1) for (let a3 = 0; a3 < t2; ++a3) if (e2[a3] === n2) {
        let e3 = 0, t3 = o2;
        for (i2 = 0; i2 < n2; ++i2) {
          e3 = e3 << 1 | 1 & t3;
          t3 >>= 1;
        }
        for (i2 = e3; i2 < r2; i2 += g2) s2[i2] = n2 << 16 | a3;
        ++o2;
      }
      return [
        s2,
        a2
      ];
    }
    readBlock() {
      let e2, t2, i2;
      const a2 = this.str;
      try {
        t2 = this.getBits(3);
      } catch (e3) {
        __privateMethod(this, _FlateStream_instances, m_fn).call(this, e3.message);
        return;
      }
      1 & t2 && (this.eof = true);
      t2 >>= 1;
      if (0 === t2) {
        let t3;
        if (-1 === (t3 = a2.getByte())) {
          __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          return;
        }
        let i3 = t3;
        if (-1 === (t3 = a2.getByte())) {
          __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          return;
        }
        i3 |= t3 << 8;
        if (-1 === (t3 = a2.getByte())) {
          __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          return;
        }
        let r3 = t3;
        if (-1 === (t3 = a2.getByte())) {
          __privateMethod(this, _FlateStream_instances, m_fn).call(this, "Bad block header in flate stream");
          return;
        }
        r3 |= t3 << 8;
        if (r3 !== (65535 & ~i3) && (0 !== i3 || 0 !== r3)) throw new FormatError("Bad uncompressed block length in flate stream");
        this.codeBuf = 0;
        this.codeSize = 0;
        const s3 = this.bufferLength, n3 = s3 + i3;
        e2 = this.ensureBuffer(n3);
        this.bufferLength = n3;
        if (0 === i3) -1 === a2.peekByte() && (this.eof = true);
        else {
          const t4 = a2.getBytes(i3);
          e2.set(t4, s3);
          t4.length < i3 && (this.eof = true);
        }
        return;
      }
      let r2, s2;
      if (1 === t2) {
        r2 = Pt;
        s2 = Wt;
      } else {
        if (2 !== t2) throw new FormatError("Unknown block type in flate stream");
        {
          const e3 = this.getBits(5) + 257, t3 = this.getBits(5) + 1, a3 = this.getBits(4) + 4, n3 = new Uint8Array(Kt.length);
          let o3;
          for (o3 = 0; o3 < a3; ++o3) n3[Kt[o3]] = this.getBits(3);
          const g2 = this.generateHuffmanTable(n3);
          i2 = 0;
          o3 = 0;
          const c2 = e3 + t3, C2 = new Uint8Array(c2);
          let h2, l2, Q2;
          for (; o3 < c2; ) {
            const e4 = this.getCode(g2);
            if (16 === e4) {
              h2 = 2;
              l2 = 3;
              Q2 = i2;
            } else if (17 === e4) {
              h2 = 3;
              l2 = 3;
              Q2 = i2 = 0;
            } else {
              if (18 !== e4) {
                C2[o3++] = i2 = e4;
                continue;
              }
              h2 = 7;
              l2 = 11;
              Q2 = i2 = 0;
            }
            let t4 = this.getBits(h2) + l2;
            for (; t4-- > 0; ) C2[o3++] = Q2;
          }
          r2 = this.generateHuffmanTable(C2.subarray(0, e3));
          s2 = this.generateHuffmanTable(C2.subarray(e3, c2));
        }
      }
      e2 = this.buffer;
      let n2 = e2 ? e2.length : 0, o2 = this.bufferLength;
      for (; ; ) {
        let t3 = this.getCode(r2);
        if (t3 < 256) {
          if (o2 + 1 >= n2) {
            e2 = this.ensureBuffer(o2 + 1);
            n2 = e2.length;
          }
          e2[o2++] = t3;
          continue;
        }
        if (256 === t3) {
          this.bufferLength = o2;
          return;
        }
        t3 -= 257;
        t3 = qt[t3];
        let a3 = t3 >> 16;
        a3 > 0 && (a3 = this.getBits(a3));
        i2 = (65535 & t3) + a3;
        t3 = this.getCode(s2);
        t3 = Ot[t3];
        a3 = t3 >> 16;
        a3 > 0 && (a3 = this.getBits(a3));
        const g2 = (65535 & t3) + a3;
        if (o2 + i2 >= n2) {
          e2 = this.ensureBuffer(o2 + i2);
          n2 = e2.length;
        }
        for (let t4 = 0; t4 < i2; ++t4, ++o2) e2[o2] = e2[o2 - g2];
      }
    }
  }
  _FlateStream_instances = new WeakSet();
  m_fn = function(e2) {
    info(e2);
    this.eof = true;
  };
  const jt = [
    {
      qe: 22017,
      nmps: 1,
      nlps: 1,
      switchFlag: 1
    },
    {
      qe: 13313,
      nmps: 2,
      nlps: 6,
      switchFlag: 0
    },
    {
      qe: 6145,
      nmps: 3,
      nlps: 9,
      switchFlag: 0
    },
    {
      qe: 2753,
      nmps: 4,
      nlps: 12,
      switchFlag: 0
    },
    {
      qe: 1313,
      nmps: 5,
      nlps: 29,
      switchFlag: 0
    },
    {
      qe: 545,
      nmps: 38,
      nlps: 33,
      switchFlag: 0
    },
    {
      qe: 22017,
      nmps: 7,
      nlps: 6,
      switchFlag: 1
    },
    {
      qe: 21505,
      nmps: 8,
      nlps: 14,
      switchFlag: 0
    },
    {
      qe: 18433,
      nmps: 9,
      nlps: 14,
      switchFlag: 0
    },
    {
      qe: 14337,
      nmps: 10,
      nlps: 14,
      switchFlag: 0
    },
    {
      qe: 12289,
      nmps: 11,
      nlps: 17,
      switchFlag: 0
    },
    {
      qe: 9217,
      nmps: 12,
      nlps: 18,
      switchFlag: 0
    },
    {
      qe: 7169,
      nmps: 13,
      nlps: 20,
      switchFlag: 0
    },
    {
      qe: 5633,
      nmps: 29,
      nlps: 21,
      switchFlag: 0
    },
    {
      qe: 22017,
      nmps: 15,
      nlps: 14,
      switchFlag: 1
    },
    {
      qe: 21505,
      nmps: 16,
      nlps: 14,
      switchFlag: 0
    },
    {
      qe: 20737,
      nmps: 17,
      nlps: 15,
      switchFlag: 0
    },
    {
      qe: 18433,
      nmps: 18,
      nlps: 16,
      switchFlag: 0
    },
    {
      qe: 14337,
      nmps: 19,
      nlps: 17,
      switchFlag: 0
    },
    {
      qe: 13313,
      nmps: 20,
      nlps: 18,
      switchFlag: 0
    },
    {
      qe: 12289,
      nmps: 21,
      nlps: 19,
      switchFlag: 0
    },
    {
      qe: 10241,
      nmps: 22,
      nlps: 19,
      switchFlag: 0
    },
    {
      qe: 9217,
      nmps: 23,
      nlps: 20,
      switchFlag: 0
    },
    {
      qe: 8705,
      nmps: 24,
      nlps: 21,
      switchFlag: 0
    },
    {
      qe: 7169,
      nmps: 25,
      nlps: 22,
      switchFlag: 0
    },
    {
      qe: 6145,
      nmps: 26,
      nlps: 23,
      switchFlag: 0
    },
    {
      qe: 5633,
      nmps: 27,
      nlps: 24,
      switchFlag: 0
    },
    {
      qe: 5121,
      nmps: 28,
      nlps: 25,
      switchFlag: 0
    },
    {
      qe: 4609,
      nmps: 29,
      nlps: 26,
      switchFlag: 0
    },
    {
      qe: 4353,
      nmps: 30,
      nlps: 27,
      switchFlag: 0
    },
    {
      qe: 2753,
      nmps: 31,
      nlps: 28,
      switchFlag: 0
    },
    {
      qe: 2497,
      nmps: 32,
      nlps: 29,
      switchFlag: 0
    },
    {
      qe: 2209,
      nmps: 33,
      nlps: 30,
      switchFlag: 0
    },
    {
      qe: 1313,
      nmps: 34,
      nlps: 31,
      switchFlag: 0
    },
    {
      qe: 1089,
      nmps: 35,
      nlps: 32,
      switchFlag: 0
    },
    {
      qe: 673,
      nmps: 36,
      nlps: 33,
      switchFlag: 0
    },
    {
      qe: 545,
      nmps: 37,
      nlps: 34,
      switchFlag: 0
    },
    {
      qe: 321,
      nmps: 38,
      nlps: 35,
      switchFlag: 0
    },
    {
      qe: 273,
      nmps: 39,
      nlps: 36,
      switchFlag: 0
    },
    {
      qe: 133,
      nmps: 40,
      nlps: 37,
      switchFlag: 0
    },
    {
      qe: 73,
      nmps: 41,
      nlps: 38,
      switchFlag: 0
    },
    {
      qe: 37,
      nmps: 42,
      nlps: 39,
      switchFlag: 0
    },
    {
      qe: 21,
      nmps: 43,
      nlps: 40,
      switchFlag: 0
    },
    {
      qe: 9,
      nmps: 44,
      nlps: 41,
      switchFlag: 0
    },
    {
      qe: 5,
      nmps: 45,
      nlps: 42,
      switchFlag: 0
    },
    {
      qe: 1,
      nmps: 45,
      nlps: 43,
      switchFlag: 0
    },
    {
      qe: 22017,
      nmps: 46,
      nlps: 46,
      switchFlag: 0
    }
  ];
  class ArithmeticDecoder {
    constructor(e2, t2, i2) {
      this.data = e2;
      this.bp = t2;
      this.dataEnd = i2;
      this.chigh = e2[t2];
      this.clow = 0;
      this.byteIn();
      this.chigh = this.chigh << 7 & 65535 | this.clow >> 9 & 127;
      this.clow = this.clow << 7 & 65535;
      this.ct -= 7;
      this.a = 32768;
    }
    byteIn() {
      const e2 = this.data;
      let t2 = this.bp;
      if (255 === e2[t2]) if (e2[t2 + 1] > 143) {
        this.clow += 65280;
        this.ct = 8;
      } else {
        t2++;
        this.clow += e2[t2] << 9;
        this.ct = 7;
        this.bp = t2;
      }
      else {
        t2++;
        this.clow += t2 < this.dataEnd ? e2[t2] << 8 : 65280;
        this.ct = 8;
        this.bp = t2;
      }
      if (this.clow > 65535) {
        this.chigh += this.clow >> 16;
        this.clow &= 65535;
      }
    }
    readBit(e2, t2) {
      let i2 = e2[t2] >> 1, a2 = 1 & e2[t2];
      const r2 = jt[i2], s2 = r2.qe;
      let n2, o2 = this.a - s2;
      if (this.chigh < s2) if (o2 < s2) {
        o2 = s2;
        n2 = a2;
        i2 = r2.nmps;
      } else {
        o2 = s2;
        n2 = 1 ^ a2;
        1 === r2.switchFlag && (a2 = n2);
        i2 = r2.nlps;
      }
      else {
        this.chigh -= s2;
        if (0 != (32768 & o2)) {
          this.a = o2;
          return a2;
        }
        if (o2 < s2) {
          n2 = 1 ^ a2;
          1 === r2.switchFlag && (a2 = n2);
          i2 = r2.nlps;
        } else {
          n2 = a2;
          i2 = r2.nmps;
        }
      }
      do {
        0 === this.ct && this.byteIn();
        o2 <<= 1;
        this.chigh = this.chigh << 1 & 65535 | this.clow >> 15 & 1;
        this.clow = this.clow << 1 & 65535;
        this.ct--;
      } while (0 == (32768 & o2));
      this.a = o2;
      e2[t2] = i2 << 1 | a2;
      return n2;
    }
  }
  class Jbig2Error extends It {
    constructor(e2) {
      super(e2, "Jbig2Error");
    }
  }
  class ContextCache {
    getContexts(e2) {
      return e2 in this ? this[e2] : this[e2] = new Int8Array(65536);
    }
  }
  class DecodingContext {
    constructor(e2, t2, i2) {
      this.data = e2;
      this.start = t2;
      this.end = i2;
    }
    get decoder() {
      return shadow(this, "decoder", new ArithmeticDecoder(this.data, this.start, this.end));
    }
    get contextCache() {
      return shadow(this, "contextCache", new ContextCache());
    }
  }
  const Xt = 2 ** 31 - 1, Zt = -(2 ** 31);
  function decodeInteger(e2, t2, i2) {
    const a2 = e2.getContexts(t2);
    let r2 = 1;
    function readBits(e3) {
      let t3 = 0;
      for (let s3 = 0; s3 < e3; s3++) {
        const e4 = i2.readBit(a2, r2);
        r2 = r2 < 256 ? r2 << 1 | e4 : 511 & (r2 << 1 | e4) | 256;
        t3 = t3 << 1 | e4;
      }
      return t3 >>> 0;
    }
    const s2 = readBits(1), n2 = readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(1) ? readBits(32) + 4436 : readBits(12) + 340 : readBits(8) + 84 : readBits(6) + 20 : readBits(4) + 4 : readBits(2);
    let o2;
    0 === s2 ? o2 = n2 : n2 > 0 && (o2 = -n2);
    return o2 >= Zt && o2 <= Xt ? o2 : null;
  }
  function decodeIAID(e2, t2, i2) {
    const a2 = e2.getContexts("IAID");
    let r2 = 1;
    for (let e3 = 0; e3 < i2; e3++) {
      r2 = r2 << 1 | t2.readBit(a2, r2);
    }
    return i2 < 31 ? r2 & (1 << i2) - 1 : 2147483647 & r2;
  }
  const Vt = [
    "SymbolDictionary",
    null,
    null,
    null,
    "IntermediateTextRegion",
    null,
    "ImmediateTextRegion",
    "ImmediateLosslessTextRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "PatternDictionary",
    null,
    null,
    null,
    "IntermediateHalftoneRegion",
    null,
    "ImmediateHalftoneRegion",
    "ImmediateLosslessHalftoneRegion",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "IntermediateGenericRegion",
    null,
    "ImmediateGenericRegion",
    "ImmediateLosslessGenericRegion",
    "IntermediateGenericRefinementRegion",
    null,
    "ImmediateGenericRefinementRegion",
    "ImmediateLosslessGenericRefinementRegion",
    null,
    null,
    null,
    null,
    "PageInformation",
    "EndOfPage",
    "EndOfStripe",
    "EndOfFile",
    "Profiles",
    "Tables",
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "Extension"
  ], _t = [
    [
      {
        x: -1,
        y: -2
      },
      {
        x: 0,
        y: -2
      },
      {
        x: 1,
        y: -2
      },
      {
        x: -2,
        y: -1
      },
      {
        x: -1,
        y: -1
      },
      {
        x: 0,
        y: -1
      },
      {
        x: 1,
        y: -1
      },
      {
        x: 2,
        y: -1
      },
      {
        x: -4,
        y: 0
      },
      {
        x: -3,
        y: 0
      },
      {
        x: -2,
        y: 0
      },
      {
        x: -1,
        y: 0
      }
    ],
    [
      {
        x: -1,
        y: -2
      },
      {
        x: 0,
        y: -2
      },
      {
        x: 1,
        y: -2
      },
      {
        x: 2,
        y: -2
      },
      {
        x: -2,
        y: -1
      },
      {
        x: -1,
        y: -1
      },
      {
        x: 0,
        y: -1
      },
      {
        x: 1,
        y: -1
      },
      {
        x: 2,
        y: -1
      },
      {
        x: -3,
        y: 0
      },
      {
        x: -2,
        y: 0
      },
      {
        x: -1,
        y: 0
      }
    ],
    [
      {
        x: -1,
        y: -2
      },
      {
        x: 0,
        y: -2
      },
      {
        x: 1,
        y: -2
      },
      {
        x: -2,
        y: -1
      },
      {
        x: -1,
        y: -1
      },
      {
        x: 0,
        y: -1
      },
      {
        x: 1,
        y: -1
      },
      {
        x: -2,
        y: 0
      },
      {
        x: -1,
        y: 0
      }
    ],
    [
      {
        x: -3,
        y: -1
      },
      {
        x: -2,
        y: -1
      },
      {
        x: -1,
        y: -1
      },
      {
        x: 0,
        y: -1
      },
      {
        x: 1,
        y: -1
      },
      {
        x: -4,
        y: 0
      },
      {
        x: -3,
        y: 0
      },
      {
        x: -2,
        y: 0
      },
      {
        x: -1,
        y: 0
      }
    ]
  ], zt = [
    {
      coding: [
        {
          x: 0,
          y: -1
        },
        {
          x: 1,
          y: -1
        },
        {
          x: -1,
          y: 0
        }
      ],
      reference: [
        {
          x: 0,
          y: -1
        },
        {
          x: 1,
          y: -1
        },
        {
          x: -1,
          y: 0
        },
        {
          x: 0,
          y: 0
        },
        {
          x: 1,
          y: 0
        },
        {
          x: -1,
          y: 1
        },
        {
          x: 0,
          y: 1
        },
        {
          x: 1,
          y: 1
        }
      ]
    },
    {
      coding: [
        {
          x: -1,
          y: -1
        },
        {
          x: 0,
          y: -1
        },
        {
          x: 1,
          y: -1
        },
        {
          x: -1,
          y: 0
        }
      ],
      reference: [
        {
          x: 0,
          y: -1
        },
        {
          x: -1,
          y: 0
        },
        {
          x: 0,
          y: 0
        },
        {
          x: 1,
          y: 0
        },
        {
          x: 0,
          y: 1
        },
        {
          x: 1,
          y: 1
        }
      ]
    }
  ], $t = [
    39717,
    1941,
    229,
    405
  ], Ai = [
    32,
    8
  ];
  function decodeBitmap(e2, t2, i2, a2, r2, s2, n2, o2) {
    if (e2) {
      return decodeMMRBitmap(new Reader(o2.data, o2.start, o2.end), t2, i2, false);
    }
    if (0 === a2 && !s2 && !r2 && 4 === n2.length && 3 === n2[0].x && -1 === n2[0].y && -3 === n2[1].x && -1 === n2[1].y && 2 === n2[2].x && -2 === n2[2].y && -2 === n2[3].x && -2 === n2[3].y) return function decodeBitmapTemplate0(e3, t3, i3) {
      const a3 = i3.decoder, r3 = i3.contextCache.getContexts("GB"), s3 = [];
      let n3, o3, g2, c3, C3, h3, l3;
      for (o3 = 0; o3 < t3; o3++) {
        C3 = s3[o3] = new Uint8Array(e3);
        h3 = o3 < 1 ? C3 : s3[o3 - 1];
        l3 = o3 < 2 ? C3 : s3[o3 - 2];
        n3 = l3[0] << 13 | l3[1] << 12 | l3[2] << 11 | h3[0] << 7 | h3[1] << 6 | h3[2] << 5 | h3[3] << 4;
        for (g2 = 0; g2 < e3; g2++) {
          C3[g2] = c3 = a3.readBit(r3, n3);
          n3 = (31735 & n3) << 1 | (g2 + 3 < e3 ? l3[g2 + 3] << 11 : 0) | (g2 + 4 < e3 ? h3[g2 + 4] << 4 : 0) | c3;
        }
      }
      return s3;
    }(t2, i2, o2);
    const c2 = _t[a2].concat(n2);
    c2.sort(function(e3, t3) {
      return e3.y - t3.y || e3.x - t3.x;
    });
    const C2 = c2.length, h2 = new Int8Array(C2), l2 = new Int8Array(C2), Q2 = [];
    let E2, u2, d2 = 0, f2 = 0, p2 = 0, m2 = 0;
    for (u2 = 0; u2 < C2; u2++) {
      h2[u2] = c2[u2].x;
      l2[u2] = c2[u2].y;
      f2 = Math.min(f2, c2[u2].x);
      p2 = Math.max(p2, c2[u2].x);
      m2 = Math.min(m2, c2[u2].y);
      u2 < C2 - 1 && c2[u2].y === c2[u2 + 1].y && c2[u2].x === c2[u2 + 1].x - 1 ? d2 |= 1 << C2 - 1 - u2 : Q2.push(u2);
    }
    const y2 = Q2.length, w2 = new Int8Array(y2), b2 = new Int8Array(y2), D2 = new Uint16Array(y2);
    for (E2 = 0; E2 < y2; E2++) {
      u2 = Q2[E2];
      w2[E2] = c2[u2].x;
      b2[E2] = c2[u2].y;
      D2[E2] = 1 << C2 - 1 - u2;
    }
    const S2 = -f2, k2 = -m2, R2 = t2 - p2, N2 = $t[a2];
    let G2 = new Uint8Array(t2);
    const x2 = [], U2 = o2.decoder, M2 = o2.contextCache.getContexts("GB");
    let L2, H2, J2, v2, Y2, T2 = 0, K2 = 0;
    for (let e3 = 0; e3 < i2; e3++) {
      if (r2) {
        T2 ^= U2.readBit(M2, N2);
        if (T2) {
          x2.push(G2);
          continue;
        }
      }
      G2 = new Uint8Array(G2);
      x2.push(G2);
      for (L2 = 0; L2 < t2; L2++) {
        if (L2 >= S2 && L2 < R2 && e3 >= k2) {
          K2 = K2 << 1 & d2;
          for (u2 = 0; u2 < y2; u2++) {
            H2 = e3 + b2[u2];
            J2 = L2 + w2[u2];
            v2 = x2[H2][J2];
            if (v2) {
              v2 = D2[u2];
              K2 |= v2;
            }
          }
        } else {
          K2 = 0;
          Y2 = C2 - 1;
          for (u2 = 0; u2 < C2; u2++, Y2--) {
            J2 = L2 + h2[u2];
            if (J2 >= 0 && J2 < t2) {
              H2 = e3 + l2[u2];
              if (H2 >= 0) {
                v2 = x2[H2][J2];
                v2 && (K2 |= v2 << Y2);
              }
            }
          }
        }
        const i3 = U2.readBit(M2, K2);
        G2[L2] = i3;
      }
    }
    return x2;
  }
  function decodeRefinement(e2, t2, i2, a2, r2, s2, n2, o2, g2) {
    let c2 = zt[i2].coding;
    0 === i2 && (c2 = c2.concat([
      o2[0]
    ]));
    const C2 = c2.length, h2 = new Int32Array(C2), l2 = new Int32Array(C2);
    let Q2;
    for (Q2 = 0; Q2 < C2; Q2++) {
      h2[Q2] = c2[Q2].x;
      l2[Q2] = c2[Q2].y;
    }
    let E2 = zt[i2].reference;
    0 === i2 && (E2 = E2.concat([
      o2[1]
    ]));
    const u2 = E2.length, d2 = new Int32Array(u2), f2 = new Int32Array(u2);
    for (Q2 = 0; Q2 < u2; Q2++) {
      d2[Q2] = E2[Q2].x;
      f2[Q2] = E2[Q2].y;
    }
    const p2 = a2[0].length, m2 = a2.length;
    Ai[i2];
    const w2 = [], b2 = g2.decoder, D2 = g2.contextCache.getContexts("GR");
    for (let i3 = 0; i3 < t2; i3++) {
      const t3 = new Uint8Array(e2);
      w2.push(t3);
      for (let n3 = 0; n3 < e2; n3++) {
        let o3, g3, c3 = 0;
        for (Q2 = 0; Q2 < C2; Q2++) {
          o3 = i3 + l2[Q2];
          g3 = n3 + h2[Q2];
          o3 < 0 || g3 < 0 || g3 >= e2 ? c3 <<= 1 : c3 = c3 << 1 | w2[o3][g3];
        }
        for (Q2 = 0; Q2 < u2; Q2++) {
          o3 = i3 + f2[Q2] - s2;
          g3 = n3 + d2[Q2] - r2;
          o3 < 0 || o3 >= m2 || g3 < 0 || g3 >= p2 ? c3 <<= 1 : c3 = c3 << 1 | a2[o3][g3];
        }
        const E3 = b2.readBit(D2, c3);
        t3[n3] = E3;
      }
    }
    return w2;
  }
  function decodeTextRegion(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2, C2, h2, l2, Q2, E2, u2, d2, f2, p2) {
    if (e2 && t2) throw new Jbig2Error("refinement with Huffman is not supported");
    const m2 = [];
    let y2, w2;
    for (y2 = 0; y2 < a2; y2++) {
      w2 = new Uint8Array(i2);
      if (r2) for (let e3 = 0; e3 < i2; e3++) w2[e3] = r2;
      m2.push(w2);
    }
    const b2 = d2.decoder, D2 = d2.contextCache;
    let S2 = e2 ? -Q2.tableDeltaT.decode(p2) : -decodeInteger(D2, "IADT", b2), k2 = 0;
    y2 = 0;
    for (; y2 < s2; ) {
      S2 += e2 ? Q2.tableDeltaT.decode(p2) : decodeInteger(D2, "IADT", b2);
      k2 += e2 ? Q2.tableFirstS.decode(p2) : decodeInteger(D2, "IAFS", b2);
      let a3 = k2;
      for (; ; ) {
        let r3 = 0;
        n2 > 1 && (r3 = e2 ? p2.readBits(f2) : decodeInteger(D2, "IAIT", b2));
        const s3 = n2 * S2 + r3, k3 = e2 ? Q2.symbolIDTable.decode(p2) : decodeIAID(D2, b2, g2), R2 = t2 && (e2 ? p2.readBit() : decodeInteger(D2, "IARI", b2));
        let N2 = o2[k3], G2 = N2[0].length, x2 = N2.length;
        if (R2) {
          const e3 = decodeInteger(D2, "IARDW", b2), t3 = decodeInteger(D2, "IARDH", b2);
          G2 += e3;
          x2 += t3;
          N2 = decodeRefinement(G2, x2, E2, N2, (e3 >> 1) + decodeInteger(D2, "IARDX", b2), (t3 >> 1) + decodeInteger(D2, "IARDY", b2), false, u2, d2);
        }
        let U2 = 0;
        c2 ? 1 & h2 ? U2 = x2 - 1 : a3 += x2 - 1 : h2 > 1 ? a3 += G2 - 1 : U2 = G2 - 1;
        const M2 = s3 - (1 & h2 ? 0 : x2 - 1), L2 = a3 - (2 & h2 ? G2 - 1 : 0);
        let H2, J2, v2;
        if (c2) for (H2 = 0; H2 < x2; H2++) {
          w2 = m2[L2 + H2];
          if (!w2) continue;
          v2 = N2[H2];
          const e3 = Math.min(i2 - M2, G2);
          switch (l2) {
            case 0:
              for (J2 = 0; J2 < e3; J2++) w2[M2 + J2] |= v2[J2];
              break;
            case 2:
              for (J2 = 0; J2 < e3; J2++) w2[M2 + J2] ^= v2[J2];
              break;
            default:
              throw new Jbig2Error(`operator ${l2} is not supported`);
          }
        }
        else for (J2 = 0; J2 < x2; J2++) {
          w2 = m2[M2 + J2];
          if (w2) {
            v2 = N2[J2];
            switch (l2) {
              case 0:
                for (H2 = 0; H2 < G2; H2++) w2[L2 + H2] |= v2[H2];
                break;
              case 2:
                for (H2 = 0; H2 < G2; H2++) w2[L2 + H2] ^= v2[H2];
                break;
              default:
                throw new Jbig2Error(`operator ${l2} is not supported`);
            }
          }
        }
        y2++;
        const Y2 = e2 ? Q2.tableDeltaS.decode(p2) : decodeInteger(D2, "IADS", b2);
        if (null === Y2) break;
        a3 += U2 + Y2 + C2;
      }
    }
    return m2;
  }
  function readSegmentHeader(e2, t2) {
    const i2 = {};
    i2.number = readUint32(e2, t2);
    const a2 = e2[t2 + 4], r2 = 63 & a2;
    if (!Vt[r2]) throw new Jbig2Error("invalid segment type: " + r2);
    i2.type = r2;
    i2.typeName = Vt[r2];
    i2.deferredNonRetain = !!(128 & a2);
    const s2 = !!(64 & a2), n2 = e2[t2 + 5];
    let o2 = n2 >> 5 & 7;
    const g2 = [
      31 & n2
    ];
    let c2 = t2 + 6;
    if (7 === n2) {
      o2 = 536870911 & readUint32(e2, c2 - 1);
      c2 += 3;
      let t3 = o2 + 7 >> 3;
      g2[0] = e2[c2++];
      for (; --t3 > 0; ) g2.push(e2[c2++]);
    } else if (5 === n2 || 6 === n2) throw new Jbig2Error("invalid referred-to flags");
    i2.retainBits = g2;
    let C2 = 4;
    i2.number <= 256 ? C2 = 1 : i2.number <= 65536 && (C2 = 2);
    const h2 = [];
    let l2, Q2;
    for (l2 = 0; l2 < o2; l2++) {
      let t3;
      t3 = 1 === C2 ? e2[c2] : 2 === C2 ? readUint16(e2, c2) : readUint32(e2, c2);
      h2.push(t3);
      c2 += C2;
    }
    i2.referredTo = h2;
    if (s2) {
      i2.pageAssociation = readUint32(e2, c2);
      c2 += 4;
    } else i2.pageAssociation = e2[c2++];
    i2.length = readUint32(e2, c2);
    c2 += 4;
    if (4294967295 === i2.length) {
      if (38 !== r2) throw new Jbig2Error("invalid unknown segment length");
      {
        const t3 = readRegionSegmentInformation(e2, c2), a3 = !!(1 & e2[c2 + ei]), r3 = 6, s3 = new Uint8Array(r3);
        if (!a3) {
          s3[0] = 255;
          s3[1] = 172;
        }
        s3[2] = t3.height >>> 24 & 255;
        s3[3] = t3.height >> 16 & 255;
        s3[4] = t3.height >> 8 & 255;
        s3[5] = 255 & t3.height;
        for (l2 = c2, Q2 = e2.length; l2 < Q2; l2++) {
          let t4 = 0;
          for (; t4 < r3 && s3[t4] === e2[l2 + t4]; ) t4++;
          if (t4 === r3) {
            i2.length = l2 + r3;
            break;
          }
        }
        if (4294967295 === i2.length) throw new Jbig2Error("segment end was not found");
      }
    }
    i2.headerEnd = c2;
    return i2;
  }
  function readSegments(e2, t2, i2, a2) {
    const r2 = [];
    let s2 = i2;
    for (; s2 < a2; ) {
      const i3 = readSegmentHeader(t2, s2);
      s2 = i3.headerEnd;
      const a3 = {
        header: i3,
        data: t2
      };
      if (!e2.randomAccess) {
        a3.start = s2;
        s2 += i3.length;
        a3.end = s2;
      }
      r2.push(a3);
      if (51 === i3.type) break;
    }
    if (e2.randomAccess) for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
      r2[e3].start = s2;
      s2 += r2[e3].header.length;
      r2[e3].end = s2;
    }
    return r2;
  }
  function readRegionSegmentInformation(e2, t2) {
    return {
      width: readUint32(e2, t2),
      height: readUint32(e2, t2 + 4),
      x: readUint32(e2, t2 + 8),
      y: readUint32(e2, t2 + 12),
      combinationOperator: 7 & e2[t2 + 16]
    };
  }
  const ei = 17;
  function processSegment(e2, t2) {
    const i2 = e2.header, a2 = e2.data, r2 = e2.end;
    let s2, n2, o2, g2, c2 = e2.start;
    switch (i2.type) {
      case 0:
        const e3 = {}, t3 = readUint16(a2, c2);
        e3.huffman = !!(1 & t3);
        e3.refinement = !!(2 & t3);
        e3.huffmanDHSelector = t3 >> 2 & 3;
        e3.huffmanDWSelector = t3 >> 4 & 3;
        e3.bitmapSizeSelector = t3 >> 6 & 1;
        e3.aggregationInstancesSelector = t3 >> 7 & 1;
        e3.bitmapCodingContextUsed = !!(256 & t3);
        e3.bitmapCodingContextRetained = !!(512 & t3);
        e3.template = t3 >> 10 & 3;
        e3.refinementTemplate = t3 >> 12 & 1;
        c2 += 2;
        if (!e3.huffman) {
          g2 = 0 === e3.template ? 4 : 1;
          n2 = [];
          for (o2 = 0; o2 < g2; o2++) {
            n2.push({
              x: readInt8(a2, c2),
              y: readInt8(a2, c2 + 1)
            });
            c2 += 2;
          }
          e3.at = n2;
        }
        if (e3.refinement && !e3.refinementTemplate) {
          n2 = [];
          for (o2 = 0; o2 < 2; o2++) {
            n2.push({
              x: readInt8(a2, c2),
              y: readInt8(a2, c2 + 1)
            });
            c2 += 2;
          }
          e3.refinementAt = n2;
        }
        e3.numberOfExportedSymbols = readUint32(a2, c2);
        c2 += 4;
        e3.numberOfNewSymbols = readUint32(a2, c2);
        c2 += 4;
        s2 = [
          e3,
          i2.number,
          i2.referredTo,
          a2,
          c2,
          r2
        ];
        break;
      case 6:
      case 7:
        const C3 = {};
        C3.info = readRegionSegmentInformation(a2, c2);
        c2 += ei;
        const h2 = readUint16(a2, c2);
        c2 += 2;
        C3.huffman = !!(1 & h2);
        C3.refinement = !!(2 & h2);
        C3.logStripSize = h2 >> 2 & 3;
        C3.stripSize = 1 << C3.logStripSize;
        C3.referenceCorner = h2 >> 4 & 3;
        C3.transposed = !!(64 & h2);
        C3.combinationOperator = h2 >> 7 & 3;
        C3.defaultPixelValue = h2 >> 9 & 1;
        C3.dsOffset = h2 << 17 >> 27;
        C3.refinementTemplate = h2 >> 15 & 1;
        if (C3.huffman) {
          const e4 = readUint16(a2, c2);
          c2 += 2;
          C3.huffmanFS = 3 & e4;
          C3.huffmanDS = e4 >> 2 & 3;
          C3.huffmanDT = e4 >> 4 & 3;
          C3.huffmanRefinementDW = e4 >> 6 & 3;
          C3.huffmanRefinementDH = e4 >> 8 & 3;
          C3.huffmanRefinementDX = e4 >> 10 & 3;
          C3.huffmanRefinementDY = e4 >> 12 & 3;
          C3.huffmanRefinementSizeSelector = !!(16384 & e4);
        }
        if (C3.refinement && !C3.refinementTemplate) {
          n2 = [];
          for (o2 = 0; o2 < 2; o2++) {
            n2.push({
              x: readInt8(a2, c2),
              y: readInt8(a2, c2 + 1)
            });
            c2 += 2;
          }
          C3.refinementAt = n2;
        }
        C3.numberOfSymbolInstances = readUint32(a2, c2);
        c2 += 4;
        s2 = [
          C3,
          i2.referredTo,
          a2,
          c2,
          r2
        ];
        break;
      case 16:
        const l2 = {}, Q2 = a2[c2++];
        l2.mmr = !!(1 & Q2);
        l2.template = Q2 >> 1 & 3;
        l2.patternWidth = a2[c2++];
        l2.patternHeight = a2[c2++];
        l2.maxPatternIndex = readUint32(a2, c2);
        c2 += 4;
        s2 = [
          l2,
          i2.number,
          a2,
          c2,
          r2
        ];
        break;
      case 22:
      case 23:
        const E2 = {};
        E2.info = readRegionSegmentInformation(a2, c2);
        c2 += ei;
        const u2 = a2[c2++];
        E2.mmr = !!(1 & u2);
        E2.template = u2 >> 1 & 3;
        E2.enableSkip = !!(8 & u2);
        E2.combinationOperator = u2 >> 4 & 7;
        E2.defaultPixelValue = u2 >> 7 & 1;
        E2.gridWidth = readUint32(a2, c2);
        c2 += 4;
        E2.gridHeight = readUint32(a2, c2);
        c2 += 4;
        E2.gridOffsetX = 4294967295 & readUint32(a2, c2);
        c2 += 4;
        E2.gridOffsetY = 4294967295 & readUint32(a2, c2);
        c2 += 4;
        E2.gridVectorX = readUint16(a2, c2);
        c2 += 2;
        E2.gridVectorY = readUint16(a2, c2);
        c2 += 2;
        s2 = [
          E2,
          i2.referredTo,
          a2,
          c2,
          r2
        ];
        break;
      case 38:
      case 39:
        const d2 = {};
        d2.info = readRegionSegmentInformation(a2, c2);
        c2 += ei;
        const f2 = a2[c2++];
        d2.mmr = !!(1 & f2);
        d2.template = f2 >> 1 & 3;
        d2.prediction = !!(8 & f2);
        if (!d2.mmr) {
          g2 = 0 === d2.template ? 4 : 1;
          n2 = [];
          for (o2 = 0; o2 < g2; o2++) {
            n2.push({
              x: readInt8(a2, c2),
              y: readInt8(a2, c2 + 1)
            });
            c2 += 2;
          }
          d2.at = n2;
        }
        s2 = [
          d2,
          a2,
          c2,
          r2
        ];
        break;
      case 48:
        const p2 = {
          width: readUint32(a2, c2),
          height: readUint32(a2, c2 + 4),
          resolutionX: readUint32(a2, c2 + 8),
          resolutionY: readUint32(a2, c2 + 12)
        };
        4294967295 === p2.height && delete p2.height;
        const m2 = a2[c2 + 16];
        readUint16(a2, c2 + 17);
        p2.lossless = !!(1 & m2);
        p2.refinement = !!(2 & m2);
        p2.defaultPixelValue = m2 >> 2 & 1;
        p2.combinationOperator = m2 >> 3 & 3;
        p2.requiresBuffer = !!(32 & m2);
        p2.combinationOperatorOverride = !!(64 & m2);
        s2 = [
          p2
        ];
        break;
      case 49:
      case 50:
      case 51:
      case 62:
        break;
      case 53:
        s2 = [
          i2.number,
          a2,
          c2,
          r2
        ];
        break;
      default:
        throw new Jbig2Error(`segment type ${i2.typeName}(${i2.type}) is not implemented`);
    }
    const C2 = "on" + i2.typeName;
    C2 in t2 && t2[C2].apply(t2, s2);
  }
  function processSegments(e2, t2) {
    for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) processSegment(e2[i2], t2);
  }
  class SimpleSegmentVisitor {
    onPageInformation(e2) {
      this.currentPageInfo = e2;
      const t2 = e2.width + 7 >> 3, i2 = new Uint8ClampedArray(t2 * e2.height);
      e2.defaultPixelValue && i2.fill(255);
      this.buffer = i2;
    }
    drawBitmap(e2, t2) {
      const i2 = this.currentPageInfo, a2 = e2.width, r2 = e2.height, s2 = i2.width + 7 >> 3, n2 = i2.combinationOperatorOverride ? e2.combinationOperator : i2.combinationOperator, o2 = this.buffer, g2 = 128 >> (7 & e2.x);
      let c2, C2, h2, l2, Q2 = e2.y * s2 + (e2.x >> 3);
      switch (n2) {
        case 0:
          for (c2 = 0; c2 < r2; c2++) {
            h2 = g2;
            l2 = Q2;
            for (C2 = 0; C2 < a2; C2++) {
              t2[c2][C2] && (o2[l2] |= h2);
              h2 >>= 1;
              if (!h2) {
                h2 = 128;
                l2++;
              }
            }
            Q2 += s2;
          }
          break;
        case 2:
          for (c2 = 0; c2 < r2; c2++) {
            h2 = g2;
            l2 = Q2;
            for (C2 = 0; C2 < a2; C2++) {
              t2[c2][C2] && (o2[l2] ^= h2);
              h2 >>= 1;
              if (!h2) {
                h2 = 128;
                l2++;
              }
            }
            Q2 += s2;
          }
          break;
        default:
          throw new Jbig2Error(`operator ${n2} is not supported`);
      }
    }
    onImmediateGenericRegion(e2, t2, i2, a2) {
      const r2 = e2.info, s2 = new DecodingContext(t2, i2, a2), n2 = decodeBitmap(e2.mmr, r2.width, r2.height, e2.template, e2.prediction, null, e2.at, s2);
      this.drawBitmap(r2, n2);
    }
    onImmediateLosslessGenericRegion() {
      this.onImmediateGenericRegion(...arguments);
    }
    onSymbolDictionary(e2, t2, i2, a2, r2, s2) {
      let n2, o2;
      if (e2.huffman) {
        n2 = function getSymbolDictionaryHuffmanTables(e3, t3, i3) {
          let a3, r3, s3, n3, o3 = 0;
          switch (e3.huffmanDHSelector) {
            case 0:
            case 1:
              a3 = getStandardTable(e3.huffmanDHSelector + 4);
              break;
            case 3:
              a3 = getCustomHuffmanTable(o3, t3, i3);
              o3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DH selector");
          }
          switch (e3.huffmanDWSelector) {
            case 0:
            case 1:
              r3 = getStandardTable(e3.huffmanDWSelector + 2);
              break;
            case 3:
              r3 = getCustomHuffmanTable(o3, t3, i3);
              o3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DW selector");
          }
          if (e3.bitmapSizeSelector) {
            s3 = getCustomHuffmanTable(o3, t3, i3);
            o3++;
          } else s3 = getStandardTable(1);
          n3 = e3.aggregationInstancesSelector ? getCustomHuffmanTable(o3, t3, i3) : getStandardTable(1);
          return {
            tableDeltaHeight: a3,
            tableDeltaWidth: r3,
            tableBitmapSize: s3,
            tableAggregateInstances: n3
          };
        }(e2, i2, this.customTables);
        o2 = new Reader(a2, r2, s2);
      }
      let g2 = this.symbols;
      g2 || (this.symbols = g2 = {});
      const c2 = [];
      for (const e3 of i2) {
        const t3 = g2[e3];
        t3 && c2.push(...t3);
      }
      const C2 = new DecodingContext(a2, r2, s2);
      g2[t2] = function decodeSymbolDictionary(e3, t3, i3, a3, r3, s3, n3, o3, g3, c3, C3, h2) {
        if (e3 && t3) throw new Jbig2Error("symbol refinement with Huffman is not supported");
        const l2 = [];
        let Q2 = 0, E2 = log2(i3.length + a3);
        const u2 = C3.decoder, d2 = C3.contextCache;
        let f2, p2;
        if (e3) {
          f2 = getStandardTable(1);
          p2 = [];
          E2 = Math.max(E2, 1);
        }
        for (; l2.length < a3; ) {
          Q2 += e3 ? s3.tableDeltaHeight.decode(h2) : decodeInteger(d2, "IADH", u2);
          let a4 = 0, r4 = 0;
          const f3 = e3 ? p2.length : 0;
          for (; ; ) {
            const f4 = e3 ? s3.tableDeltaWidth.decode(h2) : decodeInteger(d2, "IADW", u2);
            if (null === f4) break;
            a4 += f4;
            r4 += a4;
            let m3;
            if (t3) {
              const r5 = decodeInteger(d2, "IAAI", u2);
              if (r5 > 1) m3 = decodeTextRegion(e3, t3, a4, Q2, 0, r5, 1, i3.concat(l2), E2, 0, 0, 1, 0, s3, g3, c3, C3, 0, h2);
              else {
                const e4 = decodeIAID(d2, u2, E2), t4 = decodeInteger(d2, "IARDX", u2), r6 = decodeInteger(d2, "IARDY", u2);
                m3 = decodeRefinement(a4, Q2, g3, e4 < i3.length ? i3[e4] : l2[e4 - i3.length], t4, r6, false, c3, C3);
              }
              l2.push(m3);
            } else if (e3) p2.push(a4);
            else {
              m3 = decodeBitmap(false, a4, Q2, n3, false, null, o3, C3);
              l2.push(m3);
            }
          }
          if (e3 && !t3) {
            const e4 = s3.tableBitmapSize.decode(h2);
            h2.byteAlign();
            let t4;
            if (0 === e4) t4 = readUncompressedBitmap(h2, r4, Q2);
            else {
              const i5 = h2.end, a5 = h2.position + e4;
              h2.end = a5;
              t4 = decodeMMRBitmap(h2, r4, Q2, false);
              h2.end = i5;
              h2.position = a5;
            }
            const i4 = p2.length;
            if (f3 === i4 - 1) l2.push(t4);
            else {
              let e5, a5, r5, s4, n4, o4 = 0;
              for (e5 = f3; e5 < i4; e5++) {
                s4 = p2[e5];
                r5 = o4 + s4;
                n4 = [];
                for (a5 = 0; a5 < Q2; a5++) n4.push(t4[a5].subarray(o4, r5));
                l2.push(n4);
                o4 = r5;
              }
            }
          }
        }
        const m2 = [], y2 = [];
        let w2, b2, D2 = false;
        const S2 = i3.length + a3;
        for (; y2.length < S2; ) {
          let t4 = e3 ? f2.decode(h2) : decodeInteger(d2, "IAEX", u2);
          for (; t4--; ) y2.push(D2);
          D2 = !D2;
        }
        for (w2 = 0, b2 = i3.length; w2 < b2; w2++) y2[w2] && m2.push(i3[w2]);
        for (let e4 = 0; e4 < a3; w2++, e4++) y2[w2] && m2.push(l2[e4]);
        return m2;
      }(e2.huffman, e2.refinement, c2, e2.numberOfNewSymbols, e2.numberOfExportedSymbols, n2, e2.template, e2.at, e2.refinementTemplate, e2.refinementAt, C2, o2);
    }
    onImmediateTextRegion(e2, t2, i2, a2, r2) {
      const s2 = e2.info;
      let n2, o2;
      const g2 = this.symbols, c2 = [];
      for (const e3 of t2) {
        const t3 = g2[e3];
        t3 && c2.push(...t3);
      }
      const C2 = log2(c2.length);
      if (e2.huffman) {
        o2 = new Reader(i2, a2, r2);
        n2 = function getTextRegionHuffmanTables(e3, t3, i3, a3, r3) {
          const s3 = [];
          for (let e4 = 0; e4 <= 34; e4++) {
            const t4 = r3.readBits(4);
            s3.push(new HuffmanLine([
              e4,
              t4,
              0,
              0
            ]));
          }
          const n3 = new HuffmanTable(s3, false);
          s3.length = 0;
          for (let e4 = 0; e4 < a3; ) {
            const t4 = n3.decode(r3);
            if (t4 >= 32) {
              let i4, a4, n4;
              switch (t4) {
                case 32:
                  if (0 === e4) throw new Jbig2Error("no previous value in symbol ID table");
                  a4 = r3.readBits(2) + 3;
                  i4 = s3[e4 - 1].prefixLength;
                  break;
                case 33:
                  a4 = r3.readBits(3) + 3;
                  i4 = 0;
                  break;
                case 34:
                  a4 = r3.readBits(7) + 11;
                  i4 = 0;
                  break;
                default:
                  throw new Jbig2Error("invalid code length in symbol ID table");
              }
              for (n4 = 0; n4 < a4; n4++) {
                s3.push(new HuffmanLine([
                  e4,
                  i4,
                  0,
                  0
                ]));
                e4++;
              }
            } else {
              s3.push(new HuffmanLine([
                e4,
                t4,
                0,
                0
              ]));
              e4++;
            }
          }
          r3.byteAlign();
          const o3 = new HuffmanTable(s3, false);
          let g3, c3, C3, h3 = 0;
          switch (e3.huffmanFS) {
            case 0:
            case 1:
              g3 = getStandardTable(e3.huffmanFS + 6);
              break;
            case 3:
              g3 = getCustomHuffmanTable(h3, t3, i3);
              h3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman FS selector");
          }
          switch (e3.huffmanDS) {
            case 0:
            case 1:
            case 2:
              c3 = getStandardTable(e3.huffmanDS + 8);
              break;
            case 3:
              c3 = getCustomHuffmanTable(h3, t3, i3);
              h3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DS selector");
          }
          switch (e3.huffmanDT) {
            case 0:
            case 1:
            case 2:
              C3 = getStandardTable(e3.huffmanDT + 11);
              break;
            case 3:
              C3 = getCustomHuffmanTable(h3, t3, i3);
              h3++;
              break;
            default:
              throw new Jbig2Error("invalid Huffman DT selector");
          }
          if (e3.refinement) throw new Jbig2Error("refinement with Huffman is not supported");
          return {
            symbolIDTable: o3,
            tableFirstS: g3,
            tableDeltaS: c3,
            tableDeltaT: C3
          };
        }(e2, t2, this.customTables, c2.length, o2);
      }
      const h2 = new DecodingContext(i2, a2, r2), l2 = decodeTextRegion(e2.huffman, e2.refinement, s2.width, s2.height, e2.defaultPixelValue, e2.numberOfSymbolInstances, e2.stripSize, c2, C2, e2.transposed, e2.dsOffset, e2.referenceCorner, e2.combinationOperator, n2, e2.refinementTemplate, e2.refinementAt, h2, e2.logStripSize, o2);
      this.drawBitmap(s2, l2);
    }
    onImmediateLosslessTextRegion() {
      this.onImmediateTextRegion(...arguments);
    }
    onPatternDictionary(e2, t2, i2, a2, r2) {
      let s2 = this.patterns;
      s2 || (this.patterns = s2 = {});
      const n2 = new DecodingContext(i2, a2, r2);
      s2[t2] = function decodePatternDictionary(e3, t3, i3, a3, r3, s3) {
        const n3 = [];
        if (!e3) {
          n3.push({
            x: -t3,
            y: 0
          });
          0 === r3 && n3.push({
            x: -3,
            y: -1
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -2
          });
        }
        const o2 = decodeBitmap(e3, (a3 + 1) * t3, i3, r3, false, null, n3, s3), g2 = [];
        for (let e4 = 0; e4 <= a3; e4++) {
          const a4 = [], r4 = t3 * e4, s4 = r4 + t3;
          for (let e5 = 0; e5 < i3; e5++) a4.push(o2[e5].subarray(r4, s4));
          g2.push(a4);
        }
        return g2;
      }(e2.mmr, e2.patternWidth, e2.patternHeight, e2.maxPatternIndex, e2.template, n2);
    }
    onImmediateHalftoneRegion(e2, t2, i2, a2, r2) {
      const s2 = this.patterns[t2[0]], n2 = e2.info, o2 = new DecodingContext(i2, a2, r2), g2 = function decodeHalftoneRegion(e3, t3, i3, a3, r3, s3, n3, o3, g3, c2, C2, h2, l2, Q2, E2) {
        if (n3) throw new Jbig2Error("skip is not supported");
        if (0 !== o3) throw new Jbig2Error(`operator "${o3}" is not supported in halftone region`);
        const u2 = [];
        let d2, f2, p2;
        for (d2 = 0; d2 < r3; d2++) {
          p2 = new Uint8Array(a3);
          if (s3) for (f2 = 0; f2 < a3; f2++) p2[f2] = s3;
          u2.push(p2);
        }
        const m2 = t3.length, y2 = t3[0], w2 = y2[0].length, b2 = y2.length, D2 = log2(m2), S2 = [];
        if (!e3) {
          S2.push({
            x: i3 <= 1 ? 3 : 2,
            y: -1
          });
          0 === i3 && S2.push({
            x: -3,
            y: -1
          }, {
            x: 2,
            y: -2
          }, {
            x: -2,
            y: -2
          });
        }
        const k2 = [];
        let R2, N2, G2, x2, U2, M2, L2, H2, J2, v2, Y2;
        e3 && (R2 = new Reader(E2.data, E2.start, E2.end));
        for (d2 = D2 - 1; d2 >= 0; d2--) {
          N2 = e3 ? decodeMMRBitmap(R2, g3, c2, true) : decodeBitmap(false, g3, c2, i3, false, null, S2, E2);
          k2[d2] = N2;
        }
        for (G2 = 0; G2 < c2; G2++) for (x2 = 0; x2 < g3; x2++) {
          U2 = 0;
          M2 = 0;
          for (f2 = D2 - 1; f2 >= 0; f2--) {
            U2 ^= k2[f2][G2][x2];
            M2 |= U2 << f2;
          }
          L2 = t3[M2];
          H2 = C2 + G2 * Q2 + x2 * l2 >> 8;
          J2 = h2 + G2 * l2 - x2 * Q2 >> 8;
          if (H2 >= 0 && H2 + w2 <= a3 && J2 >= 0 && J2 + b2 <= r3) for (d2 = 0; d2 < b2; d2++) {
            Y2 = u2[J2 + d2];
            v2 = L2[d2];
            for (f2 = 0; f2 < w2; f2++) Y2[H2 + f2] |= v2[f2];
          }
          else {
            let e4, t4;
            for (d2 = 0; d2 < b2; d2++) {
              t4 = J2 + d2;
              if (!(t4 < 0 || t4 >= r3)) {
                Y2 = u2[t4];
                v2 = L2[d2];
                for (f2 = 0; f2 < w2; f2++) {
                  e4 = H2 + f2;
                  e4 >= 0 && e4 < a3 && (Y2[e4] |= v2[f2]);
                }
              }
            }
          }
        }
        return u2;
      }(e2.mmr, s2, e2.template, n2.width, n2.height, e2.defaultPixelValue, e2.enableSkip, e2.combinationOperator, e2.gridWidth, e2.gridHeight, e2.gridOffsetX, e2.gridOffsetY, e2.gridVectorX, e2.gridVectorY, o2);
      this.drawBitmap(n2, g2);
    }
    onImmediateLosslessHalftoneRegion() {
      this.onImmediateHalftoneRegion(...arguments);
    }
    onTables(e2, t2, i2, a2) {
      let r2 = this.customTables;
      r2 || (this.customTables = r2 = {});
      r2[e2] = function decodeTablesSegment(e3, t3, i3) {
        const a3 = e3[t3], r3 = 4294967295 & readUint32(e3, t3 + 1), s2 = 4294967295 & readUint32(e3, t3 + 5), n2 = new Reader(e3, t3 + 9, i3), o2 = 1 + (a3 >> 1 & 7), g2 = 1 + (a3 >> 4 & 7), c2 = [];
        let C2, h2, l2 = r3;
        do {
          C2 = n2.readBits(o2);
          h2 = n2.readBits(g2);
          c2.push(new HuffmanLine([
            l2,
            C2,
            h2,
            0
          ]));
          l2 += 1 << h2;
        } while (l2 < s2);
        C2 = n2.readBits(o2);
        c2.push(new HuffmanLine([
          r3 - 1,
          C2,
          32,
          0,
          "lower"
        ]));
        C2 = n2.readBits(o2);
        c2.push(new HuffmanLine([
          s2,
          C2,
          32,
          0
        ]));
        if (1 & a3) {
          C2 = n2.readBits(o2);
          c2.push(new HuffmanLine([
            C2,
            0
          ]));
        }
        return new HuffmanTable(c2, false);
      }(t2, i2, a2);
    }
  }
  class HuffmanLine {
    constructor(e2) {
      if (2 === e2.length) {
        this.isOOB = true;
        this.rangeLow = 0;
        this.prefixLength = e2[0];
        this.rangeLength = 0;
        this.prefixCode = e2[1];
        this.isLowerRange = false;
      } else {
        this.isOOB = false;
        this.rangeLow = e2[0];
        this.prefixLength = e2[1];
        this.rangeLength = e2[2];
        this.prefixCode = e2[3];
        this.isLowerRange = "lower" === e2[4];
      }
    }
  }
  class HuffmanTreeNode {
    constructor(e2) {
      this.children = [];
      if (e2) {
        this.isLeaf = true;
        this.rangeLength = e2.rangeLength;
        this.rangeLow = e2.rangeLow;
        this.isLowerRange = e2.isLowerRange;
        this.isOOB = e2.isOOB;
      } else this.isLeaf = false;
    }
    buildTree(e2, t2) {
      const i2 = e2.prefixCode >> t2 & 1;
      if (t2 <= 0) this.children[i2] = new HuffmanTreeNode(e2);
      else {
        let a2 = this.children[i2];
        a2 || (this.children[i2] = a2 = new HuffmanTreeNode(null));
        a2.buildTree(e2, t2 - 1);
      }
    }
    decodeNode(e2) {
      if (this.isLeaf) {
        if (this.isOOB) return null;
        const t3 = e2.readBits(this.rangeLength);
        return this.rangeLow + (this.isLowerRange ? -t3 : t3);
      }
      const t2 = this.children[e2.readBit()];
      if (!t2) throw new Jbig2Error("invalid Huffman data");
      return t2.decodeNode(e2);
    }
  }
  class HuffmanTable {
    constructor(e2, t2) {
      t2 || this.assignPrefixCodes(e2);
      this.rootNode = new HuffmanTreeNode(null);
      for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
        const i3 = e2[t3];
        i3.prefixLength > 0 && this.rootNode.buildTree(i3, i3.prefixLength - 1);
      }
    }
    decode(e2) {
      return this.rootNode.decodeNode(e2);
    }
    assignPrefixCodes(e2) {
      const t2 = e2.length;
      let i2 = 0;
      for (let a3 = 0; a3 < t2; a3++) i2 = Math.max(i2, e2[a3].prefixLength);
      const a2 = new Uint32Array(i2 + 1);
      for (let i3 = 0; i3 < t2; i3++) a2[e2[i3].prefixLength]++;
      let r2, s2, n2, o2 = 1, g2 = 0;
      a2[0] = 0;
      for (; o2 <= i2; ) {
        g2 = g2 + a2[o2 - 1] << 1;
        r2 = g2;
        s2 = 0;
        for (; s2 < t2; ) {
          n2 = e2[s2];
          if (n2.prefixLength === o2) {
            n2.prefixCode = r2;
            r2++;
          }
          s2++;
        }
        o2++;
      }
    }
  }
  const ti = {};
  function getStandardTable(e2) {
    let t2, i2 = ti[e2];
    if (i2) return i2;
    switch (e2) {
      case 1:
        t2 = [
          [
            0,
            1,
            4,
            0
          ],
          [
            16,
            2,
            8,
            2
          ],
          [
            272,
            3,
            16,
            6
          ],
          [
            65808,
            3,
            32,
            7
          ]
        ];
        break;
      case 2:
        t2 = [
          [
            0,
            1,
            0,
            0
          ],
          [
            1,
            2,
            0,
            2
          ],
          [
            2,
            3,
            0,
            6
          ],
          [
            3,
            4,
            3,
            14
          ],
          [
            11,
            5,
            6,
            30
          ],
          [
            75,
            6,
            32,
            62
          ],
          [
            6,
            63
          ]
        ];
        break;
      case 3:
        t2 = [
          [
            -256,
            8,
            8,
            254
          ],
          [
            0,
            1,
            0,
            0
          ],
          [
            1,
            2,
            0,
            2
          ],
          [
            2,
            3,
            0,
            6
          ],
          [
            3,
            4,
            3,
            14
          ],
          [
            11,
            5,
            6,
            30
          ],
          [
            -257,
            8,
            32,
            255,
            "lower"
          ],
          [
            75,
            7,
            32,
            126
          ],
          [
            6,
            62
          ]
        ];
        break;
      case 4:
        t2 = [
          [
            1,
            1,
            0,
            0
          ],
          [
            2,
            2,
            0,
            2
          ],
          [
            3,
            3,
            0,
            6
          ],
          [
            4,
            4,
            3,
            14
          ],
          [
            12,
            5,
            6,
            30
          ],
          [
            76,
            5,
            32,
            31
          ]
        ];
        break;
      case 5:
        t2 = [
          [
            -255,
            7,
            8,
            126
          ],
          [
            1,
            1,
            0,
            0
          ],
          [
            2,
            2,
            0,
            2
          ],
          [
            3,
            3,
            0,
            6
          ],
          [
            4,
            4,
            3,
            14
          ],
          [
            12,
            5,
            6,
            30
          ],
          [
            -256,
            7,
            32,
            127,
            "lower"
          ],
          [
            76,
            6,
            32,
            62
          ]
        ];
        break;
      case 6:
        t2 = [
          [
            -2048,
            5,
            10,
            28
          ],
          [
            -1024,
            4,
            9,
            8
          ],
          [
            -512,
            4,
            8,
            9
          ],
          [
            -256,
            4,
            7,
            10
          ],
          [
            -128,
            5,
            6,
            29
          ],
          [
            -64,
            5,
            5,
            30
          ],
          [
            -32,
            4,
            5,
            11
          ],
          [
            0,
            2,
            7,
            0
          ],
          [
            128,
            3,
            7,
            2
          ],
          [
            256,
            3,
            8,
            3
          ],
          [
            512,
            4,
            9,
            12
          ],
          [
            1024,
            4,
            10,
            13
          ],
          [
            -2049,
            6,
            32,
            62,
            "lower"
          ],
          [
            2048,
            6,
            32,
            63
          ]
        ];
        break;
      case 7:
        t2 = [
          [
            -1024,
            4,
            9,
            8
          ],
          [
            -512,
            3,
            8,
            0
          ],
          [
            -256,
            4,
            7,
            9
          ],
          [
            -128,
            5,
            6,
            26
          ],
          [
            -64,
            5,
            5,
            27
          ],
          [
            -32,
            4,
            5,
            10
          ],
          [
            0,
            4,
            5,
            11
          ],
          [
            32,
            5,
            5,
            28
          ],
          [
            64,
            5,
            6,
            29
          ],
          [
            128,
            4,
            7,
            12
          ],
          [
            256,
            3,
            8,
            1
          ],
          [
            512,
            3,
            9,
            2
          ],
          [
            1024,
            3,
            10,
            3
          ],
          [
            -1025,
            5,
            32,
            30,
            "lower"
          ],
          [
            2048,
            5,
            32,
            31
          ]
        ];
        break;
      case 8:
        t2 = [
          [
            -15,
            8,
            3,
            252
          ],
          [
            -7,
            9,
            1,
            508
          ],
          [
            -5,
            8,
            1,
            253
          ],
          [
            -3,
            9,
            0,
            509
          ],
          [
            -2,
            7,
            0,
            124
          ],
          [
            -1,
            4,
            0,
            10
          ],
          [
            0,
            2,
            1,
            0
          ],
          [
            2,
            5,
            0,
            26
          ],
          [
            3,
            6,
            0,
            58
          ],
          [
            4,
            3,
            4,
            4
          ],
          [
            20,
            6,
            1,
            59
          ],
          [
            22,
            4,
            4,
            11
          ],
          [
            38,
            4,
            5,
            12
          ],
          [
            70,
            5,
            6,
            27
          ],
          [
            134,
            5,
            7,
            28
          ],
          [
            262,
            6,
            7,
            60
          ],
          [
            390,
            7,
            8,
            125
          ],
          [
            646,
            6,
            10,
            61
          ],
          [
            -16,
            9,
            32,
            510,
            "lower"
          ],
          [
            1670,
            9,
            32,
            511
          ],
          [
            2,
            1
          ]
        ];
        break;
      case 9:
        t2 = [
          [
            -31,
            8,
            4,
            252
          ],
          [
            -15,
            9,
            2,
            508
          ],
          [
            -11,
            8,
            2,
            253
          ],
          [
            -7,
            9,
            1,
            509
          ],
          [
            -5,
            7,
            1,
            124
          ],
          [
            -3,
            4,
            1,
            10
          ],
          [
            -1,
            3,
            1,
            2
          ],
          [
            1,
            3,
            1,
            3
          ],
          [
            3,
            5,
            1,
            26
          ],
          [
            5,
            6,
            1,
            58
          ],
          [
            7,
            3,
            5,
            4
          ],
          [
            39,
            6,
            2,
            59
          ],
          [
            43,
            4,
            5,
            11
          ],
          [
            75,
            4,
            6,
            12
          ],
          [
            139,
            5,
            7,
            27
          ],
          [
            267,
            5,
            8,
            28
          ],
          [
            523,
            6,
            8,
            60
          ],
          [
            779,
            7,
            9,
            125
          ],
          [
            1291,
            6,
            11,
            61
          ],
          [
            -32,
            9,
            32,
            510,
            "lower"
          ],
          [
            3339,
            9,
            32,
            511
          ],
          [
            2,
            0
          ]
        ];
        break;
      case 10:
        t2 = [
          [
            -21,
            7,
            4,
            122
          ],
          [
            -5,
            8,
            0,
            252
          ],
          [
            -4,
            7,
            0,
            123
          ],
          [
            -3,
            5,
            0,
            24
          ],
          [
            -2,
            2,
            2,
            0
          ],
          [
            2,
            5,
            0,
            25
          ],
          [
            3,
            6,
            0,
            54
          ],
          [
            4,
            7,
            0,
            124
          ],
          [
            5,
            8,
            0,
            253
          ],
          [
            6,
            2,
            6,
            1
          ],
          [
            70,
            5,
            5,
            26
          ],
          [
            102,
            6,
            5,
            55
          ],
          [
            134,
            6,
            6,
            56
          ],
          [
            198,
            6,
            7,
            57
          ],
          [
            326,
            6,
            8,
            58
          ],
          [
            582,
            6,
            9,
            59
          ],
          [
            1094,
            6,
            10,
            60
          ],
          [
            2118,
            7,
            11,
            125
          ],
          [
            -22,
            8,
            32,
            254,
            "lower"
          ],
          [
            4166,
            8,
            32,
            255
          ],
          [
            2,
            2
          ]
        ];
        break;
      case 11:
        t2 = [
          [
            1,
            1,
            0,
            0
          ],
          [
            2,
            2,
            1,
            2
          ],
          [
            4,
            4,
            0,
            12
          ],
          [
            5,
            4,
            1,
            13
          ],
          [
            7,
            5,
            1,
            28
          ],
          [
            9,
            5,
            2,
            29
          ],
          [
            13,
            6,
            2,
            60
          ],
          [
            17,
            7,
            2,
            122
          ],
          [
            21,
            7,
            3,
            123
          ],
          [
            29,
            7,
            4,
            124
          ],
          [
            45,
            7,
            5,
            125
          ],
          [
            77,
            7,
            6,
            126
          ],
          [
            141,
            7,
            32,
            127
          ]
        ];
        break;
      case 12:
        t2 = [
          [
            1,
            1,
            0,
            0
          ],
          [
            2,
            2,
            0,
            2
          ],
          [
            3,
            3,
            1,
            6
          ],
          [
            5,
            5,
            0,
            28
          ],
          [
            6,
            5,
            1,
            29
          ],
          [
            8,
            6,
            1,
            60
          ],
          [
            10,
            7,
            0,
            122
          ],
          [
            11,
            7,
            1,
            123
          ],
          [
            13,
            7,
            2,
            124
          ],
          [
            17,
            7,
            3,
            125
          ],
          [
            25,
            7,
            4,
            126
          ],
          [
            41,
            8,
            5,
            254
          ],
          [
            73,
            8,
            32,
            255
          ]
        ];
        break;
      case 13:
        t2 = [
          [
            1,
            1,
            0,
            0
          ],
          [
            2,
            3,
            0,
            4
          ],
          [
            3,
            4,
            0,
            12
          ],
          [
            4,
            5,
            0,
            28
          ],
          [
            5,
            4,
            1,
            13
          ],
          [
            7,
            3,
            3,
            5
          ],
          [
            15,
            6,
            1,
            58
          ],
          [
            17,
            6,
            2,
            59
          ],
          [
            21,
            6,
            3,
            60
          ],
          [
            29,
            6,
            4,
            61
          ],
          [
            45,
            6,
            5,
            62
          ],
          [
            77,
            7,
            6,
            126
          ],
          [
            141,
            7,
            32,
            127
          ]
        ];
        break;
      case 14:
        t2 = [
          [
            -2,
            3,
            0,
            4
          ],
          [
            -1,
            3,
            0,
            5
          ],
          [
            0,
            1,
            0,
            0
          ],
          [
            1,
            3,
            0,
            6
          ],
          [
            2,
            3,
            0,
            7
          ]
        ];
        break;
      case 15:
        t2 = [
          [
            -24,
            7,
            4,
            124
          ],
          [
            -8,
            6,
            2,
            60
          ],
          [
            -4,
            5,
            1,
            28
          ],
          [
            -2,
            4,
            0,
            12
          ],
          [
            -1,
            3,
            0,
            4
          ],
          [
            0,
            1,
            0,
            0
          ],
          [
            1,
            3,
            0,
            5
          ],
          [
            2,
            4,
            0,
            13
          ],
          [
            3,
            5,
            1,
            29
          ],
          [
            5,
            6,
            2,
            61
          ],
          [
            9,
            7,
            4,
            125
          ],
          [
            -25,
            7,
            32,
            126,
            "lower"
          ],
          [
            25,
            7,
            32,
            127
          ]
        ];
        break;
      default:
        throw new Jbig2Error(`standard table B.${e2} does not exist`);
    }
    for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) t2[e3] = new HuffmanLine(t2[e3]);
    i2 = new HuffmanTable(t2, true);
    ti[e2] = i2;
    return i2;
  }
  class Reader {
    constructor(e2, t2, i2) {
      this.data = e2;
      this.start = t2;
      this.end = i2;
      this.position = t2;
      this.shift = -1;
      this.currentByte = 0;
    }
    readBit() {
      if (this.shift < 0) {
        if (this.position >= this.end) throw new Jbig2Error("end of data while reading bit");
        this.currentByte = this.data[this.position++];
        this.shift = 7;
      }
      const e2 = this.currentByte >> this.shift & 1;
      this.shift--;
      return e2;
    }
    readBits(e2) {
      let t2, i2 = 0;
      for (t2 = e2 - 1; t2 >= 0; t2--) i2 |= this.readBit() << t2;
      return i2;
    }
    byteAlign() {
      this.shift = -1;
    }
    next() {
      return this.position >= this.end ? -1 : this.data[this.position++];
    }
  }
  function getCustomHuffmanTable(e2, t2, i2) {
    let a2 = 0;
    for (let r2 = 0, s2 = t2.length; r2 < s2; r2++) {
      const s3 = i2[t2[r2]];
      if (s3) {
        if (e2 === a2) return s3;
        a2++;
      }
    }
    throw new Jbig2Error("can't find custom Huffman table");
  }
  function readUncompressedBitmap(e2, t2, i2) {
    const a2 = [];
    for (let r2 = 0; r2 < i2; r2++) {
      const i3 = new Uint8Array(t2);
      a2.push(i3);
      for (let a3 = 0; a3 < t2; a3++) i3[a3] = e2.readBit();
      e2.byteAlign();
    }
    return a2;
  }
  function decodeMMRBitmap(e2, t2, i2, a2) {
    const r2 = new CCITTFaxDecoder(e2, {
      K: -1,
      Columns: t2,
      Rows: i2,
      BlackIs1: true,
      EndOfBlock: a2
    }), s2 = [];
    let n2, o2 = false;
    for (let e3 = 0; e3 < i2; e3++) {
      const e4 = new Uint8Array(t2);
      s2.push(e4);
      let i3 = -1;
      for (let a3 = 0; a3 < t2; a3++) {
        if (i3 < 0) {
          n2 = r2.readNextChar();
          if (-1 === n2) {
            n2 = 0;
            o2 = true;
          }
          i3 = 7;
        }
        e4[a3] = n2 >> i3 & 1;
        i3--;
      }
    }
    if (a2 && !o2) {
      const e3 = 5;
      for (let t3 = 0; t3 < e3 && -1 !== r2.readNextChar(); t3++) ;
    }
    return s2;
  }
  class Jbig2Image {
    parseChunks(e2) {
      return function parseJbig2Chunks(e3) {
        const t2 = new SimpleSegmentVisitor();
        for (let i2 = 0, a2 = e3.length; i2 < a2; i2++) {
          const a3 = e3[i2];
          processSegments(readSegments({}, a3.data, a3.start, a3.end), t2);
        }
        return t2.buffer;
      }(e2);
    }
    parse(e2) {
      throw new Error("Not implemented: Jbig2Image.parse");
    }
  }
  class Jbig2Stream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      this.stream = e2;
      this.dict = e2.dict;
      this.maybeLength = t2;
      this.params = i2;
    }
    get bytes() {
      return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e2) {
    }
    readBlock() {
      this.decodeImage();
    }
    decodeImage(e2) {
      if (this.eof) return this.buffer;
      e2 || (e2 = this.bytes);
      const t2 = new Jbig2Image(), i2 = [];
      if (this.params instanceof Dict) {
        const e3 = this.params.get("JBIG2Globals");
        if (e3 instanceof BaseStream) {
          const t3 = e3.getBytes();
          i2.push({
            data: t3,
            start: 0,
            end: t3.length
          });
        }
      }
      i2.push({
        data: e2,
        start: 0,
        end: e2.length
      });
      const a2 = t2.parseChunks(i2), r2 = a2.length;
      for (let e3 = 0; e3 < r2; e3++) a2[e3] ^= 255;
      this.buffer = a2;
      this.bufferLength = r2;
      this.eof = true;
      return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
      return this.stream.isAsync;
    }
  }
  function convertToRGBA(e2) {
    switch (e2.kind) {
      case S:
        return convertBlackAndWhiteToRGBA(e2);
      case k:
        return function convertRGBToRGBA({ src: e3, srcPos: t2 = 0, dest: i2, destPos: a2 = 0, width: r2, height: s2 }) {
          let n2 = 0;
          const o2 = e3.length >> 2, g2 = new Uint32Array(e3.buffer, t2, o2);
          if (FeatureTest.isLittleEndian) {
            for (; n2 < o2 - 2; n2 += 3, a2 += 4) {
              const e4 = g2[n2], t3 = g2[n2 + 1], r3 = g2[n2 + 2];
              i2[a2] = 4278190080 | e4;
              i2[a2 + 1] = e4 >>> 24 | t3 << 8 | 4278190080;
              i2[a2 + 2] = t3 >>> 16 | r3 << 16 | 4278190080;
              i2[a2 + 3] = r3 >>> 8 | 4278190080;
            }
            for (let t3 = 4 * n2, r3 = e3.length; t3 < r3; t3 += 3) i2[a2++] = e3[t3] | e3[t3 + 1] << 8 | e3[t3 + 2] << 16 | 4278190080;
          } else {
            for (; n2 < o2 - 2; n2 += 3, a2 += 4) {
              const e4 = g2[n2], t3 = g2[n2 + 1], r3 = g2[n2 + 2];
              i2[a2] = 255 | e4;
              i2[a2 + 1] = e4 << 24 | t3 >>> 8 | 255;
              i2[a2 + 2] = t3 << 16 | r3 >>> 16 | 255;
              i2[a2 + 3] = r3 << 8 | 255;
            }
            for (let t3 = 4 * n2, r3 = e3.length; t3 < r3; t3 += 3) i2[a2++] = e3[t3] << 24 | e3[t3 + 1] << 16 | e3[t3 + 2] << 8 | 255;
          }
          return {
            srcPos: t2,
            destPos: a2
          };
        }(e2);
    }
    return null;
  }
  function convertBlackAndWhiteToRGBA({ src: e2, srcPos: t2 = 0, dest: i2, width: a2, height: r2, nonBlackColor: s2 = 4294967295, inverseDecode: n2 = false }) {
    const o2 = FeatureTest.isLittleEndian ? 4278190080 : 255, [g2, c2] = n2 ? [
      s2,
      o2
    ] : [
      o2,
      s2
    ], C2 = a2 >> 3, h2 = 7 & a2, l2 = e2.length;
    i2 = new Uint32Array(i2.buffer);
    let Q2 = 0;
    for (let a3 = 0; a3 < r2; a3++) {
      for (const a5 = t2 + C2; t2 < a5; t2++) {
        const a6 = t2 < l2 ? e2[t2] : 255;
        i2[Q2++] = 128 & a6 ? c2 : g2;
        i2[Q2++] = 64 & a6 ? c2 : g2;
        i2[Q2++] = 32 & a6 ? c2 : g2;
        i2[Q2++] = 16 & a6 ? c2 : g2;
        i2[Q2++] = 8 & a6 ? c2 : g2;
        i2[Q2++] = 4 & a6 ? c2 : g2;
        i2[Q2++] = 2 & a6 ? c2 : g2;
        i2[Q2++] = 1 & a6 ? c2 : g2;
      }
      if (0 === h2) continue;
      const a4 = t2 < l2 ? e2[t2++] : 255;
      for (let e3 = 0; e3 < h2; e3++) i2[Q2++] = a4 & 1 << 7 - e3 ? c2 : g2;
    }
    return {
      srcPos: t2,
      destPos: Q2
    };
  }
  class JpegError extends It {
    constructor(e2) {
      super(e2, "JpegError");
    }
  }
  class DNLMarkerError extends It {
    constructor(e2, t2) {
      super(e2, "DNLMarkerError");
      this.scanLines = t2;
    }
  }
  class EOIMarkerError extends It {
    constructor(e2) {
      super(e2, "EOIMarkerError");
    }
  }
  const ii = new Uint8Array([
    0,
    1,
    8,
    16,
    9,
    2,
    3,
    10,
    17,
    24,
    32,
    25,
    18,
    11,
    4,
    5,
    12,
    19,
    26,
    33,
    40,
    48,
    41,
    34,
    27,
    20,
    13,
    6,
    7,
    14,
    21,
    28,
    35,
    42,
    49,
    56,
    57,
    50,
    43,
    36,
    29,
    22,
    15,
    23,
    30,
    37,
    44,
    51,
    58,
    59,
    52,
    45,
    38,
    31,
    39,
    46,
    53,
    60,
    61,
    54,
    47,
    55,
    62,
    63
  ]), ai = 4017, ri = 799, si = 3406, ni = 2276, oi = 1567, gi = 3784, Ii = 5793, ci = 2896;
  function buildHuffmanTable(e2, t2) {
    let i2, a2, r2 = 0, s2 = 16;
    for (; s2 > 0 && !e2[s2 - 1]; ) s2--;
    const n2 = [
      {
        children: [],
        index: 0
      }
    ];
    let o2, g2 = n2[0];
    for (i2 = 0; i2 < s2; i2++) {
      for (a2 = 0; a2 < e2[i2]; a2++) {
        g2 = n2.pop();
        g2.children[g2.index] = t2[r2];
        for (; g2.index > 0; ) g2 = n2.pop();
        g2.index++;
        n2.push(g2);
        for (; n2.length <= i2; ) {
          n2.push(o2 = {
            children: [],
            index: 0
          });
          g2.children[g2.index] = o2.children;
          g2 = o2;
        }
        r2++;
      }
      if (i2 + 1 < s2) {
        n2.push(o2 = {
          children: [],
          index: 0
        });
        g2.children[g2.index] = o2.children;
        g2 = o2;
      }
    }
    return n2[0].children;
  }
  function getBlockBufferOffset(e2, t2, i2) {
    return 64 * ((e2.blocksPerLine + 1) * t2 + i2);
  }
  function decodeScan(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2 = false) {
    const C2 = i2.mcusPerLine, h2 = i2.progressive, l2 = t2;
    let Q2 = 0, E2 = 0;
    function readBit() {
      if (E2 > 0) {
        E2--;
        return Q2 >> E2 & 1;
      }
      Q2 = e2[t2++];
      if (255 === Q2) {
        const a3 = e2[t2++];
        if (a3) {
          if (220 === a3 && c2) {
            const a4 = readUint16(e2, t2 += 2);
            t2 += 2;
            if (a4 > 0 && a4 !== i2.scanLines) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", a4);
          } else if (217 === a3) {
            if (c2) {
              const e3 = p2 * (8 === i2.precision ? 8 : 0);
              if (e3 > 0 && Math.round(i2.scanLines / e3) >= 5) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", e3);
            }
            throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
          }
          throw new JpegError(`unexpected marker ${(Q2 << 8 | a3).toString(16)}`);
        }
      }
      E2 = 7;
      return Q2 >>> 7;
    }
    function decodeHuffman(e3) {
      let t3 = e3;
      for (; ; ) {
        t3 = t3[readBit()];
        switch (typeof t3) {
          case "number":
            return t3;
          case "object":
            continue;
        }
        throw new JpegError("invalid huffman sequence");
      }
    }
    function receive(e3) {
      let t3 = 0;
      for (; e3 > 0; ) {
        t3 = t3 << 1 | readBit();
        e3--;
      }
      return t3;
    }
    function receiveAndExtend(e3) {
      if (1 === e3) return 1 === readBit() ? 1 : -1;
      const t3 = receive(e3);
      return t3 >= 1 << e3 - 1 ? t3 : t3 + (-1 << e3) + 1;
    }
    let u2 = 0;
    let d2, f2 = 0;
    let p2 = 0;
    function decodeMcu(e3, t3, i3, a3, r3) {
      const s3 = i3 % C2;
      p2 = (i3 / C2 | 0) * e3.v + a3;
      const n3 = s3 * e3.h + r3;
      t3(e3, getBlockBufferOffset(e3, p2, n3));
    }
    function decodeBlock(e3, t3, i3) {
      p2 = i3 / e3.blocksPerLine | 0;
      const a3 = i3 % e3.blocksPerLine;
      t3(e3, getBlockBufferOffset(e3, p2, a3));
    }
    const m2 = a2.length;
    let y2, w2, b2, D2, S2, k2;
    k2 = h2 ? 0 === s2 ? 0 === o2 ? function decodeDCFirst(e3, t3) {
      const i3 = decodeHuffman(e3.huffmanTableDC), a3 = 0 === i3 ? 0 : receiveAndExtend(i3) << g2;
      e3.blockData[t3] = e3.pred += a3;
    } : function decodeDCSuccessive(e3, t3) {
      e3.blockData[t3] |= readBit() << g2;
    } : 0 === o2 ? function decodeACFirst(e3, t3) {
      if (u2 > 0) {
        u2--;
        return;
      }
      let i3 = s2;
      const a3 = n2;
      for (; i3 <= a3; ) {
        const a4 = decodeHuffman(e3.huffmanTableAC), r3 = 15 & a4, s3 = a4 >> 4;
        if (0 === r3) {
          if (s3 < 15) {
            u2 = receive(s3) + (1 << s3) - 1;
            break;
          }
          i3 += 16;
          continue;
        }
        i3 += s3;
        const n3 = ii[i3];
        e3.blockData[t3 + n3] = receiveAndExtend(r3) * (1 << g2);
        i3++;
      }
    } : function decodeACSuccessive(e3, t3) {
      let i3 = s2;
      const a3 = n2;
      let r3, o3, c3 = 0;
      for (; i3 <= a3; ) {
        const a4 = t3 + ii[i3], s3 = e3.blockData[a4] < 0 ? -1 : 1;
        switch (f2) {
          case 0:
            o3 = decodeHuffman(e3.huffmanTableAC);
            r3 = 15 & o3;
            c3 = o3 >> 4;
            if (0 === r3) if (c3 < 15) {
              u2 = receive(c3) + (1 << c3);
              f2 = 4;
            } else {
              c3 = 16;
              f2 = 1;
            }
            else {
              if (1 !== r3) throw new JpegError("invalid ACn encoding");
              d2 = receiveAndExtend(r3);
              f2 = c3 ? 2 : 3;
            }
            continue;
          case 1:
          case 2:
            if (e3.blockData[a4]) e3.blockData[a4] += s3 * (readBit() << g2);
            else {
              c3--;
              0 === c3 && (f2 = 2 === f2 ? 3 : 0);
            }
            break;
          case 3:
            if (e3.blockData[a4]) e3.blockData[a4] += s3 * (readBit() << g2);
            else {
              e3.blockData[a4] = d2 << g2;
              f2 = 0;
            }
            break;
          case 4:
            e3.blockData[a4] && (e3.blockData[a4] += s3 * (readBit() << g2));
        }
        i3++;
      }
      if (4 === f2) {
        u2--;
        0 === u2 && (f2 = 0);
      }
    } : function decodeBaseline(e3, t3) {
      const i3 = decodeHuffman(e3.huffmanTableDC), a3 = 0 === i3 ? 0 : receiveAndExtend(i3);
      e3.blockData[t3] = e3.pred += a3;
      let r3 = 1;
      for (; r3 < 64; ) {
        const i4 = decodeHuffman(e3.huffmanTableAC), a4 = 15 & i4, s3 = i4 >> 4;
        if (0 === a4) {
          if (s3 < 15) break;
          r3 += 16;
          continue;
        }
        r3 += s3;
        const n3 = ii[r3];
        e3.blockData[t3 + n3] = receiveAndExtend(a4);
        r3++;
      }
    };
    let R2, N2 = 0;
    const G2 = 1 === m2 ? a2[0].blocksPerLine * a2[0].blocksPerColumn : C2 * i2.mcusPerColumn;
    let x2, U2;
    for (; N2 <= G2; ) {
      const i3 = r2 ? Math.min(G2 - N2, r2) : G2;
      if (i3 > 0) {
        for (w2 = 0; w2 < m2; w2++) a2[w2].pred = 0;
        u2 = 0;
        if (1 === m2) {
          y2 = a2[0];
          for (S2 = 0; S2 < i3; S2++) {
            decodeBlock(y2, k2, N2);
            N2++;
          }
        } else for (S2 = 0; S2 < i3; S2++) {
          for (w2 = 0; w2 < m2; w2++) {
            y2 = a2[w2];
            x2 = y2.h;
            U2 = y2.v;
            for (b2 = 0; b2 < U2; b2++) for (D2 = 0; D2 < x2; D2++) decodeMcu(y2, k2, N2, b2, D2);
          }
          N2++;
        }
      }
      E2 = 0;
      R2 = findNextFileMarker(e2, t2);
      if (!R2) break;
      if (R2.invalid) {
        warn(`decodeScan - ${i3 > 0 ? "unexpected" : "excessive"} MCU data, current marker is: ${R2.invalid}`);
        t2 = R2.offset;
      }
      if (!(R2.marker >= 65488 && R2.marker <= 65495)) break;
      t2 += 2;
    }
    return t2 - l2;
  }
  function quantizeAndInverse(e2, t2, i2) {
    const a2 = e2.quantizationTable, r2 = e2.blockData;
    let s2, n2, o2, g2, c2, C2, h2, l2, Q2, E2, u2, d2, f2, p2, m2, y2, w2;
    if (!a2) throw new JpegError("missing required Quantization Table.");
    for (let e3 = 0; e3 < 64; e3 += 8) {
      Q2 = r2[t2 + e3];
      E2 = r2[t2 + e3 + 1];
      u2 = r2[t2 + e3 + 2];
      d2 = r2[t2 + e3 + 3];
      f2 = r2[t2 + e3 + 4];
      p2 = r2[t2 + e3 + 5];
      m2 = r2[t2 + e3 + 6];
      y2 = r2[t2 + e3 + 7];
      Q2 *= a2[e3];
      if (0 != (E2 | u2 | d2 | f2 | p2 | m2 | y2)) {
        E2 *= a2[e3 + 1];
        u2 *= a2[e3 + 2];
        d2 *= a2[e3 + 3];
        f2 *= a2[e3 + 4];
        p2 *= a2[e3 + 5];
        m2 *= a2[e3 + 6];
        y2 *= a2[e3 + 7];
        s2 = Ii * Q2 + 128 >> 8;
        n2 = Ii * f2 + 128 >> 8;
        o2 = u2;
        g2 = m2;
        c2 = ci * (E2 - y2) + 128 >> 8;
        l2 = ci * (E2 + y2) + 128 >> 8;
        C2 = d2 << 4;
        h2 = p2 << 4;
        s2 = s2 + n2 + 1 >> 1;
        n2 = s2 - n2;
        w2 = o2 * gi + g2 * oi + 128 >> 8;
        o2 = o2 * oi - g2 * gi + 128 >> 8;
        g2 = w2;
        c2 = c2 + h2 + 1 >> 1;
        h2 = c2 - h2;
        l2 = l2 + C2 + 1 >> 1;
        C2 = l2 - C2;
        s2 = s2 + g2 + 1 >> 1;
        g2 = s2 - g2;
        n2 = n2 + o2 + 1 >> 1;
        o2 = n2 - o2;
        w2 = c2 * ni + l2 * si + 2048 >> 12;
        c2 = c2 * si - l2 * ni + 2048 >> 12;
        l2 = w2;
        w2 = C2 * ri + h2 * ai + 2048 >> 12;
        C2 = C2 * ai - h2 * ri + 2048 >> 12;
        h2 = w2;
        i2[e3] = s2 + l2;
        i2[e3 + 7] = s2 - l2;
        i2[e3 + 1] = n2 + h2;
        i2[e3 + 6] = n2 - h2;
        i2[e3 + 2] = o2 + C2;
        i2[e3 + 5] = o2 - C2;
        i2[e3 + 3] = g2 + c2;
        i2[e3 + 4] = g2 - c2;
      } else {
        w2 = Ii * Q2 + 512 >> 10;
        i2[e3] = w2;
        i2[e3 + 1] = w2;
        i2[e3 + 2] = w2;
        i2[e3 + 3] = w2;
        i2[e3 + 4] = w2;
        i2[e3 + 5] = w2;
        i2[e3 + 6] = w2;
        i2[e3 + 7] = w2;
      }
    }
    for (let e3 = 0; e3 < 8; ++e3) {
      Q2 = i2[e3];
      E2 = i2[e3 + 8];
      u2 = i2[e3 + 16];
      d2 = i2[e3 + 24];
      f2 = i2[e3 + 32];
      p2 = i2[e3 + 40];
      m2 = i2[e3 + 48];
      y2 = i2[e3 + 56];
      if (0 != (E2 | u2 | d2 | f2 | p2 | m2 | y2)) {
        s2 = Ii * Q2 + 2048 >> 12;
        n2 = Ii * f2 + 2048 >> 12;
        o2 = u2;
        g2 = m2;
        c2 = ci * (E2 - y2) + 2048 >> 12;
        l2 = ci * (E2 + y2) + 2048 >> 12;
        C2 = d2;
        h2 = p2;
        s2 = 4112 + (s2 + n2 + 1 >> 1);
        n2 = s2 - n2;
        w2 = o2 * gi + g2 * oi + 2048 >> 12;
        o2 = o2 * oi - g2 * gi + 2048 >> 12;
        g2 = w2;
        c2 = c2 + h2 + 1 >> 1;
        h2 = c2 - h2;
        l2 = l2 + C2 + 1 >> 1;
        C2 = l2 - C2;
        s2 = s2 + g2 + 1 >> 1;
        g2 = s2 - g2;
        n2 = n2 + o2 + 1 >> 1;
        o2 = n2 - o2;
        w2 = c2 * ni + l2 * si + 2048 >> 12;
        c2 = c2 * si - l2 * ni + 2048 >> 12;
        l2 = w2;
        w2 = C2 * ri + h2 * ai + 2048 >> 12;
        C2 = C2 * ai - h2 * ri + 2048 >> 12;
        h2 = w2;
        Q2 = s2 + l2;
        y2 = s2 - l2;
        E2 = n2 + h2;
        m2 = n2 - h2;
        u2 = o2 + C2;
        p2 = o2 - C2;
        d2 = g2 + c2;
        f2 = g2 - c2;
        Q2 < 16 ? Q2 = 0 : Q2 >= 4080 ? Q2 = 255 : Q2 >>= 4;
        E2 < 16 ? E2 = 0 : E2 >= 4080 ? E2 = 255 : E2 >>= 4;
        u2 < 16 ? u2 = 0 : u2 >= 4080 ? u2 = 255 : u2 >>= 4;
        d2 < 16 ? d2 = 0 : d2 >= 4080 ? d2 = 255 : d2 >>= 4;
        f2 < 16 ? f2 = 0 : f2 >= 4080 ? f2 = 255 : f2 >>= 4;
        p2 < 16 ? p2 = 0 : p2 >= 4080 ? p2 = 255 : p2 >>= 4;
        m2 < 16 ? m2 = 0 : m2 >= 4080 ? m2 = 255 : m2 >>= 4;
        y2 < 16 ? y2 = 0 : y2 >= 4080 ? y2 = 255 : y2 >>= 4;
        r2[t2 + e3] = Q2;
        r2[t2 + e3 + 8] = E2;
        r2[t2 + e3 + 16] = u2;
        r2[t2 + e3 + 24] = d2;
        r2[t2 + e3 + 32] = f2;
        r2[t2 + e3 + 40] = p2;
        r2[t2 + e3 + 48] = m2;
        r2[t2 + e3 + 56] = y2;
      } else {
        w2 = Ii * Q2 + 8192 >> 14;
        w2 = w2 < -2040 ? 0 : w2 >= 2024 ? 255 : w2 + 2056 >> 4;
        r2[t2 + e3] = w2;
        r2[t2 + e3 + 8] = w2;
        r2[t2 + e3 + 16] = w2;
        r2[t2 + e3 + 24] = w2;
        r2[t2 + e3 + 32] = w2;
        r2[t2 + e3 + 40] = w2;
        r2[t2 + e3 + 48] = w2;
        r2[t2 + e3 + 56] = w2;
      }
    }
  }
  function buildComponentData(e2, t2) {
    const i2 = t2.blocksPerLine, a2 = t2.blocksPerColumn, r2 = new Int16Array(64);
    for (let e3 = 0; e3 < a2; e3++) for (let a3 = 0; a3 < i2; a3++) {
      quantizeAndInverse(t2, getBlockBufferOffset(t2, e3, a3), r2);
    }
    return t2.blockData;
  }
  function findNextFileMarker(e2, t2, i2 = t2) {
    const a2 = e2.length - 1;
    let r2 = i2 < t2 ? i2 : t2;
    if (t2 >= a2) return null;
    const s2 = readUint16(e2, t2);
    if (s2 >= 65472 && s2 <= 65534) return {
      invalid: null,
      marker: s2,
      offset: t2
    };
    let n2 = readUint16(e2, r2);
    for (; !(n2 >= 65472 && n2 <= 65534); ) {
      if (++r2 >= a2) return null;
      n2 = readUint16(e2, r2);
    }
    return {
      invalid: s2.toString(16),
      marker: n2,
      offset: r2
    };
  }
  function prepareComponents(e2) {
    const t2 = Math.ceil(e2.samplesPerLine / 8 / e2.maxH), i2 = Math.ceil(e2.scanLines / 8 / e2.maxV);
    for (const a2 of e2.components) {
      const r2 = Math.ceil(Math.ceil(e2.samplesPerLine / 8) * a2.h / e2.maxH), s2 = Math.ceil(Math.ceil(e2.scanLines / 8) * a2.v / e2.maxV), n2 = t2 * a2.h, o2 = 64 * (i2 * a2.v) * (n2 + 1);
      a2.blockData = new Int16Array(o2);
      a2.blocksPerLine = r2;
      a2.blocksPerColumn = s2;
    }
    e2.mcusPerLine = t2;
    e2.mcusPerColumn = i2;
  }
  function readDataBlock(e2, t2) {
    const i2 = readUint16(e2, t2);
    let a2 = (t2 += 2) + i2 - 2;
    const r2 = findNextFileMarker(e2, a2, t2);
    if (r2 == null ? void 0 : r2.invalid) {
      warn("readDataBlock - incorrect length, current marker is: " + r2.invalid);
      a2 = r2.offset;
    }
    const s2 = e2.subarray(t2, a2);
    return {
      appData: s2,
      newOffset: t2 += s2.length
    };
  }
  function skipData(e2, t2) {
    const i2 = readUint16(e2, t2), a2 = (t2 += 2) + i2 - 2, r2 = findNextFileMarker(e2, a2, t2);
    return (r2 == null ? void 0 : r2.invalid) ? r2.offset : a2;
  }
  class JpegImage {
    constructor({ decodeTransform: e2 = null, colorTransform: t2 = -1 } = {}) {
      this._decodeTransform = e2;
      this._colorTransform = t2;
    }
    static canUseImageDecoder(e2, t2 = -1) {
      let i2 = 0, a2 = null, r2 = readUint16(e2, i2);
      i2 += 2;
      if (65496 !== r2) throw new JpegError("SOI not found");
      r2 = readUint16(e2, i2);
      i2 += 2;
      A: for (; 65497 !== r2; ) {
        switch (r2) {
          case 65472:
          case 65473:
          case 65474:
            a2 = e2[i2 + 7];
            break A;
          case 65535:
            255 !== e2[i2] && i2--;
        }
        i2 = skipData(e2, i2);
        r2 = readUint16(e2, i2);
        i2 += 2;
      }
      return 4 !== a2 && (3 !== a2 || 0 !== t2);
    }
    parse(e2, { dnlScanLines: t2 = null } = {}) {
      let i2, a2, r2 = 0, s2 = null, n2 = null, o2 = 0;
      const g2 = [], c2 = [], C2 = [];
      let h2 = readUint16(e2, r2);
      r2 += 2;
      if (65496 !== h2) throw new JpegError("SOI not found");
      h2 = readUint16(e2, r2);
      r2 += 2;
      A: for (; 65497 !== h2; ) {
        let l2, Q2, E2;
        switch (h2) {
          case 65504:
          case 65505:
          case 65506:
          case 65507:
          case 65508:
          case 65509:
          case 65510:
          case 65511:
          case 65512:
          case 65513:
          case 65514:
          case 65515:
          case 65516:
          case 65517:
          case 65518:
          case 65519:
          case 65534:
            const { appData: u2, newOffset: d2 } = readDataBlock(e2, r2);
            r2 = d2;
            65504 === h2 && 74 === u2[0] && 70 === u2[1] && 73 === u2[2] && 70 === u2[3] && 0 === u2[4] && (s2 = {
              version: {
                major: u2[5],
                minor: u2[6]
              },
              densityUnits: u2[7],
              xDensity: u2[8] << 8 | u2[9],
              yDensity: u2[10] << 8 | u2[11],
              thumbWidth: u2[12],
              thumbHeight: u2[13],
              thumbData: u2.subarray(14, 14 + 3 * u2[12] * u2[13])
            });
            65518 === h2 && 65 === u2[0] && 100 === u2[1] && 111 === u2[2] && 98 === u2[3] && 101 === u2[4] && (n2 = {
              version: u2[5] << 8 | u2[6],
              flags0: u2[7] << 8 | u2[8],
              flags1: u2[9] << 8 | u2[10],
              transformCode: u2[11]
            });
            break;
          case 65499:
            const f2 = readUint16(e2, r2);
            r2 += 2;
            const p2 = f2 + r2 - 2;
            let m2;
            for (; r2 < p2; ) {
              const t3 = e2[r2++], i3 = new Uint16Array(64);
              if (t3 >> 4 == 0) for (Q2 = 0; Q2 < 64; Q2++) {
                m2 = ii[Q2];
                i3[m2] = e2[r2++];
              }
              else {
                if (t3 >> 4 != 1) throw new JpegError("DQT - invalid table spec");
                for (Q2 = 0; Q2 < 64; Q2++) {
                  m2 = ii[Q2];
                  i3[m2] = readUint16(e2, r2);
                  r2 += 2;
                }
              }
              g2[15 & t3] = i3;
            }
            break;
          case 65472:
          case 65473:
          case 65474:
            if (i2) throw new JpegError("Only single frame JPEGs supported");
            r2 += 2;
            i2 = {};
            i2.extended = 65473 === h2;
            i2.progressive = 65474 === h2;
            i2.precision = e2[r2++];
            const y2 = readUint16(e2, r2);
            r2 += 2;
            i2.scanLines = t2 || y2;
            i2.samplesPerLine = readUint16(e2, r2);
            r2 += 2;
            i2.components = [];
            i2.componentIds = {};
            const w2 = e2[r2++];
            let b2 = 0, D2 = 0;
            for (l2 = 0; l2 < w2; l2++) {
              const t3 = e2[r2], a3 = e2[r2 + 1] >> 4, s3 = 15 & e2[r2 + 1];
              b2 < a3 && (b2 = a3);
              D2 < s3 && (D2 = s3);
              const n3 = e2[r2 + 2];
              E2 = i2.components.push({
                h: a3,
                v: s3,
                quantizationId: n3,
                quantizationTable: null
              });
              i2.componentIds[t3] = E2 - 1;
              r2 += 3;
            }
            i2.maxH = b2;
            i2.maxV = D2;
            prepareComponents(i2);
            break;
          case 65476:
            const S2 = readUint16(e2, r2);
            r2 += 2;
            for (l2 = 2; l2 < S2; ) {
              const t3 = e2[r2++], i3 = new Uint8Array(16);
              let a3 = 0;
              for (Q2 = 0; Q2 < 16; Q2++, r2++) a3 += i3[Q2] = e2[r2];
              const s3 = new Uint8Array(a3);
              for (Q2 = 0; Q2 < a3; Q2++, r2++) s3[Q2] = e2[r2];
              l2 += 17 + a3;
              (t3 >> 4 == 0 ? C2 : c2)[15 & t3] = buildHuffmanTable(i3, s3);
            }
            break;
          case 65501:
            r2 += 2;
            a2 = readUint16(e2, r2);
            r2 += 2;
            break;
          case 65498:
            const k2 = 1 == ++o2 && !t2;
            r2 += 2;
            const R2 = e2[r2++], N2 = [];
            for (l2 = 0; l2 < R2; l2++) {
              const t3 = e2[r2++], a3 = i2.componentIds[t3], s3 = i2.components[a3];
              s3.index = t3;
              const n3 = e2[r2++];
              s3.huffmanTableDC = C2[n3 >> 4];
              s3.huffmanTableAC = c2[15 & n3];
              N2.push(s3);
            }
            const G2 = e2[r2++], x2 = e2[r2++], U2 = e2[r2++];
            try {
              r2 += decodeScan(e2, r2, i2, N2, a2, G2, x2, U2 >> 4, 15 & U2, k2);
            } catch (t3) {
              if (t3 instanceof DNLMarkerError) {
                warn(`${t3.message} -- attempting to re-parse the JPEG image.`);
                return this.parse(e2, {
                  dnlScanLines: t3.scanLines
                });
              }
              if (t3 instanceof EOIMarkerError) {
                warn(`${t3.message} -- ignoring the rest of the image data.`);
                break A;
              }
              throw t3;
            }
            break;
          case 65500:
            r2 += 4;
            break;
          case 65535:
            255 !== e2[r2] && r2--;
            break;
          default:
            const M2 = findNextFileMarker(e2, r2 - 2, r2 - 3);
            if (M2 == null ? void 0 : M2.invalid) {
              warn("JpegImage.parse - unexpected data, current marker is: " + M2.invalid);
              r2 = M2.offset;
              break;
            }
            if (!M2 || r2 >= e2.length - 1) {
              warn("JpegImage.parse - reached the end of the image data without finding an EOI marker (0xFFD9).");
              break A;
            }
            throw new JpegError("JpegImage.parse - unknown marker: " + h2.toString(16));
        }
        h2 = readUint16(e2, r2);
        r2 += 2;
      }
      if (!i2) throw new JpegError("JpegImage.parse - no frame data found.");
      this.width = i2.samplesPerLine;
      this.height = i2.scanLines;
      this.jfif = s2;
      this.adobe = n2;
      this.components = [];
      for (const e3 of i2.components) {
        const t3 = g2[e3.quantizationId];
        t3 && (e3.quantizationTable = t3);
        this.components.push({
          index: e3.index,
          output: buildComponentData(0, e3),
          scaleX: e3.h / i2.maxH,
          scaleY: e3.v / i2.maxV,
          blocksPerLine: e3.blocksPerLine,
          blocksPerColumn: e3.blocksPerColumn
        });
      }
      this.numComponents = this.components.length;
    }
    _getLinearizedBlockData(e2, t2, i2 = false) {
      const a2 = this.width / e2, r2 = this.height / t2;
      let s2, n2, o2, g2, c2, C2, h2, l2, Q2, E2, u2, d2 = 0;
      const f2 = this.components.length, p2 = e2 * t2 * f2, m2 = new Uint8ClampedArray(p2), y2 = new Uint32Array(e2), w2 = 4294967288;
      let b2;
      for (h2 = 0; h2 < f2; h2++) {
        s2 = this.components[h2];
        n2 = s2.scaleX * a2;
        o2 = s2.scaleY * r2;
        d2 = h2;
        u2 = s2.output;
        g2 = s2.blocksPerLine + 1 << 3;
        if (n2 !== b2) {
          for (c2 = 0; c2 < e2; c2++) {
            l2 = 0 | c2 * n2;
            y2[c2] = (l2 & w2) << 3 | 7 & l2;
          }
          b2 = n2;
        }
        for (C2 = 0; C2 < t2; C2++) {
          l2 = 0 | C2 * o2;
          E2 = g2 * (l2 & w2) | (7 & l2) << 3;
          for (c2 = 0; c2 < e2; c2++) {
            m2[d2] = u2[E2 + y2[c2]];
            d2 += f2;
          }
        }
      }
      let D2 = this._decodeTransform;
      i2 || 4 !== f2 || D2 || (D2 = new Int32Array([
        -256,
        255,
        -256,
        255,
        -256,
        255,
        -256,
        255
      ]));
      if (D2) for (h2 = 0; h2 < p2; ) for (l2 = 0, Q2 = 0; l2 < f2; l2++, h2++, Q2 += 2) m2[h2] = (m2[h2] * D2[Q2] >> 8) + D2[Q2 + 1];
      return m2;
    }
    get _isColorConversionNeeded() {
      return this.adobe ? !!this.adobe.transformCode : 3 === this.numComponents ? 0 !== this._colorTransform && (82 !== this.components[0].index || 71 !== this.components[1].index || 66 !== this.components[2].index) : 1 === this._colorTransform;
    }
    _convertYccToRgb(e2) {
      let t2, i2, a2;
      for (let r2 = 0, s2 = e2.length; r2 < s2; r2 += 3) {
        t2 = e2[r2];
        i2 = e2[r2 + 1];
        a2 = e2[r2 + 2];
        e2[r2] = t2 - 179.456 + 1.402 * a2;
        e2[r2 + 1] = t2 + 135.459 - 0.344 * i2 - 0.714 * a2;
        e2[r2 + 2] = t2 - 226.816 + 1.772 * i2;
      }
      return e2;
    }
    _convertYccToRgba(e2, t2) {
      for (let i2 = 0, a2 = 0, r2 = e2.length; i2 < r2; i2 += 3, a2 += 4) {
        const r3 = e2[i2], s2 = e2[i2 + 1], n2 = e2[i2 + 2];
        t2[a2] = r3 - 179.456 + 1.402 * n2;
        t2[a2 + 1] = r3 + 135.459 - 0.344 * s2 - 0.714 * n2;
        t2[a2 + 2] = r3 - 226.816 + 1.772 * s2;
        t2[a2 + 3] = 255;
      }
      return t2;
    }
    _convertYcckToRgb(e2) {
      let t2, i2, a2, r2, s2 = 0;
      for (let n2 = 0, o2 = e2.length; n2 < o2; n2 += 4) {
        t2 = e2[n2];
        i2 = e2[n2 + 1];
        a2 = e2[n2 + 2];
        r2 = e2[n2 + 3];
        e2[s2++] = i2 * (-660635669420364e-19 * i2 + 437130475926232e-18 * a2 - 54080610064599e-18 * t2 + 48449797120281e-17 * r2 - 0.154362151871126) - 122.67195406894 + a2 * (-957964378445773e-18 * a2 + 817076911346625e-18 * t2 - 0.00477271405408747 * r2 + 1.53380253221734) + t2 * (961250184130688e-18 * t2 - 0.00266257332283933 * r2 + 0.48357088451265) + r2 * (-336197177618394e-18 * r2 + 0.484791561490776);
        e2[s2++] = 107.268039397724 + i2 * (219927104525741e-19 * i2 - 640992018297945e-18 * a2 + 659397001245577e-18 * t2 + 426105652938837e-18 * r2 - 0.176491792462875) + a2 * (-778269941513683e-18 * a2 + 0.00130872261408275 * t2 + 770482631801132e-18 * r2 - 0.151051492775562) + t2 * (0.00126935368114843 * t2 - 0.00265090189010898 * r2 + 0.25802910206845) + r2 * (-318913117588328e-18 * r2 - 0.213742400323665);
        e2[s2++] = i2 * (-570115196973677e-18 * i2 - 263409051004589e-19 * a2 + 0.0020741088115012 * t2 - 0.00288260236853442 * r2 + 0.814272968359295) - 20.810012546947 + a2 * (-153496057440975e-19 * a2 - 132689043961446e-18 * t2 + 560833691242812e-18 * r2 - 0.195152027534049) + t2 * (0.00174418132927582 * t2 - 0.00255243321439347 * r2 + 0.116935020465145) + r2 * (-343531996510555e-18 * r2 + 0.24165260232407);
      }
      return e2.subarray(0, s2);
    }
    _convertYcckToRgba(e2) {
      for (let t2 = 0, i2 = e2.length; t2 < i2; t2 += 4) {
        const i3 = e2[t2], a2 = e2[t2 + 1], r2 = e2[t2 + 2], s2 = e2[t2 + 3];
        e2[t2] = a2 * (-660635669420364e-19 * a2 + 437130475926232e-18 * r2 - 54080610064599e-18 * i3 + 48449797120281e-17 * s2 - 0.154362151871126) - 122.67195406894 + r2 * (-957964378445773e-18 * r2 + 817076911346625e-18 * i3 - 0.00477271405408747 * s2 + 1.53380253221734) + i3 * (961250184130688e-18 * i3 - 0.00266257332283933 * s2 + 0.48357088451265) + s2 * (-336197177618394e-18 * s2 + 0.484791561490776);
        e2[t2 + 1] = 107.268039397724 + a2 * (219927104525741e-19 * a2 - 640992018297945e-18 * r2 + 659397001245577e-18 * i3 + 426105652938837e-18 * s2 - 0.176491792462875) + r2 * (-778269941513683e-18 * r2 + 0.00130872261408275 * i3 + 770482631801132e-18 * s2 - 0.151051492775562) + i3 * (0.00126935368114843 * i3 - 0.00265090189010898 * s2 + 0.25802910206845) + s2 * (-318913117588328e-18 * s2 - 0.213742400323665);
        e2[t2 + 2] = a2 * (-570115196973677e-18 * a2 - 263409051004589e-19 * r2 + 0.0020741088115012 * i3 - 0.00288260236853442 * s2 + 0.814272968359295) - 20.810012546947 + r2 * (-153496057440975e-19 * r2 - 132689043961446e-18 * i3 + 560833691242812e-18 * s2 - 0.195152027534049) + i3 * (0.00174418132927582 * i3 - 0.00255243321439347 * s2 + 0.116935020465145) + s2 * (-343531996510555e-18 * s2 + 0.24165260232407);
        e2[t2 + 3] = 255;
      }
      return e2;
    }
    _convertYcckToCmyk(e2) {
      let t2, i2, a2;
      for (let r2 = 0, s2 = e2.length; r2 < s2; r2 += 4) {
        t2 = e2[r2];
        i2 = e2[r2 + 1];
        a2 = e2[r2 + 2];
        e2[r2] = 434.456 - t2 - 1.402 * a2;
        e2[r2 + 1] = 119.541 - t2 + 0.344 * i2 + 0.714 * a2;
        e2[r2 + 2] = 481.816 - t2 - 1.772 * i2;
      }
      return e2;
    }
    _convertCmykToRgb(e2) {
      let t2, i2, a2, r2, s2 = 0;
      for (let n2 = 0, o2 = e2.length; n2 < o2; n2 += 4) {
        t2 = e2[n2];
        i2 = e2[n2 + 1];
        a2 = e2[n2 + 2];
        r2 = e2[n2 + 3];
        e2[s2++] = 255 + t2 * (-6747147073602441e-20 * t2 + 8379262121013727e-19 * i2 + 2894718188643294e-19 * a2 + 0.003264231057537806 * r2 - 1.1185611867203937) + i2 * (26374107616089405e-21 * i2 - 8626949158638572e-20 * a2 - 2748769067499491e-19 * r2 - 0.02155688794978967) + a2 * (-3878099212869363e-20 * a2 - 3267808279485286e-19 * r2 + 0.0686742238595345) - r2 * (3361971776183937e-19 * r2 + 0.7430659151342254);
        e2[s2++] = 255 + t2 * (13596372813588848e-20 * t2 + 924537132573585e-18 * i2 + 10567359618683593e-20 * a2 + 4791864687436512e-19 * r2 - 0.3109689587515875) + i2 * (-23545346108370344e-20 * i2 + 2702845253534714e-19 * a2 + 0.0020200308977307156 * r2 - 0.7488052167015494) + a2 * (6834815998235662e-20 * a2 + 15168452363460973e-20 * r2 - 0.09751927774728933) - r2 * (3189131175883281e-19 * r2 + 0.7364883807733168);
        e2[s2++] = 255 + t2 * (13598650411385307e-21 * t2 + 12423956175490851e-20 * i2 + 4751985097583589e-19 * a2 - 36729317476630422e-22 * r2 - 0.05562186980264034) + i2 * (16141380598724676e-20 * i2 + 9692239130725186e-19 * a2 + 7782692450036253e-19 * r2 - 0.44015232367526463) + a2 * (5068882914068769e-22 * a2 + 0.0017778369011375071 * r2 - 0.7591454649749609) - r2 * (3435319965105553e-19 * r2 + 0.7063770186160144);
      }
      return e2.subarray(0, s2);
    }
    _convertCmykToRgba(e2) {
      for (let t2 = 0, i2 = e2.length; t2 < i2; t2 += 4) {
        const i3 = e2[t2], a2 = e2[t2 + 1], r2 = e2[t2 + 2], s2 = e2[t2 + 3];
        e2[t2] = 255 + i3 * (-6747147073602441e-20 * i3 + 8379262121013727e-19 * a2 + 2894718188643294e-19 * r2 + 0.003264231057537806 * s2 - 1.1185611867203937) + a2 * (26374107616089405e-21 * a2 - 8626949158638572e-20 * r2 - 2748769067499491e-19 * s2 - 0.02155688794978967) + r2 * (-3878099212869363e-20 * r2 - 3267808279485286e-19 * s2 + 0.0686742238595345) - s2 * (3361971776183937e-19 * s2 + 0.7430659151342254);
        e2[t2 + 1] = 255 + i3 * (13596372813588848e-20 * i3 + 924537132573585e-18 * a2 + 10567359618683593e-20 * r2 + 4791864687436512e-19 * s2 - 0.3109689587515875) + a2 * (-23545346108370344e-20 * a2 + 2702845253534714e-19 * r2 + 0.0020200308977307156 * s2 - 0.7488052167015494) + r2 * (6834815998235662e-20 * r2 + 15168452363460973e-20 * s2 - 0.09751927774728933) - s2 * (3189131175883281e-19 * s2 + 0.7364883807733168);
        e2[t2 + 2] = 255 + i3 * (13598650411385307e-21 * i3 + 12423956175490851e-20 * a2 + 4751985097583589e-19 * r2 - 36729317476630422e-22 * s2 - 0.05562186980264034) + a2 * (16141380598724676e-20 * a2 + 9692239130725186e-19 * r2 + 7782692450036253e-19 * s2 - 0.44015232367526463) + r2 * (5068882914068769e-22 * r2 + 0.0017778369011375071 * s2 - 0.7591454649749609) - s2 * (3435319965105553e-19 * s2 + 0.7063770186160144);
        e2[t2 + 3] = 255;
      }
      return e2;
    }
    getData({ width: e2, height: t2, forceRGBA: i2 = false, forceRGB: a2 = false, isSourcePDF: r2 = false }) {
      if (this.numComponents > 4) throw new JpegError("Unsupported color mode");
      const s2 = this._getLinearizedBlockData(e2, t2, r2);
      if (1 === this.numComponents && (i2 || a2)) {
        const e3 = s2.length * (i2 ? 4 : 3), t3 = new Uint8ClampedArray(e3);
        let a3 = 0;
        if (i2) !function grayToRGBA(e4, t4) {
          if (FeatureTest.isLittleEndian) for (let i3 = 0, a4 = e4.length; i3 < a4; i3++) t4[i3] = 65793 * e4[i3] | 4278190080;
          else for (let i3 = 0, a4 = e4.length; i3 < a4; i3++) t4[i3] = 16843008 * e4[i3] | 255;
        }(s2, new Uint32Array(t3.buffer));
        else for (const e4 of s2) {
          t3[a3++] = e4;
          t3[a3++] = e4;
          t3[a3++] = e4;
        }
        return t3;
      }
      if (3 === this.numComponents && this._isColorConversionNeeded) {
        if (i2) {
          const e3 = new Uint8ClampedArray(s2.length / 3 * 4);
          return this._convertYccToRgba(s2, e3);
        }
        return this._convertYccToRgb(s2);
      }
      if (4 === this.numComponents) {
        if (this._isColorConversionNeeded) return i2 ? this._convertYcckToRgba(s2) : a2 ? this._convertYcckToRgb(s2) : this._convertYcckToCmyk(s2);
        if (i2) return this._convertCmykToRgba(s2);
        if (a2) return this._convertCmykToRgb(s2);
      }
      return s2;
    }
  }
  const _JpegStream = class _JpegStream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      __privateAdd(this, _JpegStream_instances);
      this.stream = e2;
      this.dict = e2.dict;
      this.maybeLength = t2;
      this.params = i2;
    }
    static get canUseImageDecoder() {
      return shadow(this, "canUseImageDecoder", "undefined" == typeof ImageDecoder ? Promise.resolve(false) : ImageDecoder.isTypeSupported("image/jpeg"));
    }
    get bytes() {
      return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e2) {
    }
    readBlock() {
      this.decodeImage();
    }
    get jpegOptions() {
      const e2 = {
        decodeTransform: void 0,
        colorTransform: void 0
      }, t2 = this.dict.getArray("D", "Decode");
      if ((this.forceRGBA || this.forceRGB) && Array.isArray(t2)) {
        const i2 = this.dict.get("BPC", "BitsPerComponent") || 8, a2 = t2.length, r2 = new Int32Array(a2);
        let s2 = false;
        const n2 = (1 << i2) - 1;
        for (let e3 = 0; e3 < a2; e3 += 2) {
          r2[e3] = 256 * (t2[e3 + 1] - t2[e3]) | 0;
          r2[e3 + 1] = t2[e3] * n2 | 0;
          256 === r2[e3] && 0 === r2[e3 + 1] || (s2 = true);
        }
        s2 && (e2.decodeTransform = r2);
      }
      if (this.params instanceof Dict) {
        const t3 = this.params.get("ColorTransform");
        Number.isInteger(t3) && (e2.colorTransform = t3);
      }
      return shadow(this, "jpegOptions", e2);
    }
    decodeImage(e2) {
      if (this.eof) return this.buffer;
      e2 = __privateMethod(this, _JpegStream_instances, y_fn).call(this, e2 || this.bytes);
      const t2 = new JpegImage(this.jpegOptions);
      t2.parse(e2);
      const i2 = t2.getData({
        width: this.drawWidth,
        height: this.drawHeight,
        forceRGBA: this.forceRGBA,
        forceRGB: this.forceRGB,
        isSourcePDF: true
      });
      this.buffer = i2;
      this.bufferLength = i2.length;
      this.eof = true;
      return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
      return this.stream.isAsync;
    }
    async getTransferableImage() {
      if (!await _JpegStream.canUseImageDecoder) return null;
      const e2 = this.jpegOptions;
      if (e2.decodeTransform) return null;
      let t2;
      try {
        const i2 = this.canAsyncDecodeImageFromBuffer && await this.stream.asyncGetBytes() || this.bytes;
        if (!i2) return null;
        const a2 = __privateMethod(this, _JpegStream_instances, y_fn).call(this, i2);
        if (!JpegImage.canUseImageDecoder(a2, e2.colorTransform)) return null;
        t2 = new ImageDecoder({
          data: a2,
          type: "image/jpeg",
          preferAnimation: false
        });
        return (await t2.decode()).image;
      } catch (e3) {
        warn(`getTransferableImage - failed: "${e3}".`);
        return null;
      } finally {
        t2 == null ? void 0 : t2.close();
      }
    }
  };
  _JpegStream_instances = new WeakSet();
  y_fn = function(e2) {
    for (let t2 = 0, i2 = e2.length - 1; t2 < i2; t2++) if (255 === e2[t2] && 216 === e2[t2 + 1]) {
      t2 > 0 && (e2 = e2.subarray(t2));
      break;
    }
    return e2;
  };
  let JpegStream = _JpegStream;
  var Ci, hi = (Ci = "undefined" != typeof document ? (_a3 = document.currentScript) == null ? void 0 : _a3.src : void 0, function(e2 = {}) {
    var t2, i2, a2 = e2;
    new Promise((e3, a3) => {
      t2 = e3;
      i2 = a3;
    });
    a2.decode = function(e3, { numComponents: t3 = 4, isIndexedColormap: i3 = false, smaskInData: r2 = false }) {
      const s3 = e3.length, n3 = a2._malloc(s3);
      a2.HEAPU8.set(e3, n3);
      const o3 = a2._jp2_decode(n3, s3, t3 > 0 ? t3 : 0, !!i3, !!r2);
      a2._free(n3);
      if (o3) {
        const { errorMessages: e4 } = a2;
        if (e4) {
          delete a2.errorMessages;
          return e4;
        }
        return "Unknown error";
      }
      const { imageData: g3 } = a2;
      a2.imageData = null;
      return g3;
    };
    var s2 = Object.assign({}, a2), n2 = "./this.program", o2 = "";
    "undefined" != typeof document && document.currentScript && (o2 = document.currentScript.src);
    Ci && (o2 = Ci);
    o2 = o2.startsWith("blob:") ? "" : o2.substr(0, o2.replace(/[?#].*/, "").lastIndexOf("/") + 1);
    var g2, c2, C2, h2, l2, Q2 = a2.print || console.log.bind(console), E2 = a2.printErr || console.error.bind(console);
    Object.assign(a2, s2);
    s2 = null;
    a2.arguments && a2.arguments;
    a2.thisProgram && (n2 = a2.thisProgram);
    a2.quit && a2.quit;
    a2.wasmBinary && (g2 = a2.wasmBinary);
    function tryParseAsDataURI(e3) {
      if (isDataURI(e3)) return function intArrayFromBase64(e4) {
        for (var t3 = atob(e4), i3 = new Uint8Array(t3.length), a3 = 0; a3 < t3.length; ++a3) i3[a3] = t3.charCodeAt(a3);
        return i3;
      }(e3.slice(b2.length));
    }
    function updateMemoryViews() {
      var e3 = c2.buffer;
      a2.HEAP8 = C2 = new Int8Array(e3);
      a2.HEAP16 = new Int16Array(e3);
      a2.HEAPU8 = h2 = new Uint8Array(e3);
      a2.HEAPU16 = new Uint16Array(e3);
      a2.HEAP32 = new Int32Array(e3);
      a2.HEAPU32 = l2 = new Uint32Array(e3);
      a2.HEAPF32 = new Float32Array(e3);
      a2.HEAPF64 = new Float64Array(e3);
    }
    var u2, d2 = [], f2 = [], p2 = [], m2 = 0, w2 = null, b2 = "data:application/octet-stream;base64,", isDataURI = (e3) => e3.startsWith(b2);
    function instantiateSync(e3, t3) {
      var i3, a3 = function getBinarySync(e4) {
        if (e4 == u2 && g2) return new Uint8Array(g2);
        var t4 = tryParseAsDataURI(e4);
        if (t4) return t4;
        throw 'sync fetching of the wasm failed: you can preload it to Module["wasmBinary"] manually, or emcc.py will do that for you when generating HTML (but not JS)';
      }(e3);
      i3 = new WebAssembly.Module(a3);
      return [
        new WebAssembly.Instance(i3, t3),
        i3
      ];
    }
    var callRuntimeCallbacks = (e3) => {
      for (; e3.length > 0; ) e3.shift()(a2);
    };
    a2.noExitRuntime;
    var D2, growMemory = (e3) => {
      var t3 = (e3 - c2.buffer.byteLength + 65535) / 65536;
      try {
        c2.grow(t3);
        updateMemoryViews();
        return 1;
      } catch (e4) {
      }
    }, S2 = {}, getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var e3 = {
          USER: "web_user",
          LOGNAME: "web_user",
          PATH: "/",
          PWD: "/",
          HOME: "/home/web_user",
          LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
          _: n2 || "./this.program"
        };
        for (var t3 in S2) void 0 === S2[t3] ? delete e3[t3] : e3[t3] = S2[t3];
        var i3 = [];
        for (var t3 in e3) i3.push(`${t3}=${e3[t3]}`);
        getEnvStrings.strings = i3;
      }
      return getEnvStrings.strings;
    }, k2 = [
      null,
      [],
      []
    ], R2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, UTF8ArrayToString = (e3, t3, i3) => {
      for (var a3 = t3 + i3, r2 = t3; e3[r2] && !(r2 >= a3); ) ++r2;
      if (r2 - t3 > 16 && e3.buffer && R2) return R2.decode(e3.subarray(t3, r2));
      for (var s3 = ""; t3 < r2; ) {
        var n3 = e3[t3++];
        if (128 & n3) {
          var o3 = 63 & e3[t3++];
          if (192 != (224 & n3)) {
            var g3 = 63 & e3[t3++];
            if ((n3 = 224 == (240 & n3) ? (15 & n3) << 12 | o3 << 6 | g3 : (7 & n3) << 18 | o3 << 12 | g3 << 6 | 63 & e3[t3++]) < 65536) s3 += String.fromCharCode(n3);
            else {
              var c3 = n3 - 65536;
              s3 += String.fromCharCode(55296 | c3 >> 10, 56320 | 1023 & c3);
            }
          } else s3 += String.fromCharCode((31 & n3) << 6 | o3);
        } else s3 += String.fromCharCode(n3);
      }
      return s3;
    }, printChar = (e3, t3) => {
      var i3 = k2[e3];
      if (0 === t3 || 10 === t3) {
        (1 === e3 ? Q2 : E2)(UTF8ArrayToString(i3, 0));
        i3.length = 0;
      } else i3.push(t3);
    }, UTF8ToString = (e3, t3) => e3 ? UTF8ArrayToString(h2, e3, t3) : "", N2 = {
      c: (e3, t3, i3) => h2.copyWithin(e3, t3, t3 + i3),
      g: function _copy_pixels_1(e3, t3) {
        e3 >>= 2;
        const i3 = a2.imageData = new Uint8ClampedArray(t3), r2 = a2.HEAP32.subarray(e3, e3 + t3);
        i3.set(r2);
      },
      f: function _copy_pixels_3(e3, t3, i3, r2) {
        e3 >>= 2;
        t3 >>= 2;
        i3 >>= 2;
        const s3 = a2.imageData = new Uint8ClampedArray(3 * r2), n3 = a2.HEAP32.subarray(e3, e3 + r2), o3 = a2.HEAP32.subarray(t3, t3 + r2), g3 = a2.HEAP32.subarray(i3, i3 + r2);
        for (let e4 = 0; e4 < r2; e4++) {
          s3[3 * e4] = n3[e4];
          s3[3 * e4 + 1] = o3[e4];
          s3[3 * e4 + 2] = g3[e4];
        }
      },
      e: function _copy_pixels_4(e3, t3, i3, r2, s3) {
        e3 >>= 2;
        t3 >>= 2;
        i3 >>= 2;
        r2 >>= 2;
        const n3 = a2.imageData = new Uint8ClampedArray(4 * s3), o3 = a2.HEAP32.subarray(e3, e3 + s3), g3 = a2.HEAP32.subarray(t3, t3 + s3), c3 = a2.HEAP32.subarray(i3, i3 + s3), C3 = a2.HEAP32.subarray(r2, r2 + s3);
        for (let e4 = 0; e4 < s3; e4++) {
          n3[4 * e4] = o3[e4];
          n3[4 * e4 + 1] = g3[e4];
          n3[4 * e4 + 2] = c3[e4];
          n3[4 * e4 + 3] = C3[e4];
        }
      },
      k: (e3) => {
        var t3 = h2.length, i3 = 2147483648;
        if ((e3 >>>= 0) > i3) return false;
        for (var a3, r2, s3 = 1; s3 <= 4; s3 *= 2) {
          var n3 = t3 * (1 + 0.2 / s3);
          n3 = Math.min(n3, e3 + 100663296);
          var o3 = Math.min(i3, (a3 = Math.max(e3, n3)) + ((r2 = 65536) - a3 % r2) % r2);
          if (growMemory(o3)) return true;
        }
        return false;
      },
      l: (e3, t3) => {
        var i3 = 0;
        getEnvStrings().forEach((a3, r2) => {
          var s3 = t3 + i3;
          l2[e3 + 4 * r2 >> 2] = s3;
          ((e4, t4) => {
            for (var i4 = 0; i4 < e4.length; ++i4) C2[t4++] = e4.charCodeAt(i4);
            C2[t4] = 0;
          })(a3, s3);
          i3 += a3.length + 1;
        });
        return 0;
      },
      m: (e3, t3) => {
        var i3 = getEnvStrings();
        l2[e3 >> 2] = i3.length;
        var a3 = 0;
        i3.forEach((e4) => a3 += e4.length + 1);
        l2[t3 >> 2] = a3;
        return 0;
      },
      n: (e3) => 52,
      j: function _fd_seek(e3, t3, i3, a3, r2) {
        return 70;
      },
      b: (e3, t3, i3, a3) => {
        for (var r2 = 0, s3 = 0; s3 < i3; s3++) {
          var n3 = l2[t3 >> 2], o3 = l2[t3 + 4 >> 2];
          t3 += 8;
          for (var g3 = 0; g3 < o3; g3++) printChar(e3, h2[n3 + g3]);
          r2 += o3;
        }
        l2[a3 >> 2] = r2;
        return 0;
      },
      o: function _gray_to_rgba(e3, t3) {
        e3 >>= 2;
        const i3 = a2.imageData = new Uint8ClampedArray(4 * t3), r2 = a2.HEAP32.subarray(e3, e3 + t3);
        for (let e4 = 0; e4 < t3; e4++) {
          i3[4 * e4] = i3[4 * e4 + 1] = i3[4 * e4 + 2] = r2[e4];
          i3[4 * e4 + 3] = 255;
        }
      },
      i: function _graya_to_rgba(e3, t3, i3) {
        e3 >>= 2;
        t3 >>= 2;
        const r2 = a2.imageData = new Uint8ClampedArray(4 * i3), s3 = a2.HEAP32.subarray(e3, e3 + i3), n3 = a2.HEAP32.subarray(t3, t3 + i3);
        for (let e4 = 0; e4 < i3; e4++) {
          r2[4 * e4] = r2[4 * e4 + 1] = r2[4 * e4 + 2] = s3[e4];
          r2[4 * e4 + 3] = n3[e4];
        }
      },
      d: function _jsPrintWarning(e3) {
        const t3 = UTF8ToString(e3);
        (a2.warn || console.warn)(`OpenJPEG: ${t3}`);
      },
      h: function _rgb_to_rgba(e3, t3, i3, r2) {
        e3 >>= 2;
        t3 >>= 2;
        i3 >>= 2;
        const s3 = a2.imageData = new Uint8ClampedArray(4 * r2), n3 = a2.HEAP32.subarray(e3, e3 + r2), o3 = a2.HEAP32.subarray(t3, t3 + r2), g3 = a2.HEAP32.subarray(i3, i3 + r2);
        for (let e4 = 0; e4 < r2; e4++) {
          s3[4 * e4] = n3[e4];
          s3[4 * e4 + 1] = o3[e4];
          s3[4 * e4 + 2] = g3[e4];
          s3[4 * e4 + 3] = 255;
        }
      },
      a: function _storeErrorMessage(e3) {
        const t3 = UTF8ToString(e3);
        a2.errorMessages ? a2.errorMessages += "\n" + t3 : a2.errorMessages = t3;
      }
    }, G2 = function createWasm() {
      var e3 = /* @__PURE__ */ function getWasmImports() {
        return {
          a: N2
        };
      }();
      function receiveInstance(e4, t3) {
        G2 = e4.exports;
        c2 = G2.p;
        updateMemoryViews();
        !function addOnInit(e5) {
          f2.unshift(e5);
        }(G2.q);
        !function removeRunDependency(e5) {
          var _a4;
          m2--;
          (_a4 = a2.monitorRunDependencies) == null ? void 0 : _a4.call(a2, m2);
          if (0 == m2) {
            if (w2) {
              var t4 = w2;
              w2 = null;
              t4();
            }
          }
        }();
        return G2;
      }
      !function addRunDependency(e4) {
        var _a4;
        m2++;
        (_a4 = a2.monitorRunDependencies) == null ? void 0 : _a4.call(a2, m2);
      }();
      if (a2.instantiateWasm) try {
        return a2.instantiateWasm(e3, receiveInstance);
      } catch (e4) {
        E2(`Module.instantiateWasm callback failed with error: ${e4}`);
        i2(e4);
      }
      u2 || (u2 = "data:application/octet-stream;base64,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A0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAswAQF/AkAgAEUNACABRQ0AQQggACABbCIBECUiAARAIABBACABEBUaCyAAIQILIAILEQAgAEUEQEEADwtBCCAAECUL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALJwEBfyMAQRBrIgMkACADIAI2AgwgACABIAJBAEEAEGsgA0EQaiQAC+gFAQl/IAFFBEBBAA8LAn8gAEUE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ACAEIE5BCmpBAiAFEBpBAkcEQCAFQQFBAiAAKAK4ARtBlhJBABAPIAAoArgBRSFnDAELIE5BCmogTkEMakECEBEgTigCDCIBQZD/A0YNACABQdn/A0YEQCAAQYACNgIIIABBADYCzAEMAQsgBCkDCCKGAVAEfkIABSCGASAEKQM4fQtQBEAgAEHAADYCCCAFQQJBrD9BABAPDAELQQAhZyAFQQFB7D5BABAPCyBOQRBqJAAgZwsLACAABEAgABAQCwu0AQEBfyAAKAIMRQRAIAIgACgCJCABEQMADwsCQEEIEBQiA0UNACADIAI2AgQgAyABNgIAQQgQFCIBRQRAIAMQEA8LIAEgAzYCACAAIAAoAgRB5ABsIgI2AigDQCAAKAIYIAJKDQALIAEgACgCFDYCBCAAIAE2AhQgACAAKAIYQQFqNgIYIAAoAhwiAUUNACABKAIAQQA2AgggACABKAIENgIcIAAgACgCIEEBazYCICABEBALC/oCAQR/AkAgAEUNACAAKAKsKCIBBEAgACgCqCgiAgRAQQAhAQNAIAAoAqwoIAFBA3RqKAIAIgMEQCADEBAgACgCqCghAgsgAUEBaiIBIAJJDQALIAAoAqwoIQELIABBADYCqCggARAQIABBADYCrCgLIAAoArQoIgEEQCABEBAgAEEANgK0KAsgACgC0CsiAQRAIAEQECAAQQA2AtArCyAAKALsKyIBBEAgARAQIABBADYC7CsLIAAoAugrIgEEQCABEBAgAEEANgLoKwsgACgC/CsiAQRAIAEQECAAQQA2AoQsIABCADcC/CsLIAAoAvArIgEEQCAAKAL0KyIDBH9BACECA0AgASgCDCIEBEAgBBAQIAFBADYCDCAAKAL0KyEDCyABQRRqIQEgAkEBaiICIANJDQALIAAoAvArBSABCxAQIABBADYC8CsLIAAoAuQrIgEEQCABEBAgAEEANgLkKwsgACgC3CsiAUUNACABEBAgAEIANwLcKwsLyAcCEX8BfiAAKAIQIghBIE8EQCAAKQMIpw8LAkAgACgCFCIDQQROBEAgACgCACICQQNrKAIAIQEgACADQQRrIgM2AhQgACACQQRrNgIADAELIANBAEwEQAwBCyADQQFxIQ0gACgCACECAkAgA0EBRgRAQRghBAwBCyADQf7///8HcSEJQRghBANAIAAgAkEB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IABBADYCiAEgACgCZBAQIABBADYCZCAALQC8AUECcUUEQCAAKAKoARAQCyAAQdAAakEAQfAAEBUaIAAoAsABEDIgAEEANgLAASAAKALEARAyIABBADYCwAEgACgCyAEiAQRAIAEoAhwiAgRAIAIQECABQQA2AhwLIAEoAigiAgRAIAEoAiQEQANAIAIgBUEobCIDaigCJCIEBEAgBBAQIAEoAigiAiADakEANgIkCyACIANqKAIQIgQEQCAEEBAgASgCKCICIANqQQA2AhALIAIgA2ooAhgiBARAIAQQECABKAIoIgIgA2pBADYCGAsgBUEBaiIFIAEoAiRJDQALCyACEBAgAUEANgIoCyABEBALIABBADYCyAEgACgCSBAhIABBADYCSCAAKAJMECEgAEEANgJMIAAoAtQBIgMEQAJAIAMoAghFDQAgAygCDARAIANBADYCKANAIAMoAhhBAEoNAAsLIANBATYCECADKAIAEBAgAygCHCICRQ0AA0AgAigCBCEBIAIQECADIAE2AhwgASICDQALCyADKAIkIgIEQCACKAIEIgVBAEoEQEEAIQEDQCACKAIAIAFBDGxqIgQoAggiBgRAIAQoAgQgBhECACACKAIEIQULIAFBAWoiASAFSA0ACwsgAigCABAQIAIQEAsgAxAQCyAAQQA2AtQBIAAQEAsL5gMCCH8EfiAAKAIUKAIAKAIUIAFBzABsaiIJKAIMIgggACgCGCgCGCABQTRsaiIKNQIEIhBCAX0iEiAANQI8fCAQgKciCyAIIAtJGyEMIAkoAggiCCAKNQIAIhFCAX0iEyAANQI4fCARgKciCiAIIApJGyEKIAkoAgQiCCASIAA1AjR8IBCApyILIAggC0sbIQsgCSgCACIIIBMgADUCMHwgEYCnIg0gCCANSxshDUEAIQggACgCICgC0CsgAUG4CGxqKAIUIQ4CQCAJKAIUQQAgAmtBfyACG2oiAkUEQCAKIQAgDSEIIAshAQwBCyADQQFxIAJBAWsiD3QiCSANSQRAIA0gCWutQn8gAq0iEIZCf4V8IBCIpyEIC0EAIQBBACEBIANBAXYgD3QiAyALSQRAIAsgA2utQn8gAq0iEIZCf4V8IBCIpyEBCyAJIApJBEAgCiAJa61CfyACrSIQhkJ/hXwgEIinIQALIAMgDE8EQEEAIQwMAQsgDCADa61CfyACrSIQhkJ/hXwgEIinIQwLQX8gAEECQQMgDkEBRhsiAmoiAyAAIANLGyAES0F/IAIgDGoiACAAIAxJGyAFS3EgCCACayIAQQAgACAITRsgBklxIAEgAmsiAEEAIAAgAU0bIAdJcQuiAQEGfyAABEAgACgCBCICBEAgAhAQIABBADYCBAsgAQRAIAAhAgNAIAIoAsgBIgMEQEEAIQUgAigCxAEiBAR/A0AgAygCDCIGBEAgBhAQIANBADYCDCACKALEASEECyADQRBqIQMgBUEBaiIFIARJDQALIAIoAsgBBSADCxAQIAJBADYCyAELIAJB8AFqIQIgB0EBaiIHIAFHDQALCyAAEBALC9UZAhN/A3sgACgCACIKIAAoAgwiDUEFdCIFaiEGIAogBWshFiAAKAIQIQUgACgCHCELIAAoAhQhCSAAKAIIIQ4CQAJAAkACQCADQQhJDQAgAUEPcQ0AIAZBD3FFDQELIAUgCU8NAgJAAkAgA0EBaw4CAAEDCwJAIAkgBWsiCEEYSQ0AIAEgBUECdGohByANQQV0IgQgCiAFQQZ0amogASAJQQJ0akkEQCAHIAogCUEGdGogBGpBPGtJDQELIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEYIAUgCEF8cSIPaiEFQQAhBANAIAYgGEEE/asBIhf9GwBBAnRqIAcgBEECdGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiAZ/R8BOAIAIAYgF/0bAkECdGogGf0fAjgCACAGIBf9GwNBAnRqIBn9HwM4AgAgGP0MBAAAAAQAAAAEAAAABAAAAP2uASEYIARBBGoiBCAPRw0ACyAIIA9GDQQLIAUhBCAJIAVrQQNxIgcEQEEAIQgDQCAGIARBBnRqIAEgBEECdGoqAgA4AgAgBEEBaiEEIAhBAWoiCCAHRw0ACwsgBSAJa0F8Sw0DA0AgBiAEQQZ0aiABIARBAnRqKgIAOAIAIAYgBEEBaiIFQQZ0aiABIAVBAnRqKgIAOAIAIAYgBEECaiIFQQZ0aiABIAVBAnRqKgIAOAIAIAYgBEEDaiIFQQZ0aiABIAVBAnRqKgIAOAIAIARBBGoiBCAJRw0ACwwDCyABIAJBAnRqIQgCQCAJIAVrIg9BPEkEQCAFIQQMAQsgCiAFQQZ0IA1BBXRqaiIEIAkgBUF/c2oiB0EGdCIQaiAESQRAIAUhBAwBCyAEQQRqIgQgEGogBEkEQCAFIQQMAQsgB0H///8fSwRAIAUhBAwBCyANQQV0IgQgCiAFQQZ0amoiByABIAIgCWpBAnRqSSAKIAlBBnRqIARqQThrIgQgASACIAVqQQJ0aktxBEAgBSEEDAELIAcgASAJQQJ0akkgASAFQQJ0aiAESXEEQCAFIQQMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIRggBSAPQXxxIhBqIQRBACEHA0AgBiAYQQT9qwEiF/0bAEECdGoiESABIAUgB2pBAnQiDGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiITIBn9HwE4AgAgBiAX/RsCQQJ0aiIUIBn9HwI4AgAgBiAX/RsDQQJ0aiIVIBn9HwM4AgAgESAIIAxq/QACACIX/R8AOAIEIBMgF/0fATgCBCAUIBf9HwI4AgQgFSAX/R8DOAIEIBj9DAQAAAAEAAAABAAAAAQAAAD9rgEhGCAHQQRqIgcgEEcNAAsgDyAQRg0DCyAEQQFqIQUgCSAEa0EBcQRAIAYgBEEGdGoiByABIARBAnQiBGoqAgA4AgAgByAEIAhqKgIAOAIEIAUhBAsgBSAJRg0CA0AgBiAEQQZ0aiIFIAEgBEECdCIHaioCADgCACAFIAcgCGoqAgA4AgQgBiAEQQFqIgVBBnRqIgcgASAFQQJ0IgVqKgIAOAIAIAcgBSAIaioCADgCBCAEQQJqIgQgCUcNAAsMAgsgBSAJTw0BIAEgAkECdGohCANAIAYgBUEGdGoiBCABIAVBAnRqKgIAOAIAIAQgASACIAVqIgdBAnRqKgIAOAIEIAQgASACIAdqIgdBAnRqKgIAOAIIIAQgASACIAdqIgdBAnRqKgIAOAIMIAQgASACIAdqIgdBAnRqKgIAOAIQIAQgASACIAdqIgdBAnRqKgIAOAIUIAQgASACIAdqQQJ0IgdqKgIAOAIYIAQgByAIaioCADgCHCAFQQFqIgUgCUcNAAsMAQsgASACQQJ0aiEIIANBA0YhByADQQRGIQ8gA0EFRiEQIANBB0YhEQNAIAYgBUEGdGoiBCABIAVBAnRqKgIAOAIAIAQgASACIAVqIgxBAnRqKgIAOAIEIAQgASACIAxqIgxBAnRqKgIAOAIIAkAgBw0AIAQgASACIAxqIgxBAnRqKgIAOAIMIA8NACAEIAEgAiAMaiIMQQJ0aioCADgCECAQDQAgBCABIAIgDGoiDEECdGoqAgA4AhQgA0EGRg0AIAQgASACIAxqQQJ0IgxqKgIAOAIYIBENACAEIAggDGoqAgA4AhwLIAVBAWoiBSAJRw0ACwsgFkEgaiEGIAEgDkECdGohBCAAKAIYIQUCQAJAAkAgA0EISQ0AIARBD3ENACAGQQ9xRQ0BCyAFIAtPDQECQAJAAkAgA0EBaw4CAAECCwJAIAsgBWsiAEEcSQ0AIAogBUEGdEEgciANQQV0IgJraiABIAsgDmpBAnRqSQRAIAEgBSAOakECdGogC0EGdCACayAKakEca0kNAQsgBCAFQQJ0aiEDIAX9Ef0MAAAAAAEAAAACAAAAAwAAAP2uASEYIAUgAEF8cSIBaiEFQQAhAgNAIAYgGEEE/asBIhf9GwBBAnRqIAMgAkECdGr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiAZ/R8BOAIAIAYgF/0bAkECdGogGf0fAjgCACAGIBf9GwNBAnRqIBn9HwM4AgAgGP0MBAAAAAQAAAAEAAAABAAAAP2uASEYIAJBBGoiAiABRw0ACyAAIAFGDQQLIAUhAiALIAVrQQNxIgAEQEEAIQEDQCAGIAJBBnRqIAQgAkECdGoqAgA4AgAgAkEBaiECIAFBAWoiASAARw0ACwsgBSALa0F8Sw0DA0AgBiACQQZ0aiAEIAJBAnRqKgIAOAIAIAYgAkEBaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAYgAkECaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAYgAkEDaiIAQQZ0aiAEIABBAnRqKgIAOAIAIAJBBGoiAiALRw0ACwwDCyAEIAJBAnRqIQMCQCALIAVrIgBBxABJBEAgBSECDAELIAogBUEGdCIJQSByIA1BBXQiCGtqIgcgCyAFQX9zaiIPQQZ0IhBqIAdJBEAgBSECDAELIAogCUEkciAIa2oiCSAQaiAJSQRAIAUhAgwBCyAPQf///x9LBEAgBSECDAELIAogBUEGdEEgciANQQV0IglraiINIAEgCyAOaiIIIAJqQQJ0akkgC0EGdCAJayAKakEYayIJIAEgDkECdGogBUECdGoiCiACQQJ0aktxBEAgBSECDAELIA0gASAIQQJ0akkgCSAKS3EEQCAFIQIMAQsgBf0R/QwAAAAAAQAAAAIAAAADAAAA/a4BIRggBSAAQXxxIglqIQJBACEBA0AgBiAYQQT9qwEiF/0bAEECdGoiCiAEIAEgBWpBAnQiDWr9AAIAIhn9HwA4AgAgBiAX/RsBQQJ0aiIOIBn9HwE4AgAgBiAX/RsCQQJ0aiIIIBn9HwI4AgAgBiAX/RsDQQJ0aiIHIBn9HwM4AgAgCiADIA1q/QACACIX/R8AOAIEIA4gF/0fATgCBCAIIBf9HwI4AgQgByAX/R8DOAIEIBj9DAQAAAAEAAAABAAAAAQAAAD9rgEhGCABQQRqIgEgCUcNAAsgACAJRg0DCyACQQFqIQAgCyACa0EBcQRAIAYgAkEGdGoiASAEIAJBAnQiAmoqAgA4AgAgASACIANqKgIAOAIEIAAhAgsgACALRg0CA0AgBiACQQZ0aiIAIAQgAkECdCIBaioCADgCACAAIAEgA2oqAgA4AgQgBiACQQFqIgBBBnRqIgEgBCAAQQJ0IgBqKgIAOAIAIAEgACADaioCADgCBCACQQJqIgIgC0cNAAsMAgsgBCACQQJ0aiEBIANBA0YhCSADQQRGIQogA0EFRiENIANBB0YhDgNAIAYgBUEGdGoiACAEIAVBAnRqKgIAOAIAIAAgBCACIAVqIghBAnRqKgIAOAIEIAAgBCACIAhqIghBAnRqKgIAOAIIAkAgCQ0AIAAgBCACIAhqIghBAnRqKgIAOAIMIAoNACAAIAQgAiAIaiIIQQJ0aioCADgCECANDQAgACAEIAIgCGoiCEECdGoqAgA4AhQgA0EGRg0AIAAgBCACIAhqQQJ0IghqKgIAOAIYIA4NACAAIAEgCGoqAgA4AhwLIAVBAWoiBSALRw0ACwwBCyAFIAtPDQAgBCACQQJ0aiEBA0AgBiAFQQZ0aiIAIAQgBUECdGoqAgA4AgAgACAEIAIgBWoiA0ECdGoqAgA4AgQgACAEIAIgA2oiA0ECdGoqAgA4AgggACAEIAIgA2oiA0ECdGoqAgA4AgwgACAEIAIgA2oiA0ECdGoqAgA4AhAgACAEIAIgA2oiA0ECdGoqAgA4AhQgACAEIAIgA2pBAnQiA2oqAgA4AhggACABIANqKgIAOAIcIAVBAWoiBSALRw0ACwsLmwMBBH8gASAAQQRqIgRqQQFrQQAgAWtxIgUgAmogACAAKAIAIgFqQQRrTQR/IAAoAgQiAyAAKAIIIgY2AgggBiADNgIEIAQgBUcEQCAAIABBBGsoAgBBfnFrIgMgBSAEayIEIAMoAgBqIgU2AgAgAyAFQXxxakEEayAFNgIAIAAgBGoiACABIARrIgE2AgALAn8gASACQRhqTwRAIAAgAmpBCGoiAyABIAJrQQhrIgE2AgAgAyABQXxxakEEayABQQFyNgIAIAMCfyADKAIAQQhrIgFB/wBNBEAgAUEDdkEBawwBCyABZyEEIAFBHSAEa3ZBBHMgBEECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIARrdkECcyAEQQF0a0HHAGoiASABQT9PGwsiAUEEdCIEQaDHAWo2AgQgAyAEQajHAWoiBCgCADYCCCAEIAM2AgAgAygCCCADNgIEQajPAUGozwEpAwBCASABrYaENwMAIAAgAkEIaiIBNgIAIAAgAUF8cWoMAQsgACABagtBBGsgATYCACAAQQRqBUEACwvCAQEDfwJAIAEgAigCECIDBH8gAwUgAhA+DQEgAigCEAsgAigCFCIEa0sEQCACIAAgASACKAIkEQAADwsCQAJAIAIoAlBBAEgNACABRQ0AIAEhAwNAIAAgA2oiBUEBay0AAEEKRwRAIANBAWsiAw0BDAILCyACIAAgAyACKAIkEQAAIgQgA0kNAiABIANrIQEgAigCFCEEDAELIAAhBUEAIQMLIAQgBSABEBIaIAIgAigCFCABajYCFCABIANqIQQLIAQLWQEBfyAAIAAoAkgiAUEBayABcjYCSCAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQALzAIBBH8gASAA/QACAP0LAgAgASgCGCICBEAgASgCECIDBH9BACECA0AgASgCGCACQTRsaigCLCIEBEAgBBAQIAEoAhAhAwsgAkEBaiICIANJDQALIAEoAhgFIAILEBAgAUEANgIYCyABIAAoAhAiAjYCECABIAJBNGwQFCICNgIYIAIEQCABKAIQBEBBACEDA0AgAiADQTRsIgVqIgIgACgCGCAFaiIE/QACAP0LAgAgAiAEKAIwNgIwIAIgBP0AAiD9CwIgIAIgBP0AAhD9CwIQIAEoAhgiAiAFakEANgIsIANBAWoiAyABKAIQSQ0ACwsgASAAKAIUNgIUIAEgACgCICICNgIgIAIEQCABIAIQFCICNgIcIAJFBEAgAUIANwIcDwsgAiAAKAIcIAAoAiAQEhoPCyABQQA2AhwPCyABQQA2AhAgAUEANgIYCwQAQQELxgEBA38DQCAAQQR0IgFBpMcBaiABQaDHAWoiAjYCACABQajHAWogAjYCACAAQQFqIgBBwABHDQALQTAQbRojAEEQayIAJAACQCAAQQxqIABBCGoQDA0AQbDPAUEIIAAoAgxBAnRBBGoQJSIBNgIAIAFFDQBBCCAAKAIIECUiAQRAQbDPASgCACICIAAoAgxBAnRqQQA2AgAgAiABEAtFDQELQbDPAUEANgIACyAAQRBqJABBzM8BQSo2AgBBlNABQdjQATYCAAuQBgIFfwN7IwBBEGsiBiQAAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshAAJAIAMoAgAiBUUEQEEAIQIgBEEBQcATQQAQDwwBCyAAKALQKyEJIAMgBUEBazYCACACIAZBDGpBARARIAkgAUG4CGxqIgcgBigCDCIAQQV2NgKkBiAHIABBH3EiATYCGCACQQFqIQAgAwJ/An8CQAJ/AkACQCABDgIAAwELIAMoAgAMAQsgAygCAEEBdgsiBUHiAE8EfyAGQuGAgICQDDcCBCAGIAU2AgAgBEECQcX4ACAGEA8gBygCGAUgAQsEQCAFIgENAUEADAILIAUEQCAHQRxqIQFBACECA0AgACAGQQxqQQEQESACQeAATQRAIAYoAgwhBCABIAJBA3RqIghBADYCBCAIIARBA3Y2AgALIABBAWohACACQQFqIgIgBUcNAAsLQQAhAiADKAIAIgAgBUkNAyAAIAVrDAILIAdBHGohBEEAIQIDQCAAIAZBDGpBAhARIAJB4ABNBEAgBCACQQN0aiIFIAYoAgwiCEH/D3E2AgQgBSAIQQt2NgIACyAAQQJqIQAgAkEBaiICIAFHDQALIAFBAXQLIQBBACECIAMoAgAiASAASQ0BIAEgAGsLNgIAQQEhAiAHKAIYQQFHDQAgB0EcaiEEIAf9CQIcIQwgBygCICED/QwBAAAAAgAAAAMAAAAEAAAAIQtBACEBA0AgBCABQQN0aiIAQRhqIAwgC/0M//////////////////////2uASIK/RsAQQNu/REgCv0bAUEDbv0cASAK/RsCQQNu/RwCIAr9GwNBA279HAP9sQH9DAAAAAAAAAAAAAAAAAAAAAD9uAEiCv1aAgACIABBEGogCv1aAgABIABBCGogCv1aAgAAIAQgAUEEaiIBQQN0aiIFIAr9WgIAAyAAIAM2AhwgACADNgIUIAAgAzYCDCAFIAM2AgQgC/0MBAAAAAQAAAAEAAAABAAAAP2uASELIAFB4ABHDQALCyAGQRBqJAAgAgufBgEGfyMAQSBrIgYkAAJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQUCQCADKAIAQQRNBEBBACEAIARBAUGdE0EAEA8MAQsgAiAFKALQKyABQbgIbGoiBSIJQQRqQQEQESAFIAUoAgRBAWoiBzYCBCAHQSJPBEAgBkEhNgIEIAYgBzYCACAEQQFB+TkgBhAPQQAhAAwBCyAHIAAoAqABIghNBEAgBiAHNgIYIAYgCDYCFCAGIAE2AhAgBEEBQbT7ACAGQRBqEA8gACAAKAIIQYCAAnI2AghBACEADAELIAJBAWogBUEIakEBEBEgBSAFKAIIQQJqNgIIIAJBAmogBUEMakEBEBEgBSAFKAIMQQJqIgA2AgwCQAJAIAUoAggiAUEKSw0AIABBCksNACAAIAFqQQ1JDQELQQAhACAEQQFBwylBABAPDAELIAJBA2ogBUEQakEBEBEgBS0AEEGAAXEEQEEAIQAgBEEBQYsyQQAQDwwBCyACQQRqIAVBFGpBARARIAUoAhRBAk8EQEEAIQAgBEEBQcoxQQAQDwwBCyADIAMoAgBBBWsiBzYCAEEBIQAgBSgCBCEBIAUtAABBAXFFBEAgAUUNASAFQbAHaiEBIAVBrAZqIQJBACEFA0AgAiAFQQJ0IgBqQQ82AgAgACABakEPNgIAQQEhACAFQQFqIgUgCSgCBEkNAAsMAQsgASAHTQRAAkAgAUUEQEEAIQEMAQsgAkEFaiAGQRxqQQEQESAFIAYoAhwiAEEEdjYCsAcgBSAAQQ9xNgKsBiAFKAIEIgFBAk8EQCAFQbAHaiEHIAVBrAZqIQggAkEGaiEAQQEhBQNAIAAgBkEcakEBEBECQCAGKAIcIgFBEE8EQCABQQ9xIgINAQtBACEAIARBAUHwLUEAEA8MBQsgCCAFQQJ0IgpqIAI2AgAgByAKaiABQQR2NgIAIABBAWohACAFQQFqIgUgCSgCBCIBSQ0ACwsgAygCACEHCyADIAcgAWs2AgBBASEADAELQQAhACAEQQFBnRNBABAPCyAGQSBqJAAgAAtSACABIAAtAAA6AAcgASAALQABOgAGIAEgAC0AAjoABSABIAAtAAM6AAQgASAALQAEOgADIAEgAC0ABToAAiABIAAtAAY6AAEgASAALQAHOgAAC5IBAQR/IAAgATYCoAECQCAAKAJIIgNFDQAgAygCGCIGRQ0AIAAoAgwiBEUNACAEKALQK0UNACADKAIQIgRFBEBBAQ8LQQAhAwNAIAEgACgCDCgC0CsgA0G4CGxqKAIETwRAIAJBAUGixQBBABAPQQAPCyAGIANBNGxqIAE2AihBASEFIANBAWoiAyAERw0ACwsgBQusBwIJfwh+IwBBEGsiCiQAAkAgAkUEQCADQQFB+tUAQQAQDwwBCyACKAIQIgsgACgCSCIGKAIQSQRAIANBAUG1zgBBABAPDAELIAQgACgCaCIFIAAoAmxsIgdPBEAgCiAENgIAIAogB0EBazYCBCADQQFB9/oAIAoQD0EAIQUMAQsgAiAAKAJUIAQgBSAEIAVuIgdsayIIIAAoAlxsaiIFNgIAIAIgBSAGKAIAIgYgBSAGSxsiBjYCACACIAAoAlQgACgCXCAIQQFqbGoiBTYCCCACIAUgACgCSCgCCCIIIAUgCEkbIgg2AgggAiAAKAJYIAAoAmAgB2xqIgU2AgQgAiAFIAAoAkgoAgQiCSAFIAlLGyIJNgIEIAIgACgCWCAAKAJgIAdBAWpsaiIFNgIMIAIgBSAAKAJIKAIMIgcgBSAHSRsiBTYCDCAAKAJIIgwoAhAiBwRAIAWsQgF9IREgCKxCAX0hEiAJrUIBfSETIAatQgF9IRQgDCgCGCEIIAIoAhghBUEAIQYDQCAFIAggBkE0bGooAigiCTYCKCAFIBQgBSgCACIMrSIOfCAOgCIVPgIQIAUgEyAFKAIEIg2tIg58IA6AIhA+AhQgBUJ/IAmtIg6GIg8gEMR9IA6HpyAPIBEgDawiEHwgEH/EfSAOh6drNgIMIAUgDyAVxH0gDoenIA8gEiAMrCIPfCAPf8R9IA6Hp2s2AgggBUE0aiEFIAZBAWoiBiAHRw0ACwsgByALSQRAIAIoAhghBQNAIAUgB0E0bCIGaigCLBAQIAIoAhgiBSAGakEANgIsIAdBAWoiByACKAIQSQ0ACyACIAAoAkgoAhA2AhALIAAoAkwiBQRAIAUQIQsgAEEBQSQQEyIHNgJMQQAhBSAHRQ0AIAIgBxA/IAAgBDYCLCAAKALAAUEXIAMQJEUNACAAKALAASIEKAIAIQYgBCgCCCEHAkAgBgRAQQEhBSAGQQFxIQsgBkEBRgR/QQAFIAZBfnEhCEEAIQYDQAJ/QQAgBUUNABpBACAAIAEgAyAHKAIAEQAARQ0AGiAAIAEgAyAHKAIEEQAAQQBHCyEFIAdBCGohByAGQQJqIgYgCEcNAAsgBUEBcwshBgJAAkAgCwRAIAYNASAAIAEgAyAHKAIAEQAAQQBHIQULIARBADYCACAFQQFxRQ0BDAMLIARBADYCAAsgACgCSBAhQQAhBSAAQQA2AkgMAgsgBEEANgIACyAAIAIQRyEFCyAKQRBqJAAgBQvyAwEFfwJAAkAgACgCPCICRQRAIAEoAhANAUEBDwsgAkE0bBAUIgVFDQEgASgCEARAIAEoAhghAgNAIAIgA0E0bCIEaigCLBAQIAEoAhgiAiAEakEANgIsIANBAWoiAyABKAIQIgRJDQALCyABIAAoAjwEfyAAKAJMKAIYIQNBACECA0AgBSACQTRsaiIEIAMgACgCQCACQQJ0aigCAEE0bCIGaiID/QACAP0LAgAgBCADKAIwNgIwIAQgA/0AAiD9CwIgIAQgA/0AAhD9CwIQIAQgACgCTCgCGCIDIAZqIgYoAiQ2AiQgBCAGKAIsNgIsIAZBADYCLCACQQFqIgIgACgCPCIGSQ0ACyABKAIQBSAECwR/IAAoAkwoAhghAkEAIQMDQCACIANBNGwiBGooAiwQECAAKAJMKAIYIgIgBGpBADYCLCADQQFqIgMgASgCEEkNAAsgACgCPAUgBgs2AhAgASgCGBAQIAEgBTYCGEEBDwsgASgCGCEEIAAoAkwoAhghA0EAIQIDQCAEIAJBNGwiBWoiBCADIAVqKAIkNgIkIAQoAiwQECABKAIYIgQgBWogACgCTCgCGCIDIAVqIgUoAiw2AiwgBUEANgIsIAJBAWoiAiABKAIQSQ0AC0EBDwsgACgCSBAhIABBADYCSEEAC84EAQh/AkAgAkUNAAJAIAAoAqABIgVFDQAgACgCSCIERQ0AIAQoAhBFDQAgBCgCGCgCKCAFRw0AIAIoAhAiCEUNACACKAIYIgYoAigNACAGKAIsDQBBACEEIAhBCE8EQCAIQXhxIQkDQCAGIARBNGxqIAU2AiggBiAEQQFyQTRsaiAFNgIoIAYgBEECckE0bGogBTYCKCAGIARBA3JBNGxqIAU2AiggBiAEQQRyQTRsaiAFNgIoIAYgBEEFckE0bGogBTYCKCAGIARBBnJBNGxqIAU2AiggBiAEQQdyQTRsaiAFNgIoIARBCGohBCAKQQhqIgogCUcNAAsLIAhBB3EiCARAA0AgBiAEQTRsaiAFNgIoIARBAWohBCALQQFqIgsgCEcNAAsLIAIgAxA3DQBBAA8LIAAoAkwiBUUEQCAAQQFBJBATIgU2AkwgBUUNAQsgAiAFED8gACgCwAFBFiADECRFDQAgACgCwAEiBigCACEEIAYoAgghBQJAIAQEQEEBIQcgBEEBcSEIIARBAUYEf0EABSAEQX5xIQlBACEEA0ACf0EAIAdFDQAaQQAgACABIAMgBSgCABEAAEUNABogACABIAMgBSgCBBEAAEEARwshByAFQQhqIQUgBEECaiIEIAlHDQALIAdBAXMLIQQCQAJAIAgEQCAEDQEgACABIAMgBSgCABEAAEEARyEHCyAGQQA2AgAgB0EBcUUNAQwDCyAGQQA2AgALIAAoAkgQISAAQQA2AkhBAA8LIAZBADYCAAsgACACEEchBwsgBwv4BAEGfwJAQQFBMBATIgIEfyACIAAoAsgBIgH9AAMA/QsDACACIAEpAxA3AxAgAiABKAIYIgE2AhggAiABQRhsEBQiATYCHCABRQRAIAIQEEEADwsCQCAAKALIASgCHCIDBEAgASADIAIoAhhBGGwQEhoMAQsgARAQIAJBADYCHAsgAiAAKALIASgCJCIBNgIkIAIgAUEoEBMiATYCKCABRQRAIAIoAhwQECACEBBBAA8LAkAgACgCyAEoAigEQCACKAIkRQ0BA0AgASAFQShsIgNqIAAoAsgBKAIoIANqKAIUIgE2AhQgAUEYbBAUIQEgAigCKCIEIANqIgYgATYCGCABRQRAIAUEf0EAIQEDQCACKAIoIAFBKGxqKAIYEBAgAUEBaiIBIAVHDQALIAIoAigFIAQLEBAMBQsCQCAAKALIASgCKCADaigCGCIEBEAgASAEIAYoAhRBGGwQEhogAigCKCEBDAELIAEQECACKAIoIgEgA2pBADYCGAsgASADaiAAKALIASgCKCADaigCBCIBNgIEIAFBGGwQFCEBIAIoAigiBCADaiIGIAE2AhAgAUUEQCAFBH9BACEBA0AgAUEobCIAIAIoAihqKAIYEBAgAigCKCAAaigCEBAQIAFBAWoiASAFRw0ACyACKAIoBSAECxAQDAULAkAgACgCyAEoAiggA2ooAhAiBARAIAEgBCAGKAIEQRhsEBIaIAIoAighAQwBCyABEBAgAigCKCIBIANqQQA2AhALIAEgA2pCADcCICAFQQFqIgUgAigCJEkNAAsMAQsgARAQIAJBADYCKAsgAgVBAAsPCyACKAIcEBAgAhAQQQALoAYCDn8BeyMAQRBrIggkACAAKAJIKAIQIQ0gCEEBQTgQEyIBNgIMAkAgAUUNACABIAAoAkgoAhAiCTYCGCABIAD9AAJU/QsCACABIAAoAmg2AhAgACgCbCECIAFBADYCNCABIAI2AhQgASAAKAIMIgwoAgA2AiAgASAMKAIENgIkIAEgDCgCCDYCKCABIAwoAhA2AiwgASAJQbgIEBMiADYCMCAABEAgDQRAA0AgDkG4CGwiACABKAIwaiIFIAwoAtArIABqIgT9AAIAIg/9CwIEIAUgBCgCEDYCFCAFIAQoAhQ2AhggD/0bASIAQSBNBEAgBUG0B2ogBEGwB2ogABASGiAFQbAGaiAEQawGaiAEKAIEEBIaCyAFIAQoAhgiADYCHCAFIAQoAqQGNgKoBkEBIQYCQCAAQQFHBEAgBCgCBEEDbCIAQQNrQd8ASw0BIABBAmshBgsgBUGkA2ohCSAFQSBqIQogBEEcaiELQQAhAAJAIAZBCEkNACAEIAZBA3RqQRxqIApLBEAgCyAFIAZBAnRqQaQDakkNAQsgBkF8cSEAQQAhAgNAIAogAkECdCIDaiALIAJBA3RqIgdBHGogB0EUaiAHQQxqIAf9CQIE/VYCAAH9VgIAAv1WAgAD/QsCACADIAlqIAdBGGogB0EQaiAHQQhqIAf9CQIA/VYCAAH9VgIAAv1WAgAD/QsCACACQQRqIgIgAEcNAAsgACAGRg0BCyAAQQFyIQMgBkEBcQRAIAogAEECdCICaiALIABBA3RqIgAoAgQ2AgAgAiAJaiAAKAIANgIAIAMhAAsgAyAGRg0AA0AgCiAAQQJ0IgJqIAsgAEEDdGoiAygCBDYCACACIAlqIAMoAgA2AgAgCiAAQQFqIgNBAnQiAmogCyADQQN0aiIDKAIENgIAIAIgCWogAygCADYCACAAQQJqIgAgBkcNAAsLIAUgBCgCqAY2AqwGIA5BAWoiDiANRw0ACwsgASEDDAELIAhBDGoEQCAIKAIMIgEoAjAiAAR/IAAQECAIKAIMBSABCxAQIAhBADYCDAsLIAhBEGokACADC/kEAQh/IwBBgAJrIgMkACAABEBB/AxBESACEB0gAyAAKAIANgLwASACQZoRIANB8AFqEBYgAyAAKAIENgLgASACQacRIANB4AFqEBYgAyAAKAIINgLQASACQYI3IANB0AFqEBYgAyAAKAIQNgLAASACQf0QIANBwAFqEBYgAUEASgRAA0AgACgC0CshBCADIAc2ArABIAJBog0gA0GwAWoQFiADIAQgB0G4CGxqIgQoAgA2AqABIAJBmREgA0GgAWoQFiADIAQoAgQ2ApABIAJB9DcgA0GQAWoQFiADIAQoAgg2AoABIAJBoDYgA0GAAWoQFiADIAQoAgw2AnAgAkGwNiADQfAAahAWIAMgBCgCEDYCYCACQYgRIANB4ABqEBYgAyAEKAIUNgJQIAJBtjggA0HQAGoQFkHVC0EXIAIQHSAEKAIEBEAgBEGwB2ohBiAEQawGaiEIQQAhBQNAIAggBUECdCIJaigCACEKIAMgBiAJaigCADYCRCADIAo2AkAgAkGLDCADQUBrEBYgBUEBaiIFIAQoAgRJDQALCyACEG4gAyAEKAIYNgIwIAJBwDYgA0EwahAWIAMgBCgCpAY2AiAgAkHxNiADQSBqEBZBASEGQe0LQRQgAhAdAkAgBCgCGEEBRwRAIAQoAgQiBUEATA0BIAVBA2xBAmshBgsgBEEcaiEIQQAhBQNAIAMgCCAFQQN0aikCAEIgiTcDECACQYsMIANBEGoQFiAFQQFqIgUgBkcNAAsLIAIQbiADIAQoAqgGNgIAIAJB4DYgAxAWQZkMQQUgAhAdIAdBAWoiByABRw0ACwtBmgxBBCACEB0LIANBgAJqJAAL5goDCX8BewF+IwBBsAFrIgUkAAJAIAFBgANxBEBBni1BCyACEB0MAQsCQCABQQFxRQ0AIAAoAkgiBkUNACMAQdAAayIDJABB7gxBDSACEB0gA0EAOgBPIANBCToATiADIAYpAgA3AkQgAyADQc4AaiIENgJAIAJBhjkgA0FAaxAWIAMgBikCCDcCNCADIAQ2AjAgAkH1OCADQTBqEBYgAyAGKAIQNgIkIAMgBDYCICACQZM3IANBIGoQFgJAIAYoAhhFDQAgBigCEEUNAANAIAMgA0HOAGoiCjYCECADIAc2AhQgAkGODSADQRBqEBYgBigCGCAHQTRsaiEIIwBBMGsiBCQAIARBCTsALiAEQQk6AC0gBCAIKQIANwIkIAQgBEEtaiIJNgIgIAJBzzYgBEEgahAWIAQgCCgCGDYCFCAEIAk2AhAgAkHFOCAEQRBqEBYgBCAIKAIgNgIEIAQgCTYCACACQao4IAQQFiAEQTBqJAAgAyAKNgIAIAJBlAwgAxAWIAdBAWoiByAGKAIQSQ0ACwtBnAxBAiACEB0gA0HQAGokAAsCQCABQQJxRQ0AIAAoAkhFDQBB+Q1BJCACEB0gBSAAKQJUNwOgASACQecRIAVBoAFqEBYgBSAAKQJcNwOQASACQcURIAVBkAFqEBYgBSAAKQNoNwOAASACQdcRIAVBgAFqEBYgACgCDCAAKAJIKAIQIAIQS0GcDEECIAIQHQsCQCABQQhxRQ0AIAAoAkhFDQAgACgCaCAAKAJsbCIERQ0AIAAoApwBIQMDQCADIAAoAkgoAhAgAhBLIANBjCxqIQMgC0EBaiILIARHDQALCyABQRBxRQ0AIAAoAsgBIQFB0w1BJSACEB0gBSAB/QADAP0LBHAgAkHJKyAFQfAAahAWQcENQREgAhAdAkAgASgCHEUNACABKAIYRQ0AQQAhAwNAIAEoAhwgA0EYbGoiAC8BACEEIAApAwghDSAFIAAoAhA2AmAgBSANNwNYIAUgBDYCUCACQYs4IAVB0ABqEBYgA0EBaiIDIAEoAhhJDQALC0GaDEEEIAIQHQJAIAEoAigiBEUNACABKAIkIgdFDQBBACEDQQAhAAJAIAdBBE8EQCAHQXxxIQADQCAEIANBA3JBKGxqQQRqIAQgA0ECckEobGpBBGogBCADQQFyQShsakEEaiAEIANBKGxq/QkCBP1WAgAB/VYCAAL9VgIAAyAM/a4BIQwgA0EEaiIDIABHDQALIAwgDCAM/Q0ICQoLDA0ODwABAgMAAQID/a4BIgwgDCAM/Q0EBQYHAAECAwABAgMAAQID/a4B/RsAIQMgACAHRg0BCwNAIAQgAEEobGooAgQgA2ohAyAAQQFqIgAgB0cNAAsLIANFDQBBsA1BECACEB0gASgCJARAIAEoAighAEEAIQcDQCAFIAAgB0EobCIEaigCBCIGNgJEIAUgBzYCQCACQdE4IAVBQGsQFiABKAIoIQACQCAGRQ0AQQAhAyAAIARqKAIQRQ0AA0AgASgCKCAEaigCECADQRhsaiIA/QADACEMIAUgACkDEDcDOCAFIAz9CwMoIAUgAzYCICACQaXRACAFQSBqEBYgA0EBaiIDIAZHDQALIAEoAighAAsCQCAAIARqIgYoAhhFDQBBACEDIAYoAhRFDQADQCAAIARqKAIYIANBGGxqIgAvAQAhBiAAKQMIIQ0gBSAAKAIQNgIQIAUgDTcDCCAFIAY2AgAgAkGLOCAFEBYgA0EBaiIDIAEoAigiACAEaigCFEkNAAsLIAdBAWoiByABKAIkSQ0ACwtBmgxBBCACEB0LQZwMQQIgAhAdCyAFQbABaiQAC48CAQN/AkBBAUHoARATIgEEfyABQQE2AgAgAUEBNgK4ASABIAEtALwBQQZyOgC8ASABQQFBjCwQEyIANgIMIABFDQEgAUEBQegHEBMiADYCECAARQ0BIAFCADcDMCABQX82AiwgAUHoBzYCFAJAQQFBMBATIgAEQCAAQQA2AhggAEHkADYCICAAQeQAQRgQEyICNgIcIAINASAAEBALIAFBADYCyAEMAgsgAEEANgIoIAEgADYCyAEgARAzIgA2AsQBIABFDQEgARAzIgA2AsABIABFDQECQBCRAUUNAAsgAUEAEGYiADYC1AEgAEUEQCABQQAQZiIANgLUASAARQ0CCyABBUEACw8LIAEQOEEAC40JAgl/AX4jAEHQAWsiByQAIAAoAkghCQJAAkACQCAAKAJoQQFHDQAgACgCbEEBRw0AIAAoApwBKALcKw0BCyAAKAIIQQhGDQAgBkEBQeHOAEEAEA8MAQsCQCABKAIQIgxFDQAgACgCoAEhCiABKAIYIQsgDEEITwRAIAxBeHEhDwNAIAsgCEE0bGogCjYCKCALIAhBAXJBNGxqIAo2AiggCyAIQQJyQTRsaiAKNgIoIAsgCEEDckE0bGogCjYCKCALIAhBBHJBNGxqIAo2AiggCyAIQQVyQTRsaiAKNgIoIAsgCEEGckE0bGogCjYCKCALIAhBB3JBNGxqIAo2AiggCEEIaiEIIA5BCGoiDiAPRw0ACwsgDEEHcSIMRQ0AA0AgCyAIQTRsaiAKNgIoIAhBAWohCCANQQFqIg0gDEcNAAsLIAIgA3IgBHIgBXJFBEAgBkEEQa8wQQAQDyAAQgA3AhwgACAAKQJoNwIkIAEgCf0AAgD9CwIAIAEgBhA3IQgMAQsgAkEASARAIAcgAjYCACAGQQFBx90AIAcQD0EAIQgMAQsgAiAJKAIIIghLBEAgByAINgIUIAcgAjYCECAGQQFBm+EAIAdBEGoQD0EAIQgMAQsCQCACIAkoAgAiCEkEQCAHIAg2AsQBIAcgAjYCwAEgBkECQfvjACAHQcABahAPIABBADYCHCAJKAIAIQIMAQsgACACIAAoAlRrIAAoAlxuNgIcCyABIAI2AgAgA0EASARAIAcgAzYCICAGQQFBh90AIAdBIGoQD0EAIQgMAQsgAyAJKAIMIgJLBEAgByACNgI0IAcgAzYCMCAGQQFB7t8AIAdBMGoQD0EAIQgMAQsCQCADIAkoAgQiAkkEQCAHIAI2ArQBIAcgAzYCsAEgBkECQcziACAHQbABahAPIABBADYCICAJKAIEIQMMAQsgACADIAAoAlhrIAAoAmBuNgIgCyABIAM2AgRBACEIIARBAEwEQCAHIAQ2AkAgBkEBQcXcACAHQUBrEA8MAQsgBCAJKAIAIgJJBEAgByACNgJUIAcgBDYCUCAGQQFBouMAIAdB0ABqEA8MAQsCQCAEIAkoAggiAksEQCAHIAI2AqQBIAcgBDYCoAEgBkECQcPgACAHQaABahAPIAAgACgCaDYCJCAJKAIIIQQMAQsgACAANQJcIhAgBCAAKAJUa618QgF9IBCAPgIkCyABIAQ2AgggBUEATARAIAcgBTYCYCAGQQFBgtwAIAdB4ABqEA8MAQsgBSAJKAIEIgJJBEAgByACNgJ0IAcgBTYCcCAGQQFB8uEAIAdB8ABqEA8MAQsCQCAFIAkoAgwiAksEQCAHIAI2ApQBIAcgBTYCkAEgBkECQZXfACAHQZABahAPIAAgACgCbDYCKCAJKAIMIQUMAQsgACAANQJgIhAgBSAAKAJYa618QgF9IBCAPgIoCyABIAU2AgwgACAALQBEQQJyOgBEIAEgBhA3IghFBEBBACEIDAELIAcgAf0AAgD9CwSAASAGQQRBtDkgB0GAAWoQDwsgB0HQAWokACAIC5UCAQd/IwBBIGsiBSQAAn8gACgCSCIERQRAIANBAUHF5gBBABAPQQAMAQtBAEEEIAQoAhAQEyIERQ0AGiABBEAgACgCSCEIA0ACQAJAIAIgBkECdGooAgAiByAIKAIQTwRAIAUgBzYCECADQQFB+REgBUEQahAPDAELIAQgB0ECdGoiCSgCAEUNASAFIAc2AgAgA0EBQY0aIAUQDwsgBBAQQQAMAwsgCUEBNgIAIAZBAWoiBiABRw0ACwsgBBAQIAAoAkAQEAJAIAEEQCAAIAFBAnQiBBAUIgM2AkAgA0UEQCAAQQA2AjxBAAwDCyADIAIgBBASGgwBCyAAQQA2AkALIAAgATYCPEEBCyEKIAVBIGokACAKC7wFAQd/IAFBAUEkEBMiBDYCSAJAAkAgBEUNAAJAIAEoAsQBQRIgAxAkBEAgASgCxAFBEyADECQNAQsMAgsgASgCxAEiBygCACEGIAcoAgghBAJAIAYEQEEBIQUgBkEBRwRAIAZBfnEhCQNAAn9BACAFRQ0AGkEAIAEgACADIAQoAgARAABFDQAaIAEgACADIAQoAgQRAABBAEcLIQUgBEEIaiEEIAhBAmoiCCAJRw0ACwsCQAJAIAZBAXEEQCAFRQ0BIAEgACADIAQoAgARAABBAEchBQsgB0EANgIAIAVFDQEMAwsgB0EANgIACwwDCyAHQQA2AgALAkAgASgCwAFBFCADECQEQCABKALAAUEVIAMQJA0BCwwCCyABKALAASIHKAIAIQYgBygCCCEEAkAgBgRAQQEhBSAGQQFxIQkgBkEBRgR/QQAFIAZBfnEhBkEAIQgDQAJ/QQAgBUUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEFIARBCGohBCAIQQJqIgggBkcNAAsgBUULIQYCQAJAIAkEQCAGDQEgASAAIAMgBCgCABEAAEEARyEFCyAHQQA2AgAgBUUNAQwDCyAHQQA2AgALDAMLIAdBADYCAAsgAkEBQSQQEyIANgIAIABFDQAgASgCSCAAED8gASgCyAEgASgCbCABKAJobCIANgIkIABBKBATIQMgASgCyAEiACADNgIoAkAgA0UNACAAKAIkRQRAQQEPC0EAIQQDQCADIARBKGwiBWoiAEEANgIUIABB5AA2AhxB5ABBGBATIQAgBSABKALIASIHKAIoIgNqIAA2AhggAEUNAUEBIQogBEEBaiIEIAcoAiRJDQALDAELIAIoAgAQIUEAIQogAkEANgIACyAKDwsgASgCSBAhIAFBADYCSEEACwIACwQAQQELNAACQCAARQ0AIAFFDQAgACABKAIENgKkASAAIAEoAgA2AqABIAAgASgCuEBBAnE2AuABCwu0BQEIfyAAKAIYIgQoAhAiCUUEQEEADwsgBCgCGCEFIAAoAhQoAgAoAhQhBAJAAkAgAUUEQEEAIQEDQCAFKAIYIQIgBCgCHCAEKAIYQZgBbGoiAEGMAWsoAgAiByAAQZQBaygCACIIayEDIABBkAFrKAIAIABBmAFrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwECyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwEC0F/IQAgAiADbCICIAFBf3NLDQIgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALDAELQQAhASAAKAJARQRAA0AgBSgCGCECIAQoAhwgBCgCGEGYAWxqIgBBBGsoAgAiByAAQQxrKAIAIghrIQMgAEEIaygCACAAQRBrKAIAayEAAkAgByAIRg0AIACtIAOtfkIgiFANAAwECyAAIANsIQMCQEEEIAJBA3YgAkEHcUEAR2oiACAAQQNGGyICRQ0AIAKtIAOtfkIgiFANAAwEC0F/IQAgAiADbCICIAFBf3NLDQIgBEHMAGohBCAFQTRqIQUgASACaiIBIQAgBkEBaiIGIAlHDQALDAELA0AgBSgCGCECIAQoAhwgBCgCGEGYAWxqIgBBjAFrKAIAIgcgAEGUAWsoAgAiCGshAyAAQZABaygCACAAQZgBaygCAGshAAJAIAcgCEYNACAArSADrX5CIIhQDQAMAwsgACADbCEDAkBBBCACQQN2IAJBB3FBAEdqIgAgAEEDRhsiAkUNACACrSADrX5CIIhQDQAMAwtBfyEAIAIgA2wiAiABQX9zSw0BIARBzABqIQQgBUE0aiEFIAEgAmoiASEAIAZBAWoiBiAJRw0ACwsgAA8LQX8L2gQBC38gAARAIAAoAhQiAQRAIAEoAgAiBQRAIAUoAhQhAyAFKAIQBH9BEEERIAAtAChBAXEbIQgDQCADKAIcIgIEQCADKAIgIgFBmAFuIQpBACEJIAFBmAFPBH8DQCACKAIwIgEEQCACKAI0IgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBApIAFBADYCICABKAIkECkgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAjAFIAELEBAgAkEANgIwCyACKAJUIgEEQCACKAJYIgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBApIAFBADYCICABKAIkECkgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAlQFIAELEBAgAkEANgJUCyACKAJ4IgEEQCACKAJ8IgZBKG4hB0EAIQQgBkEoTwR/A0AgASgCIBApIAFBADYCICABKAIkECkgAUEANgIkIAEgCBECACABQShqIQEgBEEBaiIEIAdHDQALIAIoAngFIAELEBAgAkEANgJ4CyACQZgBaiECIAlBAWoiCSAKRw0ACyADKAIcBSACCxAQIANBADYCHAsCQCADKAIoRQ0AIAMoAiQiAUUNACABEBAgA/0MAAAAAAAAAAAAAAAAAAAAAP0LAiQLIAMoAjQQECADQcwAaiEDIAtBAWoiCyAFKAIQSQ0ACyAFKAIUBSADCxAQIAVBADYCFCAAKAIUKAIAEBAgACgCFCIBQQA2AgALIAEQECAAQQA2AhQLIAAoAkQQECAAEBALC8sTARV/IwBBIGsiDyQAIA8gBTYCGCABIAMoAhxBzABsaigCHCADKAIgQZgBbGohEQJAAkAgAygCKA0AIBEoAhhFDQAgEUEcaiEJA0ACQCAJKAIIIAkoAgBHBH8gCSgCDCAJKAIERgVBAQsNACADKAIkIgEgCSgCGEEobk8EQCAIQQFBghVBABAPDAQLIAkoAhQgAUEobGoiASgCIBBiIAEoAiQQYiABKAIUIAEoAhBsIg1FDQAgASgCGCEBIA1BCE8EQCANQXhxIQtBACEKA0AgAUIANwLoAyABQgA3AqgDIAFCADcC6AIgAUIANwKoAiABQgA3AugBIAFCADcCqAEgAUIANwJoIAFCADcCKCABQYAEaiEBIApBCGoiCiALRw0ACwtBACEKIA1BB3EiDUUNAANAIAFCADcCKCABQUBrIQEgCkEBaiIKIA1HDQALCyAJQSRqIQkgDEEBaiIMIBEoAhhJDQALCyAFIQ0CQCACLQAAQQJxRQ0AIAdBBU0EQCAIQQJBsR9BABAPDAELAkAgBS0AAEH/AUYEQCAFLQABQZEBRg0BCyAIQQJB2x9BABAPDAELIA8gBUEGaiINNgIYC0EUEBQiC0UNAAJ/IAAtAGxBAXEEQCAAQShqIQcgACgCKCENIABBLGoMAQsgAi0AiCxBAnEEQCACQbAoaiEHIAIoArAoIQ0gAkG8KGoMAQsgDyAFIAdqIA1rNgIcIA9BGGohByAPQRxqCyISKAIAIQAgC0IANwIMIAsgDTYCCCALIA02AgAgCyAAIA1qNgIEIAtBARAfRQRAIAsQZBogCygCCCALKAIAayEaIAsQLCAaIA1qIQECQCACLQAAQQRxRQ0AIAcoAgAgEigCACABa2pBAU0EQCAIQQJBmCFBABAPDAELAkAgAS0AAEH/AUYEQCABLQABQZIBRg0BCyAIQQJBwiFBABAPDAELIAFBAmohAQsgEiASKAIAIAcoAgAgAWtqNgIAIAcgATYCACAEQQA2AgAgBiAPKAIYIAVrNgIAQQEhFwwBCyARKAIYBEAgEUEcaiEQA0AgAygCJCEAIBAoAhQhAQJAIBAoAgggECgCAEcEfyAQKAIMIBAoAgRGBUEBCw0AIAEgAEEobGoiFCgCFCAUKAIQbCIYRQ0AIBQoAhghCUEAIRUDQAJAAn8gCSgCKEUEQCALIBQoAiAgFSADKAIoQQFqEGAMAQsgC0EBEB8LRQRAIAlBADYCJAwBCyAJKAIoRQRAQQAhAQNAIAEiAEEBaiEBIAsgFCgCJCAVIAAQYEUNAAsgECgCHCEBIAlBAzYCICAJIAE2AhggCSABIABrQQFqNgIcCyAJAn9BASALQQEQH0UNABpBAiALQQEQH0UNABogC0ECEB8iAEEDRwRAIABBA2oMAQsgC0EFEB8iAEEfRwRAIABBBmoMAQsgC0EHEB9BJWoLNgIkQQAhAQNAIAEiAEEBaiEBIAtBARAfDQALIAkgCSgCICAAajYCIAJAAkACfyAJKAIoIgBFBEAgAigC0CsgAygCHEG4CGxqKAIQIQAgCSgCMEUEQCAJKAIAQfABEBciAUUNBCAJIAE2AgAgASAJKAIwQRhsakEAQfABEBUaIAlBCjYCMAsgCSgCACIB/QwAAAAAAAAAAAAAAAAAAAAA/QsCACABQgA3AhBBAUEKQe0AIABBAXEbIABBBHEbIQpBAAwBCyAJKAIAIgEgAEEBayIMQRhsaiIKKAIEIAooAgxHDQEgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIMIABBAWpJBH8gASAMQQpqIgxBGGwQFyIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQFRogCSAMNgIwIAkoAgAFIAELIABBGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCEAJ/QQEgCkEEcQ0AGkHtACAKQQFxRQ0AGkECQQJBASABQQxrKAIAIgpBCkYbIApBAUYbCyEKIAALIQwgASAKNgIMCyAJKAIkIQAgAigC0CsgAygCHEG4CGxqLQAQQcAAcQRAA0AgDEEYbCIOIAkoAgBqIABBASAMGyITNgIQIAkoAiAhFkEAIQogACEBIBNBAk8EQANAIApBAWohCiABQQNLIRsgAUEBdiEBIBsNAAsLIAogFmoiAUEhTwRAIA8gATYCECAIQQFBvPQAIA9BEGoQDwwDCyALIAEQHyEKIAkoAgAiASAOaiIOIAo2AhQgACAOKAIQayIAQQBMDQMgAigC0CsgAygCHEG4CGxqKAIQIQogCSgCMCIOIAxBAmpJBEAgASAOQQpqIg5BGGwQFyIBRQ0DIAkgATYCACABIAkoAjBBGGxqQQBB8AEQFRogCSAONgIwIAkoAgAhAQsgASAMQQFqIgxBGGxqIgH9DAAAAAAAAAAAAAAAAAAAAAD9CwIAIAFCADcCECABAn9BASAKQQRxDQAaQe0AIApBAXFFDQAaQQJBAkEBIAFBDGsoAgAiAUEKRhsgAUEBRhsLNgIMDAALAAsDQCAMQRhsIg4gCSgCAGoiASABKAIMIAEoAgRrIgEgACAAIAFKGyIBNgIQIAkoAiAhE0EAIQogAUECTwRAA0AgCkEBaiEKIAFBA0shHCABQQF2IQEgHA0ACwsgCiATaiIBQSFPBEAgDyABNgIAIAhBAUG89AAgDxAPDAILIAsgARAfIQogCSgCACIBIA5qIg4gCjYCFCAAIA4oAhBrIgBBAEwNAiACKALQKyADKAIcQbgIbGooAhAhCiAJKAIwIg4gDEECakkEQCABIA5BCmoiDkEYbBAXIgFFDQIgCSABNgIAIAEgCSgCMEEYbGpBAEHwARAVGiAJIA42AjAgCSgCACEBCyABIAxBAWoiDEEYbGoiAf0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAUIANwIQIAECf0EBIApBBHENABpB7QAgCkEBcUUNABpBAkECQQEgAUEMaygCACIBQQpGGyABQQFGGws2AgwMAAsACyALECwMBQsgCUFAayEJIBVBAWoiFSAYRw0ACwsgEEEkaiEQIBlBAWoiGSARKAIYSQ0ACwsgCxBkRQRAIAsQLAwBCyALKAIIIAsoAgBrIR0gCxAsIB0gDWohAQJAIAItAABBBHFFDQAgBygCACASKAIAIAFrakEBTQRAIAhBAkGYIUEAEA8MAQsCQCABLQAAQf8BRgRAIAEtAAFBkgFGDQELIAhBAkHCIUEAEA8MAQsgAUECaiEBCyASIBIoAgAgBygCACABa2o2AgAgByABNgIAQQEhFyAEQQE2AgAgBiAPKAIYIAVrNgIACyAPQSBqJAAgFwuWJAIUfw5+AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAJUDgUAAQIDBAoLAkAgACgCNCIGIAAoAsQBIgFJBEAgACgCQCIHIAFBAWpJDQELIAAoAuwBQQFB9D9BABAPDAwLIAAoAixFBEAgACgCJCECQQAhAQwFCyAAQQA2AiwgACgCRCEDQQEhAQwECwJAIAAoAjQiBiAAKALEASIBSQRAIAAoAkAiByABQQFqSQ0BCyAAKALsAUEBQaHAAEEAEA8MCwsgACgCLEUEQCAAKAIkIQRBACEBDAgLIABBADYCLCAAKAIwIQNBASEBDAcLAkAgACgCNCIEIAAoAsQBIgpJBEAgACgCQCIOIApBAWpJDQELIAAoAuwBQQFBqMEAQQAQDwwKCyAAKAIsRQRAIAAoAighCwwGCyAAQgA3AuQBIABBADYCLCAAKALIASEMA0AgDCAHQQR0aiIFKAIIIg8EQCAFKAIMIRJBACEBA0ACQCAPIAFBf3NqIhAgEiABQQR0aiIRKAIAaiIJQR9LDQAgBSgCACITQX8gCXZLDQAgACACIBMgCXQiCSACIAlJGyAJIAIbIgI2AuQBCwJAIBEoAgQgEGoiCUEfSw0AIAUoAgQiEEF/IAl2Sw0AIAAgAyAQIAl0IgkgAyAJSRsgCSADGyIDNgLoAQsgAUEBaiIBIA9HDQALCyAHQQFqIgcgCkcNAAsgAkUNByADRQ0HIAAtAABFBEAgACAAKALQATYCbCAAIAAoAswBNgJkIAAgACgC2AE2AnAgACAAKALUATYCaAsgACgCMCEFQQEhAQwFCwJAIAAoAjQiBSAAKALEASIJSQRAIAAoAkAiEiAJQQFqSQ0BCyAAKALsAUEBQfvAAEEAEA8MCQsgACgCLEUEQCAAKALIASINIAAoAhwiBEEEdGohCyAAKAIoIQgMBAsgAEIANwLkASAAQQA2AiwgACgCyAEhDQNAIA0gBkEEdGoiCigCCCIOBEAgCigCDCEQQQAhAQNAAkAgDiABQX9zaiIRIBAgAUEEdGoiEygCAGoiDEEfSw0AIAooAgAiFEF/IAx2Sw0AIAAgAiAUIAx0IgwgAiAMSRsgDCACGyICNgLkAQsCQCATKAIEIBFqIgxBH0sNACAKKAIEIhFBfyAMdksNACAAIAMgESAMdCIMIAMgDEkbIAwgAxsiAzYC6AELIAFBAWoiASAORw0ACwsgBkEBaiIGIAlHDQALIAJFDQYgA0UNBgJAIAAtAAAEQCAAKAJsIQYMAQsgACAAKALQASIGNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoC0EBIQEMAwsCQCAAKAI0IgYgACgCxAEiAUkEQCAAKAJAIg8gAUEBakkNAQsgACgC7AFBAUHOwABBABAPDAYLIAAoAixFBEAgACgCyAEgACgCHCIGQQR0aiEFIAAoAighB0EAIQEMAgsgACAGNgIcIABBADYCLEEBIQEMAQsDQAJ/AkAgAUUEQCACQQFqIQIMAQsgACADNgIoIAAoAjggA00NCSAAKAIwIQRBAAwBC0EBCyEBA0ACQAJAAkACQCABRQRAIAAgBDYCICAEIAAoAjxPDQEgACAGNgIcIAYhAUEAIQUMBAsgACACNgIkIAAoAkwgAk0EQCAAKAIcIQFBASEFDAQLIAAoAhAgACgCIGwgACgCDCAAKAIobGogACgCFCAAKAIcbGogACgCGCACbGoiASAAKAIITwRADAwLIAAoAgQgAUEBdGoiAS8BAA0BDA0LIAAoAihBAWohAwwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkAgBUUEQCABIAdPDQEgACgCICIFIAAoAsgBIAFBBHRqIg0oAghPDQMgAC0AAEUEQCAAIA0oAgwgBUEEdGoiASgCDCABKAIIbDYCTAsgACgCSCECQQEhAQwFCyAAIAFBAWoiATYCHAwBCyAAKAIgQQFqIQRBACEBDAMLQQAhBQwBC0EBIQUMAAsACwALAAsDQAJ/AkAgAUUEQCAAIAdBAWoiBzYCKAwBCyAGIA9PDQggAEIANwLkASAAKALIASAGQQR0aiIFKAIIIgtFDQggBSgCDCEKQQAhAkEAIQRBACEBA0ACQCALIAFBf3NqIgkgCiABQQR0aiIOKAIAaiIIQR9LDQAgBSgCACIMQX8gCHZLDQAgACAEIAwgCHQiCCAEIAhJGyAIIAQbIgQ2AuQBCwJAIA4oAgQgCWoiCEEfSw0AIAUoAgQiCUF/IAh2Sw0AIAAgAiAJIAh0IgggAiAISRsgCCACGyICNgLoAQsgAUEBaiIBIAtHDQALIARFDQYgAkUNBgJAIAAtAAAEQCAAKAJsIQIMAQsgACAAKALQASICNgJsIAAgACgCzAE2AmQgACAAKALYATYCcCAAIAAoAtQBNgJoC0EADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACACNgLgASACIAAoAnBPDQEgACgCZCENQQAhAQwECyAAKAI4IAdNBEAgACgCICEDQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgB2xqIAAoAhQgBmxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwLCyAAKAIEIAFBAXRqIgEvAQANAQwMCyAAIAZBAWoiBjYCHAwBC0EAIQEMAwtBASEBDAILA0ACQAJAAkAgAAJ/IAFFBEAgACANNgLcASANIAAoAmhPDQIgACgCMAwBCyADQQFqCyIDNgIgIAAoAjwiASAFKAIIIgQgASAESRsgA0sEQCAFKAIAIgEgAa0iHiAEIANBf3NqIgitIhaGIhcgFoinRw0DIAUoAgQiBEJ/IBaIp3EgBEcNAyAErSIVIBaGIhhCAX0iGSAANQLYAXwgGIAhHyAZIAAoAtABIgmtfCAYgCEaIBdCAX0iGyAANQLUAXwgF4AhICAbIAAoAswBIg6tfCAXgCEcIAFCfyAFKAIMIANBBHRqIgsoAgAiCiAIaq0iHYincSABRw0DIAQgFSALKAIEIgEgCGqtIhWGIiEgFYinRw0DIAAoAuABIgStIiIgIYJCAFIEQCAEIAlHDQRCfyAVhkJ/hSAaQv////8PgyAWhoNQDQQLIAAoAtwBIgStIhUgHiAdhoJCAFIEQCAEIA5HDQRCfyAdhkJ/hSAcQv////8PgyAWhoNQDQQLIAsoAggiBEUNAyALKAIMRQ0DIBynIgsgIKdGDQMgGqciCCAfp0YNAyAAIAAoAkQiBzYCKCAAIBUgG3wgF4CnIAp2IAsgCnZrIBkgInwgGICnIAF2IAggAXZrIARsajYCJEEBIQEMBQsgACgC3AEiASAAKALkASIEaiABIARwayENDAELIAAoAuABIgEgACgC6AEiBGogASAEcGshAkEAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIAAgCEEBaiIINgIoDAELIAAgBjYC4AEgACgCcCAGTQ0HIAAoAmQhD0EADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAPNgLcASAPIAAoAmhPDQEgACAFNgIcIAUhBEEAIQEMBAsgACgCOCAITQRAIAAoAiAhB0EBIQEMBAsgACgCECAAKAIgbCAAKAIMIAhsaiAAKAIUIARsaiAAKAIYIAAoAiRsaiIBIAAoAghPBEAMCgsgACgCBCABQQF0aiIBLwEADQEMCwsgACgC4AEiASAAKALoASIGaiABIAZwayEGDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQAJAIAFFBEAgBCASTw0CIAAgACgCMCIHNgIgIA0gBEEEdGohCwwBCyAAIAdBAWoiBzYCIAsgACgCPCIBIAsoAggiAiABIAJJGyAHSwRAIAsoAgAiASABrSIeIAIgB0F/c2oiCq0iFoYiFyAWiKdHDQMgCygCBCICQn8gFoincSACRw0DIAKtIhUgFoYiGEIBfSIZIAA1AtgBfCAYgCEfIBkgACgC0AEiDq18IBiAIRogF0IBfSIbIAA1AtQBfCAXgCEgIBsgACgCzAEiDK18IBeAIRwgAUJ/IAsoAgwgB0EEdGoiAygCACIJIApqrSIdiKdxIAFHDQMgAiAVIAMoAgQiASAKaq0iFYYiISAViKdHDQMgACgC4AEiAq0iIiAhgkIAUgRAIAIgDkcNBEJ/IBWGQn+FIBpC/////w+DIBaGg1ANBAsgACgC3AEiAq0iFSAeIB2GgkIAUgRAIAIgDEcNBEJ/IB2GQn+FIBxC/////w+DIBaGg1ANBAsgAygCCCICRQ0DIAMoAgxFDQMgHKciAyAgp0YNAyAapyIKIB+nRg0DIAAgACgCRCIINgIoIAAgFSAbfCAXgKcgCXYgAyAJdmsgGSAifCAYgKcgAXYgCiABdmsgAmxqNgIkQQEhAQwFCyAAIARBAWoiBDYCHAwBCyAAKALcASIBIAAoAuQBIgJqIAEgAnBrIQ9BACEBDAMLQQAhAQwBC0EBIQEMAAsACwALAAsDQAJ/AkAgAUUEQCAAIAtBAWoiCzYCKAwBCyAAIAU2AiAgACgCPCAFTQ0GIAAoAmwhCEEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACAINgLgASAIIAAoAnBPDQEgACgCZCENQQAhAQwECyAAKAI4IAtNBEAgACgCHCEGQQEhAQwECyAAKAIQIAAoAiBsIAAoAgwgC2xqIAAoAhQgACgCHGxqIAAoAhggACgCJGxqIgEgACgCCE8EQAwJCyAAKAIEIAFBAXRqIgEvAQANAQwKCyAAKAIgQQFqIQUMAQtBACEBDAMLQQEhAQwCCwNAAkACQAJAAkAgAUUEQCAAIA02AtwBIA0gACgCaE8NAiAAIAQ2AhwgBCEGDAELIAAgBkEBaiIGNgIcCyAGIA5JBEAgACgCICIHIAAoAsgBIAZBBHRqIgEoAggiA08NAyABKAIAIgIgAq0iHiADIAdBf3NqIgqtIhaGIhcgFoinRw0DIAEoAgQiA0J/IBaIp3EgA0cNAyADrSIVIBaGIhhCAX0iGSAANQLYAXwgGIAhHyAZIAAoAtABIg+tfCAYgCEaIBdCAX0iGyAANQLUAXwgF4AhICAbIAAoAswBIgmtfCAXgCEcIAJCfyABKAIMIAdBBHRqIgEoAgAiByAKaq0iHYincSACRw0DIAMgFSABKAIEIgIgCmqtIhWGIiEgFYinRw0DIAAoAuABIgOtIiIgIYJCAFIEQCADIA9HDQRCfyAVhkJ/hSAaQv////8PgyAWhoNQDQQLIAAoAtwBIgOtIhUgHiAdhoJCAFIEQCADIAlHDQRCfyAdhkJ/hSAcQv////8PgyAWhoNQDQQLIAEoAggiA0UNAyABKAIMRQ0DIBynIgEgIKdGDQMgGqciCiAfp0YNAyAAIAAoAkQiCzYCKCAAIBUgG3wgF4CnIAd2IAEgB3ZrIBkgInwgGICnIAJ2IAogAnZrIANsajYCJEEBIQEMBQsgACgC3AEiASAAKALkASICaiABIAJwayENDAELIAAoAuABIgEgACgC6AEiAmogASACcGshCEEAIQEMAwtBACEBDAELQQEhAQwACwALAAsACwNAAn8CQCABRQRAIARBAWohBAwBCyAAIAM2AiAgACgCPCADTQ0FIAAoAkQhAkEADAELQQELIQEDQAJAAkACQAJAIAFFBEAgACACNgIoIAIgACgCOE8NASAAIAY2AhwgBiEBQQAhBQwECyAAIAQ2AiQgACgCTCAETQRAIAAoAhwhAUEBIQUMBAsgACgCECAAKAIgbCAAKAIMIAAoAihsaiAAKAIUIAAoAhxsaiAAKAIYIARsaiIBIAAoAghPBEAMCAsgACgCBCABQQF0aiIBLwEADQEMCQsgACgCIEEBaiEDDAELQQAhAQwDC0EBIQEMAgsDQAJAAkACQCAFRQRAIAEgB08NASAAKAIgIgUgACgCyAEgAUEEdGoiDSgCCE8NAyAALQAARQRAIAAgDSgCDCAFQQR0aiIBKAIMIAEoAghsNgJMCyAAKAJIIQRBASEBDAULIAAgAUEBaiIBNgIcDAELIAAoAihBAWohAkEAIQEMAwtBACEFDAELQQEhBQwACwALAAsAC0EADwsgACgC7AFBAUGaCkEAEA8LQQAPCyABQQE7AQBBAQuRCwEKfwJAIAEoAgAgBEEDbCIMdiIGQZCAgAFxDQAgACAAQRxqIg4gACgCbCAGQe8DcWotAABBAnRqIgo2AmggACAAKAIEIAooAgAiCSgCACIIayIGNgIEAkAgCCAAKAIAIgdBEHZLBEAgCSgCBCELIAAgCDYCBCAKIAlBCEEMIAYgCEkiBhtqKAIANgIAIAsgC0UgBhshCSAAKAIIIQYDQAJAIAYNACAAKAIQIgZBAWohCyAGLQABIQogBi0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQYMAgsgACALNgIQIAcgCkEJdGohB0EHIQYMAQsgACALNgIQQQghBiAHIApBCHRqIQcLIAAgBkEBayIGNgIIIAAgB0EBdCIHNgIAIAAgCEEBdCIINgIEIAhBgIACSQ0ACyAIIQYMAQsgACAHIAhBEHRrIgc2AgAgBkGAgAJxRQRAIAkoAgQhCyAKIAlBDEEIIAYgCEkiCBtqKAIANgIAIAtFIAsgCBshCSAAKAIIIQgDQAJAIAgNACAAKAIQIghBAWohCyAILQABIQogCC0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAHQYD+A2ohB0EIIQgMAgsgACALNgIQIAcgCkEJdGohB0EHIQgMAQsgACALNgIQQQghCCAHIApBCHRqIQcLIAAgCEEBayIINgIIIAAgB0EBdCIHNgIAIAAgBkEBdCIGNgIEIAZBgIACSQ0ACwwBCyAJKAIEIQkLIAlFDQAgACAOIAEoAgQgDEERanZBBHEgAUEEayINKAIAIAxBE2p2QQFxIAEoAgAiCCAMQRBqdkHAAHEgCCAMdkGqAXFyIAggDEEMakEOIAQbdkEQcXJyciIPQdC5AWotAABBAnRqIgs2AmggACAGIAsoAgAiCigCACIIayIGNgIEAkAgCCAHQRB2SwRAIAooAgQhCSAAIAg2AgQgCyAKQQhBDCAGIAhJIgYbaigCADYCACAJIAlFIAYbIQogACgCCCEGA0ACQCAGDQAgACgCECIGQQFqIQsgBi0AASEJIAYtAABB/wFGBEAgCUGQAU8EQCAAIAAoAgxBAWo2AgwgB0GA/gNqIQdBCCEGDAILIAAgCzYCECAHIAlBCXRqIQdBByEGDAELIAAgCzYCEEEIIQYgByAJQQh0aiEHCyAAIAZBAWsiBjYCCCAAIAdBAXQiBzYCACAAIAhBAXQiCDYCBCAIQYCAAkkNAAsMAQsgACAHIAhBEHRrIgk2AgAgBkGAgAJxRQRAIAooAgQhByALIApBDEEIIAYgCEkiCBtqKAIANgIAIAdFIAcgCBshCiAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohCyAHLQABIQggBy0AAEH/AUYEQCAIQZABTwRAIAAgACgCDEEBajYCDCAJQYD+A2ohCUEIIQcMAgsgACALNgIQIAkgCEEJdGohCUEHIQcMAQsgACALNgIQQQghByAJIAhBCHRqIQkLIAAgB0EBayIHNgIIIAAgCUEBdCIJNgIAIAAgBkEBdCIGNgIEIAZBgIACSQ0ACwwBCyAKKAIEIQoLIAJBACADayADIAogD0HQuwFqLQAAcyIDGzYCACANIA0oAgBBICAMdHI2AgAgASABKAIAIANBE3RBEHIgDHRyNgIAIAEgASgCBEEIIAx0cjYCBCAEIAVyRQRAIAFBfiAAKAJ8a0ECdGoiAiACKAIEQYCAAnI2AgQgAiACKAIAIANBH3RyQYCABHI2AgAgAkEEayICIAIoAgBBgIAIcjYCAAsgBEEDRw0AIAEgACgCfEECdGoiAEEEaiAAKAIEQQRyNgIAIAAgACgCDEEBcjYCDCAAIAAoAgggA0ESdHJBAnI2AggLC6sLAQl/AkAgASgCACAEQQNsIg12IgdBkICAAXENACAHQe8DcSIHRQ0AIAAgAEEcaiIOIAAoAmwgB2otAABBAnRqIgs2AmggACAAKAIEIAsoAgAiCigCACIJayIHNgIEAkAgCSAAKAIAIghBEHZLBEAgCigCBCEMIAAgCTYCBCALIApBCEEMIAcgCUkiBxtqKAIANgIAIAwgDEUgBxshCiAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohDCAHLQABIQsgBy0AAEH/AUYEQCALQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQcMAgsgACAMNgIQIAggC0EJdGohCEEHIQcMAQsgACAMNgIQQQghByAIIAtBCHRqIQgLIAAgB0EBayIHNgIIIAAgCEEBdCIINgIAIAAgCUEBdCIJNgIEIAlBgIACSQ0ACyAJIQcMAQsgACAIIAlBEHRrIgg2AgAgB0GAgAJxRQRAIAooAgQhDCALIApBDEEIIAcgCUkiCRtqKAIANgIAIAxFIAwgCRshCiAAKAIIIQkDQAJAIAkNACAAKAIQIglBAWohDCAJLQABIQsgCS0AAEH/AUYEQCALQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQkMAgsgACAMNgIQIAggC0EJdGohCEEHIQkMAQsgACAMNgIQQQghCSAIIAtBCHRqIQgLIAAgCUEBayIJNgIIIAAgCEEBdCIINgIAIAAgB0EBdCIHNgIEIAdBgIACSQ0ACwwBCyAKKAIEIQoLAkAgCkUNACAAIA4gASgCBCANQRFqdkEEcSABQQRrIg8oAgAgDUETanZBAXEgASgCACIJIA1BEGp2QcAAcSAJIA12QaoBcXIgCSANQQxqQQ4gBBt2QRBxcnJyIgpB0LkBai0AAEECdGoiDDYCaCAAIAcgDCgCACILKAIAIglrIgc2AgQgCkHQuwFqLQAAIQ4CQCAJIAhBEHZLBEAgCygCBCEKIAAgCTYCBCAMIAtBCEEMIAcgCUkiBxtqKAIANgIAIAogCkUgBxshCyAAKAIIIQcDQAJAIAcNACAAKAIQIgdBAWohDCAHLQABIQogBy0AAEH/AUYEQCAKQZABTwRAIAAgACgCDEEBajYCDCAIQYD+A2ohCEEIIQcMAgsgACAMNgIQIAggCkEJdGohCEEHIQcMAQsgACAMNgIQQQghByAIIApBCHRqIQgLIAAgB0EBayIHNgIIIAAgCEEBdCIINgIAIAAgCUEBdCIJNgIEIAlBgIACSQ0ACwwBCyAAIAggCUEQdGsiCjYCACAHQYCAAnFFBEAgCygCBCEIIAwgC0EMQQggByAJSSIJG2ooAgA2AgAgCEUgCCAJGyELIAAoAgghCANAAkAgCA0AIAAoAhAiCEEBaiEMIAgtAAEhCSAILQAAQf8BRgRAIAlBkAFPBEAgACAAKAIMQQFqNgIMIApBgP4DaiEKQQghCAwCCyAAIAw2AhAgCiAJQQl0aiEKQQchCAwBCyAAIAw2AhBBCCEIIAogCUEIdGohCgsgACAIQQFrIgg2AgggACAKQQF0Igo2AgAgACAHQQF0Igc2AgQgB0GAgAJJDQALDAELIAsoAgQhCwsgAkEAIANrIAMgCyAOcyICGzYCACAPIA8oAgBBICANdHI2AgAgASABKAIAIAJBE3RBEHIgDXRyNgIAIAEgASgCBEEIIA10cjYCBCAEIAZyRQRAIAEgBUECdGsiACAAKAIEQYCAAnI2AgQgACAAKAIAIAJBH3RyQYCABHI2AgAgAEEEayIAIAAoAgBBgIAIcjYCAAsgBEEDRw0AIAEgBUECdGoiACAAKAIEQQFyNgIEIAAgACgCACACQRJ0ckECcjYCACAAQQRrIgAgACgCAEEEcjYCAAsgASABKAIAQYCAgAEgDXRyNgIACwutAQAgAEHwnQE2AmQgAEHwnQE2AmAgAEHwnQE2AlwgAEHwnQE2AlggAEHwnQE2AlQgAEHwnQE2AlAgAEHwnQE2AkwgAEHwnQE2AkggAEHwnQE2AkQgAEHwnQE2AkAgAEHwnQE2AjwgAEHwnQE2AjggAEHwnQE2AjQgAEHwnQE2AjAgAEHwnQE2AiwgAEHwnQE2AiggAEHwnQE2AiQgAEHwnQE2AiAgAEHwnQE2AhwLkgYCCX8EfiAAIAE2AgAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAwggACADNgIcIAAgAkEBayIFNgIYIAFBA3EhCgJ/IAJBAEwEQCABIQQgAwwBCyAAIAFBAWoiBDYCACABLQAACyEBQQghByAAQQg2AhAgACABrSINNwMIIAAgDUL/AYMiDkL/AVEiCTYCFAJAIApBA0YNACAAIAJBAmsiCDYCGAJ/IAJBAkgEQCAEIQEgAwwBCyAAIARBAWoiATYCACAELQAACyEEIABBD0EQIA5C/wFRGyIHNgIQIAAgBK0iDkL/AYMiD0L/AVEiCTYCFCAAIA5CCIYgDYQiDTcDCCAKQQJGBEAgASEEIAUhAiAIIQUMAQsgACACQQNrIgs2AhggAAJ/IAJBA0gEQCABIQYgAwwBCyAAIAFBAWoiBjYCACABLQAAC60iDkL/AYMiEEL/AVEiCTYCFCAAQQdBCCAPQv8BURsgB2oiATYCECAAIA4gB62GIA2EIg03AwggCkEBRgRAIAYhBCABIQcgCCECIAshBQwBCyAAIAJBBGsiBTYCGCAAAn8gAkEESARAIAYhBCADDAELIAAgBkEBaiIENgIAIAYtAAALrSIOQv8Bg0L/AVEiCTYCFCAAQQdBCCAQQv8BURsgAWoiBzYCECAAIA4gAa2GIA2EIg03AwggCyECCwJAIAJBBU4EQCAEKAIAIQMgACACQQVrNgIYIAAgBEEEajYCAAwBC0EAIQFBf0EAIAMbIQMgAkECSA0AA0AgACAEQQFqIgI2AgAgBC0AACEEIAAgBUEBayIGNgIYIANB/wEgAXRBf3NxIAQgAXRyIQMgAUEIaiEBIAVBAUshDCACIQQgBiEFIAwNAAsLIAAgA0EYdiIBQf8BRjYCFCAAQQdBCCAJGyICQQdBCCADQf8BcSIEQf8BRhtqIgVBB0EIIANBCHZB/wFxIgZB/wFGG2oiCEEHQQggA0EQdkH/AXEiA0H/AUYbIAdqajYCECAAIAYgAnQgAyAFdHIgASAIdHIgBHKtIAethiANhDcDCAu2BQISfwJ+An8gACgCHCABQZgBbGoiAkGQAWsoAgAgAkGYAWsoAgBrIgMhBSACQYwBaygCACACQZQBaygCAGsiAiEGQcAAIAMgA0HAAE8bIQNBwAAgAiACQcAATxshBAJAIAVFDQAgBkUNACADRQ0AIARFDQBBfyAEbkECdiADSQ0AQQFBHBATIgIgBDYCDCACIAM2AgggAiAGNgIEIAIgBTYCACACIAStIhQgBq18QgF9IBSAIhSnIgQ2AhQgAiADrSIVIAWtfEIBfSAVgCIVpyIDNgIQAkAgFEL/////D4MgFUL/////D4N+QiCIpw0AIAJBBCADIARsEBMiAzYCGCADRQ0AIAIMAgsgAhAQC0EACyIJRQRAQQAPCwJAIAEEQANAIA5BmAFsIg8gACgCHGoiBSgCGCICBEAgBUEcaiEQIAUoAhQhAyAFKAIQIQRBACEKA0AgAyAEbARAIBAgCkEkbGohBkEAIQsDQCAGKAIUIAtBKGxqIggoAhQiAiAIKAIQIgdsBEBBACEEA0AgCCgCGCAEQQZ0aiIDKAI8IhEEQCADKAIMIQcgAygCFCESIAMoAhAhDCADKAIIIhMgBigCAGshAyAGKAIQIg1BAXEEQCAAKAIcIA9qIgJBkAFrKAIAIANqIAJBmAFrKAIAayEDCyAHIAYoAgRrIQIgDUECcQRAIAIgACgCHCAPaiINQYwBaygCAGogDUGUAWsoAgBrIQILIAkgAyACIAMgDCATayIMaiASIAdrIAJqIBFBASAMQQAQJkUNCSAIKAIQIQcgCCgCFCECCyAEQQFqIgQgAiAHbEkNAAsgBSgCECEEIAUoAhQhAwsgC0EBaiILIAMgBGxJDQALIAUoAhghAgsgCkEBaiIKIAJJDQALCyAOQQFqIg4gAUcNAAsLIAkPCyAJECNBAAvQDAIQfwZ7IAAoAggiCyAAKAIEaiEHAkAgACgCDEUEQCAHQQJIDQEgASgCACABIAtBAnRqIg0oAgAiBEEBakEBdWshAyAAKAIAIQYCQCAHQQRJBEAgBCECDAELIAdBBGsiAEEBdiIJQQFqIQwCQCAAQRZJBEBBASEADAELIAYgASALQQJ0aiIFIAlBAnQiAmpBCGpJIAYgCUEDdGpBCGoiACAFQQRqS3EEQEEBIQAMAQsgBiABIAJqQQhqSSABQQRqIABJcQRAQQEhAAwBCyAMQfz///8HcSIFQQFyIQAgBUEBdCEIIAT9ESESIAP9ESET/QwAAAAAAgAAAAQAAAAGAAAAIRZBACECA0AgASACQQJ0QQRyIgNq/QACACEVIAMgDWr9AAIAIRQgBiACQQN0aiIDIBP9WgIAAyADQQhqIBUgFCASIBT9DQwNDg8QERITFBUWFxgZGhsiFf2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIhL9WgIAACADQRBqIBL9WgIAASADQRhqIBL9WgIAAiAGIBb9DAEAAAABAAAAAQAAAAEAAAD9UCIX/RsAQQJ0aiASIBMgEv0NDA0ODxAREhMUFRYXGBkaG/2uAUEB/awBIBX9rgEiE/1aAgAAIAYgF/0bAUECdGogE/1aAgABIAYgF/0bAkECdGogE/1aAgACIAYgF/0bA0ECdGogE/1aAgADIBb9DAgAAAAIAAAACAAAAAgAAAD9rgEhFiASIRMgFCESIAJBBGoiAiAFRw0ACyAS/RsDIQIgE/0bAyEDIAUgDEYNASACIQQLA0AgASAAQQJ0IgJqKAIAIQkgAiANaigCACECIAYgCEECdGoiBSADNgIAIAUgAyAJIAIgBGpBAmpBAnVrIgNqQQF1IARqNgIEIAhBAmohCCAAIAxHIRAgAiEEIABBAWohACAQDQALCyAGIAhBAnRqIAM2AgBBfCEAIAdBAXEEfyAGIAdBAWsiAEECdGogASAAQQF0aigCACACQQFqQQF1ayIANgIAIAAgA2pBAXUhA0F4BUF8CyAGIAdBAnQiAGpqIAIgA2o2AgAgASAGIAAQEhoPCwJAAkACQCAHQQFrDgIAAQILIAEgASgCAEECbTYCAA8LIAAoAgAiBCABKAIAIAEgC0ECdGoiAygCAEEBakEBdWsiADYCBCAEIAAgAygCAGo2AgAgASAEKQIANwIADwsgB0EDSA0AIAAoAgAiCiABKAIAIAEgC0ECdGoiDigCBCIEIA4oAgAiAGpBAmpBAnVrIgMgAGo2AgBBASEIAkAgB0ECayIGIAdBAXEiDEUiAGtBAkkEQCAEIQIMAQsgByAAa0EEayIAQQF2IgJBAWohDwJAAkAgAEEWSQ0AIApBBGoiBSABIAJBAnQiAGpBCGpJIAogAkEDdGpBDGoiAiABQQRqS3ENACAFIAAgASALQQJ0aiIAakEMakkgAEEIaiACSXENACAPQXxxIgVBAXIhACAFQQF0QQFyIQggBP0RIRMgA/0RIRJBACECA0AgCiACQQN0aiIEIAEgAkECdCIDav0AAgQgEyADIA5q/QACCCIT/Q0MDQ4PEBESExQVFhcYGRobIhUgE/2uAf0MAgAAAAIAAAACAAAAAgAAAP2uAUEC/awB/bEBIhQgFCASIBT9DQwNDg8QERITFBUWFxgZGhv9rgFBAf2sASAV/a4BIhX9DQQFBgcYGRobCAkKCxwdHh/9CwIUIAQgEiAV/Q0MDQ4PEBESEwABAgMUFRYXIBT9DQABAgMEBQYHEBESEwwNDg/9CwIEIBQhEiACQQRqIgIgBUcNAAsgE/0bAyECIBL9GwMhAyAFIA9GDQIgAiEEDAELQQEhAAsDQCABIABBAnRqKAIAIQ0gDiAAQQFqIgVBAnRqKAIAIQIgCiAIQQJ0aiIJIAM2AgAgCSADIA0gAiAEakECakECdWsiA2pBAXUgBGo2AgQgCEECaiEIIAAgD0chESACIQQgBSEAIBENAAsLIAogCEECdGogAzYCAAJAIAxFBEAgCiAGQQJ0aiABIAdBAXRqQQRrKAIAIAJBAWpBAXVrIgAgA2pBAXUgAmo2AgAMAQsgAiADaiEACyAKIAdBAnQiA2pBBGsgADYCACABIAogAxASGgsLoAcDA30DewJ/IANBCE8EQCADQQN2IQsDQCAB/QAEACEHIAAgAP0ABAAiCCAC/QAEACIJ/Qy8dLM/vHSzP7x0sz+8dLM//eYB/eQB/QsEACABIAggB/0MzzGwPs8xsD7PMbA+zzGwPv3mAf3lASAJ/Qzh0TY/4dE2P+HRNj/h0TY//eYB/eUB/QsEACACIAggB/0M5dDiP+XQ4j/l0OI/5dDiP/3mAf3kAf0LBAAgAf0ABBAhByAAIAD9AAQQIgggAv0ABBAiCf0MvHSzP7x0sz+8dLM/vHSzP/3mAf3kAf0LBBAgASAIIAf9DM8xsD7PMbA+zzGwPs8xsD795gH95QEgCf0M4dE2P+HRNj/h0TY/4dE2P/3mAf3lAf0LBBAgAiAIIAf9DOXQ4j/l0OI/5dDiP+XQ4j/95gH95AH9CwQQIAJBIGohAiABQSBqIQEgAEEgaiEAIApBAWoiCiALRw0ACwsCQCADQQdxIgNFDQAgASoCACEEIAAgAioCACIGQ7x0sz+UIAAqAgAiBZI4AgAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIAIAIgBSAEQ+XQ4j+UkjgCACADQQFGDQAgASoCBCEEIAAgAioCBCIGQ7x0sz+UIAAqAgQiBZI4AgQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIEIAIgBSAEQ+XQ4j+UkjgCBCADQQJGDQAgASoCCCEEIAAgAioCCCIGQ7x0sz+UIAAqAggiBZI4AgggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIIIAIgBSAEQ+XQ4j+UkjgCCCADQQNGDQAgASoCDCEEIAAgAioCDCIGQ7x0sz+UIAAqAgwiBZI4AgwgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIMIAIgBSAEQ+XQ4j+UkjgCDCADQQRGDQAgASoCECEEIAAgAioCECIGQ7x0sz+UIAAqAhAiBZI4AhAgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIQIAIgBSAEQ+XQ4j+UkjgCECADQQVGDQAgASoCFCEEIAAgAioCFCIGQ7x0sz+UIAAqAhQiBZI4AhQgASAFIARDzzGwvpSSIAZD4dE2v5SSOAIUIAIgBSAEQ+XQ4j+UkjgCFCADQQZGDQAgASoCGCEEIAAgAioCGCIGQ7x0sz+UIAAqAhgiBZI4AhggASAFIARDzzGwvpSSIAZD4dE2v5SSOAIYIAIgBSAEQ+XQ4j+UkjgCGAsL4AECBn8DewJAIANFDQAgA0EETwRAIANBfHEhBgNAIAAgBEECdCIFaiIHIAf9AAIAIAIgBWoiB/0AAgAiCyABIAVqIgX9AAIAIgz9rgFBAv2sAf2xASIKIAv9rgH9CwIAIAUgCv0LAgAgByAKIAz9rgH9CwIAIARBBGoiBCAGRw0ACyADIAZGDQELA0AgACAGQQJ0IgRqIgUgBSgCACACIARqIgUoAgAiByABIARqIggoAgAiCWpBAnVrIgQgB2o2AgAgCCAENgIAIAUgBCAJajYCACAGQQFqIgYgA0cNAAsLC90BAQR/IwBBgAFrIgYkACAGIQUCQCABKAIMIAJBBHRqIgIoAgAiBEUEQCACIQEMAQsDQCAFIAI2AgAgBUEEaiEFIAQiASICKAIAIgQNAAsLQQAhBANAIAEoAggiAiAESARAIAEgBDYCCCAEIQILAkAgAiADTg0AA0AgAiABKAIETg0BAkAgAEEBEB8EQCABIAI2AgQMAQsgAkEBaiECCyACIANIDQALCyABIAI2AgggBSAGRwRAIAVBBGsiBSgCACEBIAIhBAwBCwsgASgCBCEHIAZBgAFqJAAgByADSAv9BgELfyMAQYACayIKJAACQCAARQRAQQAhAAwBCwJAIAEgACgCAEYEQCAAKAIEIAJGDQELIAAgAjYCBCAAIAE2AgAgCiACNgIAIAogATYCgAEgAiEEIAEhBQNAIAogByIMQQFqIgdBAnQiCGogBEEBakECbSIJNgIAIApBgAFqIAhqIAVBAWpBAm0iCDYCACAGIAQgBWwiC2ohBiAJIQQgCCEFIAtBAUsNAAsgACAGNgIIAkACQAJAAkAgBkUEQCAAKAIMIgRFDQIgAEEMaiEFDAELIAZBBHQiBCAAKAIQTQ0DIAAoAgwgBBAXIgENAiADQQFBmjFBABAPIABBDGoiBSgCACIERQ0BCyAEEBAgBUEANgIACyAAEBBBACEADAMLIAAgATYCDCABIAAoAhAiAmpBACAEIAJrEBUaIAAgBDYCECAAKAIEIQIgACgCACEBCyAAKAIMIQUgDARAQQAhAyAFIAEgAmxBBHRqIgQhBgNAAkAgCiADQQJ0IgFqKAIAIghBAEwNACAIQQFrIQtBACEJAkACQCAKQYABaiABaigCACICQQBMBEAgCEEBcSENQQAhByAIQQFHDQEgBiEBDAILA0AgBiEBIAIhBgNAAkAgBSAENgIAIAZBAUYEQCAFQRBqIQUgBEEQaiEEDAELIAUgBDYCECAEQRBqIQQgBUEgaiEFIAZBAkohDiAGQQJrIQYgDg0BCwsgBCABIAJBBHRqIAkgCSALRnJBAXEiBxshBiAEIAEgBxshBCAJQQFqIgkgCEcNAAsMAgsgCEH+////B3EhCANAIAcgC0YhASAHQQJqIQcgBCAGIAEbIgQhBiAEIQEgCUECaiIJIAhHDQALCyANRQRAIAQhBgwBCyAEIAEgAkEEdGogByAHIAtGckEBcSICGyEGIAQgASACGyEECyADQQFqIgMgDEcNAAsLIAVBADYCAAsgACgCCCIBRQ0AIAAoAgwhBCABQQRPBEAgAUF8cSECQQAhBQNAIARBADYCPCAEQucHNwI0IARBADYCLCAEQucHNwIkIARBADYCHCAEQucHNwIUIARBADYCDCAEQucHNwIEIARBQGshBCAFQQRqIgUgAkcNAAsLIAFBA3EiAUUNAEEAIQUDQCAEQQA2AgwgBELnBzcCBCAEQRBqIQQgBUEBaiIFIAFHDQALCyAKQYACaiQAIAALsQEBA38CQCAARQ0AIAAoAggiAUUNACAAKAIMIQAgAUEETwRAIAFBfHEhAwNAIABBADYCPCAAQucHNwI0IABBADYCLCAAQucHNwIkIABBADYCHCAAQucHNwIUIABBADYCDCAAQucHNwIEIABBQGshACACQQRqIgIgA0cNAAsLIAFBA3EiAUUNAEEAIQIDQCAAQQA2AgwgAELnBzcCBCAAQRBqIQAgAkEBaiICIAFHDQALCwv7BQEQfyMAQYACayIIJAACf0EBQRQQEyIGRQRAIAJBAUH0MEEAEA9BAAwBCyAGIAE2AgQgBiAANgIAIAggATYCACAIIAA2AoABA0AgCCAFIg1BAWoiBUECdCIHaiABQQFqQQJtIgM2AgAgCEGAAWogB2ogAEEBakECbSIHNgIAIAQgACABbCIJaiEEIAMhASAHIQAgCUEBSw0ACyAGIAQ2AgggBEUEQCAGEBBBAAwBCyAGIARBEBATIgM2AgwgA0UEQCACQQFB2hpBABAPIAYQEEEADAELIAYgBigCCCILQQR0NgIQIAMhACANBEAgAyAGKAIEIAYoAgBsQQR0aiIEIQEDQAJAIAggDkECdCICaigCACIJQQBMDQAgCUEBayEMQQAhBwJAIAhBgAFqIAJqKAIAIgJBAEwEQEEAIQUgCUEBRwRAIAlB/v///wdxIQoDQCAFIAxGIQ8gBUECaiEFIAEgBCAPGyIEIQEgB0ECaiIHIApHDQALCyAJQQFxDQEgBCEBDAILA0AgBCEFIAIhBANAAkAgACABNgIAIARBAUYEQCAAQRBqIQAgAUEQaiEBDAELIAAgATYCECABQRBqIQEgAEEgaiEAIARBAkohECAEQQJrIQQgEA0BCwsgASAFIAJBBHRqIAcgByAMRnJBAXEiChshBCABIAUgChshASAHQQFqIgcgCUcNAAsMAQsgASAEIAJBBHRqIAUgBSAMRnJBAXEiBRshESABIAQgBRshASARIQQLIA5BAWoiDiANRw0ACwsgAEEANgIAAkAgC0UNACALQQRPBEAgC0F8cSEAQQAhAQNAIANBADYCPCADQucHNwI0IANBADYCLCADQucHNwIkIANBADYCHCADQucHNwIUIANBADYCDCADQucHNwIEIANBQGshAyABQQRqIgEgAEcNAAsLIAtBA3EiAEUNAEEAIQEDQCADQQA2AgwgA0LnBzcCBCADQRBqIQMgAUEBaiIBIABHDQALCyAGCyESIAhBgAJqJAAgEgtTAQF/An8gAC0ADEH/AUYEQCAAQoD+g4DwADcCDEEAIAAoAggiASAAKAIETw0BGiAAIAFBAWo2AgggACABLQAAQYD+A3I2AgwLIABBADYCEEEBCwt+AgF/AX4gAL0iA0I0iKdB/w9xIgJB/w9HBHwgAkUEQCABIABEAAAAAAAAAABhBH9BAAUgAEQAAAAAAADwQ6IgARBlIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLSQEBfwJAQQFBLBATIgEEQCABQQA2AhACQCAAQQBMBEAgAUEBQQgQEyIANgIkIABFDQEMAwsgAUEANgIMCyABEBALQQAhAQsgAQuRAgAgAEUEQEEADwsCfwJAIAFB/wBNDQACQEGU0AEoAgAoAgBFBEAgAUGAf3FBgL8DRg0CDAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIMAwsgAUGAQHFBgMADRyABQYCwA09xRQRAIAAgAUE/cUGAAXI6AAIgACABQQx2QeABcjoAACAAIAFBBnZBP3FBgAFyOgABQQMMAwsgAUGAgARrQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQMAwsLQZTHAUEZNgIAQX8MAQsgACABOgAAQQELC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAwALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC3MBBn8gACgCACIDLAAAQTBrIgFBCUsEQEEADwsDQEF/IQQgAkHMmbPmAE0EQEF/IAEgAkEKbCIFaiABIAVB/////wdzSxshBAsgACADQQFqIgU2AgAgAywAASEGIAQhAiAFIQMgBkEwayIBQQpJDQALIAILtBQCFX8BfiMAQUBqIggkACAIIAE2AjwgCEEnaiEWIAhBKGohEQJAAkACQAJAA0BBACEHA0AgASENIAcgDkH/////B3NKDQIgByAOaiEOAkACQAJAAkAgASIHLQAAIgsEQANAAkACQCALQf8BcSIBRQRAIAchAQwBCyABQSVHDQEgByELA0AgCy0AAUElRwRAIAshAQwCCyAHQQFqIQcgCy0AAiEZIAtBAmoiASELIBlBJUYNAAsLIAcgDWsiByAOQf////8HcyIXSg0JIAAEQCAAIA0gBxAZCyAHDQcgCCABNgI8IAFBAWohB0F/IRACQCABLAABQTBrIglBCUsNACABLQACQSRHDQAgAUEDaiEHQQEhEiAJIRALIAggBzYCPEEAIQwCQCAHLAAAIgtBIGsiAUEfSwRAIAchCQwBCyAHIQlBASABdCIBQYnRBHFFDQADQCAIIAdBAWoiCTYCPCABIAxyIQwgBywAASILQSBrIgFBIE8NASAJIQdBASABdCIBQYnRBHENAAsLAkAgC0EqRgRAAn8CQCAJLAABQTBrIgFBCUsNACAJLQACQSRHDQACfyAARQRAIAQgAUECdGpBCjYCAEEADAELIAMgAUEDdGooAgALIQ8gCUEDaiEBQQEMAQsgEg0GIAlBAWohASAARQRAIAggATYCPEEAIRJBACEPDAMLIAIgAigCACIHQQRqNgIAIAcoAgAhD0EACyESIAggATYCPCAPQQBODQFBACAPayEPIAxBgMAAciEMDAELIAhBPGoQaSIPQQBIDQogCCgCPCEBC0EAIQdBfyEKAn9BACABLQAAQS5HDQAaIAEtAAFBKkYEQAJ/AkAgASwAAkEwayIJQQlLDQAgAS0AA0EkRw0AIAFBBGohAQJ/IABFBEAgBCAJQQJ0akEKNgIAQQAMAQsgAyAJQQN0aigCAAsMAQsgEg0GIAFBAmohAUEAIABFDQAaIAIgAigCACIJQQRqNgIAIAkoAgALIQogCCABNgI8IApBAE4MAQsgCCABQQFqNgI8IAhBPGoQaSEKIAgoAjwhAUEBCyETA0AgByEUQRwhCSABIhgsAAAiB0H7AGtBRkkNCyABQQFqIQEgByAUQTpsakG/wAFqLQAAIgdBAWtBCEkNAAsgCCABNgI8AkAgB0EbRwRAIAdFDQwgEEEATgRAIABFBEAgBCAQQQJ0aiAHNgIADAwLIAggAyAQQQN0aikDADcDMAwCCyAARQ0IIAhBMGogByACIAYQaAwBCyAQQQBODQtBACEHIABFDQgLIAAtAABBIHENCyAMQf//e3EiCyAMIAxBgMAAcRshDEEAIRBBsAghFSARIQkCQAJAAn8CQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIBgsAAAiB0FTcSAHIAdBD3FBA0YbIAcgFBsiB0HYAGsOIQQWFhYWFhYWFhAWCQYQEBAWBhYWFhYCBQMWFgoWARYWBAALAkAgB0HBAGsOBxAWCxYQEBAACyAHQdMARg0LDBULIAgpAzAhHEGwCAwFC0EAIQcCQAJAAkACQAJAAkACQCAUQf8BcQ4IAAECAwQcBQYcCyAIKAIwIA42AgAMGwsgCCgCMCAONgIADBoLIAgoAjAgDqw3AwAMGQsgCCgCMCAOOwEADBgLIAgoAjAgDjoAAAwXCyAIKAIwIA42AgAMFgsgCCgCMCAOrDcDAAwVC0EIIAogCkEITRshCiAMQQhyIQxB+AAhBwsgESEBIAgpAzAiHEIAUgRAIAdBIHEhDQNAIAFBAWsiASAcp0EPcUHQxAFqLQAAIA1yOgAAIBxCD1YhGiAcQgSIIRwgGg0ACwsgASENIAgpAzBQDQMgDEEIcUUNAyAHQQR2QbAIaiEVQQIhEAwDCyARIQEgCCkDMCIcQgBSBEADQCABQQFrIgEgHKdBB3FBMHI6AAAgHEIHViEbIBxCA4ghHCAbDQALCyABIQ0gDEEIcUUNAiAKIBEgAWsiAUEBaiABIApIGyEKDAILIAgpAzAiHEIAUwRAIAhCACAcfSIcNwMwQQEhEEGwCAwBCyAMQYAQcQRAQQEhEEGxCAwBC0GyCEGwCCAMQQFxIhAbCyEVIBwgERAqIQ0LIBMgCkEASHENESAMQf//e3EgDCATGyEMAkAgCCkDMCIcQgBSDQAgCg0AIBEhDUEAIQoMDgsgCiAcUCARIA1raiIBIAEgCkgbIQoMDQsgCCkDMCEcDAsLAn9B/////wcgCiAKQf////8HTxsiDCIHQQBHIQkCQAJAAkAgCCgCMCIBQYQMIAEbIg0iAUEDcUUNACAHRQ0AA0AgAS0AAEUNAiAHQQFrIgdBAEchCSABQQFqIgFBA3FFDQEgBw0ACwsgCUUNAQJAIAEtAABFDQAgB0EESQ0AA0BBgIKECCABKAIAIglrIAlyQYCBgoR4cUGAgYKEeEcNAiABQQRqIQEgB0EEayIHQQNLDQALCyAHRQ0BCwNAIAEgAS0AAEUNAhogAUEBaiEBIAdBAWsiBw0ACwtBAAsiASANayAMIAEbIgEgDWohCSAKQQBOBEAgCyEMIAEhCgwMCyALIQwgASEKIAktAAANDwwLCyAIKQMwIhxCAFINAUIAIRwMCQsgCgRAIAgoAjAMAgtBACEHIABBICAPQQAgDBAcDAILIAhBADYCDCAIIBw+AgggCCAIQQhqIgc2AjBBfyEKIAcLIQtBACEHA0ACQCALKAIAIg1FDQAgCEEEaiANEGciDUEASA0PIA0gCiAHa0sNACALQQRqIQsgByANaiIHIApJDQELC0E9IQkgB0EASA0MIABBICAPIAcgDBAcIAdFBEBBACEHDAELQQAhCSAIKAIwIQsDQCALKAIAIg1FDQEgCEEEaiIKIA0QZyINIAlqIgkgB0sNASAAIAogDRAZIAtBBGohCyAHIAlLDQALCyAAQSAgDyAHIAxBgMAAcxAcIA8gByAHIA9IGyEHDAgLIBMgCkEASHENCUE9IQkgACAIKwMwIA8gCiAMIAcgBRETACIHQQBODQcMCgsgBy0AASELIAdBAWohBwwACwALIAANCSASRQ0DQQEhBwNAIAQgB0ECdGooAgAiAARAIAMgB0EDdGogACACIAYQaEEBIQ4gB0EBaiIHQQpHDQEMCwsLQQEhDiAHQQpPDQkDQCAEIAdBAnRqKAIADQEgB0EBaiIHQQpHDQALDAkLQRwhCQwGCyAIIBw8ACdBASEKIBYhDSALIQwLIAogCSANayILIAogC0obIgogEEH/////B3NKDQNBPSEJIA8gCiAQaiIBIAEgD0gbIgcgF0oNBCAAQSAgByABIAwQHCAAIBUgEBAZIABBMCAHIAEgDEGAgARzEBwgAEEwIAogC0EAEBwgACANIAsQGSAAQSAgByABIAxBgMAAcxAcIAgoAjwhAQwBCwsLQQAhDgwDC0E9IQkLQZTHASAJNgIAC0F/IQ4LIAhBQGskACAOC6gCAQR/IwBB0AFrIgUkACAFIAI2AswBIAVBoAFqIgJBAEEoEBUaIAUgBSgCzAE2AsgBAkBBACABIAVByAFqIAVB0ABqIAIgAyAEEGpBAEgNACAAKAJMQQBIIQggACAAKAIAIgdBX3E2AgACfwJAAkAgACgCMEUEQCAAQdAANgIwIABBADYCHCAAQgA3AxAgACgCLCEGIAAgBTYCLAwBCyAAKAIQDQELQX8gABA+DQEaCyAAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEGoLIQEgBgR/IABBAEEAIAAoAiQRAAAaIABBADYCMCAAIAY2AiwgAEEANgIcIAAoAhQaIABCADcDEEEABSABCxogACAAKAIAIAdBIHFyNgIAIAgNAAsgBUHQAWokAAsnAQF/QRwhAyABQQNxBH9BHAUgACABIAIQJSIANgIAQQBBMCAAGwsL/QMBBX8Cf0HgxAEoAgAiAiAAQQdqQXhxIgFBB2pBeHEiA2ohAAJAIANBACAAIAJNG0UEQCAAPwBBEHRNDQEgABAKDQELQZTHAUEwNgIAQX8MAQtB4MQBIAA2AgAgAgsiAkF/RwRAIAEgAmoiAEEEa0EQNgIAIABBEGsiA0EQNgIAAkACf0GgzwEoAgAiAQR/IAEoAggFQQALIAJGBEAgAiACQQRrKAIAQX5xayIEQQRrKAIAIQUgASAANgIIIAQgBUF+cWsiACAAKAIAakEEay0AAEEBcQRAIAAoAgQiASAAKAIIIgQ2AgggBCABNgIEIAAgAyAAayIBNgIADAMLIAJBEGsMAQsgAkEQNgIAIAIgADYCCCACIAE2AgQgAkEQNgIMQaDPASACNgIAIAJBEGoLIgAgAyAAayIBNgIACyAAIAFBfHFqQQRrIAFBAXI2AgAgAAJ/IAAoAgBBCGsiAUH/AE0EQCABQQN2QQFrDAELIAFBHSABZyIDa3ZBBHMgA0ECdGtB7gBqIAFB/x9NDQAaQT8gAUEeIANrdkECcyADQQF0a0HHAGoiASABQT9PGwsiAUEEdCIDQaDHAWo2AgQgACADQajHAWoiAygCADYCCCADIAA2AgAgACgCCCAANgIEQajPAUGozwEpAwBCASABrYaENwMACyACQX9HC70BAQJ/AkAgACgCTCIBQQBOBEAgAUUNAUHMzwEoAgAgAUH/////A3FHDQELAkAgACgCUEEKRg0AIAAoAhQiASAAKAIQRg0AIAAgAUEBajYCFCABQQo6AAAPCyAAEG8PCyAAQcwAaiIBIAEoAgAiAkH/////AyACGzYCAAJAAkAgACgCUEEKRg0AIAAoAhQiAiAAKAIQRg0AIAAgAkEBajYCFCACQQo6AAAMAQsgABBvCyABKAIAGiABQQA2AgALfAECfyMAQRBrIgEkACABQQo6AA8CQAJAIAAoAhAiAgR/IAIFIAAQPg0CIAAoAhALIAAoAhQiAkYNACAAKAJQQQpGDQAgACACQQFqNgIUIAJBCjoAAAwBCyAAIAFBD2pBASAAKAIkEQAAQQFHDQAgAS0ADxoLIAFBEGokAAuwAgECfyAABEAgACgCABA4IABBADYCACAAKAJIIgEEQCABEBAgAEEANgJICyAAKAJEIgEEQCABEBAgAEEANgJECyAAKAJsIgEEQCABEBAgAEEANgJsCyAAKAJ0IgEEQCABKAIAIgIEQCACEBAgACgCdCIBQQA2AgALIAEQECAAQQA2AnQLIAAoAngiAQRAIAEoAgwiAgRAIAIQECAAKAJ4IgFBADYCDAsgASgCBCICBEAgAhAQIAAoAngiAUEANgIECyABKAIIIgIEQCACEBAgACgCeCIBQQA2AggLIAEoAgAiAgRAIAIQECAAKAJ4IgFBADYCAAsgARAQIABBADYCeAsgACgCBCIBBEAgARAyIABBADYCBAsgACgCCCIBBEAgARAyIABBADYCCAsgABAQCwuLGwIefwV7IwBB8AFrIgkkAEEBIQ4CQCAAKAIAKAI8DQAgACgCgAENAAJAAkAgACgCdCIIRQRAIAAoAnghBAwBCyABKAIQIQMgCC8BBCEGAkAgACgCeCIERQ0AIAQoAgxFDQAgBC0AEiEDCwJAIAYEQCAIKAIAIQgDQCAIIAVBBmxqIgovAQAiByADTwRAIAkgAzYCtAEgCSAHNgKwASACQQFBoOYAIAlBsAFqEA9BACEODAYLAkAgCi8BBCIKRQ0AIApB//8DRg0AIApBAWsiCiADSQ0AIAkgAzYCpAEgCSAKNgKgASACQQFBoOYAIAlBoAFqEA9BACEODAYLIAVBAWoiBSAGRw0ACwwBCyADDQIMAQsDQCADQQFrIQNBACEFA0AgCCAFQQZsai8BACADRwRAIAVBAWoiBSAGRw0BDAQLCyADDQALCwJAIARFDQAgBCgCDCIKRQ0AAkACQCAELQASIggEQEEAIQVBASEHA0AgASgCECIDIAogBUECdGovAQAiBE0EQCAJIAM2ApQBIAkgBDYCkAEgAkEBQaDmACAJQZABahAPQQAhBwsgBUEBaiIFIAhHDQALIAhBBBATIgNFDQFBACEFA0ACQCAKIAVBAnRqIgQtAAIiBkECTwRAIAkgBjYCRCAJIAU2AkAgAkEBQcvZACAJQUBrEA9BACEHDAELIAggBC0AAyIETQRAIAkgBDYCgAEgAkEBQZPZACAJQYABahAPQQAhBwwBCyADIARBAnRqIQsCQCAGQQFHIgwNACALKAIARQ0AIAkgBDYCUCACQQFBvNUAIAlB0ABqEA9BACEHDAELAkAgBg0AIARFDQAgCSAENgJkIAkgBTYCYCACQQFBitgAIAlB4ABqEA9BACEHDAELAkAgDA0AIAQgBUYNACAJIAQ2AnggCSAFNgJ0IAkgBTYCcCACQQFBrtgAIAlB8ABqEA9BACEHDAELIAtBATYCAAsgBUEBaiIFIAhHDQALQQAhBQNAAkACQCADIAVBAnQiBGooAgBFBEAgBCAKai0AAg0BCyAFQQFqIgUgCEcNAiAHRQ0BIAEoAhBBAUcNBUEAIQUDQCADIAVBAnRqKAIABEAgCCAFQQFqIgVHDQEMBwsLQQAhByACQQJB7sUAQQAQDyAIQRBPBEAgCEHwAXEhB0EAIQQDQCAKIARBAnRqIgZBAToAAiAGIAQ6AAMgBkEBOgA+IAZBAToAOiAGQQE6ADYgBkEBOgAyIAZBAToALiAGQQE6ACogBkEBOgAmIAZBAToAIiAGQQE6AB4gBkEBOgAaIAZBAToAFiAGQQE6ABIgBkEBOgAOIAZBAToACiAGQQE6AAYgBiAEQQFyOgAHIAYgBEEPcjoAPyAGIARBDnI6ADsgBiAEQQ1yOgA3IAYgBEEMcjoAMyAGIARBC3I6AC8gBiAEQQpyOgArIAYgBEEJcjoAJyAGIARBCHI6ACMgBiAEQQdyOgAfIAYgBEEGcjoAGyAGIARBBXI6ABcgBiAEQQRyOgATIAYgBEEDcjoADyAGIARBAnI6AAsgBEEQaiIEIAdHDQALIAcgCEYNBgsDQCAKIAdBAnRqIgQgBzoAAyAEQQE6AAIgB0EBaiIHIAhHDQALDAULIAkgBTYCMCACQQFByNIAIAlBMGoQD0EAIQcgBUEBaiIFIAhHDQELCyADEBBBACEODAULIAhBBBATIgMNAQtBACEOIAJBAUGK2wBBABAPDAMLIAMQEAsCQCAAKAJ4IgNFDQAgAygCDCIPRQRAIAMoAgQQECAAKAJ4KAIIEBAgACgCeCgCABAQIAAoAngiAygCDCIEBH8gBBAQIAAoAngFIAMLEBAgAEEANgJ4DAELIAEoAhghDQJAAkAgAy0AEiIKBEAgAygCACEUIAMoAgQhBiADKAIIIQhBACEFAkADQCANIA8gBUECdGovAQBBNGxqKAIsBEAgCiAFQQFqIgVHDQEMAgsLIAkgBTYCICACQQFBwucAIAlBIGoQD0EAIQ4MBgsgCkE0bBAUIgtFDQFBACEFA0AgDyAFQQJ0aiIDLwEAIQcgCyADLQACBH8gAy0AAwUgBQtBNGxqIgQgDSAHQTRsaiID/QACAP0LAgAgBCADKAIwNgIwIAQgA/0AAiD9CwIgIAQgA/0AAhD9CwIQIAsgBUE0bGoiBCADKAIIIAMoAgxsQQJ0EBgiAzYCLCADRQRAIAUEQCAFQf//A3EhAANAIABBNGwgC2pBCGsoAgAQECAAQQFrIgANAAsLIAsQEEEAIQ4gAkEBQY7nAEEAEA8MBwsgBCAFIAhqLQAANgIYIAQgBSAGai0AADYCICAFQQFqIgUgCkcNAAsgACgCeC8BECIQQQFrIRIDQCALIBNBNGxqIgMoAgwgAygCCGwhBiANIA8gE0ECdGoiBC8BAEE0bGooAiwhCAJAIAQtAAJFBEAgBkUNASADKAIsIQVBACEHQQAhBAJAIAZBBEkNACAFIAhrQRBJDQAgBkF8cSEEQQAhAwNAIAUgA0ECdCIMaiAIIAxq/QACAP0LAgAgA0EEaiIDIARHDQALIAQgBkYNAgsgBCEDIAZBA3EiDARAA0AgBSADQQJ0IhFqIAggEWooAgA2AgAgA0EBaiEDIAdBAWoiByAMRw0ACwsgBCAGa0F8Sw0BA0AgBSADQQJ0IgRqIAQgCGooAgA2AgAgBSAEQQRqIgdqIAcgCGooAgA2AgAgBSAEQQhqIgdqIAcgCGooAgA2AgAgBSAEQQxqIgRqIAQgCGooAgA2AgAgA0EEaiIDIAZHDQALDAELIAZFDQAgFCAELQADIgNBAnRqIQQgCyADQTRsaigCLCEFQQAhAyAGQQFHBEAgBkF+cSEVQQAhDANAIAUgA0ECdCIHaiAEIAcgCGooAgAiESASIBAgEUobQQAgEUEAThsgCmxBAnRqKAIANgIAIAUgB0EEciIHaiAEIAcgCGooAgAiByASIAcgEEgbQQAgB0EAThsgCmxBAnRqKAIANgIAIANBAmohAyAMQQJqIgwgFUcNAAsLIAZBAXFFDQAgBSADQQJ0IgNqIAQgAyAIaigCACIDIBIgAyAQSBtBACADQQBOGyAKbEECdGooAgA2AgALIBNBAWoiEyAKRw0ACwwCCyAKQTRsEBQiCw0BC0EAIQ4gAkEBQY7nAEEAEA8MAwsgASgCECIDBEBBACEFA0AgDSAFQTRsaigCLCIEBEAgBBAQCyAFQQFqIgUgA0cNAAsLIA0QECABIAo2AhAgASALNgIYCyAAKAJ0IgVFDQEgBSgCACEHIAUvAQQiCwRAIAdBKmohEiAHQSRqIRMgB0EeaiERIAdBGGohFCAHQRJqIRUgB0EMaiEWIAdBBmohFyALQQJrIRhBACEFQQEhBANAAkAgASgCECIDIAcgBUEGbGoiDS8BACIGTQRAIAkgAzYCFCAJIAY2AhAgAkECQcw3IAlBEGoQDwwBCyANLwEEIghBAWpB//8DcUEBTQRAIAEoAhggBkE0bGogDS8BAjsBMAwBCyAIQQFrIgpB//8DcSIPIANPBEAgCSADNgIEIAkgDzYCACACQQJBozcgCRAPDAELAkAgBiAPRg0AIA0vAQINACAJIAEoAhgiCCAGQTRsaiIDKAIwNgLoASAJIAP9AAIg/QsD2AEgCSAD/QACEP0LA8gBIAkgA/0AAgD9CwO4ASADIAggD0E0bCIMaiIIKQIINwIIIAMgCCkCEDcCECADIAgpAhg3AhggAyAIKQIgNwIgIAMgCCkCKDcCKCADIAgoAjA2AjAgAyAIKQIANwIAIAEoAhggDGoiAyAJ/QADuAH9CwIAIAMgCf0AA9gB/QsCICADIAn9AAPIAf0LAhAgAyAJKALoATYCMCAFQQFqIAtPDQAgBCEIIBggBWtB//8DcSIDQQdPBEAgBCADQQFqIhlB+P8HcSIQaiEIIAr9ECEkIAb9ECEjQQAhDANAICMgJCASIAQgDGpBBmwiA2oiGiADIBNqIhsgAyARaiIcIAMgFGoiHSADIBVqIh4gAyAWaiIfIAMgF2oiICADIAdqIgP9CAEA/VUBAAH9VQEAAv1VAQAD/VUBAAT9VQEABf1VAQAG/VUBAAciISAj/S4gISAk/S0iJf1O/VIhIiAhICP9LSAl/VAiIf0ZAEEBcQRAIAMgIv1ZAQAACyAh/RkBQQFxBEAgICAi/VkBAAELICH9GQJBAXEEQCAfICL9WQEAAgsgIf0ZA0EBcQRAIB4gIv1ZAQADCyAh/RkEQQFxBEAgHSAi/VkBAAQLICH9GQVBAXEEQCAcICL9WQEABQsgIf0ZBkEBcQRAIBsgIv1ZAQAGCyAh/RkHQQFxBEAgGiAi/VkBAAcLIAxBCGoiDCAQRw0ACyAQIBlGDQELA0AgCiEDAkAgBiAHIAhBBmxqIgwvAQAiEEcEQCAGIQMgDyAQRw0BCyAMIAM7AQALIAsgCEEBaiIIQf//A3FHDQALCyABKAIYIAZBNGxqIA0vAQI7ATALIARBAWohBCAFQQFqIgUgC0cNAAsgACgCdCIFKAIAIQcLIAcEfyAHEBAgACgCdAUgBQsQECAAQQA2AnQMAQtBACEOIAJBAUGhxgBBABAPCyAJQfABaiQAIA4L6QEBBn8jAEEgayIEJAACfwJAIAAoAjwiAwRAQQEhBQNAIAAoAkwoAhggACgCQCACQQJ0aigCACIGQTRsaigCLEUEQCAEIAY2AhAgAUECQdo5IARBEGoQD0EAIQUgACgCPCEDCyACQQFqIgIgA0kNAAsMAQtBASEFQQEgACgCTCIDKAIQRQ0BGgNAIAMoAhggAkE0bGooAixFBEAgBCACNgIAIAFBAkHaOSAEEA9BACEFIAAoAkwhAwsgAkEBaiICIAMoAhBJDQALC0EBIAUNABogAUEBQb8VQQAQD0EACyEHIARBIGokACAHCwQAQX8LhgcCFn8CfiAAKAIYIhAoAhBFBEBBAQ8LIBAoAhghDSAAKAIUKAIAKAIUIQsDQCABIA0oAiQiAjYCJCALKAIcIgYgAkGYAWxqIQMCQAJAAn8gACgCQCIRBEAgBiALKAIYQZgBbGoiAkGQAWsoAgAgAkGYAWsoAgBrIQwgA0EMaiEGIANBBGohBCADKAIIIQIgAygCACEFQSQMAQsgA0GUAWohBiADQYwBaiEEIAMoApABIgIgAygCiAEiBWshDEE0CyALaigCACISRQ0AIAQoAgAhByAGKAIAIQkgAiAFayEGIAEoAggiA0J/IAE1AigiGIZCf4UiGSABNQIQfCAYiKciCGohBAJ/IAUgCEsEQCAFIAhrIQ5BACEIQQAgAiAETQ0BGiAGIAQgBWsiBmsMAQsgCCAFayEIIAIgBE0EQCAGIAhrIQZBACEOQQAMAQtBACEOIAMhBiACIARrCyEVIAkgB2shAiABKAIMIgQgGSABNQIUfCAYiKciCmohBQJ/IAcgCksEQCAHIAprIQ9BACEKQQAgBSAJTw0BGiACIAUgB2siAmsMAQsgCiAHayEKIAUgCU8EQCACIAprIQJBACEPQQAMAQtBACEPIAQhAiAJIAVrCyEHQQAhBSAIQQBIDQEgCkEASA0BIBVBAEgNASAHQQBIDQEgBkEASA0BIAJBAEgNASADIA9sIA5qIQcgCiAMbCAIaiEJAkACQAJAIAEoAiwiCA0AIAkNACAHDQAgAyAMRw0AIAMgBkcNACACIARHDQEgASALQSRBNCARG2oiAigCADYCLCACQQA2AgAMAwsgCA0BCyAERQ0CIAStIAOtfkIgiKcNAiADIARsIgNB/////wNLDQIgASADQQJ0EBgiAzYCLCADRQ0CIAYgASgCCCIERiABKAIMIgUgAkZxDQAgA0EAIAQgBWxBAnQQFRoLIAJFDQAgAkEBcSEXIAZBAnQhBiABKAIsIAdBAnRqIQQgEiAJQQJ0aiEFIAJBAUcEQCACQf7///8HcSEHQQAhAgNAIAQgBSAGEBIhFiAFIAxBAnQiCWoiCCAJaiEFIBYgASgCCEECdGogCCAGEBIgASgCCEECdGohBCACQQJqIgIgB0cNAAsLIBdFDQAgBCAFIAYQEhoLIAtBzABqIQsgDUE0aiENIAFBNGohAUEBIQUgFEEBaiIUIBAoAhBJDQELCyAFC9USAgl/DH4jAEGgAWsiBSQAAkAgAkEjTQRAQQAhAiADQQFBti5BABAPDAELIAJBJGsiAiACQQNuIglBA2xHBEBBACECIANBAUG2LkEAEA8MAQsgACgCSCEGIAEgBUGcAWoiAkECEBEgACAFKAKcATsBUCABQQJqIAZBCGpBBBARIAFBBmogBkEMakEEEBEgAUEKaiAGQQQQESABQQ5qIAZBBGpBBBARIAFBEmogAEHcAGpBBBARIAFBFmogAEHgAGpBBBARIAFBGmogAEHUAGpBBBARIAFBHmogAEHYAGpBBBARIAFBImogAkECEBECQAJAAkAgBSgCnAEiAkGAgAFNBEAgBiACNgIQIAIgCUcEQCAFIAk2AoQBIAUgAjYCgAEgA0EBQZHwACAFQYABahAPQQAhAgwFCyAGKAIEIgIgBigCDCIISSAGKAIIIgsgBigCACIES3FFBEAgBSAIrSACrX03A3ggBSALrSAErX03A3AgA0EBQdvsACAFQfAAahAPQQAhAgwFCyAAKAJcIgdBACAAKAJgIgobRQRAIAUgCjYCBCAFIAc2AgAgA0EBQYPxACAFEA9BACECDAULAkACQCAAKAJUIgwgBEsNAEF/IAcgDGoiByAHIAxJGyAETQ0AIAAoAlgiByACSw0AQX8gByAKaiIKIAcgCksbIAJLDQELQQAhAiADQQFB1hRBABAPDAULAkAgACgC4AENACAAKALYASIHRQ0AIAAoAtwBIgpFDQAgCyAEayIEIAdGIAggAmsiAiAKRnENACAFIAI2AmwgBSAENgJoIAUgCjYCZCAFIAc2AmAgA0EBQcPoACAFQeAAahAPQQAhAgwFCyAGIAlBNBATIgQ2AhggBEUNAQJAIAYoAhBFDQAgAUEkaiAFQZgBaiICQQEQESAEIAUoApgBIglBB3YiCjYCICAEIAlB/wBxQQFqIgw2AhggACgC4AEhCyABQSVqIAJBARARIAQgBSgCmAE2AgAgAUEmaiACQQEQESAEIAUoApgBIgg2AgRBACECIAQoAgAiB0GAAmtBgX5JBEBBACEJDAULQQAhCSAIQYACa0GBfkkNBCAEKAIYIghBH0sNAyAEQQA2AiQgBCAAKAKgATYCKEEBIQkgBigCEEEBTQ0AQQAgCiALGyEKQQAgDCALGyELIAFBJ2ohAQNAIAEgBUGYAWpBARARIAQgBSgCmAEiB0EHdiIINgJUIAQgB0H/AHFBAWoiBzYCTAJAIAAoAuABDQAgAC0AvAFBBHENACAHIAtGIAggCkZxDQAgBSAINgJUIAUgBzYCUCAFIAk2AkwgBSAKNgJIIAUgCzYCRCAFIAk2AkAgA0ECQcfuACAFQUBrEA8LIAFBAWogBUGYAWoiCEEBEBEgBCAFKAKYATYCNCABQQJqIAhBARARIAQgBSgCmAEiCDYCOCAEKAI0IgdBgAJrQYF+SQ0FIAhBgAJrQYB+TQ0FIAQoAkwiCEEgTw0EIAFBA2ohASAEQQA2AlggBCAAKAKgATYCXCAEQTRqIQQgCUEBaiIJIAYoAhBJDQALC0EAIQIgACgCXCIIRQ0EIAAoAmAiC0UNBCAAIAitIg1CAX0iDyAGKAIIIAAoAlQiB2utfCANgKciATYCaCAAIAutIg5CAX0iECAGKAIMIAAoAlgiCmutfCAOgKciBDYCbAJAAkAgAUUNACAERQ0AQf//AyAEbiABTw0BCyAFIAQ2AhQgBSABNgIQIANBAUG16QAgBUEQahAPDAULIAEgBGwhCQJAIAAtAERBAnEEQCAAIAAoAhwgB2sgCG42AhwgACAAKAIgIAprIAtuNgIgIAAgDyAAKAIkIAdrrXwgDYA+AiQgACAQIAAoAiggCmutfCAOgD4CKAwBCyAAIAQ2AiggACABNgIkIABCADcCHAsgACAJQYwsEBMiATYCnAEgAUUEQCADQQFBzR1BABAPDAULIAYoAhBBuAgQEyEBIAAoAgwgATYC0CsgACgCDCgC0CtFBEAgA0EBQc0dQQAQDwwFC0EKQRQQEyEBIAAoAgwgATYC8CsgACgCDCIBKALwK0UEQCADQQFBzR1BABAPDAULIAFBCjYC+CtBCkEUEBMhASAAKAIMIAE2AvwrIAAoAgwiASgC/CtFBEAgA0EBQc0dQQAQDwwFCyABQQo2AoQsAkAgBigCECIERQ0AIAYoAhghCEEAIQEgBEEBRwRAIARBfnEhCwNAIAggAUE0bGoiBygCIEUEQCAAKAIMKALQKyABQbgIbGpBASAHKAIYQQFrdDYCtAgLIAggAUEBciIHQTRsaiIKKAIgRQRAIAAoAgwoAtArIAdBuAhsakEBIAooAhhBAWt0NgK0CAsgAUECaiEBIAJBAmoiAiALRw0ACwsgBEEBcUUNACAIIAFBNGxqIgIoAiANACAAKAIMKALQKyABQbgIbGpBASACKAIYQQFrdDYCtAgLIAkEQCAAKAKcASEBQQAhAgNAIAEgBigCEEG4CBATIgQ2AtArIARFBEBBACECIANBAUHNHUEAEA8MBwsgAUGMLGohASACQQFqIgIgCUkNAAsLIABBBDYCCCAGKAIQIgMEQEF/IAAoAlgiASAAKAJgIgIgACgCbEEBa2xqIgQgAmoiAiACIARJGyICIAYoAgwiBCACIARJG60hEEF/IAAoAlQiAiAAKAJcIgQgACgCaEEBa2xqIgAgBGoiBCAAIARLGyIAIAYoAggiBCAAIARJG60hESABIAYoAgQiACAAIAFJG60hEiACIAYoAgAiACAAIAJJG60hEyAGKAIYIQBBACEBA0AgACAANQIEIg1CAX0iFCASfCANgCIVPgIUIAAgADUCACIOQgF9IhYgE3wgDoAiFz4CECAAQn8gADUCKCIPhkJ/hSIYIBAgFHwgDYAgFX1C/////w+DfCAPiD4CDCAAIBEgFnwgDoAgF31C/////w+DIBh8IA+IPgIIIABBNGohACABQQFqIgEgA0cNAAsLQQEhAgwECyAFIAI2ApABIANBAUH2OyAFQZABahAPQQAhAgwDC0EAIQIgBkEANgIQIANBAUHNHUEAEA8MAgsgBSAINgI0IAUgCTYCMCADQQFBt/MAIAVBMGoQDwwBCyAFIAg2AiggBSAHNgIkIAUgCTYCICADQQFBkesAIAVBIGoQDwsgBUGgAWokACACC54DAQd/IwBBEGsiBiQAAn8gAiACQQFBAiAAKAJIKAIQIghBgQJJGyIHQQF0QQVqIgRuIgUgBGxGIAIgBE9xRQRAIANBAUGKI0EAEA9BAAwBCwJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQRBACEAIAQtAIgsIgJBBHEEQCAEKAKkA0EBaiEACyAAIAVqIgVBIE8EQCAGIAU2AgAgA0EBQYs7IAYQD0EADAELIAQgAkEEcjoAiCwgACAFSQRAIAQgAEGUAWxqQagDaiECA0AgASACQQEQESABQQFqIgEgAkEEaiAHEBEgASAHaiIBIAJBCGpBAhARIAIgAigCCCIDIAQoAggiCSADIAlJGzYCCCABQQJqIAJBDGpBARARIAFBA2oiASACQRBqIAcQESABIAdqIgEgBkEMakEBEBEgAiAGKAIMNgIkIAIgAigCECIDIAggAyAISRs2AhAgAkGUAWohAiABQQFqIQEgAEEBaiIAIAVHDQALCyAEIAVBAWs2AqQDQQELIQogBkEQaiQAIAoL7AEBBH8jAEEQayIEJAACfwJAIAEgBEEIagJ/IAAoAkgoAhBBgAJNBEAgAgRAQX8hBUEBDAILIANBAUG+I0EAEA9BAAwDCyACQQFNDQFBfiEFQQILIgYQESAEIAIgBWo2AgwgBCgCCCICIAAoAkgoAhAiBU8EQCAEIAU2AgQgBCACNgIAIANBAUHGOiAEEA9BAAwCCyAAIAIgASAGaiAEQQxqIAMQQkUEQCADQQFBviNBABAPQQAMAgtBASAEKAIMRQ0BGiADQQFBviNBABAPQQAMAQsgA0EBQb4jQQAQD0EACyEHIARBEGokACAHC9kBAQR/IwBBEGsiBCQAIAQgAjYCDAJAAkAgAEEAIAEgBEEMaiADEEJFDQAgBCgCDA0AAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshB0EBIQUgACgCSCgCEEECSQ0BIAcoAtArIgJBHGohBkEBIQEgAiEDA0AgAyACKAIYNgLQCCADIAIoAqQGNgLcDiADQdQIaiAGQYgGEBIaIANBuAhqIQMgAUEBaiIBIAAoAkgoAhBJDQALDAELIANBAUHWIkEAEA8LIARBEGokACAFC9YBAQN/IwBBEGsiBCQAAkAgAkEBQQIgACgCSCgCECIGQYECSRsiBUECakcEQEEAIQAgA0EBQYogQQAQDwwBCwJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQIgASAEQQxqIAUQEUEBIQAgASAFaiIFIARBCGpBARARIAYgBCgCDCIBTQRAIAQgBjYCBCAEIAE2AgAgA0EBQdjvACAEEA9BACEADAELIAVBAWogAigC0CsgAUG4CGxqQagGakEBEBELIARBEGokACAAC4QCAQV/IwBBEGsiBCQAAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAshBgJAIAJBAUECIAAoAkgiBygCEEGBAkkbIgVNBEBBACECIANBAUGkI0EAEA8MAQsgBCAFQX9zIAJqNgIMIAEgBEEIaiAFEBEgBCgCCCIIIAcoAhBPBEBBACECIANBAUGA6QBBABAPDAELQQEhAiABIAVqIgEgBigC0CsgCEG4CGxqQQEQESAAIAQoAgggAUEBaiAEQQxqIAMQQ0UEQEEAIQIgA0EBQaQjQQAQDwwBCyAEKAIMRQ0AQQAhAiADQQFBpCNBABAPCyAEQRBqJAAgAgusBgEHfyMAQRBrIgYkACAGIAI2AgwgACgCSCEJAn8gACgCCEEQRgRAIAAoApwBIAAoAswBQYwsbGoMAQsgACgCDAsiBCAELQCILEEBcjoAiCwCQCACQQRNBEAgA0EBQbwiQQAQDwwBCyABIARBARARIAQoAgBBCE8EQCADQQFBmiJBABAPDAELIAFBAWogBkEIakEBEBEgBCAGKAIIIgI2AgQgAkEFTgRAIANBAUHxIUEAEA8gBEF/NgIECyABQQJqIARBCGpBAhARIAQoAggiB0GAgARrQYCAfE0EQCAGIAc2AgAgA0EBQak9IAYQDwwBCyAEIAAoAqQBIgIgByACGzYCDCABQQRqIARBEGpBARARIAQoAhBBAk8EQCADQQFBhypBABAPDAELIAFBBWohAiAGIAYoAgxBBWs2AgwCQCAJKAIQIgdFDQAgBCgCAEEBcSEIIAQoAtArIQRBACEJIAdBCE8EQCAHQXhxIQEDQCAEIAVBuAhsaiAINgIAIAQgBUEBckG4CGxqIAg2AgAgBCAFQQJyQbgIbGogCDYCACAEIAVBA3JBuAhsaiAINgIAIAQgBUEEckG4CGxqIAg2AgAgBCAFQQVyQbgIbGogCDYCACAEIAVBBnJBuAhsaiAINgIAIAQgBUEHckG4CGxqIAg2AgAgBUEIaiEFIApBCGoiCiABRw0ACwsgB0EHcSIBRQ0AA0AgBCAFQbgIbGogCDYCACAFQQFqIQUgCUEBaiIJIAFHDQALC0EAIQUgAEEAIAIgBkEMaiADEENFBEAgA0EBQbwiQQAQDwwBCyAGKAIMBEAgA0EBQbwiQQAQDwwBCwJ/IAAoAghBEEYEQCAAKAKcASAAKALMAUGMLGxqDAELIAAoAgwLIQEgACgCSCgCEEECTwRAIAEoAtArIgEoAgRBAnQhByABQbAHaiEKIAFBrAZqIQNBASEJIAEhAgNAIAIgAf0AAgT9CwK8CCACIAEoAhQ2AswIIAJB5A5qIAMgBxASGiACQegPaiAKIAcQEhogAkG4CGohAiAJQQFqIgkgACgCSCgCEEkNAAsLQQEhBQsgBkEQaiQAIAUL7AkBBn8jAEHwAGsiBCQAIARBADYCaAJAIAJBCEcEQCADQQFBvR5BABAPIANBAUG9HkEAEA8MAQsgASAAQcwBakECEBEgAUECaiAEQewAakEEEBEgAUEGaiAEQeQAakEBEBEgAUEHaiAEQegAakEBEBEgACgCzAEiAiAAKAJoIgggACgCbGxPBEAgBCACNgJgIANBAUGdOyAEQeAAahAPDAELIAAoApwBIAJBjCxsaiEFIAIgCG4hByAEKAJkIQECQCAAKAIsIgZBAE4gAiAGR3ENACAFKALUK0EBaiIGIAFGDQAgBCAGNgJYIAQgATYCVCAEIAI2AlAgA0EBQbU7IARB0ABqEA9BACEFDAELIAUgATYC1CsCQAJAIAQoAmwiAUEBa0EMTQR/IAFBDEcNASAEQQw2AjAgA0ECQeXXACAEQTBqEA8gBCgCbAUgAQtFBEAgA0EEQbLPAEEAEA8gAEEBNgI4CwJAAkACQAJAIAUoAtgrIgEEQCAEKAJkIgYgAUkNASAEIAE2AiQgBCAGNgIgIANBAUGFJyAEQSBqEA8gAEEBNgI4QQAhBQwHCyAEKAJoIgYNAQwDCyAEKAJoIgZFDQELIAQgBiAALQBEQQR2QQFxaiIBNgJoIAQoAmQiBiAFKALYKyIJQQFrSwRAIAQgCTYCBCAEIAY2AgAgA0EBQaImIAQQDyAAQQE2AjhBACEFDAULIAEgBk0EQCAEIAE2AhQgBCAGNgIQIANBAUHpJyAEQRBqEA8gAEEBNgI4QQAhBQwFCyAFIAE2AtgrCyABIAQoAmRBAWpHDQAgACAALQBEQQFyOgBECyAEKAJsIQEgAEEQNgIIIABBACABQQxrIAAoAjgbNgIYAkAgACgCLCIBQX9GBEBBBCEFIAIgByAIbGsiASAAKAIcSQ0BIAEgACgCJE8NASAHIAAoAiBJDQEgByAAKAIoT0ECdCEFDAELIAAoAswBIAFHQQJ0IQULIAAgAC0AREH7AXEgBXI6AERBASEFIAAoAsgBIgFFDQIgASgCKCIGIAAoAswBIgJBKGxqIgcgAjYCACAHIAQoAmQiCDYCDCAEKAJoIgEEQCAHIAE2AgQgByAEKAJoIgE2AgggBygCECICRQRAIAFBGBATIQEgACgCyAEoAiggACgCzAFBKGxqIAE2AhAgAQ0EQQAhBSADQQFByTRBABAPDAQLIAIgAUEYbBAXIQEgACgCyAEoAiggACgCzAFBKGxqIQIgAUUEQCACKAIQEBBBACEFIAAoAsgBKAIoIAAoAswBQShsakEANgIQIANBAUHJNEEAEA8MBAsgAiABNgIQDAMLIAcoAhAiAUUEQCAHQQo2AghBCkEYEBMhASAAKALIASgCKCIGIAAoAswBIgJBKGxqIgcgATYCECABRQ0CIAQoAmQhCAsgCCAGIAJBKGxqIgIoAghJDQIgAiAIQQFqIgI2AgggASACQRhsEBchASAAKALIASgCKCAAKALMAUEobGohAiABRQRAIAIoAhAQEEEAIQUgACgCyAEoAiggACgCzAFBKGxqIgBBADYCCCAAQQA2AhAgA0EBQck0QQAQDwwDCyACIAE2AhAMAgsgBCABNgJAIANBAUHy2QAgBEFAaxAPQQAhBQwBC0EAIQUgB0EANgIIIANBAUHJNEEAEA8LIARB8ABqJAAgBQurBwEIfyMAQdAAayIEJAAgBEEBNgJMAkACQCAAKALIASIFKAIoIgMNACAFIAAoAmwgACgCaGwiAzYCJCADQSgQEyEDIAAoAsgBIgUgAzYCKCADRQRAQQAhBQwCCyAFKAIkRQ0AA0BBACEFIAMgBkEobCIHaiIDQQA2AhQgA0HkADYCHEHkAEEYEBMhCSAHIAAoAsgBIggoAigiA2ogCTYCGCAJRQ0CIAZBAWoiBiAIKAIkSQ0ACwsgACgCLCEJAkAgAygCEEUNAAJAIAMgCUEobGoiAygCBEUEQCABIAApAzBCAnwgAhA2DQFBACEFIAJBAUGnKUEAEA8MAwsgASADKAIQKQMAQgJ8IAIQNg0AQQAhBSACQQFBpylBABAPDAILIAAoAghBgAJHDQAgAEEINgIICwJAIAAoAmwgACgCaGwiB0UNACAAKAKcASEFQQAhAyAHQQhPBEAgB0F4cSEIQQAhBgNAIAUgA0GMLGxqQX82AtQrIAUgA0EBckGMLGxqQX82AtQrIAUgA0ECckGMLGxqQX82AtQrIAUgA0EDckGMLGxqQX82AtQrIAUgA0EEckGMLGxqQX82AtQrIAUgA0EFckGMLGxqQX82AtQrIAUgA0EGckGMLGxqQX82AtQrIAUgA0EHckGMLGxqQX82AtQrIANBCGohAyAGQQhqIgYgCEcNAAsLIAdBB3EiBkUNAANAIAUgA0GMLGxqQX82AtQrIANBAWohAyAKQQFqIgogBkcNAAsLQQAhBSAAIARByABqQQAgBEHEAGogBEFAayAEQTxqIARBOGogBEE0aiAEQcwAaiABIAIQJ0UNACAJQQFqIQcDQAJAIAQoAkxFDQAgACAEKAJIIgNBAEEAIAEgAhArRQ0CIAAoAmghCCAAKAJsIQogBCADQQFqIgY2AiAgBCAIIApsNgIkIAJBBEGg1wAgBEEgahAPIAAoAtABIAAoAkwoAhgQdEUNAiAAKAKcASADQYwsbGoiBSgC3CsiCARAIAgQECAFQgA3AtwrCyAEIAY2AhAgAkEEQeb8ACAEQRBqEA8gAyAJRgRAIAEgACgCyAEpAwhCAnwgAhA2DQFBACEFIAJBAUGnKUEAEA8MAwsgBCAHNgIEIAQgBjYCACACQQJB3eUAIAQQD0EAIQUgACAEQcgAakEAIARBxABqIARBQGsgBEE8aiAEQThqIARBNGogBEHMAGogASACECcNAQwCCwsgACACEHIhBQsgBEHQAGokACAFC8gGAgd/AX4jAEHQAGsiAyQAIANBATYCTAJAAkAgACgCaCIEQQFHDQAgACgCbEEBRw0AIAAoAlQNACAAKAJYDQAgACgCTCIFKAIADQAgBSgCBA0AIAUoAgggACgCXEcNACAFKAIMIAAoAmBHDQBBACEEIAAgA0HIAGpBACADQcQAaiADQUBrIANBPGogA0E4aiADQTRqIANBzABqIAEgAhAnRQ0BAkAgACADKAJIQQBBACABIAIQKwRAIAAoAkwiASgCEA0BQQEhBAwDCyACQQFBkcIAQQAQDwwCCyABKAIYIQFBACECA0AgASACQTRsIgRqKAIsEBAgACgCTCIFKAIYIgEgBGoiBiAAKALQASIHKAIUKAIAKAIUIAJBzABsaiIIKAIkNgIsIAYgBygCGCgCGCAEaigCJDYCJCAIQQA2AiRBASEEIAJBAWoiAiAFKAIQSQ0ACwwBCwNAAkACfwJAIARBAUcNACAAKAJsQQFHDQAgACgCnAEoAtwrRQ0AIANBADYCSCAAQQA2AswBIAAgACgCCEGAAXI2AghBAAwBC0EAIQQgACADQcgAakEAIANBxABqIANBQGsgA0E8aiADQThqIANBNGogA0HMAGogASACECdFDQMgAygCTEUNASADKAJICyIHQQFqIQQgACAHQQBBACABIAIQKyEJIAAoAmggACgCbGwhBSAJRQRAIAMgBTYCBCADIAQ2AgAgAkEBQZc5IAMQD0EAIQQMAwsgAyAFNgIkIAMgBDYCICACQQRBoNcAIANBIGoQDyAAKALQASAAKAJMKAIYEHRFBEBBACEEDAMLAkACQCAAKAJoQQFHDQAgACgCbEEBRw0AIAAoAkwiBSgCACAAKAJIIgYoAgBHDQEgBSgCBCAGKAIERw0BIAUoAgggBigCCEcNASAFKAIMIAYoAgxHDQELIAAoApwBIAdBjCxsaiIFKALcKyIGRQ0AIAYQECAFQgA3AtwrCyADIAQ2AhAgAkEEQeb8ACADQRBqEA8gASkDCCIKUAR+QgAFIAogASkDOH0LUARAIAAoAghBwABGDQELIAhBAWoiCCAAKAJoIgQgACgCbGxHDQELCyAAIAIQciEECyADQdAAaiQAIAQLtQYBDH8gACgCSCEJAkAgACgCaCAAKAJsbCIMBEAgCSgCECIBQbgIbCENIAEgAWxBAnQhCiAAKAIMIQQgACgCnAEhAwNAIAMoAtArIQsgAyAEQYwsEBIiAUEANgLoKyABQX82AtQrIAFBADYCsCggAUEANgKELCABQQA2AvArIAFCADcC+CsgASALNgLQKyABIAEtAIgsQfwBcToAiCwgBCgC6CsEQCABIAoQFCIDNgLoKyADRQRAQQAPCyADIAQoAugrIAoQEhoLIAEgBCgC+CtBFGwiBRAUIgM2AvArQQAhCCADRQ0CIAMgBCgC8CsgBRASGiAEKAL0KyIGBEAgBCgC8CshAyABKALwKyEFQQAhBwNAIAMoAgwEQCAFIAMoAhAQFCIGNgIMIAZFBEBBAA8LIAYgAygCDCADKAIQEBIaIAQoAvQrIQYLIAEgASgC+CtBAWo2AvgrIAVBFGohBSADQRRqIQMgB0EBaiIHIAZJDQALCyABIAQoAoQsQRRsIgUQFCIDNgL8KyADRQ0CIAMgBCgC/CsgBRASGiABIAQoAoQsIgg2AoQsIAgEQCAEKAL8KyEDIAEoAvwrIQVBACEHA0AgAygCCCIGBEAgBSABKALwKyAGIAQoAvAra2o2AggLIAMoAgwiBgRAIAUgASgC8CsgBiAEKALwK2tqNgIMCyAFQRRqIQUgA0EUaiEDIAdBAWoiByAIRw0ACwsgCyAEKALQKyANEBIaIAFBjCxqIQMgDkEBaiIOIAxHDQALC0EBIQggAAJ/QQBBAUHIABATIgFFDQAaIAEgAS0AKEH+AXFBAXI6ACggAUEBQQQQEyIENgIUIAEgBA0AGiABEBBBAAsiATYC0AEgAUUEQEEADwsgACgC1AEhBUEAIQQgASAAQdAAajYCHCABIAk2AhhBAUHQBhATIQMgASgCFCADNgIAAkAgA0UNACAJKAIQQcwAEBMhAyABKAIUKAIAIgcgAzYCFCADRQ0AIAcgCSgCEDYCECAAKAKkASEEIAEgBTYCLCABIAQ2AgBBASEECyAEDQAgACgC0AEQVUEAIQggAEEANgLQASACQQFBwhtBABAPCyAIC9USAwx/AX0BfiMAQTBrIggkACAAQQE2AggCfwJAAkAgASAIQShqIgVBAiACEBpBAkcNACAFIAhBLGpBAhARIAgoAixBz/4DRw0AIABBAjYCCCAAKALIASABKQM4QgJ9IhA3AwAgCCAQNwMQIAJBBEHu3gAgCEEQahAPIAAoAsgBIgMpAwAhECADKAIYIgdBAWoiBSADKAIgIgRNBEAgAygCHCEEDAILIAMCfyAEs0MAAMhCkiIPQwAAgE9dIA9DAAAAAGBxBEAgD6kMAQtBAAsiBTYCICADKAIcIAVBGGwQFyIEBEAgAyAENgIcIAMoAhgiB0EBaiEFDAILIAMoAhwQECADQQA2AiAgA0IANwMYIAJBAUGpHUEAEA8LIAJBAUG19QBBABAPQQAMAQsgBCAHQRhsaiIEQQI2AhAgBCAQxDcDCCAEQc/+AzsBACADIAU2AhggASAAKAIQQQIgAhAaQQJHBEAgAkEBQZYSQQAQD0EADAELIAAoAhAgCEEoakECEBECQAJAIAgoAigiBEGQ/wNHBEADQEHgvQEhByAEQf/9A00EQCAIIAQ2AgAgAkEBQcoQIAgQD0EADAULA0AgByIFKAIAIgMEQCAFQQxqIQcgAyAERw0BCwsCQAJAIAMNAEECIQYgAkECQfUcQQAQD0GWEiEHAkACQCABIAAoAhBBAiACEBpBAkcNAANAIAAoAhAgCEEsakECEBFB4L0BIQMgCCgCLCIEQYD+A08EQANAIAMiBSgCACIMBEAgA0EMaiEDIAQgDEcNAQsLIAUoAgQgACgCCHFFBEBB/CghBwwDCyAMBEAgDEGQ/wNGBEAgCEGQ/wM2AigMBwsgASkDOCEQIAAoAsgBIgMoAhgiBUEBaiIEIAMoAiAiB00EQCADKAIcIQcMBQsgAwJ/IAezQwAAyEKSIg9DAACAT10gD0MAAAAAYHEEQCAPqQwBC0EACyIFNgIgIAMoAhwgBUEYbBAXIgcEQCADIAc2AhwgAygCGCIFQQFqIQQMBQsgAygCHBAQIANBADYCICADQgA3AxhBqR0hBwwDCyAGQQJqIQYLIAEgACgCEEECIAIQGkECRg0ACwsgAkEBIAdBABAPIAJBAUH9yABBABAPQQAMBwsgByAFQRhsaiIFIAY2AhAgBSAQpyAGa6w3AwggBUEAOwEAIAMgBDYCGCAIIAw2AihB4L0BIQQDQCAEIgUoAgAiA0UNASAEQQxqIQQgAyAMRw0ACwsgBSgCBCAAKAIIcUUEQCACQQFB/ChBABAPQQAMBgsgASAAKAIQQQIgAhAaQQJHBEAgAkEBQZYSQQAQD0EADAYLIAAoAhAgCEEkakECEBEgCCgCJCIEQQFNBEAgAkEBQaEuQQAQD0EADAYLIAggBEECayIHNgIkIAAoAhAhBCAAKAIUIAdJBEAgBCAHEBciBEUEQCAAKAIQEBAgAEIANwMQIAJBAUHUJUEAEA9BAAwHCyAAIAQ2AhAgACAIKAIkIgc2AhQLIAEgBCAHIAIQGiIEIAgoAiRHBEAgAkEBQZYSQQAQD0EADAYLIAAgACgCECAEIAIgBSgCCBEBAEUEQCACQQFBqBJBABAPQQAMBgsgASkDOCEQIAgoAiQhDAJAIAAoAsgBIgUoAhgiBkEBaiIHIAUoAiAiBE0EQCAFKAIcIQQMAQsgBQJ/IASzQwAAyEKSIg9DAACAT10gD0MAAAAAYHEEQCAPqQwBC0EACyIENgIgIAUoAhwgBEEYbBAXIgRFDQUgBSAENgIcIAUoAhgiBkEBaiEHCyAEIAZBGGxqIgQgDEEEajYCECAEIBCnIAxrQQRrrDcDCCAEIAM7AQAgBSAHNgIYIAEgACgCEEECIAIQGkECRwRAIAJBAUGWEkEAEA9BAAwGC0EBIAogA0Hc/gNGGyEKQQEgCyADQdL+A0YbIQtBASANIANB0f4DRhshDSAAKAIQIAhBKGpBAhARIAgoAigiBEGQ/wNHDQELCyANDQELIAJBAUGYJEEAEA9BAAwCCyALRQRAIAJBAUHGJEEAEA9BAAwCCyAKRQRAIAJBAUH0JEEAEA9BAAwCC0EAIQNBACENIwBBEGsiBCQAQQEhBwJAIAAtALwBQQFxRQ0AAkAgACgCcCILRQ0AAkADQCAAKAJ0IA1BA3RqIgUoAgAiCgRAIAMgBSgCBCIGayIFQQAgAyAFTxshBSADIAZJBEAgBiADayELIAMgCmohCgNAIAtBBEkEQEGOKyEDDAULIAogBEEMakEEEBEgBCgCDCIDQX9zIAlJBEBB9CohAwwFCyADIAtBBGsiBmsgBSADIAZLIgwbIQUgAyAJaiEJIAYgA2shCyAKQQAgAyAMG2pBBGohCiADIAZJDQALIAAoAnAhCwsgBSEDCyANQQFqIg0gC0kNAAsgA0UNAUEAIQcgAkEBQekWQQAQDwwCC0EAIQcgAkEBIANBABAPDAELIAAgCRAUIgM2AogBIANFBEBBACEHIAJBAUG+IEEAEA8MAQsgACAJNgJ8IAAoAnQhBgJAIAAoAnAiCgRAQQAhCUEAIQNBACEFA0AgBiAFQQN0Ig1qIgwoAgAiCwRAIAAoAogBIANqIQoCfyAMKAIEIgYgCU0EQCAKIAsgBhASGiADIAZqIQMgCSAGawwBCyAKIAsgCRASGiADIAlqIQMgBiAJayIGBEAgCSALaiEJA0AgBkEESQ0GIAkgBEEIakEEEBEgCUEEaiEJIAAoAogBIANqIQogBkEEayIGIAQoAggiC0kEQCAKIAkgBhASGiADIAZqIQMgBCgCCCAGawwDCyAKIAkgCxASGiAEKAIIIgogA2ohAyAJIApqIQkgBiAKayIGDQALC0EACyEJIAAoAnQgDWooAgAQECAAKAJ0IgYgDWpCADcCACAAKAJwIQoLIAVBAWoiBSAKSQ0ACyAAKAJ8IQkgACgCiAEhAwsgACAJNgKQASAAIAM2AnggAEEANgJwIAYQECAAQQA2AnQMAQtBACEHIAJBAUGOK0EAEA8LIARBEGokACAHRQRAIAJBAUGPPUEAEA9BAAwCCyACQQRB99YAQQAQDyAAKALIASABKQM4Qv7///8PfEL/////D4M3AwggAEEINgIIQQEMAQsgBSgCHBAQIAVBADYCICAFQgA3AxggAkEBQakdQQAQD0EACyEOIAhBMGokACAOCxwAIAAoAghFIAAoAsABQQBHIAAoAsQBQQBHcXELBABBAAsPACAABEAgACABNgK4AQsLjwEBBH8gACgCGCIBBEAgACgCHCIDQTRuIQQgA0E0TwR/QQAhAwNAIAEoAgAiAgRAIAJBAWsQECABQQA2AgALIAEoAgQiAgRAIAIQECABQQA2AgQLIAEoAggiAgRAIAIQECABQQA2AggLIAFBNGohASADQQFqIgMgBEcNAAsgACgCGAUgAQsQECAAQQA2AhgLC4YBAQR/IAAoAhgiAQRAIAAoAhwiAkHAAE8EfyACQQZ2IQRBACECA0AgASgCACIDBEAgAxAQIAFBADYCAAsgASgCBCIDBEAgAxAQIAFBADYCBAsgASgCPBAQIAFBADYCPCABQUBrIQEgAkEBaiICIARHDQALIAAoAhgFIAELEBAgAEEANgIYCws/AQF/IAAEQCAAKAJ0IgEEQCABEBAgAEEANgJ0CyAAKAJ4IgEEQCABEBAgAEEANgJ4CyAAKAKUARAQIAAQEAsLwaYFBFx/AnsGfgF9IwBB4ABrIiMkACAAKAIIIRoCQAJAAkACQCAAKAIARQRAIBogGigCECAaKAIIayAaKAIUIBooAgxrbEECdCIGEBgiAzYCPCADRQRAIAAoAiQaIAAoAiBBAUHRPEEAEA8gACgCJBogAEEcaiEQDAMLIANBACAGEBUaDAELIBooAjwiA0UNACADEBAgGkEANgI8CyAAKAIQIjIoAhwgMigCGEGYAWxqIgNBmAFrKAIAITUgA0GQAWsoAgAhNiAAKAIUIS8gACgCDCEwIAAoAgQhNyAAKAIcKAIARQ0CIABBHGohEAJAAn9BACABKAIEIgNBAEwNABogASgCACEGAkADQCAGIAdBDGxqIgQoAgBFDQEgB0EBaiIHIANHDQALQQAMAQsgBCgCBAsiBA0AQQFBnAEQEyIERQRAIAAoAiBBAUGQMEEAEA8MAgsgBEEANgKMASABKAIEIgNB/////wdHBH8CfyABKAIAIQYgA0EASgRAA0AgBiAJQQxsaiIHKAIARQRAIAcoAggiAwR/IAcoAgQgAxECACABKAIABSAGCyAJQQxsaiIBQQ82AgggASAENgIEQQEMAwsgCUEBaiIJIANHDQALC0EAIAYgA0EMbEEMahAXIgNFDQAaIAEgAzYCACADIAEoAgQiBkEMbGoiA0EPNgIIIAMgBDYCBCADQQA2AgAgASAGQQFqNgIEQQELBUEACw0AIAAoAiBBAUGMP0EAEA8gBCgCdCIBBEAgARAQIARBADYCdAsgBCgCeCIBBEAgARAQIARBADYCeAsgBCgClAEQECAEEBAMAQsgBCAAKAIYNgKQASAAKAIoISsgACgCJCEhIAAoAiAhHSAvKAKoBiERIDAoAhAhAQJAAkAgLygCECIWQcAAcQRAIBYhCiMAQbACayIPJAACQCARBEAgIQRAQQAhByAdQQFBgRhBABAPDAILQQAhByAdQQFBgRhBABAPDAELIAQoAnQhBwJAAkAgGigCFCAaKAIMayIDIBooAhAgGigCCGsiBmwiASAEKAKEAUsEQCAHEBAgBCABQQJ0IhEQGCIHNgJ0IAdFBEBBACEHDAQLIAQgATYChAEMAQsgB0UNASABQQJ0IRELIAdBACAREBUaCyAEKAJ4IQcCQCAEKAKIAUHPFEsNACAHEBAgBEHA0gAQGCIHNgJ4IAcNAEEAIQcMAQsgBEHQFDYCiAEgB0EAQcDSABAVGiAEIAM2AoABIAQgBjYCfCAaKAIYIgJFBEBBASEHDAELIBooAhwhDUEBIQcCQAJAAkACQAJAIBooAjQiAwRAIBooAgQhCUEAIQdBACEBAkAgA0EETwRAIANBfHEhAQNAIAkgCEEDdGoiBkEcaiAGQRRqIAZBDGogBv0JAgT9VgIAAf1WAgAC/VYCAAMgXv2uASFeIAhBBGoiCCABRw0ACyBeIF4gXv0NCAkKCwwNDg8AAQIDAAECA/2uASJeIF4gXv0NBAUGBwABAgMAAQIDAAECA/2uAf0bACEHIAEgA0YNAQsDQCAJIAFBA3RqKAIEIAdqIQcgAUEBaiIBIANHDQALCyADQQFGBEAgBCgCkAFFDQULIAcgBCgCmAFNDQEgBCgClAEgBxAXIhENAkEAIQcMBgsgBCgCkAFFDQULIAQoApQBIhENAUEAIQcMBAsgBCAHNgKYASAEIBE2ApQBCyAaKAI0RQRAQQAhBwwCCyAaKAIEIQhBACEHQQAhAQNAIAcgEWogCCABQQN0IgNqIgYoAgAgBigCBBASGiAaKAIEIgggA2ooAgQgB2ohByABQQFqIgEgGigCNEkNAAsMAQsgGigCBCgCACERC0EAIQFBACEIAn9BACAaKAIoIgNFDQAaIBooAgAiBigCCCEIQQAgA0EBRg0AGiAGKAIgCyEDIAIgDWshRQJAIAMgCGoiCEUEQEEAIQkMAQtBASEBIBooAgAiAygCACEFQQAhCSAIQQFGBEBBACEBDAELIAMoAhghCQsgRUEBaiEWIAQoAnQhDiAEKAJ4IRQgGigCDCESIBooAhQhGCAaKAIIISQgGigCECErAkACQAJAAkACQAJAAkACQAJAIAFFDQAgCQ0AICFFDQEgHUECQaHQAEEAEA9BASEIDAILIAhBBEkNASAhBEAgDyAINgJwIB1BAUH8xgAgD0HwAGoQDwwICyAPIAg2AmAgHUEBQfzGACAPQeAAahAPQQAhBwwICyAdQQJBodAAQQAQDyAaKAIYIgFBHksNAUEBIQwgASAWTw0DDAULIBooAhgiAUEeTQ0BICFFDQAgDyABNgIgIB1BAUGb2wAgD0EgahAPDAULIA8gATYCACAdQQFBm9sAIA8QD0EAIQcMBQsgASAWSQ0BIAhBAkkEQCAIIQwMAQsgASAWRwRAIAghDAwBC0EBIQxBkMcBLQAADQAgIUUEQEGQxwFBAToAACAPIAg2AkAgHUECQabMACAPQUBrEA8MAQtBkMcBLQAARQRAQZDHAUEBOgAAIA8gCDYCUCAdQQJBpswAIA9B0ABqEA8LCwJAAkAgBUECSQ0AIAUgB0sNACAFIAlqIAdNDQELICEEQEEAIQcgHUEBQcLGAEEAEA8MBQtBACEHIB1BAUHCxgBBABAPDAQLAkACQCAFIBFqIhNBAWstAABBBHQgE0ECay0AAEEPcXIiBkECSQ0AIAUgBkgNACAGQfAfSQ0BCyAhBEBBACEHIB1BAUHW8gBBABAPDAULQQAhByAdQQFB1vIAQQAQDwwECyAaKAIcISYgD0EANgKQAiAPQQA2ApgCIA9CADcDiAIgD0IANwOoAiAPQgA3ApwCIA8gBkEBayIHNgKUAiAPIAUgEWogBmsiATYCgAJC/wEhYCAGQQJPBEAgATEAACFgC0EIIQMgD0EINgKQAiAPIAZBAmsiCDYClAIgDyBgQg+EIGAgB0EBRhsiYDcDiAIgDyABIAZBAUpqIgc2AoACIA8gYEL/AVEiDTYCmAICfwJAIAFBA3EiAkEDRg0AQv8BIWEgDQRAQQAgBy0AAEGPAUsNAhoLIAZBA04EQCAHMQAAIWELIA8gBkEDayINNgKUAiAPQQ9BECBgQv8BUSILGyIDNgKQAiAPIAcgBkECSmoiATYCgAIgDyBhQg+EIGEgCEEBRhsiYUL/AVE2ApgCIA8gYEIHQgggCxuGIGGEImA3A4gCIAJBAkYNACBhQv8BUQRAQQAgAS0AAEGPAUsNAhoLQv8BIWIgBkEETgRAIAExAAAhYgsgDyAGQQRrIgc2ApQCIA8gASAGQQNKaiIBNgKAAiAPIGJCD4QgYiANQQFGGyJiQv8BUTYCmAIgDyADQQdBCCBhQv8BUSIIG2oiAzYCkAIgDyBgQgdCCCAIG4YgYoQiYDcDiAIgAkEBRg0AQv8BIWEgYkL/AVEEQEEAIAEtAABBjwFLDQIaCyAGQQVOBEAgATEAACFhCyAPIAZBBWs2ApQCIA8gASAGQQRKajYCgAIgDyBhQg+EIGEgB0EBRhsiYUL/AVE2ApgCIA8gA0EHQQggYkL/AVEiARtqIgM2ApACIA8gYEIHQgggARuGIGGEImA3A4gCCyAPIGBBwAAgA2uthjcDiAJBAQtFBEAgIQRAQQAhByAdQQFBg9UAQQAQDwwFC0EAIQcgHUEBQYPVAEEAEA8MBAsgKyAkayEVIA8gBkECayILNgL0ASAPIAUgEWoiAkEDayIDNgLgASAPIAJBAmstAAAiGUGPAUsiDTYC+AEgDyAZQQR2rSJgNwPoASAPQQNBBCBgQgeDQgdRGyIBNgLwASADQQNxQQFqIgcgCyAHIAtIGyEIAkACQCAGQQJMBEAgDyALIAhrIgI2AvQBDAELIA8gAkEEayIHNgLgASAPIAMtAAAiF0GPAUsiDTYC+AEgDyAXrSJhIAGthiBghCJgNwPoASAPQQhBB0EIIGFC/wCDQv8AURsgGUGPAU0bIAFqIgE2AvABAkAgCEEBRgRAIAchAwwBCyAPIAJBBWsiAzYC4AEgDyAHLQAAIhlBjwFLIg02AvgBIA8gGa0iYSABrYYgYIQiYDcD6AEgD0EIQQdBCCBhQv8Ag0L/AFEbIBdBjwFNGyABaiIBNgLwASAIQQJGDQAgDyACQQZrIgc2AuABIA8gAy0AACIXQY8BSyINNgL4ASAPIBetImEgAa2GIGCEImA3A+gBIA9BCEEHQQggYUL/AINC/wBRGyAZQY8BTRsgAWoiATYC8AEgCEEDRgRAIAchAwwBCyAPIAJBB2siAzYC4AEgDyAHMQAAImFCjwFWIg02AvgBIA8gYSABrYYgYIQiYDcD6AEgD0EIQQdBCCBhQv8Ag0L/AFEbIBdBjwFNGyABaiIBNgLwAQsgDyALIAhrIgI2AvQBIAFBIEsNAQsCQCACQQROBEAgA0EDaygCACEHIA8gAkEEazYC9AEgDyADQQRrNgLgAQwBCyACQQBMBEBBACEHDAELIAJBAXEhRwJAIAJBAUYEQEEYIQhBACEHDAELIAJB/v///wdxIRdBGCEIQQAhB0EAIQsDQCAPIANBAWsiHzYC4AEgAy0AACFGIA8gA0ECayIDNgLgASAPIAJBAWs2AvQBIB8tAAAhHyAPIAJBAmsiAjYC9AEgRiAIdCAHciAfIAhBCGt0ciEHIAhBEGshCCALQQJqIgsgF0cNAAsLIEdFDQAgDyADQQFrNgLgASADLQAAIUggDyACQQFrNgL0ASBIIAh0IAdyIQcLIA8gB0H/AXEiA0GPAUs2AvgBIA9BB0EIIAdBgICA+AdxQYCAgPgHRhtBCCANGyICQQhBB0EIIAdBgID8A3FBgID8A0YbIAdB/////3hNG2oiCEEIQQdBCCAHQYD+AXFBgP4BRhsgB0EQdkH/AXEiDUGPAU0baiILQQhBB0EIIAdB/wBxQf8ARhsgB0EIdkH/AXEiGUGPAU0bIAFqajYC8AEgDyANIAJ0IAdBGHZyIBkgCHRyIAMgC3RyrSABrYYgYIQ3A+gBCyAPQcABaiARIAUgBmtB/wEQWwJ/QQAgDEECSQ0AGiAPQaABaiATIAlBABBbQQAgDEECRg0AGkIAIWBCACFiIA9BATYCmAEgD0EANgKQASAPQgA3A4gBIA8gCUEBayIGNgKUASAPIAUgEWogCWoiA0EBayIBNgKAASABQQNxIQUCQCAJQQBMBEAgASEDDAELIA8gA0ECayIDNgKAASABMQAAIWALIA8gYDcDiAEgDyBgQo8BViIRNgKYASAPQQdBCCBgQv8Ag0L/AFEbIg02ApABAkAgBUUNACAPIAlBAmsiAjYClAECQCAJQQJIBEAgAyEHDAELIA8gA0EBayIHNgKAASADMQAAIWILIA8gYkKPAVYiETYCmAEgDyBiIA2thiBghCJhNwOIASAPQQhBB0EIIGJC/wCDQv8AURsgYEKPAVgbIA1qIg02ApABIAVBAUYEQCAHIQMgYSFgIAYhCSACIQYMAQsgDyAJQQNrIgg2ApQBAkAgCUEDSARAIAchAQwBCyAPIAdBAWsiATYCgAEgBzEAACFjCyAPIGNCjwFWIhE2ApgBIA8gYyANrYYgYYQiYDcDiAEgD0EIQQdBCCBjQv8Ag0L/AFEbIGJCjwFYGyANaiINNgKQASAFQQJGBEAgASEDIAIhCSAIIQYMAQsgDyAJQQRrIgY2ApQBQgAhYgJAIAlBBEgEQCABIQMMAQsgDyABQQFrIgM2AoABIAExAAAhYgsgDyBiQo8BViIRNgKYASAPIGIgDa2GIGCEImA3A4gBIA9BCEEHQQggYkL/AINC/wBRGyBjQo8BWBsgDWoiDTYCkAEgCCEJCyANQSBNBEACQCAJQQVOBEAgA0EDaygCACEHIA8gCUEFazYClAEgDyADQQRrNgKAAQwBC0EAIQcgCUECSA0AQRghCQNAIA8gA0EBayIBNgKAASADLQAAIUkgDyAGQQFrIgI2ApQBIEkgCXQgB3IhByAGQQFLIUogASEDIAlBCGshCSACIQYgSg0ACwsgDyAHQf8BcSIBQY8BSzYCmAEgD0EHQQggB0GAgID4B3FBgICA+AdGG0EIIBEbIgNBCEEHQQggB0GAgPwDcUGAgPwDRhsgB0H/////eE0baiIGQQhBB0EIIAdBgP4BcUGA/gFGGyAHQRB2Qf8BcSIJQY8BTRtqIgJBCEEHQQggB0H/AHFB/wBGGyAHQQh2Qf8BcSIIQY8BTRsgDWpqNgKQASAPIAkgA3QgB0EYdnIgCCAGdHIgASACdHKtIA2thiBghDcDiAELQQELITEgGCASayEfIBZBAWohLCAUQQA6AMAQIBRBwBBqIQsgD0GAAmoQKCECIBVBAEoEQCAmQQFrIRMgFCEDIAshCEEAIREgDiEGQQAhDQNAIA0hBSARQQh0IA9B4AFqEC9B/wBxQQF0ckGg/QBqLwEAIQECQCARDQAgAUEAIAJBAmsiB0F/RhshASACQQFKBEAgByECDAELIA9BgAJqECghAgsgDykD6AEhZCAPKALwASFLIAMgAygCACABQQR2IhhBA3EgAUECdkEwcXIgInRyIhY2AgAgAUEFdkEHcSABQRBxIh5BBHZyIREgSyABQQdxIgdrIQ0gZCAHrYgiYKchCUEAIQcgFSAFQQJySgRAIBFBCHQgCUH/AHFBAXRyQaD9AGovAQAhBwJAIBENACAHQQAgAkECayIJQX9GGyEHIAJBAUoEQCAJIQIMAQsgD0GAAmoQKCECCyAHQQR2QQFxIAdBBXZBB3FyIREgDSAHQQdxIglrIQ0gYCAJrYgiYKchCQsgAyAHQQJ0QYAGcSAHQTBxciAiQQRqdCAWcjYCAAJAIAdBAnZBAnEgAUEDdkEBcXIiF0EDRw0AQQRBAyACQQJrIhZBf0YbIRcgAkEBSgRAIBYhAgwBCyAPQYACahAoIQILAn8gF0UEQCAPQoGAgIAQNwJ4QQAMAQsgF0ECTQRAIA9BASAJQQdxQdSdAWotAAAiFkEFdkF/IBZBAnZBB3EiGXRBf3MgCSAWQQNxIgl2cWpBAWoiFiAXQQFGIhcbNgJ8IA8gFkEBIBcbNgJ4IAkgGWoMAQsgCSAJQQdxQdSdAWotAAAiFkEDcSIZdiEJIBdBA0YEQCAWQQV2QQFqIRcgGUEDRgRAIA8gCUEBcUECcjYCfCAPIBdBfyAWQQJ2QQdxIhZ0QX9zIAlBAXZxajYCeCAWQQRqDAILIA8gFyAJIAlBB3FB1J0Bai0AACIJQQNxIhJ2IiBBfyAWQQJ2QQdxIhZ0QX9zcWo2AnggD0F/IAlBAnZBB3EiF3RBf3MgICAWdnEgCUEFdmpBAWo2AnwgFiAZaiASaiAXagwBCyAPIAkgCUEHcUHUnQFqLQAAIglBA3EiEnYiIEF/IBZBAnZBB3EiF3RBf3NxIBZBBXZqQQNqNgJ4IA9BfyAJQQJ2QQdxIhZ0QX9zICAgF3ZxIAlBBXZqQQNqNgJ8IBIgGWogF2ogFmoLIQkCQCAsIA8oAngiGU8EQCAPKAJ8IhIgLE0NAQsgIQRAQQAhByAdQQFBmfYAQQAQDwwHC0EAIQcgHUEBQZn2AEEAEA8MBgsgDyANIAlrNgLwASAPIGAgCa2INwPoASAHQfABcSAYQQ9xckH/AUH/ASAFQQRqIg0gFWtBAXR2IA0gFUwbIgkgCUHVAHEgH0EBShsiCUF/c3EEQCAhBEBBACEHIB1BAUGv2gBBABAPDAcLQQAhByAdQQFBr9oAQQAQDwwGCwJAAkAgHgRAIA9BwAFqEBshFyAPIA8oAtABIBkgAUETdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAXQX8gFnRBf3NxIAFBCHZBAXEgFnRyQQFyQQJqIBN0IBdBH3RyIRYMAQtBACEWIAlBAXFFDQELIAYgFjYCAAsCQCABQSBxBEAgD0HAAWoQGyEXIA8gDygC0AEgGSABQRJ0QR91aiIWazYC0AEgDyAPKQPIASAWrYg3A8gBIAYgFUECdGogF0F/IBZ0QX9zcSABQQl2QQFxIBZ0ckEBciIWQQJqIBN0IBdBH3RyNgIAIAhBICAWZ2siFiAILQAAQf8AcSIXIBYgF0sbQYABcjoAAAwBCyAJQQJxRQ0AIAYgFUECdGpBADYCAAsgBkEEaiEXAkACQCABQcAAcQRAIA9BwAFqEBshGCAPIA8oAtABIBkgAUERdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAYQX8gFnRBf3NxIAFBCnZBAXEgFnRyQQFyQQJqIBN0IBhBH3RyIRYMAQtBACEWIAlBBHFFDQELIBcgFjYCAAsgCEEAOgABAkAgAUGAAXEEQCAPQcABahAbIRggDyAPKALQASAZIAFBEHRBH3VqIhZrNgLQASAPIA8pA8gBIBatiDcDyAEgFyAVQQJ0aiAYQX8gFnRBf3NxIAFBC3ZBAXEgFnRyQQFyIgFBAmogE3QgGEEfdHI2AgAgCEGgfyABZ2s6AAEMAQsgCUEIcUUNACAXIBVBAnRqQQA2AgALIAZBCGohAQJAAkAgB0EQcQRAIA9BwAFqEBshGSAPIA8oAtABIBIgB0ETdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAZQX8gFnRBf3NxIAdBCHZBAXEgFnRyQQFyQQJqIBN0IBlBH3RyIRcMAQtBACEXIAlBEHFFDQELIAEgFzYCAAsCQCAHQSBxBEAgD0HAAWoQGyEZIA8gDygC0AEgEiAHQRJ0QR91aiIWazYC0AEgDyAPKQPIASAWrYg3A8gBIAEgFUECdGogGUF/IBZ0QX9zcSAHQQl2QQFxIBZ0ckEBciIBQQJqIBN0IBlBH3RyNgIAIAhBICABZ2siASAILQABQf8AcSIWIAEgFksbQYABcjoAAQwBCyAJQSBxRQ0AIAEgFUECdGpBADYCAAsgBkEMaiEBAkACQCAHQcAAcQRAIA9BwAFqEBshGSAPIA8oAtABIBIgB0ERdEEfdWoiFms2AtABIA8gDykDyAEgFq2INwPIASAZQX8gFnRBf3NxIAdBCnZBAXEgFnRyQQFyQQJqIBN0IBlBH3RyIRcMAQtBACEXIAlBwABxRQ0BCyABIBc2AgALIAhBAmoiCEEAOgAAAkAgB0GAAXEEQCAPQcABahAbIRYgDyAPKALQASASIAdBEHRBH3VqIglrNgLQASAPIA8pA8gBIAmtiDcDyAEgASAVQQJ0aiAWQX8gCXRBf3NxIAdBC3ZBAXEgCXRyQQFyIgFBAmogE3QgFkEfdHI2AgAgCEGgfyABZ2s6AAAMAQsgCUGAAUkNACABIBVBAnRqQQA2AgALICJBEHMhIiADIAVBBHFqIQMgBkEQaiEGIA0gFUgNAAsLIApBCHEhOCAUQbAMaiEoIBRBoAhqISkgFEGQBGohJSAfQQNOBEAgFUEDbCE5IBVBAXQhOiAmQQFrISBBAyAmQQJrIgF0IS1BASABdCEuIBVBB2pBAXZB/P///wdxQQRqIT0gKyAkQX9zaiIBQQN2IgNBAnQiPkEEaiE7IANBAWoiP0H8////A3EiHEECdCE8IBxBA3QhEiABQRhJIUBBAiEZA0AgGSETIAstAAAhFiALQQA6AAAgIkFvcUECcyEiAkAgFUEATARAIBNBAmohGQwBCyAlIBQgE0EEcRshESATQQJqIRkgDiATIBVsQQJ0aiEIQQAhCiALIQZBACENA0AgDSEFIAYtAAFBBXZBBHEgCiAWQQd2cnIiA0EIdCAPQeABahAvQf8AcUEBdHJBoI0Bai8BACEBAkAgAw0AIAFBACACQQJrIgNBf0YbIQEgAkEBSgRAIAMhAgwBCyAPQYACahAoIQILIA8pA+gBIWUgDygC8AEhTCARIBEoAgAgAUEEdkEDcSABQQJ2QTBxciAidHIiCTYCACABQcAAcSIqQQV2IAFBgAFxIidBBnZyIQogTCABQQdxIgNrIRcgZSADrYgiYKchDUEAIRgCQCAVIAVBAnJMBEBBACEHDAELIAogBi0AAkEFdkEEcSAGLQABQQd2cnIiA0EIdCANQf8AcUEBdHJBoI0Bai8BACEHAkAgAw0AIAdBACACQQJrIgNBf0YbIQcgAkEBSgRAIAMhAgwBCyAPQYACahAoIQILIAdBBXYgB0EGdnJBAnEhCiAXIAdBB3EiA2shFyBgIAOtiCJgpyENCyARIAdBAnRBgAZxIAdBMHFyICJBBGp0IAlyNgIAQQEhCUEBIQMCQCAHQQJ2QQJxIAFBA3ZBAXFyIh5FDQAgDSANQQdxQdSdAWotAAAiA0EDcSINdiEJIB5BA0cEQEEBIAlBfyADQQJ2QQdxIhh0QX9zcSADQQV2akEBaiIDIB5BAUYiHhshCSADQQEgHhshAyANIBhqIRgMAQsgCUEHcUHUnQFqLQAAIh5BA3EiMyANIANBAnZBB3EiG2pqIB5BAnZBB3EiDWohGCAJIDN2IglBfyAbdEF/c3EgA0EFdmpBAWohA0F/IA10QX9zIAkgG3ZxIB5BBXZqQQFqIQkLIA8gFyAYazYC8AEgDyBgIBitiDcD6AEgAUHwAXEiDSANQQFrcQRAIAMgFkH/AHEiFiAGLQABQf8AcSIXIBYgF0sbIhZBAmsiF0EAIBYgF08baiEDCyAHQfABcSIXIBdBAWtxBEAgCSAGLQABQf8AcSIWIAYtAAJB/wBxIhggFiAYSxsiFkECa0EAIBZBAksbaiEJCyADICxNIAkgLE1xRQRAICEEQEEAIQcgHUEBQf32AEEAEA8MCQtBACEHIB1BAUH99gBBABAPDAgLIAYtAAIhFiAGQQA7AAEgFyANQQR2ckH/AUH/ASAFQQRqIg0gFWtBAXR2IA0gFUwbIhdB1QBxIBcgGSAfShsiGEF/c3EEQCAhBEBBACEHIB1BAUGv2gBBABAPDAkLQQAhByAdQQFBr9oAQQAQDwwICwJAAkAgAUEQcQRAIA9BwAFqEBshHiAPIA8oAtABIAMgAUETdEEfdWoiF2s2AtABIA8gDykDyAEgF62INwPIASAeQX8gF3RBf3NxIAFBCHZBAXEgF3RyQQFyQQJqICB0IB5BH3RyIRcMAQtBACEXIBhBAXFFDQELIAggFzYCAAsCQCABQSBxBEAgD0HAAWoQGyEeIA8gDygC0AEgAyABQRJ0QR91aiIXazYC0AEgDyAPKQPIASAXrYg3A8gBIAggFUECdGogHkF/IBd0QX9zcSABQQl2QQFxIBd0ckEBciIXQQJqICB0IB5BH3RyNgIAIAZBICAXZ2siFyAGLQAAQf8AcSIeIBcgHksbQYABcjoAAAwBCyAYQQJxRQ0AIAggFUECdGpBADYCAAsgCEEEaiEeAkACQCAqBEAgD0HAAWoQGyEbIA8gDygC0AEgAyABQRF0QR91aiIXazYC0AEgDyAPKQPIASAXrYg3A8gBIBtBfyAXdEF/c3EgAUEKdkEBcSAXdHJBAXJBAmogIHQgG0EfdHIhFwwBC0EAIRcgGEEEcUUNAQsgHiAXNgIACwJAICcEQCAPQcABahAbIRcgDyAPKALQASADIAFBEHRBH3VqIgNrNgLQASAPIA8pA8gBIAOtiDcDyAEgHiAVQQJ0aiAXQX8gA3RBf3NxIAFBC3ZBAXEgA3RyQQFyIgFBAmogIHQgF0EfdHI2AgAgBkGgfyABZ2s6AAEMAQsgGEEIcUUNACAeIBVBAnRqQQA2AgALIAhBCGohAQJAAkAgB0EQcQRAIA9BwAFqEBshFyAPIA8oAtABIAkgB0ETdEEfdWoiA2s2AtABIA8gDykDyAEgA62INwPIASAXQX8gA3RBf3NxIAdBCHZBAXEgA3RyQQFyQQJqICB0IBdBH3RyIQMMAQtBACEDIBhBEHFFDQELIAEgAzYCAAsCQCAHQSBxBEAgD0HAAWoQGyEXIA8gDygC0AEgCSAHQRJ0QR91aiIDazYC0AEgDyAPKQPIASADrYg3A8gBIAEgFUECdGogF0F/IAN0QX9zcSAHQQl2QQFxIAN0ckEBciIBQQJqICB0IBdBH3RyNgIAIAZBICABZ2siASAGLQABQf8AcSIDIAEgA0sbQYABcjoAAQwBCyAYQSBxRQ0AIAEgFUECdGpBADYCAAsgCEEMaiEBAkACQCAHQcAAcQRAIA9BwAFqEBshFyAPIA8oAtABIAkgB0ERdEEfdWoiA2s2AtABIA8gDykDyAEgA62INwPIASAXQX8gA3RBf3NxIAdBCnZBAXEgA3RyQQFyQQJqICB0IBdBH3RyIQMMAQtBACEDIBhBwABxRQ0BCyABIAM2AgALIAZBAmohBgJAIAdBgAFxBEAgD0HAAWoQGyEXIA8gDygC0AEgCSAHQRB0QR91aiIDazYC0AEgDyAPKQPIASADrYg3A8gBIAEgFUECdGogF0F/IAN0QX9zcSAHQQt2QQFxIAN0ckEBciIBQQJqICB0IBdBH3RyNgIAIAZBoH8gAWdrOgAADAELIBhBgAFJDQAgASAVQQJ0akEANgIACyAiQRBzISIgESAFQQRxaiERIAhBEGohCCANIBVIDQALCwJAIAxBAkkNACATQQJxRQ0AIBlBBHEhAwJAAn8CQAJAIDEEQCAUICUgAxshFkEAIRggFUEATA0BIA4gE0ECayAVbEECdGohEQNAIA9BgAFqEC8hB0EAIQEgFigCACIIBEAgESAYQQJ0aiEBQQAhCUEPIQYDQAJAIAYgCHFFDQAgBkGRosSIAXEiDSAIcQRAIAEgASgCACAHQX9zQQFxICB0cyAucjYCACAHQQF2IQcLIA1BAXQgCHEEQCABIBVBAnRqIgUgBSgCACAHQX9zQQFxICB0cyAucjYCACAHQQF2IQcLIA1BAnQgCHEEQCABIDpBAnRqIgUgBSgCACAHQX9zQQFxICB0cyAucjYCACAHQQF2IQcLIA1BA3QgCHFFDQAgASA5QQJ0aiINIA0oAgAgB0F/c0EBcSAgdHMgLnI2AgAgB0EBdiEHCyABQQRqIQEgBkEEdCEGIAlBAWoiCUEIRw0ACyAIaSEBCyAWQQRqIRYgDyAPKAKQASABazYCkAEgDyAPKQOIASABrYg3A4gBIBhBCGoiGCAVSA0ACwsgKSAoIAMbIQUgFCAlIAMbIRYgA0UhGCAVQQBMDQNBACEDIEANASAFIBYgO2pJIBYgBSA7aiIHSXENAUEAIAUiASAWIgYgPmpBCGpJIAZBBGogB0lxDQIaIAYgPGohBiABIDxqIQH9DAAAAAAAAAAAAAAAAAAAAAAhXkEAIQcDQCAFIAdBAnQiA2oiCSADIBZqIgP9AAIAIl9BBP2tASBfQQT9qwEgXiBf/Q0MDQ4PEBESExQVFhcYGRobQRz9rQH9UP1QIF/9UCJe/QsCACAJIF4gA/0AAgRBHP2rAf1QIl5BAf2tAf0Md3d3d3d3d3d3d3d3d3d3d/1OIF5BAf2rAf0M7u7u7u7u7u7u7u7u7u7u7v1O/VAgXv1QIF/9T/0LAgAgXyFeIAdBBGoiByAcRw0ACyAcID9GDQMgEiEDIF79GwMMAgsgA0UhGCApICggAxshBQwCCyAFIQEgFiEGQQALIQcDQCAHQRx2IQkgASAGKAIAIgdBBHYgCSAHQQR0cnIgB3IiCTYCACABIAkgBigCBEEcdHIiCUEBdkH37t27B3EgCUEBdEHu3bv3fnFyIAlyIAdBf3NxNgIAIAFBBGohASAGQQRqIQYgA0EIaiIDIBVIDQALCyATQQZJDQBBACEJQQAhESAWIQEgKSAoIBgbIhshByAUICUgGBsiFyEGAkAgFUEATCINDQADQCABQQRqIQMgBygCACEIIAEoAgAhASAHIDgEfyAIBSABQQR0IBFBHHZyIAFBBHZyIAMoAgBBHHRyIAFyQQN0QYiRosR4cSAIcgsgBigCAEF/c3E2AgAgBkEEaiEGIAdBBGohByABIREgAyEBIAlBCGoiCSAVSA0ACyANDQAgDiATQQZrIBVsQQJ0aiFBQQAhHiAXIREDQEEAIQMgGygCACIBBEAgFSAeayFCQQAhB0EAIQoDQCAHIU0gD0GgAWoQGyEHAkAgCiAKQQRqIgYgQiAGIB5qIBVIGyIzTiJDBEBBACEGDAELIBEoAgBBf3MhKiBBIAogHnJBAnRqIRhBACEGQQ8gCiIJQQJ0IkR0Ig0hCANAAkAgASAIcUUNACAIQZGixIgBcSInIAFxBEAgB0EBcQRAIAMgJ3IhA0EyIAlBAnR0ICpxIAFyIQELIAdBAXYhByAGQQFqIQYLIAEgJ0EBdCI0cQRAIAdBAXEEQCADIDRyIQMgAUH0ACAJQQJ0dCAqcXIhAQsgB0EBdiEHIAZBAWohBgsgASAnQQJ0IjRxBEAgB0EBcQRAIAMgNHIhAyABQegBIAlBAnR0ICpxciEBCyAHQQF2IQcgBkEBaiEGCyABICdBA3QiJ3FFDQAgB0EBcQRAIAMgJ3IhAyABQcABIAlBAnR0ICpxciEBCyAGQQFqIQYgB0EBdiEHCyAIQQR0IQggCUEBaiIJIDNIDQALIAMgRHZB//8DcUUNACBDDQADQAJAIAMgDXFFDQAgDUGRosSIAXEiCSADcQRAIBggGCgCACAHQR90ciAtcjYCACAHQQF2IQcgBkEBaiEGCyAJQQF0IANxBEAgGCAVQQJ0aiIIIAgoAgAgB0EfdHIgLXI2AgAgB0EBdiEHIAZBAWohBgsgCUECdCADcQRAIBggOkECdGoiCCAIKAIAIAdBH3RyIC1yNgIAIAdBAXYhByAGQQFqIQYLIAlBA3QgA3FFDQAgGCA5QQJ0aiIJIAkoAgAgB0EfdHIgLXI2AgAgBkEBaiEGIAdBAXYhBwsgDUEEdCENIBhBBGohGCAKQQFqIgogM0gNAAsLIA8gDygCsAEgBms2ArABIA8gDykDqAEgBq2INwOoAUEBIQdBBCEKIE1BAXFFDQALIBsgGygCBCADQRt2QQ5xIANBHXZyIANBHHZyIBEoAgRBf3NxcjYCBAsgESgCACADciIDQQN2QZGixIgBcSIBQQR2IAFBBHRyIAFyIQYgHgRAIAVBBGsiByAHKAIAIBZBBGsoAgBBf3MgAUEcdHFyNgIACyAFIAUoAgAgBiAWKAIAQX9zcXI2AgAgBSAFKAIEIBYoAgRBf3MgA0EfdnFyNgIEIBtBBGohGyARQQRqIREgBUEEaiEFIBZBBGohFiAeQQhqIh4gFUgNAAsLIBdBACA9EBUaCyAZIB9IDQALCwJAIAxBAkkNAAJAIB9BA3FBAWsiFkECSSAxcQRAIBVBAEwNAUEBICZBAmt0IQIgDiAfQfz//wdxIBVsQQJ0aiERICUgFCAfQQRxGyEFICZBAWshCEEAIQogFUEMbCEMIBVBA3QhCwNAIA9BgAFqEC8hB0EAIQEgBSgCACIDBEAgESAKQQJ0aiEBQQ8hBkEAIQkDQAJAIAMgBnFFDQAgBkGRosSIAXEiDSADcQRAIAEgASgCACAHQX9zQQFxIAh0cyACcjYCACAHQQF2IQcLIA1BAXQgA3EEQCABIBVBAnRqIh0gHSgCACAHQX9zQQFxIAh0cyACcjYCACAHQQF2IQcLIA1BAnQgA3EEQCABIAtqIh0gHSgCACAHQX9zQQFxIAh0cyACcjYCACAHQQF2IQcLIA1BA3QgA3FFDQAgASAMaiINIA0oAgAgB0F/c0EBcSAIdHMgAnI2AgAgB0EBdiEHCyABQQRqIQEgBkEEdCEGIAlBAWoiCUEIRw0ACyADaSEBCyAFQQRqIQUgDyAPKAKQASABazYCkAEgDyAPKQOIASABrYg3A4gBIApBCGoiCiAVSA0ACwsgFkEBSw0AIBVBAEwNACAlIBQgH0EEcSIBGyEJICggKSABGyECQQAhAwJ/AkAgKyAkQX9zaiIBQThJDQAgAiAJIAFBAXZB/P///wdxIgZBBGoiB2pJIAkgAiAHaiIHSXENACACIAYgCWpBCGpJIAlBBGogB0lxDQAgAUEDdkEBaiINQfz///8DcSIIQQN0IQMgCSAIQQJ0IgFqIQYgASACaiEB/QwAAAAAAAAAAAAAAAAAAAAAIV5BACEHA0AgAiAHQQJ0IhZqIhEgCSAWaiIW/QACACJfQQT9rQEgX0EE/asBIF4gX/0NDA0ODxAREhMUFRYXGBkaG0Ec/a0B/VD9UCBf/VAiXv0LAgAgESBeIBb9AAIEQRz9qwH9UCJeQQH9rQH9DHd3d3d3d3d3d3d3d3d3d3f9TiBeQQH9qwH9DO7u7u7u7u7u7u7u7u7u7u79Tv1QIF79UCBf/U/9CwIAIF8hXiAHQQRqIgcgCEcNAAsgCCANRg0CIF79GwMMAQsgAiEBIAkhBkEACyEHA0AgB0EcdiEJIAEgBigCACIHQQR2IAkgB0EEdHJyIAdyIgk2AgAgASAJIAYoAgRBHHRyIglBAXZB9+7duwdxIAlBAXRB7t27935xciAJciAHQX9zcTYCACABQQRqIQEgBkEEaiEGIANBCGoiAyAVSA0ACwsgHyAfQQFqQQNxa0EDa0EAIB9BBkobIhEgH04NAEEDICZBAmt0IRkgKyAkQX9zaiIBQQN2IgNBAnQiK0EEaiEdIANBAWoiA0H8////A3EiEkECdCEhIBJBA3QhFiAVQQxsISwgFUEDdCEtIAFBGEkhJiADIBJGIRsDQAJAAkACQAJAAn8CQCAfIBFrIgFBAWsiA0EDTwRAQX8hFyABQQVIDQUgFUEATA0GICUgFCARQQRxIgEbIQIgKCApIAEbIQkgOARAQQAhBiAmDQQgAiAJIB1qSSACIB1qIAlLcQ0EIAIgIWohASAJICFqIQcDQCAJIAZBAnQiA2oiCCAI/QACACACIANq/QACAP1P/QsCACAGQQRqIgYgEkcNAAsgFiEGIBsNBgwFCyAUICUgARshDUEAIQMgJg0BIAkgDSAdakkgDSAJIB1qIgFJcQ0BIAkgDSArakEIakkgDUEEaiABSXENASAJIAIgHWpJIAEgAktxDQEgAiAhaiEIIAkgIWohASANICFqIQf9DAAAAAAAAAAAAAAAAAAAAAAhXkEAIQYDQCAJIAZBAnQiA2oiBSADIA1qIgz9AAIAIl9BBP2tASBfQQT9qwEgXiBf/Q0MDQ4PEBESExQVFhcYGRobQRz9rQH9UP1QIAz9AAIEQRz9qwH9UCBf/VBBA/2rAf0MiIiIiIiIiIiIiIiIiIiIiP1OIAX9AAIA/VAgAiADav0AAgD9T/0LAgAgXyFeIAZBBGoiBiASRw0ACyAbDQUgFiEDIF79GwMMAgsgA0ECdEHcnQFqKAIAIRcMBAsgDSEHIAkhASACIQhBAAshBgNAIAZBHHYhCSABIAEoAgAgBygCACIGQQR2IAkgBkEEdHJyIAcoAgRBHHRyIAZyQQN0QYiRosR4cXIgCCgCAEF/c3E2AgAgCEEEaiEIIAFBBGohASAHQQRqIQcgA0EIaiIDIBVIDQALDAILIAkhByACIQELA0AgByAHKAIAIAEoAgBBf3NxNgIAIAFBBGohASAHQQRqIQcgBkEIaiIGIBVIDQALCyAVQQBMDQAgJSAUIBFBBHEiARshCiAoICkgARshAiAUICUgARshEyApICggARshHiAOIBEgFWxBAnRqIS5BACEFA0BBACEDIAIoAgAgF3EiAQRAIBUgBWshKkEAIQdBACENA0AgByFOIA9BoAFqEBshBwJAIA0gDUEEaiIGICogBSAGaiAVSBsiJE4iJwRAQQAhBgwBCyAXIAooAgBBf3NxIRggLiAFIA1yQQJ0aiELQQAhBkEPIA0iCUECdCIcdCIgIQgDQAJAIAEgCHFFDQAgCEGRosSIAXEiIiABcQRAIAdBAXEEQCADICJyIQNBMiAJQQJ0dCAYcSABciEBCyAHQQF2IQcgBkEBaiEGCyABICJBAXQiMXEEQCAHQQFxBEAgAyAxciEDIAFB9AAgCUECdHQgGHFyIQELIAdBAXYhByAGQQFqIQYLIAEgIkECdCIxcQRAIAdBAXEEQCADIDFyIQMgAUHoASAJQQJ0dCAYcXIhAQsgB0EBdiEHIAZBAWohBgsgASAiQQN0IiJxRQ0AIAdBAXEEQCADICJyIQMgAUHAASAJQQJ0dCAYcXIhAQsgBkEBaiEGIAdBAXYhBwsgCEEEdCEIIAlBAWoiCSAkSA0ACyADIBx2Qf//A3FFDQAgJw0AA0ACQCADICBxRQ0AICBBkaLEiAFxIgkgA3EEQCALIAsoAgAgB0EfdHIgGXI2AgAgB0EBdiEHIAZBAWohBgsgCUEBdCADcQRAIAsgFUECdGoiCCAIKAIAIAdBH3RyIBlyNgIAIAdBAXYhByAGQQFqIQYLIAlBAnQgA3EEQCALIC1qIgggCCgCACAHQR90ciAZcjYCACAHQQF2IQcgBkEBaiEGCyAJQQN0IANxRQ0AIAsgLGoiCSAJKAIAIAdBH3RyIBlyNgIAIAZBAWohBiAHQQF2IQcLICBBBHQhICALQQRqIQsgDUEBaiINICRIDQALCyAPIA8oArABIAZrNgKwASAPIA8pA6gBIAatiDcDqAFBASEHQQQhDSBOQQFxRQ0ACyACIAIoAgQgA0EbdkEOcSADQR12ciADQRx2ciAKKAIEQX9zcXI2AgQLIAooAgAgA3IiA0EDdkGRosSIAXEiAUEEdiABQQR0ciABciEGIAUEQCAeQQRrIgcgBygCACATQQRrKAIAQX9zIAFBHHRxcjYCAAsgHiAeKAIAIAYgEygCAEF/c3FyNgIAIB4gHigCBCATKAIEQX9zIANBH3ZxcjYCBCACQQRqIQIgCkEEaiEKIB5BBGohHiATQQRqIRMgBUEIaiIFIBVIDQALCyARQQRqIhEgH0gNAAsLQQEhByAfQQBMDQMgFUEATA0DIBVB/P///wdxIgZBAnQhAiAVQQRJIQhBACEJA0AgDiAJIBVsQQJ0aiEDAkACQCAIBEAgAyEHQQAhAQwBCyACIANqIQdBACEBA0AgAyABQQJ0aiINIA39AAIAIl79DP///3////9/////f////3/9TiJf/aEBIF8gXv0MAAAAAAAAAAAAAAAAAAAAAP05/VL9CwIAIAFBBGoiASAGRw0ACyAGIgEgFUYNAQsDQCAHQQAgBygCACIDQf////8HcSINayANIANBAEgbNgIAIAdBBGohByABQQFqIgEgFUcNAAsLQQEhByAJQQFqIgkgH0cNAAsMAwsgIUUNACAPIBooAhg2AjQgDyAWNgIwIB1BAUHcxwAgD0EwahAPDAELIA8gATYCFCAPIBY2AhAgHUEBQdzHACAPQRBqEA9BACEHDAELQQAhBwsgD0GwAmokACAHDQEMAwsgBCABQQl0QdCpAWo2AmwCfyAEKAJ0IQECQAJAIBooAhAgGigCCGsiBSAaKAIUIBooAgxrIglsIgMgBCgChAFLBEAgARAQIAQgA0ECdBAYIgE2AnRBACABRQ0DGiAEIAM2AoQBDAELIAFFDQELIAFBACADQQJ0EBUaCyAEKAJ4IQECQCAFQQJqIgYgCUEDakECdiIMQQJqbCIDIAQoAogBTQRAIANBAnQhCAwBCyABEBAgBCADQQJ0IggQGCIBNgJ4IAENAEEADAELIAQgAzYCiAEgAUEAIAgQFRoCQCAGRQ0AIAQoAngiByEBAkAgBkEETwRAIAcgBkF8cSINQQJ0aiEBQQAhCANAIAcgCEECdGr9DAAAIEkAACBJAAAgSQAAIEn9CwIAIAhBBGoiCCANRw0ACyAGIA1GDQELA0AgAUGAgIDJBDYCACABQQRqIQEgDUEBaiINIAZHDQALCyAHIAxBAWogBmxBAnRqIQNBACENAkACQCAGQQRJBEAgAyEBDAELIAMgBkF8cSINQQJ0aiEBQQAhCANAIAMgCEECdGr9DAAAIEkAACBJAAAgSQAAIEn9CwIAIAhBBGoiCCANRw0ACyAGIA1GDQELA0AgAUGAgIDJBDYCACABQQRqIQEgDUEBaiINIAZHDQALCyAJQQNxIgFFDQAgBkUNAEGAgIDIBEGAgIDABEGAgICABCABQQJGGyABQQFGGyELIAcgBiAMbEECdGohA0EAIQ0CQCAGQQRJBEAgAyEBDAELIAMgBkF8cSINQQJ0aiEBIAv9ESFfQQAhCANAIAMgCEECdGogX/0LAgAgCEEEaiIIIA1HDQALIAYgDUYNAQsDQCABIAs2AgAgAUEEaiEBIA1BAWoiDSAGRw0ACwsgBCAJNgKAASAEIAU2AnxBAQtFDQIgGigCHCARaiIZQR9OBEAgIUUNAiAjIBk2AhAgHUECQdXBACAjQRBqEA8MAwsgBBBaQQAhASAEQbCpATYCZCAEQdCeATYCYCAEQfCeATYCHAJAAkACQAJAIBooAjQiB0EBSw0AIAQoApABRQ0CIAcNAAwBCyAaKAIEIQMgB0EETwRAIAdBfHEhAkEAIQYDQCADIAZBA3RqIgFBHGogAUEUaiABQQxqIAH9CQIE/VYCAAH9VgIAAv1WAgADIF79rgEhXiAGQQRqIgYgAkcNAAsgXiBeIF79DQgJCgsMDQ4PAAECAwABAgP9rgEiXiBeIF79DQQFBgcAAQIDAAECAwABAgP9rgH9GwAhASACIAdGDQELA0AgAyACQQN0aigCBCABaiEBIAJBAWoiAiAHRw0ACwsgAUECaiIDIAQoApgBSwRAIAQoApQBIAMQFyIGRQ0FIAQgBjYClAEgASAGakEAOwAAIAQgAzYCmAEgGigCNCEHCyAEKAKUASEeIAdFDQEgGigCBCEGQQAhAkEAIQEDQCACIB5qIAYgAUEDdCIDaiIGKAIAIAYoAgQQEhogGigCBCIGIANqKAIEIAJqIQIgAUEBaiIBIBooAjRJDQALDAELIAdBAUcNASAaKAIEKAIAIR4LIBooAjwiAQRAIAQoAnQhLCAEIAE2AnQLIBooAiwEQCAWQQhxISUgBEEcaiEPIBZBAXEhLSAWQQJxRSEuQQIhHwNAIB4gKGohASAaKAIAIClBGGxqIiAoAgAhAwJAIC0gH0ECSSAZIBooAhxBBGtMcXEiIgRAIAQgATYCFCAEIAEgA2oiAzYCGCAEIAMvAAA7AXAgA0H/AToAACAEKAIYQf8BOgABIARBADYCCCAEQQA2AgAgBCABNgIQDAELIAQgATYCFCAEIAEgA2oiBjYCGCAEIAYvAAA7AXAgBkH/AToAACAEKAIYQf8BOgABIAQgBEEcajYCaCAEIAE2AhAgBEEANgIMIAQgAwR/IAEtAABBEHQFQYCA/AcLIgM2AgBBASEGIAFBAWohCSABLQABIQcCfyABLQAAQf8BRgRAIAdBkAFPBEAgBEEBNgIMIANBgP4DcgwCCyAEIAk2AhBBACEGIAdBCXQgA2oMAQsgBCAJNgIQIAdBCHQgA3ILIQEgBCAGNgIIIARBgIACNgIEIAQgAUEHdDYCAAsgICgCACEqAkAgGUEATA0AICAoAghFDQAgIiAuciEnQQAhJgNAAkACQAJAAkACQCAfQQFrDgIBAgALICIEQEEBIBl0IgFBAXYgAXIhESAEKAJ8IgVBAnQiDSAEKAJ4akEMaiEBIAQoAnQhBkEAIQggBCgCgAEiA0EETwRAIAVFDQUgBUEDbCECIAVBAXQhDEEAIBFrIQkDQCAMQQJ0IQtBACEDA0ACQCABIgcoAgAiAUUNAAJAIAFBkICAAXENACABQe8DcUUNACAEKAIAIQECQCAEKAIIIhANACABQf8BRiEKIAQoAhAiEC0AACEBAkAgCkUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIAkAgASAQdkEBcUUNAAJAIBANACABQf8BRiEKIAQoAhAiEC0AACEBAkAgCkUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIIAYgCSARIAEgEHZBAXEiEBs2AgAgBCgCfCEBIAdBBGsiCiAKKAIAQSByNgIAIAcgBygCBEEIcjYCBCAHIAcoAgAgEEETdHJBEHI2AgAgJQ0AIAdBfiABa0ECdGoiASABKAIEQYCAAnI2AgQgASABKAIAIBBBH3RyQYCABHI2AgAgAUEEayIBIAEoAgBBgIAIcjYCAAsgByAHKAIAQYCAgAFyIgE2AgALAkAgAUGAgYAIcQ0AIAFB+B5xRQ0AIAQoAgAhAQJAIAQoAggiEA0AIAFB/wFGIQogBCgCECIQLQAAIQECQCAKRQRAIAQgATYCACAEIBBBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAQQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIhA2AgggBwJ/IAEgEHZBAXFFBEAgBygCAAwBCwJAIBANACABQf8BRiEKIAQoAhAiEC0AACEBAkAgCkUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIIAYgDWogCSARIAEgEHZBAXEiARs2AgAgB0EEayIQIBAoAgBBgAJyNgIAIAcgBygCBEHAAHI2AgQgBygCACABQRZ0ckGAAXILQYCAgAhyIgE2AgALAkAgAUGAiIDAAHENACABQcD3AXFFDQAgBCgCACEBAkAgBCgCCCIQDQAgAUH/AUYhCiAEKAIQIhAtAAAhAQJAIApFBEAgBCABNgIAIAQgEEEBajYCEAwBCyABQY8BTQRAIAQgATYCACAEIBBBAWo2AhBBByEQDAILQf8BIQEgBEH/ATYCAAtBCCEQCyAEIBBBAWsiEDYCCCAHAn8gASAQdkEBcUUEQCAHKAIADAELAkAgEA0AIAFB/wFGIQogBCgCECIQLQAAIQECQCAKRQRAIAQgATYCACAEIBBBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAQQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIhA2AgggBiALaiAJIBEgASAQdkEBcSIBGzYCACAHQQRrIhAgECgCAEGAEHI2AgAgByAHKAIEQYAEcjYCBCAHKAIAIAFBGXRyQYAIcgtBgICAwAByIgE2AgALIAFBgMCAgARxDQAgAUGAvA9xRQ0AIAQoAgAhAQJAIAQoAggiEA0AIAFB/wFGIQogBCgCECIQLQAAIQECQCAKRQRAIAQgATYCACAEIBBBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAQQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIhA2AgggASAQdkEBcQRAIAYgAkECdGohTwJAIBANACABQf8BRiEUIAQoAhAiEC0AACEBAkAgFEUEQCAEIAE2AgAgBCAQQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgEEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIQNgIIIE8gCSARIAEgEHZBAXEiEBs2AgAgBCgCfCEBIAdBBGsiCiAKKAIAQYCAAXI2AgAgByAHKAIEQYAgcjYCBCAHIAcoAgAgEEEcdHJBgMAAcjYCACAHIAFBAnRqIgEgASgCBEEEcjYCBCABIAEoAgxBAXI2AgwgASABKAIIIBBBEnRyQQJyNgIICyAHIAcoAgBBgICAgARyNgIACyAGQQRqIQYgB0EEaiEBIANBAWoiAyAFRw0ACyAHQQxqIQEgBiACQQJ0aiEGIAhBBGoiCCAEKAKAASIDQXxxSQ0ACwsgAyAITQ0DIAVFDQNBACETQQAgEWshCyADIRADQAJAIAggEEYEQCAIIRAMAQsgAUEEayEMIAEoAgAhDUEAIQIDQAJAIA0gAkEDbCIHdiIJQZCAgAFxDQAgCUHvA3FFDQAgBCgCACEDAkAgBCgCCCIJDQAgA0H/AUchECAEKAIQIgktAAAhAwJAIBBFBEAgA0GQAU8EQEH/ASEDIARB/wE2AgAMAgsgBCADNgIAIAQgCUEBajYCEEEHIQkMAgsgBCADNgIAIAQgCUEBajYCEAtBCCEJCyAEIAlBAWsiCTYCCAJAIAMgCXZBAXFFDQAgBiACIAVsQQJ0aiFQAkAgCQ0AIANB/wFHIQ0gBCgCECIJLQAAIQMCQCANRQRAIANBkAFPBEBB/wEhAyAEQf8BNgIADAILIAQgAzYCACAEIAlBAWo2AhBBByEJDAILIAQgAzYCACAEIAlBAWo2AhALQQghCQsgBCAJQQFrIgk2AgggUCALIBEgAyAJdkEBcSIJGzYCACAEKAJ8IRAgDCAMKAIAQSAgB3RyNgIAIAEgASgCACAJQRN0QRByIAd0cjYCACABIAEoAgRBCCAHdHI2AgQgAiAlckUEQCABQX4gEGtBAnRqIgMgAygCBEGAgAJyNgIEIAMgAygCACAJQR90ckGAgARyNgIAIANBBGsiAyADKAIAQYCACHI2AgALIAJBA0cNACABIBBBAnRqIgMgAygCBEEEcjYCBCADIAMoAgxBAXI2AgwgAyADKAIIIAlBEnRyQQJyNgIICyABIAEoAgBBgICAASAHdHIiDTYCACAEKAKAASEDCyADIRAgAkEBaiICIAMgCGtJDQALCyAGQQRqIQYgAUEEaiEBIBNBAWoiEyAFRw0ACwwDC0EAIQdBACENQQAhFwJAAkACQAJAIAQoAnwiEEHAAEcNACAEKAKAAUHAAEcNAEEAQQEgGXQiAUEBdiABciIRayEFIARBHGohECAEKAJ4QYwCaiEGIAQoAgghCCAEKAIEIQMgBCgCACECIAQoAmghDCAEKAJ0IQEgFkEIcQ0BA0BBACEXA0AgASEJIAYiBygCACIGBEACQCAGQZCAgAFxDQAgBkHvA3EiAUUNACADIBAgBCgCbCABai0AAEECdGoiDCgCACILKAIAIgFrIQMCfyABIAJBEHZLBEAgCygCBCEKIAwgC0EIQQwgASADSyIUG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIAogCkUgFBsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIQogDCALQQxBCCABIANLIhQbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAKRSAKIBQbDAELIAsoAgQLBH8gAyAQIAcoAgRBEXZBBHEgB0EEayIKKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhRB0LkBai0AAEECdGoiDCgCACILKAIAIgFrIQMgFEHQuwFqLQAAIRMgCSAFIBECfyABIAJBEHZLBEAgCygCBCEUIAwgC0EIQQwgASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIBQgFEUgDhsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIRQgDCALQQxBCCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAURSAUIA4bDAELIAsoAgQLIBNzIgEbNgIAIAogCigCAEEgcjYCACAHIAcoAgRBCHI2AgQgB0GMAmsiCyALKAIAQYCACHI2AgAgB0GEAmsiCyALKAIAQYCAAnI2AgAgB0GIAmsiCyALKAIAIAFBH3RyQYCABHI2AgAgBiABQRN0ckEQcgUgBgtBgICAAXIhBgsCQCAGQYCBgAhxDQAgBkH4HnFFDQAgAyAQIAQoAmwgBkEDdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRR2QQRxIAdBBGsiCigCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAIgCiAKKAIAQYACcjYCACAHIAcoAgRBwAByNgIEIAYgAUEWdHJBgAFyBSAGC0GAgIAIciEGCwJAIAZBgIiAwABxDQAgBkHA9wFxRQ0AIAMgECAEKAJsIAZBBnYiFEHvA3FqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAwJ/IAEgAkEQdksEQCALKAIEIQogDCALQQhBDCABIANLIhMbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgCiAKRSATGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhCiAMIAtBDEEIIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIApFIAogExsMAQsgCygCBAsEfyADIBAgBygCBEEXdkEEcSAHQQRrIgooAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAUQaoBcXJycnIiFEHQuQFqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAyAUQdC7AWotAAAhEyAJIAUgEQJ/IAEgAkEQdksEQCALKAIEIRQgDCALQQhBDCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgFCAURSAOGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhFCAMIAtBDEEIIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIBRFIBQgDhsMAQsgCygCBAsgE3MiARs2AoAEIAogCigCAEGAEHI2AgAgByAHKAIEQYAEcjYCBCAGIAFBGXRyQYAIcgUgBgtBgICAwAByIQYLAkAgBkGAwICABHENACAGQYC8D3FFDQAgAyAQIAQoAmwgBkEJdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRp2QQRxIAdBBGsiCigCAEEcdkEBcSAGQRV2QRBxIAZBGXZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAYgCiAKKAIAQYCAAXI2AgAgByAHKAIEQYAgcjYCBCAHIAcoAoQCQQRyNgKEAiAHIAcoAowCQQFyNgKMAiAHIAcoAogCIAFBEnRyQQJyNgKIAiAGIAFBHHRyQYDAAHIFIAYLQYCAgIAEciEGCyAHIAY2AgALIAdBBGohBiAJQQRqIQEgF0EBaiIXQcAARw0ACyAHQQxqIQYgCUGEBmohASANQTxJIVEgDUEEaiENIFENAAsMAgtBASAZdCIBQQF2IAFyIQ0gBCgCeCIJIBBBAnRqQQxqIQYgBCgCgAEhASAEKAIIIQggBCgCBCEDIAQoAgAhAiAEKAJoIQwgBCgCdCERAkAgFkEIcQRAAkAgAUEESQ0AIBAEQEEAIA1rIRQgBEEcaiEFIBBBDGwhEyAQQQN0IRUDQEEAIQsDQCAGIgkoAgAiBgRAAkAgBkGQgIABcQ0AIAZB7wNxIgFFDQAgAyAFIAQoAmwgAWotAABBAnRqIgwoAgAiCigCACIBayEDAn8gASACQRB2TQRAIAIgAUEQdGshAiADQYCAAnEEQCAKKAIEDAILIAooAgQhDiAMIApBDEEIIAEgA0siEhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEBIAgtAABB/wFHBEAgBCAKNgIQQQghCCABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIA5FIA4gEhsMAQsgCigCBCEOIAwgCkEIQQwgASADSyISG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQMgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIANBCHQgAmohAgwBCyADQY8BTQRAIAQgCjYCECADQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIA4gDkUgEhsLBH8gAyAFIAkoAgRBEXZBBHEgCUEEayIOKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhJB0LkBai0AAEECdGoiDCgCACIKKAIAIgFrIQMgEkHQuwFqLQAAIRggESAUIA0CfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCESIAwgCkEMQQggASADSyIbG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgEkUgEiAbGwwBCyAKKAIEIRIgDCAKQQhBDCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgEiASRSAbGwsgGHMiARs2AgAgDiAOKAIAQSByNgIAIAkgCSgCBEEIcjYCBCAGIAFBE3RyQRByBSAGC0GAgIABciEGCwJAIAZBgIGACHENACAGQfgecUUNACADIAUgBCgCbCAGQQN2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEUdkEEcSAJQQRrIg4oAgBBFnZBAXEgBkEPdkEQcSAGQRN2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBBBAnRqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIBGzYCACAOIA4oAgBBgAJyNgIAIAkgCSgCBEHAAHI2AgQgBiABQRZ0ckGAAXIFIAYLQYCAgAhyIQYLAkAgBkGAiIDAAHENACAGQcD3AXFFDQAgAyAFIAQoAmwgBkEGdiISQe8DcWotAABBAnRqIgwoAgAiCigCACIBayEDAn8gASACQRB2TQRAIAIgAUEQdGshAiADQYCAAnEEQCAKKAIEDAILIAooAgQhDiAMIApBDEEIIAEgA0siGBtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEBIAgtAABB/wFHBEAgBCAKNgIQQQghCCABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIA5FIA4gGBsMAQsgCigCBCEOIAwgCkEIQQwgASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQMgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIANBCHQgAmohAgwBCyADQY8BTQRAIAQgCjYCECADQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIA4gDkUgGBsLBH8gAyAFIAkoAgRBF3ZBBHEgCUEEayIOKAIAQRl2QQFxIAZBEnZBEHEgBkEWdkHAAHEgEkGqAXFycnJyIhJB0LkBai0AAEECdGoiDCgCACIKKAIAIgFrIQMgEkHQuwFqLQAAIRggESAVaiAUIA0CfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCESIAwgCkEMQQggASADSyIbG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgEkUgEiAbGwwBCyAKKAIEIRIgDCAKQQhBDCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgEiASRSAbGwsgGHMiARs2AgAgDiAOKAIAQYAQcjYCACAJIAkoAgRBgARyNgIEIAYgAUEZdHJBgAhyBSAGC0GAgIDAAHIhBgsCQCAGQYDAgIAEcQ0AIAZBgLwPcUUNACADIAUgBCgCbCAGQQl2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEadkEEcSAJQQRrIg4oAgBBHHZBAXEgBkEVdkEQcSAGQRl2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBNqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIKGzYCACAOIA4oAgBBgIABcjYCACAJIAkoAgRBgCByNgIEIAQoAnxBAnQgCWoiASABKAIEQQRyNgIEIAEgASgCDEEBcjYCDCABIAEoAgggCkESdHJBAnI2AgggBiAKQRx0ckGAwAByBSAGC0GAgICABHIhBgsgCSAGNgIACyAJQQRqIQYgEUEEaiERIAtBAWoiCyAQRw0ACyAJQQxqIQYgESATaiERIAdBBGoiByAEKAKAASIBQXxxSQ0ACwwBC0EEIAFBfHEiBiAGQQRNG0EBayIGQXxxQQRqIQcgCSAGQQF0QXhxakEUaiEGCyAEIAg2AgggBCADNgIEIAQgAjYCACAEIAw2AmggEEUNASABIAdNDQEDQCABIAdGIVJBACEIIAchASBSRQRAA0AgBCAGIBEgCCAQbEECdGogDSAIIAQoAnxBAmpBARBZIAhBAWoiCCAEKAKAASIBIAdrSQ0ACwsgBkEEaiEGIBFBBGohESAXQQFqIhcgEEcNAAsMAQsCQCABQQRJDQAgEARAQQAgDWshFCAEQRxqIQUgEEEMbCETIBBBA3QhFQNAQQAhCwNAIAYiCSgCACIGBEACQCAGQZCAgAFxDQAgBkHvA3EiAUUNACADIAUgBCgCbCABai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyISG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiASGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhIbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSASGwsEfyADIAUgCSgCBEERdkEEcSAJQQRrIg4oAgBBE3ZBAXEgBkEOdkEQcSAGQRB2QcAAcSAGQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIKGzYCACAOIA4oAgBBIHI2AgAgCSAJKAIEQQhyNgIEIAlBfiAEKAJ8a0ECdGoiASABKAIEQYCAAnI2AgQgASABKAIAIApBH3RyQYCABHI2AgAgAUEEayIBIAEoAgBBgIAIcjYCACAGIApBE3RyQRByBSAGC0GAgIABciEGCwJAIAZBgIGACHENACAGQfgecUUNACADIAUgBCgCbCAGQQN2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEUdkEEcSAJQQRrIg4oAgBBFnZBAXEgBkEPdkEQcSAGQRN2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBBBAnRqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIBGzYCACAOIA4oAgBBgAJyNgIAIAkgCSgCBEHAAHI2AgQgBiABQRZ0ckGAAXIFIAYLQYCAgAhyIQYLAkAgBkGAiIDAAHENACAGQcD3AXFFDQAgAyAFIAQoAmwgBkEGdiISQe8DcWotAABBAnRqIgwoAgAiCigCACIBayEDAn8gASACQRB2TQRAIAIgAUEQdGshAiADQYCAAnEEQCAKKAIEDAILIAooAgQhDiAMIApBDEEIIAEgA0siGBtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEBIAgtAABB/wFHBEAgBCAKNgIQQQghCCABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIA5FIA4gGBsMAQsgCigCBCEOIAwgCkEIQQwgASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQMgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIANBCHQgAmohAgwBCyADQY8BTQRAIAQgCjYCECADQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIA4gDkUgGBsLBH8gAyAFIAkoAgRBF3ZBBHEgCUEEayIOKAIAQRl2QQFxIAZBEnZBEHEgBkEWdkHAAHEgEkGqAXFycnJyIhJB0LkBai0AAEECdGoiDCgCACIKKAIAIgFrIQMgEkHQuwFqLQAAIRggESAVaiAUIA0CfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCESIAwgCkEMQQggASADSyIbG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgEkUgEiAbGwwBCyAKKAIEIRIgDCAKQQhBDCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgEiASRSAbGwsgGHMiARs2AgAgDiAOKAIAQYAQcjYCACAJIAkoAgRBgARyNgIEIAYgAUEZdHJBgAhyBSAGC0GAgIDAAHIhBgsCQCAGQYDAgIAEcQ0AIAZBgLwPcUUNACADIAUgBCgCbCAGQQl2IhJB7wNxai0AAEECdGoiDCgCACIKKAIAIgFrIQMCfyABIAJBEHZNBEAgAiABQRB0ayECIANBgIACcQRAIAooAgQMAgsgCigCBCEOIAwgCkEMQQggASADSyIYG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCiAILQABIQEgCC0AAEH/AUcEQCAEIAo2AhBBCCEIIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEIDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgLIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgDkUgDiAYGwwBCyAKKAIEIQ4gDCAKQQhBDCABIANLIhgbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhAyAILQAAQf8BRwRAIAQgCjYCEEEIIQggA0EIdCACaiECDAELIANBjwFNBEAgBCAKNgIQIANBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgDiAORSAYGwsEfyADIAUgCSgCBEEadkEEcSAJQQRrIg4oAgBBHHZBAXEgBkEVdkEQcSAGQRl2QcAAcSASQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIMKAIAIgooAgAiAWshAyASQdC7AWotAAAhGCARIBNqIBQgDQJ/IAEgAkEQdk0EQCACIAFBEHRrIQIgA0GAgAJxBEAgCigCBAwCCyAKKAIEIRIgDCAKQQxBCCABIANLIhsbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiEKIAgtAAEhASAILQAAQf8BRwRAIAQgCjYCEEEIIQggAUEIdCACaiECDAELIAFBjwFNBEAgBCAKNgIQIAFBCXQgAmohAkEHIQgMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyASRSASIBsbDAELIAooAgQhEiAMIApBCEEMIAEgA0siGxtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQogCC0AASEDIAgtAABB/wFHBEAgBCAKNgIQQQghCCADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAo2AhAgA0EJdCACaiECQQchCAwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEICyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyASIBJFIBsbCyAYcyIKGzYCACAOIA4oAgBBgIABcjYCACAJIAkoAgRBgCByNgIEIAQoAnxBAnQgCWoiASABKAIEQQRyNgIEIAEgASgCDEEBcjYCDCABIAEoAgggCkESdHJBAnI2AgggBiAKQRx0ckGAwAByBSAGC0GAgICABHIhBgsgCSAGNgIACyAJQQRqIQYgEUEEaiERIAtBAWoiCyAQRw0ACyAJQQxqIQYgESATaiERIAdBBGoiByAEKAKAASIBQXxxSQ0ACwwBC0EEIAFBfHEiBiAGQQRNG0EBayIGQXxxQQRqIQcgCSAGQQF0QXhxakEUaiEGCyAEIAg2AgggBCADNgIEIAQgAjYCACAEIAw2AmggEEUNACABIAdNDQADQCABIAdGIVNBACEIIAchASBTRQRAA0AgBCAGIBEgCCAQbEECdGogDSAIIAQoAnxBAmpBABBZIAhBAWoiCCAEKAKAASIBIAdrSQ0ACwsgBkEEaiEGIBFBBGohESAXQQFqIhcgEEcNAAsLDAILA0BBACEXA0AgASEJIAYiBygCACIGBEACQCAGQZCAgAFxDQAgBkHvA3EiAUUNACADIBAgBCgCbCABai0AAEECdGoiDCgCACILKAIAIgFrIQMCfyABIAJBEHZLBEAgCygCBCEKIAwgC0EIQQwgASADSyIUG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIAogCkUgFBsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIQogDCALQQxBCCABIANLIhQbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAKRSAKIBQbDAELIAsoAgQLBH8gAyAQIAcoAgRBEXZBBHEgB0EEayIKKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhRB0LkBai0AAEECdGoiDCgCACILKAIAIgFrIQMgFEHQuwFqLQAAIRMgCSAFIBECfyABIAJBEHZLBEAgCygCBCEUIAwgC0EIQQwgASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQMgCC0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIANBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCADQQh0IAJqIQILIAhBAWshCCACQQF0IQIgAUEBdCIBQYCAAkkNAAsgASEDIBQgFEUgDhsMAQsgAiABQRB0ayECIANBgIACcUUEQCALKAIEIRQgDCALQQxBCCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhASAILQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgAUEJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIAFBCHQgAmohAgsgCEEBayEIIAJBAXQhAiADQQF0IgNBgIACSQ0ACyAURSAUIA4bDAELIAsoAgQLIBNzIgEbNgIAIAogCigCAEEgcjYCACAHIAcoAgRBCHI2AgQgBiABQRN0ckEQcgUgBgtBgICAAXIhBgsCQCAGQYCBgAhxDQAgBkH4HnFFDQAgAyAQIAQoAmwgBkEDdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRR2QQRxIAdBBGsiCigCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAIgCiAKKAIAQYACcjYCACAHIAcoAgRBwAByNgIEIAYgAUEWdHJBgAFyBSAGC0GAgIAIciEGCwJAIAZBgIiAwABxDQAgBkHA9wFxRQ0AIAMgECAEKAJsIAZBBnYiFEHvA3FqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAwJ/IAEgAkEQdksEQCALKAIEIQogDCALQQhBDCABIANLIhMbaigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgCiAKRSATGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhCiAMIAtBDEEIIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIApFIAogExsMAQsgCygCBAsEfyADIBAgBygCBEEXdkEEcSAHQQRrIgooAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAUQaoBcXJycnIiFEHQuQFqLQAAQQJ0aiIMKAIAIgsoAgAiAWshAyAUQdC7AWotAAAhEyAJIAUgEQJ/IAEgAkEQdksEQCALKAIEIRQgDCALQQhBDCABIANLIg4baigCADYCAANAAkAgCA0AIAQoAhAiCEEBaiELIAgtAAEhAyAILQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghCAwCCyAEIAs2AhAgA0EJdCACaiECQQchCAwBCyAEIAs2AhBBCCEIIANBCHQgAmohAgsgCEEBayEIIAJBAXQhAiABQQF0IgFBgIACSQ0ACyABIQMgFCAURSAOGwwBCyACIAFBEHRrIQIgA0GAgAJxRQRAIAsoAgQhFCAMIAtBDEEIIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEBIAgtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECABQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggAUEIdCACaiECCyAIQQFrIQggAkEBdCECIANBAXQiA0GAgAJJDQALIBRFIBQgDhsMAQsgCygCBAsgE3MiARs2AoAEIAogCigCAEGAEHI2AgAgByAHKAIEQYAEcjYCBCAGIAFBGXRyQYAIcgUgBgtBgICAwAByIQYLAkAgBkGAwICABHENACAGQYC8D3FFDQAgAyAQIAQoAmwgBkEJdiIUQe8DcWotAABBAnRqIgwoAgAiCygCACIBayEDAn8gASACQRB2SwRAIAsoAgQhCiAMIAtBCEEMIAEgA0siExtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAKIApFIBMbDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEKIAwgC0EMQQggASADSyITG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgCkUgCiATGwwBCyALKAIECwR/IAMgECAHKAIEQRp2QQRxIAdBBGsiCigCAEEcdkEBcSAGQRV2QRBxIAZBGXZBwABxIBRBqgFxcnJyciIUQdC5AWotAABBAnRqIgwoAgAiCygCACIBayEDIBRB0LsBai0AACETIAkgBSARAn8gASACQRB2SwRAIAsoAgQhFCAMIAtBCEEMIAEgA0siDhtqKAIANgIAA0ACQCAIDQAgBCgCECIIQQFqIQsgCC0AASEDIAgtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEIDAILIAQgCzYCECADQQl0IAJqIQJBByEIDAELIAQgCzYCEEEIIQggA0EIdCACaiECCyAIQQFrIQggAkEBdCECIAFBAXQiAUGAgAJJDQALIAEhAyAUIBRFIA4bDAELIAIgAUEQdGshAiADQYCAAnFFBEAgCygCBCEUIAwgC0EMQQggASADSyIOG2ooAgA2AgADQAJAIAgNACAEKAIQIghBAWohCyAILQABIQEgCC0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQgMAgsgBCALNgIQIAFBCXQgAmohAkEHIQgMAQsgBCALNgIQQQghCCABQQh0IAJqIQILIAhBAWshCCACQQF0IQIgA0EBdCIDQYCAAkkNAAsgFEUgFCAOGwwBCyALKAIECyATcyIBGzYCgAYgCiAKKAIAQYCAAXI2AgAgByAHKAIEQYAgcjYCBCAHIAcoAoQCQQRyNgKEAiAHIAcoAowCQQFyNgKMAiAHIAcoAogCIAFBEnRyQQJyNgKIAiAGIAFBHHRyQYDAAHIFIAYLQYCAgIAEciEGCyAHIAY2AgALIAdBBGohBiAJQQRqIQEgF0EBaiIXQcAARw0ACyAHQQxqIQYgCUGEBmohASANQTxJIVQgDUEEaiENIFQNAAsLIAQgCDYCCCAEIAM2AgQgBCACNgIAIAQgDDYCaAsMAgsgIgRAQQEgGXRBAXYhCSAEKAJ8IhFBAnQiDCAEKAJ4akEMaiEBIAQoAnQhBkEAIQ0gBCgCgAEiA0EETwRAIBFFDQQgEUEDbCEFIBFBAXQhC0EAIAlrIQIDQCALQQJ0IQpBACEDA0ACQCABIgcoAgAiAUUNACABQZCAgAFxQRBGBEAgBCgCACEBAkAgBCgCCCIQDQAgAUH/AUYhECAEKAIQIggtAAAhAQJAIBBFBEAgBCABNgIAIAQgCEEBajYCEAwBCyABQY8BTQRAIAQgATYCACAEIAhBAWo2AhBBByEQDAILQf8BIQEgBEH/ATYCAAtBCCEQCyAEIBBBAWsiCDYCCCAGIAIgCSABIAh2QQFxIAYoAgAiAUEfdkYbIAFqNgIAIAcgBygCAEGAgMAAciIBNgIACyABQYCBgAhxQYABRgRAIAQoAgAhAQJAIAQoAggiEA0AIAFB/wFGIRAgBCgCECIILQAAIQECQCAQRQRAIAQgATYCACAEIAhBAWo2AhAMAQsgAUGPAU0EQCAEIAE2AgAgBCAIQQFqNgIQQQchEAwCC0H/ASEBIARB/wE2AgALQQghEAsgBCAQQQFrIgg2AgggBiAMaiIQIAIgCSABIAh2QQFxIBAoAgAiAUEfdkYbIAFqNgIAIAcgBygCAEGAgIAEciIBNgIACyABQYCIgMAAcUGACEYEQCAEKAIAIQECQCAEKAIIIhANACABQf8BRiEQIAQoAhAiCC0AACEBAkAgEEUEQCAEIAE2AgAgBCAIQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgCEEBajYCEEEHIRAMAgtB/wEhASAEQf8BNgIAC0EIIRALIAQgEEEBayIINgIIIAYgCmoiECACIAkgASAIdkEBcSAQKAIAIgFBH3ZGGyABajYCACAHIAcoAgBBgICAIHIiATYCAAsgAUGAwICABHFBgMAARw0AIAYgBUECdGohECAEKAIAIQECQCAEKAIIIggNACABQf8BRiEUIAQoAhAiCC0AACEBAkAgFEUEQCAEIAE2AgAgBCAIQQFqNgIQDAELIAFBjwFNBEAgBCABNgIAIAQgCEEBajYCEEEHIQgMAgtB/wEhASAEQf8BNgIAC0EIIQgLIAQgCEEBayIINgIIIBAgAiAJIAEgCHZBAXEgECgCACIBQR92RhsgAWo2AgAgByAHKAIAQYCAgIACcjYCAAsgBkEEaiEGIAdBBGohASADQQFqIgMgEUcNAAsgB0EMaiEBIAYgBUECdGohBiANQQRqIg0gBCgCgAEiA0F8cUkNAAsLIAMgDU0NAiARRQ0CQQAhE0EAIAlrIQUgAyEHA0ACQCAHIA1GBEAgDSEHDAELIAEoAgAhEEEAIQIDQEGQgIABIAJBA2wiB3QgEHFBECAHdEYEQCAGIAIgEWxBAnRqIRAgBCgCACEDAkAgBCgCCCIIDQAgA0H/AUchDCAEKAIQIggtAAAhAwJAIAxFBEAgA0GQAU8EQEH/ASEDIARB/wE2AgAMAgsgBCADNgIAIAQgCEEBajYCEEEHIQgMAgsgBCADNgIAIAQgCEEBajYCEAtBCCEICyAEIAhBAWsiCDYCCCAQIAUgCSADIAh2QQFxIBAoAgAiA0EfdkYbIANqNgIAIAEgASgCAEGAgMAAIAd0ciIQNgIAIAQoAoABIQMLIAMhByACQQFqIgIgAyANa0kNAAsLIAZBBGohBiABQQRqIQEgE0EBaiITIBFHDQALDAILIAQoAnghCCAEKAJ0IQcgBCgCgAEhAwJAIAQoAnwiDEHAAEcNACADQcAARw0AIAhBjAJqIQNBACETQQBBASAZdEEBdiIFayEMIAQoAgghAiAEKAIEIQYgBCgCACEBIAQoAmghDQNAQQAhCANAIAchCSADIhAoAgAiBwRAIAMhVSAHQZCAgAFxQRBGBEAgBiAPQRBBD0EOIAdB7wNxGyAHQYCAwABxG0ECdGoiDSgCACIRKAIAIgNrIQYCfyADIAFBEHZLBEAgESgCBCELIA0gEUEIQQwgAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQYgAi0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIAZBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiAGQQh0IAFqIQELIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIAsgC0UgChsMAQsgASADQRB0ayEBIAZBgIACcUUEQCARKAIEIQsgDSARQQxBCCADIAZLIgobaigCADYCAANAAkAgAg0AIAQoAhAiAkEBaiERIAItAAEhAyACLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgwCCyAEIBE2AhAgA0EJdCABaiEBQQchAgwBCyAEIBE2AhBBCCECIANBCHQgAWohAQsgAkEBayECIAFBAXQhASAGQQF0IgZBgIACSQ0ACyALRSALIAobDAELIBEoAgQLIQMgCSAMIAUgAyAJKAIAIhFBH3ZGGyARajYCACAHQYCAwAByIQcLIAdBgIGACHFBgAFGBEAgBiAPQRBBD0EOIAdB+B5xGyAHQYCAgARxG0ECdGoiDSgCACIRKAIAIgNrIQYCfyADIAFBEHZLBEAgESgCBCELIA0gEUEIQQwgAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQYgAi0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIAZBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiAGQQh0IAFqIQELIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIAsgC0UgChsMAQsgASADQRB0ayEBIAZBgIACcUUEQCARKAIEIQsgDSARQQxBCCADIAZLIgobaigCADYCAANAAkAgAg0AIAQoAhAiAkEBaiERIAItAAEhAyACLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgwCCyAEIBE2AhAgA0EJdCABaiEBQQchAgwBCyAEIBE2AhBBCCECIANBCHQgAWohAQsgAkEBayECIAFBAXQhASAGQQF0IgZBgIACSQ0ACyALRSALIAobDAELIBEoAgQLIQMgCSAMIAUgAyAJKAKAAiIRQR92RhsgEWo2AoACIAdBgICABHIhBwsgB0GAiIDAAHFBgAhGBEAgBiAPQRBBD0EOIAdBwPcBcRsgB0GAgIAgcRtBAnRqIg0oAgAiESgCACIDayEGAn8gAyABQRB2SwRAIBEoAgQhCyANIBFBCEEMIAMgBksiChtqKAIANgIAA0ACQCACDQAgBCgCECICQQFqIREgAi0AASEGIAItAABB/wFGBEAgBkGQAU8EQCAEIAQoAgxBAWo2AgwgAUGA/gNqIQFBCCECDAILIAQgETYCECAGQQl0IAFqIQFBByECDAELIAQgETYCEEEIIQIgBkEIdCABaiEBCyACQQFrIQIgAUEBdCEBIANBAXQiA0GAgAJJDQALIAMhBiALIAtFIAobDAELIAEgA0EQdGshASAGQYCAAnFFBEAgESgCBCELIA0gEUEMQQggAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQMgAi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIANBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiADQQh0IAFqIQELIAJBAWshAiABQQF0IQEgBkEBdCIGQYCAAkkNAAsgC0UgCyAKGwwBCyARKAIECyEDIAkgDCAFIAMgCSgCgAQiEUEfdkYbIBFqNgKABCAHQYCAgCByIQcLIFUgB0GAwICABHFBgMAARgR/IAYgD0EQQQ9BDiAHQYC8D3EbIAdBgICAgAJxG0ECdGoiDSgCACIRKAIAIgNrIQYCfyADIAFBEHZLBEAgESgCBCELIA0gEUEIQQwgAyAGSyIKG2ooAgA2AgADQAJAIAINACAEKAIQIgJBAWohESACLQABIQYgAi0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQIMAgsgBCARNgIQIAZBCXQgAWohAUEHIQIMAQsgBCARNgIQQQghAiAGQQh0IAFqIQELIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIAsgC0UgChsMAQsgASADQRB0ayEBIAZBgIACcUUEQCARKAIEIQsgDSARQQxBCCADIAZLIgobaigCADYCAANAAkAgAg0AIAQoAhAiAkEBaiERIAItAAEhAyACLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgwCCyAEIBE2AhAgA0EJdCABaiEBQQchAgwBCyAEIBE2AhBBCCECIANBCHQgAWohAQsgAkEBayECIAFBAXQhASAGQQF0IgZBgIACSQ0ACyALRSALIAobDAELIBEoAgQLIQMgCSAMIAUgAyAJKAKABiIRQR92RhsgEWo2AoAGIAdBgICAgAJyBSAHCzYCAAsgEEEEaiEDIAlBBGohByAIQQFqIghBwABHDQALIBBBDGohAyAJQYQGaiEHIBNBPEkhViATQQRqIRMgVg0ACyAEIAI2AgggBCAGNgIEIAQgATYCACAEIA02AmgMAgtBASAZdEEBdiELIAggDEECdCIOakEMaiEJIAQoAgghAiAEKAIEIQYgBCgCACEBIAQoAmghDUEAIRECQCADQQRJDQAgDARAIAxBA2whFCAMQQF0IRdBACALayEKA0AgF0ECdCESQQAhCANAIAkiBSgCACIQBEAgEEGQgIABcUEQRgRAIAYgD0EQQQ9BDiAQQe8DcRsgEEGAgMAAcRtBAnRqIg0oAgAiCSgCACIDayEGAn8gAyABQRB2TQRAIAEgA0EQdGshASAGQYCAAnEEQCAJKAIEDAILIAkoAgQhEyANIAlBDEEIIAMgBksiFRtqKAIANgIAA0ACQCACDQAgBCgCECIJQQFqIQIgCS0AASEDIAktAABB/wFHBEAgBCACNgIQQQghAiADQQh0IAFqIQEMAQsgA0GPAU0EQCAEIAI2AhAgA0EJdCABaiEBQQchAgwBCyAEIAQoAgxBAWo2AgwgAUGA/gNqIQFBCCECCyACQQFrIQIgAUEBdCEBIAZBAXQiBkGAgAJJDQALIBNFIBMgFRsMAQsgCSgCBCETIA0gCUEIQQwgAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQYgCS0AAEH/AUcEQCAEIAI2AhBBCCECIAZBCHQgAWohAQwBCyAGQY8BTQRAIAQgAjYCECAGQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIBMgE0UgFRsLIQMgByAKIAsgAyAHKAIAIglBH3ZGGyAJajYCACAQQYCAwAByIRALIBBBgIGACHFBgAFGBEAgBiAPQRBBD0EOIBBB+B5xGyAQQYCAgARxG0ECdGoiDSgCACIJKAIAIgNrIQYCfyADIAFBEHZNBEAgASADQRB0ayEBIAZBgIACcQRAIAkoAgQMAgsgCSgCBCETIA0gCUEMQQggAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQMgCS0AAEH/AUcEQCAEIAI2AhBBCCECIANBCHQgAWohAQwBCyADQY8BTQRAIAQgAjYCECADQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgBkEBdCIGQYCAAkkNAAsgE0UgEyAVGwwBCyAJKAIEIRMgDSAJQQhBDCADIAZLIhUbaigCADYCAANAAkAgAg0AIAQoAhAiCUEBaiECIAktAAEhBiAJLQAAQf8BRwRAIAQgAjYCEEEIIQIgBkEIdCABaiEBDAELIAZBjwFNBEAgBCACNgIQIAZBCXQgAWohAUEHIQIMAQsgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgsgAkEBayECIAFBAXQhASADQQF0IgNBgIACSQ0ACyADIQYgEyATRSAVGwshAyAHIA5qIgkgCiALIAMgCSgCACIJQR92RhsgCWo2AgAgEEGAgIAEciEQCyAQQYCIgMAAcUGACEYEQCAGIA9BEEEPQQ4gEEHA9wFxGyAQQYCAgCBxG0ECdGoiDSgCACIJKAIAIgNrIQYCfyADIAFBEHZNBEAgASADQRB0ayEBIAZBgIACcQRAIAkoAgQMAgsgCSgCBCETIA0gCUEMQQggAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQMgCS0AAEH/AUcEQCAEIAI2AhBBCCECIANBCHQgAWohAQwBCyADQY8BTQRAIAQgAjYCECADQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgBkEBdCIGQYCAAkkNAAsgE0UgEyAVGwwBCyAJKAIEIRMgDSAJQQhBDCADIAZLIhUbaigCADYCAANAAkAgAg0AIAQoAhAiCUEBaiECIAktAAEhBiAJLQAAQf8BRwRAIAQgAjYCEEEIIQIgBkEIdCABaiEBDAELIAZBjwFNBEAgBCACNgIQIAZBCXQgAWohAUEHIQIMAQsgBCAEKAIMQQFqNgIMIAFBgP4DaiEBQQghAgsgAkEBayECIAFBAXQhASADQQF0IgNBgIACSQ0ACyADIQYgEyATRSAVGwshAyAHIBJqIgkgCiALIAMgCSgCACIJQR92RhsgCWo2AgAgEEGAgIAgciEQCyAFIBBBgMCAgARxQYDAAEYEfyAGIA9BEEEPQQ4gEEGAvA9xGyAQQYCAgIACcRtBAnRqIg0oAgAiCSgCACIDayEGAn8gAyABQRB2TQRAIAEgA0EQdGshASAGQYCAAnEEQCAJKAIEDAILIAkoAgQhEyANIAlBDEEIIAMgBksiFRtqKAIANgIAA0ACQCACDQAgBCgCECIJQQFqIQIgCS0AASEDIAktAABB/wFHBEAgBCACNgIQQQghAiADQQh0IAFqIQEMAQsgA0GPAU0EQCAEIAI2AhAgA0EJdCABaiEBQQchAgwBCyAEIAQoAgxBAWo2AgwgAUGA/gNqIQFBCCECCyACQQFrIQIgAUEBdCEBIAZBAXQiBkGAgAJJDQALIBNFIBMgFRsMAQsgCSgCBCETIA0gCUEIQQwgAyAGSyIVG2ooAgA2AgADQAJAIAINACAEKAIQIglBAWohAiAJLQABIQYgCS0AAEH/AUcEQCAEIAI2AhBBCCECIAZBCHQgAWohAQwBCyAGQY8BTQRAIAQgAjYCECAGQQl0IAFqIQFBByECDAELIAQgBCgCDEEBajYCDCABQYD+A2ohAUEIIQILIAJBAWshAiABQQF0IQEgA0EBdCIDQYCAAkkNAAsgAyEGIBMgE0UgFRsLIQMgByAUQQJ0aiIJIAogCyADIAkoAgAiCUEfdkYbIAlqNgIAIBBBgICAgAJyBSAQCzYCAAsgBUEEaiEJIAdBBGohByAIQQFqIgggDEcNAAsgBUEMaiEJIAcgFEECdGohByARQQRqIhEgBCgCgAEiA0F8cUkNAAsMAQtBBCADQXxxIgkgCUEETRtBAWsiCUF8cUEEaiERIAggCUEBdEF4cWpBFGohCQsgBCACNgIIIAQgBjYCBCAEIAE2AgAgBCANNgJoIAxFDQEgAyARTQ0BQQAhE0EAIAtrIRQgAyEBA0ACQCABIBFGBEAgESEBDAELIAkoAgAhAkEAIRADQEGQgIABIBBBA2wiCHQgAnFBECAIdEYEQCAHIAwgEGxBAnRqIQUgBCAPQRBBD0EOIAIgCHYiAUHvA3EbIAFBgIDAAHEbQQJ0aiINNgJoIAQgBCgCBCANKAIAIgIoAgAiAWsiAzYCBAJ/IAEgBCgCACIGQRB2SwRAIAIoAgQhCiAEIAE2AgQgDSACQQhBDCABIANLIg4baigCADYCACAEKAIIIQIDQAJAIAINACAEKAIQIgJBAWohDSACLQABIQMgAi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAGQYD+A2ohBkEIIQIMAgsgBCANNgIQIANBCXQgBmohBkEHIQIMAQsgBCANNgIQQQghAiADQQh0IAZqIQYLIAQgAkEBayICNgIIIAQgBkEBdCIGNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyAKIApFIA4bDAELIAQgBiABQRB0ayIGNgIAIANBgIACcUUEQCACKAIEIQogDSACQQxBCCABIANLIg4baigCADYCACAEKAIIIQIDQAJAIAINACAEKAIQIgJBAWohDSACLQABIQEgAi0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCAGQYD+A2ohBkEIIQIMAgsgBCANNgIQIAFBCXQgBmohBkEHIQIMAQsgBCANNgIQQQghAiABQQh0IAZqIQYLIAQgAkEBayICNgIIIAQgBkEBdCIGNgIAIAQgA0EBdCIDNgIEIANBgIACSQ0ACyAKRSAKIA4bDAELIAIoAgQLIQEgBSAUIAsgASAFKAIAIgNBH3ZGGyADajYCACAJIAkoAgBBgIDAACAIdHIiAjYCACAEKAKAASEDCyAQQQFqIhAgAyIBIBFrSQ0ACwsgCUEEaiEJIAdBBGohByATQQFqIhMgDEcNAAsMAQtBACERQQAhFwJAAkACQAJAIAQoAnwiFEHAAEcNACAEKAKAAUHAAEcNAEEAQQEgGXQiAUEBdiABciIUayETIARB5ABqIQggBEHgAGohECAEQRxqIQsgBCgCeEGMAmohBiAEKAIIIQUgBCgCBCEBIAQoAgAhAiAEKAJoIQkgBCgCdCEDIBZBCHENAQNAQQAhDANAIAMhEQJAAkACfwJAAkAgBiINKAIAIgZFBEAgASAQKAIAIgMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQcgECADQQhBDCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEJIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgByAHRSAKGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhByAQIANBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgAygCBAtFBEAgECEJDAYLIAEgCCgCACIDKAIAIgZrIQECfyAGIAJBEHZLBEAgAygCBCEHIAggA0EIQQwgASAGSSIKG2ooAgAiAzYCAANAAkAgBQ0AIAQoAhAiCUEBaiEFIAktAAEhASAJLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgByAHRSAKGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhByAIIANBDEEIIAEgBkkiChtqKAIAIgM2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQYgCS0AAEH/AUYEQCAGQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSAGQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAKGwwBCyADKAIECyEKIAEgAygCACIGayEBAn8gBiACQRB2SwRAIAMoAgQhByAIIANBCEEMIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIDQQFqIQkgAy0AASEBIAMtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAHIAdFIA4bDAELIAIgBkEQdGshAiABQYCAAnFFBEAgAygCBCEHIAggA0EMQQggASAGSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQMgBi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIANBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAOGwwBCyADKAIECyEDQQAhBiAIIQkCQAJAAkACfwJAAkAgAyAKQQF0cg4EAAEDBQoLIAEgCyANKAIEQRF2QQRxIA1BBGsiBygCAEETdkEBcXIiDkHQuQFqLQAAQQJ0aiIJKAIAIgMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQogCSADQQhBDCABIAZJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEJIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgCiAKRSASGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhCiAJIANBDEEIIAEgBkkiEhtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogEhsMAQsgAygCBAshAyARIBMgFCADIA5B0LsBai0AAHMiAxs2AgAgByAHKAIAQSByNgIAIA0gDSgCBEEIcjYCBCANQYwCayIGIAYoAgBBgIAIcjYCACANQYQCayIGIAYoAgBBgIACcjYCACANQYgCayIGIAYoAgAgA0EfdHJBgIAEcjYCACADQRN0IVcgASALIAQoAmwtAAJBAnRqIgcoAgAiAygCACIGayEBAn8gBiACQRB2SwRAIAMoAgQhCSAHIANBCEEMIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIDQQFqIQcgAy0AASEBIAMtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBzYCECABQQl0IAJqIQJBByEFDAELIAQgBzYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAJIAlFIA4bDAELIAIgBkEQdGshAiABQYCAAnFFBEAgAygCBCEJIAcgA0EMQQggASAGSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohByAGLQABIQMgBi0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAHNgIQIANBCXQgAmohAkEHIQUMAQsgBCAHNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCUUgCSAOGwwBCyADKAIECyEDIFdBEHIiBiADRQ0BGgsgASALIA0oAgRBFHZBBHEgDUEEayIJKAIAQRZ2QQFxIAZBD3ZBEHEgBkETdkHAAHEgBkEDdkGqAXFycnJyIhJB0LkBai0AAEECdGoiCigCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEOIAogB0EIQQwgASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIA4gDkUgChsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQ4gCiAHQQxBCCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAORSAOIAobDAELIAcoAgQLIQMgESATIBQgAyASQdC7AWotAABzIgMbNgKAAiAJIAkoAgBBgAJyNgIAIA0gDSgCBEHAAHI2AgQgBiADQRZ0ckGAAXILIQYgASALIAQoAmwgBkEGdkHvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQogCSAHQQhBDCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEJIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgCiAKRSAOGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhCiAJIAdBDEEIIAEgA0kiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQkgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDhsMAQsgBygCBAtFDQELIAEgCyANKAIEQRd2QQRxIA1BBGsiCSgCAEEZdkEBcSAGQRJ2QRBxIAZBFnZBwABxIAZBBnZBqgFxcnJyciISQdC5AWotAABBAnRqIgooAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAKIAdBCEEMIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIAobDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAogB0EMQQggASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAKGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAQgCSAJKAIAQYAQcjYCACANIA0oAgRBgARyNgIEIAYgA0EZdHJBgAhyIQYLIAEgCyAEKAJsIAZBCXZB7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgDhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIA4bDAELIAcoAgQLRQ0FCyABIAsgDSgCBEEadkEEcSANQQRrIg4oAgBBHHZBAXEgBkEVdkEQcSAGQRl2QcAAcSAGQQl2QaoBcXJycnIiCkHQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiA2shASADIAJBEHZLBEAgBygCBCESIAkgB0EIQQwgASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIBIgEkUgFRsMBAsgAiADQRB0ayECIAFBgIACcQ0BIAcoAgQhEiAJIAdBDEEIIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIBJFIBIgFRsMAwsCQCAGQZCAgAFxDQAgASALIAQoAmwgBkHvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQogCSAHQQhBDCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgCiAKRSAOGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhCiAJIAdBDEEIIAEgA0kiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDhsMAQsgBygCBAtFDQAgASALIA0oAgRBEXZBBHEgDUEEayIKKAIAQRN2QQFxIAZBDnZBEHEgBkEQdkHAAHEgBkGqAXFycnJyIhJB0LkBai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEOIAkgB0EIQQwgASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIA4gDkUgFRsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQ4gCSAHQQxBCCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAORSAOIBUbDAELIAcoAgQLIQMgESATIBQgAyASQdC7AWotAABzIgMbNgIAIAogCigCAEEgcjYCACANIA0oAgRBCHI2AgQgDUGMAmsiByAHKAIAQYCACHI2AgAgDUGEAmsiByAHKAIAQYCAAnI2AgAgDUGIAmsiByAHKAIAIANBH3RyQYCABHI2AgAgBiADQRN0ckEQciEGCwJAIAZBgIGACHENACABIAsgBCgCbCAGQQN2Ig5B7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgEhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBIbDAELIAcoAgQLRQ0AIAEgCyANKAIEQRR2QQRxIA1BBGsiCigCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIA5BqgFxcnJyciISQdC5AWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIBUbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAkgB0EMQQggASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAVGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAIgCiAKKAIAQYACcjYCACANIA0oAgRBwAByNgIEIAYgA0EWdHJBgAFyIQYLAkAgBkGAiIDAAHENACABIAsgBCgCbCAGQQZ2Ig5B7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgEhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBIbDAELIAcoAgQLRQ0AIAEgCyANKAIEQRd2QQRxIA1BBGsiCigCAEEZdkEBcSAGQRJ2QRBxIAZBFnZBwABxIA5BqgFxcnJyciISQdC5AWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIBUbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAkgB0EMQQggASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAVGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAQgCiAKKAIAQYAQcjYCACANIA0oAgRBgARyNgIEIAYgA0EZdHJBgAhyIQYLIAZBgMCAgARxDQMgASALIAQoAmwgBkEJdiISQe8DcWotAABBAnRqIgkoAgAiASgCACIDayEHAn8gAyACQRB2SwRAIAEoAgQhCiAJIAFBCEEMIAMgB0siDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhByAKIApFIA4bDAELIAIgA0EQdGshAiAHQYCAAnFFBEAgASgCBCEKIAkgAUEMQQggAyAHSyIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgNBAWohBSADLQABIQEgAy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgB0EBdCIHQYCAAkkNAAsgCkUgCiAOGwwBCyABKAIEC0UEQCAHIQEMBAsgByALIA0oAgRBGnZBBHEgDUEEayIOKAIAQRx2QQFxIAZBFXZBEHEgBkEZdkHAAHEgEkGqAXFycnJyIgpB0LkBai0AAEECdGoiCSgCACIHKAIAIgFrIQMgASACQRB2SwRAIAcoAgQhEiAJIAdBCEEMIAEgA0siFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIBIgEkUgFRsMAwsgAiABQRB0ayECIANBgIACcUUNASADIQELIAcoAgQMAQsgBygCBCESIAkgB0EMQQggASADSyIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIBJFIBIgFRsLIQMgESATIBQgAyAKQdC7AWotAABzIgMbNgKABiAOIA4oAgBBgIABcjYCACANIA0oAgRBgCByNgIEIA0gDSgChAJBBHI2AoQCIA0gDSgCjAJBAXI2AowCIA0gDSgCiAIgA0ESdHJBAnI2AogCIAYgA0EcdHJBgMAAciEGCyANIAZB////tntxNgIACyANQQRqIQYgEUEEaiEDIAxBAWoiDEHAAEcNAAsgDUEMaiEGIBFBhAZqIQMgF0E8SSFYIBdBBGohFyBYDQALDAILQQEgGXQiAUEBdiABciEOIAQoAngiByAUQQJ0akEMaiEDIAQoAoABIQYgBCgCCCEFIAQoAgQhASAEKAIAIQIgBCgCaCEJIAQoAnQhCwJAAkAgFkEIcQRAIAZBBEkNAiAURQ0BIARB5ABqIRAgBEHgAGohDSAUQQNsIRsgFEEBdCEkQQAgDmshFSAEQRxqIRIDQEEAIRgDQAJAAkACfwJAIAMiCCgCACIDBEACQCADQZCAgAFxDQAgASASIAQoAmwgA0HvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQwgCSAHQQxBCCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAMRSAMIAobDAELIAcoAgQhDCAJIAdBCEEMIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAMIAxFIAobC0UNACABIBIgCCgCBEERdkEEcSAIQQRrIgwoAgBBE3ZBAXEgA0EOdkEQcSADQRB2QcAAcSADQaoBcXJycnIiE0HQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQogCSAHQQxBCCABIAZJIhwbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBwbDAELIAcoAgQhCiAJIAdBCEEMIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAKIApFIBwbCyEGIAsgFSAOIAYgE0HQuwFqLQAAcyIGGzYCACAMIAwoAgBBIHI2AgAgCCAIKAIEQQhyNgIEIAMgBkETdHJBEHIhAwsCQCADQYCBgAhxDQAgASASIAQoAmwgA0EDdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRR2QQRxIAhBBGsiDCgCAEEWdkEBcSADQQ92QRBxIANBE3ZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAUQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAAnI2AgAgCCAIKAIEQcAAcjYCBCADIAZBFnRyQYABciEDCwJAIANBgIiAwABxDQAgASASIAQoAmwgA0EGdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRd2QQRxIAhBBGsiDCgCAEEZdkEBcSADQRJ2QRBxIANBFnZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAkQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAEHI2AgAgCCAIKAIEQYAEcjYCBCADIAZBGXRyQYAIciEDCyADQYDAgIAEcQ0DIAEgEiAEKAJsIANBCXYiCkHvA3FqLQAAQQJ0aiIJKAIAIgEoAgAiBmshBwJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgB0GAgAJxBEAgASgCBAwCCyABKAIEIQwgCSABQQxBCCAGIAdLIhMbaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEFIAYtAAEhASAGLQAAQf8BRwRAIAQgBTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAHQQF0IgdBgIACSQ0ACyAMRSAMIBMbDAELIAEoAgQhDCAJIAFBCEEMIAYgB0siExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhByAMIAxFIBMbC0UEQCAHIQEMBAsgByASIAgoAgRBGnZBBHEgCEEEayIMKAIAQRx2QQFxIANBFXZBEHEgA0EZdkHAAHEgCkGqAXFycnJyIhNB0LkBai0AAEECdGoiCSgCACIKKAIAIgFrIQYgASACQRB2TQRAIAIgAUEQdGshAiAGQYCAAnEEQCAGIQEMAwsgCigCBCEHIAkgCkEMQQggASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQEgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAdFIAcgHBsMAwsgCigCBCEHIAkgCkEIQQwgASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQYgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgCjYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgByAHRSAcGwwCCyABIA0oAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByANIAZBDEEIIAEgA0kiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgDBsMAQsgBigCBCEHIA0gBkEIQQwgASADSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgDBsLRQRAIA0hCQwECyABIBAoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiDBtqKAIAIgY2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQMgCS0AAEH/AUcEQCAEIAU2AhBBCCEFIANBCHQgAmohAgwBCyADQY8BTQRAIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAMGwwBCyAGKAIEIQcgECAGQQhBDCABIANJIgwbaigCACIGNgIAA0ACQCAFDQAgBCgCECIJQQFqIQUgCS0AASEBIAktAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAHIAdFIAwbCyEMIAEgBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgBigCBCEHIBAgBkEIQQwgASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgChsLIQZBACEDIBAhCQJAAkACQAJ/AkACQCAGIAxBAXRyDgQAAQMFCAsgASASIAgoAgRBEXZBBHEgCEEEayIHKAIAQRN2QQFxciIKQdC5AWotAABBAnRqIgkoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhDCAJIAZBDEEIIAEgA0kiExtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBigCBCEMIAkgBkEIQQwgASADSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAwgDEUgExsLIQMgCyAVIA4gAyAKQdC7AWotAABzIgMbNgIAIAcgBygCAEEgcjYCACAIIAgoAgRBCHI2AgQgA0ETdCFZIAEgEiAEKAJsLQACQQJ0aiIHKAIAIgYoAgAiA2shAQJ/IAMgAkEQdk0EQCACIANBEHRrIQIgAUGAgAJxBEAgBigCBAwCCyAGKAIEIQkgByAGQQxBCCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEHIAYtAAEhAyAGLQAAQf8BRwRAIAQgBzYCEEEIIQUgA0EIdCACaiECDAELIANBjwFNBEAgBCAHNgIQIANBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAJRSAJIAobDAELIAYoAgQhCSAHIAZBCEEMIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQcgBi0AASEBIAYtAABB/wFHBEAgBCAHNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAc2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAJIAlFIAobCyEGIFlBEHIiAyAGRQ0BGgsgASASIAgoAgRBFHZBBHEgCEEEayIJKAIAQRZ2QQFxIANBD3ZBEHEgA0ETdkHAAHEgA0EDdkGqAXFycnJyIhNB0LkBai0AAEECdGoiDCgCACIHKAIAIgZrIQECfyAGIAJBEHZNBEAgAiAGQRB0ayECIAFBgIACcQRAIAcoAgQMAgsgBygCBCEKIAwgB0EMQQggASAGSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQYgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgBTYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiAMGwwBCyAHKAIEIQogDCAHQQhBDCABIAZJIgwbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgCiAKRSAMGwshBiALIBRBAnRqIBUgDiAGIBNB0LsBai0AAHMiBhs2AgAgCSAJKAIAQYACcjYCACAIIAgoAgRBwAByNgIEIAMgBkEWdHJBgAFyCyEDIAEgEiAEKAJsIANBBnZB7wNxai0AAEECdGoiCSgCACIHKAIAIgZrIQECfyAGIAJBEHZNBEAgAiAGQRB0ayECIAFBgIACcQRAIAcoAgQMAgsgBygCBCEMIAkgB0EMQQggASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohCSAHLQABIQYgBy0AAEH/AUcEQCAEIAk2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgCTYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDEUgDCAKGwwBCyAHKAIEIQwgCSAHQQhBDCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEJIActAAEhASAHLQAAQf8BRwRAIAQgCTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgDCAMRSAKGwtFDQELIAEgEiAIKAIEQRd2QQRxIAhBBGsiCSgCAEEZdkEBcSADQRJ2QRBxIANBFnZBwABxIANBBnZBqgFxcnJyciITQdC5AWotAABBAnRqIgwoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAMIAdBDEEIIAEgBkkiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDBsMAQsgBygCBCEKIAwgB0EIQQwgASAGSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgDBsLIQYgCyAkQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAkgCSgCAEGAEHI2AgAgCCAIKAIEQYAEcjYCBCADIAZBGXRyQYAIciEDCyABIBIgBCgCbCADQQl2Qe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgChsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgChsLRQ0DCyABIBIgCCgCBEEadkEEcSAIQQRrIgwoAgBBHHZBAXEgA0EVdkEQcSADQRl2QcAAcSADQQl2QaoBcXJycnIiE0HQuQFqLQAAQQJ0aiIJKAIAIgooAgAiBmshASAGIAJBEHZNBEAgAiAGQRB0ayECIAFBgIACcQ0BIAooAgQhByAJIApBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIFQQFqIQogBS0AASEGIAUtAABB/wFHBEAgBCAKNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAo2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgHBsMAgsgCigCBCEHIAkgCkEIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQEgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAcgB0UgHBsMAQsgCigCBAshBiALIBtBAnRqIBUgDiAGIBNB0LsBai0AAHMiBxs2AgAgDCAMKAIAQYCAAXI2AgAgCCAIKAIEQYAgcjYCBCAEKAJ8QQJ0IAhqIgYgBigCBEEEcjYCBCAGIAYoAgxBAXI2AgwgBiAGKAIIIAdBEnRyQQJyNgIIIAMgB0EcdHJBgMAAciEDCyAIIANB////tntxNgIACyAIQQRqIQMgC0EEaiELIBhBAWoiGCAURw0ACyAIQQxqIQMgCyAbQQJ0aiELIBFBBGoiESAEKAKAASIGQXxxSQ0ACwwCCwJAIAZBBEkNACAUBEAgBEHkAGohECAEQeAAaiENIBRBA2whGyAUQQF0ISRBACAOayEVIARBHGohEgNAQQAhGANAAkACQAJ/AkAgAyIIKAIAIgMEQAJAIANBkICAAXENACABIBIgBCgCbCADQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgChsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgChsLRQ0AIAEgEiAIKAIEQRF2QQRxIAhBBGsiDCgCAEETdkEBcSADQQ52QRBxIANBEHZBwABxIANBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAVIA4gBiATQdC7AWotAABzIgcbNgIAIAwgDCgCAEEgcjYCACAIIAgoAgRBCHI2AgQgCEF+IAQoAnxrQQJ0aiIGIAYoAgRBgIACcjYCBCAGIAYoAgAgB0EfdHJBgIAEcjYCACAGQQRrIgYgBigCAEGAgAhyNgIAIAMgB0ETdHJBEHIhAwsCQCADQYCBgAhxDQAgASASIAQoAmwgA0EDdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRR2QQRxIAhBBGsiDCgCAEEWdkEBcSADQQ92QRBxIANBE3ZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAUQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAAnI2AgAgCCAIKAIEQcAAcjYCBCADIAZBFnRyQYABciEDCwJAIANBgIiAwABxDQAgASASIAQoAmwgA0EGdiIKQe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgExsLRQ0AIAEgEiAIKAIEQRd2QQRxIAhBBGsiDCgCAEEZdkEBcSADQRJ2QRBxIANBFnZBwABxIApBqgFxcnJyciITQdC5AWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAJIAdBDEEIIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogHBsMAQsgBygCBCEKIAkgB0EIQQwgASAGSSIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgHBsLIQYgCyAkQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAwgDCgCAEGAEHI2AgAgCCAIKAIEQYAEcjYCBCADIAZBGXRyQYAIciEDCyADQYDAgIAEcQ0DIAEgEiAEKAJsIANBCXYiCkHvA3FqLQAAQQJ0aiIJKAIAIgEoAgAiBmshBwJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgB0GAgAJxBEAgASgCBAwCCyABKAIEIQwgCSABQQxBCCAGIAdLIhMbaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEFIAYtAAEhASAGLQAAQf8BRwRAIAQgBTYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiAHQQF0IgdBgIACSQ0ACyAMRSAMIBMbDAELIAEoAgQhDCAJIAFBCEEMIAYgB0siExtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhByAMIAxFIBMbC0UEQCAHIQEMBAsgByASIAgoAgRBGnZBBHEgCEEEayIMKAIAQRx2QQFxIANBFXZBEHEgA0EZdkHAAHEgCkGqAXFycnJyIhNB0LkBai0AAEECdGoiCSgCACIKKAIAIgFrIQYgASACQRB2TQRAIAIgAUEQdGshAiAGQYCAAnEEQCAGIQEMAwsgCigCBCEHIAkgCkEMQQggASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQEgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCjYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAdFIAcgHBsMAwsgCigCBCEHIAkgCkEIQQwgASAGSyIcG2ooAgA2AgADQAJAIAUNACAEKAIQIgVBAWohCiAFLQABIQYgBS0AAEH/AUcEQCAEIAo2AhBBCCEFIAZBCHQgAmohAgwBCyAGQY8BTQRAIAQgCjYCECAGQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgByAHRSAcGwwCCyABIA0oAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByANIAZBDEEIIAEgA0kiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgDBsMAQsgBigCBCEHIA0gBkEIQQwgASADSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgDBsLRQRAIA0hCQwECyABIBAoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiDBtqKAIAIgY2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQMgCS0AAEH/AUcEQCAEIAU2AhBBCCEFIANBCHQgAmohAgwBCyADQY8BTQRAIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgB0UgByAMGwwBCyAGKAIEIQcgECAGQQhBDCABIANJIgwbaigCACIGNgIAA0ACQCAFDQAgBCgCECIJQQFqIQUgCS0AASEBIAktAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAHIAdFIAwbCyEMIAEgBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhByAQIAZBDEEIIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgBigCBCEHIBAgBkEIQQwgASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAcgB0UgChsLIQZBACEDIBAhCQJAAkACQAJ/AkACQCAGIAxBAXRyDgQAAQMFCAsgASASIAgoAgRBEXZBBHEgCEEEayIHKAIAQRN2QQFxciIKQdC5AWotAABBAnRqIgkoAgAiBigCACIDayEBAn8gAyACQRB2TQRAIAIgA0EQdGshAiABQYCAAnEEQCAGKAIEDAILIAYoAgQhDCAJIAZBDEEIIAEgA0kiExtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFHBEAgBCAJNgIQQQghBSADQQh0IAJqIQIMAQsgA0GPAU0EQCAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgExsMAQsgBigCBCEMIAkgBkEIQQwgASADSSITG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohCSAGLQABIQEgBi0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAwgDEUgExsLIQMgCyAVIA4gAyAKQdC7AWotAABzIgYbNgIAIAcgBygCAEEgcjYCACAIIAgoAgRBCHI2AgQgCEF+IAQoAnxrQQJ0aiIDIAMoAgRBgIACcjYCBCADIAMoAgAgBkEfdHJBgIAEcjYCACADQQRrIgMgAygCAEGAgAhyNgIAIAZBE3QhWiABIBIgBCgCbC0AAkECdGoiBygCACIGKAIAIgNrIQECfyADIAJBEHZNBEAgAiADQRB0ayECIAFBgIACcQRAIAYoAgQMAgsgBigCBCEJIAcgBkEMQQggASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgZBAWohByAGLQABIQMgBi0AAEH/AUcEQCAEIAc2AhBBCCEFIANBCHQgAmohAgwBCyADQY8BTQRAIAQgBzYCECADQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCUUgCSAKGwwBCyAGKAIEIQkgByAGQQhBDCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEHIAYtAAEhASAGLQAAQf8BRwRAIAQgBzYCEEEIIQUgAUEIdCACaiECDAELIAFBjwFNBEAgBCAHNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgCSAJRSAKGwshBiBaQRByIgMgBkUNARoLIAEgEiAIKAIEQRR2QQRxIAhBBGsiCSgCAEEWdkEBcSADQQ92QRBxIANBE3ZBwABxIANBA3ZBqgFxcnJyciITQdC5AWotAABBAnRqIgwoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhCiAMIAdBDEEIIAEgBkkiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEGIActAABB/wFHBEAgBCAFNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAU2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIApFIAogDBsMAQsgBygCBCEKIAwgB0EIQQwgASAGSSIMG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUcEQCAEIAU2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgDBsLIQYgCyAUQQJ0aiAVIA4gBiATQdC7AWotAABzIgYbNgIAIAkgCSgCAEGAAnI2AgAgCCAIKAIEQcAAcjYCBCADIAZBFnRyQYABcgshAyABIBIgBCgCbCADQQZ2Qe8DcWotAABBAnRqIgkoAgAiBygCACIGayEBAn8gBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnEEQCAHKAIEDAILIAcoAgQhDCAJIAdBDEEIIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQkgBy0AASEGIActAABB/wFHBEAgBCAJNgIQQQghBSAGQQh0IAJqIQIMAQsgBkGPAU0EQCAEIAk2AhAgBkEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAxFIAwgChsMAQsgBygCBCEMIAkgB0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohCSAHLQABIQEgBy0AAEH/AUcEQCAEIAk2AhBBCCEFIAFBCHQgAmohAgwBCyABQY8BTQRAIAQgCTYCECABQQl0IAJqIQJBByEFDAELIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQULIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAwgDEUgChsLRQ0BCyABIBIgCCgCBEEXdkEEcSAIQQRrIgkoAgBBGXZBAXEgA0ESdkEQcSADQRZ2QcAAcSADQQZ2QaoBcXJycnIiE0HQuQFqLQAAQQJ0aiIMKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQogDCAHQQxBCCABIAZJIgwbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIAwbDAELIAcoAgQhCiAMIAdBCEEMIAEgBkkiDBtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAKIApFIAwbCyEGIAsgJEECdGogFSAOIAYgE0HQuwFqLQAAcyIGGzYCACAJIAkoAgBBgBByNgIAIAggCCgCBEGABHI2AgQgAyAGQRl0ckGACHIhAwsgASASIAQoAmwgA0EJdkHvA3FqLQAAQQJ0aiIJKAIAIgcoAgAiBmshAQJ/IAYgAkEQdk0EQCACIAZBEHRrIQIgAUGAgAJxBEAgBygCBAwCCyAHKAIEIQwgCSAHQQxBCCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhBiAHLQAAQf8BRwRAIAQgBTYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAFNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAMRSAMIAobDAELIAcoAgQhDCAJIAdBCEEMIAEgBkkiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFHBEAgBCAFNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAMIAxFIAobC0UNAwsgASASIAgoAgRBGnZBBHEgCEEEayIMKAIAQRx2QQFxIANBFXZBEHEgA0EZdkHAAHEgA0EJdkGqAXFycnJyIhNB0LkBai0AAEECdGoiCSgCACIKKAIAIgZrIQEgBiACQRB2TQRAIAIgBkEQdGshAiABQYCAAnENASAKKAIEIQcgCSAKQQxBCCABIAZJIhwbaigCADYCAANAAkAgBQ0AIAQoAhAiBUEBaiEKIAUtAAEhBiAFLQAAQf8BRwRAIAQgCjYCEEEIIQUgBkEIdCACaiECDAELIAZBjwFNBEAgBCAKNgIQIAZBCXQgAmohAkEHIQUMAQsgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAHRSAHIBwbDAILIAooAgQhByAJIApBCEEMIAEgBkkiHBtqKAIANgIAA0ACQCAFDQAgBCgCECIFQQFqIQogBS0AASEBIAUtAABB/wFHBEAgBCAKNgIQQQghBSABQQh0IAJqIQIMAQsgAUGPAU0EQCAEIAo2AhAgAUEJdCACaiECQQchBQwBCyAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFCyAFQQFrIQUgAkEBdCECIAZBAXQiBkGAgAJJDQALIAYhASAHIAdFIBwbDAELIAooAgQLIQYgCyAbQQJ0aiAVIA4gBiATQdC7AWotAABzIgcbNgIAIAwgDCgCAEGAgAFyNgIAIAggCCgCBEGAIHI2AgQgBCgCfEECdCAIaiIGIAYoAgRBBHI2AgQgBiAGKAIMQQFyNgIMIAYgBigCCCAHQRJ0ckECcjYCCCADIAdBHHRyQYDAAHIhAwsgCCADQf///7Z7cTYCAAsgCEEEaiEDIAtBBGohCyAYQQFqIhggFEcNAAsgCEEMaiEDIAsgG0ECdGohCyARQQRqIhEgBCgCgAEiBkF8cUkNAAsMAQtBBCAGQXxxIgMgA0EETRtBAWsiA0F8cUEEaiERIAcgA0EBdEF4cWpBFGohAwsgBCAFNgIIIAQgATYCBCAEIAI2AgAgBCAJNgJoIBRFDQQgBiARTQ0EA0BBACEFIBEgBCgCgAFHBEADQCAEIAMgCyAFIBRsQQJ0aiAOIAVBABBYIAVBAWoiBSAEKAKAASARa0kNAAsLIAMgAygCAEH///+2e3E2AgAgC0EEaiELIANBBGohAyAXQQFqIhcgFEcNAAsMBAtBBCAGQXxxIgMgA0EETRtBAWsiA0F8cUEEaiERIAcgA0EBdEF4cWpBFGohAwsgBCAFNgIIIAQgATYCBCAEIAI2AgAgBCAJNgJoIBRFDQIgBiARTQ0CA0BBACEFIBEgBCgCgAFHBEADQCAEIAMgCyAFIBRsQQJ0aiAOIAVBARBYIAVBAWoiBSAEKAKAASARa0kNAAsLIAMgAygCAEH///+2e3E2AgAgC0EEaiELIANBBGohAyAXQQFqIhcgFEcNAAsMAgsDQEEAIQwDQCADIRECQAJAAn8CQAJAIAYiDSgCACIGRQRAIAEgECgCACIDKAIAIgZrIQECfyAGIAJBEHZLBEAgAygCBCEHIBAgA0EIQQwgASAGSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgNBAWohCSADLQABIQEgAy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAcgB0UgChsMAQsgAiAGQRB0ayECIAFBgIACcUUEQCADKAIEIQcgECADQQxBCCABIAZJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEJIAYtAAEhAyAGLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAHRSAHIAobDAELIAMoAgQLRQRAIBAhCQwGCyABIAgoAgAiAygCACIGayEBAn8gBiACQRB2SwRAIAMoAgQhByAIIANBCEEMIAEgBkkiChtqKAIAIgM2AgADQAJAIAUNACAEKAIQIglBAWohBSAJLQABIQEgCS0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAcgB0UgChsMAQsgAiAGQRB0ayECIAFBgIACcUUEQCADKAIEIQcgCCADQQxBCCABIAZJIgobaigCACIDNgIAA0ACQCAFDQAgBCgCECIJQQFqIQUgCS0AASEGIAktAABB/wFGBEAgBkGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECAGQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgBkEIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgChsMAQsgAygCBAshCiABIAMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQcgCCADQQhBDCABIAZJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEJIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgAUEJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgByAHRSAOGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhByAIIANBDEEIIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQkgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgCTYCECADQQl0IAJqIQJBByEFDAELIAQgCTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAdFIAcgDhsMAQsgAygCBAshA0EAIQYgCCEJAkACQAJAAn8CQAJAIAMgCkEBdHIOBAABAwUKCyABIAsgDSgCBEERdkEEcSANQQRrIgcoAgBBE3ZBAXFyIg5B0LkBai0AAEECdGoiCSgCACIDKAIAIgZrIQECfyAGIAJBEHZLBEAgAygCBCEKIAkgA0EIQQwgASAGSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgNBAWohCSADLQABIQEgAy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgBkEBdCIGQYCAAkkNAAsgBiEBIAogCkUgEhsMAQsgAiAGQRB0ayECIAFBgIACcUUEQCADKAIEIQogCSADQQxBCCABIAZJIhIbaigCADYCAANAAkAgBQ0AIAQoAhAiBkEBaiEJIAYtAAEhAyAGLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIBIbDAELIAMoAgQLIQMgESATIBQgAyAOQdC7AWotAABzIgMbNgIAIAcgBygCAEEgcjYCACANIA0oAgRBCHI2AgQgA0ETdCFbIAEgCyAEKAJsLQACQQJ0aiIHKAIAIgMoAgAiBmshAQJ/IAYgAkEQdksEQCADKAIEIQkgByADQQhBDCABIAZJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiA0EBaiEHIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAc2AhAgAUEJdCACaiECQQchBQwBCyAEIAc2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiAGQQF0IgZBgIACSQ0ACyAGIQEgCSAJRSAOGwwBCyACIAZBEHRrIQIgAUGAgAJxRQRAIAMoAgQhCSAHIANBDEEIIAEgBkkiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIGQQFqIQcgBi0AASEDIAYtAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBzYCECADQQl0IAJqIQJBByEFDAELIAQgBzYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIAlFIAkgDhsMAQsgAygCBAshAyBbQRByIgYgA0UNARoLIAEgCyANKAIEQRR2QQRxIA1BBGsiCSgCAEEWdkEBcSAGQQ92QRBxIAZBE3ZBwABxIAZBA3ZBqgFxcnJyciISQdC5AWotAABBAnRqIgooAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAKIAdBCEEMIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIAobDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAogB0EMQQggASADSSIKG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAKGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCgAIgCSAJKAIAQYACcjYCACANIA0oAgRBwAByNgIEIAYgA0EWdHJBgAFyCyEGIAEgCyAEKAJsIAZBBnZB7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohCSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAJNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAJNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgDhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEJIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAk2AhAgA0EJdCACaiECQQchBQwBCyAEIAk2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIA4bDAELIAcoAgQLRQ0BCyABIAsgDSgCBEEXdkEEcSANQQRrIgkoAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAGQQZ2QaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIKKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQ4gCiAHQQhBDCABIANJIgobaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgDiAORSAKGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhDiAKIAdBDEEIIAEgA0kiChtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIA5FIA4gChsMAQsgBygCBAshAyARIBMgFCADIBJB0LsBai0AAHMiAxs2AoAEIAkgCSgCAEGAEHI2AgAgDSANKAIEQYAEcjYCBCAGIANBGXRyQYAIciEGCyABIAsgBCgCbCAGQQl2Qe8DcWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhCiAJIAdBCEEMIAEgA0kiDhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAKIApFIA4bDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEKIAkgB0EMQQggASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiAOGwwBCyAHKAIEC0UNBQsgASALIA0oAgRBGnZBBHEgDUEEayIOKAIAQRx2QQFxIAZBFXZBEHEgBkEZdkHAAHEgBkEJdkGqAXFycnJyIgpB0LkBai0AAEECdGoiCSgCACIHKAIAIgNrIQEgAyACQRB2SwRAIAcoAgQhEiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASASIBJFIBUbDAQLIAIgA0EQdGshAiABQYCAAnENASAHKAIEIRIgCSAHQQxBCCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyASRSASIBUbDAMLAkAgBkGQgIABcQ0AIAEgCyAEKAJsIAZB7wNxai0AAEECdGoiCSgCACIHKAIAIgNrIQECfyADIAJBEHZLBEAgBygCBCEKIAkgB0EIQQwgASADSSIOG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQEgBy0AAEH/AUYEQCABQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIAFBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSABQQh0IAJqIQILIAVBAWshBSACQQF0IQIgA0EBdCIDQYCAAkkNAAsgAyEBIAogCkUgDhsMAQsgAiADQRB0ayECIAFBgIACcUUEQCAHKAIEIQogCSAHQQxBCCABIANJIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyAKRSAKIA4bDAELIAcoAgQLRQ0AIAEgCyANKAIEQRF2QQRxIA1BBGsiCigCAEETdkEBcSAGQQ52QRBxIAZBEHZBwABxIAZBqgFxcnJyciISQdC5AWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhDiAJIAdBCEEMIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAOIA5FIBUbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEOIAkgB0EMQQggASADSSIVG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgDkUgDiAVGwwBCyAHKAIECyEDIBEgEyAUIAMgEkHQuwFqLQAAcyIDGzYCACAKIAooAgBBIHI2AgAgDSANKAIEQQhyNgIEIAYgA0ETdHJBEHIhBgsCQCAGQYCBgAhxDQAgASALIAQoAmwgBkEDdiIOQe8DcWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhCiAJIAdBCEEMIAEgA0kiEhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAKIApFIBIbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEKIAkgB0EMQQggASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiASGwwBCyAHKAIEC0UNACABIAsgDSgCBEEUdkEEcSANQQRrIgooAgBBFnZBAXEgBkEPdkEQcSAGQRN2QcAAcSAOQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQ4gCSAHQQhBDCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgDiAORSAVGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhDiAJIAdBDEEIIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIA5FIA4gFRsMAQsgBygCBAshAyARIBMgFCADIBJB0LsBai0AAHMiAxs2AoACIAogCigCAEGAAnI2AgAgDSANKAIEQcAAcjYCBCAGIANBFnRyQYABciEGCwJAIAZBgIiAwABxDQAgASALIAQoAmwgBkEGdiIOQe8DcWotAABBAnRqIgkoAgAiBygCACIDayEBAn8gAyACQRB2SwRAIAcoAgQhCiAJIAdBCEEMIAEgA0kiEhtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASAKIApFIBIbDAELIAIgA0EQdGshAiABQYCAAnFFBEAgBygCBCEKIAkgB0EMQQggASADSSISG2ooAgA2AgADQAJAIAUNACAEKAIQIgdBAWohBSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCACQYD+A2ohAkEIIQUMAgsgBCAFNgIQIANBCXQgAmohAkEHIQUMAQsgBCAFNgIQQQghBSADQQh0IAJqIQILIAVBAWshBSACQQF0IQIgAUEBdCIBQYCAAkkNAAsgCkUgCiASGwwBCyAHKAIEC0UNACABIAsgDSgCBEEXdkEEcSANQQRrIgooAgBBGXZBAXEgBkESdkEQcSAGQRZ2QcAAcSAOQaoBcXJycnIiEkHQuQFqLQAAQQJ0aiIJKAIAIgcoAgAiA2shAQJ/IAMgAkEQdksEQCAHKAIEIQ4gCSAHQQhBDCABIANJIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQEgDiAORSAVGwwBCyACIANBEHRrIQIgAUGAgAJxRQRAIAcoAgQhDiAJIAdBDEEIIAEgA0kiFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEDIActAABB/wFGBEAgA0GQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECADQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgA0EIdCACaiECCyAFQQFrIQUgAkEBdCECIAFBAXQiAUGAgAJJDQALIA5FIA4gFRsMAQsgBygCBAshAyARIBMgFCADIBJB0LsBai0AAHMiAxs2AoAEIAogCigCAEGAEHI2AgAgDSANKAIEQYAEcjYCBCAGIANBGXRyQYAIciEGCyAGQYDAgIAEcQ0DIAEgCyAEKAJsIAZBCXYiEkHvA3FqLQAAQQJ0aiIJKAIAIgEoAgAiA2shBwJ/IAMgAkEQdksEQCABKAIEIQogCSABQQhBDCADIAdLIg4baigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhASAHLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgAUEJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIAFBCHQgAmohAgsgBUEBayEFIAJBAXQhAiADQQF0IgNBgIACSQ0ACyADIQcgCiAKRSAOGwwBCyACIANBEHRrIQIgB0GAgAJxRQRAIAEoAgQhCiAJIAFBDEEIIAMgB0siDhtqKAIANgIAA0ACQCAFDQAgBCgCECIDQQFqIQUgAy0AASEBIAMtAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIAdBAXQiB0GAgAJJDQALIApFIAogDhsMAQsgASgCBAtFBEAgByEBDAQLIAcgCyANKAIEQRp2QQRxIA1BBGsiDigCAEEcdkEBcSAGQRV2QRBxIAZBGXZBwABxIBJBqgFxcnJyciIKQdC5AWotAABBAnRqIgkoAgAiBygCACIBayEDIAEgAkEQdksEQCAHKAIEIRIgCSAHQQhBDCABIANLIhUbaigCADYCAANAAkAgBQ0AIAQoAhAiB0EBaiEFIActAAEhAyAHLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAJBgP4DaiECQQghBQwCCyAEIAU2AhAgA0EJdCACaiECQQchBQwBCyAEIAU2AhBBCCEFIANBCHQgAmohAgsgBUEBayEFIAJBAXQhAiABQQF0IgFBgIACSQ0ACyASIBJFIBUbDAMLIAIgAUEQdGshAiADQYCAAnFFDQEgAyEBCyAHKAIEDAELIAcoAgQhEiAJIAdBDEEIIAEgA0siFRtqKAIANgIAA0ACQCAFDQAgBCgCECIHQQFqIQUgBy0AASEBIActAABB/wFGBEAgAUGQAU8EQCAEIAQoAgxBAWo2AgwgAkGA/gNqIQJBCCEFDAILIAQgBTYCECABQQl0IAJqIQJBByEFDAELIAQgBTYCEEEIIQUgAUEIdCACaiECCyAFQQFrIQUgAkEBdCECIANBAXQiA0GAgAJJDQALIAMhASASRSASIBUbCyEDIBEgEyAUIAMgCkHQuwFqLQAAcyIDGzYCgAYgDiAOKAIAQYCAAXI2AgAgDSANKAIEQYAgcjYCBCANIA0oAoQCQQRyNgKEAiANIA0oAowCQQFyNgKMAiANIA0oAogCIANBEnRyQQJyNgKIAiAGIANBHHRyQYDAAHIhBgsgDSAGQf///7Z7cTYCAAsgDUEEaiEGIBFBBGohAyAMQQFqIgxBwABHDQALIA1BDGohBiARQYQGaiEDIBdBPEkhXCAXQQRqIRcgXA0ACwsgBCAFNgIIIAQgATYCBCAEIAI2AgAgBCAJNgJoCwJAIBZBIHFFDQAgBCAEQeQAajYCaCAEIAQoAgQgBCgCZCIGKAIAIgFrIgI2AgQCQCABIAQoAgAiBUEQdksEQCAEIAE2AgQgBCAGQQhBDCABIAJLG2ooAgAiBjYCZCAEKAIIIQIDQAJAIAINACAEKAIQIgdBAWohCSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQIMAgsgBCAJNgIQIANBCXQgBWohBUEHIQIMAQsgBCAJNgIQQQghAiADQQh0IAVqIQULIAQgAkEBayICNgIIIAQgBUEBdCIFNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyABIQIMAQsgBCAFIAFBEHRrIgU2AgAgAkGAgAJxDQAgBCAGQQxBCCABIAJLG2ooAgAiBjYCZCAEKAIIIQEDQAJAIAENACAEKAIQIgFBAWohByABLQABIQMgAS0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQEMAgsgBCAHNgIQIANBCXQgBWohBUEHIQEMAQsgBCAHNgIQQQghASADQQh0IAVqIQULIAQgAUEBayIBNgIIIAQgBUEBdCIFNgIAIAQgAkEBdCICNgIEIAJBgIACSQ0ACwsgBCACIAYoAgAiAWsiAjYCBAJAIAEgBUEQdksEQCAEIAE2AgQgBCAGQQhBDCABIAJLG2ooAgAiBjYCZCAEKAIIIQIDQAJAIAINACAEKAIQIgdBAWohCSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQIMAgsgBCAJNgIQIANBCXQgBWohBUEHIQIMAQsgBCAJNgIQQQghAiADQQh0IAVqIQULIAQgAkEBayICNgIIIAQgBUEBdCIFNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyABIQIMAQsgBCAFIAFBEHRrIgU2AgAgAkGAgAJxDQAgBCAGQQxBCCABIAJLG2ooAgAiBjYCZCAEKAIIIQEDQAJAIAENACAEKAIQIgFBAWohByABLQABIQMgAS0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQEMAgsgBCAHNgIQIANBCXQgBWohBUEHIQEMAQsgBCAHNgIQQQghASADQQh0IAVqIQULIAQgAUEBayIBNgIIIAQgBUEBdCIFNgIAIAQgAkEBdCICNgIEIAJBgIACSQ0ACwsgBCACIAYoAgAiAWsiAjYCBAJAIAEgBUEQdksEQCAEIAE2AgQgBCAGQQhBDCABIAJLG2ooAgAiBjYCZCAEKAIIIQIDQAJAIAINACAEKAIQIgdBAWohCSAHLQABIQMgBy0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQIMAgsgBCAJNgIQIANBCXQgBWohBUEHIQIMAQsgBCAJNgIQQQghAiADQQh0IAVqIQULIAQgAkEBayICNgIIIAQgBUEBdCIFNgIAIAQgAUEBdCIBNgIEIAFBgIACSQ0ACyABIQIMAQsgBCAFIAFBEHRrIgU2AgAgAkGAgAJxDQAgBCAGQQxBCCABIAJLG2ooAgAiBjYCZCAEKAIIIQEDQAJAIAENACAEKAIQIgFBAWohByABLQABIQMgAS0AAEH/AUYEQCADQZABTwRAIAQgBCgCDEEBajYCDCAFQYD+A2ohBUEIIQEMAgsgBCAHNgIQIANBCXQgBWohBUEHIQEMAQsgBCAHNgIQQQghASADQQh0IAVqIQULIAQgAUEBayIBNgIIIAQgBUEBdCIFNgIAIAQgAkEBdCICNgIEIAJBgIACSQ0ACwsgBCACIAYoAgAiAWsiAjYCBCABIAVBEHZLBEAgBCABNgIEIAQgBkEIQQwgASACSxtqKAIANgJkIAQoAgghAgNAAkAgAg0AIAQoAhAiBkEBaiEHIAYtAAEhAyAGLQAAQf8BRgRAIANBkAFPBEAgBCAEKAIMQQFqNgIMIAVBgP4DaiEFQQghAgwCCyAEIAc2AhAgA0EJdCAFaiEFQQchAgwBCyAEIAc2AhBBCCECIANBCHQgBWohBQsgBCACQQFrIgI2AgggBCAFQQF0IgU2AgAgBCABQQF0IgE2AgQgAUGAgAJJDQALDAELIAQgBSABQRB0ayIHNgIAIAJBgIACcQ0AIAQgBkEMQQggASACSxtqKAIANgJkIAQoAgghBQNAAkAgBQ0AIAQoAhAiA0EBaiEGIAMtAAEhASADLQAAQf8BRgRAIAFBkAFPBEAgBCAEKAIMQQFqNgIMIAdBgP4DaiEHQQghBQwCCyAEIAY2AhAgAUEJdCAHaiEHQQchBQwBCyAEIAY2AhBBCCEFIAFBCHQgB2ohBwsgBCAFQQFrIgU2AgggBCAHQQF0Igc2AgAgBCACQQF0IgI2AgQgAkGAgAJJDQALCwsgJw0AIAQQWiAEQbCpATYCZCAEQdCeATYCYCAEQfCeATYCHAtBACAfQQFqIgEgAUEDRiIBGyEfIBkgAWshGSAmQQFqIiYgICgCCE8NASAZQQBKDQALCyAoICpqISggBCgCGCAELwFwOwAAIClBAWoiKSAaKAIsSQ0ACwsCQCArRQ0AAkAgBCgCGCIBIAQoAhAiA0ECaksEQCAhRQ0BICMgASAEKAIUIgZrNgI4ICMgAyAGazYCNCAjIAEgA2tBAms2AjAgHUECQZDyACAjQTBqEA8MAgsgBCgCDCIBQQNJDQEgIQRAICMgATYCUCAdQQJB6TUgI0HQAGoQDwwCCyAjIAE2AkAgHUECQek1ICNBQGsQDwwBCyAjIAEgBCgCFCIGazYCKCAjIAMgBms2AiQgIyABIANrQQJrNgIgIB1BAkGQ8gAgI0EgahAPCyAaKAI8RQ0AIAQgLDYCdAsgMCgCBCEBIBooAgwhXSAaKAIIIDAoAgBrIQggMCgCECIGQQFxBEAgMigCHCA3QZgBbGoiB0GQAWsoAgAgCGogB0GYAWsoAgBrIQgLIF0gAWshAyAGQQJxBEAgMigCHCA3QZgBbGoiAUGMAWsoAgAgA2ogAUGUAWsoAgBrIQMLIBooAjwiBiECIAZFBEAgBCgCdCECCyAEKAKAASEWIAQoAnwhDQJAIC8oAqgGIgdFDQAgFkUgDUVyIQEgB0EeTARAIAENAUEAIRADQCANIBBsIQRBACEBA0AgAiABIARqQQJ0aiIRKAIAIgkgCUEfdSIFcyAFayIFIAd2BEAgEUEAIAUgLygCqAZ2IhFrIBEgCUEASBs2AgALIAFBAWoiASANRw0ACyAQQQFqIhAgFkcNAAsMAQsgAQ0AIAJBACANIBZsQQJ0EBUaCyAGBEAgDSAWbCEGIC8oAhRBAUYEQCAGRQ0FQQAhASAGQQRPBEAgBkF8cSEBQQAhBANAIAIgBEECdGoiAyAD/QACACJe/RsAQQJt/REgXv0bAUECbf0cASBe/RsCQQJt/RwCIF79GwNBAm39HAP9CwIAIARBBGoiBCABRw0ACyABIAZGDQYLA0AgAiABQQJ0aiIDIAMoAgBBAm02AgAgAUEBaiIBIAZHDQALDAULIAZFDQQgMCoCIEMAAAA/lCFmQQAhBAJAIAZBBEkEQCACIQEMAQsgAiAGQXxxIgRBAnRqIQEgZv0TIV5BACEDA0AgAiADQQJ0aiIHIF4gB/0AAgD9+gH95gH9CwIAIANBBGoiAyAERw0ACyAEIAZGDQULA0AgASBmIAEoAgCylDgCACABQQRqIQEgBEEBaiIEIAZHDQALDAQLIDYgNWshESAvKAIUQQFHDQIgFkUNAyAyKAIkIgYgAyARbCIDQQJ0aiAIQQJ0aiEJIA1BfHEiDEEBayIBQQRxIQsgNiANIDVqa0ECdCEaIAFBAnZBAWpB/v///wdxIR0gAyAIakECdCAGaiACayEKQQAhCCABQQNHIRQDQEEAIQECQCAMRQ0AIAggDWwhAyAJIAggEWxBAnRqIQZBACEHIBQEQANAIAYgAUECdGogAiABIANqQQJ0av0AAgAiXv0bAEECbf0RIF79GwFBAm39HAEgXv0bAkECbf0cAiBe/RsDQQJt/RwD/QsCACAGIAFBBHIiBEECdGogAiADIARqQQJ0av0AAgAiXv0bAEECbf0RIF79GwFBAm39HAEgXv0bAkECbf0cAiBe/RsDQQJt/RwD/QsCACABQQhqIQEgB0ECaiIHIB1HDQALCyALDQAgBiABQQJ0aiACIAEgA2pBAnRq/QACACJe/RsAQQJt/REgXv0bAUECbf0cASBe/RsCQQJt/RwCIF79GwNBAm39HAP9CwIAIAFBBGohAQsCQCABIA1PDQAgCCANbCEDIAkgCCARbEECdGohBwJAIA0gAWsiEEEESQRAIAEhBAwBCyAKIAggGmxqQRBJBEAgASEEDAELIAEgEEF8cSIFaiEEQQAhBgNAIAcgASAGaiIhQQJ0aiACIAMgIWpBAnRq/QACACJe/RsAQQJt/REgXv0bAUECbf0cASBe/RsCQQJt/RwCIF79GwNBAm39HAP9CwIAIAZBBGoiBiAFRw0ACyAFIBBGDQELIARBAWohASANIARrQQFxBEAgByAEQQJ0aiACIAMgBGpBAnRqKAIAQQJtNgIAIAEhBAsgASANRg0AA0AgByAEQQJ0aiACIAMgBGpBAnRqKAIAQQJtNgIAIAcgBEEBaiIBQQJ0aiACIAEgA2pBAnRqKAIAQQJtNgIAIARBAmoiBCANRw0ACwsgCEEBaiIIIBZHDQALDAMLICMgGTYCACAdQQJB1cEAICMQDwsgECgCAEEANgIADAELIBZFDQAgDUUNACAyKAIkIAMgEWxBAnRqIAhBAnRqIQcgDUF8cSIDQQJ0IQYgMCoCIEMAAAA/lCJm/RMhXkEAIRAgDUEESSEIA0ACQAJAIAgEQCACIQkgByEBQQAhBAwBCyAGIAdqIQEgAiAGaiEJQQAhBANAIAcgBEECdCIFaiBeIAIgBWr9AAIA/foB/eYB/QsCACAEQQRqIgQgA0cNAAsgCSECIAMiBCANRg0BCyAJIQIDQCABIGYgAigCALKUOAIAIAFBBGohASACQQRqIQIgBEEBaiIEIA1HDQALCyAHIBFBAnRqIQcgEEEBaiIQIBZHDQALCyAAEBAgI0HgAGokAAvWBAEJfyAAKAIsQQhPBEAgACgCKCEFQQghCgNAIAAoAgxBBXQhCCAAKAIAIQQgACgCJCEDAkAgACgCFCIGIAAoAhAiAU0NACAEIAhqIQcgAUEBaiECIAYgAWtBAXEEQCAHIAFBBnRqIgkgBSABIANsQQJ0aiIB/QACAP0LAgAgCSAB/QACEP0LAhAgAiEBCyACIAZGDQADQCAHIAFBBnRqIgIgBSABIANsQQJ0aiIJ/QACAP0LAgAgAiAJ/QACEP0LAhAgByABQQFqIgJBBnRqIgkgBSACIANsQQJ0aiIC/QACEP0LAhAgCSAC/QACAP0LAgAgAUECaiIBIAZHDQALCwJAIAAoAhwiBiAAKAIYIgFNDQAgBCAIa0EgaiEHIAUgACgCCCADbEECdGohCCABQQFqIQIgBiABa0EBcQRAIAcgAUEGdGoiBCAIIAEgA2xBAnRqIgH9AAIA/QsCACAEIAH9AAIQ/QsCECACIQELIAIgBkYNAANAIAcgAUEGdGoiAiAIIAEgA2xBAnRqIgT9AAIA/QsCACACIAT9AAIQ/QsCECAHIAFBAWoiAkEGdGoiBCAIIAIgA2xBAnRqIgL9AAIQ/QsCECAEIAL9AAIA/QsCACABQQJqIgEgBkcNAAsLIAAQIkEAIQEgACgCIARAA0AgBSAAKAIkIAFsQQJ0aiICIAAoAgAgAUEFdGoiA/0AAgD9CwIAIAIgA/0AAhD9CwIQIAFBAWoiASAAKAIgSQ0ACwsgBUEgaiEFIApBCGoiCiAAKAIsTQ0ACwsgACgCABAQIAAQEAv3DQElfyAAKAIsQQhPBEAgACgCJCIKQQV0IR4gCkEHbCEWIApBBmwhFyAKQQVsIRggCkEDbCEZIApBAXQhGiAAKAIoIgEgCkEcbGohHyABIApBGGxqISAgASAKQRRsaiEhIAEgCkEEdGohIiABIApBDGxqISMgASAKQQN0IiRqISUgASAKQQJ0IhtqISZBCCEcA0AgACABIAAoAiRBCBA7IAAQIgJAIAAoAiAiC0UNACAdIB5sIQggACgCACEGQQAhBAJAAkAgC0HoAkkNACAGQQxqIg4gC0EBayICQQV0IgNqIA5JDQAgBkEIaiIPIANqIA9JDQAgAyAGaiAGSQ0AIAZBBGoiECADaiAQSQ0AIAJB////P0sNACABIAggJmoiAyALQQJ0IgVqIgxJIAMgASAFaiIHSXENACABIAggJWoiAiAFaiINSSACIAdJcQ0AIAEgBSAIICNqIglqIgVJIAcgCUtxDQAgBiAHSSABIAYgC0EFdGoiEUEcayISSXENACABIBFBGGsiE0kgByAQS3ENACABIBFBFGsiFEkgByAPS3ENACAHIA5LIAEgEUEQayIHSXENACADIA1JIAIgDElxDQAgAyAFSSAJIAxJcQ0AIAMgEkkgBiAMSXENACADIBNJIAwgEEtxDQAgAyAUSSAMIA9LcQ0AIAMgB0kgDCAOS3ENACACIAVJIAkgDUlxDQAgAiASSSAGIA1JcQ0AIAIgE0kgDSAQS3ENACACIBRJIA0gD0txDQAgAiAHSSANIA5LcQ0AIAkgEkkgBSAGS3ENACAJIBNJIAUgEEtxDQAgCSAUSSAFIA9LcQ0AIAcgCUsgBSAOS3ENACALQfz///8AcSEEQQAhAwNAIAEgA0ECdGogBiADQQV0aiIC/QkCACACKgIg/SABIAJBQGsqAgD9IAIgAioCYP0gA/0LAgAgASADIApqQQJ0aiAC/QkCBCACKgIk/SABIAIqAkT9IAIgAioCZP0gA/0LAgAgASADIBpqQQJ0aiAC/QkCCCACKgIo/SABIAIqAkj9IAIgAioCaP0gA/0LAgAgASADIBlqQQJ0aiAC/QkCDCACKgIs/SABIAIqAkz9IAIgAioCbP0gA/0LAgAgA0EEaiIDIARHDQALIAQgC0YNAQsDQCABIARBAnRqIAYgBEEFdGoiAyoCADgCACABIAQgCmpBAnRqIAMqAgQ4AgAgASAEIBpqQQJ0aiADKgIIOAIAIAEgBCAZakECdGogAyoCDDgCACAEQQFqIgQgC0cNAAsLIAAoAgAhBkEAIQQCQCALQdwASQ0AIAZBHGoiDyALQQFrIgJBBXQiA2ogD0kNACAGQRhqIhAgA2ogEEkNACAGQRBqIhEgA2ogEUkNACAGQRRqIhIgA2ogEkkNACACQf///z9LDQAgCCAiaiIDIAggIWoiAiALQQJ0IgVqIgxJIAIgAyAFaiIHSXENACADIAggIGoiCSAFaiINSSAHIAlLcQ0AIAMgCCAfaiIIIAVqIgVJIAcgCEtxDQAgAyAGIAtBBXRqIg5BDGsiE0kgByARS3ENACADIA5BCGsiFEkgByASS3ENACADIA5BBGsiFUkgByAQS3ENACADIA5JIAcgD0txDQAgAiANSSAJIAxJcQ0AIAIgBUkgCCAMSXENACACIBNJIAwgEUtxDQAgAiAUSSAMIBJLcQ0AIAIgFUkgDCAQS3ENACACIA5JIAwgD0txDQAgCCANSSAFIAlLcQ0AIAkgE0kgDSARS3ENACAJIBRJIA0gEktxDQAgCSAVSSANIBBLcQ0AIAkgDkkgDSAPS3ENACAIIBNJIAUgEUtxDQAgCCAUSSAFIBJLcQ0AIAggFUkgBSAQS3ENACAIIA5JIAUgD0txDQAgC0H8////AHEhBEEAIQMDQCABIAMgG2pBAnRqIAYgA0EFdGoiAv0JAhAgAioCMP0gASACKgJQ/SACIAIqAnD9IAP9CwIAIAEgAyAYakECdGogAv0JAhQgAioCNP0gASACKgJU/SACIAIqAnT9IAP9CwIAIAEgAyAXakECdGogAv0JAhggAioCOP0gASACKgJY/SACIAIqAnj9IAP9CwIAIAEgAyAWakECdGogAv0JAhwgAioCPP0gASACKgJc/SACIAIqAnz9IAP9CwIAIANBBGoiAyAERw0ACyAEIAtGDQELA0AgASAEIBtqQQJ0aiAGIARBBXRqIgMqAhA4AgAgASAEIBhqQQJ0aiADKgIUOAIAIAEgBCAXakECdGogAyoCGDgCACABIAQgFmpBAnRqIAMqAhw4AgAgBEEBaiIEIAtHDQALCyAdQQFqIR0gASAkQQJ0aiEBIBxBCGoiHCAAKAIsTQ0ACwsgACgCABAQIAAQEAtzAQJ/IAAoAhwiAUEIaiIDIAAoAiAiAk0EQANAIAAgACgCGCABQQJ0aiAAKAIUQQgQMCADIgFBCGoiAyAAKAIgIgJNDQALCyABIAJJBEAgACAAKAIYIAFBAnRqIAAoAhQgAiABaxAwCyAAKAIAEBAgABAQC0QAIAAoAhwiASAAKAIgSQRAA0AgACAAKAIYIAAoAhQgAWxBAnRqEF0gAUEBaiIBIAAoAiBJDQALCyAAKAIAEBAgABAQC6gBAQV/IAAoAlQiAygCACEFIAMoAgQiBCAAKAIUIAAoAhwiB2siBiAEIAZJGyIGBEAgBSAHIAYQEhogAyADKAIAIAZqIgU2AgAgAyADKAIEIAZrIgQ2AgQLIAQgAiACIARLGyIEBEAgBSABIAQQEhogAyADKAIAIARqIgU2AgAgAyADKAIEIARrNgIECyAFQQA6AAAgACAAKAIsIgE2AhwgACABNgIUIAILngUCBn4EfyABIAEoAgBBB2pBeHEiAUEQajYCACAAIQsgASkDACEDIAEpAwghByMAQSBrIggkACAHQv///////z+DIQQCfiAHQjCIQv//AYMiBaciCkGB+ABrQf0PTQRAIARCBIYgA0I8iIQhAiAKQYD4AGutIQUCQCADQv//////////D4MiA0KBgICAgICAgAhaBEAgAkIBfCECDAELIANCgICAgICAgIAIUg0AIAJCAYMgAnwhAgtCACACIAJC/////////wdWIgAbIQIgAK0gBXwMAQsCQCADIASEUA0AIAVC//8BUg0AIARCBIYgA0I8iIRCgICAgICAgASEIQJC/w8MAQtC/w8gCkH+hwFLDQAaQgBBgPgAQYH4ACAFUCIBGyIAIAprIglB8ABKDQAaIAMhAiAEIARCgICAgICAwACEIAEbIgYhBAJAQYABIAlrIgFBwABxBEAgAyABQUBqrYYhBEIAIQIMAQsgAUUNACAEIAGtIgWGIAJBwAAgAWutiIQhBCACIAWGIQILIAggAjcDECAIIAQ3AxgCQCAJQcAAcQRAIAYgCUFAaq2IIQNCACEGDAELIAlFDQAgBkHAACAJa62GIAMgCa0iAoiEIQMgBiACiCEGCyAIIAM3AwAgCCAGNwMIIAgpAwhCBIYgCCkDACICQjyIhCEDAkAgACAKRyAIKQMQIAgpAxiEQgBSca0gAkL//////////w+DhCICQoGAgICAgICACFoEQCADQgF8IQMMAQsgAkKAgICAgICAgAhSDQAgA0IBgyADfCEDCyADQoCAgICAgIAIhSADIANC/////////wdWIgAbIQIgAK0LIQMgCEEgaiQAIAsgB0KAgICAgICAgIB/gyADQjSGhCAChL85AwALhhgDE38BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIaQgBTBEBBASERQboIIRMgAZoiAb0hGgwBCyAEQYAQcQRAQQEhEUG9CCETDAELQcAIQbsIIARBAXEiERshEyARRSEVCwJAIBpCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgMgBEH//3txEBwgACATIBEQGSAAQZIJQfYKIAVBIHEiBRtB+wlB+gogBRsgASABYhtBAxAZIABBICACIAMgBEGAwABzEBwgAyACIAIgA0gbIQoMAQsgDEEQaiESAkACfwJAIAEgDEEsahBlIgEgAaAiAUQAAAAAAAAAAGIEQCAMIAwoAiwiBkEBazYCLCAFQSByIg5B4QBHDQEMAwsgBUEgciIOQeEARg0CIAwoAiwhCUEGIAMgA0EASBsMAQsgDCAGQR1rIgk2AiwgAUQAAAAAAACwQaIhAUEGIAMgA0EASBsLIQsgDEEwakGgAkEAIAlBAE4baiINIQcDQCAHAn8gAUQAAAAAAADwQWMgAUQAAAAAAAAAAGZxBEAgAasMAQtBAAsiAzYCACAHQQRqIQcgASADuKFEAAAAAGXNzUGiIgFEAAAAAAAAAABiDQALAkAgCUEATARAIAkhAyAHIQYgDSEIDAELIA0hCCAJIQMDQEEdIAMgA0EdTxshAwJAIAdBBGsiBiAISQ0AIAOtIRxCACEaA0AgBiAaQv////8PgyAGNQIAIByGfCIbQoCU69wDgCIaQoDslKMMfiAbfD4CACAGQQRrIgYgCE8NAAsgG0KAlOvcA1QNACAIQQRrIgggGj4CAAsDQCAIIAciBkkEQCAGQQRrIgcoAgBFDQELCyAMIAwoAiwgA2siAzYCLCAGIQcgA0EASg0ACwsgA0EASARAIAtBGWpBCW5BAWohDyAOQeYARiEQA0BBCUEAIANrIgMgA0EJTxshCgJAIAYgCE0EQCAIKAIARUECdCEHDAELQYCU69wDIAp2IRRBfyAKdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAp2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgBFQQJ0IQcgA0UNACAGIAM2AgAgBkEEaiEGCyAMIAwoAiwgCmoiAzYCLCANIAcgCGoiCCAQGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIgpBCkkNAANAIANBAWohAyAKIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQCAMQTBqQYRgQaRiIAlBAEgbaiAHQYDIAGoiCkEJbSIPQQJ0aiEJQQohByAPQXdsIApqIgpBB0wEQANAIAdBCmwhByAKQQFqIgpBCEcNAAsLAkAgCSgCACIQIBAgB24iDyAHbCIKRiAJQQRqIhQgBkZxDQAgECAKayEQAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAJTw0BIAlBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IBAgB0EBdiIURhsgECAUSRshGQJAIBUNACATLQAAQS1HDQAgGZohGSABmiEBCyAJIAo2AgAgASAZoCABYQ0AIAkgByAKaiIDNgIAIANBgJTr3ANPBEADQCAJQQA2AgAgCCAJQQRrIglLBEAgCEEEayIIQQA2AgALIAkgCSgCAEEBaiIDNgIAIANB/5Pr3ANLDQALCyANIAhrQQJ1QQlsIQNBCiEHIAgoAgAiCkEKSQ0AA0AgA0EBaiEDIAogB0EKbCIHTw0ACwsgCUEEaiIHIAYgBiAHSxshBgsDQCAGIgcgCE0iCkUEQCAGQQRrIgYoAgBFDQELCwJAIA5B5wBHBEAgBEEIcSEJDAELIANBf3NBfyALQQEgCxsiBiADSiADQXtKcSIJGyAGaiELQX9BfiAJGyAFaiEFIARBCHEiCQ0AQXchBgJAIAoNACAHQQRrKAIAIg5FDQBBCiEKQQAhBiAOQQpwDQADQCAGIglBAWohBiAOIApBCmwiCnBFDQALIAlBf3MhBgsgByANa0ECdUEJbCEKIAVBX3FBxgBGBEBBACEJIAsgBiAKakEJayIGQQAgBkEAShsiBiAGIAtKGyELDAELQQAhCSALIAMgCmogBmpBCWsiBkEAIAZBAEobIgYgBiALShshCwtBfyEKIAtB/f///wdB/v///wcgCSALciIQG0oNASALIBBBAEdqQQFqIQ4CQCAFQV9xIhVBxgBGBEAgAyAOQf////8Hc0oNAyADQQAgA0EAShshBgwBCyASIAMgA0EfdSIGcyAGa60gEhAqIgZrQQFMBEADQCAGQQFrIgZBMDoAACASIAZrQQJIDQALCyAGQQJrIg8gBToAACAGQQFrQS1BKyADQQBIGzoAACASIA9rIgYgDkH/////B3NKDQILIAYgDmoiAyARQf////8Hc0oNASAAQSAgAiADIBFqIgMgBBAcIAAgEyAREBkgAEEwIAIgAyAEQYCABHMQHAJAAkACQCAVQcYARgRAIAxBEGpBCXIhBSANIAggCCANSxsiCSEIA0AgCDUCACAFECohBgJAIAggCUcEQCAGIAxBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAxBEGpLDQALDAELIAUgBkcNACAGQQFrIgZBMDoAAAsgACAGIAUgBmsQGSAIQQRqIgggDU0NAAsgEARAIABBggxBARAZCyAHIAhNDQEgC0EATA0BA0AgCDUCACAFECoiBiAMQRBqSwRAA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwsgACAGQQkgCyALQQlOGxAZIAtBCWshBiAIQQRqIgggB08NAyALQQlKIRggBiELIBgNAAsMAgsCQCALQQBIDQAgByAIQQRqIAcgCEsbIQ0gDEEQakEJciEFIAghBwNAIAUgBzUCACAFECoiBkYEQCAGQQFrIgZBMDoAAAsCQCAHIAhHBEAgBiAMQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiAMQRBqSw0ACwwBCyAAIAZBARAZIAZBAWohBiAJIAtyRQ0AIABBggxBARAZCyAAIAYgBSAGayIGIAsgBiALSBsQGSALIAZrIQsgB0EEaiIHIA1PDQEgC0EATg0ACwsgAEEwIAtBEmpBEkEAEBwgACAPIBIgD2sQGQwCCyALIQYLIABBMCAGQQlqQQlBABAcCyAAQSAgAiADIARBgMAAcxAcIAMgAiACIANIGyEKDAELIBMgBUEadEEfdUEJcWohCAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGQNAIBlEAAAAAAAAMECiIRkgBkEBayIGDQALIAgtAABBLUYEQCAZIAGaIBmhoJohAQwBCyABIBmgIBmhIQELIBIgDCgCLCIHIAdBH3UiBnMgBmutIBIQKiIGRgRAIAZBAWsiBkEwOgAACyARQQJyIQsgBUEgcSENIAZBAmsiCSAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiAMQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0HQxAFqLQAAIA1yOgAAIAEgB7ehRAAAAAAAADBAoiEBAkAgBUEBaiIHIAxBEGprQQFHDQACQCAGDQAgA0EASg0AIAFEAAAAAAAAAABhDQELIAVBLjoAASAFQQJqIQcLIAFEAAAAAAAAAABiDQALQX8hCkH9////ByALIBIgCWsiBmoiDWsgA0gNACAAQSAgAiANIANBAmogByAMQRBqIgdrIgUgBUECayADSBsgBSADGyIKaiIDIAQQHCAAIAggCxAZIABBMCACIAMgBEGAgARzEBwgACAHIAUQGSAAQTAgCiAFa0EAQQAQHCAAIAkgBhAZIABBICACIAMgBEGAwABzEBwgAyACIAIgA0gbIQoLIAxBsARqJAAgCgsEAEIACwQAQQALnwMBCX9B5gohAAJAA0AgAC0AACIBRQ0BIAFBPUYNASAAQQFqIgBBA3ENAAsCQAJAQYCChAggACgCACICayACckGAgYKEeHFBgIGChHhHDQADQEGAgoQIIAJBvfr06QNzIgFrIAFyQYCBgoR4cUGAgYKEeEcNASAAKAIEIQIgAEEEaiIBIQAgAkGAgoQIIAJrckGAgYKEeHFBgIGChHhGDQALDAELIAAhAQsDQCABIgAtAAAiAkUNASAAQQFqIQEgAkE9Rw0ACwsgACIBQeYKRgRAQQAPCwJAIAFB5gprIgBB5gpqLQAADQBBsM8BKAIAIgRFDQAgBCgCACIFRQ0AA0ACQAJ/IAUhAkHmCiEGQQAgACIBRQ0AGkHmCi0AACIDBH8CQANAIAMgAi0AACIHRw0BIAdFDQEgAUEBayIBRQ0BIAJBAWohAiAGLQABIQMgBkEBaiEGIAMNAAtBACEDCyADBUEACyACLQAAawtFBEAgACAFaiIBLQAAQT1GDQELIAQoAgQhBSAEQQRqIQQgBQ0BDAILCyABQQFqIQgLIAgLCQAgACgCPBANC84CAQh/IwBBIGsiAyQAIAMgACgCHCIENgIQIAAoAhQhBSADIAI2AhwgAyABNgIYIAMgBSAEayIBNgIUIAEgAmohBUECIQYgA0EQaiEBAn8DQAJAAkACQCAAKAI8IAEgBiADQQxqEAEiBAR/QZTHASAENgIAQX8FQQALRQRAIAUgAygCDCIHRg0BIAdBAE4NAgwDCyAFQX9HDQILIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAgwDCyABIAcgASgCBCIISyIJQQN0aiIEIAcgCEEAIAkbayIIIAQoAgBqNgIAIAFBDEEEIAkbaiIBIAEoAgAgCGs2AgAgBSAHayEFIAYgCWshBiAEIQEMAQsLIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgBkECRg0AGiACIAEoAgRrCyEKIANBIGokACAKC1YBAn8gACgCPCEEIwBBEGsiACQAIAQgAacgAUIgiKcgAkH/AXEgAEEIahAJIgIEf0GUxwEgAjYCAEF/BUEACyECIAApAwghASAAQRBqJABCfyABIAIbCwYAIAAQAAsGACAAEAML8n4FAnw2fwh7A34GfSMAQeDAAGsiGCQAIBhBADYCIEECIQwCQAJAIAAoAgAiB0GNlJzUAEYNACAHQf+f/Y8FRwRAAkAgB0GAgIDgAEcNACAAKAIEQeqggYECRw0AIAAoAghBjZSc1ABGDQILQc0IEABBASEMDAILQQAhDAsCf0EAQQFB4AAQEyIHRQ0AGiAHQQE2AkwCQAJAAkACQCAMDgMAAwEDCyAHQcMANgJYIAdBxAA2AlQgB0HFADYCUCAHQcYANgIQIAdBxwA2AgQgB0HIADYCHCAHQckANgIYIAdBygA2AhQgB0HLADYCACAHQcwANgJcIAdBzQA2AiwgB0HOADYCKCAHQc8ANgIkIAdB0AA2AiAgB0HRADYCDCAHQdIANgIIIAcQTSIINgIwIAgNAQwCCyAHQdMANgJYIAdB1AA2AlQgB0HVADYCUCAHQdYANgIQIAdB1wA2AgQgB0HYADYCXCAHQdkANgIsIAdB2gA2AiggB0HbADYCJCAHQdwANgIgIAdB3QA2AhwgB0HeADYCGCAHQd8ANgIUIAdB4AA2AgwgB0HhADYCCCAHQeIANgIAIAcCf0EBQYgBEBMiCARAIAgQTSIONgIAAkAgDkUNACAI/QwAAAAAAAAAAAAAAAAAAAAA/QsCbCAIQQA6AHwgCBAzIg42AgQgDkUNACAIEDMiDjYCCCAORQ0AIAgMAgsgCBBwC0EACyIINgIwIAhFDQELIAdBATYCSCAHQQE2AkAgB0EANgI8IAdCADcCNCAHQQE2AkQgBwwBCyAHEBBBAAsiCARAIAhBADYCPCAIQeMANgJICyAIBEAgCEEANgI4IAhB5AA2AkQLIAgEQCAIQQA2AjQgCEHlADYCQAsgGEEkaiIHBEAgB0EAQbjAABAVIgdBADYCuEAgB0J/NwKIQAsgAwRAIBggGCgC3EBBAXI2AtxACyAYIAE2AhwgGCAANgIYIBggADYCFEEBIQxBACEBAkAgGEEUaiIHRQ0AQQFByAAQEyIABH8CfyAAQYCAwAA2AkAgAEGAgMAAEBQiDjYCICAORQRAIAAQEEEADAELIAAgDjYCJCAAQQI2AhwgAEEDNgIYIABBBDYCFCAAQQU2AhAgAEEGNgIsIABBCDYCKCAAIAAoAkRBAnI2AkQgAAsFQQALIgBFDQAgAARAIABBADYCBCAAIAc2AgALIAc1AgghRSAABEAgACBFNwMICwJAIABFDQAgAC0AREECcUUNACAAQT82AhALIAAEQCAAQcEANgIYCyAABEAgAEHCADYCHAsgACEBCyABIQACfyAYQSRqIQECQCAIRQ0AIAFFDQAgCCgCTEUEQCAIQTRqQQFBtMkAQQAQD0EADAILIAgoAjAgASAIKAIYEQMAQQEhCwsgCwtFBEBB3AgQACAAEDQgCBA1DAELAn8gGEEgaiEBQQAhBwJAIABFDQAgCEUNACAIKAJMRQRAIAhBNGpBAUGFygBBABAPQQAMAgsgACAIKAIwIAEgCEE0aiAIKAIAEQEAIQcLIAcLRQRAQfgIEAAgABA0IAgQNSAYKAIgECEMAQsgGCgCICEBQQAhBwJAIAhFDQAgAEUNACAIKAJMRQ0AIAgoAjAgACABIAhBNGogCCgCBBEBACEHCwJAIAcEQEEAIQcCQCAIRQ0AIABFDQAgCCgCTEUNACAIKAIwIAAgCEE0aiAIKAIQEQAAIQcLIAcNAQtB/wkQACAIEDUgABA0IBgoAiAQIQwBCyAAEDQgCBA1IBgoAiAiDSgCHCIABEAgABAQIBgoAiAiDUIANwIcCyANKAIQISECQAJAIAJFBEACQCAERQ0AICFBBEcNAEEBIRlBBCEhDAMLAkACQCANKAIUIgFBA0YNACAhQQNHDQAgDSgCGCIAKAIAIAAoAgRHDQEgACgCNEEBRg0BIA1BAzYCFAwDCyAhQQJLDQAgDUECNgIUDAMLAkACQCABQQNrDgMDAQAECyMAQRBrIg4kAAJAAkACQCANKAIQQQRJDQAgDSgCGCIAKAIAIgEgACgCNEcNACABIAAoAmhHDQAgASAAKAKcAUcNACAAKAIEIgEgACgCOEcNACABIAAoAmxHDQAgASAAKAKgAUYNAQsgDkGHCDYCBCAOQbgKNgIAQejEAUHtPSAOEBYMAQsCQCAAKAIMIAAoAghsIghFBEAgACgCyAEhAQwBC0MAAIA/QX8gACgCtAF0QX9zs5UhSEMAAIA/QX8gACgCgAF0QX9zs5UhSkMAAIA/QX8gACgCTHRBf3OzlSFLQwAAgD9BfyAAKAIYdEF/c7OVIUkgACgCyAEhASAAKAKUASECIAAoAmAhCiAAKAIsIQdBACEAAkAgCEEISQ0AIAcgCiAIQQJ0IgtqIg9JIAogByALaiIXSXENACACIBdJIAcgAiALaiIJSXENACABIBdJIAcgASALaiILSXENACACIA9JIAkgCktxDQAgASAPSSAKIAtJcQ0AIAEgCUkgAiALSXENACAIQXxxIQAgSP0TIT0gSv0TIT4gS/0TIUMgSf0TIUBBACELA0AgAiALQQJ0Ig9qIhf9AAIAIUEgCiAPaiIJ/QACACFCIAcgD2oiEP0MAACAPwAAgD8AAIA/AACAPyBAIBD9AAIA/foB/eYB/eUB/QwAAH9DAAB/QwAAf0MAAH9D/eYB/QwAAIA/AACAPwAAgD8AAIA/ID0gASAPav0AAgD9+gH95gH95QEiP/3mAf34Af0LAgAgCf0MAACAPwAAgD8AAIA/AACAPyBDIEL9+gH95gH95QH9DAAAf0MAAH9DAAB/QwAAf0P95gEgP/3mAf34Af0LAgAgF/0MAACAPwAAgD8AAIA/AACAPyA+IEH9+gH95gH95QH9DAAAf0MAAH9DAAB/QwAAf0P95gEgP/3mAf34Af0LAgAgC0EEaiILIABHDQALIAAgCEYNAQsDQAJ/QwAAgD8gSSAHIABBAnQiC2oiDygCALKUk0MAAH9DlEMAAIA/IEggASALaigCALKUkyJMlCJNi0MAAABPXQRAIE2oDAELQYCAgIB4CyEXIAIgC2oiCSgCACEQIAogC2oiCygCACEMIA8gFzYCACALAn9DAACAPyBLIAyylJNDAAB/Q5QgTJQiTYtDAAAAT10EQCBNqAwBC0GAgICAeAs2AgAgCQJ/QwAAgD8gSiAQspSTQwAAf0OUIEyUIkyLQwAAAE9dBEAgTKgMAQtBgICAgHgLNgIAIABBAWoiACAIRw0ACwsgARAQIA0oAhgiAEEINgKAASAAQQg2AkwgAEEINgIYIABBADYCyAEgDUEBNgIUIA0gDSgCEEEBayIANgIQIABBBEkNAEEDIQADQCANKAIYIABBNGxqIgEgASgCZDYCMCABIAH9AAJU/QsCICABIAH9AAJE/QsCECABIAH9AAI0/QsCACAAQQFqIgAgDSgCEEkNAAsLIA5BEGokAAwDCyMAQRBrIgskAAJAAkACQCANKAIQQQNJDQAgDSgCGCIAKAIAIgEgACgCNEcNACABIAAoAmhHDQAgACgCBCIBIAAoAjhHDQAgASAAKAJsRg0BCyALQcUINgIEIAtBuAo2AgBB6MQBQZc+IAsQFgwBCwJAIAAoAgwgACgCCGwiAkUNAEF/IAAoAhgiCnRBf3MhAUEAQQEgCkEBa3QiCiAAKAKIARshD0EAIAogACgCVBshFyAAKAKUASEKIAAoAmAhByAAKAIsIQ5BACEAAkAgAkEESQ0AIA4gByACQQJ0IghqIglJIAcgCCAOaiIQSXENACAKIBBJIA4gCCAKaiIISXENACAHIAhJIAkgCktxDQAgAkF8cSEAIAH9ESE/IA/9ESFAIBf9ESFBQQAhCANAIA4gCEECdCIJaiIQID8gCSAKaiIM/QACACBA/bEB/foBIj39DGl0sz9pdLM/aXSzP2l0sz/95gEgByAJaiIJ/QACACBB/bEB/foBIj79DLNZGrizWRq4s1kauLNZGrj95gEgEP0AAgD9+gEiQ/3kAf3kAf0MAAAAPwAAAD8AAAA/AAAAP/3kAf34ASJC/QwAAAAAAAAAAAAAAAAAAAAA/bgBID8gQv05/VL9CwIAIAkgPyA9/QwZ0Da/GdA2vxnQNr8Z0Da//eYBIEP9DNUJgD/VCYA/1QmAP9UJgD/95gEgPv0MJzGwvicxsL4nMbC+JzGwvv3mAf3kAf3kAf0MAAAAPwAAAD8AAAA/AAAAP/3kAf34ASJC/QwAAAAAAAAAAAAAAAAAAAAA/bgBID8gQv05/VL9CwIAIAwgPyA9/Qy9Nwa3vTcGt703Bre9Nwa3/eYBIEP9DGb0fz9m9H8/ZvR/P2b0fz/95gEgPv0MNdLiPzXS4j810uI/NdLiP/3mAf3kAf3kAf0MAAAAPwAAAD8AAAA/AAAAP/3kAf34ASI9/QwAAAAAAAAAAAAAAAAAAAAA/bgBID8gPf05/VL9CwIAIAhBBGoiCCAARw0ACyAAIAJGDQELA0ACfyAKIABBAnQiCGoiCSgCACAPa7IiSENpdLM/lCAHIAhqIhAoAgAgF2uyIkpDs1kauJQgCCAOaiIMKAIAsiJLkpJDAAAAP5IiSYtDAAAAT10EQCBJqAwBC0GAgICAeAshCCAMIAEgCEEAIAhBAEobIAEgCEgbNgIAIBAgAQJ/IEhDGdA2v5QgS0PVCYA/lCBKQycxsL6UkpJDAAAAP5IiSYtDAAAAT10EQCBJqAwBC0GAgICAeAsiCEEAIAhBAEobIAEgCEgbNgIAIAkgAQJ/IEhDvTcGt5QgS0Nm9H8/lCBKQzXS4j+UkpJDAAAAP5IiSItDAAAAT10EQCBIqAwBC0GAgICAeAsiCEEAIAhBAEobIAEgCEgbNgIAIABBAWoiACACRw0ACwsgDUEBNgIUCyALQRBqJAAMAgsgISACIAIgIUsbISFBASEZDAELAkACQAJ/AkACQCANKAIYIgEoAgBBAUcNAAJAAkAgASgCNEEBaw4CAQACCyABKAJoQQJHDQECQCABKAIEQQFHDQAgASgCOEECRw0AIAEoAmxBAkcNAEEAIQsgDSIXKAIYIgAoAhghASAAKAKUASERIAAoAmAhCiAAKAIsIRAgACgCCCINIAAoAgwiAmxBAnQiABAYIQcgABAYIQggABAYIQ4CQAJAAkACQAJAAkAgB0UNACAIRQ0AIA5FDQBBfyABdEF/cyEJQQEgAUEBa3QhDCACIBcoAgRBAXEiAGshHiAXKAIAQQFxIRsgAEUNAyANRQ0DAn9BACAMa7K7IgVEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAshFAJ/IAVEJzEIrBxa/D+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyEaIA1BCEkhOAJ/IAVEO99PjZdu9j+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyEdIDgNASAIIAdrQRBJDQEgDiAHa0EQSQ0BIAcgEGtBEEkNASAOIAhrQRBJDQEgCCAQa0EQSQ0BIA4gEGtBEEkNASAOIA1BfHEiC0ECdCICaiEBIAIgB2ohACAa/REhPiAU/REhQyAJ/REhPyAd/REhQANAIAcgD0ECdCITav0MAAAAAAAAAAAAAAAAAAAAACAQIBNq/QACACI9IED9rgEiQSA//bYBIEH9DAAAAAAAAAAAAAAAAAAAAAD9Of1S/QsCACAIIBNq/QwAAAAAAAAAAAAAAAAAAAAAID0gQ/2xASJBID/9tgEgQf0MAAAAAAAAAAAAAAAAAAAAAP05/VL9CwIAIA4gE2r9DAAAAAAAAAAAAAAAAAAAAAAgPSA+/a4BIj0gP/22ASA9/QwAAAAAAAAAAAAAAAAAAAAA/Tn9Uv0LAgAgD0EEaiIPIAtHDQALIAIgEGohECACIAhqIQIgCyANRg0EDAILIAcQECAIEBAgDhAQDAQLIAchACAIIQIgDiEBCwNAIAAgECgCACIPIB1qIhMgCSAJIBNKG0EAIBNBAE4bNgIAIAIgDyAUayITIAkgCSATShtBACATQQBOGzYCACABIA8gGmoiDyAJIAkgD0obQQAgD0EAThs2AgAgAUEEaiEBIAJBBGohAiAAQQRqIQAgEEEEaiEQIAtBAWoiCyANRw0ACwwBCyAOIQEgCCECIAchAAsgDSAbayEaAkAgHkF+cSIdBH8Cf0EAIAxrsrsiBURqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyEiIBpBfnEiHEEBayE5An8gBUQnMQisHFr8P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLISMgOUF+cSE6An8gBUQ730+Nl272P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLISQgHUEBayElIDpBAmohJiANQQJ0IQ0DQCABIA1qIQ8gAiANaiETIAAgDWohCyANIBBqIRQgGwRAIAAgECgCACIVICRqIhIgCSAJIBJKG0EAIBJBAE4bNgIAIAIgFSAiayISIAkgCSASShtBACASQQBOGzYCACABIBUgI2oiFSAJIAkgFUobQQAgFUEAThs2AgAgCigCACEWIAsCfyARKAIAIAxrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIBQoAgAiFWoiEiAJIAkgEkobQQAgEkEAThs2AgAgEyAVAn8gFiAMa7K7IgZEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAtrIhIgCSAJIBJKG0EAIBJBAE4bNgIAIA8CfyAGRCcxCKwcWvw/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsgFWoiFSAJIAkgFUobQQAgFUEAThs2AgAgD0EEaiEPIBNBBGohEyALQQRqIQsgFEEEaiEUIAJBBGohAiAQQQRqIRAgAUEEaiEBIABBBGohAAtBACEVIBwEfwNAIAooAgAhHyAAAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAQKAIAIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIAIAIgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCACABAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIAIAooAgAhHyAAAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAQKAIEIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIEIAIgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCBCABAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIEIAooAgAhHyALAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAUKAIAIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIAIBMgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCACAPAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIAIAooAgAhHyALAn8gESgCACAMa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAUKAIEIhJqIhYgCSAJIBZKG0EAIBZBAE4bNgIEIBMgEgJ/IB8gDGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIWIAkgCSAWShtBACAWQQBOGzYCBCAPAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIBJqIhIgCSAJIBJKG0EAIBJBAE4bNgIEIBFBBGohESAKQQRqIQogD0EIaiEPIBNBCGohEyALQQhqIQsgFEEIaiEUIAFBCGohASACQQhqIQIgAEEIaiEAIBBBCGohECAVQQJqIhUgHEkNAAsgJgVBAAsgGkkEfyAKKAIAIRYgAAJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgECgCACIVaiISIAkgCSASShtBACASQQBOGzYCACACIBUCfyAWIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siEiAJIAkgEkobQQAgEkEAThs2AgAgAQJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyAVaiIVIAkgCSAVShtBACAVQQBOGzYCACAKKAIAIRUgCwJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgFCgCACILaiIUIAkgCSAUShtBACAUQQBOGzYCACATIAsCfyAVIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siEyAJIAkgE0obQQAgE0EAThs2AgAgDwJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyALaiILIAkgCSALShtBACALQQBOGzYCACARQQRqIREgCkEEaiEKIAJBBGohAiAQQQRqIRAgAEEEaiEAIAFBBGoFIAELIA1qIQEgAiANaiECIAAgDWohACANIBBqIRAgIEECaiIgIB1JDQALICVBfnFBAmoFQQALIB5PDQAgGwRAIAACf0EAIAxrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIBAoAgAiC2oiDSAJIAkgDUobQQAgDUEAThs2AgAgAiALAn8gBURqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4C2siDSAJIAkgDUobQQAgDUEAThs2AgAgAQJ/IAVEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyALaiILIAkgCSALShtBACALQQBOGzYCACACQQRqIQIgEEEEaiEQIAFBBGohASAAQQRqIQALIBpBfnEiIAR/ICBBAWsiC0F+cSE7AkACf0EAICBBD0kNABpBACAAIAIgC0EBdiIUQQN0QQhqIhNqIgtJIAIgACATaiINSXENABpBACABIA1JIAAgASATaiIPSXENABpBACAAIBAgE2oiE0kgDSAQS3ENABpBACAKIA1JIAAgCiAUQQJ0QQRqIh5qIhtJcQ0AGkEAIA0gEUsgACARIB5qIg1JcQ0AGkEAIAIgD0kgASALSXENABpBACACIBNJIAsgEEtxDQAaQQAgCiALSSACIBtJcQ0AGkEAIAIgDUkgCyARS3ENABpBACABIBNJIA8gEEtxDQAaQQAgCiAPSSABIBtJcQ0AGkEAIAEgDUkgDyARS3ENABogCiAUQQFqIhZB/P///wdxIhtBAnQiImohCyABIBtBA3QiHmohDSAAIB5qIQ8gCf0RIT8gDP0RIUNBACETA0AgECATQQN0IhRBGHIiHWoiIyAQIBRBEHIiHGoiJCAQIBRBCHIiFWoiJSAQIBRqIib9CQIA/VYCAAH9VgIAAv1WAgADIT0CfyARIBNBAnQiH2r9AAIAIEP9sQH9+gEiPv1fIkD9DDvfT42XbvY/O99PjZdu9j/98gEiQf0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshJyAKIB9q/QACACFCIAAgFGoiH/0MAAAAAAAAAAAAAAAAAAAAACA9An8gQf0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9ESAn/RwBAn8gPiA+/Q0ICQoLDA0ODwABAgMAAQID/V8iQf0MO99PjZdu9j8730+Nl272P/3yASI+/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cAgJ/ID79IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwDIkT9rgEiPiA//bYBID79DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj79WgIAACAAIBVqIicgPv1aAgABIAAgHGoiKSA+/VoCAAIgACAdaiIqID79WgIAAwJ/IEIgQ/2xAf36ASI+/V8iQv0Marx0kxgE1j9qvHSTGATWP/3yASBA/QwMAiuHFtnmPwwCK4cW2eY//fIB/fABIkD9IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLISggAiAUaiIr/QwAAAAAAAAAAAAAAAAAAAAAID0CfyBA/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RICj9HAECfyA+/QwAAAAAAAAAAAAAAAAAAAAA/Q0ICQoLDA0ODwABAgMAAQID/V8iQP0Marx0kxgE1j9qvHSTGATWP/3yASBB/QwMAiuHFtnmPwwCK4cW2eY//fIB/fABIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAMiQf2xASI+ID/9tgEgPv0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPv1aAgAAIAIgFWoiKCA+/VoCAAEgAiAcaiIsID79WgIAAiACIB1qIi0gPv1aAgADAn8gQv0MJzEIrBxa/D8nMQisHFr8P/3yASI+/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyEuIAEgFGoiFP0MAAAAAAAAAAAAAAAAAAAAACA9An8gPv0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9ESAu/RwBAn8gQP0MJzEIrBxa/D8nMQisHFr8P/3yASI9/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cAgJ/ID39IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwDIkD9rgEiPSA//bYBID39DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj39WgIAACABIBVqIhUgPf1aAgABIAEgHGoiHCA9/VoCAAIgASAdaiIdID39WgIAAyAf/QwAAAAAAAAAAAAAAAAAAAAAICNBBGogJEEEaiAlQQRqICb9CQIE/VYCAAH9VgIAAv1WAgADIj4gRP2uASI9ID/9tgEgPf0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPf1aAgQAICcgPf1aAgQBICkgPf1aAgQCICogPf1aAgQDICv9DAAAAAAAAAAAAAAAAAAAAAAgPiBB/bEBIj0gP/22ASA9/QwAAAAAAAAAAAAAAAAAAAAA/Tn9UiI9/VoCBAAgKCA9/VoCBAEgLCA9/VoCBAIgLSA9/VoCBAMgFP0MAAAAAAAAAAAAAAAAAAAAACA+IED9rgEiPSA//bYBID39DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj39WgIEACAVID39WgIEASAcID39WgIEAiAdID39WgIEAyATQQRqIhMgG0cNAAsgESAiaiERIBAgHmohECACIB5qIQIgFiAbRgRAIA8hACANIQEgCyEKDAILIA8hACANIQEgCyEKIBtBAXQLIQsDQCAKKAIAIRMgAAJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgECgCACINaiIPIAkgCSAPShtBACAPQQBOGzYCACACIA0CfyATIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siDyAJIAkgD0obQQAgD0EAThs2AgAgAQJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyANaiINIAkgCSANShtBACANQQBOGzYCACAKKAIAIRMgAAJ/IBEoAgAgDGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgECgCBCINaiIPIAkgCSAPShtBACAPQQBOGzYCBCACIA0CfyATIAxrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siDyAJIAkgD0obQQAgD0EAThs2AgQgAQJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyANaiINIAkgCSANShtBACANQQBOGzYCBCARQQRqIREgCkEEaiEKIAFBCGohASACQQhqIQIgAEEIaiEAIBBBCGohECALQQJqIgsgIEkNAAsLIDtBAmoFQQALIBpPDQAgCigCACELIAACfyARKAIAIAxrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIBAoAgAiAGoiCiAJIAkgCkobQQAgCkEAThs2AgAgAiAAAn8gCyAMa7K7IgZEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAtrIgIgCSACIAlIG0EAIAJBAE4bNgIAIAECfyAGRCcxCKwcWvw/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsgAGoiACAJIAAgCUgbQQAgAEEAThs2AgALIBcoAhgoAiwQECAXKAIYIgAgBzYCLCAAKAJgEBAgFygCGCIAIAg2AmAgACgClAEQECAXKAIYIgAgDjYClAEgACAA/QACACI//QsCaCAAID/9CwI0IBdBATYCFAsMBwsgASgCBEEBRw0BIAEoAjhBAUcNASABKAJsQQFHDQEgASgCGCEAIAEoApQBIQIgASgCYCEHIAEoAiwhDCABKAIIIgogASgCDCIWbEECdCIBEBghDyABEBghFyABEBghCSAPRQ0FIBdFDQUgCUUNBSAWBEAgCiANKAIAQQFxIh9rISICf0EAQQEgAEEBa3QiFGuyuyIFRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLISdBfyAAdCE8ICJBfnEiHUEBayIKQQF2IgBBAWohIwJ/IAVEJzEIrBxa/D+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyEpIApBfnEhCiAAQQJ0IQggAEEDdCEAICNBfHEhGyA8QX9zIRECfyAFRDvfT42XbvY/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshKiAKQQJqISQgCEEEaiElIABBCGohICAbQQJ0ISYgG0EDdCEeIBtBAXQhECAR/REhPyAU/REhQyAdQQdJISggDyEKIBchACAJIQ4DQCAfBEAgCiAMKAIAIgEgKmoiCCARIAggEUgbQQAgCEEAThs2AgAgACABICdrIgggESAIIBFIG0EAIAhBAE4bNgIAIA4gASApaiIBIBEgASARSBtBACABQQBOGzYCACAOQQRqIQ4gCkEEaiEKIAxBBGohDCAAQQRqIQALAn8CfyAdRQRAIAchASAOIQsgCiEIQQAMAQtBACEZAkACQCAoDQAgCiAAICBqIgFJIAAgCiAgaiIISXENACAKIA4gIGoiC0kgCCAOS3ENACAKIAwgIGoiGkkgCCAMS3ENACAHIAhJIAogByAlaiIcSXENACACIAhJIAogAiAlaiIISXENACAAIAtJIAEgDktxDQAgACAaSSABIAxLcQ0AIAAgHEkgASAHS3ENACAAIAhJIAEgAktxDQAgDiAaSSALIAxLcQ0AIA4gHEkgByALSXENACACIAtJIAggDktxDQAgByAmaiEBIA4gHmohCyAKIB5qIQgDQCAMIBlBA3QiGkEYciIcaiIrIAwgGkEQciIVaiIsIAwgGkEIciISaiItIAwgGmoiLv0JAgD9VgIAAf1WAgAC/VYCAAMhPQJ/IAIgGUECdCIvav0AAgAgQ/2xAf36ASI+/V8iQP0MO99PjZdu9j8730+Nl272P/3yASJB/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyEwIAcgL2r9AAIAIUIgCiAaaiIv/QwAAAAAAAAAAAAAAAAAAAAAID0CfyBB/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIDD9HAECfyA+ID79DQgJCgsMDQ4PAAECAwABAgP9XyJB/Qw730+Nl272PzvfT42XbvY//fIBIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAMiRP2uASI+ID/9tgEgPv0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPv1aAgAAIAogEmoiMCA+/VoCAAEgCiAVaiIyID79WgIAAiAKIBxqIjMgPv1aAgADAn8gQiBD/bEB/foBIj79XyJC/QxqvHSTGATWP2q8dJMYBNY//fIBIED9DAwCK4cW2eY/DAIrhxbZ5j/98gH98AEiQP0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshMSAAIBpqIjT9DAAAAAAAAAAAAAAAAAAAAAAgPQJ/IED9IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/REgMf0cAQJ/ID79DAAAAAAAAAAAAAAAAAAAAAD9DQgJCgsMDQ4PAAECAwABAgP9XyJA/QxqvHSTGATWP2q8dJMYBNY//fIBIEH9DAwCK4cW2eY/DAIrhxbZ5j/98gH98AEiPv0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAICfyA+/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cAyJB/bEBIj4gP/22ASA+/QwAAAAAAAAAAAAAAAAAAAAA/Tn9UiI+/VoCAAAgACASaiIxID79WgIAASAAIBVqIjUgPv1aAgACIAAgHGoiNiA+/VoCAAMCfyBC/QwnMQisHFr8PycxCKwcWvw//fIBIj79IQEiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLITcgDiAaaiIa/QwAAAAAAAAAAAAAAAAAAAAAID0CfyA+/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIDf9HAECfyBA/QwnMQisHFr8PycxCKwcWvw//fIBIj39IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPf0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAMiQP2uASI9ID/9tgEgPf0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPf1aAgAAIA4gEmoiEiA9/VoCAAEgDiAVaiIVID39WgIAAiAOIBxqIhwgPf1aAgADIC/9DAAAAAAAAAAAAAAAAAAAAAAgK0EEaiAsQQRqIC1BBGogLv0JAgT9VgIAAf1WAgAC/VYCAAMiPiBE/a4BIj0gP/22ASA9/QwAAAAAAAAAAAAAAAAAAAAA/Tn9UiI9/VoCBAAgMCA9/VoCBAEgMiA9/VoCBAIgMyA9/VoCBAMgNP0MAAAAAAAAAAAAAAAAAAAAACA+IEH9sQEiPSA//bYBID39DAAAAAAAAAAAAAAAAAAAAAD9Of1SIj39WgIEACAxID39WgIEASA1ID39WgIEAiA2ID39WgIEAyAa/QwAAAAAAAAAAAAAAAAAAAAAID4gQP2uASI9ID/9tgEgPf0MAAAAAAAAAAAAAAAAAAAAAP05/VIiPf1aAgQAIBIgPf1aAgQBIBUgPf1aAgQCIBwgPf1aAgQDIBlBBGoiGSAbRw0ACyACICZqIQIgDCAeaiEMIAAgHmohACAQIRkgJCAbICNGDQIaDAELIAohCCAOIQsgByEBCwNAIAEoAgAhDiAIAn8gAigCACAUa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAMKAIAIgpqIgcgESAHIBFIG0EAIAdBAE4bNgIAIAAgCgJ/IA4gFGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIHIBEgByARSBtBACAHQQBOGzYCACALAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIApqIgogESAKIBFIG0EAIApBAE4bNgIAIAEoAgAhDiAIAn8gAigCACAUa7K7IgVEO99PjZdu9j+iIgaZRAAAAAAAAOBBYwRAIAaqDAELQYCAgIB4CyAMKAIEIgpqIgcgESAHIBFIG0EAIAdBAE4bNgIEIAAgCgJ/IA4gFGuyuyIGRGq8dJMYBNY/oiAFRAwCK4cW2eY/oqAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLayIHIBEgByARSBtBACAHQQBOGzYCBCALAn8gBkQnMQisHFr8P6IiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIApqIgogESAKIBFIG0EAIApBAE4bNgIEIAJBBGohAiABQQRqIQEgC0EIaiELIABBCGohACAIQQhqIQggDEEIaiEMIBlBAmoiGSAdSQ0ACyAkCyAiTwRAIAEhByAIIQogCwwBCyABKAIAIQ4gCAJ/IAIoAgAgFGuyuyIFRDvfT42XbvY/oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsgDCgCACIKaiIHIBEgByARSBtBACAHQQBOGzYCACAAIAoCfyAOIBRrsrsiBkRqvHSTGATWP6IgBUQMAiuHFtnmP6KgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C2siByARIAcgEUgbQQAgB0EAThs2AgAgCwJ/IAZEJzEIrBxa/D+iIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CyAKaiIKIBEgCiARSBtBACAKQQBOGzYCACACQQRqIQIgAUEEaiEHIABBBGohACAIQQRqIQogDEEEaiEMIAtBBGoLIQ4gE0EBaiITIBZHDQALCyANKAIYKAIsEBAgDSgCGCIAIA82AiwgACgCYBAQIA0oAhgiACAXNgJgIAAoApQBEBAgDSgCGCIAIAk2ApQBIAAgAP0AAgAiP/0LAmggACA//QsCNCANQQE2AhRBACEZDAYLIAEoAmhBAUcNACABKAIEQQFHDQAgASgCOEEBRw0AIAEoAmxBAUcNACABKAIYIQIgASgClAEhCCABKAJgIQwgASgCLCEAIAEoAgwgASgCCGwiF0ECdCIBEBghByABEBghDyABEBghDgJAIAdFDQAgD0UNACAORQ0AIBdFDQRBfyACdEF/cyEZQQEgAkEBa3QhESAXQQhJDQIgDyAHa0EQSQ0CIA4gB2tBEEkNAiAHIABrQRBJDQIgByAMa0EQSQ0CIAcgCGtBEEkNAiAOIA9rQRBJDQIgDyAAa0EQSQ0CIA8gDGtBEEkNAiAPIAhrQRBJDQIgDiAAa0EQSQ0CIA4gDGtBEEkNAiAOIAhrQRBJDQIgCCAXQXxxIgpBAnQiCWohCyAJIA5qIQEgByAJaiECIBn9ESE/IBH9ESE9A0ACfyAIIBNBAnQiEGr9AAIAID39sQH9+gEiPv1fIkD9DDvfT42XbvY/O99PjZdu9j/98gEiQf0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshFCAMIBBq/QACACFCIAcgEGr9DAAAAAAAAAAAAAAAAAAAAAAgACAQav0AAgAiQwJ/IEH9IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/REgFP0cAQJ/ID4gPv0NCAkKCwwNDg8AAQIDAAECA/1fIj79DDvfT42XbvY/O99PjZdu9j/98gEiQf0hACIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAICfyBB/SEBIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0cA/2uASJBID/9tgEgQf0MAAAAAAAAAAAAAAAAAAAAAP05/VL9CwIAAn8gQiA9/bEB/foBIkH9XyJC/QxqvHSTGATWP2q8dJMYBNY//fIBIED9DAwCK4cW2eY/DAIrhxbZ5j/98gH98AEiQP0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshFCAPIBBq/QwAAAAAAAAAAAAAAAAAAAAAIEMCfyBA/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIBT9HAECfyBB/QwAAAAAAAAAAAAAAAAAAAAA/Q0ICQoLDA0ODwABAgMAAQID/V8iQP0Marx0kxgE1j9qvHSTGATWP/3yASA+/QwMAiuHFtnmPwwCK4cW2eY//fIB/fABIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAP9sQEiPiA//bYBID79DAAAAAAAAAAAAAAAAAAAAAD9Of1S/QsCAAJ/IEL9DCcxCKwcWvw/JzEIrBxa/D/98gEiPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshFCAOIBBq/QwAAAAAAAAAAAAAAAAAAAAAIEMCfyA+/SEAIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C/0RIBT9HAECfyBA/QwnMQisHFr8PycxCKwcWvw//fIBIj79IQAiBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgL/RwCAn8gPv0hASIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAv9HAP9rgEiPiA//bYBID79DAAAAAAAAAAAAAAAAAAAAAD9Of1S/QsCACATQQRqIhMgCkcNAAsgCiAXRg0EIAkgDGohDCAAIAlqIQAgCSAPagwDCyAHEBAgDxAQIA4QEAwFCyAYQbkDNgIEIBhBuAo2AgBB6MQBQcI+IBgQFgwECyAHIQIgDiEBIAghCyAPCyEIA0AgDCgCACETIAICfyALKAIAIBFrsrsiBUQ730+Nl272P6IiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIAAoAgAiCWoiECAZIBAgGUgbQQAgEEEAThs2AgAgCCAJAn8gEyARa7K7IgZEarx0kxgE1j+iIAVEDAIrhxbZ5j+ioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAtrIhAgGSAQIBlIG0EAIBBBAE4bNgIAIAECfyAGRCcxCKwcWvw/oiIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsgCWoiCSAZIAkgGUgbQQAgCUEAThs2AgAgAUEEaiEBIAhBBGohCCACQQRqIQIgC0EEaiELIAxBBGohDCAAQQRqIQAgCkEBaiIKIBdHDQALCyANKAIYKAIsEBAgDSgCGCIAIAc2AiwgACgCYBAQIA0oAhgiACAPNgJgIAAoApQBEBAgDSgCGCAONgKUASANQQE2AhRBACEZDAELIA8QECAXEBAgCRAQCyAYKAIgIQACQCADDQAgIUUNACAAKAIYIQ5BACETA0AgDiATQTRsaiIDKAIYIgJBCEcEQAJAIAJBB00EQCADKAIMIAMoAghsIQEgAygCLCEKIAMoAiAEQCABRQ0CQQEgAkEBa3StIUVBACEHIAFBBE8EQCABQXxxIQcgRf0SIT9BACEMA0AgCiAMQQJ0aiICIAL9AAIAIj39xwFBB/3LASI+/R0AID/9HQAiRn/9EiA+/R0BID/9HQEiR3/9HgEgPSA//Q0ICQoLDA0ODwABAgMAAQID/ccBQQf9ywEiPf0dACBGf/0SID39HQEgR3/9HgH9DQABAgMICQoLEBESExgZGhv9CwIAIAxBBGoiDCAHRw0ACyABIAdGDQMLA0AgCiAHQQJ0aiICIAI0AgBCB4YgRX8+AgAgB0EBaiIHIAFHDQALDAILIAFFDQFBfyACdEF/c60hRUEAIQcgAUEETwRAIAFBfHEhByBF/RIhP0EAIQwDQCAKIAxBAnRqIgIgAv0AAgAiPf3JAf0M/wAAAAAAAAD/AAAAAAAAAP3VASI+/R0AID/9HQAiRoD9EiA+/R0BID/9HQEiR4D9HgEgPSA//Q0ICQoLDA0ODwABAgMAAQID/ckB/Qz/AAAAAAAAAP8AAAAAAAAA/dUBIj39HQAgRoD9EiA9/R0BIEeA/R4B/Q0AAQIDCAkKCxAREhMYGRob/QsCACAMQQRqIgwgB0cNAAsgASAHRg0CCwNAIAogB0ECdGoiAiACNQIAQv8BfiBFgD4CACAHQQFqIgcgAUcNAAsMAQsgAkEIayEKIAMoAgwgAygCCGwhASADKAIsIQggAygCIARAIAFFDQFBACEHIAFBBE8EQCABQXxxIQdBACECA0AgCCACQQJ0aiILIAv9AAIAIAr9rAH9CwIAIAJBBGoiAiAHRw0ACyABIAdGDQILA0AgCCAHQQJ0aiICIAIoAgAgCnU2AgAgB0EBaiIHIAFHDQALDAELIAFFDQBBACEHIAFBBE8EQCABQXxxIQdBACECA0AgCCACQQJ0aiILIAv9AAIAIAr9rQH9CwIAIAJBBGoiAiAHRw0ACyABIAdGDQELA0AgCCAHQQJ0aiICIAIoAgAgCnY2AgAgB0EBaiIHIAFHDQALCyADQQg2AhgLIBNBAWoiEyAhRw0ACwsgACgCDCAAKAIIbCEBAkAgGUUEQCAAKAIUQQJGBEAgACgCEEEBRgRAIAAoAhgoAiwgARAODAMLIARFDQIgACgCGCIAKAIsIAAoAmAgARAIDAILIAAoAhgiACgCLCAAKAJgIAAoApQBIAEQBwwBCwJAAkACQCAhQQFrDgQAAwECAwsgACgCGCgCLCABEAYMAgsgACgCGCIAKAIsIAAoAmAgACgClAEgARAFDAELIAAoAhgiACgCLCAAKAJgIAAoApQBIAAoAsgBIAEQBAsgGCgCIBAhQQAhDAsgGEHgwABqJAAgDAsIAEEIIAAQJQurAgICfgJ/Qn8hAyAALQBEQQhxRQRAIAAgACgCICIGNgIkAkACQAJAIAAgACgCMCIFBH8DQCAGIAUgACgCACAAKAIUEQAAIgVBf0YNAiAAIAAoAiQgBWoiBjYCJCAAIAAoAjAgBWsiBTYCMCAFDQALIAAoAiAFIAYLNgIkIAFCAFUNAUIAIQMMAgsgACAAKAJEQQhyNgJEIAJBBEGB9QBBABAPIABBADYCMCAAIAAoAkRBCHI2AkRCfw8LQgAhAwNAIAEgACgCACAAKAIYEQsAIgRCf1EEQCACQQRB8vQAQQAQDyAAIAAoAkRBCHI2AkQgACAAKQM4IAN8NwM4Qn8gAyADUBsPCyADIAR8IQMgASAEfSIBQgBVDQALCyAAIAApAzggA3w3AzgLIAMLIwEBfyABIAEoAgAgASgCCCIBIACnIgIgASACSRtqNgIEQQELPAICfwF+IAEoAgAgASgCCGoiAyABKAIEIgJGBEBCfw8LIAEgAiAAp2o2AgQgAyACa6wiBCAAIAAgBFUbC5gDAgJ+An8gACgCMCIFIAGnIgZPBEAgACAFIAZrNgIwIAAgACgCJCAGajYCJCAAIAApAzggAXw3AzggAQ8LIAAtAERBBHEEQCAAQQA2AjAgACAAKAIkIAVqNgIkIAAgBa0iASAAKQM4fDcDOCABQn8gBRsPCwJAIAVFBEAMAQsgAEEANgIwIAAgACgCIDYCJCABIAWtIgN9IQELIAFCAFUEQANAIAApAwggACkDOCABIAN8fFQEQCACQQRBm/UAQQAQDyAAQQA2AjAgACAAKAIgNgIkIAAgACkDOCADfCIDNwM4IAApAwgiASADfSEEIAEgACgCACAAKAIcEQoAIQUgACgCRCECIAAgBQR/IAAgATcDOCACQXtxBSACC0EEcjYCREJ/IAQgASADURsPCyABIAAoAgAgACgCGBELACIEQn9RBEAgAkEEQZv1AEEAEA8gACAAKAJEQQRyNgJEIAAgACkDOCADfDcDOEJ/IAMgA1AbDwsgAyAEfCEDIAEgBH0iAUIAVQ0ACwsgACAAKQM4IAN8NwM4IAMLmwEBBX9BASACKAIIIgcgB0EBTRshBCACKAIEIgMgAigCAGshBgNAIAQiBUEBdCEEIAUgBmsgAUkNAAsgBSAHRwRAIAUQFCIDRQRAQX8PCyACKAIAIgQEQCADIAQgBhASGiACKAIAEBALIAIgBTYCCCACIAM2AgAgAiADIAZqIgM2AgQLIAMgACABEBIaIAIgAigCBCABajYCBCABC0YBAn8gAigCACACKAIIaiIEIAIoAgQiA0YEQEF/DwsgACADIAQgA2siACABIAAgAUkbIgAQEhogAiACKAIEIABqNgIEIAALqgIBBH8jAEEQayIEJAACQCAAKAJ0DQAgAkEBTQRAIANBAUH7wgBBABAPDAELIAEgBEEMakECEBEgBCgCDCIGQf//A3EiB0UEQCADQQFBnMMAQQAQDwwBCyACIAdBBmxBAmpJBEAgA0EBQfvCAEEAEA8MAQsgBkEGbBAUIgNFDQAgAEEIEBQiAjYCdCACRQRAIAMQEAwBCyACIAM2AgAgAiAELwEMIgI7AQQgAkUEQEEBIQUMAQtBACECA0AgAUECaiAEQQxqIgVBAhARIAMgAkEGbGoiBiAEKAIMOwEAIAFBBGogBUECEBEgBiAEKAIMOwECIAFBBmoiASAFQQIQESAGIAQoAgw7AQRBASEFIAJBAWoiAiAAKAJ0LwEESQ0ACwsgBEEQaiQAIAUL8AEBBX8jAEEQayIEJAACfyAAKAJ4IgVFBEAgA0EBQc3CAEEAEA9BAAwBCyAFKAIMBEAgA0EBQdvVAEEAEA9BAAwBCyACIAUtABIiBUECdCIGSQRAIANBAUGswgBBABAPQQAMAQtBACAGEBQiAkUNABogBQRAQQAhAwNAIAEgBEEMaiIHQQIQESACIANBAnRqIgYgBCgCDDsBACABQQJqIAdBARARIAYgBCgCDDoAAiABQQNqIAdBARARIAYgBCgCDDoAAyABQQRqIQEgA0EBaiIDIAVHDQALCyAAKAJ4IAI2AgxBAQshCCAEQRBqJAAgCAvwAwEJfyMAQRBrIgUkAAJAIAJBA0kNACAAKAJ4DQAgASAFQQxqQQIQESAFLwEMIglBgQhrQf93TQRAIAUgCTYCACADQQFBtBogBRAPDAELIAFBAmogBUEMakEBEBEgBS8BDCIIRQRAIANBAUHUF0EAEA8MAQsgCEEDaiACSw0AIAggCWxBAnQQFCIHRQ0AIAgQFCIKRQRAIAcQEAwBCyAIEBQiC0UEQCAHEBAgChAQDAELQRQQFCIGRQRAIAcQECAKEBAgCxAQDAELIAFBA2ohAyAGIAo2AgggBiALNgIEIAYgCTsBECAGIAc2AgAgBSgCDCEMIAZBADYCDCAGIAw6ABIgACAGNgJ4A0AgAyAFQQxqQQEQESAEIApqIAUtAAxB/wBxQQFqOgAAIAQgC2ogBSgCDEGAAXFBB3Y6AAAgA0EBaiEDIARBAWoiBCAIRw0ACyAJRQRAQQEhBAwBC0EAIQYDQEEAIQRBACEAA0AgAkEEIAQgCmotAABBB2pBA3YiBCAEQQRPGyIEIAMgAWtqSARAQQAhBAwDCyADIAVBDGogBBARIAcgBSgCDDYCACAHQQRqIQcgAyAEaiEDIABBAWoiAEH//wNxIgQgCEkNAAtBASEEIAZBAWoiBkH//wNxIAlJDQALCyAFQRBqJAAgBAuYAQECfyMAQRBrIgUkACAAKAIYIgRB/wFHBEAgBSAENgIAIANBAkHkEyAFEA8LAkACQCACIAAoAhRGBEAgAg0BQQEhBAwCC0EAIQQgA0EBQbvsAEEAEA8MAQtBACECA0BBASEEIAEgACgCSCACQQxsakEIakEBEBEgAUEBaiEBIAJBAWoiAiAAKAIUSQ0ACwsgBUEQaiQAIAQLjgYBBn8jAEHQAGsiBCQAAkAgAkECTQRAIANBAUGb7ABBABAPDAELIAAtAHwEQCADQQRB7tIAQQAQD0EBIQYMAQtBASEGIAEgAEEoakEBEBEgAUEBaiAAQTRqQQEQESABQQJqIABBLGpBARARIAFBA2ohBQJAAkACQAJAAkAgACgCKCIHQQFrDgIAAQILIAJBBk0EQCAEIAI2AhAgA0EBQcDxACAEQRBqEA9BACEGDAULAkAgAkEHRg0AIAAoAjBBDkYNACAEIAI2AjAgA0ECQcDxACAEQTBqEA8LIAUgAEEwakEEEBEgACgCMEEORw0DQSQQFCIFRQRAQQAhBiADQQFBszxBABAPDAULIAVBDjYCACAEQQA2AkAgBEEANgI4IARBADYCSCAEQQA2AjwgBEEANgJEIARBADYCTEGw6pACIQYgBEGw6pACNgI0IAVBgIyVogQ2AgQCfyACQQdHBEAgAkEjRgRAIAFBB2ogBEHMAGpBBBARIAFBC2ogBEHIAGpBBBARIAFBD2ogBEHEAGpBBBARIAFBE2ogBEFAa0EEEBEgAUEXaiAEQTxqQQQQESABQRtqIARBOGpBBBARIAFBH2ogBEE0akEEEBEgBUEANgIEIAQoAjQhBiAEKAI4IQIgBCgCQCEDIAQoAjwhByAEKAJEIQggBCgCTCEJIAQoAkgMAgsgBCACNgIgIANBAkHk8QAgBEEgahAPC0EAIQJBACEDQQAhB0EACyEBIAUgBzYCGCAFIAg2AhAgBSAJNgIIIAUgBjYCICAFIAI2AhwgBSADNgIUIAUgATYCDCAAQQA2AnAgACAFNgJsDAMLIAAgAkEDayIBNgJwIABBASABEBMiAzYCbCADRQ0BIAJBA0wNAkEAIQIDQCAFIARBzABqQQEQESAAKAJsIAJqIAQoAkw6AAAgBUEBaiEFIAJBAWoiAiABRw0ACwwCCyAHQQNJDQIgBCAHNgIAIANBBEHb9wAgBBAPDAILQQAhBiAAQQA2AnAMAQtBASEGIABBAToAfAsgBEHQAGokACAGC7QDAQN/IwBBIGsiBCQAAkAgACgCSARAIANBAkGNNUEAEA9BASECDAELIAJBDkcEQEEAIQIgA0EBQfrrAEEAEA8MAQsgASAAQRBqQQQQESABQQRqIABBDGpBBBARIAFBCGogAEEUakECEBEgACgCDCEFAkAgBAJ/IAAoAhAiBkUEQCAAKAIUDAELIAAoAhQiAiAFRQ0AGiACDQFBAAs2AgggBCAGNgIEIAQgBTYCACADQQFB3uoAIAQQD0EAIQIMAQsgAkGBgAFrQf//fk0EQEEAIQIgA0EBQYjqAEEAEA8MAQsgACACQQwQEyICNgJIIAJFBEBBACECIANBAUGt6gBBABAPDAELQQEhAiABQQpqIABBGGpBARARIAFBC2ogAEEcakEBEBEgACgCHCIFQQdHBEAgBCAFNgIQIANBBEGd+gAgBEEQahAPCyABQQxqIABBIGpBARARIAFBDWogAEEkakEBEBEgACgCACIBIAEtALwBQfsBcSAAKAIYQf8BRkECdHI6ALwBIAAoAgAiASAAKAIMNgLYASABIAAoAhA2AtwBIABBAToAhQELIARBIGokACACC7oEAQZ/IwBBEGsiBiQAAn8gAC0AZEECcUUEQCADQQFBkdQAQQAQD0EADAELIABBADYCaAJAAkACQCACBEADQCACQQdNBEAgA0EBQbkZQQAQDwwFCyABIAZBDGoiBUEEEBEgBigCDCEEIAFBBGogBUEEEBFBCCEHIAYoAgwhBQJAAkACQAJAIAQOAgEAAwsgAkEQSQRAQeEZIQQMBwsgAUEIaiAGQQhqQQQQESAGKAIIBEBByj8hBAwHCyABQQxqIAZBDGpBBBARIAYoAgwiBA0BQbIYIQQMBgsgA0EBQbIYQQAQDwwGC0EQIQcLIAQgB0kEQCADQQFBhcUAQQAQDwwFCyACIARJBEAgA0EBQb3EAEEAEA9BAAwGCwJAAkAgACABIAdqIAQgB2sgAwJ/AkACQAJAIAVB8di9mwZMBEAgBUHjxsGTBkYNASAFQebKkZsGRg0DIAVB8MK1mwZHDQVB4MABDAQLIAVB8tiNgwdGDQFBwMABIAVB8sihywZGDQMaIAVB8ti9mwZHDQRByMABDAMLQdDAAQwCC0HYwAEMAQtB6MABCygCBBEBAA0BQQAMBwsgACAAKAJoQf////8HcjYCaAtBASAIIAVB8sihywZGGyEIIAEgBGohASACIARrIgINAAsgCA0BCyADQQFB2cMAQQAQD0EADAMLIABBAToAhAEgACAAKAJkQQRyNgJkQQEMAgsgA0EBIARBABAPCyADQQFBng5BABAPQQALIQkgBkEQaiQAIAkL4gEBAX8gACgCZEEBRwRAIANBAUG+1ABBABAPQQAPCwJAIAJBB00EQAwBCyABIABBOGpBBBARIAFBBGogAEE8akEEEBEgAkEDcQRADAELIAAgAkEIayICQQJ2IgQ2AkACQCACRQ0AIAAgBEEEEBMiAjYCRCACRQRAIANBAUGpEEEAEA9BAA8LIAAoAkBFDQAgAUEIaiEDQQAhAgNAIAMgACgCRCACQQJ0akEEEBEgA0EEaiEDIAJBAWoiAiAAKAJASQ0ACwsgACAAKAJkQQJyNgJkQQEPCyADQQFBqi1BABAPQQALxAEBAn8gACAAKAIgIgQ2AiQCQCAAKAIwIgMEQANAIAQgAyAAKAIAIAAoAhQRAAAiA0F/Rg0CIAAgACgCJCADaiIENgIkIAAgACgCMCADayIDNgIwIAMNAAsgACgCICEECyAAQQA2AjAgACAENgIkIAEgACgCACAAKAIcEQoARQRAIAAgACgCREEIcjYCREEADwsgACABNwM4QQEPCyAAIAAoAkRBCHI2AkQgAkEEQYH1AEEAEA8gACAAKAJEQQhyNgJEQQALggEBAn8jAEEQayIEJAACfyAAKAJkBEAgA0EBQdvTAEEAEA9BAAwBCyACQQRHBEAgA0EBQc4tQQAQD0EADAELIAEgBEEMakEEEBEgBCgCDEGKjqroAEcEQCADQQFB9iVBABAPQQAMAQsgACAAKAJkQQFyNgJkQQELIQUgBEEQaiQAIAULDQAgACgCACABIAIQRQsJACAAKAIAEEoLCQAgACgCABBJCw0AIAAoAgAgASACEEwLQQEBfyACBH8gA0ECQdvLAEEAEA8gACgCACABIAIgAyAEEEZFBEAgA0EBQakvQQAQD0EADwsgACACIAMQcQVBAAsLFQAgACgCACABIAIgAyAEIAUgBhBOCw8AIAAoAgAgASACIAMQTwsTACAAKAIAIAEgAiADIAQgBRArCx0AIAAoAgAgASACIAMgBCAFIAYgByAIIAkgChAnC+oEAQd/AkAgASgCCEE1IAMQJEUNACABKAIEIgcoAgAhBSAHKAIIIQQCQCAFBEBBASEGIAVBAUcEQCAFQX5xIQoDQAJ/QQAgBkUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEGIARBCGohBCAJQQJqIgkgCkcNAAsLAkAgBUEBcQRAIAZFDQEgASAAIAMgBCgCABEAAEEARyEGCyAHQQA2AgAgBkUNAwwCCyAHQQA2AgBBAA8LIAdBADYCAAsgASgCCCIHKAIAIQUgBygCCCEEAkACQAJ/AkAgBQRAQQEhBiAFQQFxIQggBUEBRw0BQQAMAgsgB0EANgIADAILIAVBfnEhBUEAIQkDQAJ/QQAgBkUNABpBACABIAAgAyAEKAIAEQAARQ0AGiABIAAgAyAEKAIEEQAAQQBHCyEGIARBCGohBCAJQQJqIgkgBUcNAAsgBkULIQUgCARAIAUNAiABIAAgAyAEKAIAEQAAQQBHIQYLIAdBADYCAEEAIQggBkUNAgsgAS0AhAFFBEAgA0EBQb3WAEEAEA9BAA8LIAEtAIUBRQRAIANBAUGg1gBBABAPQQAPCyAAIAEoAgAgAiADEFAhCCACRQ0BIAIoAgAiAEUNAUEBIQQCQAJAAkACQAJAAkAgASgCMEEMaw4NAwQEBAUAAQQEBAQEAgQLQQIhBAwEC0EDIQQMAwtBBCEEDAILQQUhBAwBC0F/IQQLIAAgBDYCFCABKAJsIgNFDQEgACADNgIcIAIoAgAgASgCcDYCICABQQA2AmwgCA8LIAdBADYCAEEAIQgLIAgL5AkCCn8BfiMAQfAAayIDJABBgAghCAJ/AkBBAUGACBATIgYEQCADQdwAaiELIANB7ABqIQkDQAJAAkACQCABIANB6ABqIgRBCCACEBpBCEcNACAEIANB2ABqQQQQESAJIAtBBBARQQghBQJAAkACQAJAAkAgAygCWA4CAAEECyABKQMIIg1QBH5CAAUgDSABKQM4fQsiDUL4////D1MNASACQQFByj9BABAPDAQLIAEgA0HoAGoiBEEIIAIQGkEIRw0DIAQgA0HkAGpBBBARIAMoAmRFDQEgAkEBQco/QQAQDwwDCyADIA2nQQhqNgJYDAELIAkgA0HYAGpBBBARQRAhBQsgAygCXCIEQePkwNMGRgRAIAAoAmQiAUEEcQRAIAAgAUEIcjYCZAwCCyACQQFBrStBABAPIAYQEEEADAcLIAMoAlgiB0UEQCACQQFBshhBABAPIAYQEEEADAcLIAUgB0sEQCADIAQ2AgQgAyAHNgIAIAJBAUH65wAgAxAPDAYLAkACfwJ/AkACfwJAAkACQAJAAkAgBEHx2L2bBkwEQCAEQePGwZMGRg0CIARB5sqRmwZGDQQgBEHwwrWbBkcNAUHgwAEMBgsgBEGfwMDSBkwEQCAEQfLYvZsGRg0FQcDAASAEQfLIocsGRg0GGiAEQfDy0bMGRw0BQajAAQwICyAEQfLYjYMHRg0CIARBoMDA0gZGDQZBsMABIARB6OTA0wZGDQcaCyAAKAJkIgRBAXENCCACQQFB/A5BABAPIAYQEEEADA8LQdDAAQwDC0HYwAEMAgtB6MABDAELQcjAAQshCiADIARB/wFxNgJMIAMgBEEYdjYCQCADIARBCHZB/wFxNgJIIAMgBEEQdkH/AXE2AkQgAkECQckOIANBQGsQDyAHIAVrIgUgAC0AZEEEcQ0CGiADIAMoAlwiBEEYdjYCMCADIARB/wFxNgI8IAMgBEEQdkH/AXE2AjQgAyAEQQh2Qf8BcTYCOCACQQJB2jMgA0EwahAPIAAgACgCZEH/////B3I2AmQgASAFrSINIAIgASgCKBEIACANUQ0HIAJBAUGSHEEAEA8gBhAQQQAMCgtBoMABCyEKIAcgBWsLIQUgASkDCCINUAR+QgAFIA0gASkDOH0LIAWtUwRAIAMoAlghBCADKAJcIQAgAyABKQMIIg1QBH5CAAUgDSABKQM4fQs+AiggAyAFNgIkIAMgAEH/AXE2AiAgAyAAQRh2NgIUIAMgBDYCECADIABBCHZB/wFxNgIcIAMgAEEQdkH/AXE2AhggAkEBQc31ACADQRBqEA8MBwsgBSAITQRAIAYhBAwECyAFIQggBiAFEBciBA0DIAYQECACQQFB/w9BABAPQQAMBwsgBEECcUUEQCACQQFBwg9BABAPIAYQEEEADAcLIAAgBEH/////B3I2AmQgASAHIAVrrSINIAIgASgCKBEIACANUQ0DIAAtAGRBCHFFDQEgAkECQZIcQQAQDwsgBhAQQQEMBQsgAkEBQZIcQQAQDyAGEBBBAAwECyABIAQgBSACEBogBUcEQCACQQFBxBxBABAPIAQQEEEADAQLIAAgBCIGIAUgAiAKKAIEEQEADQALIAQQEEEADAILIAJBAUGiJUEAEA9BAAwBCyAGEBBBAAshDCADQfAAaiQAIAwL5gEBBn8gACgCCEE1IAIQJARAAkAgACgCCCIGKAIAIQMgBigCCCEFAkACQAJ/AkAgAwRAQQEhBCADQQFxIQcgA0EBRw0BQQAMAgsgBkEANgIADAILIANBfnEhAwNAAn9BACAERQ0AGkEAIAAgASACIAUoAgARAABFDQAaIAAgASACIAUoAgQRAABBAEcLIQQgBUEIaiEFIAhBAmoiCCADRw0ACyAERQshAyAHBEAgAw0CIAAgASACIAUoAgARAABBAEchBAsgBkEANgIAIARFDQILIAAoAgAaQQEPCyAGQQA2AgALC0EACwoAIAAoAgAaQQALFAAgACgCACIABEAgACABNgK4AQsLIQAgACgCACABEFMgAEEAOgB8IAAgASgCuEBBAXE2AoABCzIAIAJFBEBBAA8LIAAoAgAgASACIAMQSEUEQCADQQFBqS9BABAPQQAPCyAAIAIgAxBxC2kCAn8BfCMAQRBrIgMkACACBEADQCAAIANBCGoQRCABAn8gAysDCCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgAUEEaiEBIABBCGohACAEQQFqIgQgAkcNAAsLIANBEGokAAuEAQICfwF9IwBBEGsiAyQAIAIEQANAIAMgAC0AADoADyADIAAtAAE6AA4gAyAALQACOgANIAMgAC0AAzoADCABAn8gAyoCDCIFi0MAAABPXQRAIAWoDAELQYCAgIB4CzYCACABQQRqIQEgAEEEaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC0sBAn8jAEEQayIDJAAgAgRAA0AgACADQQxqQQQQESABIAMoAgw2AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtLAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMNgIAIAFBBGohASAAQQJqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALSgECfyMAQRBrIgMkACACBEADQCAAIANBCGoQRCABIAMrAwi2OAIAIAFBBGohASAAQQhqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALaAECfyMAQRBrIgMkACACBEADQCADIAAtAAA6AA8gAyAALQABOgAOIAMgAC0AAjoADSADIAAtAAM6AAwgASADKgIMOAIAIAFBBGohASAAQQRqIQAgBEEBaiIEIAJHDQALCyADQRBqJAALTAECfyMAQRBrIgMkACACBEADQCAAIANBDGpBBBARIAEgAygCDLM4AgAgAUEEaiEBIABBBGohACAEQQFqIgQgAkcNAAsLIANBEGokAAtMAQJ/IwBBEGsiAyQAIAIEQANAIAAgA0EMakECEBEgASADKAIMszgCACABQQRqIQEgAEECaiEAIARBAWoiBCACRw0ACwsgA0EQaiQAC6oIAg1/AXsjAEEQayIIJAACfyAAKAIIQRBGBEAgACgCnAEgACgCzAFBjCxsagwBCyAAKAIMCyEJAkAgAkUEQCADQQFB8B9BABAPDAELIAAoAkghBkEBIQQgASAIQQhqQQEQESAIKAIIIgVBAk8EQCADQQJBxsgAQQAQDwwBCyACIAVBAWpHBEBBACEEIANBAkHwH0EAEA8MAQsCQCAGKAIQIgNFDQAgCSgC0CshBCADQQhPBEAgA0F4cSEGQQAhAgNAIARBADYCvEMgBEEANgKEOyAEQQA2AswyIARBADYClCogBEEANgLcISAEQQA2AqQZIARBADYC7BAgBEEANgK0CCAEQcDDAGohBCACQQhqIgIgBkcNAAsLIANBB3EiA0UNAEEAIQIDQCAEQQA2ArQIIARBuAhqIQQgAkEBaiICIANHDQALCyAJKALoKyICBH8gAhAQIAlBADYC6CsgCCgCCAUgBQtFBEBBASEEDAELA0AgAUEBaiIBIAhBDGpBARARAkAgCSgCgCxF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KT0ALgAobnVsbCkAKCVkLCVkKSAAJXN9CgAJCSB9CgBbREVWXSBEdW1wIGFuIGltYWdlX2NvbXBfaGVhZGVyIHN0cnVjdCB7CgBbREVWXSBEdW1wIGFuIGltYWdlX2hlYWRlciBzdHJ1Y3QgewoASW1hZ2UgaW5mbyB7CgAJIGRlZmF1bHQgdGlsZSB7CgAlcwkgY29tcG9uZW50ICVkIHsKAAkJIGNvbXAgJWQgewoACSBUaWxlIGluZGV4OiB7CgAJIE1hcmtlciBsaXN0OiB7CgBDb2Rlc3RyZWFtIGluZGV4IGZyb20gbWFpbiBoZWFkZXI6IHsKAENvZGVzdHJlYW0gaW5mbyBmcm9tIG1haW4gaGVhZGVyOiB7CgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveAoARm91bmQgYSBtaXNwbGFjZWQgJyVjJWMlYyVjJyBib3ggb3V0c2lkZSBqcDJoIGJveAoATWFsZm9ybWVkIEpQMiBmaWxlIGZvcm1hdDogZmlyc3QgYm94IG11c3QgYmUgSlBFRyAyMDAwIHNpZ25hdHVyZSBib3gKAE1hbGZvcm1lZCBKUDIgZmlsZSBmb3JtYXQ6IHNlY29uZCBib3ggbXVzdCBiZSBmaWxlIHR5cGUgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB0byBoYW5kbGUganBlZzIwMDAgYm94CgBOb3QgZW5vdWdoIG1lbW9yeSB3aXRoIEZUWVAgQm94CgBBIG1hcmtlciBJRCB3YXMgZXhwZWN0ZWQgKDB4ZmYtLSkgaW5zdGVhZCBvZiAlLjh4CgAJCSBtY3Q9JXgKAAkJCSBjYmxrc3R5PSUjeAoACQkJIGNzdHk9JSN4CgAJCSBwcmc9JSN4CgBJbnRlZ2VyIG92ZXJmbG93CgAJIHRkeD0ldSwgdGR5PSV1CgAJIHR3PSV1LCB0aD0ldQoACSB0eDA9JXUsIHR5MD0ldQoASW52YWxpZCBjb21wb25lbnQgaW5kZXg6ICV1CgBTdHJlYW0gdG9vIHNob3J0CgBNYXJrZXIgaGFuZGxlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmVhZCB0aGUgbWFya2VyIHNlZ21lbnQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjdXJyZW50IHByZWNpbmN0IGNvZGVibG9jayBlbGVtZW50CgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQKAEVycm9yIHJlYWRpbmcgU1FjZCBvciBTUWNjIGVsZW1lbnQKAEEgQlBDQyBoZWFkZXIgYm94IGlzIGF2YWlsYWJsZSBhbHRob3VnaCBCUEMgZ2l2ZW4gYnkgdGhlIElIRFIgYm94ICglZCkgaW5kaWNhdGUgY29tcG9uZW50cyBiaXQgZGVwdGggaXMgY29uc3RhbnQKAEVycm9yIHdpdGggU0laIG1hcmtlcjogaWxsZWdhbCB0aWxlIG9mZnNldAoASW52YWxpZCBwcmVjaW5jdAoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGJhbmQgcHJlY2ludHMKAEZhaWxlZCB0byBkZWNvZGUgYWxsIHVzZWQgY29tcG9uZW50cwoAU2l6ZSBvZiBjb2RlIGJsb2NrIGRhdGEgZXhjZWVkcyBzeXN0ZW0gbGltaXRzCgBTaXplIG9mIHRpbGUgZGF0YSBleGNlZWRzIHN5c3RlbSBsaW1pdHMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtdWx0aXBsZSBNQ1QgbWFya2VycwoAQ29ycnVwdGVkIFBQTSBtYXJrZXJzCgBOb3QgZW5vdWdoIG1lbW9yeSBmb3IgdGlsZSByZXNvbHV0aW9ucwoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGNvbGxlY3Rpb25zCgBJbnZhbGlkIFBDTFIgYm94LiBSZXBvcnRzIDAgcGFsZXR0ZSBjb2x1bW5zCgBXZSBkbyBub3Qgc3VwcG9ydCBST0kgaW4gZGVjb2RpbmcgSFQgY29kZWJsb2NrcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgdW5kZWZpbmVkIHNpemVzCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aG91dCBzYW1lIG51bWJlciBvZiBpbmRpeGVzCgBJbnZhbGlkIHRpbGVjLT53aW5feHh4IHZhbHVlcwoAQ2Fubm90IGhhbmRsZSBib3ggb2YgbGVzcyB0aGFuIDggYnl0ZXMKAENhbm5vdCBoYW5kbGUgWEwgYm94IG9mIGxlc3MgdGhhbiAxNiBieXRlcwoAQ29tcG9uZW50IGluZGV4ICV1IHVzZWQgc2V2ZXJhbCB0aW1lcwoASW52YWxpZCBQQ0xSIGJveC4gUmVwb3J0cyAlZCBlbnRyaWVzCgBOb3QgZW5vdWdoIG1lbW9yeSB0byBjcmVhdGUgVGFnLXRyZWUgbm9kZXMKAENhbm5vdCB0YWtlIGluIGNoYXJnZSBtY3QgZGF0YSB3aXRoaW4gbXVsdGlwbGUgTUNUIHJlY29yZHMKAENhbm5vdCBkZWNvZGUgdGlsZSwgbWVtb3J5IGVycm9yCgBvcGpfajJrX2FwcGx5X25iX3RpbGVfcGFydHNfY29ycmVjdGlvbiBlcnJvcgoAUHJvYmxlbSB3aXRoIHNraXBwaW5nIEpQRUcyMDAwIGJveCwgc3RyZWFtIGVycm9yCgBQcm9ibGVtIHdpdGggcmVhZGluZyBKUEVHMjAwMCBib3gsIHN0cmVhbSBlcnJvcgoAVW5rbm93biBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCB0bCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBtaCBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHRha2UgaW4gY2hhcmdlIFNJWiBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUFBUIG1hcmtlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBQUFQgbWFya2VyCgBFcnJvciByZWFkaW5nIFNPVCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUExUIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ1QgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DVCBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIFNPUCBtYXJrZXIKAEV4cGVjdGVkIFNPUCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgTUNPIG1hcmtlcgoARXJyb3IgcmVhZGluZyBSR04gbWFya2VyCgBFcnJvciByZWFkaW5nIFBQTSBtYXJrZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgUFBNIG1hcmtlcgoARXJyb3IgcmVhZGluZyBUTE0gbWFya2VyCgBFcnJvciByZWFkaW5nIFBMTSBtYXJrZXIKAE5vdCBlbm91Z2ggc3BhY2UgZm9yIGV4cGVjdGVkIEVQSCBtYXJrZXIKAEV4cGVjdGVkIEVQSCBtYXJrZXIKAEVycm9yIHJlYWRpbmcgQ1JHIG1hcmtlcgoAVW5rbm93biBwcm9ncmVzc2lvbiBvcmRlciBpbiBDT0QgbWFya2VyCgBVbmtub3duIFNjb2QgdmFsdWUgaW4gQ09EIG1hcmtlcgoARXJyb3IgcmVhZGluZyBDT0QgbWFya2VyCgBFcnJvciByZWFkaW5nIFFDRCBtYXJrZXIKAENycm9yIHJlYWRpbmcgQ0JEIG1hcmtlcgoARXJyb3IgcmVhZGluZyBQT0MgbWFya2VyCgBFcnJvciByZWFkaW5nIENPQyBtYXJrZXIKAEVycm9yIHJlYWRpbmcgUUNDIG1hcmtlcgoARXJyb3IgcmVhZGluZyBNQ0MgbWFya2VyCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWFkIE1DQyBtYXJrZXIKAHJlcXVpcmVkIFNJWiBtYXJrZXIgbm90IGZvdW5kIGluIG1haW4gaGVhZGVyCgByZXF1aXJlZCBDT0QgbWFya2VyIG5vdCBmb3VuZCBpbiBtYWluIGhlYWRlcgoAcmVxdWlyZWQgUUNEIG1hcmtlciBub3QgZm91bmQgaW4gbWFpbiBoZWFkZXIKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGhhbmRsZSBqcGVnMjAwMCBmaWxlIGhlYWRlcgoATm90IGVub3VnaCBtZW1vcnkgdG8gcmVhZCBoZWFkZXIKAEVycm9yIHdpdGggSlAgU2lnbmF0dXJlIDogYmFkIG1hZ2ljIG51bWJlcgoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgY3VycmVudCBudW1iZXIgb2YgdGlsZS1wYXJ0ICglZCksIGdpdmluZyB1cAoASW4gU09UIG1hcmtlciwgVFBTb3QgKCVkKSBpcyBub3QgdmFsaWQgcmVnYXJkcyB0byB0aGUgcHJldmlvdXMgbnVtYmVyIG9mIHRpbGUtcGFydCAoJWQpLCBnaXZpbmcgdXAKAEluIFNPVCBtYXJrZXIsIFRQU290ICglZCkgaXMgbm90IHZhbGlkIHJlZ2FyZHMgdG8gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHRpbGUtcGFydCAoaGVhZGVyKSAoJWQpLCBnaXZpbmcgdXAKAHRpbGVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIHJlc29sdXRpb24KAE1hcmtlciBpcyBub3QgY29tcGxpYW50IHdpdGggaXRzIHBvc2l0aW9uCgBQcm9ibGVtIHdpdGggc2VlayBmdW5jdGlvbgoARXJyb3IgcmVhZGluZyBTUENvZCBTUENvYyBlbGVtZW50LCBJbnZhbGlkIGNibGt3L2NibGtoIGNvbWJpbmF0aW9uCgBJbnZhbGlkIG11bHRpcGxlIGNvbXBvbmVudCB0cmFuc2Zvcm1hdGlvbgoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIGNvbGxlY3Rpb25zIG90aGVyIHRoYW4gYXJyYXkgZGVjb3JyZWxhdGlvbgoAVG9vIGxhcmdlIHZhbHVlIGZvciBOcHBtCgBOb3QgZW5vdWdoIGJ5dGVzIHRvIHJlYWQgTnBwbQoAYmFkIHBsYWNlZCBqcGVnIGNvZGVzdHJlYW0KAAkgTWFpbiBoZWFkZXIgc3RhcnQgcG9zaXRpb249JWxsaQoJIE1haW4gaGVhZGVyIGVuZCBwb3NpdGlvbj0lbGxpCgBNYXJrZXIgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCBzdHJlYW0gbGVuZ3RoCgBUaWxlIHBhcnQgbGVuZ3RoIHNpemUgaW5jb25zaXN0ZW50IHdpdGggc3RyZWFtIGxlbmd0aAoAQ2Fubm90IHRha2UgaW4gY2hhcmdlIG11bHRpcGxlIGRhdGEgc3Bhbm5pbmcKAFdyb25nIGZsYWcKAEVycm9yIHdpdGggRlRZUCBzaWduYXR1cmUgQm94IHNpemUKAEVycm9yIHdpdGggSlAgc2lnbmF0dXJlIEJveCBzaXplCgBJbnZhbGlkIHByZWNpbmN0IHNpemUKAEluY29uc2lzdGVudCBtYXJrZXIgc2l6ZQoASW52YWxpZCBtYXJrZXIgc2l6ZQoARXJyb3Igd2l0aCBTSVogbWFya2VyIHNpemUKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIGFkZCBhIG5ldyB2YWxpZGF0aW9uIHByb2NlZHVyZQoATm90IGVub3VnaCBtZW1vcnkgdG8gZGVjb2RlIHRpbGUKAEZhaWxlZCB0byBkZWNvZGUgdGhlIGNvZGVzdHJlYW0gaW4gdGhlIEpQMiBmaWxlCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBpbmRpeCBzaHVmZmxlCgBDYW5ub3QgYWxsb2NhdGUgVGllciAxIGhhbmRsZQoATm8gZGVjb2RlZCBhcmVhIHBhcmFtZXRlcnMsIHNldCB0aGUgZGVjb2RlZCBhcmVhIHRvIHRoZSB3aG9sZSBpbWFnZQoATm90IGVub3VnaCBtZW1vcnkgdG8gY3JlYXRlIFRhZy10cmVlCgBOb3QgZW5vdWdoIG1lbW9yeSB0byByZWluaXRpYWxpemUgdGhlIHRhZyB0cmVlCgBFcnJvciByZWFkaW5nIFNQQ29kIFNQQ29jIGVsZW1lbnQsIEludmFsaWQgdHJhbnNmb3JtYXRpb24gZm91bmQKAEVycm9yIHJlYWRpbmcgU1BDb2QgU1BDb2MgZWxlbWVudC4gVW5zdXBwb3J0ZWQgTWl4ZWQgSFQgY29kZS1ibG9jayBzdHlsZSBmb3VuZAoAVGlsZSBZIGNvb3JkaW5hdGVzIGFyZSBub3Qgc3VwcG9ydGVkCgBUaWxlIFggY29vcmRpbmF0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQKAEltYWdlIGNvb3JkaW5hdGVzIGFib3ZlIElOVF9NQVggYXJlIG5vdCBzdXBwb3J0ZWQKAEpQRUcyMDAwIEhlYWRlciBib3ggbm90IHJlYWQgeWV0LCAnJWMlYyVjJWMnIGJveCB3aWxsIGJlIGlnbm9yZWQKAG9wal9qMmtfbWVyZ2VfcHB0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQKAE5vdCBlbm91Z2ggbWVtb3J5IHRvIHJlYWQgU09UIG1hcmtlci4gVGlsZSBpbmRleCBhbGxvY2F0aW9uIGZhaWxlZAoASWdub3JpbmcgaWhkciBib3guIEZpcnN0IGloZHIgYm94IGFscmVhZHkgcmVhZAoAWnBwdCAldSBhbHJlYWR5IHJlYWQKAFpwcG0gJXUgYWxyZWFkeSByZWFkCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCBzeW50aGV0aXplZCAweEZGIG1hcmtlcnMgcmVhZAoACQkJIGNibGt3PTJeJWQKAAkJCSBjYmxraD0yXiVkCgAJCQkgcW50c3R5PSVkCgAlcyBkeD0lZCwgZHk9JWQKAAkJCSByb2lzaGlmdD0lZAoACQkJIG51bWdiaXRzPSVkCgAJCSBudW1sYXllcnM9JWQKACVzIG51bWNvbXBzPSVkCgBvcGpfanAyX2FwcGx5X2NkZWY6IGFjbj0lZCwgbnVtY29tcHM9JWQKAG9wal9qcDJfYXBwbHlfY2RlZjogY249JWQsIG51bWNvbXBzPSVkCgAJCQkgbnVtcmVzb2x1dGlvbnM9JWQKAAkJIHR5cGU9JSN4LCBwb3M9JWxsaSwgbGVuPSVkCgAlcyBzZ25kPSVkCgAJCQkgcW1mYmlkPSVkCgAlcyBwcmVjPSVkCgAJCSBuYiBvZiB0aWxlLXBhcnQgaW4gdGlsZSBbJWRdPSVkCgAlcyB4MT0lZCwgeTE9JWQKACVzIHgwPSVkLCB5MD0lZAoARmFpbGVkIHRvIGRlY29kZSB0aWxlICVkLyVkCgBTZXR0aW5nIGRlY29kaW5nIGFyZWEgdG8gJWQsJWQsJWQsJWQKAEZhaWxlZCB0byBkZWNvZGUgY29tcG9uZW50ICVkCgBJbnZhbGlkIHZhbHVlIGZvciBudW1yZXNvbHV0aW9ucyA6ICVkLCBtYXggdmFsdWUgaXMgc2V0IGluIG9wZW5qcGVnLmggYXQgJWQKAEludmFsaWQgY29tcG9uZW50IG51bWJlcjogJWQsIHJlZ2FyZGluZyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgJWQKAFRvbyBtYW55IFBPQ3MgJWQKAEludmFsaWQgdGlsZSBudW1iZXIgJWQKAEludmFsaWQgdGlsZSBwYXJ0IGluZGV4IGZvciB0aWxlIG51bWJlciAlZC4gR290ICVkLCBleHBlY3RlZCAlZAoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBudW1iZXIgb2YgY29tcG9uZW50IGlzIGlsbGVnYWwgLT4gJWQKAE5vdCBlbm91Z2ggbWVtb3J5IGZvciBjaWVsYWIKAENhbm5vdCBhbGxvY2F0ZSBjYmxrLT5kZWNvZGVkX2RhdGEKAEZhaWxlZCB0byBtZXJnZSBQUFQgZGF0YQoARmFpbGVkIHRvIG1lcmdlIFBQTSBkYXRhCgBJbnZhbGlkIG51bWJlciBvZiBsYXllcnMgaW4gQ09EIG1hcmtlciA6ICVkIG5vdCBpbiByYW5nZSBbMS02NTUzNV0KACVzOiVkOmNvbG9yX2NteWtfdG9fcmdiCglDQU4gTk9UIENPTlZFUlQKACVzOiVkOmNvbG9yX2VzeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgAlczolZDpjb2xvcl9zeWNjX3RvX3JnYgoJQ0FOIE5PVCBDT05WRVJUCgBTdHJlYW0gdG9vIHNob3J0LCBleHBlY3RlZCBTT1QKAFVuYWJsZSB0byBzZXQgdDEgaGFuZGxlIGFzIFRMUwoAU3RyZWFtIGRvZXMgbm90IGVuZCB3aXRoIEVPQwoAQ2Fubm90IGhhbmRsZSBib3ggc2l6ZXMgaGlnaGVyIHRoYW4gMl4zMgoAb3BqX3BpX25leHRfbHJjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcmxjcCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfY3BybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcGNybCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3BpX25leHRfcnBjbCgpOiBpbnZhbGlkIGNvbXBubzAvY29tcG5vMQoAb3BqX3QxX2RlY29kZV9jYmxrKCk6IHVuc3VwcG9ydGVkIGJwbm9fcGx1c19vbmUgPSAlZCA+PSAzMQoARmFpbGVkIHRvIGRlY29kZSB0aWxlIDEvMQoASW5zdWZmaWNpZW50IGRhdGEgZm9yIENNQVAgYm94LgoATmVlZCB0byByZWFkIGEgUENMUiBib3ggYmVmb3JlIHRoZSBDTUFQIGJveC4KAEluc3VmZmljaWVudCBkYXRhIGZvciBDREVGIGJveC4KAE51bWJlciBvZiBjaGFubmVsIGRlc2NyaXB0aW9uIGlzIGVxdWFsIHRvIHplcm8gaW4gQ0RFRiBib3guCgBTdHJlYW0gZXJyb3Igd2hpbGUgcmVhZGluZyBKUDIgSGVhZGVyIGJveDogbm8gJ2loZHInIGJveC4KAE5vbiBjb25mb3JtYW50IGNvZGVzdHJlYW0gVFBzb3Q9PVROc290LgoAU3RyZWFtIGVycm9yIHdoaWxlIHJlYWRpbmcgSlAyIEhlYWRlciBib3g6IGJveCBsZW5ndGggaXMgaW5jb25zaXN0ZW50LgoAQm94IGxlbmd0aCBpcyBpbmNvbnNpc3RlbnQuCgBSZXNvbHV0aW9uIGZhY3RvciBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBpbiB0aGUgY29tcG9uZW50LgoAQ29tcG9uZW50IG1hcHBpbmcgc2VlbXMgd3JvbmcuIFRyeWluZyB0byBjb3JyZWN0LgoASW5jb21wbGV0ZSBjaGFubmVsIGRlZmluaXRpb25zLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW52YWxpZCBjb2RlYmxvY2sgbGVuZ3RoIHZhbHVlcy4KAFdlIGRvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiAzIGNvZGluZyBwYXNzZXMgaW4gYW4gSFQgY29kZWJsb2NrOyBUaGlzIGNvZGVibG9ja3MgaGFzICVkIHBhc3Nlcy4KAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFRoZXJlIGFyZSAlZCB6ZXJvIGJpdHBsYW5lcyBpbiAlZCBiaXRwbGFuZXMuCgBDYW5ub3QgdGFrZSBpbiBjaGFyZ2UgbXVsdGlwbGUgdHJhbnNmb3JtYXRpb24gc3RhZ2VzLgoAVW5rbm93biBtYXJrZXIgaGFzIGJlZW4gZGV0ZWN0ZWQgYW5kIGdlbmVyYXRlZCBlcnJvci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfc2V0dXBfZGVjb2RlciBmdW5jdGlvbiBpcyBub3QgYSBkZWNvbXByZXNzb3IgaGFuZGxlci4KAENvZGVjIHByb3ZpZGVkIHRvIHRoZSBvcGpfcmVhZF9oZWFkZXIgZnVuY3Rpb24gaXMgbm90IGEgZGVjb21wcmVzc29yIGhhbmRsZXIuCgBUaWxlcyBkb24ndCBhbGwgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb24uIFNraXAgdGhlIE1DVCBzdGVwLgoATnVtYmVyIG9mIGNvbXBvbmVudHMgKCVkKSBpcyBpbmNvbnNpc3RlbnQgd2l0aCBhIE1DVC4gU2tpcCB0aGUgTUNUIHN0ZXAuCgBKUDIgYm94IHdoaWNoIGFyZSBhZnRlciB0aGUgY29kZXN0cmVhbSB3aWxsIG5vdCBiZSByZWFkIGJ5IHRoaXMgZnVuY3Rpb24uCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBXaGVuIHRoZSBudW1iZXIgb2YgemVybyBwbGFuZXMgYml0cGxhbmVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYml0cGxhbmVzLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3MgbWFrZXMgc2Vuc2UsIGJ1dCB3ZSBoYXZlICVkIHBhc3NlcyBpbiB0aGlzIGNvZGVibG9jay4gVGhlcmVmb3JlLCBvbmx5IHRoZSBjbGVhbnVwIHBhc3Mgd2lsbCBiZSBkZWNvZGVkLiBUaGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgZGlzcGxheWVkIGFnYWluLgoASW1hZ2UgaGFzIGxlc3MgY29tcG9uZW50cyB0aGFuIGNvZGVzdHJlYW0uCgBOZWVkIHRvIGRlY29kZSB0aGUgbWFpbiBoZWFkZXIgYmVmb3JlIGJlZ2luIHRvIGRlY29kZSB0aGUgcmVtYWluaW5nIGNvZGVzdHJlYW0uCgBQc290IHZhbHVlIG9mIHRoZSBjdXJyZW50IHRpbGUtcGFydCBpcyBlcXVhbCB0byB6ZXJvLCB3ZSBhc3N1bWluZyBpdCBpcyB0aGUgbGFzdCB0aWxlLXBhcnQgb2YgdGhlIGNvZGVzdHJlYW0uCgBBIG1hbGZvcm1lZCBjb2RlYmxvY2sgdGhhdCBoYXMgbW9yZSB0aGFuIG9uZSBjb2RpbmcgcGFzcywgYnV0IHplcm8gbGVuZ3RoIGZvciAybmQgYW5kIHBvdGVudGlhbGx5IHRoZSAzcmQgcGFzcyBpbiBhbiBIVCBjb2RlYmxvY2suCgAJCQkgdGlsZS1wYXJ0WyVkXTogc3Rhcl9wb3M9JWxsaSwgZW5kX2hlYWRlcj0lbGxpLCBlbmRfcG9zPSVsbGkuCgBUaWxlICV1IGhhcyBUUHNvdCA9PSAwIGFuZCBUTnNvdCA9PSAwLCBidXQgbm8gb3RoZXIgdGlsZS1wYXJ0cyB3ZXJlIGZvdW5kLiBFT0MgaXMgYWxzbyBtaXNzaW5nLgoAQ29tcG9uZW50ICVkIGRvZXNuJ3QgaGF2ZSBhIG1hcHBpbmcuCgBBIGNvbmZvcm1pbmcgSlAyIHJlYWRlciBzaGFsbCBpZ25vcmUgYWxsIENvbG91ciBTcGVjaWZpY2F0aW9uIGJveGVzIGFmdGVyIHRoZSBmaXJzdCwgc28gd2UgaWdub3JlIHRoaXMgb25lLgoAVGhlIHNpZ25hdHVyZSBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlICBib3ggbXVzdCBiZSB0aGUgZmlyc3QgYm94IGluIHRoZSBmaWxlLgoAVGhlIGZ0eXAgYm94IG11c3QgYmUgdGhlIHNlY29uZCBib3ggaW4gdGhlIGZpbGUuCgBGYWlsZWQgdG8gZGVjb2RlLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gSW5jb3JyZWN0IE1FTCBzZWdtZW50IHNlcXVlbmNlLgoAQ29tcG9uZW50ICVkIGlzIG1hcHBlZCB0d2ljZS4KAE9ubHkgb25lIENNQVAgYm94IGlzIGFsbG93ZWQuCgBXZSBuZWVkIGFuIGltYWdlIHByZXZpb3VzbHkgY3JlYXRlZC4KAElIRFIgYm94X21pc3NpbmcuIFJlcXVpcmVkLgoASlAySCBib3ggbWlzc2luZy4gUmVxdWlyZWQuCgBOb3Qgc3VyZSBob3cgdGhhdCBoYXBwZW5lZC4KAE1haW4gaGVhZGVyIGhhcyBiZWVuIGNvcnJlY3RseSBkZWNvZGVkLgoAVGlsZSAlZC8lZCBoYXMgYmVlbiBkZWNvZGVkLgoASGVhZGVyIG9mIHRpbGUgJWQgLyAlZCBoYXMgYmVlbiByZWFkLgoARW1wdHkgU09UIG1hcmtlciBkZXRlY3RlZDogUHNvdD0lZC4KAERpcmVjdCB1c2UgYXQgIyVkIGhvd2V2ZXIgcGNvbD0lZC4KAEltcGxlbWVudGF0aW9uIGxpbWl0YXRpb246IGZvciBwYWxldHRlIG1hcHBpbmcsIHBjb2xbJWRdIHNob3VsZCBiZSBlcXVhbCB0byAlZCwgYnV0IGlzIGVxdWFsIHRvICVkLgoASW52YWxpZCBjb21wb25lbnQvcGFsZXR0ZSBpbmRleCBmb3IgZGlyZWN0IG1hcHBpbmcgJWQuCgBJbnZhbGlkIHZhbHVlIGZvciBjbWFwWyVkXS5tdHlwID0gJWQuCgBQc290IHZhbHVlIGlzIG5vdCBjb3JyZWN0IHJlZ2FyZHMgdG8gdGhlIEpQRUcyMDAwIG5vcm06ICVkLgoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gVkxDIGNvZGUgcHJvZHVjZXMgc2lnbmlmaWNhbnQgc2FtcGxlcyBvdXRzaWRlIHRoZSBjb2RlYmxvY2sgYXJlYS4KAFVuZXhwZWN0ZWQgT09NLgoAMzIgYml0cyBhcmUgbm90IGVub3VnaCB0byBkZWNvZGUgdGhpcyBjb2RlYmxvY2ssIHNpbmNlIHRoZSBudW1iZXIgb2YgYml0cGxhbmUsICVkLCBpcyBsYXJnZXIgdGhhbiAzMC4KAEJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTE9JWQpIHNob3VsZCBiZSA+IDAuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIHNob3VsZCBiZSA+IDAuCgBVcCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feTA9JWQpIHNob3VsZCBiZSA+PSAwLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIHNob3VsZCBiZSA+PSAwLgoARXJyb3IgcmVhZGluZyBQUFQgbWFya2VyOiBwYWNrZXQgaGVhZGVyIGhhdmUgYmVlbiBwcmV2aW91c2x5IGZvdW5kIGluIHRoZSBtYWluIGhlYWRlciAoUFBNIG1hcmtlcikuCgBTdGFydCB0byByZWFkIGoyayBtYWluIGhlYWRlciAoJWxsZCkuCgBCb3R0b20gcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kxPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZc2l6PSVkKS4KAFVwIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MD0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWXNpej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoATGVmdCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDA9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhzaXo9JWQpLgoAQm90dG9tIHBvc2l0aW9uIG9mIHRoZSBkZWNvZGVkIGFyZWEgKHJlZ2lvbl95MT0lZCkgaXMgb3V0c2lkZSB0aGUgaW1hZ2UgYXJlYSAoWU9zaXo9JWQpLgoAVXAgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3kwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChZT3Npej0lZCkuCgBSaWdodCBwb3NpdGlvbiBvZiB0aGUgZGVjb2RlZCBhcmVhIChyZWdpb25feDE9JWQpIGlzIG91dHNpZGUgdGhlIGltYWdlIGFyZWEgKFhPc2l6PSVkKS4KAExlZnQgcG9zaXRpb24gb2YgdGhlIGRlY29kZWQgYXJlYSAocmVnaW9uX3gwPSVkKSBpcyBvdXRzaWRlIHRoZSBpbWFnZSBhcmVhIChYT3Npej0lZCkuCgBTaXplIHggb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0udz0lZCkuCgBTaXplIHkgb2YgdGhlIGRlY29kZWQgY29tcG9uZW50IGltYWdlIGlzIGluY29ycmVjdCAoY29tcFslZF0uaD0lZCkuCgBUaWxlIHJlYWQsIGRlY29kZWQgYW5kIHVwZGF0ZWQgaXMgbm90IHRoZSBkZXNpcmVkIG9uZSAoJWQgdnMgJWQpLgoASW52YWxpZCBjb21wb25lbnQgaW5kZXggJWQgKD49ICVkKS4KAG9wal9yZWFkX2hlYWRlcigpIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIG9wal9zZXRfZGVjb2RlZF9jb21wb25lbnRzKCkuCgBNZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlIGluIG9wal9qcDJfYXBwbHlfcGNscigpLgoAaW1hZ2UtPmNvbXBzWyVkXS5kYXRhID09IE5VTEwgaW4gb3BqX2pwMl9hcHBseV9wY2xyKCkuCgBpbnZhbGlkIGJveCBzaXplICVkICgleCkKAEZhaWwgdG8gcmVhZCB0aGUgY3VycmVudCBtYXJrZXIgc2VnbWVudCAoJSN4KQoARXJyb3Igd2l0aCBTSVogbWFya2VyOiBJSERSIHcoJXUpIGgoJXUpIHZzLiBTSVogdygldSkgaCgldSkKAEVycm9yIHJlYWRpbmcgQ09DIG1hcmtlciAoYmFkIG51bWJlciBvZiBjb21wb25lbnRzKQoASW52YWxpZCBudW1iZXIgb2YgdGlsZXMgOiAldSB4ICV1IChtYXhpbXVtIGZpeGVkIGJ5IGpwZWcyMDAwIG5vcm0gaXMgNjU1MzUgdGlsZXMpCgBJbnZhbGlkIG51bWJlciBvZiBjb21wb25lbnRzIChpaGRyKQoATm90IGVub3VnaCBtZW1vcnkgdG8gaGFuZGxlIGltYWdlIGhlYWRlciAoaWhkcikKAFdyb25nIHZhbHVlcyBmb3I6IHcoJWQpIGgoJWQpIG51bWNvbXBzKCVkKSAoaWhkcikKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBkeD0ldSBkeT0ldSAoc2hvdWxkIGJlIGJldHdlZW4gMSBhbmQgMjU1IGFjY29yZGluZyB0byB0aGUgSlBFRzIwMDAgbm9ybSkKAEJhZCBpbWFnZSBoZWFkZXIgYm94IChiYWQgc2l6ZSkKAEJhZCBDT0xSIGhlYWRlciBib3ggKGJhZCBzaXplKQoAQmFkIEJQQ0MgaGVhZGVyIGJveCAoYmFkIHNpemUpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG5lZ2F0aXZlIG9yIHplcm8gaW1hZ2Ugc2l6ZSAoJWxsZCB4ICVsbGQpCgBza2lwOiBzZWdtZW50IHRvbyBsb25nICglZCkgd2l0aCBtYXggKCVkKSBmb3IgY29kZWJsb2NrICVkIChwPSVkLCBiPSVkLCByPSVkLCBjPSVkKQoAcmVhZDogc2VnbWVudCB0b28gbG9uZyAoJWQpIHdpdGggbWF4ICglZCkgZm9yIGNvZGVibG9jayAlZCAocD0lZCwgYj0lZCwgcj0lZCwgYz0lZCkKAERlc3BpdGUgSlAyIEJQQyE9MjU1LCBwcmVjaXNpb24gYW5kL29yIHNnbmQgdmFsdWVzIGZvciBjb21wWyVkXSBpcyBkaWZmZXJlbnQgdGhhbiBjb21wWzBdOgogICAgICAgIFswXSBwcmVjKCVkKSBzZ25kKCVkKSBbJWRdIHByZWMoJWQpIHNnbmQoJWQpCgBiYWQgY29tcG9uZW50IG51bWJlciBpbiBSR04gKCVkIHdoZW4gdGhlcmUgYXJlIG9ubHkgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IG51bWJlciBvZiBjb21wb25lbnQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcmVtYWluaW5nIG51bWJlciBvZiBwYXJhbWV0ZXJzICggJWQgdnMgJWQpCgBFcnJvciB3aXRoIFNJWiBtYXJrZXI6IGludmFsaWQgdGlsZSBzaXplICh0ZHg6ICVkLCB0ZHk6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoYmFkIHNpemU6ICVkKQoAQmFkIENPTFIgaGVhZGVyIGJveCAoQ0lFTGFiLCBiYWQgc2l6ZTogJWQpCgBQVEVSTSBjaGVjayBmYWlsdXJlOiAlZCByZW1haW5pbmcgYnl0ZXMgaW4gY29kZSBibG9jayAoJWQgdXNlZCAvICVkKQoATWFsZm9ybWVkIEhUIGNvZGVibG9jay4gT25lIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQ6IDIgPD0gU2N1cCA8PSBtaW4oTGN1cCwgNDA3OSkKAEludmFsaWQgdmFsdWVzIGZvciBjb21wID0gJWQgOiBwcmVjPSV1IChzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAzOCBhY2NvcmRpbmcgdG8gdGhlIEpQRUcyMDAwIG5vcm0uIE9wZW5KcGVnIG9ubHkgc3VwcG9ydHMgdXAgdG8gMzEpCgBJbnZhbGlkIGJpdCBudW1iZXIgJWQgaW4gb3BqX3QyX3JlYWRfcGFja2V0X2hlYWRlcigpCgBTdHJlYW0gZXJyb3IhCgBFcnJvciBvbiB3cml0aW5nIHN0cmVhbSEKAFN0cmVhbSByZWFjaGVkIGl0cyBlbmQgIQoARXhwZWN0ZWQgYSBTT0MgbWFya2VyIAoASW52YWxpZCBib3ggc2l6ZSAlZCBmb3IgYm94ICclYyVjJWMlYycuIE5lZWQgJWQgYnl0ZXMsICVkIGJ5dGVzIHJlbWFpbmluZyAKAE1hbGZvcm1lZCBIVCBjb2RlYmxvY2suIERlY29kaW5nIHRoaXMgY29kZWJsb2NrIGlzIHN0b3BwZWQuIFVfcSBpcyBsYXJnZXIgdGhhbiB6ZXJvIGJpdHBsYW5lcyArIDEgCgBNYWxmb3JtZWQgSFQgY29kZWJsb2NrLiBEZWNvZGluZyB0aGlzIGNvZGVibG9jayBpcyBzdG9wcGVkLiBVX3EgaXNsYXJnZXIgdGhhbiBiaXRwbGFuZXMgKyAxIAoAQ09MUiBCT1ggbWV0aCB2YWx1ZSBpcyBub3QgYSByZWd1bGFyIHZhbHVlICglZCksIHNvIHdlIHdpbGwgaWdub3JlIHRoZSBlbnRpcmUgQ29sb3VyIFNwZWNpZmljYXRpb24gYm94LiAKAFdoaWxlIHJlYWRpbmcgQ0NQX1FOVFNUWSBlbGVtZW50IGluc2lkZSBRQ0Qgb3IgUUNDIG1hcmtlciBzZWdtZW50LCBudW1iZXIgb2Ygc3ViYmFuZHMgKCVkKSBpcyBncmVhdGVyIHRvIE9QSl9KMktfTUFYQkFORFMgKCVkKS4gU28gd2UgbGltaXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgdG8gT1BKX0oyS19NQVhCQU5EUyAoJWQpIGFuZCBza2lwIHRoZSByZXN0LiAKAEpQMiBJSERSIGJveDogY29tcHJlc3Npb24gdHlwZSBpbmRpY2F0ZSB0aGF0IHRoZSBmaWxlIGlzIG5vdCBhIGNvbmZvcm1pbmcgSlAyIGZpbGUgKCVkKSAKAFRpbGUgaW5kZXggcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgaW5jb3JyZWN0ICVkIChtYXggPSAlZCkgCgBFcnJvciBkZWNvZGluZyBjb21wb25lbnQgJWQuClRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgdG8gcmVtb3ZlICglZCkgaXMgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBudW1iZXIgb2YgcmVzb2x1dGlvbnMgb2YgdGhpcyBjb21wb25lbnQgKCVkKQpNb2RpZnkgdGhlIGNwX3JlZHVjZSBwYXJhbWV0ZXIuCgoASW1hZ2UgZGF0YSBoYXMgYmVlbiB1cGRhdGVkIHdpdGggdGlsZSAlZC4KCgBBoP0AC4AgIwClAEMAZgCDAO6oFADf2CMAvhBDAP/1gwB+IFUAX1EjADUAQwBORIMAzsQUAM/MIwD+4kMA/5mDAJYAxQA/MSMApQBDAF5EgwDOyBQA3xEjAP70QwD//IMAngBVAHcAIwA1AEMA//GDAK6IFAC3ACMA/vhDAO/kgwCOiMUAHxEjAKUAQwBmAIMA7qgUAN9UIwC+EEMA7yKDAH4gVQB/IiMANQBDAE5EgwDOxBQAvxEjAP7iQwD3AIMAlgDFAD8iIwClAEMAXkSDAM7IFADXACMA/vRDAP+6gwCeAFUAbwAjADUAQwD/5oMArogUAK+iIwD++EMA5wCDAI6IxQAvIgIAxQCEAH4gAgDOxCQA9wACAP6iRABWAAIAngAUANcAAgC+EIQAZgACAK6IJADfEQIA7qhEADYAAgCOiBQAHxECAMUAhABuAAIAzogkAP+IAgD+uEQATkQCAJYAFAC3AAIA/uSEAF5EAgCmACQA5wACAN5URAAuIgIAPgAUAHcAAgDFAIQAfiACAM7EJAD/8QIA/qJEAFYAAgCeABQAvxECAL4QhABmAAIArogkAO8iAgDuqEQANgACAI6IFAB/IgIAxQCEAG4AAgDOiCQA7+QCAP64RABORAIAlgAUAK+iAgD+5IQAXkQCAKYAJADf2AIA3lREAC4iAgA+ABQAX1ECAFUAhABmAAIA3ogkAP8yAgD+EUQATkQCAK4AFAC3AAIAfjGEAF5RAgDGACQA1wACAO4gRAAeEQIAngAUAHcAAgBVAIQAXlQCAM5EJADnAAIA/vFEADYAAgCmABQAX1UCAP50hAA+EQIAviAkAH90AgDexEQA//gCAJYAFAAvIgIAVQCEAGYAAgDeiCQA9wACAP4RRABORAIArgAUAI+IAgB+MYQAXlECAMYAJADPyAIA7iBEAB4RAgCeABQAbwACAFUAhABeVAIAzkQkAN/RAgD+8UQANgACAKYAFAB/IgIA/nSEAD4RAgC+ICQAvyICAN7ERADvIgIAlgAUAD8yAwDe1P30//wUAD4RVQCPiAMAvjKFAOcAJQBeUf6qf3IDAM5E/fjvRBQAfmRFAK+iAwCmAF1V35n98TYA/vVvYgMA3tH99P/mFAB+cVUAv7EDAK6IhQDf1SUATkT+8n9mAwDGAP347+IUAF5URQCfEQMAlgBdVc/I/fEeEe7IZwADAN7U/fT/8xQAPhFVAL8RAwC+MoUA39glAF5R/qovIgMAzkT9+PcAFAB+ZEUAn5gDAKYAXVXXAP3xNgD+9W9EAwDe0f30/7kUAH5xVQC3AAMAroiFAN/cJQBORP7ydwADAMYA/fjv5BQAXlRFAH9zAwCWAF1Vv7j98R4R7sg/MgIApQCEAH5AAgDeECQA3xECAP5yRABWAAIArqgUAL+yAgCWAIQAZgACAMYAJADnAAIA7shEAC4iAgCOiBQAdwACAKUAhABuAAIAzogkAPcAAgD+kUQANgACAK6iFACvqgIA/riEAF4AAgC+ACQAz8QCAO5ERAD/9AIAPiIUAB8RAgClAIQAfkACAN4QJAD/mQIA/nJEAFYAAgCuqBQAtwACAJYAhABmAAIAxgAkANcAAgDuyEQALiICAI6IFABPRAIApQCEAG4AAgDOiCQA7+ICAP6RRAA2AAIArqIUAH9EAgD+uIQAXgACAL4AJACfAAIA7kREAP92AgA+IhQAPzEDAMYAhQD/2f3yfmT+8b+ZAwCuoiUA72b99FYA7uJ/cwMAvphFAPcA/fhmAP52n4gDAI6IFQDf1aUALiLemE9EAwC+soUA//z98m4ilgC3AAMArqolAN/R/fQ2AN7Ub2QDAK6oRQDv6v34XkTu6H9xAwA+MhUAz8SlAP/6zog/MQMAxgCFAP93/fJ+ZP7xv7MDAK6iJQDnAP30VgDu4ncAAwC+mEUA7+T9+GYA/nZ/ZgMAjogVANcApQAuIt6YPzMDAL6yhQD/df3ybiKWAJ+RAwCuqiUA35n99DYA3tRfUQMArqhFAO/s/fheRO7of3IDAD4yFQC/saUA//POiB8RAwDeVP3yHhEUAH5k/vjPzAMAvpFFAO8iJQAuIv7zj4gDAMYAhQD3ABQAXhH+/K+oAwCmADUA38j98T4x/mZvZAMAzsj98v/1FABmAP70v7oDAK4iRQDnACUAPjL+6n9zAwC+soUA31UUAFYAfnGfEQMAlgA1AM/E/fE+M+7oT0QDAN5U/fIeERQAfmT++L+ZAwC+kUUA7+IlAC4i/vN/ZgMAxgCFAO/kFABeEf78n5gDAKYANQDXAP3xPjH+Zm8iAwDOyP3y/7kUAGYA/vS3AAMAriJFAN/RJQA+Mv7qdwADAL6yhQDv7BQAVgB+cX9yAwCWADUAv7j98T4z7uhfVPzx3tH9+tcA/PgWAP3/f3T89H5x/fO/s/zy7+ru6E9E/PGuIgUAv7j8+PcA/vx3APz0XhH99X91/PLf2O7iPzP88b6y/frPiPz4//v9/39z/PRuAP3ztwD88u9m/vk/MfzxngAFAL+6/Pj//f72ZwD89CYA/fWPiPzy39ze1C8i/PHe0f36z8T8+BYA/f9/cvz0fnH987+Z/PLv7O7oRwD88a4iBQCnAPz4//f+/FcA/PReEf31lwD88t/V7uI3APzxvrL9+scA/Pj//v3/f2b89G4A/fOvqPzy5wD++T8y/PGeAAUAv7H8+O/k/vZfVPz0JgD99YcA/PLfmd7UHxETAGUAQwDeAIMAjYgjAE5EEwClAEMAroiDADUAIwDXABMAxQBDAJ4AgwBVACMALiITAJUAQwB+AIMA/hAjAHcAEwBlAEMAzoiDAI2IIwAeERMApQBDAF4AgwA1ACMA5wATAMUAQwC+AIMAVQAjAP8REwCVAEMAPgCDAO5AIwCvohMAZQBDAN4AgwCNiCMATkQTAKUAQwCuiIMANQAjAO9EEwDFAEMAngCDAFUAIwAuIhMAlQBDAH4AgwD+ECMAtwATAGUAQwDOiIMAjYgjAB4REwClAEMAXgCDADUAIwDPxBMAxQBDAL4AgwBVACMA9wATAJUAQwA+AIMA7kAjAG8AAQCEAAEAVgABABQAAQDXAAEAJAABAJYAAQBFAAEAdwABAIQAAQDGAAEAFAABAI+IAQAkAAEA9wABADUAAQAvIgEAhAABAP5AAQAUAAEAtwABACQAAQC/AAEARQABAGcAAQCEAAEApgABABQAAQBPRAEAJAABAOcAAQA1AAEAPxEBAIQAAQBWAAEAFAABAM8AAQAkAAEAlgABAEUAAQBvAAEAhAABAMYAAQAUAAEAnwABACQAAQDvAAEANQABAD8yAQCEAAEA/kABABQAAQCvAAEAJAABAP9EAQBFAAEAXwABAIQAAQCmAAEAFAABAH8AAQAkAAEA3wABADUAAQAfEQEAJAABAFYAAQCFAAEAvwABABQAAQD3AAEAxgABAHcAAQAkAAEA//gBAEUAAQB/AAEAFAABAN8AAQCmAAEAPzEBACQAAQAuIgEAhQABALcAAQAUAAEA70QBAK6iAQBnAAEAJAABAP9RAQBFAAEAlwABABQAAQDPAAEANgABAD8iAQAkAAEAVgABAIUAAQC/sgEAFAABAO9AAQDGAAEAbwABACQAAQD/cgEARQABAJ8AAQAUAAEA1wABAKYAAQBPRAEAJAABAC4iAQCFAAEAr6gBABQAAQDnAAEArqIBAF8AAQAkAAEA/0QBAEUAAQCPiAEAFAABAK+qAQA2AAEAHxECAP74JABWAAIAtgCFAP9mAgDOABQAHhECAJYANQCvqAIA9gAkAD4xAgCmAEUAv7MCAL6yFAD/9QIAZgB+UV9UAgD+8iQALiICAK4ihQDvRAIAxgAUAP/0AgB2ADUAf0QCAN5AJAA+MgIAngBFANcAAgC+iBQA//oCAF4R/vFPRAIA/vgkAFYAAgC2AIUA78gCAM4AFAAeEQIAlgA1AI+IAgD2ACQAPjECAKYARQDfRAIAvrIUAP+oAgBmAH5RbwACAP7yJAAuIgIAriKFAOcAAgDGABQA7+ICAHYANQB/cgIA3kAkAD4yAgCeAEUAv7ECAL6IFAD/cwIAXhH+8T8zAQCEAAEA7iABAMUAAQDPxAEARAABAP8yAQAVAAEAj4gBAIQAAQBmAAEAJQABAK8AAQBEAAEA7yIBAKYAAQBfAAEAhAABAE5EAQDFAAEAz8wBAEQAAQD3AAEAFQABAG8AAQCEAAEAVgABACUAAQCfAAEARAABAN8AAQD+MAEALyIBAIQAAQDuIAEAxQABAM/IAQBEAAEA/xEBABUAAQB3AAEAhAABAGYAAQAlAAEAfwABAEQAAQDnAAEApgABADcAAQCEAAEATkQBAMUAAQC3AAEARAABAL8AAQAVAAEAPwABAIQAAQBWAAEAJQABAJcAAQBEAAEA1wABAP4wAQAfEQIA7qhEAI6IAgDWAMUA//MCAP78JQA+AAIAtgBVAN/YAgD++EQAZgACAH4ghQD/mQIA5gD1ADYAAgCmABUAnwACAP7yRAB2AAIAzkTFAP92AgD+8SUATkQCAK4AVQDPyAIA/vREAF5EAgC+EIUA7+QCAN5U9QAeEQIAlgAVAC8iAgDuqEQAjogCANYAxQD/+gIA/vwlAD4AAgC2AFUAvxECAP74RABmAAIAfiCFAO8iAgDmAPUANgACAKYAFQB/IgIA/vJEAHYAAgDORMUA/9UCAP7xJQBORAIArgBVAG8AAgD+9EQAXkQCAL4QhQDfEQIA3lT1AB4RAgCWABUAX1EDAPYAFAAeEUQAjoilAN/UAwCuolUA/3YkAD4itgCvqgMA5gAUAP/1RABmAIUAz8wDAJ4AxQDvRCQANgD++H8xAwDu6BQA//FEAHYApQDPxAMAfiJVAN/RJABORP70X1EDANYAFADv4kQAXkSFAL8iAwCWAMUA38gkAC4i/vJvIgMA9gAUAB4RRACOiKUAv7EDAK6iVQD/MyQAPiK2AK+oAwDmABQA/7lEAGYAhQC/qAMAngDFAO/kJAA2AP74b2QDAO7oFAD//EQAdgClAM/IAwB+IlUA7+okAE5E/vR/dAMA1gAUAP/6RABeRIUAv7IDAJYAxQDfRCQALiL+8j8x8wD++v3xNgAEAL4ydQDfEfMA3lT98u/k1QB+cf78f3PzAP7z/fgeEQQAlgBVAL+x8wDOALUA39j99GYA/rlfVPMA/nb98SYABACmAHUAnwDzAK4A/fL/99UARgD+9X908wDmAP34FgAEAIYAVQCPiPMAxgC1AO/i/fReEe6oPxHzAP76/fE2AAQAvjJ1AN/R8wDeVP3y//vVAH5x/vx/RPMA/vP9+B4RBACWAFUAf3LzAM4AtQDvIv30ZgD+uU9E8wD+dv3xJgAEAKYAdQC/EfMArgD98v//1QBGAP71PzLzAOYA/fgWAAQAhgBVAG8A8wDGALUAv7j99F4R7qgvIgBBrJ0BC6QeAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAwAAAAMAAAAEAAAABQAAALchQiFnIUIhERERETMzMzN3d3d3AAAAAAAAAAABVgAAAAAAABBPAAAgTwAAAVYAAAEAAAAgTwAAEE8AAAE0AAAAAAAAME8AALBPAAABNAAAAQAAAEBPAADATwAAARgAAAAAAABQTwAAEFAAAAEYAAABAAAAYE8AACBQAADBCgAAAAAAAHBPAABwUAAAwQoAAAEAAACATwAAgFAAACEFAAAAAAAAkE8AAJBSAAAhBQAAAQAAAKBPAACgUgAAIQIAAAAAAACwUwAAEFMAACECAAABAAAAwFMAACBTAAABVgAAAAAAANBPAADATwAAAVYAAAEAAADgTwAAsE8AAAFUAAAAAAAA8E8AALBQAAABVAAAAQAAAABQAADAUAAAAUgAAAAAAAAQUAAAsFAAAAFIAAABAAAAIFAAAMBQAAABOAAAAAAAADBQAACwUAAAATgAAAEAAABAUAAAwFAAAAEwAAAAAAAAUFAAABBRAAABMAAAAQAAAGBQAAAgUQAAASQAAAAAAABwUAAAMFEAAAEkAAABAAAAgFAAAEBRAAABHAAAAAAAAJBQAABwUQAAARwAAAEAAACgUAAAgFEAAAEWAAAAAAAAkFIAAJBRAAABFgAAAQAAAKBSAACgUQAAAVYAAAAAAADQUAAAwFAAAAFWAAABAAAA4FAAALBQAAABVAAAAAAAAPBQAACwUAAAAVQAAAEAAAAAUQAAwFAAAAFRAAAAAAAAEFEAANBQAAABUQAAAQAAACBRAADgUAAAAUgAAAAAAAAwUQAA8FAAAAFIAAABAAAAQFEAAABRAAABOAAAAAAAAFBRAAAQUQAAATgAAAEAAABgUQAAIFEAAAE0AAAAAAAAcFEAADBRAAABNAAAAQAAAIBRAABAUQAAATAAAAAAAACQUQAAUFEAAAEwAAABAAAAoFEAAGBRAAABKAAAAAAAALBRAABQUQAAASgAAAEAAADAUQAAYFEAAAEkAAAAAAAA0FEAAHBRAAABJAAAAQAAAOBRAACAUQAAASIAAAAAAADwUQAAkFEAAAEiAAABAAAAAFIAAKBRAAABHAAAAAAAABBSAACwUQAAARwAAAEAAAAgUgAAwFEAAAEYAAAAAAAAMFIAANBRAAABGAAAAQAAAEBSAADgUQAAARYAAAAAAABQUgAA8FEAAAEWAAABAAAAYFIAAABSAAABFAAAAAAAAHBSAAAQUgAAARQAAAEAAACAUgAAIFIAAAESAAAAAAAAkFIAADBSAAABEgAAAQAAAKBSAABAUgAAAREAAAAAAACwUgAAUFIAAAERAAABAAAAwFIAAGBSAADBCgAAAAAAANBSAABwUgAAwQoAAAEAAADgUgAAgFIAAMEJAAAAAAAA8FIAAJBSAADBCQAAAQAAAABTAACgUgAAoQgAAAAAAAAQUwAAsFIAAKEIAAABAAAAIFMAAMBSAAAhBQAAAAAAADBTAADQUgAAIQUAAAEAAABAUwAA4FIAAEEEAAAAAAAAUFMAAPBSAABBBAAAAQAAAGBTAAAAUwAAoQIAAAAAAABwUwAAEFMAAKECAAABAAAAgFMAACBTAAAhAgAAAAAAAJBTAAAwUwAAIQIAAAEAAACgUwAAQFMAAEEBAAAAAAAAsFMAAFBTAABBAQAAAQAAAMBTAABgUwAAEQEAAAAAAADQUwAAcFMAABEBAAABAAAA4FMAAIBTAACFAAAAAAAAAPBTAACQUwAAhQAAAAEAAAAAVAAAoFMAAEkAAAAAAAAAEFQAALBTAABJAAAAAQAAACBUAADAUwAAJQAAAAAAAAAwVAAA0FMAACUAAAABAAAAQFQAAOBTAAAVAAAAAAAAAFBUAADwUwAAFQAAAAEAAABgVAAAAFQAAAkAAAAAAAAAcFQAABBUAAAJAAAAAQAAAIBUAAAgVAAABQAAAAAAAACQVAAAMFQAAAUAAAABAAAAoFQAAEBUAAABAAAAAAAAAJBUAABQVAAAAQAAAAEAAACgVAAAYFQAAAFWAAAAAAAAsFQAALBUAAABVgAAAQAAAMBUAADAVAAAAAEDAwECAwMFBgcHBgYHBwABAwMBAgMDBQYHBwYGBwcFBgcHBgYHBwgICAgICAgIBQYHBwYGBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAECAwMCAgMDBgYHBwYGBwcBAgMDAgIDAwYGBwcGBgcHBgYHBwYGBwcICAgICAgICAYGBwcGBgcHCAgICAgICAgCAgMDAgIDAwYGBwcGBgcHAgIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgAAQUGAQIGBgMDBwcDAwcHAAEFBgECBgYDAwcHAwMHBwMDBwcDAwcHBAQHBwQEBwcDAwcHAwMHBwQEBwcEBAcHAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwUGCAgGBggIBwcICAcHCAgFBggIBgYICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIAQIGBgICBgYDAwcHAwMHBwECBgYCAgYGAwMHBwMDBwcDAwcHAwMHBwQEBwcEBAcHAwMHBwMDBwcEBAcHBAQHBwICBgYCAgYGAwMHBwMDBwcCAgYGAgIGBgMDBwcDAwcHAwMHBwMDBwcEBAcHBAQHBwMDBwcDAwcHBAQHBwQEBwcGBggIBgYICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBgYICAYGCAgHBwgIBwcICAYGCAgGBggIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAcHCAgHBwgIBwcICAABAwMBAgMDBQYHBwYGBwcAAQMDAQIDAwUGBwcGBgcHBQYHBwYGBwcICAgICAgICAUGBwcGBgcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAwMEBAMDBAQHBwcHBwcHBwMDBAQDAwQEBwcHBwcHBwcHBwcHBwcHBwgICAgICAgIBwcHBwcHBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgBAgMDAgIDAwYGBwcGBgcHAQIDAwICAwMGBgcHBgYHBwYGBwcGBgcHCAgICAgICAgGBgcHBgYHBwgICAgICAgIAgIDAwICAwMGBgcHBgYHBwICAwMCAgMDBgYHBwYGBwcGBgcHBgYHBwgICAgICAgIBgYHBwYGBwcICAgICAgICAMDBAQDAwQEBwcHBwcHBwcDAwQEAwMEBAcHBwcHBwcHBwcHBwcHBwcICAgICAgICAcHBwcHBwcHCAgICAgICAgDAwQEAwMEBAcHBwcHBwcHAwMEBAMDBAQHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgHBwcHBwcHBwgICAgICAgIAAMBBAMGBAcBBAIFBAcFBwADAQQDBgQHAQQCBQQHBQcBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgBBAIFBAcFBwIFAgUFBwUHAQQCBQQHBQcCBQIFBQcFBwIFAgUFBwUHAgUCBQUHBQcCBQIFBQcFBwIFAgUFBwUHBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAMGBAcGCAcIBAcFBwcIBwgDBgQHBggHCAQHBQcHCAcIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgGCAcICAgICAcIBwgICAgIBggHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBAcFBwcIBwgFBwUHBwgHCAQHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAUHBQcHCAcIBQcFBwcIBwgFBwUHBwgHCAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgHCAcICAgICAcIBwgICAgIBwgHCAgICAgJCQoKCQkKCgwMDQsMDA0LCQkKCgkJCgoMDAsNDAwLDQwMDQ0MDAsLDAkNCgkMCgsMDAsLDAwNDQwJCwoJDAoNCQkKCgkJCgoMDA0LDAwNCwkJCgoJCQoKDAwLDQwMCw0MDA0NDAwLCwwJDQoJDAoLDAwLCwwMDQ0MCQsKCQwKDQoKCgoKCgoKDQsNCw0LDQsKCgkJCgoJCQ0LDAwNCwwMDQ0NDQsLCwsNCg0KCgsKCw0NDAwLCwwMDQoMCQoLCQwKCgkJCgoJCQsNDAwLDQwMCgoKCgoKCgoLDQsNCw0LDQsLDAwNDQwMCwoMCQoNCQwLCwsLDQ0NDQsKCwoKDQoNAEHZuwELNwEAAQABAAEAAAEBAAABAQABAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAQABAQEAQZm8AQs3AQABAAEAAQAAAQEAAAEBAAEAAQABAAEAAAAAAQEBAQAAAAAAAQABAAAAAAEBAQEAAAABAAEBAQBB2bwBCwcBAAEAAQABAEHpvAELlQIBAAEAAQABAAAAAAEBAQEAAAAAAAEAAQAAAAABAQEBAAAAAAABAAEBAQAAAQEAAAABAAEAAQABAQEBAQEBAQEAAQABAAEAAQAAAAABAQEBAAEAAAEBAAEAAAAAAQEBAQABAAEBAQEBAgAAAAQAAAAEAAAACAAAAJD/AAAMAAAAGAAAAFL/AAAUAAAAGQAAAFP/AAAUAAAAGgAAAF7/AAAUAAAAGwAAAFz/AAAUAAAAHAAAAF3/AAAUAAAAHQAAAF//AAAUAAAAHgAAAFH/AAACAAAAHwAAAFX/AAAEAAAAIAAAAFf/AAAEAAAAIQAAAFj/AAAQAAAAIgAAAGD/AAAEAAAAIwAAAGH/AAAQAAAAJAAAAJH/AEGIvwELZWP/AAAEAAAAJQAAAGT/AAAUAAAAJgAAAHT/AAAUAAAAJwAAAHj/AAAEAAAAKAAAAFD/AAAEAAAAKQAAAFn/AAAEAAAAKgAAAHX/AAAUAAAAKwAAAHf/AAAUAAAALAAAAAAAAAAUAEGAwAELNS0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAAICBQajYAAABweXRmNwAAAGgycGo4AEHAwAELMnJkaGk5AAAAcmxvYzoAAABjY3BiOwAAAHJsY3A8AAAAcGFtYz0AAABmZWRjPgAAAPhiAEGAwQELQRkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHRwQELIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBi8IBCwEMAEGXwgELFRMAAAAAEwAAAAAJDAAAAAAADAAADABBxcIBCwEQAEHRwgELFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABB/8IBCwESAEGLwwELHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBBwsMBCw4aAAAAGhoaAAAAAAAACQBB88MBCwEUAEH/wwELFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBrcQBCwEWAEG5xAELJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBB4MQBCwmQbAEAAAAAAAUAQfTEAQsBaQBBjMUBCwpqAAAAawAAAHhoAEGkxQELAQIAQbTFAQsI//////////8AQfjFAQsBBQBBhMYBCwFsAEGcxgELDmoAAABtAAAAiGgAAAAEAEG0xgELAQEAQcTGAQsF/////wo=");
      return receiveInstance(instantiateSync(u2, e3)[0]);
    }();
    G2.q, a2._malloc = G2.r, a2._free = G2.s, a2._jp2_decode = G2.u;
    w2 = function runCaller() {
      D2 || run();
      D2 || (w2 = runCaller);
    };
    function run() {
      if (!(m2 > 0)) {
        !function preRun() {
          if (a2.preRun) {
            "function" == typeof a2.preRun && (a2.preRun = [
              a2.preRun
            ]);
            for (; a2.preRun.length; ) e3 = a2.preRun.shift(), d2.unshift(e3);
          }
          var e3;
          callRuntimeCallbacks(d2);
        }();
        if (!(m2 > 0)) if (a2.setStatus) {
          a2.setStatus("Running...");
          setTimeout(function() {
            setTimeout(function() {
              a2.setStatus("");
            }, 1);
            doRun();
          }, 1);
        } else doRun();
      }
      function doRun() {
        if (!D2) {
          D2 = true;
          a2.calledRun = true;
          !function initRuntime() {
            callRuntimeCallbacks(f2);
          }();
          t2(a2);
          a2.onRuntimeInitialized && a2.onRuntimeInitialized();
          !function postRun() {
            if (a2.postRun) {
              "function" == typeof a2.postRun && (a2.postRun = [
                a2.postRun
              ]);
              for (; a2.postRun.length; ) e3 = a2.postRun.shift(), p2.unshift(e3);
            }
            var e3;
            callRuntimeCallbacks(p2);
          }();
        }
      }
    }
    if (a2.preInit) {
      "function" == typeof a2.preInit && (a2.preInit = [
        a2.preInit
      ]);
      for (; a2.preInit.length > 0; ) a2.preInit.pop()();
    }
    run();
    return a2;
  });
  const li = hi;
  class JpxError extends It {
    constructor(e2) {
      super(e2, "JpxError");
    }
  }
  class JpxImage {
    static decode(e2, t2) {
      t2 || (t2 = {});
      __privateGet(this, _w) || __privateSet(this, _w, li({
        warn
      }));
      const i2 = __privateGet(this, _w).decode(e2, t2);
      if ("string" == typeof i2) throw new JpxError(i2);
      return i2;
    }
    static cleanup() {
      __privateSet(this, _w, null);
    }
    static parseImageProperties(e2) {
      let t2 = e2.getByte();
      for (; t2 >= 0; ) {
        const i2 = t2;
        t2 = e2.getByte();
        if (65361 === (i2 << 8 | t2)) {
          e2.skip(4);
          const t3 = e2.getInt32() >>> 0, i3 = e2.getInt32() >>> 0, a2 = e2.getInt32() >>> 0, r2 = e2.getInt32() >>> 0;
          e2.skip(16);
          return {
            width: t3 - a2,
            height: i3 - r2,
            bitsPerComponent: 8,
            componentsCount: e2.getUint16()
          };
        }
      }
      throw new JpxError("No size marker found in JPX stream");
    }
  }
  _w = new WeakMap();
  __privateAdd(JpxImage, _w, null);
  class JpxStream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      this.stream = e2;
      this.dict = e2.dict;
      this.maybeLength = t2;
      this.params = i2;
    }
    get bytes() {
      return shadow(this, "bytes", this.stream.getBytes(this.maybeLength));
    }
    ensureBuffer(e2) {
    }
    readBlock(e2) {
      this.decodeImage(null, e2);
    }
    decodeImage(e2, t2) {
      if (this.eof) return this.buffer;
      e2 || (e2 = this.bytes);
      this.buffer = JpxImage.decode(e2, t2);
      this.bufferLength = this.buffer.length;
      this.eof = true;
      return this.buffer;
    }
    get canAsyncDecodeImageFromBuffer() {
      return this.stream.isAsync;
    }
  }
  class LZWStream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      this.str = e2;
      this.dict = e2.dict;
      this.cachedData = 0;
      this.bitsCached = 0;
      const a2 = 4096, r2 = {
        earlyChange: i2,
        codeLength: 9,
        nextCode: 258,
        dictionaryValues: new Uint8Array(a2),
        dictionaryLengths: new Uint16Array(a2),
        dictionaryPrevCodes: new Uint16Array(a2),
        currentSequence: new Uint8Array(a2),
        currentSequenceLength: 0
      };
      for (let e3 = 0; e3 < 256; ++e3) {
        r2.dictionaryValues[e3] = e3;
        r2.dictionaryLengths[e3] = 1;
      }
      this.lzwState = r2;
    }
    readBits(e2) {
      let t2 = this.bitsCached, i2 = this.cachedData;
      for (; t2 < e2; ) {
        const e3 = this.str.getByte();
        if (-1 === e3) {
          this.eof = true;
          return null;
        }
        i2 = i2 << 8 | e3;
        t2 += 8;
      }
      this.bitsCached = t2 -= e2;
      this.cachedData = i2;
      this.lastCode = null;
      return i2 >>> t2 & (1 << e2) - 1;
    }
    readBlock() {
      let e2, t2, i2, a2 = 1024;
      const r2 = this.lzwState;
      if (!r2) return;
      const s2 = r2.earlyChange;
      let n2 = r2.nextCode;
      const o2 = r2.dictionaryValues, g2 = r2.dictionaryLengths, c2 = r2.dictionaryPrevCodes;
      let C2 = r2.codeLength, h2 = r2.prevCode;
      const l2 = r2.currentSequence;
      let Q2 = r2.currentSequenceLength, E2 = 0, u2 = this.bufferLength, d2 = this.ensureBuffer(this.bufferLength + a2);
      for (e2 = 0; e2 < 512; e2++) {
        const e3 = this.readBits(C2), r3 = Q2 > 0;
        if (e3 < 256) {
          l2[0] = e3;
          Q2 = 1;
        } else {
          if (!(e3 >= 258)) {
            if (256 === e3) {
              C2 = 9;
              n2 = 258;
              Q2 = 0;
              continue;
            }
            this.eof = true;
            delete this.lzwState;
            break;
          }
          if (e3 < n2) {
            Q2 = g2[e3];
            for (t2 = Q2 - 1, i2 = e3; t2 >= 0; t2--) {
              l2[t2] = o2[i2];
              i2 = c2[i2];
            }
          } else l2[Q2++] = l2[0];
        }
        if (r3) {
          c2[n2] = h2;
          g2[n2] = g2[h2] + 1;
          o2[n2] = l2[0];
          n2++;
          C2 = n2 + s2 & n2 + s2 - 1 ? C2 : 0 | Math.min(Math.log(n2 + s2) / 0.6931471805599453 + 1, 12);
        }
        h2 = e3;
        E2 += Q2;
        if (a2 < E2) {
          do {
            a2 += 512;
          } while (a2 < E2);
          d2 = this.ensureBuffer(this.bufferLength + a2);
        }
        for (t2 = 0; t2 < Q2; t2++) d2[u2++] = l2[t2];
      }
      r2.nextCode = n2;
      r2.codeLength = C2;
      r2.prevCode = h2;
      r2.currentSequenceLength = Q2;
      this.bufferLength = u2;
    }
  }
  class PredictorStream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      if (!(i2 instanceof Dict)) return e2;
      const a2 = this.predictor = i2.get("Predictor") || 1;
      if (a2 <= 1) return e2;
      if (2 !== a2 && (a2 < 10 || a2 > 15)) throw new FormatError(`Unsupported predictor: ${a2}`);
      this.readBlock = 2 === a2 ? this.readBlockTiff : this.readBlockPng;
      this.str = e2;
      this.dict = e2.dict;
      const r2 = this.colors = i2.get("Colors") || 1, s2 = this.bits = i2.get("BPC", "BitsPerComponent") || 8, n2 = this.columns = i2.get("Columns") || 1;
      this.pixBytes = r2 * s2 + 7 >> 3;
      this.rowBytes = n2 * r2 * s2 + 7 >> 3;
      return this;
    }
    readBlockTiff() {
      const e2 = this.rowBytes, t2 = this.bufferLength, i2 = this.ensureBuffer(t2 + e2), a2 = this.bits, r2 = this.colors, s2 = this.str.getBytes(e2);
      this.eof = !s2.length;
      if (this.eof) return;
      let n2, o2 = 0, g2 = 0, c2 = 0, C2 = 0, h2 = t2;
      if (1 === a2 && 1 === r2) for (n2 = 0; n2 < e2; ++n2) {
        let e3 = s2[n2] ^ o2;
        e3 ^= e3 >> 1;
        e3 ^= e3 >> 2;
        e3 ^= e3 >> 4;
        o2 = (1 & e3) << 7;
        i2[h2++] = e3;
      }
      else if (8 === a2) {
        for (n2 = 0; n2 < r2; ++n2) i2[h2++] = s2[n2];
        for (; n2 < e2; ++n2) {
          i2[h2] = i2[h2 - r2] + s2[n2];
          h2++;
        }
      } else if (16 === a2) {
        const t3 = 2 * r2;
        for (n2 = 0; n2 < t3; ++n2) i2[h2++] = s2[n2];
        for (; n2 < e2; n2 += 2) {
          const e3 = ((255 & s2[n2]) << 8) + (255 & s2[n2 + 1]) + ((255 & i2[h2 - t3]) << 8) + (255 & i2[h2 - t3 + 1]);
          i2[h2++] = e3 >> 8 & 255;
          i2[h2++] = 255 & e3;
        }
      } else {
        const e3 = new Uint8Array(r2 + 1), h3 = (1 << a2) - 1;
        let l2 = 0, Q2 = t2;
        const E2 = this.columns;
        for (n2 = 0; n2 < E2; ++n2) for (let t3 = 0; t3 < r2; ++t3) {
          if (c2 < a2) {
            o2 = o2 << 8 | 255 & s2[l2++];
            c2 += 8;
          }
          e3[t3] = e3[t3] + (o2 >> c2 - a2) & h3;
          c2 -= a2;
          g2 = g2 << a2 | e3[t3];
          C2 += a2;
          if (C2 >= 8) {
            i2[Q2++] = g2 >> C2 - 8 & 255;
            C2 -= 8;
          }
        }
        C2 > 0 && (i2[Q2++] = (g2 << 8 - C2) + (o2 & (1 << 8 - C2) - 1));
      }
      this.bufferLength += e2;
    }
    readBlockPng() {
      const e2 = this.rowBytes, t2 = this.pixBytes, i2 = this.str.getByte(), a2 = this.str.getBytes(e2);
      this.eof = !a2.length;
      if (this.eof) return;
      const r2 = this.bufferLength, s2 = this.ensureBuffer(r2 + e2);
      let n2 = s2.subarray(r2 - e2, r2);
      0 === n2.length && (n2 = new Uint8Array(e2));
      let o2, g2, c2, C2 = r2;
      switch (i2) {
        case 0:
          for (o2 = 0; o2 < e2; ++o2) s2[C2++] = a2[o2];
          break;
        case 1:
          for (o2 = 0; o2 < t2; ++o2) s2[C2++] = a2[o2];
          for (; o2 < e2; ++o2) {
            s2[C2] = s2[C2 - t2] + a2[o2] & 255;
            C2++;
          }
          break;
        case 2:
          for (o2 = 0; o2 < e2; ++o2) s2[C2++] = n2[o2] + a2[o2] & 255;
          break;
        case 3:
          for (o2 = 0; o2 < t2; ++o2) s2[C2++] = (n2[o2] >> 1) + a2[o2];
          for (; o2 < e2; ++o2) {
            s2[C2] = (n2[o2] + s2[C2 - t2] >> 1) + a2[o2] & 255;
            C2++;
          }
          break;
        case 4:
          for (o2 = 0; o2 < t2; ++o2) {
            g2 = n2[o2];
            c2 = a2[o2];
            s2[C2++] = g2 + c2;
          }
          for (; o2 < e2; ++o2) {
            g2 = n2[o2];
            const e3 = n2[o2 - t2], i3 = s2[C2 - t2], r3 = i3 + g2 - e3;
            let h2 = r3 - i3;
            h2 < 0 && (h2 = -h2);
            let l2 = r3 - g2;
            l2 < 0 && (l2 = -l2);
            let Q2 = r3 - e3;
            Q2 < 0 && (Q2 = -Q2);
            c2 = a2[o2];
            s2[C2++] = h2 <= l2 && h2 <= Q2 ? i3 + c2 : l2 <= Q2 ? g2 + c2 : e3 + c2;
          }
          break;
        default:
          throw new FormatError(`Unsupported predictor: ${i2}`);
      }
      this.bufferLength += e2;
    }
  }
  class RunLengthStream extends DecodeStream {
    constructor(e2, t2) {
      super(t2);
      this.str = e2;
      this.dict = e2.dict;
    }
    readBlock() {
      const e2 = this.str.getBytes(2);
      if (!e2 || e2.length < 2 || 128 === e2[0]) {
        this.eof = true;
        return;
      }
      let t2, i2 = this.bufferLength, a2 = e2[0];
      if (a2 < 128) {
        t2 = this.ensureBuffer(i2 + a2 + 1);
        t2[i2++] = e2[1];
        if (a2 > 0) {
          const e3 = this.str.getBytes(a2);
          t2.set(e3, i2);
          i2 += a2;
        }
      } else {
        a2 = 257 - a2;
        const r2 = e2[1];
        t2 = this.ensureBuffer(i2 + a2 + 1);
        for (let e3 = 0; e3 < a2; e3++) t2[i2++] = r2;
      }
      this.bufferLength = i2;
    }
  }
  class Parser {
    constructor({ lexer: e2, xref: t2, allowStreams: i2 = false, recoveryMode: a2 = false }) {
      __privateAdd(this, _Parser_instances);
      this.lexer = e2;
      this.xref = t2;
      this.allowStreams = i2;
      this.recoveryMode = a2;
      this.imageCache = /* @__PURE__ */ Object.create(null);
      this._imageId = 0;
      this.refill();
    }
    refill() {
      this.buf1 = this.lexer.getObj();
      this.buf2 = this.lexer.getObj();
    }
    shift() {
      if (this.buf2 instanceof Cmd && "ID" === this.buf2.cmd) {
        this.buf1 = this.buf2;
        this.buf2 = null;
      } else {
        this.buf1 = this.buf2;
        this.buf2 = this.lexer.getObj();
      }
    }
    tryShift() {
      try {
        this.shift();
        return true;
      } catch (e2) {
        if (e2 instanceof MissingDataException) throw e2;
        return false;
      }
    }
    getObj(e2 = null) {
      const t2 = this.buf1;
      this.shift();
      if (t2 instanceof Cmd) switch (t2.cmd) {
        case "BI":
          return this.makeInlineImage(e2);
        case "[":
          const i2 = [];
          for (; !isCmd(this.buf1, "]") && this.buf1 !== bt; ) i2.push(this.getObj(e2));
          if (this.buf1 === bt) {
            if (this.recoveryMode) return i2;
            throw new ParserEOFException("End of file inside array.");
          }
          this.shift();
          return i2;
        case "<<":
          const a2 = new Dict(this.xref);
          for (; !isCmd(this.buf1, ">>") && this.buf1 !== bt; ) {
            if (!(this.buf1 instanceof Name)) {
              info("Malformed dictionary: key must be a name object");
              this.shift();
              continue;
            }
            const t3 = this.buf1.name;
            this.shift();
            if (this.buf1 === bt) break;
            a2.set(t3, this.getObj(e2));
          }
          if (this.buf1 === bt) {
            if (this.recoveryMode) return a2;
            throw new ParserEOFException("End of file inside dictionary.");
          }
          if (isCmd(this.buf2, "stream")) return this.allowStreams ? this.makeStream(a2, e2) : a2;
          this.shift();
          return a2;
        default:
          return t2;
      }
      if (Number.isInteger(t2)) {
        if (Number.isInteger(this.buf1) && isCmd(this.buf2, "R")) {
          const e3 = Ref.get(t2, this.buf1);
          this.shift();
          this.shift();
          return e3;
        }
        return t2;
      }
      return "string" == typeof t2 && e2 ? e2.decryptString(t2) : t2;
    }
    findDefaultInlineStreamEnd(e2) {
      const { knownCommands: t2 } = this.lexer, i2 = e2.pos;
      let a2, r2, s2 = 0;
      for (; -1 !== (a2 = e2.getByte()); ) if (0 === s2) s2 = 69 === a2 ? 1 : 0;
      else if (1 === s2) s2 = 73 === a2 ? 2 : 0;
      else if (32 === a2 || 10 === a2 || 13 === a2) {
        r2 = e2.pos;
        const i3 = e2.peekBytes(15), n3 = i3.length;
        if (0 === n3) break;
        for (let e3 = 0; e3 < n3; e3++) {
          a2 = i3[e3];
          if ((0 !== a2 || 0 === i3[e3 + 1]) && (10 !== a2 && 13 !== a2 && (a2 < 32 || a2 > 127))) {
            s2 = 0;
            break;
          }
        }
        if (2 !== s2) continue;
        if (!t2) {
          warn("findDefaultInlineStreamEnd - `lexer.knownCommands` is undefined.");
          continue;
        }
        const o2 = new Lexer(new Stream(i3.slice()), t2);
        o2._hexStringWarn = () => {
        };
        let g2 = 0;
        for (; ; ) {
          const e3 = o2.getObj();
          if (e3 === bt) {
            s2 = 0;
            break;
          }
          if (e3 instanceof Cmd) {
            const i4 = t2[e3.cmd];
            if (!i4) {
              s2 = 0;
              break;
            }
            if (i4.variableArgs ? g2 <= i4.numArgs : g2 === i4.numArgs) break;
            g2 = 0;
          } else g2++;
        }
        if (2 === s2) break;
      } else s2 = 0;
      if (-1 === a2) {
        warn("findDefaultInlineStreamEnd: Reached the end of the stream without finding a valid EI marker");
        if (r2) {
          warn('... trying to recover by using the last "EI" occurrence.');
          e2.skip(-(e2.pos - r2));
        }
      }
      let n2 = 4;
      e2.skip(-n2);
      a2 = e2.peekByte();
      e2.skip(n2);
      isWhiteSpace(a2) || n2--;
      return e2.pos - n2 - i2;
    }
    findDCTDecodeInlineStreamEnd(e2) {
      const t2 = e2.pos;
      let i2, a2, r2 = false;
      for (; -1 !== (i2 = e2.getByte()); ) if (255 === i2) {
        switch (e2.getByte()) {
          case 0:
            break;
          case 255:
            e2.skip(-1);
            break;
          case 217:
            r2 = true;
            break;
          case 192:
          case 193:
          case 194:
          case 195:
          case 197:
          case 198:
          case 199:
          case 201:
          case 202:
          case 203:
          case 205:
          case 206:
          case 207:
          case 196:
          case 204:
          case 218:
          case 219:
          case 220:
          case 221:
          case 222:
          case 223:
          case 224:
          case 225:
          case 226:
          case 227:
          case 228:
          case 229:
          case 230:
          case 231:
          case 232:
          case 233:
          case 234:
          case 235:
          case 236:
          case 237:
          case 238:
          case 239:
          case 254:
            a2 = e2.getUint16();
            a2 > 2 ? e2.skip(a2 - 2) : e2.skip(-2);
        }
        if (r2) break;
      }
      const s2 = e2.pos - t2;
      if (-1 === i2) {
        warn("Inline DCTDecode image stream: EOI marker not found, searching for /EI/ instead.");
        e2.skip(-s2);
        return this.findDefaultInlineStreamEnd(e2);
      }
      this.inlineStreamSkipEI(e2);
      return s2;
    }
    findASCII85DecodeInlineStreamEnd(e2) {
      const t2 = e2.pos;
      let i2;
      for (; -1 !== (i2 = e2.getByte()); ) if (126 === i2) {
        const t3 = e2.pos;
        i2 = e2.peekByte();
        for (; isWhiteSpace(i2); ) {
          e2.skip();
          i2 = e2.peekByte();
        }
        if (62 === i2) {
          e2.skip();
          break;
        }
        if (e2.pos > t3) {
          const t4 = e2.peekBytes(2);
          if (69 === t4[0] && 73 === t4[1]) break;
        }
      }
      const a2 = e2.pos - t2;
      if (-1 === i2) {
        warn("Inline ASCII85Decode image stream: EOD marker not found, searching for /EI/ instead.");
        e2.skip(-a2);
        return this.findDefaultInlineStreamEnd(e2);
      }
      this.inlineStreamSkipEI(e2);
      return a2;
    }
    findASCIIHexDecodeInlineStreamEnd(e2) {
      const t2 = e2.pos;
      let i2;
      for (; -1 !== (i2 = e2.getByte()) && 62 !== i2; ) ;
      const a2 = e2.pos - t2;
      if (-1 === i2) {
        warn("Inline ASCIIHexDecode image stream: EOD marker not found, searching for /EI/ instead.");
        e2.skip(-a2);
        return this.findDefaultInlineStreamEnd(e2);
      }
      this.inlineStreamSkipEI(e2);
      return a2;
    }
    inlineStreamSkipEI(e2) {
      let t2, i2 = 0;
      for (; -1 !== (t2 = e2.getByte()); ) if (0 === i2) i2 = 69 === t2 ? 1 : 0;
      else if (1 === i2) i2 = 73 === t2 ? 2 : 0;
      else if (2 === i2) break;
    }
    makeInlineImage(e2) {
      const t2 = this.lexer, i2 = t2.stream, a2 = /* @__PURE__ */ Object.create(null);
      let r2;
      for (; !isCmd(this.buf1, "ID") && this.buf1 !== bt; ) {
        if (!(this.buf1 instanceof Name)) throw new FormatError("Dictionary key must be a name object");
        const t3 = this.buf1.name;
        this.shift();
        if (this.buf1 === bt) break;
        a2[t3] = this.getObj(e2);
      }
      -1 !== t2.beginInlineImagePos && (r2 = i2.pos - t2.beginInlineImagePos);
      const s2 = this.xref.fetchIfRef(a2.F || a2.Filter);
      let n2;
      if (s2 instanceof Name) n2 = s2.name;
      else if (Array.isArray(s2)) {
        const e3 = this.xref.fetchIfRef(s2[0]);
        e3 instanceof Name && (n2 = e3.name);
      }
      const o2 = i2.pos;
      let g2, c2;
      switch (n2) {
        case "DCT":
        case "DCTDecode":
          g2 = this.findDCTDecodeInlineStreamEnd(i2);
          break;
        case "A85":
        case "ASCII85Decode":
          g2 = this.findASCII85DecodeInlineStreamEnd(i2);
          break;
        case "AHx":
        case "ASCIIHexDecode":
          g2 = this.findASCIIHexDecodeInlineStreamEnd(i2);
          break;
        default:
          g2 = this.findDefaultInlineStreamEnd(i2);
      }
      if (g2 < 1e3 && r2 > 0) {
        const e3 = i2.pos;
        i2.pos = t2.beginInlineImagePos;
        c2 = function getInlineImageCacheKey(e4) {
          const t3 = [], i3 = e4.length;
          let a4 = 0;
          for (; a4 < i3 - 1; ) t3.push(e4[a4++] << 8 | e4[a4++]);
          a4 < i3 && t3.push(e4[a4]);
          return i3 + "_" + String.fromCharCode.apply(null, t3);
        }(i2.getBytes(r2 + g2));
        i2.pos = e3;
        const a3 = this.imageCache[c2];
        if (void 0 !== a3) {
          this.buf2 = Cmd.get("EI");
          this.shift();
          a3.reset();
          return a3;
        }
      }
      const C2 = new Dict(this.xref);
      for (const e3 in a2) C2.set(e3, a2[e3]);
      let h2 = i2.makeSubStream(o2, g2, C2);
      e2 && (h2 = e2.createStream(h2, g2));
      h2 = this.filter(h2, C2, g2);
      h2.dict = C2;
      if (void 0 !== c2) {
        h2.cacheKey = "inline_img_" + ++this._imageId;
        this.imageCache[c2] = h2;
      }
      this.buf2 = Cmd.get("EI");
      this.shift();
      return h2;
    }
    makeStream(e2, t2) {
      const i2 = this.lexer;
      let a2 = i2.stream;
      i2.skipToNextLine();
      const r2 = a2.pos - 1;
      let s2 = e2.get("Length");
      if (!Number.isInteger(s2)) {
        info(`Bad length "${s2 && s2.toString()}" in stream.`);
        s2 = 0;
      }
      a2.pos = r2 + s2;
      i2.nextChar();
      if (this.tryShift() && isCmd(this.buf2, "endstream")) this.shift();
      else {
        s2 = __privateMethod(this, _Parser_instances, b_fn).call(this, r2);
        if (s2 < 0) throw new FormatError("Missing endstream command.");
        i2.nextChar();
        this.shift();
        this.shift();
      }
      this.shift();
      a2 = a2.makeSubStream(r2, s2, e2);
      t2 && (a2 = t2.createStream(a2, s2));
      a2 = this.filter(a2, e2, s2);
      a2.dict = e2;
      return a2;
    }
    filter(e2, t2, i2) {
      let a2 = t2.get("F", "Filter"), r2 = t2.get("DP", "DecodeParms");
      if (a2 instanceof Name) {
        Array.isArray(r2) && warn("/DecodeParms should not be an Array, when /Filter is a Name.");
        return this.makeFilter(e2, a2.name, i2, r2);
      }
      let s2 = i2;
      if (Array.isArray(a2)) {
        const t3 = a2, i3 = r2;
        for (let n2 = 0, o2 = t3.length; n2 < o2; ++n2) {
          a2 = this.xref.fetchIfRef(t3[n2]);
          if (!(a2 instanceof Name)) throw new FormatError(`Bad filter name "${a2}"`);
          r2 = null;
          Array.isArray(i3) && n2 in i3 && (r2 = this.xref.fetchIfRef(i3[n2]));
          e2 = this.makeFilter(e2, a2.name, s2, r2);
          s2 = null;
        }
      }
      return e2;
    }
    makeFilter(e2, t2, i2, a2) {
      if (0 === i2) {
        warn(`Empty "${t2}" stream.`);
        return new NullStream();
      }
      try {
        switch (t2) {
          case "Fl":
          case "FlateDecode":
            return a2 ? new PredictorStream(new FlateStream(e2, i2), i2, a2) : new FlateStream(e2, i2);
          case "LZW":
          case "LZWDecode":
            let t3 = 1;
            if (a2) {
              a2.has("EarlyChange") && (t3 = a2.get("EarlyChange"));
              return new PredictorStream(new LZWStream(e2, i2, t3), i2, a2);
            }
            return new LZWStream(e2, i2, t3);
          case "DCT":
          case "DCTDecode":
            return new JpegStream(e2, i2, a2);
          case "JPX":
          case "JPXDecode":
            return new JpxStream(e2, i2, a2);
          case "A85":
          case "ASCII85Decode":
            return new Ascii85Stream(e2, i2);
          case "AHx":
          case "ASCIIHexDecode":
            return new AsciiHexStream(e2, i2);
          case "CCF":
          case "CCITTFaxDecode":
            return new CCITTFaxStream(e2, i2, a2);
          case "RL":
          case "RunLengthDecode":
            return new RunLengthStream(e2, i2);
          case "JBIG2Decode":
            return new Jbig2Stream(e2, i2, a2);
        }
        warn(`Filter "${t2}" is not supported.`);
        return e2;
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(`Invalid stream: "${e3}"`);
        return new NullStream();
      }
    }
  }
  _Parser_instances = new WeakSet();
  b_fn = function(e2) {
    const { stream: t2 } = this.lexer;
    t2.pos = e2;
    const i2 = new Uint8Array([
      101,
      110,
      100
    ]), a2 = i2.length, r2 = [
      new Uint8Array([
        115,
        116,
        114,
        101,
        97,
        109
      ]),
      new Uint8Array([
        115,
        116,
        101,
        97,
        109
      ]),
      new Uint8Array([
        115,
        116,
        114,
        101,
        97
      ])
    ], s2 = 9 - a2;
    for (; t2.pos < t2.end; ) {
      const n2 = t2.peekBytes(2048), o2 = n2.length - 9;
      if (o2 <= 0) break;
      let g2 = 0;
      for (; g2 < o2; ) {
        let o3 = 0;
        for (; o3 < a2 && n2[g2 + o3] === i2[o3]; ) o3++;
        if (o3 >= a2) {
          let a3 = false;
          for (const e3 of r2) {
            const t3 = e3.length;
            let r3 = 0;
            for (; r3 < t3 && n2[g2 + o3 + r3] === e3[r3]; ) r3++;
            if (r3 >= s2) {
              a3 = true;
              break;
            }
            if (r3 >= t3) {
              if (isWhiteSpace(n2[g2 + o3 + r3])) {
                info(`Found "${bytesToString([
                  ...i2,
                  ...e3
                ])}" when searching for endstream command.`);
                a3 = true;
              }
              break;
            }
          }
          if (a3) {
            t2.pos += g2;
            return t2.pos - e2;
          }
        }
        g2++;
      }
      t2.pos += o2;
    }
    return -1;
  };
  const Bi = [
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    2,
    2,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    0,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function toHexDigit(e2) {
    return e2 >= 48 && e2 <= 57 ? 15 & e2 : e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102 ? 9 + (15 & e2) : -1;
  }
  class Lexer {
    constructor(e2, t2 = null) {
      this.stream = e2;
      this.nextChar();
      this.strBuf = [];
      this.knownCommands = t2;
      this._hexStringNumWarn = 0;
      this.beginInlineImagePos = -1;
    }
    nextChar() {
      return this.currentChar = this.stream.getByte();
    }
    peekChar() {
      return this.stream.peekByte();
    }
    getNumber() {
      let e2 = this.currentChar, t2 = false, i2 = 0, a2 = 1;
      if (45 === e2) {
        a2 = -1;
        e2 = this.nextChar();
        45 === e2 && (e2 = this.nextChar());
      } else 43 === e2 && (e2 = this.nextChar());
      if (10 === e2 || 13 === e2) do {
        e2 = this.nextChar();
      } while (10 === e2 || 13 === e2);
      if (46 === e2) {
        i2 = 10;
        e2 = this.nextChar();
      }
      if (e2 < 48 || e2 > 57) {
        const t3 = `Invalid number: ${String.fromCharCode(e2)} (charCode ${e2})`;
        if (isWhiteSpace(e2) || -1 === e2) {
          info(`Lexer.getNumber - "${t3}".`);
          return 0;
        }
        throw new FormatError(t3);
      }
      let r2 = e2 - 48, s2 = 0, n2 = 1;
      for (; (e2 = this.nextChar()) >= 0; ) if (e2 >= 48 && e2 <= 57) {
        const a3 = e2 - 48;
        if (t2) s2 = 10 * s2 + a3;
        else {
          0 !== i2 && (i2 *= 10);
          r2 = 10 * r2 + a3;
        }
      } else if (46 === e2) {
        if (0 !== i2) break;
        i2 = 1;
      } else if (45 === e2) warn("Badly formatted number: minus sign in the middle");
      else {
        if (69 !== e2 && 101 !== e2) break;
        e2 = this.peekChar();
        if (43 === e2 || 45 === e2) {
          n2 = 45 === e2 ? -1 : 1;
          this.nextChar();
        } else if (e2 < 48 || e2 > 57) break;
        t2 = true;
      }
      0 !== i2 && (r2 /= i2);
      t2 && (r2 *= 10 ** (n2 * s2));
      return a2 * r2;
    }
    getString() {
      let e2 = 1, t2 = false;
      const i2 = this.strBuf;
      i2.length = 0;
      let a2 = this.nextChar();
      for (; ; ) {
        let r2 = false;
        switch (0 | a2) {
          case -1:
            warn("Unterminated string");
            t2 = true;
            break;
          case 40:
            ++e2;
            i2.push("(");
            break;
          case 41:
            if (0 == --e2) {
              this.nextChar();
              t2 = true;
            } else i2.push(")");
            break;
          case 92:
            a2 = this.nextChar();
            switch (a2) {
              case -1:
                warn("Unterminated string");
                t2 = true;
                break;
              case 110:
                i2.push("\n");
                break;
              case 114:
                i2.push("\r");
                break;
              case 116:
                i2.push("	");
                break;
              case 98:
                i2.push("\b");
                break;
              case 102:
                i2.push("\f");
                break;
              case 92:
              case 40:
              case 41:
                i2.push(String.fromCharCode(a2));
                break;
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
                let e3 = 15 & a2;
                a2 = this.nextChar();
                r2 = true;
                if (a2 >= 48 && a2 <= 55) {
                  e3 = (e3 << 3) + (15 & a2);
                  a2 = this.nextChar();
                  if (a2 >= 48 && a2 <= 55) {
                    r2 = false;
                    e3 = (e3 << 3) + (15 & a2);
                  }
                }
                i2.push(String.fromCharCode(e3));
                break;
              case 13:
                10 === this.peekChar() && this.nextChar();
                break;
              case 10:
                break;
              default:
                i2.push(String.fromCharCode(a2));
            }
            break;
          default:
            i2.push(String.fromCharCode(a2));
        }
        if (t2) break;
        r2 || (a2 = this.nextChar());
      }
      return i2.join("");
    }
    getName() {
      let e2, t2;
      const i2 = this.strBuf;
      i2.length = 0;
      for (; (e2 = this.nextChar()) >= 0 && !Bi[e2]; ) if (35 === e2) {
        e2 = this.nextChar();
        if (Bi[e2]) {
          warn("Lexer_getName: NUMBER SIGN (#) should be followed by a hexadecimal number.");
          i2.push("#");
          break;
        }
        const a2 = toHexDigit(e2);
        if (-1 !== a2) {
          t2 = e2;
          e2 = this.nextChar();
          const r2 = toHexDigit(e2);
          if (-1 === r2) {
            warn(`Lexer_getName: Illegal digit (${String.fromCharCode(e2)}) in hexadecimal number.`);
            i2.push("#", String.fromCharCode(t2));
            if (Bi[e2]) break;
            i2.push(String.fromCharCode(e2));
            continue;
          }
          i2.push(String.fromCharCode(a2 << 4 | r2));
        } else i2.push("#", String.fromCharCode(e2));
      } else i2.push(String.fromCharCode(e2));
      i2.length > 127 && warn(`Name token is longer than allowed by the spec: ${i2.length}`);
      return Name.get(i2.join(""));
    }
    _hexStringWarn(e2) {
      5 != this._hexStringNumWarn++ ? this._hexStringNumWarn > 5 || warn(`getHexString - ignoring invalid character: ${e2}`) : warn("getHexString - ignoring additional invalid characters.");
    }
    getHexString() {
      const e2 = this.strBuf;
      e2.length = 0;
      let t2 = this.currentChar, i2 = -1, a2 = -1;
      this._hexStringNumWarn = 0;
      for (; ; ) {
        if (t2 < 0) {
          warn("Unterminated hex string");
          break;
        }
        if (62 === t2) {
          this.nextChar();
          break;
        }
        if (1 !== Bi[t2]) {
          a2 = toHexDigit(t2);
          if (-1 === a2) this._hexStringWarn(t2);
          else if (-1 === i2) i2 = a2;
          else {
            e2.push(String.fromCharCode(i2 << 4 | a2));
            i2 = -1;
          }
          t2 = this.nextChar();
        } else t2 = this.nextChar();
      }
      -1 !== i2 && e2.push(String.fromCharCode(i2 << 4));
      return e2.join("");
    }
    getObj() {
      let e2 = false, t2 = this.currentChar;
      for (; ; ) {
        if (t2 < 0) return bt;
        if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
        else if (37 === t2) e2 = true;
        else if (1 !== Bi[t2]) break;
        t2 = this.nextChar();
      }
      switch (0 | t2) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 43:
        case 45:
        case 46:
          return this.getNumber();
        case 40:
          return this.getString();
        case 47:
          return this.getName();
        case 91:
          this.nextChar();
          return Cmd.get("[");
        case 93:
          this.nextChar();
          return Cmd.get("]");
        case 60:
          t2 = this.nextChar();
          if (60 === t2) {
            this.nextChar();
            return Cmd.get("<<");
          }
          return this.getHexString();
        case 62:
          t2 = this.nextChar();
          if (62 === t2) {
            this.nextChar();
            return Cmd.get(">>");
          }
          return Cmd.get(">");
        case 123:
          this.nextChar();
          return Cmd.get("{");
        case 125:
          this.nextChar();
          return Cmd.get("}");
        case 41:
          this.nextChar();
          throw new FormatError(`Illegal character: ${t2}`);
      }
      let i2 = String.fromCharCode(t2);
      if (t2 < 32 || t2 > 127) {
        const e3 = this.peekChar();
        if (e3 >= 32 && e3 <= 127) {
          this.nextChar();
          return Cmd.get(i2);
        }
      }
      const a2 = this.knownCommands;
      let r2 = void 0 !== (a2 == null ? void 0 : a2[i2]);
      for (; (t2 = this.nextChar()) >= 0 && !Bi[t2]; ) {
        const e3 = i2 + String.fromCharCode(t2);
        if (r2 && void 0 === a2[e3]) break;
        if (128 === i2.length) throw new FormatError(`Command token too long: ${i2.length}`);
        i2 = e3;
        r2 = void 0 !== (a2 == null ? void 0 : a2[i2]);
      }
      if ("true" === i2) return true;
      if ("false" === i2) return false;
      if ("null" === i2) return null;
      "BI" === i2 && (this.beginInlineImagePos = this.stream.pos);
      return Cmd.get(i2);
    }
    skipToNextLine() {
      let e2 = this.currentChar;
      for (; e2 >= 0; ) {
        if (13 === e2) {
          e2 = this.nextChar();
          10 === e2 && this.nextChar();
          break;
        }
        if (10 === e2) {
          this.nextChar();
          break;
        }
        e2 = this.nextChar();
      }
    }
  }
  class Linearization {
    static create(e2) {
      function getInt(e3, t3, i3 = false) {
        const a3 = e3.get(t3);
        if (Number.isInteger(a3) && (i3 ? a3 >= 0 : a3 > 0)) return a3;
        throw new Error(`The "${t3}" parameter in the linearization dictionary is invalid.`);
      }
      const t2 = new Parser({
        lexer: new Lexer(e2),
        xref: null
      }), i2 = t2.getObj(), a2 = t2.getObj(), r2 = t2.getObj(), s2 = t2.getObj();
      let n2, o2;
      if (!(Number.isInteger(i2) && Number.isInteger(a2) && isCmd(r2, "obj") && s2 instanceof Dict && "number" == typeof (n2 = s2.get("Linearized")) && n2 > 0)) return null;
      if ((o2 = getInt(s2, "L")) !== e2.length) throw new Error('The "L" parameter in the linearization dictionary does not equal the stream length.');
      return {
        length: o2,
        hints: function getHints(e3) {
          const t3 = e3.get("H");
          let i3;
          if (Array.isArray(t3) && (2 === (i3 = t3.length) || 4 === i3)) {
            for (let e4 = 0; e4 < i3; e4++) {
              const i4 = t3[e4];
              if (!(Number.isInteger(i4) && i4 > 0)) throw new Error(`Hint (${e4}) in the linearization dictionary is invalid.`);
            }
            return t3;
          }
          throw new Error("Hint array in the linearization dictionary is invalid.");
        }(s2),
        objectNumberFirst: getInt(s2, "O"),
        endFirst: getInt(s2, "E"),
        numPages: getInt(s2, "N"),
        mainXRefEntriesOffset: getInt(s2, "T"),
        pageFirst: s2.has("P") ? getInt(s2, "P", true) : 0
      };
    }
  }
  const Qi = [
    "Adobe-GB1-UCS2",
    "Adobe-CNS1-UCS2",
    "Adobe-Japan1-UCS2",
    "Adobe-Korea1-UCS2",
    "78-EUC-H",
    "78-EUC-V",
    "78-H",
    "78-RKSJ-H",
    "78-RKSJ-V",
    "78-V",
    "78ms-RKSJ-H",
    "78ms-RKSJ-V",
    "83pv-RKSJ-H",
    "90ms-RKSJ-H",
    "90ms-RKSJ-V",
    "90msp-RKSJ-H",
    "90msp-RKSJ-V",
    "90pv-RKSJ-H",
    "90pv-RKSJ-V",
    "Add-H",
    "Add-RKSJ-H",
    "Add-RKSJ-V",
    "Add-V",
    "Adobe-CNS1-0",
    "Adobe-CNS1-1",
    "Adobe-CNS1-2",
    "Adobe-CNS1-3",
    "Adobe-CNS1-4",
    "Adobe-CNS1-5",
    "Adobe-CNS1-6",
    "Adobe-GB1-0",
    "Adobe-GB1-1",
    "Adobe-GB1-2",
    "Adobe-GB1-3",
    "Adobe-GB1-4",
    "Adobe-GB1-5",
    "Adobe-Japan1-0",
    "Adobe-Japan1-1",
    "Adobe-Japan1-2",
    "Adobe-Japan1-3",
    "Adobe-Japan1-4",
    "Adobe-Japan1-5",
    "Adobe-Japan1-6",
    "Adobe-Korea1-0",
    "Adobe-Korea1-1",
    "Adobe-Korea1-2",
    "B5-H",
    "B5-V",
    "B5pc-H",
    "B5pc-V",
    "CNS-EUC-H",
    "CNS-EUC-V",
    "CNS1-H",
    "CNS1-V",
    "CNS2-H",
    "CNS2-V",
    "ETHK-B5-H",
    "ETHK-B5-V",
    "ETen-B5-H",
    "ETen-B5-V",
    "ETenms-B5-H",
    "ETenms-B5-V",
    "EUC-H",
    "EUC-V",
    "Ext-H",
    "Ext-RKSJ-H",
    "Ext-RKSJ-V",
    "Ext-V",
    "GB-EUC-H",
    "GB-EUC-V",
    "GB-H",
    "GB-V",
    "GBK-EUC-H",
    "GBK-EUC-V",
    "GBK2K-H",
    "GBK2K-V",
    "GBKp-EUC-H",
    "GBKp-EUC-V",
    "GBT-EUC-H",
    "GBT-EUC-V",
    "GBT-H",
    "GBT-V",
    "GBTpc-EUC-H",
    "GBTpc-EUC-V",
    "GBpc-EUC-H",
    "GBpc-EUC-V",
    "H",
    "HKdla-B5-H",
    "HKdla-B5-V",
    "HKdlb-B5-H",
    "HKdlb-B5-V",
    "HKgccs-B5-H",
    "HKgccs-B5-V",
    "HKm314-B5-H",
    "HKm314-B5-V",
    "HKm471-B5-H",
    "HKm471-B5-V",
    "HKscs-B5-H",
    "HKscs-B5-V",
    "Hankaku",
    "Hiragana",
    "KSC-EUC-H",
    "KSC-EUC-V",
    "KSC-H",
    "KSC-Johab-H",
    "KSC-Johab-V",
    "KSC-V",
    "KSCms-UHC-H",
    "KSCms-UHC-HW-H",
    "KSCms-UHC-HW-V",
    "KSCms-UHC-V",
    "KSCpc-EUC-H",
    "KSCpc-EUC-V",
    "Katakana",
    "NWP-H",
    "NWP-V",
    "RKSJ-H",
    "RKSJ-V",
    "Roman",
    "UniCNS-UCS2-H",
    "UniCNS-UCS2-V",
    "UniCNS-UTF16-H",
    "UniCNS-UTF16-V",
    "UniCNS-UTF32-H",
    "UniCNS-UTF32-V",
    "UniCNS-UTF8-H",
    "UniCNS-UTF8-V",
    "UniGB-UCS2-H",
    "UniGB-UCS2-V",
    "UniGB-UTF16-H",
    "UniGB-UTF16-V",
    "UniGB-UTF32-H",
    "UniGB-UTF32-V",
    "UniGB-UTF8-H",
    "UniGB-UTF8-V",
    "UniJIS-UCS2-H",
    "UniJIS-UCS2-HW-H",
    "UniJIS-UCS2-HW-V",
    "UniJIS-UCS2-V",
    "UniJIS-UTF16-H",
    "UniJIS-UTF16-V",
    "UniJIS-UTF32-H",
    "UniJIS-UTF32-V",
    "UniJIS-UTF8-H",
    "UniJIS-UTF8-V",
    "UniJIS2004-UTF16-H",
    "UniJIS2004-UTF16-V",
    "UniJIS2004-UTF32-H",
    "UniJIS2004-UTF32-V",
    "UniJIS2004-UTF8-H",
    "UniJIS2004-UTF8-V",
    "UniJISPro-UCS2-HW-V",
    "UniJISPro-UCS2-V",
    "UniJISPro-UTF8-V",
    "UniJISX0213-UTF32-H",
    "UniJISX0213-UTF32-V",
    "UniJISX02132004-UTF32-H",
    "UniJISX02132004-UTF32-V",
    "UniKS-UCS2-H",
    "UniKS-UCS2-V",
    "UniKS-UTF16-H",
    "UniKS-UTF16-V",
    "UniKS-UTF32-H",
    "UniKS-UTF32-V",
    "UniKS-UTF8-H",
    "UniKS-UTF8-V",
    "V",
    "WP-Symbol"
  ], Ei = 2 ** 24 - 1;
  class CMap {
    constructor(e2 = false) {
      this.codespaceRanges = [
        [],
        [],
        [],
        []
      ];
      this.numCodespaceRanges = 0;
      this._map = [];
      this.name = "";
      this.vertical = false;
      this.useCMap = null;
      this.builtInCMap = e2;
    }
    addCodespaceRange(e2, t2, i2) {
      this.codespaceRanges[e2 - 1].push(t2, i2);
      this.numCodespaceRanges++;
    }
    mapCidRange(e2, t2, i2) {
      if (t2 - e2 > Ei) throw new Error("mapCidRange - ignoring data above MAX_MAP_RANGE.");
      for (; e2 <= t2; ) this._map[e2++] = i2++;
    }
    mapBfRange(e2, t2, i2) {
      if (t2 - e2 > Ei) throw new Error("mapBfRange - ignoring data above MAX_MAP_RANGE.");
      const a2 = i2.length - 1;
      for (; e2 <= t2; ) {
        this._map[e2++] = i2;
        const t3 = i2.charCodeAt(a2) + 1;
        t3 > 255 ? i2 = i2.substring(0, a2 - 1) + String.fromCharCode(i2.charCodeAt(a2 - 1) + 1) + "\0" : i2 = i2.substring(0, a2) + String.fromCharCode(t3);
      }
    }
    mapBfRangeToArray(e2, t2, i2) {
      if (t2 - e2 > Ei) throw new Error("mapBfRangeToArray - ignoring data above MAX_MAP_RANGE.");
      const a2 = i2.length;
      let r2 = 0;
      for (; e2 <= t2 && r2 < a2; ) {
        this._map[e2] = i2[r2++];
        ++e2;
      }
    }
    mapOne(e2, t2) {
      this._map[e2] = t2;
    }
    lookup(e2) {
      return this._map[e2];
    }
    contains(e2) {
      return void 0 !== this._map[e2];
    }
    forEach(e2) {
      const t2 = this._map, i2 = t2.length;
      if (i2 <= 65536) for (let a2 = 0; a2 < i2; a2++) void 0 !== t2[a2] && e2(a2, t2[a2]);
      else for (const i3 in t2) e2(i3, t2[i3]);
    }
    charCodeOf(e2) {
      const t2 = this._map;
      if (t2.length <= 65536) return t2.indexOf(e2);
      for (const i2 in t2) if (t2[i2] === e2) return 0 | i2;
      return -1;
    }
    getMap() {
      return this._map;
    }
    readCharCode(e2, t2, i2) {
      let a2 = 0;
      const r2 = this.codespaceRanges;
      for (let s2 = 0, n2 = r2.length; s2 < n2; s2++) {
        a2 = (a2 << 8 | e2.charCodeAt(t2 + s2)) >>> 0;
        const n3 = r2[s2];
        for (let e3 = 0, t3 = n3.length; e3 < t3; ) {
          const t4 = n3[e3++], r3 = n3[e3++];
          if (a2 >= t4 && a2 <= r3) {
            i2.charcode = a2;
            i2.length = s2 + 1;
            return;
          }
        }
      }
      i2.charcode = 0;
      i2.length = 1;
    }
    getCharCodeLength(e2) {
      const t2 = this.codespaceRanges;
      for (let i2 = 0, a2 = t2.length; i2 < a2; i2++) {
        const a3 = t2[i2];
        for (let t3 = 0, r2 = a3.length; t3 < r2; ) {
          const r3 = a3[t3++], s2 = a3[t3++];
          if (e2 >= r3 && e2 <= s2) return i2 + 1;
        }
      }
      return 1;
    }
    get length() {
      return this._map.length;
    }
    get isIdentityCMap() {
      if ("Identity-H" !== this.name && "Identity-V" !== this.name) return false;
      if (65536 !== this._map.length) return false;
      for (let e2 = 0; e2 < 65536; e2++) if (this._map[e2] !== e2) return false;
      return true;
    }
  }
  class IdentityCMap extends CMap {
    constructor(e2, t2) {
      super();
      this.vertical = e2;
      this.addCodespaceRange(t2, 0, 65535);
    }
    mapCidRange(e2, t2, i2) {
      unreachable("should not call mapCidRange");
    }
    mapBfRange(e2, t2, i2) {
      unreachable("should not call mapBfRange");
    }
    mapBfRangeToArray(e2, t2, i2) {
      unreachable("should not call mapBfRangeToArray");
    }
    mapOne(e2, t2) {
      unreachable("should not call mapCidOne");
    }
    lookup(e2) {
      return Number.isInteger(e2) && e2 <= 65535 ? e2 : void 0;
    }
    contains(e2) {
      return Number.isInteger(e2) && e2 <= 65535;
    }
    forEach(e2) {
      for (let t2 = 0; t2 <= 65535; t2++) e2(t2, t2);
    }
    charCodeOf(e2) {
      return Number.isInteger(e2) && e2 <= 65535 ? e2 : -1;
    }
    getMap() {
      const e2 = new Array(65536);
      for (let t2 = 0; t2 <= 65535; t2++) e2[t2] = t2;
      return e2;
    }
    get length() {
      return 65536;
    }
    get isIdentityCMap() {
      unreachable("should not access .isIdentityCMap");
    }
  }
  function strToInt(e2) {
    let t2 = 0;
    for (let i2 = 0; i2 < e2.length; i2++) t2 = t2 << 8 | e2.charCodeAt(i2);
    return t2 >>> 0;
  }
  function expectString(e2) {
    if ("string" != typeof e2) throw new FormatError("Malformed CMap: expected string.");
  }
  function expectInt(e2) {
    if (!Number.isInteger(e2)) throw new FormatError("Malformed CMap: expected int.");
  }
  function parseBfChar(e2, t2) {
    for (; ; ) {
      let i2 = t2.getObj();
      if (i2 === bt) break;
      if (isCmd(i2, "endbfchar")) return;
      expectString(i2);
      const a2 = strToInt(i2);
      i2 = t2.getObj();
      expectString(i2);
      const r2 = i2;
      e2.mapOne(a2, r2);
    }
  }
  function parseBfRange(e2, t2) {
    for (; ; ) {
      let i2 = t2.getObj();
      if (i2 === bt) break;
      if (isCmd(i2, "endbfrange")) return;
      expectString(i2);
      const a2 = strToInt(i2);
      i2 = t2.getObj();
      expectString(i2);
      const r2 = strToInt(i2);
      i2 = t2.getObj();
      if (Number.isInteger(i2) || "string" == typeof i2) {
        const t3 = Number.isInteger(i2) ? String.fromCharCode(i2) : i2;
        e2.mapBfRange(a2, r2, t3);
      } else {
        if (!isCmd(i2, "[")) break;
        {
          i2 = t2.getObj();
          const s2 = [];
          for (; !isCmd(i2, "]") && i2 !== bt; ) {
            s2.push(i2);
            i2 = t2.getObj();
          }
          e2.mapBfRangeToArray(a2, r2, s2);
        }
      }
    }
    throw new FormatError("Invalid bf range.");
  }
  function parseCidChar(e2, t2) {
    for (; ; ) {
      let i2 = t2.getObj();
      if (i2 === bt) break;
      if (isCmd(i2, "endcidchar")) return;
      expectString(i2);
      const a2 = strToInt(i2);
      i2 = t2.getObj();
      expectInt(i2);
      const r2 = i2;
      e2.mapOne(a2, r2);
    }
  }
  function parseCidRange(e2, t2) {
    for (; ; ) {
      let i2 = t2.getObj();
      if (i2 === bt) break;
      if (isCmd(i2, "endcidrange")) return;
      expectString(i2);
      const a2 = strToInt(i2);
      i2 = t2.getObj();
      expectString(i2);
      const r2 = strToInt(i2);
      i2 = t2.getObj();
      expectInt(i2);
      const s2 = i2;
      e2.mapCidRange(a2, r2, s2);
    }
  }
  function parseCodespaceRange(e2, t2) {
    for (; ; ) {
      let i2 = t2.getObj();
      if (i2 === bt) break;
      if (isCmd(i2, "endcodespacerange")) return;
      if ("string" != typeof i2) break;
      const a2 = strToInt(i2);
      i2 = t2.getObj();
      if ("string" != typeof i2) break;
      const r2 = strToInt(i2);
      e2.addCodespaceRange(i2.length, a2, r2);
    }
    throw new FormatError("Invalid codespace range.");
  }
  function parseWMode(e2, t2) {
    const i2 = t2.getObj();
    Number.isInteger(i2) && (e2.vertical = !!i2);
  }
  function parseCMapName(e2, t2) {
    const i2 = t2.getObj();
    i2 instanceof Name && (e2.name = i2.name);
  }
  async function parseCMap(e2, t2, i2, a2) {
    let r2, s2;
    A: for (; ; ) try {
      const i3 = t2.getObj();
      if (i3 === bt) break;
      if (i3 instanceof Name) {
        "WMode" === i3.name ? parseWMode(e2, t2) : "CMapName" === i3.name && parseCMapName(e2, t2);
        r2 = i3;
      } else if (i3 instanceof Cmd) switch (i3.cmd) {
        case "endcmap":
          break A;
        case "usecmap":
          r2 instanceof Name && (s2 = r2.name);
          break;
        case "begincodespacerange":
          parseCodespaceRange(e2, t2);
          break;
        case "beginbfchar":
          parseBfChar(e2, t2);
          break;
        case "begincidchar":
          parseCidChar(e2, t2);
          break;
        case "beginbfrange":
          parseBfRange(e2, t2);
          break;
        case "begincidrange":
          parseCidRange(e2, t2);
      }
    } catch (e3) {
      if (e3 instanceof MissingDataException) throw e3;
      warn("Invalid cMap data: " + e3);
      continue;
    }
    !a2 && s2 && (a2 = s2);
    return a2 ? extendCMap(e2, i2, a2) : e2;
  }
  async function extendCMap(e2, t2, i2) {
    e2.useCMap = await createBuiltInCMap(i2, t2);
    if (0 === e2.numCodespaceRanges) {
      const t3 = e2.useCMap.codespaceRanges;
      for (let i3 = 0; i3 < t3.length; i3++) e2.codespaceRanges[i3] = t3[i3].slice();
      e2.numCodespaceRanges = e2.useCMap.numCodespaceRanges;
    }
    e2.useCMap.forEach(function(t3, i3) {
      e2.contains(t3) || e2.mapOne(t3, e2.useCMap.lookup(t3));
    });
    return e2;
  }
  async function createBuiltInCMap(e2, t2) {
    if ("Identity-H" === e2) return new IdentityCMap(false, 2);
    if ("Identity-V" === e2) return new IdentityCMap(true, 2);
    if (!Qi.includes(e2)) throw new Error("Unknown CMap name: " + e2);
    if (!t2) throw new Error("Built-in CMap parameters are not provided.");
    const { cMapData: i2, isCompressed: a2 } = await t2(e2), r2 = new CMap(true);
    if (a2) return new BinaryCMapReader().process(i2, r2, (e3) => extendCMap(r2, t2, e3));
    const s2 = new Lexer(new Stream(i2));
    return parseCMap(r2, s2, t2, null);
  }
  class CMapFactory {
    static async create({ encoding: e2, fetchBuiltInCMap: t2, useCMap: i2 }) {
      if (e2 instanceof Name) return createBuiltInCMap(e2.name, t2);
      if (e2 instanceof BaseStream) {
        const a2 = await parseCMap(new CMap(), new Lexer(e2), t2, i2);
        return a2.isIdentityCMap ? createBuiltInCMap(a2.name, t2) : a2;
      }
      throw new Error("Encoding required.");
    }
  }
  __webpack_require__(1795);
  const ui = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron"
  ], di = [
    ".notdef",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
  ], fi = [
    ".notdef",
    "space",
    "dollaroldstyle",
    "dollarsuperior",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "hyphensuperior",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "centoldstyle",
    "figuredash",
    "hypheninferior",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior"
  ], pi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "",
    "",
    "",
    "isuperior",
    "",
    "",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "",
    "",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "",
    "",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "",
    "Dotaccentsmall",
    "",
    "",
    "Macronsmall",
    "",
    "",
    "figuredash",
    "hypheninferior",
    "",
    "",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "zerosuperior",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall"
  ], mi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclamsmall",
    "Hungarumlautsmall",
    "centoldstyle",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "comma",
    "hyphen",
    "period",
    "fraction",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "colon",
    "semicolon",
    "",
    "threequartersemdash",
    "",
    "questionsmall",
    "",
    "",
    "",
    "",
    "Ethsmall",
    "",
    "",
    "onequarter",
    "onehalf",
    "threequarters",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "",
    "",
    "",
    "",
    "",
    "",
    "ff",
    "fi",
    "fl",
    "ffi",
    "ffl",
    "parenleftinferior",
    "",
    "parenrightinferior",
    "Circumflexsmall",
    "hypheninferior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "",
    "",
    "asuperior",
    "centsuperior",
    "",
    "",
    "",
    "",
    "Aacutesmall",
    "Agravesmall",
    "Acircumflexsmall",
    "Adieresissmall",
    "Atildesmall",
    "Aringsmall",
    "Ccedillasmall",
    "Eacutesmall",
    "Egravesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Iacutesmall",
    "Igravesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ntildesmall",
    "Oacutesmall",
    "Ogravesmall",
    "Ocircumflexsmall",
    "Odieresissmall",
    "Otildesmall",
    "Uacutesmall",
    "Ugravesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "",
    "eightsuperior",
    "fourinferior",
    "threeinferior",
    "sixinferior",
    "eightinferior",
    "seveninferior",
    "Scaronsmall",
    "",
    "centinferior",
    "twoinferior",
    "",
    "Dieresissmall",
    "",
    "Caronsmall",
    "osuperior",
    "fiveinferior",
    "",
    "commainferior",
    "periodinferior",
    "Yacutesmall",
    "",
    "dollarinferior",
    "",
    "",
    "Thornsmall",
    "",
    "nineinferior",
    "zeroinferior",
    "Zcaronsmall",
    "AEsmall",
    "Oslashsmall",
    "questiondownsmall",
    "oneinferior",
    "Lslashsmall",
    "",
    "",
    "",
    "",
    "",
    "",
    "Cedillasmall",
    "",
    "",
    "",
    "",
    "",
    "OEsmall",
    "figuredash",
    "hyphensuperior",
    "",
    "",
    "",
    "",
    "exclamdownsmall",
    "",
    "Ydieresissmall",
    "",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "ninesuperior",
    "zerosuperior",
    "",
    "esuperior",
    "rsuperior",
    "tsuperior",
    "",
    "",
    "isuperior",
    "ssuperior",
    "dsuperior",
    "",
    "",
    "",
    "",
    "",
    "lsuperior",
    "Ogoneksmall",
    "Brevesmall",
    "Macronsmall",
    "bsuperior",
    "nsuperior",
    "msuperior",
    "commasuperior",
    "periodsuperior",
    "Dotaccentsmall",
    "Ringsmall",
    "",
    "",
    "",
    ""
  ], yi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "space",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron"
  ], wi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "",
    "questiondown",
    "",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "",
    "ring",
    "cedilla",
    "",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "AE",
    "",
    "ordfeminine",
    "",
    "",
    "",
    "",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "",
    "",
    "",
    "",
    "",
    "ae",
    "",
    "",
    "",
    "dotlessi",
    "",
    "",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "",
    "",
    "",
    ""
  ], bi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "bullet",
    "Euro",
    "bullet",
    "quotesinglbase",
    "florin",
    "quotedblbase",
    "ellipsis",
    "dagger",
    "daggerdbl",
    "circumflex",
    "perthousand",
    "Scaron",
    "guilsinglleft",
    "OE",
    "bullet",
    "Zcaron",
    "bullet",
    "bullet",
    "quoteleft",
    "quoteright",
    "quotedblleft",
    "quotedblright",
    "bullet",
    "endash",
    "emdash",
    "tilde",
    "trademark",
    "scaron",
    "guilsinglright",
    "oe",
    "bullet",
    "zcaron",
    "Ydieresis",
    "space",
    "exclamdown",
    "cent",
    "sterling",
    "currency",
    "yen",
    "brokenbar",
    "section",
    "dieresis",
    "copyright",
    "ordfeminine",
    "guillemotleft",
    "logicalnot",
    "hyphen",
    "registered",
    "macron",
    "degree",
    "plusminus",
    "twosuperior",
    "threesuperior",
    "acute",
    "mu",
    "paragraph",
    "periodcentered",
    "cedilla",
    "onesuperior",
    "ordmasculine",
    "guillemotright",
    "onequarter",
    "onehalf",
    "threequarters",
    "questiondown",
    "Agrave",
    "Aacute",
    "Acircumflex",
    "Atilde",
    "Adieresis",
    "Aring",
    "AE",
    "Ccedilla",
    "Egrave",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Igrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Eth",
    "Ntilde",
    "Ograve",
    "Oacute",
    "Ocircumflex",
    "Otilde",
    "Odieresis",
    "multiply",
    "Oslash",
    "Ugrave",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Yacute",
    "Thorn",
    "germandbls",
    "agrave",
    "aacute",
    "acircumflex",
    "atilde",
    "adieresis",
    "aring",
    "ae",
    "ccedilla",
    "egrave",
    "eacute",
    "ecircumflex",
    "edieresis",
    "igrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "eth",
    "ntilde",
    "ograve",
    "oacute",
    "ocircumflex",
    "otilde",
    "odieresis",
    "divide",
    "oslash",
    "ugrave",
    "uacute",
    "ucircumflex",
    "udieresis",
    "yacute",
    "thorn",
    "ydieresis"
  ], Di = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "exclam",
    "universal",
    "numbersign",
    "existential",
    "percent",
    "ampersand",
    "suchthat",
    "parenleft",
    "parenright",
    "asteriskmath",
    "plus",
    "comma",
    "minus",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "congruent",
    "Alpha",
    "Beta",
    "Chi",
    "Delta",
    "Epsilon",
    "Phi",
    "Gamma",
    "Eta",
    "Iota",
    "theta1",
    "Kappa",
    "Lambda",
    "Mu",
    "Nu",
    "Omicron",
    "Pi",
    "Theta",
    "Rho",
    "Sigma",
    "Tau",
    "Upsilon",
    "sigma1",
    "Omega",
    "Xi",
    "Psi",
    "Zeta",
    "bracketleft",
    "therefore",
    "bracketright",
    "perpendicular",
    "underscore",
    "radicalex",
    "alpha",
    "beta",
    "chi",
    "delta",
    "epsilon",
    "phi",
    "gamma",
    "eta",
    "iota",
    "phi1",
    "kappa",
    "lambda",
    "mu",
    "nu",
    "omicron",
    "pi",
    "theta",
    "rho",
    "sigma",
    "tau",
    "upsilon",
    "omega1",
    "omega",
    "xi",
    "psi",
    "zeta",
    "braceleft",
    "bar",
    "braceright",
    "similar",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Euro",
    "Upsilon1",
    "minute",
    "lessequal",
    "fraction",
    "infinity",
    "florin",
    "club",
    "diamond",
    "heart",
    "spade",
    "arrowboth",
    "arrowleft",
    "arrowup",
    "arrowright",
    "arrowdown",
    "degree",
    "plusminus",
    "second",
    "greaterequal",
    "multiply",
    "proportional",
    "partialdiff",
    "bullet",
    "divide",
    "notequal",
    "equivalence",
    "approxequal",
    "ellipsis",
    "arrowvertex",
    "arrowhorizex",
    "carriagereturn",
    "aleph",
    "Ifraktur",
    "Rfraktur",
    "weierstrass",
    "circlemultiply",
    "circleplus",
    "emptyset",
    "intersection",
    "union",
    "propersuperset",
    "reflexsuperset",
    "notsubset",
    "propersubset",
    "reflexsubset",
    "element",
    "notelement",
    "angle",
    "gradient",
    "registerserif",
    "copyrightserif",
    "trademarkserif",
    "product",
    "radical",
    "dotmath",
    "logicalnot",
    "logicaland",
    "logicalor",
    "arrowdblboth",
    "arrowdblleft",
    "arrowdblup",
    "arrowdblright",
    "arrowdbldown",
    "lozenge",
    "angleleft",
    "registersans",
    "copyrightsans",
    "trademarksans",
    "summation",
    "parenlefttp",
    "parenleftex",
    "parenleftbt",
    "bracketlefttp",
    "bracketleftex",
    "bracketleftbt",
    "bracelefttp",
    "braceleftmid",
    "braceleftbt",
    "braceex",
    "",
    "angleright",
    "integral",
    "integraltp",
    "integralex",
    "integralbt",
    "parenrighttp",
    "parenrightex",
    "parenrightbt",
    "bracketrighttp",
    "bracketrightex",
    "bracketrightbt",
    "bracerighttp",
    "bracerightmid",
    "bracerightbt",
    ""
  ], Fi = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "space",
    "a1",
    "a2",
    "a202",
    "a3",
    "a4",
    "a5",
    "a119",
    "a118",
    "a117",
    "a11",
    "a12",
    "a13",
    "a14",
    "a15",
    "a16",
    "a105",
    "a17",
    "a18",
    "a19",
    "a20",
    "a21",
    "a22",
    "a23",
    "a24",
    "a25",
    "a26",
    "a27",
    "a28",
    "a6",
    "a7",
    "a8",
    "a9",
    "a10",
    "a29",
    "a30",
    "a31",
    "a32",
    "a33",
    "a34",
    "a35",
    "a36",
    "a37",
    "a38",
    "a39",
    "a40",
    "a41",
    "a42",
    "a43",
    "a44",
    "a45",
    "a46",
    "a47",
    "a48",
    "a49",
    "a50",
    "a51",
    "a52",
    "a53",
    "a54",
    "a55",
    "a56",
    "a57",
    "a58",
    "a59",
    "a60",
    "a61",
    "a62",
    "a63",
    "a64",
    "a65",
    "a66",
    "a67",
    "a68",
    "a69",
    "a70",
    "a71",
    "a72",
    "a73",
    "a74",
    "a203",
    "a75",
    "a204",
    "a76",
    "a77",
    "a78",
    "a79",
    "a81",
    "a82",
    "a83",
    "a84",
    "a97",
    "a98",
    "a99",
    "a100",
    "",
    "a89",
    "a90",
    "a93",
    "a94",
    "a91",
    "a92",
    "a205",
    "a85",
    "a206",
    "a86",
    "a87",
    "a88",
    "a95",
    "a96",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "a101",
    "a102",
    "a103",
    "a104",
    "a106",
    "a107",
    "a108",
    "a112",
    "a111",
    "a110",
    "a109",
    "a120",
    "a121",
    "a122",
    "a123",
    "a124",
    "a125",
    "a126",
    "a127",
    "a128",
    "a129",
    "a130",
    "a131",
    "a132",
    "a133",
    "a134",
    "a135",
    "a136",
    "a137",
    "a138",
    "a139",
    "a140",
    "a141",
    "a142",
    "a143",
    "a144",
    "a145",
    "a146",
    "a147",
    "a148",
    "a149",
    "a150",
    "a151",
    "a152",
    "a153",
    "a154",
    "a155",
    "a156",
    "a157",
    "a158",
    "a159",
    "a160",
    "a161",
    "a163",
    "a164",
    "a196",
    "a165",
    "a192",
    "a166",
    "a167",
    "a168",
    "a169",
    "a170",
    "a171",
    "a172",
    "a173",
    "a162",
    "a174",
    "a175",
    "a176",
    "a177",
    "a178",
    "a179",
    "a193",
    "a180",
    "a199",
    "a181",
    "a200",
    "a182",
    "",
    "a201",
    "a183",
    "a184",
    "a197",
    "a185",
    "a194",
    "a198",
    "a186",
    "a195",
    "a187",
    "a188",
    "a189",
    "a190",
    "a191",
    ""
  ];
  function getEncoding(e2) {
    switch (e2) {
      case "WinAnsiEncoding":
        return bi;
      case "StandardEncoding":
        return wi;
      case "MacRomanEncoding":
        return yi;
      case "SymbolSetEncoding":
        return Di;
      case "ZapfDingbatsEncoding":
        return Fi;
      case "ExpertEncoding":
        return pi;
      case "MacExpertEncoding":
        return mi;
      default:
        return null;
    }
  }
  const Si = [
    ".notdef",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quoteright",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "quoteleft",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "exclamdown",
    "cent",
    "sterling",
    "fraction",
    "yen",
    "florin",
    "section",
    "currency",
    "quotesingle",
    "quotedblleft",
    "guillemotleft",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "endash",
    "dagger",
    "daggerdbl",
    "periodcentered",
    "paragraph",
    "bullet",
    "quotesinglbase",
    "quotedblbase",
    "quotedblright",
    "guillemotright",
    "ellipsis",
    "perthousand",
    "questiondown",
    "grave",
    "acute",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "dieresis",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "emdash",
    "AE",
    "ordfeminine",
    "Lslash",
    "Oslash",
    "OE",
    "ordmasculine",
    "ae",
    "dotlessi",
    "lslash",
    "oslash",
    "oe",
    "germandbls",
    "onesuperior",
    "logicalnot",
    "mu",
    "trademark",
    "Eth",
    "onehalf",
    "plusminus",
    "Thorn",
    "onequarter",
    "divide",
    "brokenbar",
    "degree",
    "thorn",
    "threequarters",
    "twosuperior",
    "registered",
    "minus",
    "eth",
    "multiply",
    "threesuperior",
    "copyright",
    "Aacute",
    "Acircumflex",
    "Adieresis",
    "Agrave",
    "Aring",
    "Atilde",
    "Ccedilla",
    "Eacute",
    "Ecircumflex",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Ntilde",
    "Oacute",
    "Ocircumflex",
    "Odieresis",
    "Ograve",
    "Otilde",
    "Scaron",
    "Uacute",
    "Ucircumflex",
    "Udieresis",
    "Ugrave",
    "Yacute",
    "Ydieresis",
    "Zcaron",
    "aacute",
    "acircumflex",
    "adieresis",
    "agrave",
    "aring",
    "atilde",
    "ccedilla",
    "eacute",
    "ecircumflex",
    "edieresis",
    "egrave",
    "iacute",
    "icircumflex",
    "idieresis",
    "igrave",
    "ntilde",
    "oacute",
    "ocircumflex",
    "odieresis",
    "ograve",
    "otilde",
    "scaron",
    "uacute",
    "ucircumflex",
    "udieresis",
    "ugrave",
    "yacute",
    "ydieresis",
    "zcaron",
    "exclamsmall",
    "Hungarumlautsmall",
    "dollaroldstyle",
    "dollarsuperior",
    "ampersandsmall",
    "Acutesmall",
    "parenleftsuperior",
    "parenrightsuperior",
    "twodotenleader",
    "onedotenleader",
    "zerooldstyle",
    "oneoldstyle",
    "twooldstyle",
    "threeoldstyle",
    "fouroldstyle",
    "fiveoldstyle",
    "sixoldstyle",
    "sevenoldstyle",
    "eightoldstyle",
    "nineoldstyle",
    "commasuperior",
    "threequartersemdash",
    "periodsuperior",
    "questionsmall",
    "asuperior",
    "bsuperior",
    "centsuperior",
    "dsuperior",
    "esuperior",
    "isuperior",
    "lsuperior",
    "msuperior",
    "nsuperior",
    "osuperior",
    "rsuperior",
    "ssuperior",
    "tsuperior",
    "ff",
    "ffi",
    "ffl",
    "parenleftinferior",
    "parenrightinferior",
    "Circumflexsmall",
    "hyphensuperior",
    "Gravesmall",
    "Asmall",
    "Bsmall",
    "Csmall",
    "Dsmall",
    "Esmall",
    "Fsmall",
    "Gsmall",
    "Hsmall",
    "Ismall",
    "Jsmall",
    "Ksmall",
    "Lsmall",
    "Msmall",
    "Nsmall",
    "Osmall",
    "Psmall",
    "Qsmall",
    "Rsmall",
    "Ssmall",
    "Tsmall",
    "Usmall",
    "Vsmall",
    "Wsmall",
    "Xsmall",
    "Ysmall",
    "Zsmall",
    "colonmonetary",
    "onefitted",
    "rupiah",
    "Tildesmall",
    "exclamdownsmall",
    "centoldstyle",
    "Lslashsmall",
    "Scaronsmall",
    "Zcaronsmall",
    "Dieresissmall",
    "Brevesmall",
    "Caronsmall",
    "Dotaccentsmall",
    "Macronsmall",
    "figuredash",
    "hypheninferior",
    "Ogoneksmall",
    "Ringsmall",
    "Cedillasmall",
    "questiondownsmall",
    "oneeighth",
    "threeeighths",
    "fiveeighths",
    "seveneighths",
    "onethird",
    "twothirds",
    "zerosuperior",
    "foursuperior",
    "fivesuperior",
    "sixsuperior",
    "sevensuperior",
    "eightsuperior",
    "ninesuperior",
    "zeroinferior",
    "oneinferior",
    "twoinferior",
    "threeinferior",
    "fourinferior",
    "fiveinferior",
    "sixinferior",
    "seveninferior",
    "eightinferior",
    "nineinferior",
    "centinferior",
    "dollarinferior",
    "periodinferior",
    "commainferior",
    "Agravesmall",
    "Aacutesmall",
    "Acircumflexsmall",
    "Atildesmall",
    "Adieresissmall",
    "Aringsmall",
    "AEsmall",
    "Ccedillasmall",
    "Egravesmall",
    "Eacutesmall",
    "Ecircumflexsmall",
    "Edieresissmall",
    "Igravesmall",
    "Iacutesmall",
    "Icircumflexsmall",
    "Idieresissmall",
    "Ethsmall",
    "Ntildesmall",
    "Ogravesmall",
    "Oacutesmall",
    "Ocircumflexsmall",
    "Otildesmall",
    "Odieresissmall",
    "OEsmall",
    "Oslashsmall",
    "Ugravesmall",
    "Uacutesmall",
    "Ucircumflexsmall",
    "Udieresissmall",
    "Yacutesmall",
    "Thornsmall",
    "Ydieresissmall",
    "001.000",
    "001.001",
    "001.002",
    "001.003",
    "Black",
    "Bold",
    "Book",
    "Light",
    "Medium",
    "Regular",
    "Roman",
    "Semibold"
  ], ki = 391, Ri = [
    null,
    {
      id: "hstem",
      min: 2,
      stackClearing: true,
      stem: true
    },
    null,
    {
      id: "vstem",
      min: 2,
      stackClearing: true,
      stem: true
    },
    {
      id: "vmoveto",
      min: 1,
      stackClearing: true
    },
    {
      id: "rlineto",
      min: 2,
      resetStack: true
    },
    {
      id: "hlineto",
      min: 1,
      resetStack: true
    },
    {
      id: "vlineto",
      min: 1,
      resetStack: true
    },
    {
      id: "rrcurveto",
      min: 6,
      resetStack: true
    },
    null,
    {
      id: "callsubr",
      min: 1,
      undefStack: true
    },
    {
      id: "return",
      min: 0,
      undefStack: true
    },
    null,
    null,
    {
      id: "endchar",
      min: 0,
      stackClearing: true
    },
    null,
    null,
    null,
    {
      id: "hstemhm",
      min: 2,
      stackClearing: true,
      stem: true
    },
    {
      id: "hintmask",
      min: 0,
      stackClearing: true
    },
    {
      id: "cntrmask",
      min: 0,
      stackClearing: true
    },
    {
      id: "rmoveto",
      min: 2,
      stackClearing: true
    },
    {
      id: "hmoveto",
      min: 1,
      stackClearing: true
    },
    {
      id: "vstemhm",
      min: 2,
      stackClearing: true,
      stem: true
    },
    {
      id: "rcurveline",
      min: 8,
      resetStack: true
    },
    {
      id: "rlinecurve",
      min: 8,
      resetStack: true
    },
    {
      id: "vvcurveto",
      min: 4,
      resetStack: true
    },
    {
      id: "hhcurveto",
      min: 4,
      resetStack: true
    },
    null,
    {
      id: "callgsubr",
      min: 1,
      undefStack: true
    },
    {
      id: "vhcurveto",
      min: 4,
      resetStack: true
    },
    {
      id: "hvcurveto",
      min: 4,
      resetStack: true
    }
  ], Ni = [
    null,
    null,
    null,
    {
      id: "and",
      min: 2,
      stackDelta: -1
    },
    {
      id: "or",
      min: 2,
      stackDelta: -1
    },
    {
      id: "not",
      min: 1,
      stackDelta: 0
    },
    null,
    null,
    null,
    {
      id: "abs",
      min: 1,
      stackDelta: 0
    },
    {
      id: "add",
      min: 2,
      stackDelta: -1,
      stackFn(e2, t2) {
        e2[t2 - 2] = e2[t2 - 2] + e2[t2 - 1];
      }
    },
    {
      id: "sub",
      min: 2,
      stackDelta: -1,
      stackFn(e2, t2) {
        e2[t2 - 2] = e2[t2 - 2] - e2[t2 - 1];
      }
    },
    {
      id: "div",
      min: 2,
      stackDelta: -1,
      stackFn(e2, t2) {
        e2[t2 - 2] = e2[t2 - 2] / e2[t2 - 1];
      }
    },
    null,
    {
      id: "neg",
      min: 1,
      stackDelta: 0,
      stackFn(e2, t2) {
        e2[t2 - 1] = -e2[t2 - 1];
      }
    },
    {
      id: "eq",
      min: 2,
      stackDelta: -1
    },
    null,
    null,
    {
      id: "drop",
      min: 1,
      stackDelta: -1
    },
    null,
    {
      id: "put",
      min: 2,
      stackDelta: -2
    },
    {
      id: "get",
      min: 1,
      stackDelta: 0
    },
    {
      id: "ifelse",
      min: 4,
      stackDelta: -3
    },
    {
      id: "random",
      min: 0,
      stackDelta: 1
    },
    {
      id: "mul",
      min: 2,
      stackDelta: -1,
      stackFn(e2, t2) {
        e2[t2 - 2] = e2[t2 - 2] * e2[t2 - 1];
      }
    },
    null,
    {
      id: "sqrt",
      min: 1,
      stackDelta: 0
    },
    {
      id: "dup",
      min: 1,
      stackDelta: 1
    },
    {
      id: "exch",
      min: 2,
      stackDelta: 0
    },
    {
      id: "index",
      min: 2,
      stackDelta: 0
    },
    {
      id: "roll",
      min: 3,
      stackDelta: -2
    },
    null,
    null,
    null,
    {
      id: "hflex",
      min: 7,
      resetStack: true
    },
    {
      id: "flex",
      min: 13,
      resetStack: true
    },
    {
      id: "hflex1",
      min: 9,
      resetStack: true
    },
    {
      id: "flex1",
      min: 11,
      resetStack: true
    }
  ];
  class CFFParser {
    constructor(e2, t2, i2) {
      this.bytes = e2.getBytes();
      this.properties = t2;
      this.seacAnalysisEnabled = !!i2;
    }
    parse() {
      const e2 = this.properties, t2 = new CFF();
      this.cff = t2;
      const i2 = this.parseHeader(), a2 = this.parseIndex(i2.endPos), r2 = this.parseIndex(a2.endPos), s2 = this.parseIndex(r2.endPos), n2 = this.parseIndex(s2.endPos), o2 = this.parseDict(r2.obj.get(0)), g2 = this.createDict(CFFTopDict, o2, t2.strings);
      t2.header = i2.obj;
      t2.names = this.parseNameIndex(a2.obj);
      t2.strings = this.parseStringIndex(s2.obj);
      t2.topDict = g2;
      t2.globalSubrIndex = n2.obj;
      this.parsePrivateDict(t2.topDict);
      t2.isCIDFont = g2.hasName("ROS");
      const c2 = g2.getByName("CharStrings"), C2 = this.parseIndex(c2).obj, h2 = g2.getByName("FontMatrix");
      h2 && (e2.fontMatrix = h2);
      const l2 = g2.getByName("FontBBox");
      if (l2) {
        e2.ascent = Math.max(l2[3], l2[1]);
        e2.descent = Math.min(l2[1], l2[3]);
        e2.ascentScaled = true;
      }
      let Q2, E2;
      if (t2.isCIDFont) {
        const e3 = this.parseIndex(g2.getByName("FDArray")).obj;
        for (let i3 = 0, a3 = e3.count; i3 < a3; ++i3) {
          const a4 = e3.get(i3), r3 = this.createDict(CFFTopDict, this.parseDict(a4), t2.strings);
          this.parsePrivateDict(r3);
          t2.fdArray.push(r3);
        }
        E2 = null;
        Q2 = this.parseCharsets(g2.getByName("charset"), C2.count, t2.strings, true);
        t2.fdSelect = this.parseFDSelect(g2.getByName("FDSelect"), C2.count);
      } else {
        Q2 = this.parseCharsets(g2.getByName("charset"), C2.count, t2.strings, false);
        E2 = this.parseEncoding(g2.getByName("Encoding"), e2, t2.strings, Q2.charset);
      }
      t2.charset = Q2;
      t2.encoding = E2;
      const u2 = this.parseCharStrings({
        charStrings: C2,
        localSubrIndex: g2.privateDict.subrsIndex,
        globalSubrIndex: n2.obj,
        fdSelect: t2.fdSelect,
        fdArray: t2.fdArray,
        privateDict: g2.privateDict
      });
      t2.charStrings = u2.charStrings;
      t2.seacs = u2.seacs;
      t2.widths = u2.widths;
      return t2;
    }
    parseHeader() {
      let e2 = this.bytes;
      const t2 = e2.length;
      let i2 = 0;
      for (; i2 < t2 && 1 !== e2[i2]; ) ++i2;
      if (i2 >= t2) throw new FormatError("Invalid CFF header");
      if (0 !== i2) {
        info("cff data is shifted");
        e2 = e2.subarray(i2);
        this.bytes = e2;
      }
      const a2 = e2[0], r2 = e2[1], s2 = e2[2], n2 = e2[3];
      return {
        obj: new CFFHeader(a2, r2, s2, n2),
        endPos: s2
      };
    }
    parseDict(e2) {
      let t2 = 0;
      function parseOperand() {
        let i3 = e2[t2++];
        if (30 === i3) return function parseFloatOperand() {
          let i4 = "";
          const a3 = 15, r3 = [
            "0",
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            ".",
            "E",
            "E-",
            null,
            "-"
          ], s2 = e2.length;
          for (; t2 < s2; ) {
            const s3 = e2[t2++], n2 = s3 >> 4, o2 = 15 & s3;
            if (n2 === a3) break;
            i4 += r3[n2];
            if (o2 === a3) break;
            i4 += r3[o2];
          }
          return parseFloat(i4);
        }();
        if (28 === i3) {
          i3 = e2[t2++];
          i3 = (i3 << 24 | e2[t2++] << 16) >> 16;
          return i3;
        }
        if (29 === i3) {
          i3 = e2[t2++];
          i3 = i3 << 8 | e2[t2++];
          i3 = i3 << 8 | e2[t2++];
          i3 = i3 << 8 | e2[t2++];
          return i3;
        }
        if (i3 >= 32 && i3 <= 246) return i3 - 139;
        if (i3 >= 247 && i3 <= 250) return 256 * (i3 - 247) + e2[t2++] + 108;
        if (i3 >= 251 && i3 <= 254) return -256 * (i3 - 251) - e2[t2++] - 108;
        warn('CFFParser_parseDict: "' + i3 + '" is a reserved command.');
        return NaN;
      }
      let i2 = [];
      const a2 = [];
      t2 = 0;
      const r2 = e2.length;
      for (; t2 < r2; ) {
        let r3 = e2[t2];
        if (r3 <= 21) {
          12 === r3 && (r3 = r3 << 8 | e2[++t2]);
          a2.push([
            r3,
            i2
          ]);
          i2 = [];
          ++t2;
        } else i2.push(parseOperand());
      }
      return a2;
    }
    parseIndex(e2) {
      const t2 = new CFFIndex(), i2 = this.bytes, a2 = i2[e2++] << 8 | i2[e2++], r2 = [];
      let s2, n2, o2 = e2;
      if (0 !== a2) {
        const t3 = i2[e2++], g2 = e2 + (a2 + 1) * t3 - 1;
        for (s2 = 0, n2 = a2 + 1; s2 < n2; ++s2) {
          let a3 = 0;
          for (let r3 = 0; r3 < t3; ++r3) {
            a3 <<= 8;
            a3 += i2[e2++];
          }
          r2.push(g2 + a3);
        }
        o2 = r2[a2];
      }
      for (s2 = 0, n2 = r2.length - 1; s2 < n2; ++s2) {
        const e3 = r2[s2], a3 = r2[s2 + 1];
        t2.add(i2.subarray(e3, a3));
      }
      return {
        obj: t2,
        endPos: o2
      };
    }
    parseNameIndex(e2) {
      const t2 = [];
      for (let i2 = 0, a2 = e2.count; i2 < a2; ++i2) {
        const a3 = e2.get(i2);
        t2.push(bytesToString(a3));
      }
      return t2;
    }
    parseStringIndex(e2) {
      const t2 = new CFFStrings();
      for (let i2 = 0, a2 = e2.count; i2 < a2; ++i2) {
        const a3 = e2.get(i2);
        t2.add(bytesToString(a3));
      }
      return t2;
    }
    createDict(e2, t2, i2) {
      const a2 = new e2(i2);
      for (const [e3, i3] of t2) a2.setByKey(e3, i3);
      return a2;
    }
    parseCharString(e2, t2, i2, a2) {
      if (!t2 || e2.callDepth > 10) return false;
      let r2 = e2.stackSize;
      const s2 = e2.stack;
      let n2 = t2.length;
      for (let o2 = 0; o2 < n2; ) {
        const g2 = t2[o2++];
        let c2 = null;
        if (12 === g2) {
          const e3 = t2[o2++];
          if (0 === e3) {
            t2[o2 - 2] = 139;
            t2[o2 - 1] = 22;
            r2 = 0;
          } else c2 = Ni[e3];
        } else if (28 === g2) {
          s2[r2] = (t2[o2] << 24 | t2[o2 + 1] << 16) >> 16;
          o2 += 2;
          r2++;
        } else if (14 === g2) {
          if (r2 >= 4) {
            r2 -= 4;
            if (this.seacAnalysisEnabled) {
              e2.seac = s2.slice(r2, r2 + 4);
              return false;
            }
          }
          c2 = Ri[g2];
        } else if (g2 >= 32 && g2 <= 246) {
          s2[r2] = g2 - 139;
          r2++;
        } else if (g2 >= 247 && g2 <= 254) {
          s2[r2] = g2 < 251 ? (g2 - 247 << 8) + t2[o2] + 108 : -(g2 - 251 << 8) - t2[o2] - 108;
          o2++;
          r2++;
        } else if (255 === g2) {
          s2[r2] = (t2[o2] << 24 | t2[o2 + 1] << 16 | t2[o2 + 2] << 8 | t2[o2 + 3]) / 65536;
          o2 += 4;
          r2++;
        } else if (19 === g2 || 20 === g2) {
          e2.hints += r2 >> 1;
          if (0 === e2.hints) {
            t2.copyWithin(o2 - 1, o2, -1);
            o2 -= 1;
            n2 -= 1;
            continue;
          }
          o2 += e2.hints + 7 >> 3;
          r2 %= 2;
          c2 = Ri[g2];
        } else {
          if (10 === g2 || 29 === g2) {
            const t3 = 10 === g2 ? i2 : a2;
            if (!t3) {
              c2 = Ri[g2];
              warn("Missing subrsIndex for " + c2.id);
              return false;
            }
            let n3 = 32768;
            t3.count < 1240 ? n3 = 107 : t3.count < 33900 && (n3 = 1131);
            const o3 = s2[--r2] + n3;
            if (o3 < 0 || o3 >= t3.count || isNaN(o3)) {
              c2 = Ri[g2];
              warn("Out of bounds subrIndex for " + c2.id);
              return false;
            }
            e2.stackSize = r2;
            e2.callDepth++;
            if (!this.parseCharString(e2, t3.get(o3), i2, a2)) return false;
            e2.callDepth--;
            r2 = e2.stackSize;
            continue;
          }
          if (11 === g2) {
            e2.stackSize = r2;
            return true;
          }
          if (0 === g2 && o2 === t2.length) {
            t2[o2 - 1] = 14;
            c2 = Ri[14];
          } else {
            if (9 === g2) {
              t2.copyWithin(o2 - 1, o2, -1);
              o2 -= 1;
              n2 -= 1;
              continue;
            }
            c2 = Ri[g2];
          }
        }
        if (c2) {
          if (c2.stem) {
            e2.hints += r2 >> 1;
            if (3 === g2 || 23 === g2) e2.hasVStems = true;
            else if (e2.hasVStems && (1 === g2 || 18 === g2)) {
              warn("CFF stem hints are in wrong order");
              t2[o2 - 1] = 1 === g2 ? 3 : 23;
            }
          }
          if ("min" in c2 && !e2.undefStack && r2 < c2.min) {
            warn("Not enough parameters for " + c2.id + "; actual: " + r2 + ", expected: " + c2.min);
            if (0 === r2) {
              t2[o2 - 1] = 14;
              return true;
            }
            return false;
          }
          if (e2.firstStackClearing && c2.stackClearing) {
            e2.firstStackClearing = false;
            r2 -= c2.min;
            r2 >= 2 && c2.stem ? r2 %= 2 : r2 > 1 && warn("Found too many parameters for stack-clearing command");
            r2 > 0 && (e2.width = s2[r2 - 1]);
          }
          if ("stackDelta" in c2) {
            "stackFn" in c2 && c2.stackFn(s2, r2);
            r2 += c2.stackDelta;
          } else if (c2.stackClearing) r2 = 0;
          else if (c2.resetStack) {
            r2 = 0;
            e2.undefStack = false;
          } else if (c2.undefStack) {
            r2 = 0;
            e2.undefStack = true;
            e2.firstStackClearing = false;
          }
        }
      }
      n2 < t2.length && t2.fill(14, n2);
      e2.stackSize = r2;
      return true;
    }
    parseCharStrings({ charStrings: e2, localSubrIndex: t2, globalSubrIndex: i2, fdSelect: a2, fdArray: r2, privateDict: s2 }) {
      const n2 = [], o2 = [], g2 = e2.count;
      for (let c2 = 0; c2 < g2; c2++) {
        const g3 = e2.get(c2), C2 = {
          callDepth: 0,
          stackSize: 0,
          stack: [],
          undefStack: true,
          hints: 0,
          firstStackClearing: true,
          seac: null,
          width: null,
          hasVStems: false
        };
        let h2 = true, l2 = null, Q2 = s2;
        if (a2 && r2.length) {
          const e3 = a2.getFDIndex(c2);
          if (-1 === e3) {
            warn("Glyph index is not in fd select.");
            h2 = false;
          }
          if (e3 >= r2.length) {
            warn("Invalid fd index for glyph index.");
            h2 = false;
          }
          if (h2) {
            Q2 = r2[e3].privateDict;
            l2 = Q2.subrsIndex;
          }
        } else t2 && (l2 = t2);
        h2 && (h2 = this.parseCharString(C2, g3, l2, i2));
        if (null !== C2.width) {
          const e3 = Q2.getByName("nominalWidthX");
          o2[c2] = e3 + C2.width;
        } else {
          const e3 = Q2.getByName("defaultWidthX");
          o2[c2] = e3;
        }
        null !== C2.seac && (n2[c2] = C2.seac);
        h2 || e2.set(c2, new Uint8Array([
          14
        ]));
      }
      return {
        charStrings: e2,
        seacs: n2,
        widths: o2
      };
    }
    emptyPrivateDictionary(e2) {
      const t2 = this.createDict(CFFPrivateDict, [], e2.strings);
      e2.setByKey(18, [
        0,
        0
      ]);
      e2.privateDict = t2;
    }
    parsePrivateDict(e2) {
      if (!e2.hasName("Private")) {
        this.emptyPrivateDictionary(e2);
        return;
      }
      const t2 = e2.getByName("Private");
      if (!Array.isArray(t2) || 2 !== t2.length) {
        e2.removeByName("Private");
        return;
      }
      const i2 = t2[0], a2 = t2[1];
      if (0 === i2 || a2 >= this.bytes.length) {
        this.emptyPrivateDictionary(e2);
        return;
      }
      const r2 = a2 + i2, s2 = this.bytes.subarray(a2, r2), n2 = this.parseDict(s2), o2 = this.createDict(CFFPrivateDict, n2, e2.strings);
      e2.privateDict = o2;
      0 === o2.getByName("ExpansionFactor") && o2.setByName("ExpansionFactor", 0.06);
      if (!o2.getByName("Subrs")) return;
      const g2 = o2.getByName("Subrs"), c2 = a2 + g2;
      if (0 === g2 || c2 >= this.bytes.length) {
        this.emptyPrivateDictionary(e2);
        return;
      }
      const C2 = this.parseIndex(c2);
      o2.subrsIndex = C2.obj;
    }
    parseCharsets(e2, t2, i2, a2) {
      if (0 === e2) return new CFFCharset(true, Mi.ISO_ADOBE, ui);
      if (1 === e2) return new CFFCharset(true, Mi.EXPERT, di);
      if (2 === e2) return new CFFCharset(true, Mi.EXPERT_SUBSET, fi);
      const r2 = this.bytes, s2 = e2, n2 = r2[e2++], o2 = [
        a2 ? 0 : ".notdef"
      ];
      let g2, c2, C2;
      t2 -= 1;
      switch (n2) {
        case 0:
          for (C2 = 0; C2 < t2; C2++) {
            g2 = r2[e2++] << 8 | r2[e2++];
            o2.push(a2 ? g2 : i2.get(g2));
          }
          break;
        case 1:
          for (; o2.length <= t2; ) {
            g2 = r2[e2++] << 8 | r2[e2++];
            c2 = r2[e2++];
            for (C2 = 0; C2 <= c2; C2++) o2.push(a2 ? g2++ : i2.get(g2++));
          }
          break;
        case 2:
          for (; o2.length <= t2; ) {
            g2 = r2[e2++] << 8 | r2[e2++];
            c2 = r2[e2++] << 8 | r2[e2++];
            for (C2 = 0; C2 <= c2; C2++) o2.push(a2 ? g2++ : i2.get(g2++));
          }
          break;
        default:
          throw new FormatError("Unknown charset format");
      }
      const h2 = e2, l2 = r2.subarray(s2, h2);
      return new CFFCharset(false, n2, o2, l2);
    }
    parseEncoding(e2, t2, i2, a2) {
      const r2 = /* @__PURE__ */ Object.create(null), s2 = this.bytes;
      let n2, o2, g2, c2 = false, C2 = null;
      if (0 === e2 || 1 === e2) {
        c2 = true;
        n2 = e2;
        const t3 = e2 ? pi : wi;
        for (o2 = 0, g2 = a2.length; o2 < g2; o2++) {
          const e3 = t3.indexOf(a2[o2]);
          -1 !== e3 && (r2[e3] = o2);
        }
      } else {
        const t3 = e2;
        n2 = s2[e2++];
        switch (127 & n2) {
          case 0:
            const t4 = s2[e2++];
            for (o2 = 1; o2 <= t4; o2++) r2[s2[e2++]] = o2;
            break;
          case 1:
            const i3 = s2[e2++];
            let a3 = 1;
            for (o2 = 0; o2 < i3; o2++) {
              const t5 = s2[e2++], i4 = s2[e2++];
              for (let e3 = t5; e3 <= t5 + i4; e3++) r2[e3] = a3++;
            }
            break;
          default:
            throw new FormatError(`Unknown encoding format: ${n2} in CFF`);
        }
        const g3 = e2;
        if (128 & n2) {
          s2[t3] &= 127;
          !function readSupplement() {
            const t4 = s2[e2++];
            for (o2 = 0; o2 < t4; o2++) {
              const t5 = s2[e2++], n3 = (s2[e2++] << 8) + (255 & s2[e2++]);
              r2[t5] = a2.indexOf(i2.get(n3));
            }
          }();
        }
        C2 = s2.subarray(t3, g3);
      }
      n2 &= 127;
      return new CFFEncoding(c2, n2, r2, C2);
    }
    parseFDSelect(e2, t2) {
      const i2 = this.bytes, a2 = i2[e2++], r2 = [];
      let s2;
      switch (a2) {
        case 0:
          for (s2 = 0; s2 < t2; ++s2) {
            const t3 = i2[e2++];
            r2.push(t3);
          }
          break;
        case 3:
          const n2 = i2[e2++] << 8 | i2[e2++];
          for (s2 = 0; s2 < n2; ++s2) {
            let t3 = i2[e2++] << 8 | i2[e2++];
            if (0 === s2 && 0 !== t3) {
              warn("parseFDSelect: The first range must have a first GID of 0 -- trying to recover.");
              t3 = 0;
            }
            const a3 = i2[e2++], n3 = i2[e2] << 8 | i2[e2 + 1];
            for (let e3 = t3; e3 < n3; ++e3) r2.push(a3);
          }
          e2 += 2;
          break;
        default:
          throw new FormatError(`parseFDSelect: Unknown format "${a2}".`);
      }
      if (r2.length !== t2) throw new FormatError("parseFDSelect: Invalid font data.");
      return new CFFFDSelect(a2, r2);
    }
  }
  class CFF {
    constructor() {
      this.header = null;
      this.names = [];
      this.topDict = null;
      this.strings = new CFFStrings();
      this.globalSubrIndex = null;
      this.encoding = null;
      this.charset = null;
      this.charStrings = null;
      this.fdArray = [];
      this.fdSelect = null;
      this.isCIDFont = false;
    }
    duplicateFirstGlyph() {
      if (this.charStrings.count >= 65535) {
        warn("Not enough space in charstrings to duplicate first glyph.");
        return;
      }
      const e2 = this.charStrings.get(0);
      this.charStrings.add(e2);
      this.isCIDFont && this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0]);
    }
    hasGlyphId(e2) {
      if (e2 < 0 || e2 >= this.charStrings.count) return false;
      return this.charStrings.get(e2).length > 0;
    }
  }
  class CFFHeader {
    constructor(e2, t2, i2, a2) {
      this.major = e2;
      this.minor = t2;
      this.hdrSize = i2;
      this.offSize = a2;
    }
  }
  class CFFStrings {
    constructor() {
      this.strings = [];
    }
    get(e2) {
      return e2 >= 0 && e2 <= 390 ? Si[e2] : e2 - ki <= this.strings.length ? this.strings[e2 - ki] : Si[0];
    }
    getSID(e2) {
      let t2 = Si.indexOf(e2);
      if (-1 !== t2) return t2;
      t2 = this.strings.indexOf(e2);
      return -1 !== t2 ? t2 + ki : -1;
    }
    add(e2) {
      this.strings.push(e2);
    }
    get count() {
      return this.strings.length;
    }
  }
  class CFFIndex {
    constructor() {
      this.objects = [];
      this.length = 0;
    }
    add(e2) {
      this.length += e2.length;
      this.objects.push(e2);
    }
    set(e2, t2) {
      this.length += t2.length - this.objects[e2].length;
      this.objects[e2] = t2;
    }
    get(e2) {
      return this.objects[e2];
    }
    get count() {
      return this.objects.length;
    }
  }
  class CFFDict {
    constructor(e2, t2) {
      this.keyToNameMap = e2.keyToNameMap;
      this.nameToKeyMap = e2.nameToKeyMap;
      this.defaults = e2.defaults;
      this.types = e2.types;
      this.opcodes = e2.opcodes;
      this.order = e2.order;
      this.strings = t2;
      this.values = /* @__PURE__ */ Object.create(null);
    }
    setByKey(e2, t2) {
      if (!(e2 in this.keyToNameMap)) return false;
      if (0 === t2.length) return true;
      for (const i3 of t2) if (isNaN(i3)) {
        warn(`Invalid CFFDict value: "${t2}" for key "${e2}".`);
        return true;
      }
      const i2 = this.types[e2];
      "num" !== i2 && "sid" !== i2 && "offset" !== i2 || (t2 = t2[0]);
      this.values[e2] = t2;
      return true;
    }
    setByName(e2, t2) {
      if (!(e2 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name "${e2}"`);
      this.values[this.nameToKeyMap[e2]] = t2;
    }
    hasName(e2) {
      return this.nameToKeyMap[e2] in this.values;
    }
    getByName(e2) {
      if (!(e2 in this.nameToKeyMap)) throw new FormatError(`Invalid dictionary name ${e2}"`);
      const t2 = this.nameToKeyMap[e2];
      return t2 in this.values ? this.values[t2] : this.defaults[t2];
    }
    removeByName(e2) {
      delete this.values[this.nameToKeyMap[e2]];
    }
    static createTables(e2) {
      const t2 = {
        keyToNameMap: {},
        nameToKeyMap: {},
        defaults: {},
        types: {},
        opcodes: {},
        order: []
      };
      for (const i2 of e2) {
        const e3 = Array.isArray(i2[0]) ? (i2[0][0] << 8) + i2[0][1] : i2[0];
        t2.keyToNameMap[e3] = i2[1];
        t2.nameToKeyMap[i2[1]] = e3;
        t2.types[e3] = i2[2];
        t2.defaults[e3] = i2[3];
        t2.opcodes[e3] = Array.isArray(i2[0]) ? i2[0] : [
          i2[0]
        ];
        t2.order.push(e3);
      }
      return t2;
    }
  }
  const Gi = [
    [
      [
        12,
        30
      ],
      "ROS",
      [
        "sid",
        "sid",
        "num"
      ],
      null
    ],
    [
      [
        12,
        20
      ],
      "SyntheticBase",
      "num",
      null
    ],
    [
      0,
      "version",
      "sid",
      null
    ],
    [
      1,
      "Notice",
      "sid",
      null
    ],
    [
      [
        12,
        0
      ],
      "Copyright",
      "sid",
      null
    ],
    [
      2,
      "FullName",
      "sid",
      null
    ],
    [
      3,
      "FamilyName",
      "sid",
      null
    ],
    [
      4,
      "Weight",
      "sid",
      null
    ],
    [
      [
        12,
        1
      ],
      "isFixedPitch",
      "num",
      0
    ],
    [
      [
        12,
        2
      ],
      "ItalicAngle",
      "num",
      0
    ],
    [
      [
        12,
        3
      ],
      "UnderlinePosition",
      "num",
      -100
    ],
    [
      [
        12,
        4
      ],
      "UnderlineThickness",
      "num",
      50
    ],
    [
      [
        12,
        5
      ],
      "PaintType",
      "num",
      0
    ],
    [
      [
        12,
        6
      ],
      "CharstringType",
      "num",
      2
    ],
    [
      [
        12,
        7
      ],
      "FontMatrix",
      [
        "num",
        "num",
        "num",
        "num",
        "num",
        "num"
      ],
      [
        1e-3,
        0,
        0,
        1e-3,
        0,
        0
      ]
    ],
    [
      13,
      "UniqueID",
      "num",
      null
    ],
    [
      5,
      "FontBBox",
      [
        "num",
        "num",
        "num",
        "num"
      ],
      [
        0,
        0,
        0,
        0
      ]
    ],
    [
      [
        12,
        8
      ],
      "StrokeWidth",
      "num",
      0
    ],
    [
      14,
      "XUID",
      "array",
      null
    ],
    [
      15,
      "charset",
      "offset",
      0
    ],
    [
      16,
      "Encoding",
      "offset",
      0
    ],
    [
      17,
      "CharStrings",
      "offset",
      0
    ],
    [
      18,
      "Private",
      [
        "offset",
        "offset"
      ],
      null
    ],
    [
      [
        12,
        21
      ],
      "PostScript",
      "sid",
      null
    ],
    [
      [
        12,
        22
      ],
      "BaseFontName",
      "sid",
      null
    ],
    [
      [
        12,
        23
      ],
      "BaseFontBlend",
      "delta",
      null
    ],
    [
      [
        12,
        31
      ],
      "CIDFontVersion",
      "num",
      0
    ],
    [
      [
        12,
        32
      ],
      "CIDFontRevision",
      "num",
      0
    ],
    [
      [
        12,
        33
      ],
      "CIDFontType",
      "num",
      0
    ],
    [
      [
        12,
        34
      ],
      "CIDCount",
      "num",
      8720
    ],
    [
      [
        12,
        35
      ],
      "UIDBase",
      "num",
      null
    ],
    [
      [
        12,
        37
      ],
      "FDSelect",
      "offset",
      null
    ],
    [
      [
        12,
        36
      ],
      "FDArray",
      "offset",
      null
    ],
    [
      [
        12,
        38
      ],
      "FontName",
      "sid",
      null
    ]
  ];
  class CFFTopDict extends CFFDict {
    static get tables() {
      return shadow(this, "tables", this.createTables(Gi));
    }
    constructor(e2) {
      super(CFFTopDict.tables, e2);
      this.privateDict = null;
    }
  }
  const xi = [
    [
      6,
      "BlueValues",
      "delta",
      null
    ],
    [
      7,
      "OtherBlues",
      "delta",
      null
    ],
    [
      8,
      "FamilyBlues",
      "delta",
      null
    ],
    [
      9,
      "FamilyOtherBlues",
      "delta",
      null
    ],
    [
      [
        12,
        9
      ],
      "BlueScale",
      "num",
      0.039625
    ],
    [
      [
        12,
        10
      ],
      "BlueShift",
      "num",
      7
    ],
    [
      [
        12,
        11
      ],
      "BlueFuzz",
      "num",
      1
    ],
    [
      10,
      "StdHW",
      "num",
      null
    ],
    [
      11,
      "StdVW",
      "num",
      null
    ],
    [
      [
        12,
        12
      ],
      "StemSnapH",
      "delta",
      null
    ],
    [
      [
        12,
        13
      ],
      "StemSnapV",
      "delta",
      null
    ],
    [
      [
        12,
        14
      ],
      "ForceBold",
      "num",
      0
    ],
    [
      [
        12,
        17
      ],
      "LanguageGroup",
      "num",
      0
    ],
    [
      [
        12,
        18
      ],
      "ExpansionFactor",
      "num",
      0.06
    ],
    [
      [
        12,
        19
      ],
      "initialRandomSeed",
      "num",
      0
    ],
    [
      20,
      "defaultWidthX",
      "num",
      0
    ],
    [
      21,
      "nominalWidthX",
      "num",
      0
    ],
    [
      19,
      "Subrs",
      "offset",
      null
    ]
  ];
  class CFFPrivateDict extends CFFDict {
    static get tables() {
      return shadow(this, "tables", this.createTables(xi));
    }
    constructor(e2) {
      super(CFFPrivateDict.tables, e2);
      this.subrsIndex = null;
    }
  }
  const Mi = {
    ISO_ADOBE: 0,
    EXPERT: 1,
    EXPERT_SUBSET: 2
  };
  class CFFCharset {
    constructor(e2, t2, i2, a2) {
      this.predefined = e2;
      this.format = t2;
      this.charset = i2;
      this.raw = a2;
    }
  }
  class CFFEncoding {
    constructor(e2, t2, i2, a2) {
      this.predefined = e2;
      this.format = t2;
      this.encoding = i2;
      this.raw = a2;
    }
  }
  class CFFFDSelect {
    constructor(e2, t2) {
      this.format = e2;
      this.fdSelect = t2;
    }
    getFDIndex(e2) {
      return e2 < 0 || e2 >= this.fdSelect.length ? -1 : this.fdSelect[e2];
    }
  }
  class CFFOffsetTracker {
    constructor() {
      this.offsets = /* @__PURE__ */ Object.create(null);
    }
    isTracking(e2) {
      return e2 in this.offsets;
    }
    track(e2, t2) {
      if (e2 in this.offsets) throw new FormatError(`Already tracking location of ${e2}`);
      this.offsets[e2] = t2;
    }
    offset(e2) {
      for (const t2 in this.offsets) this.offsets[t2] += e2;
    }
    setEntryLocation(e2, t2, i2) {
      if (!(e2 in this.offsets)) throw new FormatError(`Not tracking location of ${e2}`);
      const a2 = i2.data, r2 = this.offsets[e2];
      for (let e3 = 0, i3 = t2.length; e3 < i3; ++e3) {
        const i4 = 5 * e3 + r2, s2 = i4 + 1, n2 = i4 + 2, o2 = i4 + 3, g2 = i4 + 4;
        if (29 !== a2[i4] || 0 !== a2[s2] || 0 !== a2[n2] || 0 !== a2[o2] || 0 !== a2[g2]) throw new FormatError("writing to an offset that is not empty");
        const c2 = t2[e3];
        a2[i4] = 29;
        a2[s2] = c2 >> 24 & 255;
        a2[n2] = c2 >> 16 & 255;
        a2[o2] = c2 >> 8 & 255;
        a2[g2] = 255 & c2;
      }
    }
  }
  class CFFCompiler {
    constructor(e2) {
      this.cff = e2;
    }
    compile() {
      const e2 = this.cff, t2 = {
        data: [],
        length: 0,
        add(e3) {
          try {
            this.data.push(...e3);
          } catch {
            this.data = this.data.concat(e3);
          }
          this.length = this.data.length;
        }
      }, i2 = this.compileHeader(e2.header);
      t2.add(i2);
      const a2 = this.compileNameIndex(e2.names);
      t2.add(a2);
      if (e2.isCIDFont && e2.topDict.hasName("FontMatrix")) {
        const t3 = e2.topDict.getByName("FontMatrix");
        e2.topDict.removeByName("FontMatrix");
        for (const i3 of e2.fdArray) {
          let e3 = t3.slice(0);
          i3.hasName("FontMatrix") && (e3 = Util.transform(e3, i3.getByName("FontMatrix")));
          i3.setByName("FontMatrix", e3);
        }
      }
      const r2 = e2.topDict.getByName("XUID");
      (r2 == null ? void 0 : r2.length) > 16 && e2.topDict.removeByName("XUID");
      e2.topDict.setByName("charset", 0);
      let s2 = this.compileTopDicts([
        e2.topDict
      ], t2.length, e2.isCIDFont);
      t2.add(s2.output);
      const n2 = s2.trackers[0], o2 = this.compileStringIndex(e2.strings.strings);
      t2.add(o2);
      const g2 = this.compileIndex(e2.globalSubrIndex);
      t2.add(g2);
      if (e2.encoding && e2.topDict.hasName("Encoding")) if (e2.encoding.predefined) n2.setEntryLocation("Encoding", [
        e2.encoding.format
      ], t2);
      else {
        const i3 = this.compileEncoding(e2.encoding);
        n2.setEntryLocation("Encoding", [
          t2.length
        ], t2);
        t2.add(i3);
      }
      const c2 = this.compileCharset(e2.charset, e2.charStrings.count, e2.strings, e2.isCIDFont);
      n2.setEntryLocation("charset", [
        t2.length
      ], t2);
      t2.add(c2);
      const C2 = this.compileCharStrings(e2.charStrings);
      n2.setEntryLocation("CharStrings", [
        t2.length
      ], t2);
      t2.add(C2);
      if (e2.isCIDFont) {
        n2.setEntryLocation("FDSelect", [
          t2.length
        ], t2);
        const i3 = this.compileFDSelect(e2.fdSelect);
        t2.add(i3);
        s2 = this.compileTopDicts(e2.fdArray, t2.length, true);
        n2.setEntryLocation("FDArray", [
          t2.length
        ], t2);
        t2.add(s2.output);
        const a3 = s2.trackers;
        this.compilePrivateDicts(e2.fdArray, a3, t2);
      }
      this.compilePrivateDicts([
        e2.topDict
      ], [
        n2
      ], t2);
      t2.add([
        0
      ]);
      return t2.data;
    }
    encodeNumber(e2) {
      return Number.isInteger(e2) ? this.encodeInteger(e2) : this.encodeFloat(e2);
    }
    static get EncodeFloatRegExp() {
      return shadow(this, "EncodeFloatRegExp", /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/);
    }
    encodeFloat(e2) {
      let t2 = e2.toString();
      const i2 = CFFCompiler.EncodeFloatRegExp.exec(t2);
      if (i2) {
        const a3 = parseFloat("1e" + ((i2[2] ? +i2[2] : 0) + i2[1].length));
        t2 = (Math.round(e2 * a3) / a3).toString();
      }
      let a2, r2, s2 = "";
      for (a2 = 0, r2 = t2.length; a2 < r2; ++a2) {
        const e3 = t2[a2];
        s2 += "e" === e3 ? "-" === t2[++a2] ? "c" : "b" : "." === e3 ? "a" : "-" === e3 ? "e" : e3;
      }
      s2 += 1 & s2.length ? "f" : "ff";
      const n2 = [
        30
      ];
      for (a2 = 0, r2 = s2.length; a2 < r2; a2 += 2) n2.push(parseInt(s2.substring(a2, a2 + 2), 16));
      return n2;
    }
    encodeInteger(e2) {
      let t2;
      t2 = e2 >= -107 && e2 <= 107 ? [
        e2 + 139
      ] : e2 >= 108 && e2 <= 1131 ? [
        247 + ((e2 -= 108) >> 8),
        255 & e2
      ] : e2 >= -1131 && e2 <= -108 ? [
        251 + ((e2 = -e2 - 108) >> 8),
        255 & e2
      ] : e2 >= -32768 && e2 <= 32767 ? [
        28,
        e2 >> 8 & 255,
        255 & e2
      ] : [
        29,
        e2 >> 24 & 255,
        e2 >> 16 & 255,
        e2 >> 8 & 255,
        255 & e2
      ];
      return t2;
    }
    compileHeader(e2) {
      return [
        e2.major,
        e2.minor,
        4,
        e2.offSize
      ];
    }
    compileNameIndex(e2) {
      const t2 = new CFFIndex();
      for (const i2 of e2) {
        const e3 = Math.min(i2.length, 127);
        let a2 = new Array(e3);
        for (let t3 = 0; t3 < e3; t3++) {
          let e4 = i2[t3];
          (e4 < "!" || e4 > "~" || "[" === e4 || "]" === e4 || "(" === e4 || ")" === e4 || "{" === e4 || "}" === e4 || "<" === e4 || ">" === e4 || "/" === e4 || "%" === e4) && (e4 = "_");
          a2[t3] = e4;
        }
        a2 = a2.join("");
        "" === a2 && (a2 = "Bad_Font_Name");
        t2.add(stringToBytes(a2));
      }
      return this.compileIndex(t2);
    }
    compileTopDicts(e2, t2, i2) {
      const a2 = [];
      let r2 = new CFFIndex();
      for (const s2 of e2) {
        if (i2) {
          s2.removeByName("CIDFontVersion");
          s2.removeByName("CIDFontRevision");
          s2.removeByName("CIDFontType");
          s2.removeByName("CIDCount");
          s2.removeByName("UIDBase");
        }
        const e3 = new CFFOffsetTracker(), n2 = this.compileDict(s2, e3);
        a2.push(e3);
        r2.add(n2);
        e3.offset(t2);
      }
      r2 = this.compileIndex(r2, a2);
      return {
        trackers: a2,
        output: r2
      };
    }
    compilePrivateDicts(e2, t2, i2) {
      for (let a2 = 0, r2 = e2.length; a2 < r2; ++a2) {
        const r3 = e2[a2], s2 = r3.privateDict;
        if (!s2 || !r3.hasName("Private")) throw new FormatError("There must be a private dictionary.");
        const n2 = new CFFOffsetTracker(), o2 = this.compileDict(s2, n2);
        let g2 = i2.length;
        n2.offset(g2);
        o2.length || (g2 = 0);
        t2[a2].setEntryLocation("Private", [
          o2.length,
          g2
        ], i2);
        i2.add(o2);
        if (s2.subrsIndex && s2.hasName("Subrs")) {
          const e3 = this.compileIndex(s2.subrsIndex);
          n2.setEntryLocation("Subrs", [
            o2.length
          ], i2);
          i2.add(e3);
        }
      }
    }
    compileDict(e2, t2) {
      const i2 = [];
      for (const a2 of e2.order) {
        if (!(a2 in e2.values)) continue;
        let r2 = e2.values[a2], s2 = e2.types[a2];
        Array.isArray(s2) || (s2 = [
          s2
        ]);
        Array.isArray(r2) || (r2 = [
          r2
        ]);
        if (0 !== r2.length) {
          for (let n2 = 0, o2 = s2.length; n2 < o2; ++n2) {
            const o3 = s2[n2], g2 = r2[n2];
            switch (o3) {
              case "num":
              case "sid":
                i2.push(...this.encodeNumber(g2));
                break;
              case "offset":
                const s3 = e2.keyToNameMap[a2];
                t2.isTracking(s3) || t2.track(s3, i2.length);
                i2.push(29, 0, 0, 0, 0);
                break;
              case "array":
              case "delta":
                i2.push(...this.encodeNumber(g2));
                for (let e3 = 1, t3 = r2.length; e3 < t3; ++e3) i2.push(...this.encodeNumber(r2[e3]));
                break;
              default:
                throw new FormatError(`Unknown data type of ${o3}`);
            }
          }
          i2.push(...e2.opcodes[a2]);
        }
      }
      return i2;
    }
    compileStringIndex(e2) {
      const t2 = new CFFIndex();
      for (const i2 of e2) t2.add(stringToBytes(i2));
      return this.compileIndex(t2);
    }
    compileCharStrings(e2) {
      const t2 = new CFFIndex();
      for (let i2 = 0; i2 < e2.count; i2++) {
        const a2 = e2.get(i2);
        0 !== a2.length ? t2.add(a2) : t2.add(new Uint8Array([
          139,
          14
        ]));
      }
      return this.compileIndex(t2);
    }
    compileCharset(e2, t2, i2, a2) {
      let r2;
      const s2 = t2 - 1;
      if (a2) r2 = new Uint8Array([
        2,
        0,
        0,
        s2 >> 8 & 255,
        255 & s2
      ]);
      else {
        r2 = new Uint8Array(1 + 2 * s2);
        r2[0] = 0;
        let t3 = 0;
        const a3 = e2.charset.length;
        let n2 = false;
        for (let s3 = 1; s3 < r2.length; s3 += 2) {
          let o2 = 0;
          if (t3 < a3) {
            const a4 = e2.charset[t3++];
            o2 = i2.getSID(a4);
            if (-1 === o2) {
              o2 = 0;
              if (!n2) {
                n2 = true;
                warn(`Couldn't find ${a4} in CFF strings`);
              }
            }
          }
          r2[s3] = o2 >> 8 & 255;
          r2[s3 + 1] = 255 & o2;
        }
      }
      return this.compileTypedArray(r2);
    }
    compileEncoding(e2) {
      return this.compileTypedArray(e2.raw);
    }
    compileFDSelect(e2) {
      const t2 = e2.format;
      let i2, a2;
      switch (t2) {
        case 0:
          i2 = new Uint8Array(1 + e2.fdSelect.length);
          i2[0] = t2;
          for (a2 = 0; a2 < e2.fdSelect.length; a2++) i2[a2 + 1] = e2.fdSelect[a2];
          break;
        case 3:
          const r2 = 0;
          let s2 = e2.fdSelect[0];
          const n2 = [
            t2,
            0,
            0,
            r2 >> 8 & 255,
            255 & r2,
            s2
          ];
          for (a2 = 1; a2 < e2.fdSelect.length; a2++) {
            const t3 = e2.fdSelect[a2];
            if (t3 !== s2) {
              n2.push(a2 >> 8 & 255, 255 & a2, t3);
              s2 = t3;
            }
          }
          const o2 = (n2.length - 3) / 3;
          n2[1] = o2 >> 8 & 255;
          n2[2] = 255 & o2;
          n2.push(a2 >> 8 & 255, 255 & a2);
          i2 = new Uint8Array(n2);
      }
      return this.compileTypedArray(i2);
    }
    compileTypedArray(e2) {
      return Array.from(e2);
    }
    compileIndex(e2, t2 = []) {
      const i2 = e2.objects, a2 = i2.length;
      if (0 === a2) return [
        0,
        0
      ];
      const r2 = [
        a2 >> 8 & 255,
        255 & a2
      ];
      let s2, n2, o2 = 1;
      for (s2 = 0; s2 < a2; ++s2) o2 += i2[s2].length;
      n2 = o2 < 256 ? 1 : o2 < 65536 ? 2 : o2 < 16777216 ? 3 : 4;
      r2.push(n2);
      let g2 = 1;
      for (s2 = 0; s2 < a2 + 1; s2++) {
        1 === n2 ? r2.push(255 & g2) : 2 === n2 ? r2.push(g2 >> 8 & 255, 255 & g2) : 3 === n2 ? r2.push(g2 >> 16 & 255, g2 >> 8 & 255, 255 & g2) : r2.push(g2 >>> 24 & 255, g2 >> 16 & 255, g2 >> 8 & 255, 255 & g2);
        i2[s2] && (g2 += i2[s2].length);
      }
      for (s2 = 0; s2 < a2; s2++) {
        t2[s2] && t2[s2].offset(r2.length);
        r2.push(...i2[s2]);
      }
      return r2;
    }
  }
  const Hi = getLookupTableFactory(function(e2) {
    e2.A = 65;
    e2.AE = 198;
    e2.AEacute = 508;
    e2.AEmacron = 482;
    e2.AEsmall = 63462;
    e2.Aacute = 193;
    e2.Aacutesmall = 63457;
    e2.Abreve = 258;
    e2.Abreveacute = 7854;
    e2.Abrevecyrillic = 1232;
    e2.Abrevedotbelow = 7862;
    e2.Abrevegrave = 7856;
    e2.Abrevehookabove = 7858;
    e2.Abrevetilde = 7860;
    e2.Acaron = 461;
    e2.Acircle = 9398;
    e2.Acircumflex = 194;
    e2.Acircumflexacute = 7844;
    e2.Acircumflexdotbelow = 7852;
    e2.Acircumflexgrave = 7846;
    e2.Acircumflexhookabove = 7848;
    e2.Acircumflexsmall = 63458;
    e2.Acircumflextilde = 7850;
    e2.Acute = 63177;
    e2.Acutesmall = 63412;
    e2.Acyrillic = 1040;
    e2.Adblgrave = 512;
    e2.Adieresis = 196;
    e2.Adieresiscyrillic = 1234;
    e2.Adieresismacron = 478;
    e2.Adieresissmall = 63460;
    e2.Adotbelow = 7840;
    e2.Adotmacron = 480;
    e2.Agrave = 192;
    e2.Agravesmall = 63456;
    e2.Ahookabove = 7842;
    e2.Aiecyrillic = 1236;
    e2.Ainvertedbreve = 514;
    e2.Alpha = 913;
    e2.Alphatonos = 902;
    e2.Amacron = 256;
    e2.Amonospace = 65313;
    e2.Aogonek = 260;
    e2.Aring = 197;
    e2.Aringacute = 506;
    e2.Aringbelow = 7680;
    e2.Aringsmall = 63461;
    e2.Asmall = 63329;
    e2.Atilde = 195;
    e2.Atildesmall = 63459;
    e2.Aybarmenian = 1329;
    e2.B = 66;
    e2.Bcircle = 9399;
    e2.Bdotaccent = 7682;
    e2.Bdotbelow = 7684;
    e2.Becyrillic = 1041;
    e2.Benarmenian = 1330;
    e2.Beta = 914;
    e2.Bhook = 385;
    e2.Blinebelow = 7686;
    e2.Bmonospace = 65314;
    e2.Brevesmall = 63220;
    e2.Bsmall = 63330;
    e2.Btopbar = 386;
    e2.C = 67;
    e2.Caarmenian = 1342;
    e2.Cacute = 262;
    e2.Caron = 63178;
    e2.Caronsmall = 63221;
    e2.Ccaron = 268;
    e2.Ccedilla = 199;
    e2.Ccedillaacute = 7688;
    e2.Ccedillasmall = 63463;
    e2.Ccircle = 9400;
    e2.Ccircumflex = 264;
    e2.Cdot = 266;
    e2.Cdotaccent = 266;
    e2.Cedillasmall = 63416;
    e2.Chaarmenian = 1353;
    e2.Cheabkhasiancyrillic = 1212;
    e2.Checyrillic = 1063;
    e2.Chedescenderabkhasiancyrillic = 1214;
    e2.Chedescendercyrillic = 1206;
    e2.Chedieresiscyrillic = 1268;
    e2.Cheharmenian = 1347;
    e2.Chekhakassiancyrillic = 1227;
    e2.Cheverticalstrokecyrillic = 1208;
    e2.Chi = 935;
    e2.Chook = 391;
    e2.Circumflexsmall = 63222;
    e2.Cmonospace = 65315;
    e2.Coarmenian = 1361;
    e2.Csmall = 63331;
    e2.D = 68;
    e2.DZ = 497;
    e2.DZcaron = 452;
    e2.Daarmenian = 1332;
    e2.Dafrican = 393;
    e2.Dcaron = 270;
    e2.Dcedilla = 7696;
    e2.Dcircle = 9401;
    e2.Dcircumflexbelow = 7698;
    e2.Dcroat = 272;
    e2.Ddotaccent = 7690;
    e2.Ddotbelow = 7692;
    e2.Decyrillic = 1044;
    e2.Deicoptic = 1006;
    e2.Delta = 8710;
    e2.Deltagreek = 916;
    e2.Dhook = 394;
    e2.Dieresis = 63179;
    e2.DieresisAcute = 63180;
    e2.DieresisGrave = 63181;
    e2.Dieresissmall = 63400;
    e2.Digammagreek = 988;
    e2.Djecyrillic = 1026;
    e2.Dlinebelow = 7694;
    e2.Dmonospace = 65316;
    e2.Dotaccentsmall = 63223;
    e2.Dslash = 272;
    e2.Dsmall = 63332;
    e2.Dtopbar = 395;
    e2.Dz = 498;
    e2.Dzcaron = 453;
    e2.Dzeabkhasiancyrillic = 1248;
    e2.Dzecyrillic = 1029;
    e2.Dzhecyrillic = 1039;
    e2.E = 69;
    e2.Eacute = 201;
    e2.Eacutesmall = 63465;
    e2.Ebreve = 276;
    e2.Ecaron = 282;
    e2.Ecedillabreve = 7708;
    e2.Echarmenian = 1333;
    e2.Ecircle = 9402;
    e2.Ecircumflex = 202;
    e2.Ecircumflexacute = 7870;
    e2.Ecircumflexbelow = 7704;
    e2.Ecircumflexdotbelow = 7878;
    e2.Ecircumflexgrave = 7872;
    e2.Ecircumflexhookabove = 7874;
    e2.Ecircumflexsmall = 63466;
    e2.Ecircumflextilde = 7876;
    e2.Ecyrillic = 1028;
    e2.Edblgrave = 516;
    e2.Edieresis = 203;
    e2.Edieresissmall = 63467;
    e2.Edot = 278;
    e2.Edotaccent = 278;
    e2.Edotbelow = 7864;
    e2.Efcyrillic = 1060;
    e2.Egrave = 200;
    e2.Egravesmall = 63464;
    e2.Eharmenian = 1335;
    e2.Ehookabove = 7866;
    e2.Eightroman = 8551;
    e2.Einvertedbreve = 518;
    e2.Eiotifiedcyrillic = 1124;
    e2.Elcyrillic = 1051;
    e2.Elevenroman = 8554;
    e2.Emacron = 274;
    e2.Emacronacute = 7702;
    e2.Emacrongrave = 7700;
    e2.Emcyrillic = 1052;
    e2.Emonospace = 65317;
    e2.Encyrillic = 1053;
    e2.Endescendercyrillic = 1186;
    e2.Eng = 330;
    e2.Enghecyrillic = 1188;
    e2.Enhookcyrillic = 1223;
    e2.Eogonek = 280;
    e2.Eopen = 400;
    e2.Epsilon = 917;
    e2.Epsilontonos = 904;
    e2.Ercyrillic = 1056;
    e2.Ereversed = 398;
    e2.Ereversedcyrillic = 1069;
    e2.Escyrillic = 1057;
    e2.Esdescendercyrillic = 1194;
    e2.Esh = 425;
    e2.Esmall = 63333;
    e2.Eta = 919;
    e2.Etarmenian = 1336;
    e2.Etatonos = 905;
    e2.Eth = 208;
    e2.Ethsmall = 63472;
    e2.Etilde = 7868;
    e2.Etildebelow = 7706;
    e2.Euro = 8364;
    e2.Ezh = 439;
    e2.Ezhcaron = 494;
    e2.Ezhreversed = 440;
    e2.F = 70;
    e2.Fcircle = 9403;
    e2.Fdotaccent = 7710;
    e2.Feharmenian = 1366;
    e2.Feicoptic = 996;
    e2.Fhook = 401;
    e2.Fitacyrillic = 1138;
    e2.Fiveroman = 8548;
    e2.Fmonospace = 65318;
    e2.Fourroman = 8547;
    e2.Fsmall = 63334;
    e2.G = 71;
    e2.GBsquare = 13191;
    e2.Gacute = 500;
    e2.Gamma = 915;
    e2.Gammaafrican = 404;
    e2.Gangiacoptic = 1002;
    e2.Gbreve = 286;
    e2.Gcaron = 486;
    e2.Gcedilla = 290;
    e2.Gcircle = 9404;
    e2.Gcircumflex = 284;
    e2.Gcommaaccent = 290;
    e2.Gdot = 288;
    e2.Gdotaccent = 288;
    e2.Gecyrillic = 1043;
    e2.Ghadarmenian = 1346;
    e2.Ghemiddlehookcyrillic = 1172;
    e2.Ghestrokecyrillic = 1170;
    e2.Gheupturncyrillic = 1168;
    e2.Ghook = 403;
    e2.Gimarmenian = 1331;
    e2.Gjecyrillic = 1027;
    e2.Gmacron = 7712;
    e2.Gmonospace = 65319;
    e2.Grave = 63182;
    e2.Gravesmall = 63328;
    e2.Gsmall = 63335;
    e2.Gsmallhook = 667;
    e2.Gstroke = 484;
    e2.H = 72;
    e2.H18533 = 9679;
    e2.H18543 = 9642;
    e2.H18551 = 9643;
    e2.H22073 = 9633;
    e2.HPsquare = 13259;
    e2.Haabkhasiancyrillic = 1192;
    e2.Hadescendercyrillic = 1202;
    e2.Hardsigncyrillic = 1066;
    e2.Hbar = 294;
    e2.Hbrevebelow = 7722;
    e2.Hcedilla = 7720;
    e2.Hcircle = 9405;
    e2.Hcircumflex = 292;
    e2.Hdieresis = 7718;
    e2.Hdotaccent = 7714;
    e2.Hdotbelow = 7716;
    e2.Hmonospace = 65320;
    e2.Hoarmenian = 1344;
    e2.Horicoptic = 1e3;
    e2.Hsmall = 63336;
    e2.Hungarumlaut = 63183;
    e2.Hungarumlautsmall = 63224;
    e2.Hzsquare = 13200;
    e2.I = 73;
    e2.IAcyrillic = 1071;
    e2.IJ = 306;
    e2.IUcyrillic = 1070;
    e2.Iacute = 205;
    e2.Iacutesmall = 63469;
    e2.Ibreve = 300;
    e2.Icaron = 463;
    e2.Icircle = 9406;
    e2.Icircumflex = 206;
    e2.Icircumflexsmall = 63470;
    e2.Icyrillic = 1030;
    e2.Idblgrave = 520;
    e2.Idieresis = 207;
    e2.Idieresisacute = 7726;
    e2.Idieresiscyrillic = 1252;
    e2.Idieresissmall = 63471;
    e2.Idot = 304;
    e2.Idotaccent = 304;
    e2.Idotbelow = 7882;
    e2.Iebrevecyrillic = 1238;
    e2.Iecyrillic = 1045;
    e2.Ifraktur = 8465;
    e2.Igrave = 204;
    e2.Igravesmall = 63468;
    e2.Ihookabove = 7880;
    e2.Iicyrillic = 1048;
    e2.Iinvertedbreve = 522;
    e2.Iishortcyrillic = 1049;
    e2.Imacron = 298;
    e2.Imacroncyrillic = 1250;
    e2.Imonospace = 65321;
    e2.Iniarmenian = 1339;
    e2.Iocyrillic = 1025;
    e2.Iogonek = 302;
    e2.Iota = 921;
    e2.Iotaafrican = 406;
    e2.Iotadieresis = 938;
    e2.Iotatonos = 906;
    e2.Ismall = 63337;
    e2.Istroke = 407;
    e2.Itilde = 296;
    e2.Itildebelow = 7724;
    e2.Izhitsacyrillic = 1140;
    e2.Izhitsadblgravecyrillic = 1142;
    e2.J = 74;
    e2.Jaarmenian = 1345;
    e2.Jcircle = 9407;
    e2.Jcircumflex = 308;
    e2.Jecyrillic = 1032;
    e2.Jheharmenian = 1355;
    e2.Jmonospace = 65322;
    e2.Jsmall = 63338;
    e2.K = 75;
    e2.KBsquare = 13189;
    e2.KKsquare = 13261;
    e2.Kabashkircyrillic = 1184;
    e2.Kacute = 7728;
    e2.Kacyrillic = 1050;
    e2.Kadescendercyrillic = 1178;
    e2.Kahookcyrillic = 1219;
    e2.Kappa = 922;
    e2.Kastrokecyrillic = 1182;
    e2.Kaverticalstrokecyrillic = 1180;
    e2.Kcaron = 488;
    e2.Kcedilla = 310;
    e2.Kcircle = 9408;
    e2.Kcommaaccent = 310;
    e2.Kdotbelow = 7730;
    e2.Keharmenian = 1364;
    e2.Kenarmenian = 1343;
    e2.Khacyrillic = 1061;
    e2.Kheicoptic = 998;
    e2.Khook = 408;
    e2.Kjecyrillic = 1036;
    e2.Klinebelow = 7732;
    e2.Kmonospace = 65323;
    e2.Koppacyrillic = 1152;
    e2.Koppagreek = 990;
    e2.Ksicyrillic = 1134;
    e2.Ksmall = 63339;
    e2.L = 76;
    e2.LJ = 455;
    e2.LL = 63167;
    e2.Lacute = 313;
    e2.Lambda = 923;
    e2.Lcaron = 317;
    e2.Lcedilla = 315;
    e2.Lcircle = 9409;
    e2.Lcircumflexbelow = 7740;
    e2.Lcommaaccent = 315;
    e2.Ldot = 319;
    e2.Ldotaccent = 319;
    e2.Ldotbelow = 7734;
    e2.Ldotbelowmacron = 7736;
    e2.Liwnarmenian = 1340;
    e2.Lj = 456;
    e2.Ljecyrillic = 1033;
    e2.Llinebelow = 7738;
    e2.Lmonospace = 65324;
    e2.Lslash = 321;
    e2.Lslashsmall = 63225;
    e2.Lsmall = 63340;
    e2.M = 77;
    e2.MBsquare = 13190;
    e2.Macron = 63184;
    e2.Macronsmall = 63407;
    e2.Macute = 7742;
    e2.Mcircle = 9410;
    e2.Mdotaccent = 7744;
    e2.Mdotbelow = 7746;
    e2.Menarmenian = 1348;
    e2.Mmonospace = 65325;
    e2.Msmall = 63341;
    e2.Mturned = 412;
    e2.Mu = 924;
    e2.N = 78;
    e2.NJ = 458;
    e2.Nacute = 323;
    e2.Ncaron = 327;
    e2.Ncedilla = 325;
    e2.Ncircle = 9411;
    e2.Ncircumflexbelow = 7754;
    e2.Ncommaaccent = 325;
    e2.Ndotaccent = 7748;
    e2.Ndotbelow = 7750;
    e2.Nhookleft = 413;
    e2.Nineroman = 8552;
    e2.Nj = 459;
    e2.Njecyrillic = 1034;
    e2.Nlinebelow = 7752;
    e2.Nmonospace = 65326;
    e2.Nowarmenian = 1350;
    e2.Nsmall = 63342;
    e2.Ntilde = 209;
    e2.Ntildesmall = 63473;
    e2.Nu = 925;
    e2.O = 79;
    e2.OE = 338;
    e2.OEsmall = 63226;
    e2.Oacute = 211;
    e2.Oacutesmall = 63475;
    e2.Obarredcyrillic = 1256;
    e2.Obarreddieresiscyrillic = 1258;
    e2.Obreve = 334;
    e2.Ocaron = 465;
    e2.Ocenteredtilde = 415;
    e2.Ocircle = 9412;
    e2.Ocircumflex = 212;
    e2.Ocircumflexacute = 7888;
    e2.Ocircumflexdotbelow = 7896;
    e2.Ocircumflexgrave = 7890;
    e2.Ocircumflexhookabove = 7892;
    e2.Ocircumflexsmall = 63476;
    e2.Ocircumflextilde = 7894;
    e2.Ocyrillic = 1054;
    e2.Odblacute = 336;
    e2.Odblgrave = 524;
    e2.Odieresis = 214;
    e2.Odieresiscyrillic = 1254;
    e2.Odieresissmall = 63478;
    e2.Odotbelow = 7884;
    e2.Ogoneksmall = 63227;
    e2.Ograve = 210;
    e2.Ogravesmall = 63474;
    e2.Oharmenian = 1365;
    e2.Ohm = 8486;
    e2.Ohookabove = 7886;
    e2.Ohorn = 416;
    e2.Ohornacute = 7898;
    e2.Ohorndotbelow = 7906;
    e2.Ohorngrave = 7900;
    e2.Ohornhookabove = 7902;
    e2.Ohorntilde = 7904;
    e2.Ohungarumlaut = 336;
    e2.Oi = 418;
    e2.Oinvertedbreve = 526;
    e2.Omacron = 332;
    e2.Omacronacute = 7762;
    e2.Omacrongrave = 7760;
    e2.Omega = 8486;
    e2.Omegacyrillic = 1120;
    e2.Omegagreek = 937;
    e2.Omegaroundcyrillic = 1146;
    e2.Omegatitlocyrillic = 1148;
    e2.Omegatonos = 911;
    e2.Omicron = 927;
    e2.Omicrontonos = 908;
    e2.Omonospace = 65327;
    e2.Oneroman = 8544;
    e2.Oogonek = 490;
    e2.Oogonekmacron = 492;
    e2.Oopen = 390;
    e2.Oslash = 216;
    e2.Oslashacute = 510;
    e2.Oslashsmall = 63480;
    e2.Osmall = 63343;
    e2.Ostrokeacute = 510;
    e2.Otcyrillic = 1150;
    e2.Otilde = 213;
    e2.Otildeacute = 7756;
    e2.Otildedieresis = 7758;
    e2.Otildesmall = 63477;
    e2.P = 80;
    e2.Pacute = 7764;
    e2.Pcircle = 9413;
    e2.Pdotaccent = 7766;
    e2.Pecyrillic = 1055;
    e2.Peharmenian = 1354;
    e2.Pemiddlehookcyrillic = 1190;
    e2.Phi = 934;
    e2.Phook = 420;
    e2.Pi = 928;
    e2.Piwrarmenian = 1363;
    e2.Pmonospace = 65328;
    e2.Psi = 936;
    e2.Psicyrillic = 1136;
    e2.Psmall = 63344;
    e2.Q = 81;
    e2.Qcircle = 9414;
    e2.Qmonospace = 65329;
    e2.Qsmall = 63345;
    e2.R = 82;
    e2.Raarmenian = 1356;
    e2.Racute = 340;
    e2.Rcaron = 344;
    e2.Rcedilla = 342;
    e2.Rcircle = 9415;
    e2.Rcommaaccent = 342;
    e2.Rdblgrave = 528;
    e2.Rdotaccent = 7768;
    e2.Rdotbelow = 7770;
    e2.Rdotbelowmacron = 7772;
    e2.Reharmenian = 1360;
    e2.Rfraktur = 8476;
    e2.Rho = 929;
    e2.Ringsmall = 63228;
    e2.Rinvertedbreve = 530;
    e2.Rlinebelow = 7774;
    e2.Rmonospace = 65330;
    e2.Rsmall = 63346;
    e2.Rsmallinverted = 641;
    e2.Rsmallinvertedsuperior = 694;
    e2.S = 83;
    e2.SF010000 = 9484;
    e2.SF020000 = 9492;
    e2.SF030000 = 9488;
    e2.SF040000 = 9496;
    e2.SF050000 = 9532;
    e2.SF060000 = 9516;
    e2.SF070000 = 9524;
    e2.SF080000 = 9500;
    e2.SF090000 = 9508;
    e2.SF100000 = 9472;
    e2.SF110000 = 9474;
    e2.SF190000 = 9569;
    e2.SF200000 = 9570;
    e2.SF210000 = 9558;
    e2.SF220000 = 9557;
    e2.SF230000 = 9571;
    e2.SF240000 = 9553;
    e2.SF250000 = 9559;
    e2.SF260000 = 9565;
    e2.SF270000 = 9564;
    e2.SF280000 = 9563;
    e2.SF360000 = 9566;
    e2.SF370000 = 9567;
    e2.SF380000 = 9562;
    e2.SF390000 = 9556;
    e2.SF400000 = 9577;
    e2.SF410000 = 9574;
    e2.SF420000 = 9568;
    e2.SF430000 = 9552;
    e2.SF440000 = 9580;
    e2.SF450000 = 9575;
    e2.SF460000 = 9576;
    e2.SF470000 = 9572;
    e2.SF480000 = 9573;
    e2.SF490000 = 9561;
    e2.SF500000 = 9560;
    e2.SF510000 = 9554;
    e2.SF520000 = 9555;
    e2.SF530000 = 9579;
    e2.SF540000 = 9578;
    e2.Sacute = 346;
    e2.Sacutedotaccent = 7780;
    e2.Sampigreek = 992;
    e2.Scaron = 352;
    e2.Scarondotaccent = 7782;
    e2.Scaronsmall = 63229;
    e2.Scedilla = 350;
    e2.Schwa = 399;
    e2.Schwacyrillic = 1240;
    e2.Schwadieresiscyrillic = 1242;
    e2.Scircle = 9416;
    e2.Scircumflex = 348;
    e2.Scommaaccent = 536;
    e2.Sdotaccent = 7776;
    e2.Sdotbelow = 7778;
    e2.Sdotbelowdotaccent = 7784;
    e2.Seharmenian = 1357;
    e2.Sevenroman = 8550;
    e2.Shaarmenian = 1351;
    e2.Shacyrillic = 1064;
    e2.Shchacyrillic = 1065;
    e2.Sheicoptic = 994;
    e2.Shhacyrillic = 1210;
    e2.Shimacoptic = 1004;
    e2.Sigma = 931;
    e2.Sixroman = 8549;
    e2.Smonospace = 65331;
    e2.Softsigncyrillic = 1068;
    e2.Ssmall = 63347;
    e2.Stigmagreek = 986;
    e2.T = 84;
    e2.Tau = 932;
    e2.Tbar = 358;
    e2.Tcaron = 356;
    e2.Tcedilla = 354;
    e2.Tcircle = 9417;
    e2.Tcircumflexbelow = 7792;
    e2.Tcommaaccent = 354;
    e2.Tdotaccent = 7786;
    e2.Tdotbelow = 7788;
    e2.Tecyrillic = 1058;
    e2.Tedescendercyrillic = 1196;
    e2.Tenroman = 8553;
    e2.Tetsecyrillic = 1204;
    e2.Theta = 920;
    e2.Thook = 428;
    e2.Thorn = 222;
    e2.Thornsmall = 63486;
    e2.Threeroman = 8546;
    e2.Tildesmall = 63230;
    e2.Tiwnarmenian = 1359;
    e2.Tlinebelow = 7790;
    e2.Tmonospace = 65332;
    e2.Toarmenian = 1337;
    e2.Tonefive = 444;
    e2.Tonesix = 388;
    e2.Tonetwo = 423;
    e2.Tretroflexhook = 430;
    e2.Tsecyrillic = 1062;
    e2.Tshecyrillic = 1035;
    e2.Tsmall = 63348;
    e2.Twelveroman = 8555;
    e2.Tworoman = 8545;
    e2.U = 85;
    e2.Uacute = 218;
    e2.Uacutesmall = 63482;
    e2.Ubreve = 364;
    e2.Ucaron = 467;
    e2.Ucircle = 9418;
    e2.Ucircumflex = 219;
    e2.Ucircumflexbelow = 7798;
    e2.Ucircumflexsmall = 63483;
    e2.Ucyrillic = 1059;
    e2.Udblacute = 368;
    e2.Udblgrave = 532;
    e2.Udieresis = 220;
    e2.Udieresisacute = 471;
    e2.Udieresisbelow = 7794;
    e2.Udieresiscaron = 473;
    e2.Udieresiscyrillic = 1264;
    e2.Udieresisgrave = 475;
    e2.Udieresismacron = 469;
    e2.Udieresissmall = 63484;
    e2.Udotbelow = 7908;
    e2.Ugrave = 217;
    e2.Ugravesmall = 63481;
    e2.Uhookabove = 7910;
    e2.Uhorn = 431;
    e2.Uhornacute = 7912;
    e2.Uhorndotbelow = 7920;
    e2.Uhorngrave = 7914;
    e2.Uhornhookabove = 7916;
    e2.Uhorntilde = 7918;
    e2.Uhungarumlaut = 368;
    e2.Uhungarumlautcyrillic = 1266;
    e2.Uinvertedbreve = 534;
    e2.Ukcyrillic = 1144;
    e2.Umacron = 362;
    e2.Umacroncyrillic = 1262;
    e2.Umacrondieresis = 7802;
    e2.Umonospace = 65333;
    e2.Uogonek = 370;
    e2.Upsilon = 933;
    e2.Upsilon1 = 978;
    e2.Upsilonacutehooksymbolgreek = 979;
    e2.Upsilonafrican = 433;
    e2.Upsilondieresis = 939;
    e2.Upsilondieresishooksymbolgreek = 980;
    e2.Upsilonhooksymbol = 978;
    e2.Upsilontonos = 910;
    e2.Uring = 366;
    e2.Ushortcyrillic = 1038;
    e2.Usmall = 63349;
    e2.Ustraightcyrillic = 1198;
    e2.Ustraightstrokecyrillic = 1200;
    e2.Utilde = 360;
    e2.Utildeacute = 7800;
    e2.Utildebelow = 7796;
    e2.V = 86;
    e2.Vcircle = 9419;
    e2.Vdotbelow = 7806;
    e2.Vecyrillic = 1042;
    e2.Vewarmenian = 1358;
    e2.Vhook = 434;
    e2.Vmonospace = 65334;
    e2.Voarmenian = 1352;
    e2.Vsmall = 63350;
    e2.Vtilde = 7804;
    e2.W = 87;
    e2.Wacute = 7810;
    e2.Wcircle = 9420;
    e2.Wcircumflex = 372;
    e2.Wdieresis = 7812;
    e2.Wdotaccent = 7814;
    e2.Wdotbelow = 7816;
    e2.Wgrave = 7808;
    e2.Wmonospace = 65335;
    e2.Wsmall = 63351;
    e2.X = 88;
    e2.Xcircle = 9421;
    e2.Xdieresis = 7820;
    e2.Xdotaccent = 7818;
    e2.Xeharmenian = 1341;
    e2.Xi = 926;
    e2.Xmonospace = 65336;
    e2.Xsmall = 63352;
    e2.Y = 89;
    e2.Yacute = 221;
    e2.Yacutesmall = 63485;
    e2.Yatcyrillic = 1122;
    e2.Ycircle = 9422;
    e2.Ycircumflex = 374;
    e2.Ydieresis = 376;
    e2.Ydieresissmall = 63487;
    e2.Ydotaccent = 7822;
    e2.Ydotbelow = 7924;
    e2.Yericyrillic = 1067;
    e2.Yerudieresiscyrillic = 1272;
    e2.Ygrave = 7922;
    e2.Yhook = 435;
    e2.Yhookabove = 7926;
    e2.Yiarmenian = 1349;
    e2.Yicyrillic = 1031;
    e2.Yiwnarmenian = 1362;
    e2.Ymonospace = 65337;
    e2.Ysmall = 63353;
    e2.Ytilde = 7928;
    e2.Yusbigcyrillic = 1130;
    e2.Yusbigiotifiedcyrillic = 1132;
    e2.Yuslittlecyrillic = 1126;
    e2.Yuslittleiotifiedcyrillic = 1128;
    e2.Z = 90;
    e2.Zaarmenian = 1334;
    e2.Zacute = 377;
    e2.Zcaron = 381;
    e2.Zcaronsmall = 63231;
    e2.Zcircle = 9423;
    e2.Zcircumflex = 7824;
    e2.Zdot = 379;
    e2.Zdotaccent = 379;
    e2.Zdotbelow = 7826;
    e2.Zecyrillic = 1047;
    e2.Zedescendercyrillic = 1176;
    e2.Zedieresiscyrillic = 1246;
    e2.Zeta = 918;
    e2.Zhearmenian = 1338;
    e2.Zhebrevecyrillic = 1217;
    e2.Zhecyrillic = 1046;
    e2.Zhedescendercyrillic = 1174;
    e2.Zhedieresiscyrillic = 1244;
    e2.Zlinebelow = 7828;
    e2.Zmonospace = 65338;
    e2.Zsmall = 63354;
    e2.Zstroke = 437;
    e2.a = 97;
    e2.aabengali = 2438;
    e2.aacute = 225;
    e2.aadeva = 2310;
    e2.aagujarati = 2694;
    e2.aagurmukhi = 2566;
    e2.aamatragurmukhi = 2622;
    e2.aarusquare = 13059;
    e2.aavowelsignbengali = 2494;
    e2.aavowelsigndeva = 2366;
    e2.aavowelsigngujarati = 2750;
    e2.abbreviationmarkarmenian = 1375;
    e2.abbreviationsigndeva = 2416;
    e2.abengali = 2437;
    e2.abopomofo = 12570;
    e2.abreve = 259;
    e2.abreveacute = 7855;
    e2.abrevecyrillic = 1233;
    e2.abrevedotbelow = 7863;
    e2.abrevegrave = 7857;
    e2.abrevehookabove = 7859;
    e2.abrevetilde = 7861;
    e2.acaron = 462;
    e2.acircle = 9424;
    e2.acircumflex = 226;
    e2.acircumflexacute = 7845;
    e2.acircumflexdotbelow = 7853;
    e2.acircumflexgrave = 7847;
    e2.acircumflexhookabove = 7849;
    e2.acircumflextilde = 7851;
    e2.acute = 180;
    e2.acutebelowcmb = 791;
    e2.acutecmb = 769;
    e2.acutecomb = 769;
    e2.acutedeva = 2388;
    e2.acutelowmod = 719;
    e2.acutetonecmb = 833;
    e2.acyrillic = 1072;
    e2.adblgrave = 513;
    e2.addakgurmukhi = 2673;
    e2.adeva = 2309;
    e2.adieresis = 228;
    e2.adieresiscyrillic = 1235;
    e2.adieresismacron = 479;
    e2.adotbelow = 7841;
    e2.adotmacron = 481;
    e2.ae = 230;
    e2.aeacute = 509;
    e2.aekorean = 12624;
    e2.aemacron = 483;
    e2.afii00208 = 8213;
    e2.afii08941 = 8356;
    e2.afii10017 = 1040;
    e2.afii10018 = 1041;
    e2.afii10019 = 1042;
    e2.afii10020 = 1043;
    e2.afii10021 = 1044;
    e2.afii10022 = 1045;
    e2.afii10023 = 1025;
    e2.afii10024 = 1046;
    e2.afii10025 = 1047;
    e2.afii10026 = 1048;
    e2.afii10027 = 1049;
    e2.afii10028 = 1050;
    e2.afii10029 = 1051;
    e2.afii10030 = 1052;
    e2.afii10031 = 1053;
    e2.afii10032 = 1054;
    e2.afii10033 = 1055;
    e2.afii10034 = 1056;
    e2.afii10035 = 1057;
    e2.afii10036 = 1058;
    e2.afii10037 = 1059;
    e2.afii10038 = 1060;
    e2.afii10039 = 1061;
    e2.afii10040 = 1062;
    e2.afii10041 = 1063;
    e2.afii10042 = 1064;
    e2.afii10043 = 1065;
    e2.afii10044 = 1066;
    e2.afii10045 = 1067;
    e2.afii10046 = 1068;
    e2.afii10047 = 1069;
    e2.afii10048 = 1070;
    e2.afii10049 = 1071;
    e2.afii10050 = 1168;
    e2.afii10051 = 1026;
    e2.afii10052 = 1027;
    e2.afii10053 = 1028;
    e2.afii10054 = 1029;
    e2.afii10055 = 1030;
    e2.afii10056 = 1031;
    e2.afii10057 = 1032;
    e2.afii10058 = 1033;
    e2.afii10059 = 1034;
    e2.afii10060 = 1035;
    e2.afii10061 = 1036;
    e2.afii10062 = 1038;
    e2.afii10063 = 63172;
    e2.afii10064 = 63173;
    e2.afii10065 = 1072;
    e2.afii10066 = 1073;
    e2.afii10067 = 1074;
    e2.afii10068 = 1075;
    e2.afii10069 = 1076;
    e2.afii10070 = 1077;
    e2.afii10071 = 1105;
    e2.afii10072 = 1078;
    e2.afii10073 = 1079;
    e2.afii10074 = 1080;
    e2.afii10075 = 1081;
    e2.afii10076 = 1082;
    e2.afii10077 = 1083;
    e2.afii10078 = 1084;
    e2.afii10079 = 1085;
    e2.afii10080 = 1086;
    e2.afii10081 = 1087;
    e2.afii10082 = 1088;
    e2.afii10083 = 1089;
    e2.afii10084 = 1090;
    e2.afii10085 = 1091;
    e2.afii10086 = 1092;
    e2.afii10087 = 1093;
    e2.afii10088 = 1094;
    e2.afii10089 = 1095;
    e2.afii10090 = 1096;
    e2.afii10091 = 1097;
    e2.afii10092 = 1098;
    e2.afii10093 = 1099;
    e2.afii10094 = 1100;
    e2.afii10095 = 1101;
    e2.afii10096 = 1102;
    e2.afii10097 = 1103;
    e2.afii10098 = 1169;
    e2.afii10099 = 1106;
    e2.afii10100 = 1107;
    e2.afii10101 = 1108;
    e2.afii10102 = 1109;
    e2.afii10103 = 1110;
    e2.afii10104 = 1111;
    e2.afii10105 = 1112;
    e2.afii10106 = 1113;
    e2.afii10107 = 1114;
    e2.afii10108 = 1115;
    e2.afii10109 = 1116;
    e2.afii10110 = 1118;
    e2.afii10145 = 1039;
    e2.afii10146 = 1122;
    e2.afii10147 = 1138;
    e2.afii10148 = 1140;
    e2.afii10192 = 63174;
    e2.afii10193 = 1119;
    e2.afii10194 = 1123;
    e2.afii10195 = 1139;
    e2.afii10196 = 1141;
    e2.afii10831 = 63175;
    e2.afii10832 = 63176;
    e2.afii10846 = 1241;
    e2.afii299 = 8206;
    e2.afii300 = 8207;
    e2.afii301 = 8205;
    e2.afii57381 = 1642;
    e2.afii57388 = 1548;
    e2.afii57392 = 1632;
    e2.afii57393 = 1633;
    e2.afii57394 = 1634;
    e2.afii57395 = 1635;
    e2.afii57396 = 1636;
    e2.afii57397 = 1637;
    e2.afii57398 = 1638;
    e2.afii57399 = 1639;
    e2.afii57400 = 1640;
    e2.afii57401 = 1641;
    e2.afii57403 = 1563;
    e2.afii57407 = 1567;
    e2.afii57409 = 1569;
    e2.afii57410 = 1570;
    e2.afii57411 = 1571;
    e2.afii57412 = 1572;
    e2.afii57413 = 1573;
    e2.afii57414 = 1574;
    e2.afii57415 = 1575;
    e2.afii57416 = 1576;
    e2.afii57417 = 1577;
    e2.afii57418 = 1578;
    e2.afii57419 = 1579;
    e2.afii57420 = 1580;
    e2.afii57421 = 1581;
    e2.afii57422 = 1582;
    e2.afii57423 = 1583;
    e2.afii57424 = 1584;
    e2.afii57425 = 1585;
    e2.afii57426 = 1586;
    e2.afii57427 = 1587;
    e2.afii57428 = 1588;
    e2.afii57429 = 1589;
    e2.afii57430 = 1590;
    e2.afii57431 = 1591;
    e2.afii57432 = 1592;
    e2.afii57433 = 1593;
    e2.afii57434 = 1594;
    e2.afii57440 = 1600;
    e2.afii57441 = 1601;
    e2.afii57442 = 1602;
    e2.afii57443 = 1603;
    e2.afii57444 = 1604;
    e2.afii57445 = 1605;
    e2.afii57446 = 1606;
    e2.afii57448 = 1608;
    e2.afii57449 = 1609;
    e2.afii57450 = 1610;
    e2.afii57451 = 1611;
    e2.afii57452 = 1612;
    e2.afii57453 = 1613;
    e2.afii57454 = 1614;
    e2.afii57455 = 1615;
    e2.afii57456 = 1616;
    e2.afii57457 = 1617;
    e2.afii57458 = 1618;
    e2.afii57470 = 1607;
    e2.afii57505 = 1700;
    e2.afii57506 = 1662;
    e2.afii57507 = 1670;
    e2.afii57508 = 1688;
    e2.afii57509 = 1711;
    e2.afii57511 = 1657;
    e2.afii57512 = 1672;
    e2.afii57513 = 1681;
    e2.afii57514 = 1722;
    e2.afii57519 = 1746;
    e2.afii57534 = 1749;
    e2.afii57636 = 8362;
    e2.afii57645 = 1470;
    e2.afii57658 = 1475;
    e2.afii57664 = 1488;
    e2.afii57665 = 1489;
    e2.afii57666 = 1490;
    e2.afii57667 = 1491;
    e2.afii57668 = 1492;
    e2.afii57669 = 1493;
    e2.afii57670 = 1494;
    e2.afii57671 = 1495;
    e2.afii57672 = 1496;
    e2.afii57673 = 1497;
    e2.afii57674 = 1498;
    e2.afii57675 = 1499;
    e2.afii57676 = 1500;
    e2.afii57677 = 1501;
    e2.afii57678 = 1502;
    e2.afii57679 = 1503;
    e2.afii57680 = 1504;
    e2.afii57681 = 1505;
    e2.afii57682 = 1506;
    e2.afii57683 = 1507;
    e2.afii57684 = 1508;
    e2.afii57685 = 1509;
    e2.afii57686 = 1510;
    e2.afii57687 = 1511;
    e2.afii57688 = 1512;
    e2.afii57689 = 1513;
    e2.afii57690 = 1514;
    e2.afii57694 = 64298;
    e2.afii57695 = 64299;
    e2.afii57700 = 64331;
    e2.afii57705 = 64287;
    e2.afii57716 = 1520;
    e2.afii57717 = 1521;
    e2.afii57718 = 1522;
    e2.afii57723 = 64309;
    e2.afii57793 = 1460;
    e2.afii57794 = 1461;
    e2.afii57795 = 1462;
    e2.afii57796 = 1467;
    e2.afii57797 = 1464;
    e2.afii57798 = 1463;
    e2.afii57799 = 1456;
    e2.afii57800 = 1458;
    e2.afii57801 = 1457;
    e2.afii57802 = 1459;
    e2.afii57803 = 1474;
    e2.afii57804 = 1473;
    e2.afii57806 = 1465;
    e2.afii57807 = 1468;
    e2.afii57839 = 1469;
    e2.afii57841 = 1471;
    e2.afii57842 = 1472;
    e2.afii57929 = 700;
    e2.afii61248 = 8453;
    e2.afii61289 = 8467;
    e2.afii61352 = 8470;
    e2.afii61573 = 8236;
    e2.afii61574 = 8237;
    e2.afii61575 = 8238;
    e2.afii61664 = 8204;
    e2.afii63167 = 1645;
    e2.afii64937 = 701;
    e2.agrave = 224;
    e2.agujarati = 2693;
    e2.agurmukhi = 2565;
    e2.ahiragana = 12354;
    e2.ahookabove = 7843;
    e2.aibengali = 2448;
    e2.aibopomofo = 12574;
    e2.aideva = 2320;
    e2.aiecyrillic = 1237;
    e2.aigujarati = 2704;
    e2.aigurmukhi = 2576;
    e2.aimatragurmukhi = 2632;
    e2.ainarabic = 1593;
    e2.ainfinalarabic = 65226;
    e2.aininitialarabic = 65227;
    e2.ainmedialarabic = 65228;
    e2.ainvertedbreve = 515;
    e2.aivowelsignbengali = 2504;
    e2.aivowelsigndeva = 2376;
    e2.aivowelsigngujarati = 2760;
    e2.akatakana = 12450;
    e2.akatakanahalfwidth = 65393;
    e2.akorean = 12623;
    e2.alef = 1488;
    e2.alefarabic = 1575;
    e2.alefdageshhebrew = 64304;
    e2.aleffinalarabic = 65166;
    e2.alefhamzaabovearabic = 1571;
    e2.alefhamzaabovefinalarabic = 65156;
    e2.alefhamzabelowarabic = 1573;
    e2.alefhamzabelowfinalarabic = 65160;
    e2.alefhebrew = 1488;
    e2.aleflamedhebrew = 64335;
    e2.alefmaddaabovearabic = 1570;
    e2.alefmaddaabovefinalarabic = 65154;
    e2.alefmaksuraarabic = 1609;
    e2.alefmaksurafinalarabic = 65264;
    e2.alefmaksurainitialarabic = 65267;
    e2.alefmaksuramedialarabic = 65268;
    e2.alefpatahhebrew = 64302;
    e2.alefqamatshebrew = 64303;
    e2.aleph = 8501;
    e2.allequal = 8780;
    e2.alpha = 945;
    e2.alphatonos = 940;
    e2.amacron = 257;
    e2.amonospace = 65345;
    e2.ampersand = 38;
    e2.ampersandmonospace = 65286;
    e2.ampersandsmall = 63270;
    e2.amsquare = 13250;
    e2.anbopomofo = 12578;
    e2.angbopomofo = 12580;
    e2.angbracketleft = 12296;
    e2.angbracketright = 12297;
    e2.angkhankhuthai = 3674;
    e2.angle = 8736;
    e2.anglebracketleft = 12296;
    e2.anglebracketleftvertical = 65087;
    e2.anglebracketright = 12297;
    e2.anglebracketrightvertical = 65088;
    e2.angleleft = 9001;
    e2.angleright = 9002;
    e2.angstrom = 8491;
    e2.anoteleia = 903;
    e2.anudattadeva = 2386;
    e2.anusvarabengali = 2434;
    e2.anusvaradeva = 2306;
    e2.anusvaragujarati = 2690;
    e2.aogonek = 261;
    e2.apaatosquare = 13056;
    e2.aparen = 9372;
    e2.apostrophearmenian = 1370;
    e2.apostrophemod = 700;
    e2.apple = 63743;
    e2.approaches = 8784;
    e2.approxequal = 8776;
    e2.approxequalorimage = 8786;
    e2.approximatelyequal = 8773;
    e2.araeaekorean = 12686;
    e2.araeakorean = 12685;
    e2.arc = 8978;
    e2.arighthalfring = 7834;
    e2.aring = 229;
    e2.aringacute = 507;
    e2.aringbelow = 7681;
    e2.arrowboth = 8596;
    e2.arrowdashdown = 8675;
    e2.arrowdashleft = 8672;
    e2.arrowdashright = 8674;
    e2.arrowdashup = 8673;
    e2.arrowdblboth = 8660;
    e2.arrowdbldown = 8659;
    e2.arrowdblleft = 8656;
    e2.arrowdblright = 8658;
    e2.arrowdblup = 8657;
    e2.arrowdown = 8595;
    e2.arrowdownleft = 8601;
    e2.arrowdownright = 8600;
    e2.arrowdownwhite = 8681;
    e2.arrowheaddownmod = 709;
    e2.arrowheadleftmod = 706;
    e2.arrowheadrightmod = 707;
    e2.arrowheadupmod = 708;
    e2.arrowhorizex = 63719;
    e2.arrowleft = 8592;
    e2.arrowleftdbl = 8656;
    e2.arrowleftdblstroke = 8653;
    e2.arrowleftoverright = 8646;
    e2.arrowleftwhite = 8678;
    e2.arrowright = 8594;
    e2.arrowrightdblstroke = 8655;
    e2.arrowrightheavy = 10142;
    e2.arrowrightoverleft = 8644;
    e2.arrowrightwhite = 8680;
    e2.arrowtableft = 8676;
    e2.arrowtabright = 8677;
    e2.arrowup = 8593;
    e2.arrowupdn = 8597;
    e2.arrowupdnbse = 8616;
    e2.arrowupdownbase = 8616;
    e2.arrowupleft = 8598;
    e2.arrowupleftofdown = 8645;
    e2.arrowupright = 8599;
    e2.arrowupwhite = 8679;
    e2.arrowvertex = 63718;
    e2.asciicircum = 94;
    e2.asciicircummonospace = 65342;
    e2.asciitilde = 126;
    e2.asciitildemonospace = 65374;
    e2.ascript = 593;
    e2.ascriptturned = 594;
    e2.asmallhiragana = 12353;
    e2.asmallkatakana = 12449;
    e2.asmallkatakanahalfwidth = 65383;
    e2.asterisk = 42;
    e2.asteriskaltonearabic = 1645;
    e2.asteriskarabic = 1645;
    e2.asteriskmath = 8727;
    e2.asteriskmonospace = 65290;
    e2.asterisksmall = 65121;
    e2.asterism = 8258;
    e2.asuperior = 63209;
    e2.asymptoticallyequal = 8771;
    e2.at = 64;
    e2.atilde = 227;
    e2.atmonospace = 65312;
    e2.atsmall = 65131;
    e2.aturned = 592;
    e2.aubengali = 2452;
    e2.aubopomofo = 12576;
    e2.audeva = 2324;
    e2.augujarati = 2708;
    e2.augurmukhi = 2580;
    e2.aulengthmarkbengali = 2519;
    e2.aumatragurmukhi = 2636;
    e2.auvowelsignbengali = 2508;
    e2.auvowelsigndeva = 2380;
    e2.auvowelsigngujarati = 2764;
    e2.avagrahadeva = 2365;
    e2.aybarmenian = 1377;
    e2.ayin = 1506;
    e2.ayinaltonehebrew = 64288;
    e2.ayinhebrew = 1506;
    e2.b = 98;
    e2.babengali = 2476;
    e2.backslash = 92;
    e2.backslashmonospace = 65340;
    e2.badeva = 2348;
    e2.bagujarati = 2732;
    e2.bagurmukhi = 2604;
    e2.bahiragana = 12400;
    e2.bahtthai = 3647;
    e2.bakatakana = 12496;
    e2.bar = 124;
    e2.barmonospace = 65372;
    e2.bbopomofo = 12549;
    e2.bcircle = 9425;
    e2.bdotaccent = 7683;
    e2.bdotbelow = 7685;
    e2.beamedsixteenthnotes = 9836;
    e2.because = 8757;
    e2.becyrillic = 1073;
    e2.beharabic = 1576;
    e2.behfinalarabic = 65168;
    e2.behinitialarabic = 65169;
    e2.behiragana = 12409;
    e2.behmedialarabic = 65170;
    e2.behmeeminitialarabic = 64671;
    e2.behmeemisolatedarabic = 64520;
    e2.behnoonfinalarabic = 64621;
    e2.bekatakana = 12505;
    e2.benarmenian = 1378;
    e2.bet = 1489;
    e2.beta = 946;
    e2.betasymbolgreek = 976;
    e2.betdagesh = 64305;
    e2.betdageshhebrew = 64305;
    e2.bethebrew = 1489;
    e2.betrafehebrew = 64332;
    e2.bhabengali = 2477;
    e2.bhadeva = 2349;
    e2.bhagujarati = 2733;
    e2.bhagurmukhi = 2605;
    e2.bhook = 595;
    e2.bihiragana = 12403;
    e2.bikatakana = 12499;
    e2.bilabialclick = 664;
    e2.bindigurmukhi = 2562;
    e2.birusquare = 13105;
    e2.blackcircle = 9679;
    e2.blackdiamond = 9670;
    e2.blackdownpointingtriangle = 9660;
    e2.blackleftpointingpointer = 9668;
    e2.blackleftpointingtriangle = 9664;
    e2.blacklenticularbracketleft = 12304;
    e2.blacklenticularbracketleftvertical = 65083;
    e2.blacklenticularbracketright = 12305;
    e2.blacklenticularbracketrightvertical = 65084;
    e2.blacklowerlefttriangle = 9699;
    e2.blacklowerrighttriangle = 9698;
    e2.blackrectangle = 9644;
    e2.blackrightpointingpointer = 9658;
    e2.blackrightpointingtriangle = 9654;
    e2.blacksmallsquare = 9642;
    e2.blacksmilingface = 9787;
    e2.blacksquare = 9632;
    e2.blackstar = 9733;
    e2.blackupperlefttriangle = 9700;
    e2.blackupperrighttriangle = 9701;
    e2.blackuppointingsmalltriangle = 9652;
    e2.blackuppointingtriangle = 9650;
    e2.blank = 9251;
    e2.blinebelow = 7687;
    e2.block = 9608;
    e2.bmonospace = 65346;
    e2.bobaimaithai = 3610;
    e2.bohiragana = 12412;
    e2.bokatakana = 12508;
    e2.bparen = 9373;
    e2.bqsquare = 13251;
    e2.braceex = 63732;
    e2.braceleft = 123;
    e2.braceleftbt = 63731;
    e2.braceleftmid = 63730;
    e2.braceleftmonospace = 65371;
    e2.braceleftsmall = 65115;
    e2.bracelefttp = 63729;
    e2.braceleftvertical = 65079;
    e2.braceright = 125;
    e2.bracerightbt = 63742;
    e2.bracerightmid = 63741;
    e2.bracerightmonospace = 65373;
    e2.bracerightsmall = 65116;
    e2.bracerighttp = 63740;
    e2.bracerightvertical = 65080;
    e2.bracketleft = 91;
    e2.bracketleftbt = 63728;
    e2.bracketleftex = 63727;
    e2.bracketleftmonospace = 65339;
    e2.bracketlefttp = 63726;
    e2.bracketright = 93;
    e2.bracketrightbt = 63739;
    e2.bracketrightex = 63738;
    e2.bracketrightmonospace = 65341;
    e2.bracketrighttp = 63737;
    e2.breve = 728;
    e2.brevebelowcmb = 814;
    e2.brevecmb = 774;
    e2.breveinvertedbelowcmb = 815;
    e2.breveinvertedcmb = 785;
    e2.breveinverteddoublecmb = 865;
    e2.bridgebelowcmb = 810;
    e2.bridgeinvertedbelowcmb = 826;
    e2.brokenbar = 166;
    e2.bstroke = 384;
    e2.bsuperior = 63210;
    e2.btopbar = 387;
    e2.buhiragana = 12406;
    e2.bukatakana = 12502;
    e2.bullet = 8226;
    e2.bulletinverse = 9688;
    e2.bulletoperator = 8729;
    e2.bullseye = 9678;
    e2.c = 99;
    e2.caarmenian = 1390;
    e2.cabengali = 2458;
    e2.cacute = 263;
    e2.cadeva = 2330;
    e2.cagujarati = 2714;
    e2.cagurmukhi = 2586;
    e2.calsquare = 13192;
    e2.candrabindubengali = 2433;
    e2.candrabinducmb = 784;
    e2.candrabindudeva = 2305;
    e2.candrabindugujarati = 2689;
    e2.capslock = 8682;
    e2.careof = 8453;
    e2.caron = 711;
    e2.caronbelowcmb = 812;
    e2.caroncmb = 780;
    e2.carriagereturn = 8629;
    e2.cbopomofo = 12568;
    e2.ccaron = 269;
    e2.ccedilla = 231;
    e2.ccedillaacute = 7689;
    e2.ccircle = 9426;
    e2.ccircumflex = 265;
    e2.ccurl = 597;
    e2.cdot = 267;
    e2.cdotaccent = 267;
    e2.cdsquare = 13253;
    e2.cedilla = 184;
    e2.cedillacmb = 807;
    e2.cent = 162;
    e2.centigrade = 8451;
    e2.centinferior = 63199;
    e2.centmonospace = 65504;
    e2.centoldstyle = 63394;
    e2.centsuperior = 63200;
    e2.chaarmenian = 1401;
    e2.chabengali = 2459;
    e2.chadeva = 2331;
    e2.chagujarati = 2715;
    e2.chagurmukhi = 2587;
    e2.chbopomofo = 12564;
    e2.cheabkhasiancyrillic = 1213;
    e2.checkmark = 10003;
    e2.checyrillic = 1095;
    e2.chedescenderabkhasiancyrillic = 1215;
    e2.chedescendercyrillic = 1207;
    e2.chedieresiscyrillic = 1269;
    e2.cheharmenian = 1395;
    e2.chekhakassiancyrillic = 1228;
    e2.cheverticalstrokecyrillic = 1209;
    e2.chi = 967;
    e2.chieuchacirclekorean = 12919;
    e2.chieuchaparenkorean = 12823;
    e2.chieuchcirclekorean = 12905;
    e2.chieuchkorean = 12618;
    e2.chieuchparenkorean = 12809;
    e2.chochangthai = 3594;
    e2.chochanthai = 3592;
    e2.chochingthai = 3593;
    e2.chochoethai = 3596;
    e2.chook = 392;
    e2.cieucacirclekorean = 12918;
    e2.cieucaparenkorean = 12822;
    e2.cieuccirclekorean = 12904;
    e2.cieuckorean = 12616;
    e2.cieucparenkorean = 12808;
    e2.cieucuparenkorean = 12828;
    e2.circle = 9675;
    e2.circlecopyrt = 169;
    e2.circlemultiply = 8855;
    e2.circleot = 8857;
    e2.circleplus = 8853;
    e2.circlepostalmark = 12342;
    e2.circlewithlefthalfblack = 9680;
    e2.circlewithrighthalfblack = 9681;
    e2.circumflex = 710;
    e2.circumflexbelowcmb = 813;
    e2.circumflexcmb = 770;
    e2.clear = 8999;
    e2.clickalveolar = 450;
    e2.clickdental = 448;
    e2.clicklateral = 449;
    e2.clickretroflex = 451;
    e2.club = 9827;
    e2.clubsuitblack = 9827;
    e2.clubsuitwhite = 9831;
    e2.cmcubedsquare = 13220;
    e2.cmonospace = 65347;
    e2.cmsquaredsquare = 13216;
    e2.coarmenian = 1409;
    e2.colon = 58;
    e2.colonmonetary = 8353;
    e2.colonmonospace = 65306;
    e2.colonsign = 8353;
    e2.colonsmall = 65109;
    e2.colontriangularhalfmod = 721;
    e2.colontriangularmod = 720;
    e2.comma = 44;
    e2.commaabovecmb = 787;
    e2.commaaboverightcmb = 789;
    e2.commaaccent = 63171;
    e2.commaarabic = 1548;
    e2.commaarmenian = 1373;
    e2.commainferior = 63201;
    e2.commamonospace = 65292;
    e2.commareversedabovecmb = 788;
    e2.commareversedmod = 701;
    e2.commasmall = 65104;
    e2.commasuperior = 63202;
    e2.commaturnedabovecmb = 786;
    e2.commaturnedmod = 699;
    e2.compass = 9788;
    e2.congruent = 8773;
    e2.contourintegral = 8750;
    e2.control = 8963;
    e2.controlACK = 6;
    e2.controlBEL = 7;
    e2.controlBS = 8;
    e2.controlCAN = 24;
    e2.controlCR = 13;
    e2.controlDC1 = 17;
    e2.controlDC2 = 18;
    e2.controlDC3 = 19;
    e2.controlDC4 = 20;
    e2.controlDEL = 127;
    e2.controlDLE = 16;
    e2.controlEM = 25;
    e2.controlENQ = 5;
    e2.controlEOT = 4;
    e2.controlESC = 27;
    e2.controlETB = 23;
    e2.controlETX = 3;
    e2.controlFF = 12;
    e2.controlFS = 28;
    e2.controlGS = 29;
    e2.controlHT = 9;
    e2.controlLF = 10;
    e2.controlNAK = 21;
    e2.controlNULL = 0;
    e2.controlRS = 30;
    e2.controlSI = 15;
    e2.controlSO = 14;
    e2.controlSOT = 2;
    e2.controlSTX = 1;
    e2.controlSUB = 26;
    e2.controlSYN = 22;
    e2.controlUS = 31;
    e2.controlVT = 11;
    e2.copyright = 169;
    e2.copyrightsans = 63721;
    e2.copyrightserif = 63193;
    e2.cornerbracketleft = 12300;
    e2.cornerbracketlefthalfwidth = 65378;
    e2.cornerbracketleftvertical = 65089;
    e2.cornerbracketright = 12301;
    e2.cornerbracketrighthalfwidth = 65379;
    e2.cornerbracketrightvertical = 65090;
    e2.corporationsquare = 13183;
    e2.cosquare = 13255;
    e2.coverkgsquare = 13254;
    e2.cparen = 9374;
    e2.cruzeiro = 8354;
    e2.cstretched = 663;
    e2.curlyand = 8911;
    e2.curlyor = 8910;
    e2.currency = 164;
    e2.cyrBreve = 63185;
    e2.cyrFlex = 63186;
    e2.cyrbreve = 63188;
    e2.cyrflex = 63189;
    e2.d = 100;
    e2.daarmenian = 1380;
    e2.dabengali = 2470;
    e2.dadarabic = 1590;
    e2.dadeva = 2342;
    e2.dadfinalarabic = 65214;
    e2.dadinitialarabic = 65215;
    e2.dadmedialarabic = 65216;
    e2.dagesh = 1468;
    e2.dageshhebrew = 1468;
    e2.dagger = 8224;
    e2.daggerdbl = 8225;
    e2.dagujarati = 2726;
    e2.dagurmukhi = 2598;
    e2.dahiragana = 12384;
    e2.dakatakana = 12480;
    e2.dalarabic = 1583;
    e2.dalet = 1491;
    e2.daletdagesh = 64307;
    e2.daletdageshhebrew = 64307;
    e2.dalethebrew = 1491;
    e2.dalfinalarabic = 65194;
    e2.dammaarabic = 1615;
    e2.dammalowarabic = 1615;
    e2.dammatanaltonearabic = 1612;
    e2.dammatanarabic = 1612;
    e2.danda = 2404;
    e2.dargahebrew = 1447;
    e2.dargalefthebrew = 1447;
    e2.dasiapneumatacyrilliccmb = 1157;
    e2.dblGrave = 63187;
    e2.dblanglebracketleft = 12298;
    e2.dblanglebracketleftvertical = 65085;
    e2.dblanglebracketright = 12299;
    e2.dblanglebracketrightvertical = 65086;
    e2.dblarchinvertedbelowcmb = 811;
    e2.dblarrowleft = 8660;
    e2.dblarrowright = 8658;
    e2.dbldanda = 2405;
    e2.dblgrave = 63190;
    e2.dblgravecmb = 783;
    e2.dblintegral = 8748;
    e2.dbllowline = 8215;
    e2.dbllowlinecmb = 819;
    e2.dbloverlinecmb = 831;
    e2.dblprimemod = 698;
    e2.dblverticalbar = 8214;
    e2.dblverticallineabovecmb = 782;
    e2.dbopomofo = 12553;
    e2.dbsquare = 13256;
    e2.dcaron = 271;
    e2.dcedilla = 7697;
    e2.dcircle = 9427;
    e2.dcircumflexbelow = 7699;
    e2.dcroat = 273;
    e2.ddabengali = 2465;
    e2.ddadeva = 2337;
    e2.ddagujarati = 2721;
    e2.ddagurmukhi = 2593;
    e2.ddalarabic = 1672;
    e2.ddalfinalarabic = 64393;
    e2.dddhadeva = 2396;
    e2.ddhabengali = 2466;
    e2.ddhadeva = 2338;
    e2.ddhagujarati = 2722;
    e2.ddhagurmukhi = 2594;
    e2.ddotaccent = 7691;
    e2.ddotbelow = 7693;
    e2.decimalseparatorarabic = 1643;
    e2.decimalseparatorpersian = 1643;
    e2.decyrillic = 1076;
    e2.degree = 176;
    e2.dehihebrew = 1453;
    e2.dehiragana = 12391;
    e2.deicoptic = 1007;
    e2.dekatakana = 12487;
    e2.deleteleft = 9003;
    e2.deleteright = 8998;
    e2.delta = 948;
    e2.deltaturned = 397;
    e2.denominatorminusonenumeratorbengali = 2552;
    e2.dezh = 676;
    e2.dhabengali = 2471;
    e2.dhadeva = 2343;
    e2.dhagujarati = 2727;
    e2.dhagurmukhi = 2599;
    e2.dhook = 599;
    e2.dialytikatonos = 901;
    e2.dialytikatonoscmb = 836;
    e2.diamond = 9830;
    e2.diamondsuitwhite = 9826;
    e2.dieresis = 168;
    e2.dieresisacute = 63191;
    e2.dieresisbelowcmb = 804;
    e2.dieresiscmb = 776;
    e2.dieresisgrave = 63192;
    e2.dieresistonos = 901;
    e2.dihiragana = 12386;
    e2.dikatakana = 12482;
    e2.dittomark = 12291;
    e2.divide = 247;
    e2.divides = 8739;
    e2.divisionslash = 8725;
    e2.djecyrillic = 1106;
    e2.dkshade = 9619;
    e2.dlinebelow = 7695;
    e2.dlsquare = 13207;
    e2.dmacron = 273;
    e2.dmonospace = 65348;
    e2.dnblock = 9604;
    e2.dochadathai = 3598;
    e2.dodekthai = 3604;
    e2.dohiragana = 12393;
    e2.dokatakana = 12489;
    e2.dollar = 36;
    e2.dollarinferior = 63203;
    e2.dollarmonospace = 65284;
    e2.dollaroldstyle = 63268;
    e2.dollarsmall = 65129;
    e2.dollarsuperior = 63204;
    e2.dong = 8363;
    e2.dorusquare = 13094;
    e2.dotaccent = 729;
    e2.dotaccentcmb = 775;
    e2.dotbelowcmb = 803;
    e2.dotbelowcomb = 803;
    e2.dotkatakana = 12539;
    e2.dotlessi = 305;
    e2.dotlessj = 63166;
    e2.dotlessjstrokehook = 644;
    e2.dotmath = 8901;
    e2.dottedcircle = 9676;
    e2.doubleyodpatah = 64287;
    e2.doubleyodpatahhebrew = 64287;
    e2.downtackbelowcmb = 798;
    e2.downtackmod = 725;
    e2.dparen = 9375;
    e2.dsuperior = 63211;
    e2.dtail = 598;
    e2.dtopbar = 396;
    e2.duhiragana = 12389;
    e2.dukatakana = 12485;
    e2.dz = 499;
    e2.dzaltone = 675;
    e2.dzcaron = 454;
    e2.dzcurl = 677;
    e2.dzeabkhasiancyrillic = 1249;
    e2.dzecyrillic = 1109;
    e2.dzhecyrillic = 1119;
    e2.e = 101;
    e2.eacute = 233;
    e2.earth = 9793;
    e2.ebengali = 2447;
    e2.ebopomofo = 12572;
    e2.ebreve = 277;
    e2.ecandradeva = 2317;
    e2.ecandragujarati = 2701;
    e2.ecandravowelsigndeva = 2373;
    e2.ecandravowelsigngujarati = 2757;
    e2.ecaron = 283;
    e2.ecedillabreve = 7709;
    e2.echarmenian = 1381;
    e2.echyiwnarmenian = 1415;
    e2.ecircle = 9428;
    e2.ecircumflex = 234;
    e2.ecircumflexacute = 7871;
    e2.ecircumflexbelow = 7705;
    e2.ecircumflexdotbelow = 7879;
    e2.ecircumflexgrave = 7873;
    e2.ecircumflexhookabove = 7875;
    e2.ecircumflextilde = 7877;
    e2.ecyrillic = 1108;
    e2.edblgrave = 517;
    e2.edeva = 2319;
    e2.edieresis = 235;
    e2.edot = 279;
    e2.edotaccent = 279;
    e2.edotbelow = 7865;
    e2.eegurmukhi = 2575;
    e2.eematragurmukhi = 2631;
    e2.efcyrillic = 1092;
    e2.egrave = 232;
    e2.egujarati = 2703;
    e2.eharmenian = 1383;
    e2.ehbopomofo = 12573;
    e2.ehiragana = 12360;
    e2.ehookabove = 7867;
    e2.eibopomofo = 12575;
    e2.eight = 56;
    e2.eightarabic = 1640;
    e2.eightbengali = 2542;
    e2.eightcircle = 9319;
    e2.eightcircleinversesansserif = 10129;
    e2.eightdeva = 2414;
    e2.eighteencircle = 9329;
    e2.eighteenparen = 9349;
    e2.eighteenperiod = 9369;
    e2.eightgujarati = 2798;
    e2.eightgurmukhi = 2670;
    e2.eighthackarabic = 1640;
    e2.eighthangzhou = 12328;
    e2.eighthnotebeamed = 9835;
    e2.eightideographicparen = 12839;
    e2.eightinferior = 8328;
    e2.eightmonospace = 65304;
    e2.eightoldstyle = 63288;
    e2.eightparen = 9339;
    e2.eightperiod = 9359;
    e2.eightpersian = 1784;
    e2.eightroman = 8567;
    e2.eightsuperior = 8312;
    e2.eightthai = 3672;
    e2.einvertedbreve = 519;
    e2.eiotifiedcyrillic = 1125;
    e2.ekatakana = 12456;
    e2.ekatakanahalfwidth = 65396;
    e2.ekonkargurmukhi = 2676;
    e2.ekorean = 12628;
    e2.elcyrillic = 1083;
    e2.element = 8712;
    e2.elevencircle = 9322;
    e2.elevenparen = 9342;
    e2.elevenperiod = 9362;
    e2.elevenroman = 8570;
    e2.ellipsis = 8230;
    e2.ellipsisvertical = 8942;
    e2.emacron = 275;
    e2.emacronacute = 7703;
    e2.emacrongrave = 7701;
    e2.emcyrillic = 1084;
    e2.emdash = 8212;
    e2.emdashvertical = 65073;
    e2.emonospace = 65349;
    e2.emphasismarkarmenian = 1371;
    e2.emptyset = 8709;
    e2.enbopomofo = 12579;
    e2.encyrillic = 1085;
    e2.endash = 8211;
    e2.endashvertical = 65074;
    e2.endescendercyrillic = 1187;
    e2.eng = 331;
    e2.engbopomofo = 12581;
    e2.enghecyrillic = 1189;
    e2.enhookcyrillic = 1224;
    e2.enspace = 8194;
    e2.eogonek = 281;
    e2.eokorean = 12627;
    e2.eopen = 603;
    e2.eopenclosed = 666;
    e2.eopenreversed = 604;
    e2.eopenreversedclosed = 606;
    e2.eopenreversedhook = 605;
    e2.eparen = 9376;
    e2.epsilon = 949;
    e2.epsilontonos = 941;
    e2.equal = 61;
    e2.equalmonospace = 65309;
    e2.equalsmall = 65126;
    e2.equalsuperior = 8316;
    e2.equivalence = 8801;
    e2.erbopomofo = 12582;
    e2.ercyrillic = 1088;
    e2.ereversed = 600;
    e2.ereversedcyrillic = 1101;
    e2.escyrillic = 1089;
    e2.esdescendercyrillic = 1195;
    e2.esh = 643;
    e2.eshcurl = 646;
    e2.eshortdeva = 2318;
    e2.eshortvowelsigndeva = 2374;
    e2.eshreversedloop = 426;
    e2.eshsquatreversed = 645;
    e2.esmallhiragana = 12359;
    e2.esmallkatakana = 12455;
    e2.esmallkatakanahalfwidth = 65386;
    e2.estimated = 8494;
    e2.esuperior = 63212;
    e2.eta = 951;
    e2.etarmenian = 1384;
    e2.etatonos = 942;
    e2.eth = 240;
    e2.etilde = 7869;
    e2.etildebelow = 7707;
    e2.etnahtafoukhhebrew = 1425;
    e2.etnahtafoukhlefthebrew = 1425;
    e2.etnahtahebrew = 1425;
    e2.etnahtalefthebrew = 1425;
    e2.eturned = 477;
    e2.eukorean = 12641;
    e2.euro = 8364;
    e2.evowelsignbengali = 2503;
    e2.evowelsigndeva = 2375;
    e2.evowelsigngujarati = 2759;
    e2.exclam = 33;
    e2.exclamarmenian = 1372;
    e2.exclamdbl = 8252;
    e2.exclamdown = 161;
    e2.exclamdownsmall = 63393;
    e2.exclammonospace = 65281;
    e2.exclamsmall = 63265;
    e2.existential = 8707;
    e2.ezh = 658;
    e2.ezhcaron = 495;
    e2.ezhcurl = 659;
    e2.ezhreversed = 441;
    e2.ezhtail = 442;
    e2.f = 102;
    e2.fadeva = 2398;
    e2.fagurmukhi = 2654;
    e2.fahrenheit = 8457;
    e2.fathaarabic = 1614;
    e2.fathalowarabic = 1614;
    e2.fathatanarabic = 1611;
    e2.fbopomofo = 12552;
    e2.fcircle = 9429;
    e2.fdotaccent = 7711;
    e2.feharabic = 1601;
    e2.feharmenian = 1414;
    e2.fehfinalarabic = 65234;
    e2.fehinitialarabic = 65235;
    e2.fehmedialarabic = 65236;
    e2.feicoptic = 997;
    e2.female = 9792;
    e2.ff = 64256;
    e2.f_f = 64256;
    e2.ffi = 64259;
    e2.f_f_i = 64259;
    e2.ffl = 64260;
    e2.f_f_l = 64260;
    e2.fi = 64257;
    e2.f_i = 64257;
    e2.fifteencircle = 9326;
    e2.fifteenparen = 9346;
    e2.fifteenperiod = 9366;
    e2.figuredash = 8210;
    e2.filledbox = 9632;
    e2.filledrect = 9644;
    e2.finalkaf = 1498;
    e2.finalkafdagesh = 64314;
    e2.finalkafdageshhebrew = 64314;
    e2.finalkafhebrew = 1498;
    e2.finalmem = 1501;
    e2.finalmemhebrew = 1501;
    e2.finalnun = 1503;
    e2.finalnunhebrew = 1503;
    e2.finalpe = 1507;
    e2.finalpehebrew = 1507;
    e2.finaltsadi = 1509;
    e2.finaltsadihebrew = 1509;
    e2.firsttonechinese = 713;
    e2.fisheye = 9673;
    e2.fitacyrillic = 1139;
    e2.five = 53;
    e2.fivearabic = 1637;
    e2.fivebengali = 2539;
    e2.fivecircle = 9316;
    e2.fivecircleinversesansserif = 10126;
    e2.fivedeva = 2411;
    e2.fiveeighths = 8541;
    e2.fivegujarati = 2795;
    e2.fivegurmukhi = 2667;
    e2.fivehackarabic = 1637;
    e2.fivehangzhou = 12325;
    e2.fiveideographicparen = 12836;
    e2.fiveinferior = 8325;
    e2.fivemonospace = 65301;
    e2.fiveoldstyle = 63285;
    e2.fiveparen = 9336;
    e2.fiveperiod = 9356;
    e2.fivepersian = 1781;
    e2.fiveroman = 8564;
    e2.fivesuperior = 8309;
    e2.fivethai = 3669;
    e2.fl = 64258;
    e2.f_l = 64258;
    e2.florin = 402;
    e2.fmonospace = 65350;
    e2.fmsquare = 13209;
    e2.fofanthai = 3615;
    e2.fofathai = 3613;
    e2.fongmanthai = 3663;
    e2.forall = 8704;
    e2.four = 52;
    e2.fourarabic = 1636;
    e2.fourbengali = 2538;
    e2.fourcircle = 9315;
    e2.fourcircleinversesansserif = 10125;
    e2.fourdeva = 2410;
    e2.fourgujarati = 2794;
    e2.fourgurmukhi = 2666;
    e2.fourhackarabic = 1636;
    e2.fourhangzhou = 12324;
    e2.fourideographicparen = 12835;
    e2.fourinferior = 8324;
    e2.fourmonospace = 65300;
    e2.fournumeratorbengali = 2551;
    e2.fouroldstyle = 63284;
    e2.fourparen = 9335;
    e2.fourperiod = 9355;
    e2.fourpersian = 1780;
    e2.fourroman = 8563;
    e2.foursuperior = 8308;
    e2.fourteencircle = 9325;
    e2.fourteenparen = 9345;
    e2.fourteenperiod = 9365;
    e2.fourthai = 3668;
    e2.fourthtonechinese = 715;
    e2.fparen = 9377;
    e2.fraction = 8260;
    e2.franc = 8355;
    e2.g = 103;
    e2.gabengali = 2455;
    e2.gacute = 501;
    e2.gadeva = 2327;
    e2.gafarabic = 1711;
    e2.gaffinalarabic = 64403;
    e2.gafinitialarabic = 64404;
    e2.gafmedialarabic = 64405;
    e2.gagujarati = 2711;
    e2.gagurmukhi = 2583;
    e2.gahiragana = 12364;
    e2.gakatakana = 12460;
    e2.gamma = 947;
    e2.gammalatinsmall = 611;
    e2.gammasuperior = 736;
    e2.gangiacoptic = 1003;
    e2.gbopomofo = 12557;
    e2.gbreve = 287;
    e2.gcaron = 487;
    e2.gcedilla = 291;
    e2.gcircle = 9430;
    e2.gcircumflex = 285;
    e2.gcommaaccent = 291;
    e2.gdot = 289;
    e2.gdotaccent = 289;
    e2.gecyrillic = 1075;
    e2.gehiragana = 12370;
    e2.gekatakana = 12466;
    e2.geometricallyequal = 8785;
    e2.gereshaccenthebrew = 1436;
    e2.gereshhebrew = 1523;
    e2.gereshmuqdamhebrew = 1437;
    e2.germandbls = 223;
    e2.gershayimaccenthebrew = 1438;
    e2.gershayimhebrew = 1524;
    e2.getamark = 12307;
    e2.ghabengali = 2456;
    e2.ghadarmenian = 1394;
    e2.ghadeva = 2328;
    e2.ghagujarati = 2712;
    e2.ghagurmukhi = 2584;
    e2.ghainarabic = 1594;
    e2.ghainfinalarabic = 65230;
    e2.ghaininitialarabic = 65231;
    e2.ghainmedialarabic = 65232;
    e2.ghemiddlehookcyrillic = 1173;
    e2.ghestrokecyrillic = 1171;
    e2.gheupturncyrillic = 1169;
    e2.ghhadeva = 2394;
    e2.ghhagurmukhi = 2650;
    e2.ghook = 608;
    e2.ghzsquare = 13203;
    e2.gihiragana = 12366;
    e2.gikatakana = 12462;
    e2.gimarmenian = 1379;
    e2.gimel = 1490;
    e2.gimeldagesh = 64306;
    e2.gimeldageshhebrew = 64306;
    e2.gimelhebrew = 1490;
    e2.gjecyrillic = 1107;
    e2.glottalinvertedstroke = 446;
    e2.glottalstop = 660;
    e2.glottalstopinverted = 662;
    e2.glottalstopmod = 704;
    e2.glottalstopreversed = 661;
    e2.glottalstopreversedmod = 705;
    e2.glottalstopreversedsuperior = 740;
    e2.glottalstopstroke = 673;
    e2.glottalstopstrokereversed = 674;
    e2.gmacron = 7713;
    e2.gmonospace = 65351;
    e2.gohiragana = 12372;
    e2.gokatakana = 12468;
    e2.gparen = 9378;
    e2.gpasquare = 13228;
    e2.gradient = 8711;
    e2.grave = 96;
    e2.gravebelowcmb = 790;
    e2.gravecmb = 768;
    e2.gravecomb = 768;
    e2.gravedeva = 2387;
    e2.gravelowmod = 718;
    e2.gravemonospace = 65344;
    e2.gravetonecmb = 832;
    e2.greater = 62;
    e2.greaterequal = 8805;
    e2.greaterequalorless = 8923;
    e2.greatermonospace = 65310;
    e2.greaterorequivalent = 8819;
    e2.greaterorless = 8823;
    e2.greateroverequal = 8807;
    e2.greatersmall = 65125;
    e2.gscript = 609;
    e2.gstroke = 485;
    e2.guhiragana = 12368;
    e2.guillemotleft = 171;
    e2.guillemotright = 187;
    e2.guilsinglleft = 8249;
    e2.guilsinglright = 8250;
    e2.gukatakana = 12464;
    e2.guramusquare = 13080;
    e2.gysquare = 13257;
    e2.h = 104;
    e2.haabkhasiancyrillic = 1193;
    e2.haaltonearabic = 1729;
    e2.habengali = 2489;
    e2.hadescendercyrillic = 1203;
    e2.hadeva = 2361;
    e2.hagujarati = 2745;
    e2.hagurmukhi = 2617;
    e2.haharabic = 1581;
    e2.hahfinalarabic = 65186;
    e2.hahinitialarabic = 65187;
    e2.hahiragana = 12399;
    e2.hahmedialarabic = 65188;
    e2.haitusquare = 13098;
    e2.hakatakana = 12495;
    e2.hakatakanahalfwidth = 65418;
    e2.halantgurmukhi = 2637;
    e2.hamzaarabic = 1569;
    e2.hamzalowarabic = 1569;
    e2.hangulfiller = 12644;
    e2.hardsigncyrillic = 1098;
    e2.harpoonleftbarbup = 8636;
    e2.harpoonrightbarbup = 8640;
    e2.hasquare = 13258;
    e2.hatafpatah = 1458;
    e2.hatafpatah16 = 1458;
    e2.hatafpatah23 = 1458;
    e2.hatafpatah2f = 1458;
    e2.hatafpatahhebrew = 1458;
    e2.hatafpatahnarrowhebrew = 1458;
    e2.hatafpatahquarterhebrew = 1458;
    e2.hatafpatahwidehebrew = 1458;
    e2.hatafqamats = 1459;
    e2.hatafqamats1b = 1459;
    e2.hatafqamats28 = 1459;
    e2.hatafqamats34 = 1459;
    e2.hatafqamatshebrew = 1459;
    e2.hatafqamatsnarrowhebrew = 1459;
    e2.hatafqamatsquarterhebrew = 1459;
    e2.hatafqamatswidehebrew = 1459;
    e2.hatafsegol = 1457;
    e2.hatafsegol17 = 1457;
    e2.hatafsegol24 = 1457;
    e2.hatafsegol30 = 1457;
    e2.hatafsegolhebrew = 1457;
    e2.hatafsegolnarrowhebrew = 1457;
    e2.hatafsegolquarterhebrew = 1457;
    e2.hatafsegolwidehebrew = 1457;
    e2.hbar = 295;
    e2.hbopomofo = 12559;
    e2.hbrevebelow = 7723;
    e2.hcedilla = 7721;
    e2.hcircle = 9431;
    e2.hcircumflex = 293;
    e2.hdieresis = 7719;
    e2.hdotaccent = 7715;
    e2.hdotbelow = 7717;
    e2.he = 1492;
    e2.heart = 9829;
    e2.heartsuitblack = 9829;
    e2.heartsuitwhite = 9825;
    e2.hedagesh = 64308;
    e2.hedageshhebrew = 64308;
    e2.hehaltonearabic = 1729;
    e2.heharabic = 1607;
    e2.hehebrew = 1492;
    e2.hehfinalaltonearabic = 64423;
    e2.hehfinalalttwoarabic = 65258;
    e2.hehfinalarabic = 65258;
    e2.hehhamzaabovefinalarabic = 64421;
    e2.hehhamzaaboveisolatedarabic = 64420;
    e2.hehinitialaltonearabic = 64424;
    e2.hehinitialarabic = 65259;
    e2.hehiragana = 12408;
    e2.hehmedialaltonearabic = 64425;
    e2.hehmedialarabic = 65260;
    e2.heiseierasquare = 13179;
    e2.hekatakana = 12504;
    e2.hekatakanahalfwidth = 65421;
    e2.hekutaarusquare = 13110;
    e2.henghook = 615;
    e2.herutusquare = 13113;
    e2.het = 1495;
    e2.hethebrew = 1495;
    e2.hhook = 614;
    e2.hhooksuperior = 689;
    e2.hieuhacirclekorean = 12923;
    e2.hieuhaparenkorean = 12827;
    e2.hieuhcirclekorean = 12909;
    e2.hieuhkorean = 12622;
    e2.hieuhparenkorean = 12813;
    e2.hihiragana = 12402;
    e2.hikatakana = 12498;
    e2.hikatakanahalfwidth = 65419;
    e2.hiriq = 1460;
    e2.hiriq14 = 1460;
    e2.hiriq21 = 1460;
    e2.hiriq2d = 1460;
    e2.hiriqhebrew = 1460;
    e2.hiriqnarrowhebrew = 1460;
    e2.hiriqquarterhebrew = 1460;
    e2.hiriqwidehebrew = 1460;
    e2.hlinebelow = 7830;
    e2.hmonospace = 65352;
    e2.hoarmenian = 1392;
    e2.hohipthai = 3627;
    e2.hohiragana = 12411;
    e2.hokatakana = 12507;
    e2.hokatakanahalfwidth = 65422;
    e2.holam = 1465;
    e2.holam19 = 1465;
    e2.holam26 = 1465;
    e2.holam32 = 1465;
    e2.holamhebrew = 1465;
    e2.holamnarrowhebrew = 1465;
    e2.holamquarterhebrew = 1465;
    e2.holamwidehebrew = 1465;
    e2.honokhukthai = 3630;
    e2.hookabovecomb = 777;
    e2.hookcmb = 777;
    e2.hookpalatalizedbelowcmb = 801;
    e2.hookretroflexbelowcmb = 802;
    e2.hoonsquare = 13122;
    e2.horicoptic = 1001;
    e2.horizontalbar = 8213;
    e2.horncmb = 795;
    e2.hotsprings = 9832;
    e2.house = 8962;
    e2.hparen = 9379;
    e2.hsuperior = 688;
    e2.hturned = 613;
    e2.huhiragana = 12405;
    e2.huiitosquare = 13107;
    e2.hukatakana = 12501;
    e2.hukatakanahalfwidth = 65420;
    e2.hungarumlaut = 733;
    e2.hungarumlautcmb = 779;
    e2.hv = 405;
    e2.hyphen = 45;
    e2.hypheninferior = 63205;
    e2.hyphenmonospace = 65293;
    e2.hyphensmall = 65123;
    e2.hyphensuperior = 63206;
    e2.hyphentwo = 8208;
    e2.i = 105;
    e2.iacute = 237;
    e2.iacyrillic = 1103;
    e2.ibengali = 2439;
    e2.ibopomofo = 12583;
    e2.ibreve = 301;
    e2.icaron = 464;
    e2.icircle = 9432;
    e2.icircumflex = 238;
    e2.icyrillic = 1110;
    e2.idblgrave = 521;
    e2.ideographearthcircle = 12943;
    e2.ideographfirecircle = 12939;
    e2.ideographicallianceparen = 12863;
    e2.ideographiccallparen = 12858;
    e2.ideographiccentrecircle = 12965;
    e2.ideographicclose = 12294;
    e2.ideographiccomma = 12289;
    e2.ideographiccommaleft = 65380;
    e2.ideographiccongratulationparen = 12855;
    e2.ideographiccorrectcircle = 12963;
    e2.ideographicearthparen = 12847;
    e2.ideographicenterpriseparen = 12861;
    e2.ideographicexcellentcircle = 12957;
    e2.ideographicfestivalparen = 12864;
    e2.ideographicfinancialcircle = 12950;
    e2.ideographicfinancialparen = 12854;
    e2.ideographicfireparen = 12843;
    e2.ideographichaveparen = 12850;
    e2.ideographichighcircle = 12964;
    e2.ideographiciterationmark = 12293;
    e2.ideographiclaborcircle = 12952;
    e2.ideographiclaborparen = 12856;
    e2.ideographicleftcircle = 12967;
    e2.ideographiclowcircle = 12966;
    e2.ideographicmedicinecircle = 12969;
    e2.ideographicmetalparen = 12846;
    e2.ideographicmoonparen = 12842;
    e2.ideographicnameparen = 12852;
    e2.ideographicperiod = 12290;
    e2.ideographicprintcircle = 12958;
    e2.ideographicreachparen = 12867;
    e2.ideographicrepresentparen = 12857;
    e2.ideographicresourceparen = 12862;
    e2.ideographicrightcircle = 12968;
    e2.ideographicsecretcircle = 12953;
    e2.ideographicselfparen = 12866;
    e2.ideographicsocietyparen = 12851;
    e2.ideographicspace = 12288;
    e2.ideographicspecialparen = 12853;
    e2.ideographicstockparen = 12849;
    e2.ideographicstudyparen = 12859;
    e2.ideographicsunparen = 12848;
    e2.ideographicsuperviseparen = 12860;
    e2.ideographicwaterparen = 12844;
    e2.ideographicwoodparen = 12845;
    e2.ideographiczero = 12295;
    e2.ideographmetalcircle = 12942;
    e2.ideographmooncircle = 12938;
    e2.ideographnamecircle = 12948;
    e2.ideographsuncircle = 12944;
    e2.ideographwatercircle = 12940;
    e2.ideographwoodcircle = 12941;
    e2.ideva = 2311;
    e2.idieresis = 239;
    e2.idieresisacute = 7727;
    e2.idieresiscyrillic = 1253;
    e2.idotbelow = 7883;
    e2.iebrevecyrillic = 1239;
    e2.iecyrillic = 1077;
    e2.ieungacirclekorean = 12917;
    e2.ieungaparenkorean = 12821;
    e2.ieungcirclekorean = 12903;
    e2.ieungkorean = 12615;
    e2.ieungparenkorean = 12807;
    e2.igrave = 236;
    e2.igujarati = 2695;
    e2.igurmukhi = 2567;
    e2.ihiragana = 12356;
    e2.ihookabove = 7881;
    e2.iibengali = 2440;
    e2.iicyrillic = 1080;
    e2.iideva = 2312;
    e2.iigujarati = 2696;
    e2.iigurmukhi = 2568;
    e2.iimatragurmukhi = 2624;
    e2.iinvertedbreve = 523;
    e2.iishortcyrillic = 1081;
    e2.iivowelsignbengali = 2496;
    e2.iivowelsigndeva = 2368;
    e2.iivowelsigngujarati = 2752;
    e2.ij = 307;
    e2.ikatakana = 12452;
    e2.ikatakanahalfwidth = 65394;
    e2.ikorean = 12643;
    e2.ilde = 732;
    e2.iluyhebrew = 1452;
    e2.imacron = 299;
    e2.imacroncyrillic = 1251;
    e2.imageorapproximatelyequal = 8787;
    e2.imatragurmukhi = 2623;
    e2.imonospace = 65353;
    e2.increment = 8710;
    e2.infinity = 8734;
    e2.iniarmenian = 1387;
    e2.integral = 8747;
    e2.integralbottom = 8993;
    e2.integralbt = 8993;
    e2.integralex = 63733;
    e2.integraltop = 8992;
    e2.integraltp = 8992;
    e2.intersection = 8745;
    e2.intisquare = 13061;
    e2.invbullet = 9688;
    e2.invcircle = 9689;
    e2.invsmileface = 9787;
    e2.iocyrillic = 1105;
    e2.iogonek = 303;
    e2.iota = 953;
    e2.iotadieresis = 970;
    e2.iotadieresistonos = 912;
    e2.iotalatin = 617;
    e2.iotatonos = 943;
    e2.iparen = 9380;
    e2.irigurmukhi = 2674;
    e2.ismallhiragana = 12355;
    e2.ismallkatakana = 12451;
    e2.ismallkatakanahalfwidth = 65384;
    e2.issharbengali = 2554;
    e2.istroke = 616;
    e2.isuperior = 63213;
    e2.iterationhiragana = 12445;
    e2.iterationkatakana = 12541;
    e2.itilde = 297;
    e2.itildebelow = 7725;
    e2.iubopomofo = 12585;
    e2.iucyrillic = 1102;
    e2.ivowelsignbengali = 2495;
    e2.ivowelsigndeva = 2367;
    e2.ivowelsigngujarati = 2751;
    e2.izhitsacyrillic = 1141;
    e2.izhitsadblgravecyrillic = 1143;
    e2.j = 106;
    e2.jaarmenian = 1393;
    e2.jabengali = 2460;
    e2.jadeva = 2332;
    e2.jagujarati = 2716;
    e2.jagurmukhi = 2588;
    e2.jbopomofo = 12560;
    e2.jcaron = 496;
    e2.jcircle = 9433;
    e2.jcircumflex = 309;
    e2.jcrossedtail = 669;
    e2.jdotlessstroke = 607;
    e2.jecyrillic = 1112;
    e2.jeemarabic = 1580;
    e2.jeemfinalarabic = 65182;
    e2.jeeminitialarabic = 65183;
    e2.jeemmedialarabic = 65184;
    e2.jeharabic = 1688;
    e2.jehfinalarabic = 64395;
    e2.jhabengali = 2461;
    e2.jhadeva = 2333;
    e2.jhagujarati = 2717;
    e2.jhagurmukhi = 2589;
    e2.jheharmenian = 1403;
    e2.jis = 12292;
    e2.jmonospace = 65354;
    e2.jparen = 9381;
    e2.jsuperior = 690;
    e2.k = 107;
    e2.kabashkircyrillic = 1185;
    e2.kabengali = 2453;
    e2.kacute = 7729;
    e2.kacyrillic = 1082;
    e2.kadescendercyrillic = 1179;
    e2.kadeva = 2325;
    e2.kaf = 1499;
    e2.kafarabic = 1603;
    e2.kafdagesh = 64315;
    e2.kafdageshhebrew = 64315;
    e2.kaffinalarabic = 65242;
    e2.kafhebrew = 1499;
    e2.kafinitialarabic = 65243;
    e2.kafmedialarabic = 65244;
    e2.kafrafehebrew = 64333;
    e2.kagujarati = 2709;
    e2.kagurmukhi = 2581;
    e2.kahiragana = 12363;
    e2.kahookcyrillic = 1220;
    e2.kakatakana = 12459;
    e2.kakatakanahalfwidth = 65398;
    e2.kappa = 954;
    e2.kappasymbolgreek = 1008;
    e2.kapyeounmieumkorean = 12657;
    e2.kapyeounphieuphkorean = 12676;
    e2.kapyeounpieupkorean = 12664;
    e2.kapyeounssangpieupkorean = 12665;
    e2.karoriisquare = 13069;
    e2.kashidaautoarabic = 1600;
    e2.kashidaautonosidebearingarabic = 1600;
    e2.kasmallkatakana = 12533;
    e2.kasquare = 13188;
    e2.kasraarabic = 1616;
    e2.kasratanarabic = 1613;
    e2.kastrokecyrillic = 1183;
    e2.katahiraprolongmarkhalfwidth = 65392;
    e2.kaverticalstrokecyrillic = 1181;
    e2.kbopomofo = 12558;
    e2.kcalsquare = 13193;
    e2.kcaron = 489;
    e2.kcedilla = 311;
    e2.kcircle = 9434;
    e2.kcommaaccent = 311;
    e2.kdotbelow = 7731;
    e2.keharmenian = 1412;
    e2.kehiragana = 12369;
    e2.kekatakana = 12465;
    e2.kekatakanahalfwidth = 65401;
    e2.kenarmenian = 1391;
    e2.kesmallkatakana = 12534;
    e2.kgreenlandic = 312;
    e2.khabengali = 2454;
    e2.khacyrillic = 1093;
    e2.khadeva = 2326;
    e2.khagujarati = 2710;
    e2.khagurmukhi = 2582;
    e2.khaharabic = 1582;
    e2.khahfinalarabic = 65190;
    e2.khahinitialarabic = 65191;
    e2.khahmedialarabic = 65192;
    e2.kheicoptic = 999;
    e2.khhadeva = 2393;
    e2.khhagurmukhi = 2649;
    e2.khieukhacirclekorean = 12920;
    e2.khieukhaparenkorean = 12824;
    e2.khieukhcirclekorean = 12906;
    e2.khieukhkorean = 12619;
    e2.khieukhparenkorean = 12810;
    e2.khokhaithai = 3586;
    e2.khokhonthai = 3589;
    e2.khokhuatthai = 3587;
    e2.khokhwaithai = 3588;
    e2.khomutthai = 3675;
    e2.khook = 409;
    e2.khorakhangthai = 3590;
    e2.khzsquare = 13201;
    e2.kihiragana = 12365;
    e2.kikatakana = 12461;
    e2.kikatakanahalfwidth = 65399;
    e2.kiroguramusquare = 13077;
    e2.kiromeetorusquare = 13078;
    e2.kirosquare = 13076;
    e2.kiyeokacirclekorean = 12910;
    e2.kiyeokaparenkorean = 12814;
    e2.kiyeokcirclekorean = 12896;
    e2.kiyeokkorean = 12593;
    e2.kiyeokparenkorean = 12800;
    e2.kiyeoksioskorean = 12595;
    e2.kjecyrillic = 1116;
    e2.klinebelow = 7733;
    e2.klsquare = 13208;
    e2.kmcubedsquare = 13222;
    e2.kmonospace = 65355;
    e2.kmsquaredsquare = 13218;
    e2.kohiragana = 12371;
    e2.kohmsquare = 13248;
    e2.kokaithai = 3585;
    e2.kokatakana = 12467;
    e2.kokatakanahalfwidth = 65402;
    e2.kooposquare = 13086;
    e2.koppacyrillic = 1153;
    e2.koreanstandardsymbol = 12927;
    e2.koroniscmb = 835;
    e2.kparen = 9382;
    e2.kpasquare = 13226;
    e2.ksicyrillic = 1135;
    e2.ktsquare = 13263;
    e2.kturned = 670;
    e2.kuhiragana = 12367;
    e2.kukatakana = 12463;
    e2.kukatakanahalfwidth = 65400;
    e2.kvsquare = 13240;
    e2.kwsquare = 13246;
    e2.l = 108;
    e2.labengali = 2482;
    e2.lacute = 314;
    e2.ladeva = 2354;
    e2.lagujarati = 2738;
    e2.lagurmukhi = 2610;
    e2.lakkhangyaothai = 3653;
    e2.lamaleffinalarabic = 65276;
    e2.lamalefhamzaabovefinalarabic = 65272;
    e2.lamalefhamzaaboveisolatedarabic = 65271;
    e2.lamalefhamzabelowfinalarabic = 65274;
    e2.lamalefhamzabelowisolatedarabic = 65273;
    e2.lamalefisolatedarabic = 65275;
    e2.lamalefmaddaabovefinalarabic = 65270;
    e2.lamalefmaddaaboveisolatedarabic = 65269;
    e2.lamarabic = 1604;
    e2.lambda = 955;
    e2.lambdastroke = 411;
    e2.lamed = 1500;
    e2.lameddagesh = 64316;
    e2.lameddageshhebrew = 64316;
    e2.lamedhebrew = 1500;
    e2.lamfinalarabic = 65246;
    e2.lamhahinitialarabic = 64714;
    e2.laminitialarabic = 65247;
    e2.lamjeeminitialarabic = 64713;
    e2.lamkhahinitialarabic = 64715;
    e2.lamlamhehisolatedarabic = 65010;
    e2.lammedialarabic = 65248;
    e2.lammeemhahinitialarabic = 64904;
    e2.lammeeminitialarabic = 64716;
    e2.largecircle = 9711;
    e2.lbar = 410;
    e2.lbelt = 620;
    e2.lbopomofo = 12556;
    e2.lcaron = 318;
    e2.lcedilla = 316;
    e2.lcircle = 9435;
    e2.lcircumflexbelow = 7741;
    e2.lcommaaccent = 316;
    e2.ldot = 320;
    e2.ldotaccent = 320;
    e2.ldotbelow = 7735;
    e2.ldotbelowmacron = 7737;
    e2.leftangleabovecmb = 794;
    e2.lefttackbelowcmb = 792;
    e2.less = 60;
    e2.lessequal = 8804;
    e2.lessequalorgreater = 8922;
    e2.lessmonospace = 65308;
    e2.lessorequivalent = 8818;
    e2.lessorgreater = 8822;
    e2.lessoverequal = 8806;
    e2.lesssmall = 65124;
    e2.lezh = 622;
    e2.lfblock = 9612;
    e2.lhookretroflex = 621;
    e2.lira = 8356;
    e2.liwnarmenian = 1388;
    e2.lj = 457;
    e2.ljecyrillic = 1113;
    e2.ll = 63168;
    e2.lladeva = 2355;
    e2.llagujarati = 2739;
    e2.llinebelow = 7739;
    e2.llladeva = 2356;
    e2.llvocalicbengali = 2529;
    e2.llvocalicdeva = 2401;
    e2.llvocalicvowelsignbengali = 2531;
    e2.llvocalicvowelsigndeva = 2403;
    e2.lmiddletilde = 619;
    e2.lmonospace = 65356;
    e2.lmsquare = 13264;
    e2.lochulathai = 3628;
    e2.logicaland = 8743;
    e2.logicalnot = 172;
    e2.logicalnotreversed = 8976;
    e2.logicalor = 8744;
    e2.lolingthai = 3621;
    e2.longs = 383;
    e2.lowlinecenterline = 65102;
    e2.lowlinecmb = 818;
    e2.lowlinedashed = 65101;
    e2.lozenge = 9674;
    e2.lparen = 9383;
    e2.lslash = 322;
    e2.lsquare = 8467;
    e2.lsuperior = 63214;
    e2.ltshade = 9617;
    e2.luthai = 3622;
    e2.lvocalicbengali = 2444;
    e2.lvocalicdeva = 2316;
    e2.lvocalicvowelsignbengali = 2530;
    e2.lvocalicvowelsigndeva = 2402;
    e2.lxsquare = 13267;
    e2.m = 109;
    e2.mabengali = 2478;
    e2.macron = 175;
    e2.macronbelowcmb = 817;
    e2.macroncmb = 772;
    e2.macronlowmod = 717;
    e2.macronmonospace = 65507;
    e2.macute = 7743;
    e2.madeva = 2350;
    e2.magujarati = 2734;
    e2.magurmukhi = 2606;
    e2.mahapakhhebrew = 1444;
    e2.mahapakhlefthebrew = 1444;
    e2.mahiragana = 12414;
    e2.maichattawalowleftthai = 63637;
    e2.maichattawalowrightthai = 63636;
    e2.maichattawathai = 3659;
    e2.maichattawaupperleftthai = 63635;
    e2.maieklowleftthai = 63628;
    e2.maieklowrightthai = 63627;
    e2.maiekthai = 3656;
    e2.maiekupperleftthai = 63626;
    e2.maihanakatleftthai = 63620;
    e2.maihanakatthai = 3633;
    e2.maitaikhuleftthai = 63625;
    e2.maitaikhuthai = 3655;
    e2.maitholowleftthai = 63631;
    e2.maitholowrightthai = 63630;
    e2.maithothai = 3657;
    e2.maithoupperleftthai = 63629;
    e2.maitrilowleftthai = 63634;
    e2.maitrilowrightthai = 63633;
    e2.maitrithai = 3658;
    e2.maitriupperleftthai = 63632;
    e2.maiyamokthai = 3654;
    e2.makatakana = 12510;
    e2.makatakanahalfwidth = 65423;
    e2.male = 9794;
    e2.mansyonsquare = 13127;
    e2.maqafhebrew = 1470;
    e2.mars = 9794;
    e2.masoracirclehebrew = 1455;
    e2.masquare = 13187;
    e2.mbopomofo = 12551;
    e2.mbsquare = 13268;
    e2.mcircle = 9436;
    e2.mcubedsquare = 13221;
    e2.mdotaccent = 7745;
    e2.mdotbelow = 7747;
    e2.meemarabic = 1605;
    e2.meemfinalarabic = 65250;
    e2.meeminitialarabic = 65251;
    e2.meemmedialarabic = 65252;
    e2.meemmeeminitialarabic = 64721;
    e2.meemmeemisolatedarabic = 64584;
    e2.meetorusquare = 13133;
    e2.mehiragana = 12417;
    e2.meizierasquare = 13182;
    e2.mekatakana = 12513;
    e2.mekatakanahalfwidth = 65426;
    e2.mem = 1502;
    e2.memdagesh = 64318;
    e2.memdageshhebrew = 64318;
    e2.memhebrew = 1502;
    e2.menarmenian = 1396;
    e2.merkhahebrew = 1445;
    e2.merkhakefulahebrew = 1446;
    e2.merkhakefulalefthebrew = 1446;
    e2.merkhalefthebrew = 1445;
    e2.mhook = 625;
    e2.mhzsquare = 13202;
    e2.middledotkatakanahalfwidth = 65381;
    e2.middot = 183;
    e2.mieumacirclekorean = 12914;
    e2.mieumaparenkorean = 12818;
    e2.mieumcirclekorean = 12900;
    e2.mieumkorean = 12609;
    e2.mieumpansioskorean = 12656;
    e2.mieumparenkorean = 12804;
    e2.mieumpieupkorean = 12654;
    e2.mieumsioskorean = 12655;
    e2.mihiragana = 12415;
    e2.mikatakana = 12511;
    e2.mikatakanahalfwidth = 65424;
    e2.minus = 8722;
    e2.minusbelowcmb = 800;
    e2.minuscircle = 8854;
    e2.minusmod = 727;
    e2.minusplus = 8723;
    e2.minute = 8242;
    e2.miribaarusquare = 13130;
    e2.mirisquare = 13129;
    e2.mlonglegturned = 624;
    e2.mlsquare = 13206;
    e2.mmcubedsquare = 13219;
    e2.mmonospace = 65357;
    e2.mmsquaredsquare = 13215;
    e2.mohiragana = 12418;
    e2.mohmsquare = 13249;
    e2.mokatakana = 12514;
    e2.mokatakanahalfwidth = 65427;
    e2.molsquare = 13270;
    e2.momathai = 3617;
    e2.moverssquare = 13223;
    e2.moverssquaredsquare = 13224;
    e2.mparen = 9384;
    e2.mpasquare = 13227;
    e2.mssquare = 13235;
    e2.msuperior = 63215;
    e2.mturned = 623;
    e2.mu = 181;
    e2.mu1 = 181;
    e2.muasquare = 13186;
    e2.muchgreater = 8811;
    e2.muchless = 8810;
    e2.mufsquare = 13196;
    e2.mugreek = 956;
    e2.mugsquare = 13197;
    e2.muhiragana = 12416;
    e2.mukatakana = 12512;
    e2.mukatakanahalfwidth = 65425;
    e2.mulsquare = 13205;
    e2.multiply = 215;
    e2.mumsquare = 13211;
    e2.munahhebrew = 1443;
    e2.munahlefthebrew = 1443;
    e2.musicalnote = 9834;
    e2.musicalnotedbl = 9835;
    e2.musicflatsign = 9837;
    e2.musicsharpsign = 9839;
    e2.mussquare = 13234;
    e2.muvsquare = 13238;
    e2.muwsquare = 13244;
    e2.mvmegasquare = 13241;
    e2.mvsquare = 13239;
    e2.mwmegasquare = 13247;
    e2.mwsquare = 13245;
    e2.n = 110;
    e2.nabengali = 2472;
    e2.nabla = 8711;
    e2.nacute = 324;
    e2.nadeva = 2344;
    e2.nagujarati = 2728;
    e2.nagurmukhi = 2600;
    e2.nahiragana = 12394;
    e2.nakatakana = 12490;
    e2.nakatakanahalfwidth = 65413;
    e2.napostrophe = 329;
    e2.nasquare = 13185;
    e2.nbopomofo = 12555;
    e2.nbspace = 160;
    e2.ncaron = 328;
    e2.ncedilla = 326;
    e2.ncircle = 9437;
    e2.ncircumflexbelow = 7755;
    e2.ncommaaccent = 326;
    e2.ndotaccent = 7749;
    e2.ndotbelow = 7751;
    e2.nehiragana = 12397;
    e2.nekatakana = 12493;
    e2.nekatakanahalfwidth = 65416;
    e2.newsheqelsign = 8362;
    e2.nfsquare = 13195;
    e2.ngabengali = 2457;
    e2.ngadeva = 2329;
    e2.ngagujarati = 2713;
    e2.ngagurmukhi = 2585;
    e2.ngonguthai = 3591;
    e2.nhiragana = 12435;
    e2.nhookleft = 626;
    e2.nhookretroflex = 627;
    e2.nieunacirclekorean = 12911;
    e2.nieunaparenkorean = 12815;
    e2.nieuncieuckorean = 12597;
    e2.nieuncirclekorean = 12897;
    e2.nieunhieuhkorean = 12598;
    e2.nieunkorean = 12596;
    e2.nieunpansioskorean = 12648;
    e2.nieunparenkorean = 12801;
    e2.nieunsioskorean = 12647;
    e2.nieuntikeutkorean = 12646;
    e2.nihiragana = 12395;
    e2.nikatakana = 12491;
    e2.nikatakanahalfwidth = 65414;
    e2.nikhahitleftthai = 63641;
    e2.nikhahitthai = 3661;
    e2.nine = 57;
    e2.ninearabic = 1641;
    e2.ninebengali = 2543;
    e2.ninecircle = 9320;
    e2.ninecircleinversesansserif = 10130;
    e2.ninedeva = 2415;
    e2.ninegujarati = 2799;
    e2.ninegurmukhi = 2671;
    e2.ninehackarabic = 1641;
    e2.ninehangzhou = 12329;
    e2.nineideographicparen = 12840;
    e2.nineinferior = 8329;
    e2.ninemonospace = 65305;
    e2.nineoldstyle = 63289;
    e2.nineparen = 9340;
    e2.nineperiod = 9360;
    e2.ninepersian = 1785;
    e2.nineroman = 8568;
    e2.ninesuperior = 8313;
    e2.nineteencircle = 9330;
    e2.nineteenparen = 9350;
    e2.nineteenperiod = 9370;
    e2.ninethai = 3673;
    e2.nj = 460;
    e2.njecyrillic = 1114;
    e2.nkatakana = 12531;
    e2.nkatakanahalfwidth = 65437;
    e2.nlegrightlong = 414;
    e2.nlinebelow = 7753;
    e2.nmonospace = 65358;
    e2.nmsquare = 13210;
    e2.nnabengali = 2467;
    e2.nnadeva = 2339;
    e2.nnagujarati = 2723;
    e2.nnagurmukhi = 2595;
    e2.nnnadeva = 2345;
    e2.nohiragana = 12398;
    e2.nokatakana = 12494;
    e2.nokatakanahalfwidth = 65417;
    e2.nonbreakingspace = 160;
    e2.nonenthai = 3603;
    e2.nonuthai = 3609;
    e2.noonarabic = 1606;
    e2.noonfinalarabic = 65254;
    e2.noonghunnaarabic = 1722;
    e2.noonghunnafinalarabic = 64415;
    e2.nooninitialarabic = 65255;
    e2.noonjeeminitialarabic = 64722;
    e2.noonjeemisolatedarabic = 64587;
    e2.noonmedialarabic = 65256;
    e2.noonmeeminitialarabic = 64725;
    e2.noonmeemisolatedarabic = 64590;
    e2.noonnoonfinalarabic = 64653;
    e2.notcontains = 8716;
    e2.notelement = 8713;
    e2.notelementof = 8713;
    e2.notequal = 8800;
    e2.notgreater = 8815;
    e2.notgreaternorequal = 8817;
    e2.notgreaternorless = 8825;
    e2.notidentical = 8802;
    e2.notless = 8814;
    e2.notlessnorequal = 8816;
    e2.notparallel = 8742;
    e2.notprecedes = 8832;
    e2.notsubset = 8836;
    e2.notsucceeds = 8833;
    e2.notsuperset = 8837;
    e2.nowarmenian = 1398;
    e2.nparen = 9385;
    e2.nssquare = 13233;
    e2.nsuperior = 8319;
    e2.ntilde = 241;
    e2.nu = 957;
    e2.nuhiragana = 12396;
    e2.nukatakana = 12492;
    e2.nukatakanahalfwidth = 65415;
    e2.nuktabengali = 2492;
    e2.nuktadeva = 2364;
    e2.nuktagujarati = 2748;
    e2.nuktagurmukhi = 2620;
    e2.numbersign = 35;
    e2.numbersignmonospace = 65283;
    e2.numbersignsmall = 65119;
    e2.numeralsigngreek = 884;
    e2.numeralsignlowergreek = 885;
    e2.numero = 8470;
    e2.nun = 1504;
    e2.nundagesh = 64320;
    e2.nundageshhebrew = 64320;
    e2.nunhebrew = 1504;
    e2.nvsquare = 13237;
    e2.nwsquare = 13243;
    e2.nyabengali = 2462;
    e2.nyadeva = 2334;
    e2.nyagujarati = 2718;
    e2.nyagurmukhi = 2590;
    e2.o = 111;
    e2.oacute = 243;
    e2.oangthai = 3629;
    e2.obarred = 629;
    e2.obarredcyrillic = 1257;
    e2.obarreddieresiscyrillic = 1259;
    e2.obengali = 2451;
    e2.obopomofo = 12571;
    e2.obreve = 335;
    e2.ocandradeva = 2321;
    e2.ocandragujarati = 2705;
    e2.ocandravowelsigndeva = 2377;
    e2.ocandravowelsigngujarati = 2761;
    e2.ocaron = 466;
    e2.ocircle = 9438;
    e2.ocircumflex = 244;
    e2.ocircumflexacute = 7889;
    e2.ocircumflexdotbelow = 7897;
    e2.ocircumflexgrave = 7891;
    e2.ocircumflexhookabove = 7893;
    e2.ocircumflextilde = 7895;
    e2.ocyrillic = 1086;
    e2.odblacute = 337;
    e2.odblgrave = 525;
    e2.odeva = 2323;
    e2.odieresis = 246;
    e2.odieresiscyrillic = 1255;
    e2.odotbelow = 7885;
    e2.oe = 339;
    e2.oekorean = 12634;
    e2.ogonek = 731;
    e2.ogonekcmb = 808;
    e2.ograve = 242;
    e2.ogujarati = 2707;
    e2.oharmenian = 1413;
    e2.ohiragana = 12362;
    e2.ohookabove = 7887;
    e2.ohorn = 417;
    e2.ohornacute = 7899;
    e2.ohorndotbelow = 7907;
    e2.ohorngrave = 7901;
    e2.ohornhookabove = 7903;
    e2.ohorntilde = 7905;
    e2.ohungarumlaut = 337;
    e2.oi = 419;
    e2.oinvertedbreve = 527;
    e2.okatakana = 12458;
    e2.okatakanahalfwidth = 65397;
    e2.okorean = 12631;
    e2.olehebrew = 1451;
    e2.omacron = 333;
    e2.omacronacute = 7763;
    e2.omacrongrave = 7761;
    e2.omdeva = 2384;
    e2.omega = 969;
    e2.omega1 = 982;
    e2.omegacyrillic = 1121;
    e2.omegalatinclosed = 631;
    e2.omegaroundcyrillic = 1147;
    e2.omegatitlocyrillic = 1149;
    e2.omegatonos = 974;
    e2.omgujarati = 2768;
    e2.omicron = 959;
    e2.omicrontonos = 972;
    e2.omonospace = 65359;
    e2.one = 49;
    e2.onearabic = 1633;
    e2.onebengali = 2535;
    e2.onecircle = 9312;
    e2.onecircleinversesansserif = 10122;
    e2.onedeva = 2407;
    e2.onedotenleader = 8228;
    e2.oneeighth = 8539;
    e2.onefitted = 63196;
    e2.onegujarati = 2791;
    e2.onegurmukhi = 2663;
    e2.onehackarabic = 1633;
    e2.onehalf = 189;
    e2.onehangzhou = 12321;
    e2.oneideographicparen = 12832;
    e2.oneinferior = 8321;
    e2.onemonospace = 65297;
    e2.onenumeratorbengali = 2548;
    e2.oneoldstyle = 63281;
    e2.oneparen = 9332;
    e2.oneperiod = 9352;
    e2.onepersian = 1777;
    e2.onequarter = 188;
    e2.oneroman = 8560;
    e2.onesuperior = 185;
    e2.onethai = 3665;
    e2.onethird = 8531;
    e2.oogonek = 491;
    e2.oogonekmacron = 493;
    e2.oogurmukhi = 2579;
    e2.oomatragurmukhi = 2635;
    e2.oopen = 596;
    e2.oparen = 9386;
    e2.openbullet = 9702;
    e2.option = 8997;
    e2.ordfeminine = 170;
    e2.ordmasculine = 186;
    e2.orthogonal = 8735;
    e2.oshortdeva = 2322;
    e2.oshortvowelsigndeva = 2378;
    e2.oslash = 248;
    e2.oslashacute = 511;
    e2.osmallhiragana = 12361;
    e2.osmallkatakana = 12457;
    e2.osmallkatakanahalfwidth = 65387;
    e2.ostrokeacute = 511;
    e2.osuperior = 63216;
    e2.otcyrillic = 1151;
    e2.otilde = 245;
    e2.otildeacute = 7757;
    e2.otildedieresis = 7759;
    e2.oubopomofo = 12577;
    e2.overline = 8254;
    e2.overlinecenterline = 65098;
    e2.overlinecmb = 773;
    e2.overlinedashed = 65097;
    e2.overlinedblwavy = 65100;
    e2.overlinewavy = 65099;
    e2.overscore = 175;
    e2.ovowelsignbengali = 2507;
    e2.ovowelsigndeva = 2379;
    e2.ovowelsigngujarati = 2763;
    e2.p = 112;
    e2.paampssquare = 13184;
    e2.paasentosquare = 13099;
    e2.pabengali = 2474;
    e2.pacute = 7765;
    e2.padeva = 2346;
    e2.pagedown = 8671;
    e2.pageup = 8670;
    e2.pagujarati = 2730;
    e2.pagurmukhi = 2602;
    e2.pahiragana = 12401;
    e2.paiyannoithai = 3631;
    e2.pakatakana = 12497;
    e2.palatalizationcyrilliccmb = 1156;
    e2.palochkacyrillic = 1216;
    e2.pansioskorean = 12671;
    e2.paragraph = 182;
    e2.parallel = 8741;
    e2.parenleft = 40;
    e2.parenleftaltonearabic = 64830;
    e2.parenleftbt = 63725;
    e2.parenleftex = 63724;
    e2.parenleftinferior = 8333;
    e2.parenleftmonospace = 65288;
    e2.parenleftsmall = 65113;
    e2.parenleftsuperior = 8317;
    e2.parenlefttp = 63723;
    e2.parenleftvertical = 65077;
    e2.parenright = 41;
    e2.parenrightaltonearabic = 64831;
    e2.parenrightbt = 63736;
    e2.parenrightex = 63735;
    e2.parenrightinferior = 8334;
    e2.parenrightmonospace = 65289;
    e2.parenrightsmall = 65114;
    e2.parenrightsuperior = 8318;
    e2.parenrighttp = 63734;
    e2.parenrightvertical = 65078;
    e2.partialdiff = 8706;
    e2.paseqhebrew = 1472;
    e2.pashtahebrew = 1433;
    e2.pasquare = 13225;
    e2.patah = 1463;
    e2.patah11 = 1463;
    e2.patah1d = 1463;
    e2.patah2a = 1463;
    e2.patahhebrew = 1463;
    e2.patahnarrowhebrew = 1463;
    e2.patahquarterhebrew = 1463;
    e2.patahwidehebrew = 1463;
    e2.pazerhebrew = 1441;
    e2.pbopomofo = 12550;
    e2.pcircle = 9439;
    e2.pdotaccent = 7767;
    e2.pe = 1508;
    e2.pecyrillic = 1087;
    e2.pedagesh = 64324;
    e2.pedageshhebrew = 64324;
    e2.peezisquare = 13115;
    e2.pefinaldageshhebrew = 64323;
    e2.peharabic = 1662;
    e2.peharmenian = 1402;
    e2.pehebrew = 1508;
    e2.pehfinalarabic = 64343;
    e2.pehinitialarabic = 64344;
    e2.pehiragana = 12410;
    e2.pehmedialarabic = 64345;
    e2.pekatakana = 12506;
    e2.pemiddlehookcyrillic = 1191;
    e2.perafehebrew = 64334;
    e2.percent = 37;
    e2.percentarabic = 1642;
    e2.percentmonospace = 65285;
    e2.percentsmall = 65130;
    e2.period = 46;
    e2.periodarmenian = 1417;
    e2.periodcentered = 183;
    e2.periodhalfwidth = 65377;
    e2.periodinferior = 63207;
    e2.periodmonospace = 65294;
    e2.periodsmall = 65106;
    e2.periodsuperior = 63208;
    e2.perispomenigreekcmb = 834;
    e2.perpendicular = 8869;
    e2.perthousand = 8240;
    e2.peseta = 8359;
    e2.pfsquare = 13194;
    e2.phabengali = 2475;
    e2.phadeva = 2347;
    e2.phagujarati = 2731;
    e2.phagurmukhi = 2603;
    e2.phi = 966;
    e2.phi1 = 981;
    e2.phieuphacirclekorean = 12922;
    e2.phieuphaparenkorean = 12826;
    e2.phieuphcirclekorean = 12908;
    e2.phieuphkorean = 12621;
    e2.phieuphparenkorean = 12812;
    e2.philatin = 632;
    e2.phinthuthai = 3642;
    e2.phisymbolgreek = 981;
    e2.phook = 421;
    e2.phophanthai = 3614;
    e2.phophungthai = 3612;
    e2.phosamphaothai = 3616;
    e2.pi = 960;
    e2.pieupacirclekorean = 12915;
    e2.pieupaparenkorean = 12819;
    e2.pieupcieuckorean = 12662;
    e2.pieupcirclekorean = 12901;
    e2.pieupkiyeokkorean = 12658;
    e2.pieupkorean = 12610;
    e2.pieupparenkorean = 12805;
    e2.pieupsioskiyeokkorean = 12660;
    e2.pieupsioskorean = 12612;
    e2.pieupsiostikeutkorean = 12661;
    e2.pieupthieuthkorean = 12663;
    e2.pieuptikeutkorean = 12659;
    e2.pihiragana = 12404;
    e2.pikatakana = 12500;
    e2.pisymbolgreek = 982;
    e2.piwrarmenian = 1411;
    e2.planckover2pi = 8463;
    e2.planckover2pi1 = 8463;
    e2.plus = 43;
    e2.plusbelowcmb = 799;
    e2.pluscircle = 8853;
    e2.plusminus = 177;
    e2.plusmod = 726;
    e2.plusmonospace = 65291;
    e2.plussmall = 65122;
    e2.plussuperior = 8314;
    e2.pmonospace = 65360;
    e2.pmsquare = 13272;
    e2.pohiragana = 12413;
    e2.pointingindexdownwhite = 9759;
    e2.pointingindexleftwhite = 9756;
    e2.pointingindexrightwhite = 9758;
    e2.pointingindexupwhite = 9757;
    e2.pokatakana = 12509;
    e2.poplathai = 3611;
    e2.postalmark = 12306;
    e2.postalmarkface = 12320;
    e2.pparen = 9387;
    e2.precedes = 8826;
    e2.prescription = 8478;
    e2.primemod = 697;
    e2.primereversed = 8245;
    e2.product = 8719;
    e2.projective = 8965;
    e2.prolongedkana = 12540;
    e2.propellor = 8984;
    e2.propersubset = 8834;
    e2.propersuperset = 8835;
    e2.proportion = 8759;
    e2.proportional = 8733;
    e2.psi = 968;
    e2.psicyrillic = 1137;
    e2.psilipneumatacyrilliccmb = 1158;
    e2.pssquare = 13232;
    e2.puhiragana = 12407;
    e2.pukatakana = 12503;
    e2.pvsquare = 13236;
    e2.pwsquare = 13242;
    e2.q = 113;
    e2.qadeva = 2392;
    e2.qadmahebrew = 1448;
    e2.qafarabic = 1602;
    e2.qaffinalarabic = 65238;
    e2.qafinitialarabic = 65239;
    e2.qafmedialarabic = 65240;
    e2.qamats = 1464;
    e2.qamats10 = 1464;
    e2.qamats1a = 1464;
    e2.qamats1c = 1464;
    e2.qamats27 = 1464;
    e2.qamats29 = 1464;
    e2.qamats33 = 1464;
    e2.qamatsde = 1464;
    e2.qamatshebrew = 1464;
    e2.qamatsnarrowhebrew = 1464;
    e2.qamatsqatanhebrew = 1464;
    e2.qamatsqatannarrowhebrew = 1464;
    e2.qamatsqatanquarterhebrew = 1464;
    e2.qamatsqatanwidehebrew = 1464;
    e2.qamatsquarterhebrew = 1464;
    e2.qamatswidehebrew = 1464;
    e2.qarneyparahebrew = 1439;
    e2.qbopomofo = 12561;
    e2.qcircle = 9440;
    e2.qhook = 672;
    e2.qmonospace = 65361;
    e2.qof = 1511;
    e2.qofdagesh = 64327;
    e2.qofdageshhebrew = 64327;
    e2.qofhebrew = 1511;
    e2.qparen = 9388;
    e2.quarternote = 9833;
    e2.qubuts = 1467;
    e2.qubuts18 = 1467;
    e2.qubuts25 = 1467;
    e2.qubuts31 = 1467;
    e2.qubutshebrew = 1467;
    e2.qubutsnarrowhebrew = 1467;
    e2.qubutsquarterhebrew = 1467;
    e2.qubutswidehebrew = 1467;
    e2.question = 63;
    e2.questionarabic = 1567;
    e2.questionarmenian = 1374;
    e2.questiondown = 191;
    e2.questiondownsmall = 63423;
    e2.questiongreek = 894;
    e2.questionmonospace = 65311;
    e2.questionsmall = 63295;
    e2.quotedbl = 34;
    e2.quotedblbase = 8222;
    e2.quotedblleft = 8220;
    e2.quotedblmonospace = 65282;
    e2.quotedblprime = 12318;
    e2.quotedblprimereversed = 12317;
    e2.quotedblright = 8221;
    e2.quoteleft = 8216;
    e2.quoteleftreversed = 8219;
    e2.quotereversed = 8219;
    e2.quoteright = 8217;
    e2.quoterightn = 329;
    e2.quotesinglbase = 8218;
    e2.quotesingle = 39;
    e2.quotesinglemonospace = 65287;
    e2.r = 114;
    e2.raarmenian = 1404;
    e2.rabengali = 2480;
    e2.racute = 341;
    e2.radeva = 2352;
    e2.radical = 8730;
    e2.radicalex = 63717;
    e2.radoverssquare = 13230;
    e2.radoverssquaredsquare = 13231;
    e2.radsquare = 13229;
    e2.rafe = 1471;
    e2.rafehebrew = 1471;
    e2.ragujarati = 2736;
    e2.ragurmukhi = 2608;
    e2.rahiragana = 12425;
    e2.rakatakana = 12521;
    e2.rakatakanahalfwidth = 65431;
    e2.ralowerdiagonalbengali = 2545;
    e2.ramiddlediagonalbengali = 2544;
    e2.ramshorn = 612;
    e2.ratio = 8758;
    e2.rbopomofo = 12566;
    e2.rcaron = 345;
    e2.rcedilla = 343;
    e2.rcircle = 9441;
    e2.rcommaaccent = 343;
    e2.rdblgrave = 529;
    e2.rdotaccent = 7769;
    e2.rdotbelow = 7771;
    e2.rdotbelowmacron = 7773;
    e2.referencemark = 8251;
    e2.reflexsubset = 8838;
    e2.reflexsuperset = 8839;
    e2.registered = 174;
    e2.registersans = 63720;
    e2.registerserif = 63194;
    e2.reharabic = 1585;
    e2.reharmenian = 1408;
    e2.rehfinalarabic = 65198;
    e2.rehiragana = 12428;
    e2.rekatakana = 12524;
    e2.rekatakanahalfwidth = 65434;
    e2.resh = 1512;
    e2.reshdageshhebrew = 64328;
    e2.reshhebrew = 1512;
    e2.reversedtilde = 8765;
    e2.reviahebrew = 1431;
    e2.reviamugrashhebrew = 1431;
    e2.revlogicalnot = 8976;
    e2.rfishhook = 638;
    e2.rfishhookreversed = 639;
    e2.rhabengali = 2525;
    e2.rhadeva = 2397;
    e2.rho = 961;
    e2.rhook = 637;
    e2.rhookturned = 635;
    e2.rhookturnedsuperior = 693;
    e2.rhosymbolgreek = 1009;
    e2.rhotichookmod = 734;
    e2.rieulacirclekorean = 12913;
    e2.rieulaparenkorean = 12817;
    e2.rieulcirclekorean = 12899;
    e2.rieulhieuhkorean = 12608;
    e2.rieulkiyeokkorean = 12602;
    e2.rieulkiyeoksioskorean = 12649;
    e2.rieulkorean = 12601;
    e2.rieulmieumkorean = 12603;
    e2.rieulpansioskorean = 12652;
    e2.rieulparenkorean = 12803;
    e2.rieulphieuphkorean = 12607;
    e2.rieulpieupkorean = 12604;
    e2.rieulpieupsioskorean = 12651;
    e2.rieulsioskorean = 12605;
    e2.rieulthieuthkorean = 12606;
    e2.rieultikeutkorean = 12650;
    e2.rieulyeorinhieuhkorean = 12653;
    e2.rightangle = 8735;
    e2.righttackbelowcmb = 793;
    e2.righttriangle = 8895;
    e2.rihiragana = 12426;
    e2.rikatakana = 12522;
    e2.rikatakanahalfwidth = 65432;
    e2.ring = 730;
    e2.ringbelowcmb = 805;
    e2.ringcmb = 778;
    e2.ringhalfleft = 703;
    e2.ringhalfleftarmenian = 1369;
    e2.ringhalfleftbelowcmb = 796;
    e2.ringhalfleftcentered = 723;
    e2.ringhalfright = 702;
    e2.ringhalfrightbelowcmb = 825;
    e2.ringhalfrightcentered = 722;
    e2.rinvertedbreve = 531;
    e2.rittorusquare = 13137;
    e2.rlinebelow = 7775;
    e2.rlongleg = 636;
    e2.rlonglegturned = 634;
    e2.rmonospace = 65362;
    e2.rohiragana = 12429;
    e2.rokatakana = 12525;
    e2.rokatakanahalfwidth = 65435;
    e2.roruathai = 3619;
    e2.rparen = 9389;
    e2.rrabengali = 2524;
    e2.rradeva = 2353;
    e2.rragurmukhi = 2652;
    e2.rreharabic = 1681;
    e2.rrehfinalarabic = 64397;
    e2.rrvocalicbengali = 2528;
    e2.rrvocalicdeva = 2400;
    e2.rrvocalicgujarati = 2784;
    e2.rrvocalicvowelsignbengali = 2500;
    e2.rrvocalicvowelsigndeva = 2372;
    e2.rrvocalicvowelsigngujarati = 2756;
    e2.rsuperior = 63217;
    e2.rtblock = 9616;
    e2.rturned = 633;
    e2.rturnedsuperior = 692;
    e2.ruhiragana = 12427;
    e2.rukatakana = 12523;
    e2.rukatakanahalfwidth = 65433;
    e2.rupeemarkbengali = 2546;
    e2.rupeesignbengali = 2547;
    e2.rupiah = 63197;
    e2.ruthai = 3620;
    e2.rvocalicbengali = 2443;
    e2.rvocalicdeva = 2315;
    e2.rvocalicgujarati = 2699;
    e2.rvocalicvowelsignbengali = 2499;
    e2.rvocalicvowelsigndeva = 2371;
    e2.rvocalicvowelsigngujarati = 2755;
    e2.s = 115;
    e2.sabengali = 2488;
    e2.sacute = 347;
    e2.sacutedotaccent = 7781;
    e2.sadarabic = 1589;
    e2.sadeva = 2360;
    e2.sadfinalarabic = 65210;
    e2.sadinitialarabic = 65211;
    e2.sadmedialarabic = 65212;
    e2.sagujarati = 2744;
    e2.sagurmukhi = 2616;
    e2.sahiragana = 12373;
    e2.sakatakana = 12469;
    e2.sakatakanahalfwidth = 65403;
    e2.sallallahoualayhewasallamarabic = 65018;
    e2.samekh = 1505;
    e2.samekhdagesh = 64321;
    e2.samekhdageshhebrew = 64321;
    e2.samekhhebrew = 1505;
    e2.saraaathai = 3634;
    e2.saraaethai = 3649;
    e2.saraaimaimalaithai = 3652;
    e2.saraaimaimuanthai = 3651;
    e2.saraamthai = 3635;
    e2.saraathai = 3632;
    e2.saraethai = 3648;
    e2.saraiileftthai = 63622;
    e2.saraiithai = 3637;
    e2.saraileftthai = 63621;
    e2.saraithai = 3636;
    e2.saraothai = 3650;
    e2.saraueeleftthai = 63624;
    e2.saraueethai = 3639;
    e2.saraueleftthai = 63623;
    e2.sarauethai = 3638;
    e2.sarauthai = 3640;
    e2.sarauuthai = 3641;
    e2.sbopomofo = 12569;
    e2.scaron = 353;
    e2.scarondotaccent = 7783;
    e2.scedilla = 351;
    e2.schwa = 601;
    e2.schwacyrillic = 1241;
    e2.schwadieresiscyrillic = 1243;
    e2.schwahook = 602;
    e2.scircle = 9442;
    e2.scircumflex = 349;
    e2.scommaaccent = 537;
    e2.sdotaccent = 7777;
    e2.sdotbelow = 7779;
    e2.sdotbelowdotaccent = 7785;
    e2.seagullbelowcmb = 828;
    e2.second = 8243;
    e2.secondtonechinese = 714;
    e2.section = 167;
    e2.seenarabic = 1587;
    e2.seenfinalarabic = 65202;
    e2.seeninitialarabic = 65203;
    e2.seenmedialarabic = 65204;
    e2.segol = 1462;
    e2.segol13 = 1462;
    e2.segol1f = 1462;
    e2.segol2c = 1462;
    e2.segolhebrew = 1462;
    e2.segolnarrowhebrew = 1462;
    e2.segolquarterhebrew = 1462;
    e2.segoltahebrew = 1426;
    e2.segolwidehebrew = 1462;
    e2.seharmenian = 1405;
    e2.sehiragana = 12379;
    e2.sekatakana = 12475;
    e2.sekatakanahalfwidth = 65406;
    e2.semicolon = 59;
    e2.semicolonarabic = 1563;
    e2.semicolonmonospace = 65307;
    e2.semicolonsmall = 65108;
    e2.semivoicedmarkkana = 12444;
    e2.semivoicedmarkkanahalfwidth = 65439;
    e2.sentisquare = 13090;
    e2.sentosquare = 13091;
    e2.seven = 55;
    e2.sevenarabic = 1639;
    e2.sevenbengali = 2541;
    e2.sevencircle = 9318;
    e2.sevencircleinversesansserif = 10128;
    e2.sevendeva = 2413;
    e2.seveneighths = 8542;
    e2.sevengujarati = 2797;
    e2.sevengurmukhi = 2669;
    e2.sevenhackarabic = 1639;
    e2.sevenhangzhou = 12327;
    e2.sevenideographicparen = 12838;
    e2.seveninferior = 8327;
    e2.sevenmonospace = 65303;
    e2.sevenoldstyle = 63287;
    e2.sevenparen = 9338;
    e2.sevenperiod = 9358;
    e2.sevenpersian = 1783;
    e2.sevenroman = 8566;
    e2.sevensuperior = 8311;
    e2.seventeencircle = 9328;
    e2.seventeenparen = 9348;
    e2.seventeenperiod = 9368;
    e2.seventhai = 3671;
    e2.sfthyphen = 173;
    e2.shaarmenian = 1399;
    e2.shabengali = 2486;
    e2.shacyrillic = 1096;
    e2.shaddaarabic = 1617;
    e2.shaddadammaarabic = 64609;
    e2.shaddadammatanarabic = 64606;
    e2.shaddafathaarabic = 64608;
    e2.shaddakasraarabic = 64610;
    e2.shaddakasratanarabic = 64607;
    e2.shade = 9618;
    e2.shadedark = 9619;
    e2.shadelight = 9617;
    e2.shademedium = 9618;
    e2.shadeva = 2358;
    e2.shagujarati = 2742;
    e2.shagurmukhi = 2614;
    e2.shalshelethebrew = 1427;
    e2.shbopomofo = 12565;
    e2.shchacyrillic = 1097;
    e2.sheenarabic = 1588;
    e2.sheenfinalarabic = 65206;
    e2.sheeninitialarabic = 65207;
    e2.sheenmedialarabic = 65208;
    e2.sheicoptic = 995;
    e2.sheqel = 8362;
    e2.sheqelhebrew = 8362;
    e2.sheva = 1456;
    e2.sheva115 = 1456;
    e2.sheva15 = 1456;
    e2.sheva22 = 1456;
    e2.sheva2e = 1456;
    e2.shevahebrew = 1456;
    e2.shevanarrowhebrew = 1456;
    e2.shevaquarterhebrew = 1456;
    e2.shevawidehebrew = 1456;
    e2.shhacyrillic = 1211;
    e2.shimacoptic = 1005;
    e2.shin = 1513;
    e2.shindagesh = 64329;
    e2.shindageshhebrew = 64329;
    e2.shindageshshindot = 64300;
    e2.shindageshshindothebrew = 64300;
    e2.shindageshsindot = 64301;
    e2.shindageshsindothebrew = 64301;
    e2.shindothebrew = 1473;
    e2.shinhebrew = 1513;
    e2.shinshindot = 64298;
    e2.shinshindothebrew = 64298;
    e2.shinsindot = 64299;
    e2.shinsindothebrew = 64299;
    e2.shook = 642;
    e2.sigma = 963;
    e2.sigma1 = 962;
    e2.sigmafinal = 962;
    e2.sigmalunatesymbolgreek = 1010;
    e2.sihiragana = 12375;
    e2.sikatakana = 12471;
    e2.sikatakanahalfwidth = 65404;
    e2.siluqhebrew = 1469;
    e2.siluqlefthebrew = 1469;
    e2.similar = 8764;
    e2.sindothebrew = 1474;
    e2.siosacirclekorean = 12916;
    e2.siosaparenkorean = 12820;
    e2.sioscieuckorean = 12670;
    e2.sioscirclekorean = 12902;
    e2.sioskiyeokkorean = 12666;
    e2.sioskorean = 12613;
    e2.siosnieunkorean = 12667;
    e2.siosparenkorean = 12806;
    e2.siospieupkorean = 12669;
    e2.siostikeutkorean = 12668;
    e2.six = 54;
    e2.sixarabic = 1638;
    e2.sixbengali = 2540;
    e2.sixcircle = 9317;
    e2.sixcircleinversesansserif = 10127;
    e2.sixdeva = 2412;
    e2.sixgujarati = 2796;
    e2.sixgurmukhi = 2668;
    e2.sixhackarabic = 1638;
    e2.sixhangzhou = 12326;
    e2.sixideographicparen = 12837;
    e2.sixinferior = 8326;
    e2.sixmonospace = 65302;
    e2.sixoldstyle = 63286;
    e2.sixparen = 9337;
    e2.sixperiod = 9357;
    e2.sixpersian = 1782;
    e2.sixroman = 8565;
    e2.sixsuperior = 8310;
    e2.sixteencircle = 9327;
    e2.sixteencurrencydenominatorbengali = 2553;
    e2.sixteenparen = 9347;
    e2.sixteenperiod = 9367;
    e2.sixthai = 3670;
    e2.slash = 47;
    e2.slashmonospace = 65295;
    e2.slong = 383;
    e2.slongdotaccent = 7835;
    e2.smileface = 9786;
    e2.smonospace = 65363;
    e2.sofpasuqhebrew = 1475;
    e2.softhyphen = 173;
    e2.softsigncyrillic = 1100;
    e2.sohiragana = 12381;
    e2.sokatakana = 12477;
    e2.sokatakanahalfwidth = 65407;
    e2.soliduslongoverlaycmb = 824;
    e2.solidusshortoverlaycmb = 823;
    e2.sorusithai = 3625;
    e2.sosalathai = 3624;
    e2.sosothai = 3595;
    e2.sosuathai = 3626;
    e2.space = 32;
    e2.spacehackarabic = 32;
    e2.spade = 9824;
    e2.spadesuitblack = 9824;
    e2.spadesuitwhite = 9828;
    e2.sparen = 9390;
    e2.squarebelowcmb = 827;
    e2.squarecc = 13252;
    e2.squarecm = 13213;
    e2.squarediagonalcrosshatchfill = 9641;
    e2.squarehorizontalfill = 9636;
    e2.squarekg = 13199;
    e2.squarekm = 13214;
    e2.squarekmcapital = 13262;
    e2.squareln = 13265;
    e2.squarelog = 13266;
    e2.squaremg = 13198;
    e2.squaremil = 13269;
    e2.squaremm = 13212;
    e2.squaremsquared = 13217;
    e2.squareorthogonalcrosshatchfill = 9638;
    e2.squareupperlefttolowerrightfill = 9639;
    e2.squareupperrighttolowerleftfill = 9640;
    e2.squareverticalfill = 9637;
    e2.squarewhitewithsmallblack = 9635;
    e2.srsquare = 13275;
    e2.ssabengali = 2487;
    e2.ssadeva = 2359;
    e2.ssagujarati = 2743;
    e2.ssangcieuckorean = 12617;
    e2.ssanghieuhkorean = 12677;
    e2.ssangieungkorean = 12672;
    e2.ssangkiyeokkorean = 12594;
    e2.ssangnieunkorean = 12645;
    e2.ssangpieupkorean = 12611;
    e2.ssangsioskorean = 12614;
    e2.ssangtikeutkorean = 12600;
    e2.ssuperior = 63218;
    e2.sterling = 163;
    e2.sterlingmonospace = 65505;
    e2.strokelongoverlaycmb = 822;
    e2.strokeshortoverlaycmb = 821;
    e2.subset = 8834;
    e2.subsetnotequal = 8842;
    e2.subsetorequal = 8838;
    e2.succeeds = 8827;
    e2.suchthat = 8715;
    e2.suhiragana = 12377;
    e2.sukatakana = 12473;
    e2.sukatakanahalfwidth = 65405;
    e2.sukunarabic = 1618;
    e2.summation = 8721;
    e2.sun = 9788;
    e2.superset = 8835;
    e2.supersetnotequal = 8843;
    e2.supersetorequal = 8839;
    e2.svsquare = 13276;
    e2.syouwaerasquare = 13180;
    e2.t = 116;
    e2.tabengali = 2468;
    e2.tackdown = 8868;
    e2.tackleft = 8867;
    e2.tadeva = 2340;
    e2.tagujarati = 2724;
    e2.tagurmukhi = 2596;
    e2.taharabic = 1591;
    e2.tahfinalarabic = 65218;
    e2.tahinitialarabic = 65219;
    e2.tahiragana = 12383;
    e2.tahmedialarabic = 65220;
    e2.taisyouerasquare = 13181;
    e2.takatakana = 12479;
    e2.takatakanahalfwidth = 65408;
    e2.tatweelarabic = 1600;
    e2.tau = 964;
    e2.tav = 1514;
    e2.tavdages = 64330;
    e2.tavdagesh = 64330;
    e2.tavdageshhebrew = 64330;
    e2.tavhebrew = 1514;
    e2.tbar = 359;
    e2.tbopomofo = 12554;
    e2.tcaron = 357;
    e2.tccurl = 680;
    e2.tcedilla = 355;
    e2.tcheharabic = 1670;
    e2.tchehfinalarabic = 64379;
    e2.tchehinitialarabic = 64380;
    e2.tchehmedialarabic = 64381;
    e2.tcircle = 9443;
    e2.tcircumflexbelow = 7793;
    e2.tcommaaccent = 355;
    e2.tdieresis = 7831;
    e2.tdotaccent = 7787;
    e2.tdotbelow = 7789;
    e2.tecyrillic = 1090;
    e2.tedescendercyrillic = 1197;
    e2.teharabic = 1578;
    e2.tehfinalarabic = 65174;
    e2.tehhahinitialarabic = 64674;
    e2.tehhahisolatedarabic = 64524;
    e2.tehinitialarabic = 65175;
    e2.tehiragana = 12390;
    e2.tehjeeminitialarabic = 64673;
    e2.tehjeemisolatedarabic = 64523;
    e2.tehmarbutaarabic = 1577;
    e2.tehmarbutafinalarabic = 65172;
    e2.tehmedialarabic = 65176;
    e2.tehmeeminitialarabic = 64676;
    e2.tehmeemisolatedarabic = 64526;
    e2.tehnoonfinalarabic = 64627;
    e2.tekatakana = 12486;
    e2.tekatakanahalfwidth = 65411;
    e2.telephone = 8481;
    e2.telephoneblack = 9742;
    e2.telishagedolahebrew = 1440;
    e2.telishaqetanahebrew = 1449;
    e2.tencircle = 9321;
    e2.tenideographicparen = 12841;
    e2.tenparen = 9341;
    e2.tenperiod = 9361;
    e2.tenroman = 8569;
    e2.tesh = 679;
    e2.tet = 1496;
    e2.tetdagesh = 64312;
    e2.tetdageshhebrew = 64312;
    e2.tethebrew = 1496;
    e2.tetsecyrillic = 1205;
    e2.tevirhebrew = 1435;
    e2.tevirlefthebrew = 1435;
    e2.thabengali = 2469;
    e2.thadeva = 2341;
    e2.thagujarati = 2725;
    e2.thagurmukhi = 2597;
    e2.thalarabic = 1584;
    e2.thalfinalarabic = 65196;
    e2.thanthakhatlowleftthai = 63640;
    e2.thanthakhatlowrightthai = 63639;
    e2.thanthakhatthai = 3660;
    e2.thanthakhatupperleftthai = 63638;
    e2.theharabic = 1579;
    e2.thehfinalarabic = 65178;
    e2.thehinitialarabic = 65179;
    e2.thehmedialarabic = 65180;
    e2.thereexists = 8707;
    e2.therefore = 8756;
    e2.theta = 952;
    e2.theta1 = 977;
    e2.thetasymbolgreek = 977;
    e2.thieuthacirclekorean = 12921;
    e2.thieuthaparenkorean = 12825;
    e2.thieuthcirclekorean = 12907;
    e2.thieuthkorean = 12620;
    e2.thieuthparenkorean = 12811;
    e2.thirteencircle = 9324;
    e2.thirteenparen = 9344;
    e2.thirteenperiod = 9364;
    e2.thonangmonthothai = 3601;
    e2.thook = 429;
    e2.thophuthaothai = 3602;
    e2.thorn = 254;
    e2.thothahanthai = 3607;
    e2.thothanthai = 3600;
    e2.thothongthai = 3608;
    e2.thothungthai = 3606;
    e2.thousandcyrillic = 1154;
    e2.thousandsseparatorarabic = 1644;
    e2.thousandsseparatorpersian = 1644;
    e2.three = 51;
    e2.threearabic = 1635;
    e2.threebengali = 2537;
    e2.threecircle = 9314;
    e2.threecircleinversesansserif = 10124;
    e2.threedeva = 2409;
    e2.threeeighths = 8540;
    e2.threegujarati = 2793;
    e2.threegurmukhi = 2665;
    e2.threehackarabic = 1635;
    e2.threehangzhou = 12323;
    e2.threeideographicparen = 12834;
    e2.threeinferior = 8323;
    e2.threemonospace = 65299;
    e2.threenumeratorbengali = 2550;
    e2.threeoldstyle = 63283;
    e2.threeparen = 9334;
    e2.threeperiod = 9354;
    e2.threepersian = 1779;
    e2.threequarters = 190;
    e2.threequartersemdash = 63198;
    e2.threeroman = 8562;
    e2.threesuperior = 179;
    e2.threethai = 3667;
    e2.thzsquare = 13204;
    e2.tihiragana = 12385;
    e2.tikatakana = 12481;
    e2.tikatakanahalfwidth = 65409;
    e2.tikeutacirclekorean = 12912;
    e2.tikeutaparenkorean = 12816;
    e2.tikeutcirclekorean = 12898;
    e2.tikeutkorean = 12599;
    e2.tikeutparenkorean = 12802;
    e2.tilde = 732;
    e2.tildebelowcmb = 816;
    e2.tildecmb = 771;
    e2.tildecomb = 771;
    e2.tildedoublecmb = 864;
    e2.tildeoperator = 8764;
    e2.tildeoverlaycmb = 820;
    e2.tildeverticalcmb = 830;
    e2.timescircle = 8855;
    e2.tipehahebrew = 1430;
    e2.tipehalefthebrew = 1430;
    e2.tippigurmukhi = 2672;
    e2.titlocyrilliccmb = 1155;
    e2.tiwnarmenian = 1407;
    e2.tlinebelow = 7791;
    e2.tmonospace = 65364;
    e2.toarmenian = 1385;
    e2.tohiragana = 12392;
    e2.tokatakana = 12488;
    e2.tokatakanahalfwidth = 65412;
    e2.tonebarextrahighmod = 741;
    e2.tonebarextralowmod = 745;
    e2.tonebarhighmod = 742;
    e2.tonebarlowmod = 744;
    e2.tonebarmidmod = 743;
    e2.tonefive = 445;
    e2.tonesix = 389;
    e2.tonetwo = 424;
    e2.tonos = 900;
    e2.tonsquare = 13095;
    e2.topatakthai = 3599;
    e2.tortoiseshellbracketleft = 12308;
    e2.tortoiseshellbracketleftsmall = 65117;
    e2.tortoiseshellbracketleftvertical = 65081;
    e2.tortoiseshellbracketright = 12309;
    e2.tortoiseshellbracketrightsmall = 65118;
    e2.tortoiseshellbracketrightvertical = 65082;
    e2.totaothai = 3605;
    e2.tpalatalhook = 427;
    e2.tparen = 9391;
    e2.trademark = 8482;
    e2.trademarksans = 63722;
    e2.trademarkserif = 63195;
    e2.tretroflexhook = 648;
    e2.triagdn = 9660;
    e2.triaglf = 9668;
    e2.triagrt = 9658;
    e2.triagup = 9650;
    e2.ts = 678;
    e2.tsadi = 1510;
    e2.tsadidagesh = 64326;
    e2.tsadidageshhebrew = 64326;
    e2.tsadihebrew = 1510;
    e2.tsecyrillic = 1094;
    e2.tsere = 1461;
    e2.tsere12 = 1461;
    e2.tsere1e = 1461;
    e2.tsere2b = 1461;
    e2.tserehebrew = 1461;
    e2.tserenarrowhebrew = 1461;
    e2.tserequarterhebrew = 1461;
    e2.tserewidehebrew = 1461;
    e2.tshecyrillic = 1115;
    e2.tsuperior = 63219;
    e2.ttabengali = 2463;
    e2.ttadeva = 2335;
    e2.ttagujarati = 2719;
    e2.ttagurmukhi = 2591;
    e2.tteharabic = 1657;
    e2.ttehfinalarabic = 64359;
    e2.ttehinitialarabic = 64360;
    e2.ttehmedialarabic = 64361;
    e2.tthabengali = 2464;
    e2.tthadeva = 2336;
    e2.tthagujarati = 2720;
    e2.tthagurmukhi = 2592;
    e2.tturned = 647;
    e2.tuhiragana = 12388;
    e2.tukatakana = 12484;
    e2.tukatakanahalfwidth = 65410;
    e2.tusmallhiragana = 12387;
    e2.tusmallkatakana = 12483;
    e2.tusmallkatakanahalfwidth = 65391;
    e2.twelvecircle = 9323;
    e2.twelveparen = 9343;
    e2.twelveperiod = 9363;
    e2.twelveroman = 8571;
    e2.twentycircle = 9331;
    e2.twentyhangzhou = 21316;
    e2.twentyparen = 9351;
    e2.twentyperiod = 9371;
    e2.two = 50;
    e2.twoarabic = 1634;
    e2.twobengali = 2536;
    e2.twocircle = 9313;
    e2.twocircleinversesansserif = 10123;
    e2.twodeva = 2408;
    e2.twodotenleader = 8229;
    e2.twodotleader = 8229;
    e2.twodotleadervertical = 65072;
    e2.twogujarati = 2792;
    e2.twogurmukhi = 2664;
    e2.twohackarabic = 1634;
    e2.twohangzhou = 12322;
    e2.twoideographicparen = 12833;
    e2.twoinferior = 8322;
    e2.twomonospace = 65298;
    e2.twonumeratorbengali = 2549;
    e2.twooldstyle = 63282;
    e2.twoparen = 9333;
    e2.twoperiod = 9353;
    e2.twopersian = 1778;
    e2.tworoman = 8561;
    e2.twostroke = 443;
    e2.twosuperior = 178;
    e2.twothai = 3666;
    e2.twothirds = 8532;
    e2.u = 117;
    e2.uacute = 250;
    e2.ubar = 649;
    e2.ubengali = 2441;
    e2.ubopomofo = 12584;
    e2.ubreve = 365;
    e2.ucaron = 468;
    e2.ucircle = 9444;
    e2.ucircumflex = 251;
    e2.ucircumflexbelow = 7799;
    e2.ucyrillic = 1091;
    e2.udattadeva = 2385;
    e2.udblacute = 369;
    e2.udblgrave = 533;
    e2.udeva = 2313;
    e2.udieresis = 252;
    e2.udieresisacute = 472;
    e2.udieresisbelow = 7795;
    e2.udieresiscaron = 474;
    e2.udieresiscyrillic = 1265;
    e2.udieresisgrave = 476;
    e2.udieresismacron = 470;
    e2.udotbelow = 7909;
    e2.ugrave = 249;
    e2.ugujarati = 2697;
    e2.ugurmukhi = 2569;
    e2.uhiragana = 12358;
    e2.uhookabove = 7911;
    e2.uhorn = 432;
    e2.uhornacute = 7913;
    e2.uhorndotbelow = 7921;
    e2.uhorngrave = 7915;
    e2.uhornhookabove = 7917;
    e2.uhorntilde = 7919;
    e2.uhungarumlaut = 369;
    e2.uhungarumlautcyrillic = 1267;
    e2.uinvertedbreve = 535;
    e2.ukatakana = 12454;
    e2.ukatakanahalfwidth = 65395;
    e2.ukcyrillic = 1145;
    e2.ukorean = 12636;
    e2.umacron = 363;
    e2.umacroncyrillic = 1263;
    e2.umacrondieresis = 7803;
    e2.umatragurmukhi = 2625;
    e2.umonospace = 65365;
    e2.underscore = 95;
    e2.underscoredbl = 8215;
    e2.underscoremonospace = 65343;
    e2.underscorevertical = 65075;
    e2.underscorewavy = 65103;
    e2.union = 8746;
    e2.universal = 8704;
    e2.uogonek = 371;
    e2.uparen = 9392;
    e2.upblock = 9600;
    e2.upperdothebrew = 1476;
    e2.upsilon = 965;
    e2.upsilondieresis = 971;
    e2.upsilondieresistonos = 944;
    e2.upsilonlatin = 650;
    e2.upsilontonos = 973;
    e2.uptackbelowcmb = 797;
    e2.uptackmod = 724;
    e2.uragurmukhi = 2675;
    e2.uring = 367;
    e2.ushortcyrillic = 1118;
    e2.usmallhiragana = 12357;
    e2.usmallkatakana = 12453;
    e2.usmallkatakanahalfwidth = 65385;
    e2.ustraightcyrillic = 1199;
    e2.ustraightstrokecyrillic = 1201;
    e2.utilde = 361;
    e2.utildeacute = 7801;
    e2.utildebelow = 7797;
    e2.uubengali = 2442;
    e2.uudeva = 2314;
    e2.uugujarati = 2698;
    e2.uugurmukhi = 2570;
    e2.uumatragurmukhi = 2626;
    e2.uuvowelsignbengali = 2498;
    e2.uuvowelsigndeva = 2370;
    e2.uuvowelsigngujarati = 2754;
    e2.uvowelsignbengali = 2497;
    e2.uvowelsigndeva = 2369;
    e2.uvowelsigngujarati = 2753;
    e2.v = 118;
    e2.vadeva = 2357;
    e2.vagujarati = 2741;
    e2.vagurmukhi = 2613;
    e2.vakatakana = 12535;
    e2.vav = 1493;
    e2.vavdagesh = 64309;
    e2.vavdagesh65 = 64309;
    e2.vavdageshhebrew = 64309;
    e2.vavhebrew = 1493;
    e2.vavholam = 64331;
    e2.vavholamhebrew = 64331;
    e2.vavvavhebrew = 1520;
    e2.vavyodhebrew = 1521;
    e2.vcircle = 9445;
    e2.vdotbelow = 7807;
    e2.vecyrillic = 1074;
    e2.veharabic = 1700;
    e2.vehfinalarabic = 64363;
    e2.vehinitialarabic = 64364;
    e2.vehmedialarabic = 64365;
    e2.vekatakana = 12537;
    e2.venus = 9792;
    e2.verticalbar = 124;
    e2.verticallineabovecmb = 781;
    e2.verticallinebelowcmb = 809;
    e2.verticallinelowmod = 716;
    e2.verticallinemod = 712;
    e2.vewarmenian = 1406;
    e2.vhook = 651;
    e2.vikatakana = 12536;
    e2.viramabengali = 2509;
    e2.viramadeva = 2381;
    e2.viramagujarati = 2765;
    e2.visargabengali = 2435;
    e2.visargadeva = 2307;
    e2.visargagujarati = 2691;
    e2.vmonospace = 65366;
    e2.voarmenian = 1400;
    e2.voicediterationhiragana = 12446;
    e2.voicediterationkatakana = 12542;
    e2.voicedmarkkana = 12443;
    e2.voicedmarkkanahalfwidth = 65438;
    e2.vokatakana = 12538;
    e2.vparen = 9393;
    e2.vtilde = 7805;
    e2.vturned = 652;
    e2.vuhiragana = 12436;
    e2.vukatakana = 12532;
    e2.w = 119;
    e2.wacute = 7811;
    e2.waekorean = 12633;
    e2.wahiragana = 12431;
    e2.wakatakana = 12527;
    e2.wakatakanahalfwidth = 65436;
    e2.wakorean = 12632;
    e2.wasmallhiragana = 12430;
    e2.wasmallkatakana = 12526;
    e2.wattosquare = 13143;
    e2.wavedash = 12316;
    e2.wavyunderscorevertical = 65076;
    e2.wawarabic = 1608;
    e2.wawfinalarabic = 65262;
    e2.wawhamzaabovearabic = 1572;
    e2.wawhamzaabovefinalarabic = 65158;
    e2.wbsquare = 13277;
    e2.wcircle = 9446;
    e2.wcircumflex = 373;
    e2.wdieresis = 7813;
    e2.wdotaccent = 7815;
    e2.wdotbelow = 7817;
    e2.wehiragana = 12433;
    e2.weierstrass = 8472;
    e2.wekatakana = 12529;
    e2.wekorean = 12638;
    e2.weokorean = 12637;
    e2.wgrave = 7809;
    e2.whitebullet = 9702;
    e2.whitecircle = 9675;
    e2.whitecircleinverse = 9689;
    e2.whitecornerbracketleft = 12302;
    e2.whitecornerbracketleftvertical = 65091;
    e2.whitecornerbracketright = 12303;
    e2.whitecornerbracketrightvertical = 65092;
    e2.whitediamond = 9671;
    e2.whitediamondcontainingblacksmalldiamond = 9672;
    e2.whitedownpointingsmalltriangle = 9663;
    e2.whitedownpointingtriangle = 9661;
    e2.whiteleftpointingsmalltriangle = 9667;
    e2.whiteleftpointingtriangle = 9665;
    e2.whitelenticularbracketleft = 12310;
    e2.whitelenticularbracketright = 12311;
    e2.whiterightpointingsmalltriangle = 9657;
    e2.whiterightpointingtriangle = 9655;
    e2.whitesmallsquare = 9643;
    e2.whitesmilingface = 9786;
    e2.whitesquare = 9633;
    e2.whitestar = 9734;
    e2.whitetelephone = 9743;
    e2.whitetortoiseshellbracketleft = 12312;
    e2.whitetortoiseshellbracketright = 12313;
    e2.whiteuppointingsmalltriangle = 9653;
    e2.whiteuppointingtriangle = 9651;
    e2.wihiragana = 12432;
    e2.wikatakana = 12528;
    e2.wikorean = 12639;
    e2.wmonospace = 65367;
    e2.wohiragana = 12434;
    e2.wokatakana = 12530;
    e2.wokatakanahalfwidth = 65382;
    e2.won = 8361;
    e2.wonmonospace = 65510;
    e2.wowaenthai = 3623;
    e2.wparen = 9394;
    e2.wring = 7832;
    e2.wsuperior = 695;
    e2.wturned = 653;
    e2.wynn = 447;
    e2.x = 120;
    e2.xabovecmb = 829;
    e2.xbopomofo = 12562;
    e2.xcircle = 9447;
    e2.xdieresis = 7821;
    e2.xdotaccent = 7819;
    e2.xeharmenian = 1389;
    e2.xi = 958;
    e2.xmonospace = 65368;
    e2.xparen = 9395;
    e2.xsuperior = 739;
    e2.y = 121;
    e2.yaadosquare = 13134;
    e2.yabengali = 2479;
    e2.yacute = 253;
    e2.yadeva = 2351;
    e2.yaekorean = 12626;
    e2.yagujarati = 2735;
    e2.yagurmukhi = 2607;
    e2.yahiragana = 12420;
    e2.yakatakana = 12516;
    e2.yakatakanahalfwidth = 65428;
    e2.yakorean = 12625;
    e2.yamakkanthai = 3662;
    e2.yasmallhiragana = 12419;
    e2.yasmallkatakana = 12515;
    e2.yasmallkatakanahalfwidth = 65388;
    e2.yatcyrillic = 1123;
    e2.ycircle = 9448;
    e2.ycircumflex = 375;
    e2.ydieresis = 255;
    e2.ydotaccent = 7823;
    e2.ydotbelow = 7925;
    e2.yeharabic = 1610;
    e2.yehbarreearabic = 1746;
    e2.yehbarreefinalarabic = 64431;
    e2.yehfinalarabic = 65266;
    e2.yehhamzaabovearabic = 1574;
    e2.yehhamzaabovefinalarabic = 65162;
    e2.yehhamzaaboveinitialarabic = 65163;
    e2.yehhamzaabovemedialarabic = 65164;
    e2.yehinitialarabic = 65267;
    e2.yehmedialarabic = 65268;
    e2.yehmeeminitialarabic = 64733;
    e2.yehmeemisolatedarabic = 64600;
    e2.yehnoonfinalarabic = 64660;
    e2.yehthreedotsbelowarabic = 1745;
    e2.yekorean = 12630;
    e2.yen = 165;
    e2.yenmonospace = 65509;
    e2.yeokorean = 12629;
    e2.yeorinhieuhkorean = 12678;
    e2.yerahbenyomohebrew = 1450;
    e2.yerahbenyomolefthebrew = 1450;
    e2.yericyrillic = 1099;
    e2.yerudieresiscyrillic = 1273;
    e2.yesieungkorean = 12673;
    e2.yesieungpansioskorean = 12675;
    e2.yesieungsioskorean = 12674;
    e2.yetivhebrew = 1434;
    e2.ygrave = 7923;
    e2.yhook = 436;
    e2.yhookabove = 7927;
    e2.yiarmenian = 1397;
    e2.yicyrillic = 1111;
    e2.yikorean = 12642;
    e2.yinyang = 9775;
    e2.yiwnarmenian = 1410;
    e2.ymonospace = 65369;
    e2.yod = 1497;
    e2.yoddagesh = 64313;
    e2.yoddageshhebrew = 64313;
    e2.yodhebrew = 1497;
    e2.yodyodhebrew = 1522;
    e2.yodyodpatahhebrew = 64287;
    e2.yohiragana = 12424;
    e2.yoikorean = 12681;
    e2.yokatakana = 12520;
    e2.yokatakanahalfwidth = 65430;
    e2.yokorean = 12635;
    e2.yosmallhiragana = 12423;
    e2.yosmallkatakana = 12519;
    e2.yosmallkatakanahalfwidth = 65390;
    e2.yotgreek = 1011;
    e2.yoyaekorean = 12680;
    e2.yoyakorean = 12679;
    e2.yoyakthai = 3618;
    e2.yoyingthai = 3597;
    e2.yparen = 9396;
    e2.ypogegrammeni = 890;
    e2.ypogegrammenigreekcmb = 837;
    e2.yr = 422;
    e2.yring = 7833;
    e2.ysuperior = 696;
    e2.ytilde = 7929;
    e2.yturned = 654;
    e2.yuhiragana = 12422;
    e2.yuikorean = 12684;
    e2.yukatakana = 12518;
    e2.yukatakanahalfwidth = 65429;
    e2.yukorean = 12640;
    e2.yusbigcyrillic = 1131;
    e2.yusbigiotifiedcyrillic = 1133;
    e2.yuslittlecyrillic = 1127;
    e2.yuslittleiotifiedcyrillic = 1129;
    e2.yusmallhiragana = 12421;
    e2.yusmallkatakana = 12517;
    e2.yusmallkatakanahalfwidth = 65389;
    e2.yuyekorean = 12683;
    e2.yuyeokorean = 12682;
    e2.yyabengali = 2527;
    e2.yyadeva = 2399;
    e2.z = 122;
    e2.zaarmenian = 1382;
    e2.zacute = 378;
    e2.zadeva = 2395;
    e2.zagurmukhi = 2651;
    e2.zaharabic = 1592;
    e2.zahfinalarabic = 65222;
    e2.zahinitialarabic = 65223;
    e2.zahiragana = 12374;
    e2.zahmedialarabic = 65224;
    e2.zainarabic = 1586;
    e2.zainfinalarabic = 65200;
    e2.zakatakana = 12470;
    e2.zaqefgadolhebrew = 1429;
    e2.zaqefqatanhebrew = 1428;
    e2.zarqahebrew = 1432;
    e2.zayin = 1494;
    e2.zayindagesh = 64310;
    e2.zayindageshhebrew = 64310;
    e2.zayinhebrew = 1494;
    e2.zbopomofo = 12567;
    e2.zcaron = 382;
    e2.zcircle = 9449;
    e2.zcircumflex = 7825;
    e2.zcurl = 657;
    e2.zdot = 380;
    e2.zdotaccent = 380;
    e2.zdotbelow = 7827;
    e2.zecyrillic = 1079;
    e2.zedescendercyrillic = 1177;
    e2.zedieresiscyrillic = 1247;
    e2.zehiragana = 12380;
    e2.zekatakana = 12476;
    e2.zero = 48;
    e2.zeroarabic = 1632;
    e2.zerobengali = 2534;
    e2.zerodeva = 2406;
    e2.zerogujarati = 2790;
    e2.zerogurmukhi = 2662;
    e2.zerohackarabic = 1632;
    e2.zeroinferior = 8320;
    e2.zeromonospace = 65296;
    e2.zerooldstyle = 63280;
    e2.zeropersian = 1776;
    e2.zerosuperior = 8304;
    e2.zerothai = 3664;
    e2.zerowidthjoiner = 65279;
    e2.zerowidthnonjoiner = 8204;
    e2.zerowidthspace = 8203;
    e2.zeta = 950;
    e2.zhbopomofo = 12563;
    e2.zhearmenian = 1386;
    e2.zhebrevecyrillic = 1218;
    e2.zhecyrillic = 1078;
    e2.zhedescendercyrillic = 1175;
    e2.zhedieresiscyrillic = 1245;
    e2.zihiragana = 12376;
    e2.zikatakana = 12472;
    e2.zinorhebrew = 1454;
    e2.zlinebelow = 7829;
    e2.zmonospace = 65370;
    e2.zohiragana = 12382;
    e2.zokatakana = 12478;
    e2.zparen = 9397;
    e2.zretroflexhook = 656;
    e2.zstroke = 438;
    e2.zuhiragana = 12378;
    e2.zukatakana = 12474;
    e2[".notdef"] = 0;
    e2.angbracketleftbig = 9001;
    e2.angbracketleftBig = 9001;
    e2.angbracketleftbigg = 9001;
    e2.angbracketleftBigg = 9001;
    e2.angbracketrightBig = 9002;
    e2.angbracketrightbig = 9002;
    e2.angbracketrightBigg = 9002;
    e2.angbracketrightbigg = 9002;
    e2.arrowhookleft = 8618;
    e2.arrowhookright = 8617;
    e2.arrowlefttophalf = 8636;
    e2.arrowleftbothalf = 8637;
    e2.arrownortheast = 8599;
    e2.arrownorthwest = 8598;
    e2.arrowrighttophalf = 8640;
    e2.arrowrightbothalf = 8641;
    e2.arrowsoutheast = 8600;
    e2.arrowsouthwest = 8601;
    e2.backslashbig = 8726;
    e2.backslashBig = 8726;
    e2.backslashBigg = 8726;
    e2.backslashbigg = 8726;
    e2.bardbl = 8214;
    e2.bracehtipdownleft = 65079;
    e2.bracehtipdownright = 65079;
    e2.bracehtipupleft = 65080;
    e2.bracehtipupright = 65080;
    e2.braceleftBig = 123;
    e2.braceleftbig = 123;
    e2.braceleftbigg = 123;
    e2.braceleftBigg = 123;
    e2.bracerightBig = 125;
    e2.bracerightbig = 125;
    e2.bracerightbigg = 125;
    e2.bracerightBigg = 125;
    e2.bracketleftbig = 91;
    e2.bracketleftBig = 91;
    e2.bracketleftbigg = 91;
    e2.bracketleftBigg = 91;
    e2.bracketrightBig = 93;
    e2.bracketrightbig = 93;
    e2.bracketrightbigg = 93;
    e2.bracketrightBigg = 93;
    e2.ceilingleftbig = 8968;
    e2.ceilingleftBig = 8968;
    e2.ceilingleftBigg = 8968;
    e2.ceilingleftbigg = 8968;
    e2.ceilingrightbig = 8969;
    e2.ceilingrightBig = 8969;
    e2.ceilingrightbigg = 8969;
    e2.ceilingrightBigg = 8969;
    e2.circledotdisplay = 8857;
    e2.circledottext = 8857;
    e2.circlemultiplydisplay = 8855;
    e2.circlemultiplytext = 8855;
    e2.circleplusdisplay = 8853;
    e2.circleplustext = 8853;
    e2.contintegraldisplay = 8750;
    e2.contintegraltext = 8750;
    e2.coproductdisplay = 8720;
    e2.coproducttext = 8720;
    e2.floorleftBig = 8970;
    e2.floorleftbig = 8970;
    e2.floorleftbigg = 8970;
    e2.floorleftBigg = 8970;
    e2.floorrightbig = 8971;
    e2.floorrightBig = 8971;
    e2.floorrightBigg = 8971;
    e2.floorrightbigg = 8971;
    e2.hatwide = 770;
    e2.hatwider = 770;
    e2.hatwidest = 770;
    e2.intercal = 7488;
    e2.integraldisplay = 8747;
    e2.integraltext = 8747;
    e2.intersectiondisplay = 8898;
    e2.intersectiontext = 8898;
    e2.logicalanddisplay = 8743;
    e2.logicalandtext = 8743;
    e2.logicalordisplay = 8744;
    e2.logicalortext = 8744;
    e2.parenleftBig = 40;
    e2.parenleftbig = 40;
    e2.parenleftBigg = 40;
    e2.parenleftbigg = 40;
    e2.parenrightBig = 41;
    e2.parenrightbig = 41;
    e2.parenrightBigg = 41;
    e2.parenrightbigg = 41;
    e2.prime = 8242;
    e2.productdisplay = 8719;
    e2.producttext = 8719;
    e2.radicalbig = 8730;
    e2.radicalBig = 8730;
    e2.radicalBigg = 8730;
    e2.radicalbigg = 8730;
    e2.radicalbt = 8730;
    e2.radicaltp = 8730;
    e2.radicalvertex = 8730;
    e2.slashbig = 47;
    e2.slashBig = 47;
    e2.slashBigg = 47;
    e2.slashbigg = 47;
    e2.summationdisplay = 8721;
    e2.summationtext = 8721;
    e2.tildewide = 732;
    e2.tildewider = 732;
    e2.tildewidest = 732;
    e2.uniondisplay = 8899;
    e2.unionmultidisplay = 8846;
    e2.unionmultitext = 8846;
    e2.unionsqdisplay = 8852;
    e2.unionsqtext = 8852;
    e2.uniontext = 8899;
    e2.vextenddouble = 8741;
    e2.vextendsingle = 8739;
  }), Ji = getLookupTableFactory(function(e2) {
    e2.space = 32;
    e2.a1 = 9985;
    e2.a2 = 9986;
    e2.a202 = 9987;
    e2.a3 = 9988;
    e2.a4 = 9742;
    e2.a5 = 9990;
    e2.a119 = 9991;
    e2.a118 = 9992;
    e2.a117 = 9993;
    e2.a11 = 9755;
    e2.a12 = 9758;
    e2.a13 = 9996;
    e2.a14 = 9997;
    e2.a15 = 9998;
    e2.a16 = 9999;
    e2.a105 = 1e4;
    e2.a17 = 10001;
    e2.a18 = 10002;
    e2.a19 = 10003;
    e2.a20 = 10004;
    e2.a21 = 10005;
    e2.a22 = 10006;
    e2.a23 = 10007;
    e2.a24 = 10008;
    e2.a25 = 10009;
    e2.a26 = 10010;
    e2.a27 = 10011;
    e2.a28 = 10012;
    e2.a6 = 10013;
    e2.a7 = 10014;
    e2.a8 = 10015;
    e2.a9 = 10016;
    e2.a10 = 10017;
    e2.a29 = 10018;
    e2.a30 = 10019;
    e2.a31 = 10020;
    e2.a32 = 10021;
    e2.a33 = 10022;
    e2.a34 = 10023;
    e2.a35 = 9733;
    e2.a36 = 10025;
    e2.a37 = 10026;
    e2.a38 = 10027;
    e2.a39 = 10028;
    e2.a40 = 10029;
    e2.a41 = 10030;
    e2.a42 = 10031;
    e2.a43 = 10032;
    e2.a44 = 10033;
    e2.a45 = 10034;
    e2.a46 = 10035;
    e2.a47 = 10036;
    e2.a48 = 10037;
    e2.a49 = 10038;
    e2.a50 = 10039;
    e2.a51 = 10040;
    e2.a52 = 10041;
    e2.a53 = 10042;
    e2.a54 = 10043;
    e2.a55 = 10044;
    e2.a56 = 10045;
    e2.a57 = 10046;
    e2.a58 = 10047;
    e2.a59 = 10048;
    e2.a60 = 10049;
    e2.a61 = 10050;
    e2.a62 = 10051;
    e2.a63 = 10052;
    e2.a64 = 10053;
    e2.a65 = 10054;
    e2.a66 = 10055;
    e2.a67 = 10056;
    e2.a68 = 10057;
    e2.a69 = 10058;
    e2.a70 = 10059;
    e2.a71 = 9679;
    e2.a72 = 10061;
    e2.a73 = 9632;
    e2.a74 = 10063;
    e2.a203 = 10064;
    e2.a75 = 10065;
    e2.a204 = 10066;
    e2.a76 = 9650;
    e2.a77 = 9660;
    e2.a78 = 9670;
    e2.a79 = 10070;
    e2.a81 = 9687;
    e2.a82 = 10072;
    e2.a83 = 10073;
    e2.a84 = 10074;
    e2.a97 = 10075;
    e2.a98 = 10076;
    e2.a99 = 10077;
    e2.a100 = 10078;
    e2.a101 = 10081;
    e2.a102 = 10082;
    e2.a103 = 10083;
    e2.a104 = 10084;
    e2.a106 = 10085;
    e2.a107 = 10086;
    e2.a108 = 10087;
    e2.a112 = 9827;
    e2.a111 = 9830;
    e2.a110 = 9829;
    e2.a109 = 9824;
    e2.a120 = 9312;
    e2.a121 = 9313;
    e2.a122 = 9314;
    e2.a123 = 9315;
    e2.a124 = 9316;
    e2.a125 = 9317;
    e2.a126 = 9318;
    e2.a127 = 9319;
    e2.a128 = 9320;
    e2.a129 = 9321;
    e2.a130 = 10102;
    e2.a131 = 10103;
    e2.a132 = 10104;
    e2.a133 = 10105;
    e2.a134 = 10106;
    e2.a135 = 10107;
    e2.a136 = 10108;
    e2.a137 = 10109;
    e2.a138 = 10110;
    e2.a139 = 10111;
    e2.a140 = 10112;
    e2.a141 = 10113;
    e2.a142 = 10114;
    e2.a143 = 10115;
    e2.a144 = 10116;
    e2.a145 = 10117;
    e2.a146 = 10118;
    e2.a147 = 10119;
    e2.a148 = 10120;
    e2.a149 = 10121;
    e2.a150 = 10122;
    e2.a151 = 10123;
    e2.a152 = 10124;
    e2.a153 = 10125;
    e2.a154 = 10126;
    e2.a155 = 10127;
    e2.a156 = 10128;
    e2.a157 = 10129;
    e2.a158 = 10130;
    e2.a159 = 10131;
    e2.a160 = 10132;
    e2.a161 = 8594;
    e2.a163 = 8596;
    e2.a164 = 8597;
    e2.a196 = 10136;
    e2.a165 = 10137;
    e2.a192 = 10138;
    e2.a166 = 10139;
    e2.a167 = 10140;
    e2.a168 = 10141;
    e2.a169 = 10142;
    e2.a170 = 10143;
    e2.a171 = 10144;
    e2.a172 = 10145;
    e2.a173 = 10146;
    e2.a162 = 10147;
    e2.a174 = 10148;
    e2.a175 = 10149;
    e2.a176 = 10150;
    e2.a177 = 10151;
    e2.a178 = 10152;
    e2.a179 = 10153;
    e2.a193 = 10154;
    e2.a180 = 10155;
    e2.a199 = 10156;
    e2.a181 = 10157;
    e2.a200 = 10158;
    e2.a182 = 10159;
    e2.a201 = 10161;
    e2.a183 = 10162;
    e2.a184 = 10163;
    e2.a197 = 10164;
    e2.a185 = 10165;
    e2.a194 = 10166;
    e2.a198 = 10167;
    e2.a186 = 10168;
    e2.a195 = 10169;
    e2.a187 = 10170;
    e2.a188 = 10171;
    e2.a189 = 10172;
    e2.a190 = 10173;
    e2.a191 = 10174;
    e2.a89 = 10088;
    e2.a90 = 10089;
    e2.a93 = 10090;
    e2.a94 = 10091;
    e2.a91 = 10092;
    e2.a92 = 10093;
    e2.a205 = 10094;
    e2.a85 = 10095;
    e2.a206 = 10096;
    e2.a86 = 10097;
    e2.a87 = 10098;
    e2.a88 = 10099;
    e2.a95 = 10100;
    e2.a96 = 10101;
    e2[".notdef"] = 0;
  }), vi = getLookupTableFactory(function(e2) {
    e2[63721] = 169;
    e2[63193] = 169;
    e2[63720] = 174;
    e2[63194] = 174;
    e2[63722] = 8482;
    e2[63195] = 8482;
    e2[63729] = 9127;
    e2[63730] = 9128;
    e2[63731] = 9129;
    e2[63740] = 9131;
    e2[63741] = 9132;
    e2[63742] = 9133;
    e2[63726] = 9121;
    e2[63727] = 9122;
    e2[63728] = 9123;
    e2[63737] = 9124;
    e2[63738] = 9125;
    e2[63739] = 9126;
    e2[63723] = 9115;
    e2[63724] = 9116;
    e2[63725] = 9117;
    e2[63734] = 9118;
    e2[63735] = 9119;
    e2[63736] = 9120;
  });
  function getUnicodeForGlyph(e2, t2) {
    let i2 = t2[e2];
    if (void 0 !== i2) return i2;
    if (!e2) return -1;
    if ("u" === e2[0]) {
      const t3 = e2.length;
      let a2;
      if (7 === t3 && "n" === e2[1] && "i" === e2[2]) a2 = e2.substring(3);
      else {
        if (!(t3 >= 5 && t3 <= 7)) return -1;
        a2 = e2.substring(1);
      }
      if (a2 === a2.toUpperCase()) {
        i2 = parseInt(a2, 16);
        if (i2 >= 0) return i2;
      }
    }
    return -1;
  }
  const Yi = [
    [
      0,
      127
    ],
    [
      128,
      255
    ],
    [
      256,
      383
    ],
    [
      384,
      591
    ],
    [
      592,
      687,
      7424,
      7551,
      7552,
      7615
    ],
    [
      688,
      767,
      42752,
      42783
    ],
    [
      768,
      879,
      7616,
      7679
    ],
    [
      880,
      1023
    ],
    [
      11392,
      11519
    ],
    [
      1024,
      1279,
      1280,
      1327,
      11744,
      11775,
      42560,
      42655
    ],
    [
      1328,
      1423
    ],
    [
      1424,
      1535
    ],
    [
      42240,
      42559
    ],
    [
      1536,
      1791,
      1872,
      1919
    ],
    [
      1984,
      2047
    ],
    [
      2304,
      2431
    ],
    [
      2432,
      2559
    ],
    [
      2560,
      2687
    ],
    [
      2688,
      2815
    ],
    [
      2816,
      2943
    ],
    [
      2944,
      3071
    ],
    [
      3072,
      3199
    ],
    [
      3200,
      3327
    ],
    [
      3328,
      3455
    ],
    [
      3584,
      3711
    ],
    [
      3712,
      3839
    ],
    [
      4256,
      4351,
      11520,
      11567
    ],
    [
      6912,
      7039
    ],
    [
      4352,
      4607
    ],
    [
      7680,
      7935,
      11360,
      11391,
      42784,
      43007
    ],
    [
      7936,
      8191
    ],
    [
      8192,
      8303,
      11776,
      11903
    ],
    [
      8304,
      8351
    ],
    [
      8352,
      8399
    ],
    [
      8400,
      8447
    ],
    [
      8448,
      8527
    ],
    [
      8528,
      8591
    ],
    [
      8592,
      8703,
      10224,
      10239,
      10496,
      10623,
      11008,
      11263
    ],
    [
      8704,
      8959,
      10752,
      11007,
      10176,
      10223,
      10624,
      10751
    ],
    [
      8960,
      9215
    ],
    [
      9216,
      9279
    ],
    [
      9280,
      9311
    ],
    [
      9312,
      9471
    ],
    [
      9472,
      9599
    ],
    [
      9600,
      9631
    ],
    [
      9632,
      9727
    ],
    [
      9728,
      9983
    ],
    [
      9984,
      10175
    ],
    [
      12288,
      12351
    ],
    [
      12352,
      12447
    ],
    [
      12448,
      12543,
      12784,
      12799
    ],
    [
      12544,
      12591,
      12704,
      12735
    ],
    [
      12592,
      12687
    ],
    [
      43072,
      43135
    ],
    [
      12800,
      13055
    ],
    [
      13056,
      13311
    ],
    [
      44032,
      55215
    ],
    [
      55296,
      57343
    ],
    [
      67840,
      67871
    ],
    [
      19968,
      40959,
      11904,
      12031,
      12032,
      12255,
      12272,
      12287,
      13312,
      19903,
      131072,
      173791,
      12688,
      12703
    ],
    [
      57344,
      63743
    ],
    [
      12736,
      12783,
      63744,
      64255,
      194560,
      195103
    ],
    [
      64256,
      64335
    ],
    [
      64336,
      65023
    ],
    [
      65056,
      65071
    ],
    [
      65040,
      65055
    ],
    [
      65104,
      65135
    ],
    [
      65136,
      65279
    ],
    [
      65280,
      65519
    ],
    [
      65520,
      65535
    ],
    [
      3840,
      4095
    ],
    [
      1792,
      1871
    ],
    [
      1920,
      1983
    ],
    [
      3456,
      3583
    ],
    [
      4096,
      4255
    ],
    [
      4608,
      4991,
      4992,
      5023,
      11648,
      11743
    ],
    [
      5024,
      5119
    ],
    [
      5120,
      5759
    ],
    [
      5760,
      5791
    ],
    [
      5792,
      5887
    ],
    [
      6016,
      6143
    ],
    [
      6144,
      6319
    ],
    [
      10240,
      10495
    ],
    [
      40960,
      42127
    ],
    [
      5888,
      5919,
      5920,
      5951,
      5952,
      5983,
      5984,
      6015
    ],
    [
      66304,
      66351
    ],
    [
      66352,
      66383
    ],
    [
      66560,
      66639
    ],
    [
      118784,
      119039,
      119040,
      119295,
      119296,
      119375
    ],
    [
      119808,
      120831
    ],
    [
      1044480,
      1048573
    ],
    [
      65024,
      65039,
      917760,
      917999
    ],
    [
      917504,
      917631
    ],
    [
      6400,
      6479
    ],
    [
      6480,
      6527
    ],
    [
      6528,
      6623
    ],
    [
      6656,
      6687
    ],
    [
      11264,
      11359
    ],
    [
      11568,
      11647
    ],
    [
      19904,
      19967
    ],
    [
      43008,
      43055
    ],
    [
      65536,
      65663,
      65664,
      65791,
      65792,
      65855
    ],
    [
      65856,
      65935
    ],
    [
      66432,
      66463
    ],
    [
      66464,
      66527
    ],
    [
      66640,
      66687
    ],
    [
      66688,
      66735
    ],
    [
      67584,
      67647
    ],
    [
      68096,
      68191
    ],
    [
      119552,
      119647
    ],
    [
      73728,
      74751,
      74752,
      74879
    ],
    [
      119648,
      119679
    ],
    [
      7040,
      7103
    ],
    [
      7168,
      7247
    ],
    [
      7248,
      7295
    ],
    [
      43136,
      43231
    ],
    [
      43264,
      43311
    ],
    [
      43312,
      43359
    ],
    [
      43520,
      43615
    ],
    [
      65936,
      65999
    ],
    [
      66e3,
      66047
    ],
    [
      66208,
      66271,
      66176,
      66207,
      67872,
      67903
    ],
    [
      127024,
      127135,
      126976,
      127023
    ]
  ];
  function getUnicodeRangeFor(e2, t2 = -1) {
    if (-1 !== t2) {
      const i2 = Yi[t2];
      for (let a2 = 0, r2 = i2.length; a2 < r2; a2 += 2) if (e2 >= i2[a2] && e2 <= i2[a2 + 1]) return t2;
    }
    for (let t3 = 0, i2 = Yi.length; t3 < i2; t3++) {
      const i3 = Yi[t3];
      for (let a2 = 0, r2 = i3.length; a2 < r2; a2 += 2) if (e2 >= i3[a2] && e2 <= i3[a2 + 1]) return t3;
    }
    return -1;
  }
  const Ti = new RegExp("^(\\s)|(\\p{Mn})|(\\p{Cf})$", "u"), Ki = /* @__PURE__ */ new Map();
  const qi = true, Oi = 1, Pi = 2, Wi = 4, ji = 32, Xi = [
    ".notdef",
    ".null",
    "nonmarkingreturn",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "nonbreakingspace",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "Lslash",
    "lslash",
    "Scaron",
    "scaron",
    "Zcaron",
    "zcaron",
    "brokenbar",
    "Eth",
    "eth",
    "Yacute",
    "yacute",
    "Thorn",
    "thorn",
    "minus",
    "multiply",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "onehalf",
    "onequarter",
    "threequarters",
    "franc",
    "Gbreve",
    "gbreve",
    "Idotaccent",
    "Scedilla",
    "scedilla",
    "Cacute",
    "cacute",
    "Ccaron",
    "ccaron",
    "dcroat"
  ];
  function recoverGlyphName(e2, t2) {
    if (void 0 !== t2[e2]) return e2;
    const i2 = getUnicodeForGlyph(e2, t2);
    if (-1 !== i2) {
      for (const e3 in t2) if (t2[e3] === i2) return e3;
    }
    info("Unable to recover a standard glyph name for: " + e2);
    return e2;
  }
  function type1FontGlyphMapping(e2, t2, i2) {
    const a2 = /* @__PURE__ */ Object.create(null);
    let r2, s2, n2;
    const o2 = !!(e2.flags & Wi);
    if (e2.isInternalFont) {
      n2 = t2;
      for (s2 = 0; s2 < n2.length; s2++) {
        r2 = i2.indexOf(n2[s2]);
        a2[s2] = r2 >= 0 ? r2 : 0;
      }
    } else if (e2.baseEncodingName) {
      n2 = getEncoding(e2.baseEncodingName);
      for (s2 = 0; s2 < n2.length; s2++) {
        r2 = i2.indexOf(n2[s2]);
        a2[s2] = r2 >= 0 ? r2 : 0;
      }
    } else if (o2) for (s2 in t2) a2[s2] = t2[s2];
    else {
      n2 = wi;
      for (s2 = 0; s2 < n2.length; s2++) {
        r2 = i2.indexOf(n2[s2]);
        a2[s2] = r2 >= 0 ? r2 : 0;
      }
    }
    const g2 = e2.differences;
    let c2;
    if (g2) for (s2 in g2) {
      const e3 = g2[s2];
      r2 = i2.indexOf(e3);
      if (-1 === r2) {
        c2 || (c2 = Hi());
        const t3 = recoverGlyphName(e3, c2);
        t3 !== e3 && (r2 = i2.indexOf(t3));
      }
      a2[s2] = r2 >= 0 ? r2 : 0;
    }
    return a2;
  }
  function normalizeFontName(e2) {
    return e2.replaceAll(/[,_]/g, "-").replaceAll(/\s/g, "");
  }
  const Zi = getLookupTableFactory((e2) => {
    e2[8211] = 65074;
    e2[8212] = 65073;
    e2[8229] = 65072;
    e2[8230] = 65049;
    e2[12289] = 65041;
    e2[12290] = 65042;
    e2[12296] = 65087;
    e2[12297] = 65088;
    e2[12298] = 65085;
    e2[12299] = 65086;
    e2[12300] = 65089;
    e2[12301] = 65090;
    e2[12302] = 65091;
    e2[12303] = 65092;
    e2[12304] = 65083;
    e2[12305] = 65084;
    e2[12308] = 65081;
    e2[12309] = 65082;
    e2[12310] = 65047;
    e2[12311] = 65048;
    e2[65103] = 65076;
    e2[65281] = 65045;
    e2[65288] = 65077;
    e2[65289] = 65078;
    e2[65292] = 65040;
    e2[65306] = 65043;
    e2[65307] = 65044;
    e2[65311] = 65046;
    e2[65339] = 65095;
    e2[65341] = 65096;
    e2[65343] = 65075;
    e2[65371] = 65079;
    e2[65373] = 65080;
  }), Vi = getLookupTableFactory(function(e2) {
    e2["Times-Roman"] = "Times-Roman";
    e2.Helvetica = "Helvetica";
    e2.Courier = "Courier";
    e2.Symbol = "Symbol";
    e2["Times-Bold"] = "Times-Bold";
    e2["Helvetica-Bold"] = "Helvetica-Bold";
    e2["Courier-Bold"] = "Courier-Bold";
    e2.ZapfDingbats = "ZapfDingbats";
    e2["Times-Italic"] = "Times-Italic";
    e2["Helvetica-Oblique"] = "Helvetica-Oblique";
    e2["Courier-Oblique"] = "Courier-Oblique";
    e2["Times-BoldItalic"] = "Times-BoldItalic";
    e2["Helvetica-BoldOblique"] = "Helvetica-BoldOblique";
    e2["Courier-BoldOblique"] = "Courier-BoldOblique";
    e2.ArialNarrow = "Helvetica";
    e2["ArialNarrow-Bold"] = "Helvetica-Bold";
    e2["ArialNarrow-BoldItalic"] = "Helvetica-BoldOblique";
    e2["ArialNarrow-Italic"] = "Helvetica-Oblique";
    e2.ArialBlack = "Helvetica";
    e2["ArialBlack-Bold"] = "Helvetica-Bold";
    e2["ArialBlack-BoldItalic"] = "Helvetica-BoldOblique";
    e2["ArialBlack-Italic"] = "Helvetica-Oblique";
    e2["Arial-Black"] = "Helvetica";
    e2["Arial-Black-Bold"] = "Helvetica-Bold";
    e2["Arial-Black-BoldItalic"] = "Helvetica-BoldOblique";
    e2["Arial-Black-Italic"] = "Helvetica-Oblique";
    e2.Arial = "Helvetica";
    e2["Arial-Bold"] = "Helvetica-Bold";
    e2["Arial-BoldItalic"] = "Helvetica-BoldOblique";
    e2["Arial-Italic"] = "Helvetica-Oblique";
    e2.ArialMT = "Helvetica";
    e2["Arial-BoldItalicMT"] = "Helvetica-BoldOblique";
    e2["Arial-BoldMT"] = "Helvetica-Bold";
    e2["Arial-ItalicMT"] = "Helvetica-Oblique";
    e2["Arial-BoldItalicMT-BoldItalic"] = "Helvetica-BoldOblique";
    e2["Arial-BoldMT-Bold"] = "Helvetica-Bold";
    e2["Arial-ItalicMT-Italic"] = "Helvetica-Oblique";
    e2.ArialUnicodeMS = "Helvetica";
    e2["ArialUnicodeMS-Bold"] = "Helvetica-Bold";
    e2["ArialUnicodeMS-BoldItalic"] = "Helvetica-BoldOblique";
    e2["ArialUnicodeMS-Italic"] = "Helvetica-Oblique";
    e2["Courier-BoldItalic"] = "Courier-BoldOblique";
    e2["Courier-Italic"] = "Courier-Oblique";
    e2.CourierNew = "Courier";
    e2["CourierNew-Bold"] = "Courier-Bold";
    e2["CourierNew-BoldItalic"] = "Courier-BoldOblique";
    e2["CourierNew-Italic"] = "Courier-Oblique";
    e2["CourierNewPS-BoldItalicMT"] = "Courier-BoldOblique";
    e2["CourierNewPS-BoldMT"] = "Courier-Bold";
    e2["CourierNewPS-ItalicMT"] = "Courier-Oblique";
    e2.CourierNewPSMT = "Courier";
    e2["Helvetica-BoldItalic"] = "Helvetica-BoldOblique";
    e2["Helvetica-Italic"] = "Helvetica-Oblique";
    e2["Symbol-Bold"] = "Symbol";
    e2["Symbol-BoldItalic"] = "Symbol";
    e2["Symbol-Italic"] = "Symbol";
    e2.TimesNewRoman = "Times-Roman";
    e2["TimesNewRoman-Bold"] = "Times-Bold";
    e2["TimesNewRoman-BoldItalic"] = "Times-BoldItalic";
    e2["TimesNewRoman-Italic"] = "Times-Italic";
    e2.TimesNewRomanPS = "Times-Roman";
    e2["TimesNewRomanPS-Bold"] = "Times-Bold";
    e2["TimesNewRomanPS-BoldItalic"] = "Times-BoldItalic";
    e2["TimesNewRomanPS-BoldItalicMT"] = "Times-BoldItalic";
    e2["TimesNewRomanPS-BoldMT"] = "Times-Bold";
    e2["TimesNewRomanPS-Italic"] = "Times-Italic";
    e2["TimesNewRomanPS-ItalicMT"] = "Times-Italic";
    e2.TimesNewRomanPSMT = "Times-Roman";
    e2["TimesNewRomanPSMT-Bold"] = "Times-Bold";
    e2["TimesNewRomanPSMT-BoldItalic"] = "Times-BoldItalic";
    e2["TimesNewRomanPSMT-Italic"] = "Times-Italic";
  }), _i = getLookupTableFactory(function(e2) {
    e2.Courier = "FoxitFixed.pfb";
    e2["Courier-Bold"] = "FoxitFixedBold.pfb";
    e2["Courier-BoldOblique"] = "FoxitFixedBoldItalic.pfb";
    e2["Courier-Oblique"] = "FoxitFixedItalic.pfb";
    e2.Helvetica = "LiberationSans-Regular.ttf";
    e2["Helvetica-Bold"] = "LiberationSans-Bold.ttf";
    e2["Helvetica-BoldOblique"] = "LiberationSans-BoldItalic.ttf";
    e2["Helvetica-Oblique"] = "LiberationSans-Italic.ttf";
    e2["Times-Roman"] = "FoxitSerif.pfb";
    e2["Times-Bold"] = "FoxitSerifBold.pfb";
    e2["Times-BoldItalic"] = "FoxitSerifBoldItalic.pfb";
    e2["Times-Italic"] = "FoxitSerifItalic.pfb";
    e2.Symbol = "FoxitSymbol.pfb";
    e2.ZapfDingbats = "FoxitDingbats.pfb";
    e2["LiberationSans-Regular"] = "LiberationSans-Regular.ttf";
    e2["LiberationSans-Bold"] = "LiberationSans-Bold.ttf";
    e2["LiberationSans-Italic"] = "LiberationSans-Italic.ttf";
    e2["LiberationSans-BoldItalic"] = "LiberationSans-BoldItalic.ttf";
  }), zi = getLookupTableFactory(function(e2) {
    e2.Calibri = "Helvetica";
    e2["Calibri-Bold"] = "Helvetica-Bold";
    e2["Calibri-BoldItalic"] = "Helvetica-BoldOblique";
    e2["Calibri-Italic"] = "Helvetica-Oblique";
    e2.CenturyGothic = "Helvetica";
    e2["CenturyGothic-Bold"] = "Helvetica-Bold";
    e2["CenturyGothic-BoldItalic"] = "Helvetica-BoldOblique";
    e2["CenturyGothic-Italic"] = "Helvetica-Oblique";
    e2.ComicSansMS = "Comic Sans MS";
    e2["ComicSansMS-Bold"] = "Comic Sans MS-Bold";
    e2["ComicSansMS-BoldItalic"] = "Comic Sans MS-BoldItalic";
    e2["ComicSansMS-Italic"] = "Comic Sans MS-Italic";
    e2.GillSansMT = "Helvetica";
    e2["GillSansMT-Bold"] = "Helvetica-Bold";
    e2["GillSansMT-BoldItalic"] = "Helvetica-BoldOblique";
    e2["GillSansMT-Italic"] = "Helvetica-Oblique";
    e2.Impact = "Helvetica";
    e2["ItcSymbol-Bold"] = "Helvetica-Bold";
    e2["ItcSymbol-BoldItalic"] = "Helvetica-BoldOblique";
    e2["ItcSymbol-Book"] = "Helvetica";
    e2["ItcSymbol-BookItalic"] = "Helvetica-Oblique";
    e2["ItcSymbol-Medium"] = "Helvetica";
    e2["ItcSymbol-MediumItalic"] = "Helvetica-Oblique";
    e2.LucidaConsole = "Courier";
    e2["LucidaConsole-Bold"] = "Courier-Bold";
    e2["LucidaConsole-BoldItalic"] = "Courier-BoldOblique";
    e2["LucidaConsole-Italic"] = "Courier-Oblique";
    e2["LucidaSans-Demi"] = "Helvetica-Bold";
    e2["MS-Gothic"] = "MS Gothic";
    e2["MS-Gothic-Bold"] = "MS Gothic-Bold";
    e2["MS-Gothic-BoldItalic"] = "MS Gothic-BoldItalic";
    e2["MS-Gothic-Italic"] = "MS Gothic-Italic";
    e2["MS-Mincho"] = "MS Mincho";
    e2["MS-Mincho-Bold"] = "MS Mincho-Bold";
    e2["MS-Mincho-BoldItalic"] = "MS Mincho-BoldItalic";
    e2["MS-Mincho-Italic"] = "MS Mincho-Italic";
    e2["MS-PGothic"] = "MS PGothic";
    e2["MS-PGothic-Bold"] = "MS PGothic-Bold";
    e2["MS-PGothic-BoldItalic"] = "MS PGothic-BoldItalic";
    e2["MS-PGothic-Italic"] = "MS PGothic-Italic";
    e2["MS-PMincho"] = "MS PMincho";
    e2["MS-PMincho-Bold"] = "MS PMincho-Bold";
    e2["MS-PMincho-BoldItalic"] = "MS PMincho-BoldItalic";
    e2["MS-PMincho-Italic"] = "MS PMincho-Italic";
    e2.NuptialScript = "Times-Italic";
    e2.SegoeUISymbol = "Helvetica";
  }), $i = getLookupTableFactory(function(e2) {
    e2["Adobe Jenson"] = true;
    e2["Adobe Text"] = true;
    e2.Albertus = true;
    e2.Aldus = true;
    e2.Alexandria = true;
    e2.Algerian = true;
    e2["American Typewriter"] = true;
    e2.Antiqua = true;
    e2.Apex = true;
    e2.Arno = true;
    e2.Aster = true;
    e2.Aurora = true;
    e2.Baskerville = true;
    e2.Bell = true;
    e2.Bembo = true;
    e2["Bembo Schoolbook"] = true;
    e2.Benguiat = true;
    e2["Berkeley Old Style"] = true;
    e2["Bernhard Modern"] = true;
    e2["Berthold City"] = true;
    e2.Bodoni = true;
    e2["Bauer Bodoni"] = true;
    e2["Book Antiqua"] = true;
    e2.Bookman = true;
    e2["Bordeaux Roman"] = true;
    e2["Californian FB"] = true;
    e2.Calisto = true;
    e2.Calvert = true;
    e2.Capitals = true;
    e2.Cambria = true;
    e2.Cartier = true;
    e2.Caslon = true;
    e2.Catull = true;
    e2.Centaur = true;
    e2["Century Old Style"] = true;
    e2["Century Schoolbook"] = true;
    e2.Chaparral = true;
    e2["Charis SIL"] = true;
    e2.Cheltenham = true;
    e2["Cholla Slab"] = true;
    e2.Clarendon = true;
    e2.Clearface = true;
    e2.Cochin = true;
    e2.Colonna = true;
    e2["Computer Modern"] = true;
    e2["Concrete Roman"] = true;
    e2.Constantia = true;
    e2["Cooper Black"] = true;
    e2.Corona = true;
    e2.Ecotype = true;
    e2.Egyptienne = true;
    e2.Elephant = true;
    e2.Excelsior = true;
    e2.Fairfield = true;
    e2["FF Scala"] = true;
    e2.Folkard = true;
    e2.Footlight = true;
    e2.FreeSerif = true;
    e2["Friz Quadrata"] = true;
    e2.Garamond = true;
    e2.Gentium = true;
    e2.Georgia = true;
    e2.Gloucester = true;
    e2["Goudy Old Style"] = true;
    e2["Goudy Schoolbook"] = true;
    e2["Goudy Pro Font"] = true;
    e2.Granjon = true;
    e2["Guardian Egyptian"] = true;
    e2.Heather = true;
    e2.Hercules = true;
    e2["High Tower Text"] = true;
    e2.Hiroshige = true;
    e2["Hoefler Text"] = true;
    e2["Humana Serif"] = true;
    e2.Imprint = true;
    e2["Ionic No. 5"] = true;
    e2.Janson = true;
    e2.Joanna = true;
    e2.Korinna = true;
    e2.Lexicon = true;
    e2.LiberationSerif = true;
    e2["Liberation Serif"] = true;
    e2["Linux Libertine"] = true;
    e2.Literaturnaya = true;
    e2.Lucida = true;
    e2["Lucida Bright"] = true;
    e2.Melior = true;
    e2.Memphis = true;
    e2.Miller = true;
    e2.Minion = true;
    e2.Modern = true;
    e2["Mona Lisa"] = true;
    e2["Mrs Eaves"] = true;
    e2["MS Serif"] = true;
    e2["Museo Slab"] = true;
    e2["New York"] = true;
    e2["Nimbus Roman"] = true;
    e2["NPS Rawlinson Roadway"] = true;
    e2.NuptialScript = true;
    e2.Palatino = true;
    e2.Perpetua = true;
    e2.Plantin = true;
    e2["Plantin Schoolbook"] = true;
    e2.Playbill = true;
    e2["Poor Richard"] = true;
    e2["Rawlinson Roadway"] = true;
    e2.Renault = true;
    e2.Requiem = true;
    e2.Rockwell = true;
    e2.Roman = true;
    e2["Rotis Serif"] = true;
    e2.Sabon = true;
    e2.Scala = true;
    e2.Seagull = true;
    e2.Sistina = true;
    e2.Souvenir = true;
    e2.STIX = true;
    e2["Stone Informal"] = true;
    e2["Stone Serif"] = true;
    e2.Sylfaen = true;
    e2.Times = true;
    e2.Trajan = true;
    e2["Trinit\xE9"] = true;
    e2["Trump Mediaeval"] = true;
    e2.Utopia = true;
    e2["Vale Type"] = true;
    e2["Bitstream Vera"] = true;
    e2["Vera Serif"] = true;
    e2.Versailles = true;
    e2.Wanted = true;
    e2.Weiss = true;
    e2["Wide Latin"] = true;
    e2.Windsor = true;
    e2.XITS = true;
  }), Aa = getLookupTableFactory(function(e2) {
    e2.Dingbats = true;
    e2.Symbol = true;
    e2.ZapfDingbats = true;
    e2.Wingdings = true;
    e2["Wingdings-Bold"] = true;
    e2["Wingdings-Regular"] = true;
  }), ea = getLookupTableFactory(function(e2) {
    e2[2] = 10;
    e2[3] = 32;
    e2[4] = 33;
    e2[5] = 34;
    e2[6] = 35;
    e2[7] = 36;
    e2[8] = 37;
    e2[9] = 38;
    e2[10] = 39;
    e2[11] = 40;
    e2[12] = 41;
    e2[13] = 42;
    e2[14] = 43;
    e2[15] = 44;
    e2[16] = 45;
    e2[17] = 46;
    e2[18] = 47;
    e2[19] = 48;
    e2[20] = 49;
    e2[21] = 50;
    e2[22] = 51;
    e2[23] = 52;
    e2[24] = 53;
    e2[25] = 54;
    e2[26] = 55;
    e2[27] = 56;
    e2[28] = 57;
    e2[29] = 58;
    e2[30] = 894;
    e2[31] = 60;
    e2[32] = 61;
    e2[33] = 62;
    e2[34] = 63;
    e2[35] = 64;
    e2[36] = 65;
    e2[37] = 66;
    e2[38] = 67;
    e2[39] = 68;
    e2[40] = 69;
    e2[41] = 70;
    e2[42] = 71;
    e2[43] = 72;
    e2[44] = 73;
    e2[45] = 74;
    e2[46] = 75;
    e2[47] = 76;
    e2[48] = 77;
    e2[49] = 78;
    e2[50] = 79;
    e2[51] = 80;
    e2[52] = 81;
    e2[53] = 82;
    e2[54] = 83;
    e2[55] = 84;
    e2[56] = 85;
    e2[57] = 86;
    e2[58] = 87;
    e2[59] = 88;
    e2[60] = 89;
    e2[61] = 90;
    e2[62] = 91;
    e2[63] = 92;
    e2[64] = 93;
    e2[65] = 94;
    e2[66] = 95;
    e2[67] = 96;
    e2[68] = 97;
    e2[69] = 98;
    e2[70] = 99;
    e2[71] = 100;
    e2[72] = 101;
    e2[73] = 102;
    e2[74] = 103;
    e2[75] = 104;
    e2[76] = 105;
    e2[77] = 106;
    e2[78] = 107;
    e2[79] = 108;
    e2[80] = 109;
    e2[81] = 110;
    e2[82] = 111;
    e2[83] = 112;
    e2[84] = 113;
    e2[85] = 114;
    e2[86] = 115;
    e2[87] = 116;
    e2[88] = 117;
    e2[89] = 118;
    e2[90] = 119;
    e2[91] = 120;
    e2[92] = 121;
    e2[93] = 122;
    e2[94] = 123;
    e2[95] = 124;
    e2[96] = 125;
    e2[97] = 126;
    e2[98] = 196;
    e2[99] = 197;
    e2[100] = 199;
    e2[101] = 201;
    e2[102] = 209;
    e2[103] = 214;
    e2[104] = 220;
    e2[105] = 225;
    e2[106] = 224;
    e2[107] = 226;
    e2[108] = 228;
    e2[109] = 227;
    e2[110] = 229;
    e2[111] = 231;
    e2[112] = 233;
    e2[113] = 232;
    e2[114] = 234;
    e2[115] = 235;
    e2[116] = 237;
    e2[117] = 236;
    e2[118] = 238;
    e2[119] = 239;
    e2[120] = 241;
    e2[121] = 243;
    e2[122] = 242;
    e2[123] = 244;
    e2[124] = 246;
    e2[125] = 245;
    e2[126] = 250;
    e2[127] = 249;
    e2[128] = 251;
    e2[129] = 252;
    e2[130] = 8224;
    e2[131] = 176;
    e2[132] = 162;
    e2[133] = 163;
    e2[134] = 167;
    e2[135] = 8226;
    e2[136] = 182;
    e2[137] = 223;
    e2[138] = 174;
    e2[139] = 169;
    e2[140] = 8482;
    e2[141] = 180;
    e2[142] = 168;
    e2[143] = 8800;
    e2[144] = 198;
    e2[145] = 216;
    e2[146] = 8734;
    e2[147] = 177;
    e2[148] = 8804;
    e2[149] = 8805;
    e2[150] = 165;
    e2[151] = 181;
    e2[152] = 8706;
    e2[153] = 8721;
    e2[154] = 8719;
    e2[156] = 8747;
    e2[157] = 170;
    e2[158] = 186;
    e2[159] = 8486;
    e2[160] = 230;
    e2[161] = 248;
    e2[162] = 191;
    e2[163] = 161;
    e2[164] = 172;
    e2[165] = 8730;
    e2[166] = 402;
    e2[167] = 8776;
    e2[168] = 8710;
    e2[169] = 171;
    e2[170] = 187;
    e2[171] = 8230;
    e2[179] = 8220;
    e2[180] = 8221;
    e2[181] = 8216;
    e2[182] = 8217;
    e2[200] = 193;
    e2[203] = 205;
    e2[207] = 211;
    e2[210] = 218;
    e2[223] = 711;
    e2[224] = 321;
    e2[225] = 322;
    e2[226] = 352;
    e2[227] = 353;
    e2[228] = 381;
    e2[229] = 382;
    e2[233] = 221;
    e2[234] = 253;
    e2[252] = 263;
    e2[253] = 268;
    e2[254] = 269;
    e2[258] = 258;
    e2[260] = 260;
    e2[261] = 261;
    e2[265] = 280;
    e2[266] = 281;
    e2[267] = 282;
    e2[268] = 283;
    e2[269] = 313;
    e2[275] = 323;
    e2[276] = 324;
    e2[278] = 328;
    e2[283] = 344;
    e2[284] = 345;
    e2[285] = 346;
    e2[286] = 347;
    e2[292] = 367;
    e2[295] = 377;
    e2[296] = 378;
    e2[298] = 380;
    e2[305] = 963;
    e2[306] = 964;
    e2[307] = 966;
    e2[308] = 8215;
    e2[309] = 8252;
    e2[310] = 8319;
    e2[311] = 8359;
    e2[312] = 8592;
    e2[313] = 8593;
    e2[337] = 9552;
    e2[493] = 1039;
    e2[494] = 1040;
    e2[672] = 1488;
    e2[673] = 1489;
    e2[674] = 1490;
    e2[675] = 1491;
    e2[676] = 1492;
    e2[677] = 1493;
    e2[678] = 1494;
    e2[679] = 1495;
    e2[680] = 1496;
    e2[681] = 1497;
    e2[682] = 1498;
    e2[683] = 1499;
    e2[684] = 1500;
    e2[685] = 1501;
    e2[686] = 1502;
    e2[687] = 1503;
    e2[688] = 1504;
    e2[689] = 1505;
    e2[690] = 1506;
    e2[691] = 1507;
    e2[692] = 1508;
    e2[693] = 1509;
    e2[694] = 1510;
    e2[695] = 1511;
    e2[696] = 1512;
    e2[697] = 1513;
    e2[698] = 1514;
    e2[705] = 1524;
    e2[706] = 8362;
    e2[710] = 64288;
    e2[711] = 64298;
    e2[759] = 1617;
    e2[761] = 1776;
    e2[763] = 1778;
    e2[775] = 1652;
    e2[777] = 1764;
    e2[778] = 1780;
    e2[779] = 1781;
    e2[780] = 1782;
    e2[782] = 771;
    e2[783] = 64726;
    e2[786] = 8363;
    e2[788] = 8532;
    e2[790] = 768;
    e2[791] = 769;
    e2[792] = 768;
    e2[795] = 803;
    e2[797] = 64336;
    e2[798] = 64337;
    e2[799] = 64342;
    e2[800] = 64343;
    e2[801] = 64344;
    e2[802] = 64345;
    e2[803] = 64362;
    e2[804] = 64363;
    e2[805] = 64364;
    e2[2424] = 7821;
    e2[2425] = 7822;
    e2[2426] = 7823;
    e2[2427] = 7824;
    e2[2428] = 7825;
    e2[2429] = 7826;
    e2[2430] = 7827;
    e2[2433] = 7682;
    e2[2678] = 8045;
    e2[2679] = 8046;
    e2[2830] = 1552;
    e2[2838] = 686;
    e2[2840] = 751;
    e2[2842] = 753;
    e2[2843] = 754;
    e2[2844] = 755;
    e2[2846] = 757;
    e2[2856] = 767;
    e2[2857] = 848;
    e2[2858] = 849;
    e2[2862] = 853;
    e2[2863] = 854;
    e2[2864] = 855;
    e2[2865] = 861;
    e2[2866] = 862;
    e2[2906] = 7460;
    e2[2908] = 7462;
    e2[2909] = 7463;
    e2[2910] = 7464;
    e2[2912] = 7466;
    e2[2913] = 7467;
    e2[2914] = 7468;
    e2[2916] = 7470;
    e2[2917] = 7471;
    e2[2918] = 7472;
    e2[2920] = 7474;
    e2[2921] = 7475;
    e2[2922] = 7476;
    e2[2924] = 7478;
    e2[2925] = 7479;
    e2[2926] = 7480;
    e2[2928] = 7482;
    e2[2929] = 7483;
    e2[2930] = 7484;
    e2[2932] = 7486;
    e2[2933] = 7487;
    e2[2934] = 7488;
    e2[2936] = 7490;
    e2[2937] = 7491;
    e2[2938] = 7492;
    e2[2940] = 7494;
    e2[2941] = 7495;
    e2[2942] = 7496;
    e2[2944] = 7498;
    e2[2946] = 7500;
    e2[2948] = 7502;
    e2[2950] = 7504;
    e2[2951] = 7505;
    e2[2952] = 7506;
    e2[2954] = 7508;
    e2[2955] = 7509;
    e2[2956] = 7510;
    e2[2958] = 7512;
    e2[2959] = 7513;
    e2[2960] = 7514;
    e2[2962] = 7516;
    e2[2963] = 7517;
    e2[2964] = 7518;
    e2[2966] = 7520;
    e2[2967] = 7521;
    e2[2968] = 7522;
    e2[2970] = 7524;
    e2[2971] = 7525;
    e2[2972] = 7526;
    e2[2974] = 7528;
    e2[2975] = 7529;
    e2[2976] = 7530;
    e2[2978] = 1537;
    e2[2979] = 1538;
    e2[2980] = 1539;
    e2[2982] = 1549;
    e2[2983] = 1551;
    e2[2984] = 1552;
    e2[2986] = 1554;
    e2[2987] = 1555;
    e2[2988] = 1556;
    e2[2990] = 1623;
    e2[2991] = 1624;
    e2[2995] = 1775;
    e2[2999] = 1791;
    e2[3002] = 64290;
    e2[3003] = 64291;
    e2[3004] = 64292;
    e2[3006] = 64294;
    e2[3007] = 64295;
    e2[3008] = 64296;
    e2[3011] = 1900;
    e2[3014] = 8223;
    e2[3015] = 8244;
    e2[3017] = 7532;
    e2[3018] = 7533;
    e2[3019] = 7534;
    e2[3075] = 7590;
    e2[3076] = 7591;
    e2[3079] = 7594;
    e2[3080] = 7595;
    e2[3083] = 7598;
    e2[3084] = 7599;
    e2[3087] = 7602;
    e2[3088] = 7603;
    e2[3091] = 7606;
    e2[3092] = 7607;
    e2[3095] = 7610;
    e2[3096] = 7611;
    e2[3099] = 7614;
    e2[3100] = 7615;
    e2[3103] = 7618;
    e2[3104] = 7619;
    e2[3107] = 8337;
    e2[3108] = 8338;
    e2[3116] = 1884;
    e2[3119] = 1885;
    e2[3120] = 1885;
    e2[3123] = 1886;
    e2[3124] = 1886;
    e2[3127] = 1887;
    e2[3128] = 1887;
    e2[3131] = 1888;
    e2[3132] = 1888;
    e2[3135] = 1889;
    e2[3136] = 1889;
    e2[3139] = 1890;
    e2[3140] = 1890;
    e2[3143] = 1891;
    e2[3144] = 1891;
    e2[3147] = 1892;
    e2[3148] = 1892;
    e2[3153] = 580;
    e2[3154] = 581;
    e2[3157] = 584;
    e2[3158] = 585;
    e2[3161] = 588;
    e2[3162] = 589;
    e2[3165] = 891;
    e2[3166] = 892;
    e2[3169] = 1274;
    e2[3170] = 1275;
    e2[3173] = 1278;
    e2[3174] = 1279;
    e2[3181] = 7622;
    e2[3182] = 7623;
    e2[3282] = 11799;
    e2[3316] = 578;
    e2[3379] = 42785;
    e2[3393] = 1159;
    e2[3416] = 8377;
  }), ta = getLookupTableFactory(function(e2) {
    e2[227] = 322;
    e2[264] = 261;
    e2[291] = 346;
  }), ia = getLookupTableFactory(function(e2) {
    e2[1] = 32;
    e2[4] = 65;
    e2[5] = 192;
    e2[6] = 193;
    e2[9] = 196;
    e2[17] = 66;
    e2[18] = 67;
    e2[21] = 268;
    e2[24] = 68;
    e2[28] = 69;
    e2[29] = 200;
    e2[30] = 201;
    e2[32] = 282;
    e2[38] = 70;
    e2[39] = 71;
    e2[44] = 72;
    e2[47] = 73;
    e2[48] = 204;
    e2[49] = 205;
    e2[58] = 74;
    e2[60] = 75;
    e2[62] = 76;
    e2[68] = 77;
    e2[69] = 78;
    e2[75] = 79;
    e2[76] = 210;
    e2[80] = 214;
    e2[87] = 80;
    e2[89] = 81;
    e2[90] = 82;
    e2[92] = 344;
    e2[94] = 83;
    e2[97] = 352;
    e2[100] = 84;
    e2[104] = 85;
    e2[109] = 220;
    e2[115] = 86;
    e2[116] = 87;
    e2[121] = 88;
    e2[122] = 89;
    e2[124] = 221;
    e2[127] = 90;
    e2[129] = 381;
    e2[258] = 97;
    e2[259] = 224;
    e2[260] = 225;
    e2[263] = 228;
    e2[268] = 261;
    e2[271] = 98;
    e2[272] = 99;
    e2[273] = 263;
    e2[275] = 269;
    e2[282] = 100;
    e2[286] = 101;
    e2[287] = 232;
    e2[288] = 233;
    e2[290] = 283;
    e2[295] = 281;
    e2[296] = 102;
    e2[336] = 103;
    e2[346] = 104;
    e2[349] = 105;
    e2[350] = 236;
    e2[351] = 237;
    e2[361] = 106;
    e2[364] = 107;
    e2[367] = 108;
    e2[371] = 322;
    e2[373] = 109;
    e2[374] = 110;
    e2[381] = 111;
    e2[382] = 242;
    e2[383] = 243;
    e2[386] = 246;
    e2[393] = 112;
    e2[395] = 113;
    e2[396] = 114;
    e2[398] = 345;
    e2[400] = 115;
    e2[401] = 347;
    e2[403] = 353;
    e2[410] = 116;
    e2[437] = 117;
    e2[442] = 252;
    e2[448] = 118;
    e2[449] = 119;
    e2[454] = 120;
    e2[455] = 121;
    e2[457] = 253;
    e2[460] = 122;
    e2[462] = 382;
    e2[463] = 380;
    e2[853] = 44;
    e2[855] = 58;
    e2[856] = 46;
    e2[876] = 47;
    e2[878] = 45;
    e2[882] = 45;
    e2[894] = 40;
    e2[895] = 41;
    e2[896] = 91;
    e2[897] = 93;
    e2[923] = 64;
    e2[1004] = 48;
    e2[1005] = 49;
    e2[1006] = 50;
    e2[1007] = 51;
    e2[1008] = 52;
    e2[1009] = 53;
    e2[1010] = 54;
    e2[1011] = 55;
    e2[1012] = 56;
    e2[1013] = 57;
    e2[1081] = 37;
    e2[1085] = 43;
    e2[1086] = 45;
  });
  function getStandardFontName(e2) {
    const t2 = normalizeFontName(e2);
    return Vi()[t2];
  }
  function isKnownFontName(e2) {
    const t2 = normalizeFontName(e2);
    return !!(Vi()[t2] || zi()[t2] || $i()[t2] || Aa()[t2]);
  }
  class ToUnicodeMap {
    constructor(e2 = []) {
      this._map = e2;
    }
    get length() {
      return this._map.length;
    }
    forEach(e2) {
      for (const t2 in this._map) e2(t2, this._map[t2].charCodeAt(0));
    }
    has(e2) {
      return void 0 !== this._map[e2];
    }
    get(e2) {
      return this._map[e2];
    }
    charCodeOf(e2) {
      const t2 = this._map;
      if (t2.length <= 65536) return t2.indexOf(e2);
      for (const i2 in t2) if (t2[i2] === e2) return 0 | i2;
      return -1;
    }
    amend(e2) {
      for (const t2 in e2) this._map[t2] = e2[t2];
    }
  }
  class IdentityToUnicodeMap {
    constructor(e2, t2) {
      this.firstChar = e2;
      this.lastChar = t2;
    }
    get length() {
      return this.lastChar + 1 - this.firstChar;
    }
    forEach(e2) {
      for (let t2 = this.firstChar, i2 = this.lastChar; t2 <= i2; t2++) e2(t2, t2);
    }
    has(e2) {
      return this.firstChar <= e2 && e2 <= this.lastChar;
    }
    get(e2) {
      if (this.firstChar <= e2 && e2 <= this.lastChar) return String.fromCharCode(e2);
    }
    charCodeOf(e2) {
      return Number.isInteger(e2) && e2 >= this.firstChar && e2 <= this.lastChar ? e2 : -1;
    }
    amend(e2) {
      unreachable("Should not call amend()");
    }
  }
  class CFFFont {
    constructor(e2, t2) {
      this.properties = t2;
      const i2 = new CFFParser(e2, t2, qi);
      this.cff = i2.parse();
      this.cff.duplicateFirstGlyph();
      const a2 = new CFFCompiler(this.cff);
      this.seacs = this.cff.seacs;
      try {
        this.data = a2.compile();
      } catch {
        warn("Failed to compile font " + t2.loadedName);
        this.data = e2;
      }
      this._createBuiltInEncoding();
    }
    get numGlyphs() {
      return this.cff.charStrings.count;
    }
    getCharset() {
      return this.cff.charset.charset;
    }
    getGlyphMapping() {
      const e2 = this.cff, t2 = this.properties, { cidToGidMap: i2, cMap: a2 } = t2, r2 = e2.charset.charset;
      let s2, n2;
      if (t2.composite) {
        let t3, o3;
        if ((i2 == null ? void 0 : i2.length) > 0) {
          t3 = /* @__PURE__ */ Object.create(null);
          for (let e3 = 0, a3 = i2.length; e3 < a3; e3++) {
            const a4 = i2[e3];
            void 0 !== a4 && (t3[a4] = e3);
          }
        }
        s2 = /* @__PURE__ */ Object.create(null);
        if (e2.isCIDFont) for (n2 = 0; n2 < r2.length; n2++) {
          const e3 = r2[n2];
          o3 = a2.charCodeOf(e3);
          void 0 !== (t3 == null ? void 0 : t3[o3]) && (o3 = t3[o3]);
          s2[o3] = n2;
        }
        else for (n2 = 0; n2 < e2.charStrings.count; n2++) {
          o3 = a2.charCodeOf(n2);
          s2[o3] = n2;
        }
        return s2;
      }
      let o2 = e2.encoding ? e2.encoding.encoding : null;
      t2.isInternalFont && (o2 = t2.defaultEncoding);
      s2 = type1FontGlyphMapping(t2, o2, r2);
      return s2;
    }
    hasGlyphId(e2) {
      return this.cff.hasGlyphId(e2);
    }
    _createBuiltInEncoding() {
      const { charset: e2, encoding: t2 } = this.cff;
      if (!e2 || !t2) return;
      const i2 = e2.charset, a2 = t2.encoding, r2 = [];
      for (const e3 in a2) {
        const t3 = a2[e3];
        if (t3 >= 0) {
          const a3 = i2[t3];
          a3 && (r2[e3] = a3);
        }
      }
      r2.length > 0 && (this.properties.builtInEncoding = r2);
    }
  }
  function getUint32(e2, t2) {
    return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
  }
  function getUint16(e2, t2) {
    return e2[t2] << 8 | e2[t2 + 1];
  }
  function getInt16(e2, t2) {
    return (e2[t2] << 24 | e2[t2 + 1] << 16) >> 16;
  }
  function getInt8(e2, t2) {
    return e2[t2] << 24 >> 24;
  }
  function getFloat214(e2, t2) {
    return getInt16(e2, t2) / 16384;
  }
  function getSubroutineBias(e2) {
    const t2 = e2.length;
    let i2 = 32768;
    t2 < 1240 ? i2 = 107 : t2 < 33900 && (i2 = 1131);
    return i2;
  }
  function parseCmap(e2, t2, i2) {
    const a2 = 1 === getUint16(e2, t2 + 2) ? getUint32(e2, t2 + 8) : getUint32(e2, t2 + 16), r2 = getUint16(e2, t2 + a2);
    let s2, n2, o2;
    if (4 === r2) {
      getUint16(e2, t2 + a2 + 2);
      const i3 = getUint16(e2, t2 + a2 + 6) >> 1;
      n2 = t2 + a2 + 14;
      s2 = [];
      for (o2 = 0; o2 < i3; o2++, n2 += 2) s2[o2] = {
        end: getUint16(e2, n2)
      };
      n2 += 2;
      for (o2 = 0; o2 < i3; o2++, n2 += 2) s2[o2].start = getUint16(e2, n2);
      for (o2 = 0; o2 < i3; o2++, n2 += 2) s2[o2].idDelta = getUint16(e2, n2);
      for (o2 = 0; o2 < i3; o2++, n2 += 2) {
        let t3 = getUint16(e2, n2);
        if (0 !== t3) {
          s2[o2].ids = [];
          for (let i4 = 0, a3 = s2[o2].end - s2[o2].start + 1; i4 < a3; i4++) {
            s2[o2].ids[i4] = getUint16(e2, n2 + t3);
            t3 += 2;
          }
        }
      }
      return s2;
    }
    if (12 === r2) {
      const i3 = getUint32(e2, t2 + a2 + 12);
      n2 = t2 + a2 + 16;
      s2 = [];
      for (o2 = 0; o2 < i3; o2++) {
        t2 = getUint32(e2, n2);
        s2.push({
          start: t2,
          end: getUint32(e2, n2 + 4),
          idDelta: getUint32(e2, n2 + 8) - t2
        });
        n2 += 12;
      }
      return s2;
    }
    throw new FormatError(`unsupported cmap: ${r2}`);
  }
  function parseCff(e2, t2, i2, a2) {
    var _a4, _b, _c;
    const r2 = new CFFParser(new Stream(e2, t2, i2 - t2), {}, a2).parse();
    return {
      glyphs: r2.charStrings.objects,
      subrs: (_b = (_a4 = r2.topDict.privateDict) == null ? void 0 : _a4.subrsIndex) == null ? void 0 : _b.objects,
      gsubrs: (_c = r2.globalSubrIndex) == null ? void 0 : _c.objects,
      isCFFCIDFont: r2.isCIDFont,
      fdSelect: r2.fdSelect,
      fdArray: r2.fdArray
    };
  }
  function lookupCmap(e2, t2) {
    const i2 = t2.codePointAt(0);
    let a2 = 0, r2 = 0, s2 = e2.length - 1;
    for (; r2 < s2; ) {
      const t3 = r2 + s2 + 1 >> 1;
      i2 < e2[t3].start ? s2 = t3 - 1 : r2 = t3;
    }
    e2[r2].start <= i2 && i2 <= e2[r2].end && (a2 = e2[r2].idDelta + (e2[r2].ids ? e2[r2].ids[i2 - e2[r2].start] : i2) & 65535);
    return {
      charCode: i2,
      glyphId: a2
    };
  }
  function compileGlyf(e2, t2, i2) {
    function moveTo(e3, i3) {
      t2.add(Qt, [
        e3,
        i3
      ]);
    }
    function lineTo(e3, i3) {
      t2.add(Et, [
        e3,
        i3
      ]);
    }
    function quadraticCurveTo(e3, i3, a3, r3) {
      t2.add(ut, [
        e3,
        i3,
        a3,
        r3
      ]);
    }
    let a2 = 0;
    const r2 = getInt16(e2, a2);
    let s2, n2 = 0, o2 = 0;
    a2 += 10;
    if (r2 < 0) do {
      s2 = getUint16(e2, a2);
      const r3 = getUint16(e2, a2 + 2);
      a2 += 4;
      let g2, c2;
      if (1 & s2) {
        if (2 & s2) {
          g2 = getInt16(e2, a2);
          c2 = getInt16(e2, a2 + 2);
        } else {
          g2 = getUint16(e2, a2);
          c2 = getUint16(e2, a2 + 2);
        }
        a2 += 4;
      } else if (2 & s2) {
        g2 = getInt8(e2, a2++);
        c2 = getInt8(e2, a2++);
      } else {
        g2 = e2[a2++];
        c2 = e2[a2++];
      }
      if (2 & s2) {
        n2 = g2;
        o2 = c2;
      } else {
        n2 = 0;
        o2 = 0;
      }
      let C2 = 1, h2 = 1, l2 = 0, Q2 = 0;
      if (8 & s2) {
        C2 = h2 = getFloat214(e2, a2);
        a2 += 2;
      } else if (64 & s2) {
        C2 = getFloat214(e2, a2);
        h2 = getFloat214(e2, a2 + 2);
        a2 += 4;
      } else if (128 & s2) {
        C2 = getFloat214(e2, a2);
        l2 = getFloat214(e2, a2 + 2);
        Q2 = getFloat214(e2, a2 + 4);
        h2 = getFloat214(e2, a2 + 6);
        a2 += 8;
      }
      const E2 = i2.glyphs[r3];
      if (E2) {
        t2.add(ft);
        t2.add(mt, [
          C2,
          l2,
          Q2,
          h2,
          n2,
          o2
        ]);
        compileGlyf(E2, t2, i2);
        t2.add(dt);
      }
    } while (32 & s2);
    else {
      const t3 = [];
      let i3, g2;
      for (i3 = 0; i3 < r2; i3++) {
        t3.push(getUint16(e2, a2));
        a2 += 2;
      }
      a2 += 2 + getUint16(e2, a2);
      const c2 = t3.at(-1) + 1, C2 = [];
      for (; C2.length < c2; ) {
        s2 = e2[a2++];
        let t4 = 1;
        8 & s2 && (t4 += e2[a2++]);
        for (; t4-- > 0; ) C2.push({
          flags: s2
        });
      }
      for (i3 = 0; i3 < c2; i3++) {
        switch (18 & C2[i3].flags) {
          case 0:
            n2 += getInt16(e2, a2);
            a2 += 2;
            break;
          case 2:
            n2 -= e2[a2++];
            break;
          case 18:
            n2 += e2[a2++];
        }
        C2[i3].x = n2;
      }
      for (i3 = 0; i3 < c2; i3++) {
        switch (36 & C2[i3].flags) {
          case 0:
            o2 += getInt16(e2, a2);
            a2 += 2;
            break;
          case 4:
            o2 -= e2[a2++];
            break;
          case 36:
            o2 += e2[a2++];
        }
        C2[i3].y = o2;
      }
      let h2 = 0;
      for (a2 = 0; a2 < r2; a2++) {
        const e3 = t3[a2], r3 = C2.slice(h2, e3 + 1);
        if (1 & r3[0].flags) r3.push(r3[0]);
        else if (1 & r3.at(-1).flags) r3.unshift(r3.at(-1));
        else {
          const e4 = {
            flags: 1,
            x: (r3[0].x + r3.at(-1).x) / 2,
            y: (r3[0].y + r3.at(-1).y) / 2
          };
          r3.unshift(e4);
          r3.push(e4);
        }
        moveTo(r3[0].x, r3[0].y);
        for (i3 = 1, g2 = r3.length; i3 < g2; i3++) if (1 & r3[i3].flags) lineTo(r3[i3].x, r3[i3].y);
        else if (1 & r3[i3 + 1].flags) {
          quadraticCurveTo(r3[i3].x, r3[i3].y, r3[i3 + 1].x, r3[i3 + 1].y);
          i3++;
        } else quadraticCurveTo(r3[i3].x, r3[i3].y, (r3[i3].x + r3[i3 + 1].x) / 2, (r3[i3].y + r3[i3 + 1].y) / 2);
        h2 = e3 + 1;
      }
    }
  }
  function compileCharString(e2, t2, i2, a2) {
    function moveTo(e3, i3) {
      t2.add(Qt, [
        e3,
        i3
      ]);
    }
    function lineTo(e3, i3) {
      t2.add(Et, [
        e3,
        i3
      ]);
    }
    function bezierCurveTo(e3, i3, a3, r3, s3, n3) {
      t2.add(Bt, [
        e3,
        i3,
        a3,
        r3,
        s3,
        n3
      ]);
    }
    const r2 = [];
    let s2 = 0, n2 = 0, o2 = 0;
    !function parse(e3) {
      var _a4;
      let g2 = 0;
      for (; g2 < e3.length; ) {
        let c2, C2, h2, l2, Q2, E2, u2, d2, f2, p2 = false, m2 = e3[g2++];
        switch (m2) {
          case 1:
          case 3:
          case 18:
          case 23:
            o2 += r2.length >> 1;
            p2 = true;
            break;
          case 4:
            n2 += r2.pop();
            moveTo(s2, n2);
            p2 = true;
            break;
          case 5:
            for (; r2.length > 0; ) {
              s2 += r2.shift();
              n2 += r2.shift();
              lineTo(s2, n2);
            }
            break;
          case 6:
            for (; r2.length > 0; ) {
              s2 += r2.shift();
              lineTo(s2, n2);
              if (0 === r2.length) break;
              n2 += r2.shift();
              lineTo(s2, n2);
            }
            break;
          case 7:
            for (; r2.length > 0; ) {
              n2 += r2.shift();
              lineTo(s2, n2);
              if (0 === r2.length) break;
              s2 += r2.shift();
              lineTo(s2, n2);
            }
            break;
          case 8:
            for (; r2.length > 0; ) {
              c2 = s2 + r2.shift();
              h2 = n2 + r2.shift();
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              s2 = C2 + r2.shift();
              n2 = l2 + r2.shift();
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
            }
            break;
          case 10:
            d2 = r2.pop();
            f2 = null;
            if (i2.isCFFCIDFont) {
              const e4 = i2.fdSelect.getFDIndex(a2);
              if (e4 >= 0 && e4 < i2.fdArray.length) {
                const t3 = i2.fdArray[e4];
                let a3;
                ((_a4 = t3.privateDict) == null ? void 0 : _a4.subrsIndex) && (a3 = t3.privateDict.subrsIndex.objects);
                if (a3) {
                  d2 += getSubroutineBias(a3);
                  f2 = a3[d2];
                }
              } else warn("Invalid fd index for glyph index.");
            } else f2 = i2.subrs[d2 + i2.subrsBias];
            f2 && parse(f2);
            break;
          case 11:
            return;
          case 12:
            m2 = e3[g2++];
            switch (m2) {
              case 34:
                c2 = s2 + r2.shift();
                C2 = c2 + r2.shift();
                Q2 = n2 + r2.shift();
                s2 = C2 + r2.shift();
                bezierCurveTo(c2, n2, C2, Q2, s2, Q2);
                c2 = s2 + r2.shift();
                C2 = c2 + r2.shift();
                s2 = C2 + r2.shift();
                bezierCurveTo(c2, Q2, C2, n2, s2, n2);
                break;
              case 35:
                c2 = s2 + r2.shift();
                h2 = n2 + r2.shift();
                C2 = c2 + r2.shift();
                l2 = h2 + r2.shift();
                s2 = C2 + r2.shift();
                n2 = l2 + r2.shift();
                bezierCurveTo(c2, h2, C2, l2, s2, n2);
                c2 = s2 + r2.shift();
                h2 = n2 + r2.shift();
                C2 = c2 + r2.shift();
                l2 = h2 + r2.shift();
                s2 = C2 + r2.shift();
                n2 = l2 + r2.shift();
                bezierCurveTo(c2, h2, C2, l2, s2, n2);
                r2.pop();
                break;
              case 36:
                c2 = s2 + r2.shift();
                Q2 = n2 + r2.shift();
                C2 = c2 + r2.shift();
                E2 = Q2 + r2.shift();
                s2 = C2 + r2.shift();
                bezierCurveTo(c2, Q2, C2, E2, s2, E2);
                c2 = s2 + r2.shift();
                C2 = c2 + r2.shift();
                u2 = E2 + r2.shift();
                s2 = C2 + r2.shift();
                bezierCurveTo(c2, E2, C2, u2, s2, n2);
                break;
              case 37:
                const e4 = s2, t3 = n2;
                c2 = s2 + r2.shift();
                h2 = n2 + r2.shift();
                C2 = c2 + r2.shift();
                l2 = h2 + r2.shift();
                s2 = C2 + r2.shift();
                n2 = l2 + r2.shift();
                bezierCurveTo(c2, h2, C2, l2, s2, n2);
                c2 = s2 + r2.shift();
                h2 = n2 + r2.shift();
                C2 = c2 + r2.shift();
                l2 = h2 + r2.shift();
                s2 = C2;
                n2 = l2;
                Math.abs(s2 - e4) > Math.abs(n2 - t3) ? s2 += r2.shift() : n2 += r2.shift();
                bezierCurveTo(c2, h2, C2, l2, s2, n2);
                break;
              default:
                throw new FormatError(`unknown operator: 12 ${m2}`);
            }
            break;
          case 14:
            if (r2.length >= 4) {
              const e4 = r2.pop(), a3 = r2.pop();
              n2 = r2.pop();
              s2 = r2.pop();
              t2.add(ft);
              t2.add(yt, [
                s2,
                n2
              ]);
              let o3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[wi[e4]]));
              compileCharString(i2.glyphs[o3.glyphId], t2, i2, o3.glyphId);
              t2.add(dt);
              o3 = lookupCmap(i2.cmap, String.fromCharCode(i2.glyphNameMap[wi[a3]]));
              compileCharString(i2.glyphs[o3.glyphId], t2, i2, o3.glyphId);
            }
            return;
          case 19:
          case 20:
            o2 += r2.length >> 1;
            g2 += o2 + 7 >> 3;
            p2 = true;
            break;
          case 21:
            n2 += r2.pop();
            s2 += r2.pop();
            moveTo(s2, n2);
            p2 = true;
            break;
          case 22:
            s2 += r2.pop();
            moveTo(s2, n2);
            p2 = true;
            break;
          case 24:
            for (; r2.length > 2; ) {
              c2 = s2 + r2.shift();
              h2 = n2 + r2.shift();
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              s2 = C2 + r2.shift();
              n2 = l2 + r2.shift();
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
            }
            s2 += r2.shift();
            n2 += r2.shift();
            lineTo(s2, n2);
            break;
          case 25:
            for (; r2.length > 6; ) {
              s2 += r2.shift();
              n2 += r2.shift();
              lineTo(s2, n2);
            }
            c2 = s2 + r2.shift();
            h2 = n2 + r2.shift();
            C2 = c2 + r2.shift();
            l2 = h2 + r2.shift();
            s2 = C2 + r2.shift();
            n2 = l2 + r2.shift();
            bezierCurveTo(c2, h2, C2, l2, s2, n2);
            break;
          case 26:
            r2.length % 2 && (s2 += r2.shift());
            for (; r2.length > 0; ) {
              c2 = s2;
              h2 = n2 + r2.shift();
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              s2 = C2;
              n2 = l2 + r2.shift();
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
            }
            break;
          case 27:
            r2.length % 2 && (n2 += r2.shift());
            for (; r2.length > 0; ) {
              c2 = s2 + r2.shift();
              h2 = n2;
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              s2 = C2 + r2.shift();
              n2 = l2;
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
            }
            break;
          case 28:
            r2.push((e3[g2] << 24 | e3[g2 + 1] << 16) >> 16);
            g2 += 2;
            break;
          case 29:
            d2 = r2.pop() + i2.gsubrsBias;
            f2 = i2.gsubrs[d2];
            f2 && parse(f2);
            break;
          case 30:
            for (; r2.length > 0; ) {
              c2 = s2;
              h2 = n2 + r2.shift();
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              s2 = C2 + r2.shift();
              n2 = l2 + (1 === r2.length ? r2.shift() : 0);
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
              if (0 === r2.length) break;
              c2 = s2 + r2.shift();
              h2 = n2;
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              n2 = l2 + r2.shift();
              s2 = C2 + (1 === r2.length ? r2.shift() : 0);
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
            }
            break;
          case 31:
            for (; r2.length > 0; ) {
              c2 = s2 + r2.shift();
              h2 = n2;
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              n2 = l2 + r2.shift();
              s2 = C2 + (1 === r2.length ? r2.shift() : 0);
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
              if (0 === r2.length) break;
              c2 = s2;
              h2 = n2 + r2.shift();
              C2 = c2 + r2.shift();
              l2 = h2 + r2.shift();
              s2 = C2 + r2.shift();
              n2 = l2 + (1 === r2.length ? r2.shift() : 0);
              bezierCurveTo(c2, h2, C2, l2, s2, n2);
            }
            break;
          default:
            if (m2 < 32) throw new FormatError(`unknown operator: ${m2}`);
            if (m2 < 247) r2.push(m2 - 139);
            else if (m2 < 251) r2.push(256 * (m2 - 247) + e3[g2++] + 108);
            else if (m2 < 255) r2.push(256 * -(m2 - 251) - e3[g2++] - 108);
            else {
              r2.push((e3[g2] << 24 | e3[g2 + 1] << 16 | e3[g2 + 2] << 8 | e3[g2 + 3]) / 65536);
              g2 += 4;
            }
        }
        p2 && (r2.length = 0);
      }
    }(e2);
  }
  const aa = [];
  class Commands {
    constructor() {
      __publicField(this, "cmds", []);
    }
    add(e2, t2) {
      if (t2) if (isNumberArray(t2, null)) this.cmds.push(e2, ...t2);
      else {
        warn(`Commands.add - "${e2}" has at least one non-number arg: "${t2}".`);
        const i2 = t2.map((e3) => "number" == typeof e3 ? e3 : 0);
        this.cmds.push(e2, ...i2);
      }
      else this.cmds.push(e2);
    }
  }
  class CompiledFont {
    constructor(e2) {
      this.fontMatrix = e2;
      this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
      this.compiledCharCodeToGlyphId = /* @__PURE__ */ Object.create(null);
    }
    getPathJs(e2) {
      var _a4;
      const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
      let a2, r2 = this.compiledGlyphs[i2];
      if (!r2) {
        try {
          r2 = this.compileGlyph(this.glyphs[i2], i2);
        } catch (e3) {
          r2 = aa;
          a2 = e3;
        }
        this.compiledGlyphs[i2] = r2;
      }
      (_a4 = this.compiledCharCodeToGlyphId)[t2] ?? (_a4[t2] = i2);
      if (a2) throw a2;
      return r2;
    }
    compileGlyph(e2, t2) {
      if (!e2 || 0 === e2.length || 14 === e2[0]) return aa;
      let i2 = this.fontMatrix;
      if (this.isCFFCIDFont) {
        const e3 = this.fdSelect.getFDIndex(t2);
        if (e3 >= 0 && e3 < this.fdArray.length) {
          i2 = this.fdArray[e3].getByName("FontMatrix") || r;
        } else warn("Invalid fd index for glyph index.");
      }
      const a2 = new Commands();
      a2.add(ft);
      a2.add(mt, i2.slice());
      a2.add(pt);
      this.compileGlyphImpl(e2, a2, t2);
      a2.add(dt);
      return a2.cmds;
    }
    compileGlyphImpl() {
      unreachable("Children classes should implement this.");
    }
    hasBuiltPath(e2) {
      const { charCode: t2, glyphId: i2 } = lookupCmap(this.cmap, e2);
      return void 0 !== this.compiledGlyphs[i2] && void 0 !== this.compiledCharCodeToGlyphId[t2];
    }
  }
  class TrueTypeCompiled extends CompiledFont {
    constructor(e2, t2, i2) {
      super(i2 || [
        488e-6,
        0,
        0,
        488e-6,
        0,
        0
      ]);
      this.glyphs = e2;
      this.cmap = t2;
    }
    compileGlyphImpl(e2, t2) {
      compileGlyf(e2, t2, this);
    }
  }
  class Type2Compiled extends CompiledFont {
    constructor(e2, t2, i2, a2) {
      super(i2 || [
        1e-3,
        0,
        0,
        1e-3,
        0,
        0
      ]);
      this.glyphs = e2.glyphs;
      this.gsubrs = e2.gsubrs || [];
      this.subrs = e2.subrs || [];
      this.cmap = t2;
      this.glyphNameMap = a2 || Hi();
      this.gsubrsBias = getSubroutineBias(this.gsubrs);
      this.subrsBias = getSubroutineBias(this.subrs);
      this.isCFFCIDFont = e2.isCFFCIDFont;
      this.fdSelect = e2.fdSelect;
      this.fdArray = e2.fdArray;
    }
    compileGlyphImpl(e2, t2, i2) {
      compileCharString(e2, t2, this, i2);
    }
  }
  class FontRendererFactory {
    static create(e2, t2) {
      const i2 = new Uint8Array(e2.data);
      let a2, r2, s2, n2, o2, g2;
      const c2 = getUint16(i2, 4);
      for (let e3 = 0, C2 = 12; e3 < c2; e3++, C2 += 16) {
        const e4 = bytesToString(i2.subarray(C2, C2 + 4)), c3 = getUint32(i2, C2 + 8), h2 = getUint32(i2, C2 + 12);
        switch (e4) {
          case "cmap":
            a2 = parseCmap(i2, c3);
            break;
          case "glyf":
            r2 = i2.subarray(c3, c3 + h2);
            break;
          case "loca":
            s2 = i2.subarray(c3, c3 + h2);
            break;
          case "head":
            g2 = getUint16(i2, c3 + 18);
            o2 = getUint16(i2, c3 + 50);
            break;
          case "CFF ":
            n2 = parseCff(i2, c3, c3 + h2, t2);
        }
      }
      if (r2) {
        const t3 = g2 ? [
          1 / g2,
          0,
          0,
          1 / g2,
          0,
          0
        ] : e2.fontMatrix;
        return new TrueTypeCompiled(function parseGlyfTable(e3, t4, i3) {
          let a3, r3;
          if (i3) {
            a3 = 4;
            r3 = getUint32;
          } else {
            a3 = 2;
            r3 = (e4, t5) => 2 * getUint16(e4, t5);
          }
          const s3 = [];
          let n3 = r3(t4, 0);
          for (let i4 = a3; i4 < t4.length; i4 += a3) {
            const a4 = r3(t4, i4);
            s3.push(e3.subarray(n3, a4));
            n3 = a4;
          }
          return s3;
        }(r2, s2, o2), a2, t3);
      }
      return new Type2Compiled(n2, a2, e2.fontMatrix, e2.glyphNameMap);
    }
  }
  const ra = getLookupTableFactory(function(e2) {
    e2.Courier = 600;
    e2["Courier-Bold"] = 600;
    e2["Courier-BoldOblique"] = 600;
    e2["Courier-Oblique"] = 600;
    e2.Helvetica = getLookupTableFactory(function(e3) {
      e3.space = 278;
      e3.exclam = 278;
      e3.quotedbl = 355;
      e3.numbersign = 556;
      e3.dollar = 556;
      e3.percent = 889;
      e3.ampersand = 667;
      e3.quoteright = 222;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 389;
      e3.plus = 584;
      e3.comma = 278;
      e3.hyphen = 333;
      e3.period = 278;
      e3.slash = 278;
      e3.zero = 556;
      e3.one = 556;
      e3.two = 556;
      e3.three = 556;
      e3.four = 556;
      e3.five = 556;
      e3.six = 556;
      e3.seven = 556;
      e3.eight = 556;
      e3.nine = 556;
      e3.colon = 278;
      e3.semicolon = 278;
      e3.less = 584;
      e3.equal = 584;
      e3.greater = 584;
      e3.question = 556;
      e3.at = 1015;
      e3.A = 667;
      e3.B = 667;
      e3.C = 722;
      e3.D = 722;
      e3.E = 667;
      e3.F = 611;
      e3.G = 778;
      e3.H = 722;
      e3.I = 278;
      e3.J = 500;
      e3.K = 667;
      e3.L = 556;
      e3.M = 833;
      e3.N = 722;
      e3.O = 778;
      e3.P = 667;
      e3.Q = 778;
      e3.R = 722;
      e3.S = 667;
      e3.T = 611;
      e3.U = 722;
      e3.V = 667;
      e3.W = 944;
      e3.X = 667;
      e3.Y = 667;
      e3.Z = 611;
      e3.bracketleft = 278;
      e3.backslash = 278;
      e3.bracketright = 278;
      e3.asciicircum = 469;
      e3.underscore = 556;
      e3.quoteleft = 222;
      e3.a = 556;
      e3.b = 556;
      e3.c = 500;
      e3.d = 556;
      e3.e = 556;
      e3.f = 278;
      e3.g = 556;
      e3.h = 556;
      e3.i = 222;
      e3.j = 222;
      e3.k = 500;
      e3.l = 222;
      e3.m = 833;
      e3.n = 556;
      e3.o = 556;
      e3.p = 556;
      e3.q = 556;
      e3.r = 333;
      e3.s = 500;
      e3.t = 278;
      e3.u = 556;
      e3.v = 500;
      e3.w = 722;
      e3.x = 500;
      e3.y = 500;
      e3.z = 500;
      e3.braceleft = 334;
      e3.bar = 260;
      e3.braceright = 334;
      e3.asciitilde = 584;
      e3.exclamdown = 333;
      e3.cent = 556;
      e3.sterling = 556;
      e3.fraction = 167;
      e3.yen = 556;
      e3.florin = 556;
      e3.section = 556;
      e3.currency = 556;
      e3.quotesingle = 191;
      e3.quotedblleft = 333;
      e3.guillemotleft = 556;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 500;
      e3.fl = 500;
      e3.endash = 556;
      e3.dagger = 556;
      e3.daggerdbl = 556;
      e3.periodcentered = 278;
      e3.paragraph = 537;
      e3.bullet = 350;
      e3.quotesinglbase = 222;
      e3.quotedblbase = 333;
      e3.quotedblright = 333;
      e3.guillemotright = 556;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 611;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 1e3;
      e3.ordfeminine = 370;
      e3.Lslash = 556;
      e3.Oslash = 778;
      e3.OE = 1e3;
      e3.ordmasculine = 365;
      e3.ae = 889;
      e3.dotlessi = 278;
      e3.lslash = 222;
      e3.oslash = 611;
      e3.oe = 944;
      e3.germandbls = 611;
      e3.Idieresis = 278;
      e3.eacute = 556;
      e3.abreve = 556;
      e3.uhungarumlaut = 556;
      e3.ecaron = 556;
      e3.Ydieresis = 667;
      e3.divide = 584;
      e3.Yacute = 667;
      e3.Acircumflex = 667;
      e3.aacute = 556;
      e3.Ucircumflex = 722;
      e3.yacute = 500;
      e3.scommaaccent = 500;
      e3.ecircumflex = 556;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 556;
      e3.Uacute = 722;
      e3.uogonek = 556;
      e3.Edieresis = 667;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 737;
      e3.Emacron = 667;
      e3.ccaron = 500;
      e3.aring = 556;
      e3.Ncommaaccent = 722;
      e3.lacute = 222;
      e3.agrave = 556;
      e3.Tcommaaccent = 611;
      e3.Cacute = 722;
      e3.atilde = 556;
      e3.Edotaccent = 667;
      e3.scaron = 500;
      e3.scedilla = 500;
      e3.iacute = 278;
      e3.lozenge = 471;
      e3.Rcaron = 722;
      e3.Gcommaaccent = 778;
      e3.ucircumflex = 556;
      e3.acircumflex = 556;
      e3.Amacron = 667;
      e3.rcaron = 333;
      e3.ccedilla = 500;
      e3.Zdotaccent = 611;
      e3.Thorn = 667;
      e3.Omacron = 778;
      e3.Racute = 722;
      e3.Sacute = 667;
      e3.dcaron = 643;
      e3.Umacron = 722;
      e3.uring = 556;
      e3.threesuperior = 333;
      e3.Ograve = 778;
      e3.Agrave = 667;
      e3.Abreve = 667;
      e3.multiply = 584;
      e3.uacute = 556;
      e3.Tcaron = 611;
      e3.partialdiff = 476;
      e3.ydieresis = 500;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 667;
      e3.adieresis = 556;
      e3.edieresis = 556;
      e3.cacute = 500;
      e3.nacute = 556;
      e3.umacron = 556;
      e3.Ncaron = 722;
      e3.Iacute = 278;
      e3.plusminus = 584;
      e3.brokenbar = 260;
      e3.registered = 737;
      e3.Gbreve = 778;
      e3.Idotaccent = 278;
      e3.summation = 600;
      e3.Egrave = 667;
      e3.racute = 333;
      e3.omacron = 556;
      e3.Zacute = 611;
      e3.Zcaron = 611;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 722;
      e3.lcommaaccent = 222;
      e3.tcaron = 317;
      e3.eogonek = 556;
      e3.Uogonek = 722;
      e3.Aacute = 667;
      e3.Adieresis = 667;
      e3.egrave = 556;
      e3.zacute = 500;
      e3.iogonek = 222;
      e3.Oacute = 778;
      e3.oacute = 556;
      e3.amacron = 556;
      e3.sacute = 500;
      e3.idieresis = 278;
      e3.Ocircumflex = 778;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 556;
      e3.twosuperior = 333;
      e3.Odieresis = 778;
      e3.mu = 556;
      e3.igrave = 278;
      e3.ohungarumlaut = 556;
      e3.Eogonek = 667;
      e3.dcroat = 556;
      e3.threequarters = 834;
      e3.Scedilla = 667;
      e3.lcaron = 299;
      e3.Kcommaaccent = 667;
      e3.Lacute = 556;
      e3.trademark = 1e3;
      e3.edotaccent = 556;
      e3.Igrave = 278;
      e3.Imacron = 278;
      e3.Lcaron = 556;
      e3.onehalf = 834;
      e3.lessequal = 549;
      e3.ocircumflex = 556;
      e3.ntilde = 556;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 667;
      e3.emacron = 556;
      e3.gbreve = 556;
      e3.onequarter = 834;
      e3.Scaron = 667;
      e3.Scommaaccent = 667;
      e3.Ohungarumlaut = 778;
      e3.degree = 400;
      e3.ograve = 556;
      e3.Ccaron = 722;
      e3.ugrave = 556;
      e3.radical = 453;
      e3.Dcaron = 722;
      e3.rcommaaccent = 333;
      e3.Ntilde = 722;
      e3.otilde = 556;
      e3.Rcommaaccent = 722;
      e3.Lcommaaccent = 556;
      e3.Atilde = 667;
      e3.Aogonek = 667;
      e3.Aring = 667;
      e3.Otilde = 778;
      e3.zdotaccent = 500;
      e3.Ecaron = 667;
      e3.Iogonek = 278;
      e3.kcommaaccent = 500;
      e3.minus = 584;
      e3.Icircumflex = 278;
      e3.ncaron = 556;
      e3.tcommaaccent = 278;
      e3.logicalnot = 584;
      e3.odieresis = 556;
      e3.udieresis = 556;
      e3.notequal = 549;
      e3.gcommaaccent = 556;
      e3.eth = 556;
      e3.zcaron = 500;
      e3.ncommaaccent = 556;
      e3.onesuperior = 333;
      e3.imacron = 278;
      e3.Euro = 556;
    });
    e2["Helvetica-Bold"] = getLookupTableFactory(function(e3) {
      e3.space = 278;
      e3.exclam = 333;
      e3.quotedbl = 474;
      e3.numbersign = 556;
      e3.dollar = 556;
      e3.percent = 889;
      e3.ampersand = 722;
      e3.quoteright = 278;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 389;
      e3.plus = 584;
      e3.comma = 278;
      e3.hyphen = 333;
      e3.period = 278;
      e3.slash = 278;
      e3.zero = 556;
      e3.one = 556;
      e3.two = 556;
      e3.three = 556;
      e3.four = 556;
      e3.five = 556;
      e3.six = 556;
      e3.seven = 556;
      e3.eight = 556;
      e3.nine = 556;
      e3.colon = 333;
      e3.semicolon = 333;
      e3.less = 584;
      e3.equal = 584;
      e3.greater = 584;
      e3.question = 611;
      e3.at = 975;
      e3.A = 722;
      e3.B = 722;
      e3.C = 722;
      e3.D = 722;
      e3.E = 667;
      e3.F = 611;
      e3.G = 778;
      e3.H = 722;
      e3.I = 278;
      e3.J = 556;
      e3.K = 722;
      e3.L = 611;
      e3.M = 833;
      e3.N = 722;
      e3.O = 778;
      e3.P = 667;
      e3.Q = 778;
      e3.R = 722;
      e3.S = 667;
      e3.T = 611;
      e3.U = 722;
      e3.V = 667;
      e3.W = 944;
      e3.X = 667;
      e3.Y = 667;
      e3.Z = 611;
      e3.bracketleft = 333;
      e3.backslash = 278;
      e3.bracketright = 333;
      e3.asciicircum = 584;
      e3.underscore = 556;
      e3.quoteleft = 278;
      e3.a = 556;
      e3.b = 611;
      e3.c = 556;
      e3.d = 611;
      e3.e = 556;
      e3.f = 333;
      e3.g = 611;
      e3.h = 611;
      e3.i = 278;
      e3.j = 278;
      e3.k = 556;
      e3.l = 278;
      e3.m = 889;
      e3.n = 611;
      e3.o = 611;
      e3.p = 611;
      e3.q = 611;
      e3.r = 389;
      e3.s = 556;
      e3.t = 333;
      e3.u = 611;
      e3.v = 556;
      e3.w = 778;
      e3.x = 556;
      e3.y = 556;
      e3.z = 500;
      e3.braceleft = 389;
      e3.bar = 280;
      e3.braceright = 389;
      e3.asciitilde = 584;
      e3.exclamdown = 333;
      e3.cent = 556;
      e3.sterling = 556;
      e3.fraction = 167;
      e3.yen = 556;
      e3.florin = 556;
      e3.section = 556;
      e3.currency = 556;
      e3.quotesingle = 238;
      e3.quotedblleft = 500;
      e3.guillemotleft = 556;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 611;
      e3.fl = 611;
      e3.endash = 556;
      e3.dagger = 556;
      e3.daggerdbl = 556;
      e3.periodcentered = 278;
      e3.paragraph = 556;
      e3.bullet = 350;
      e3.quotesinglbase = 278;
      e3.quotedblbase = 500;
      e3.quotedblright = 500;
      e3.guillemotright = 556;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 611;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 1e3;
      e3.ordfeminine = 370;
      e3.Lslash = 611;
      e3.Oslash = 778;
      e3.OE = 1e3;
      e3.ordmasculine = 365;
      e3.ae = 889;
      e3.dotlessi = 278;
      e3.lslash = 278;
      e3.oslash = 611;
      e3.oe = 944;
      e3.germandbls = 611;
      e3.Idieresis = 278;
      e3.eacute = 556;
      e3.abreve = 556;
      e3.uhungarumlaut = 611;
      e3.ecaron = 556;
      e3.Ydieresis = 667;
      e3.divide = 584;
      e3.Yacute = 667;
      e3.Acircumflex = 722;
      e3.aacute = 556;
      e3.Ucircumflex = 722;
      e3.yacute = 556;
      e3.scommaaccent = 556;
      e3.ecircumflex = 556;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 556;
      e3.Uacute = 722;
      e3.uogonek = 611;
      e3.Edieresis = 667;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 737;
      e3.Emacron = 667;
      e3.ccaron = 556;
      e3.aring = 556;
      e3.Ncommaaccent = 722;
      e3.lacute = 278;
      e3.agrave = 556;
      e3.Tcommaaccent = 611;
      e3.Cacute = 722;
      e3.atilde = 556;
      e3.Edotaccent = 667;
      e3.scaron = 556;
      e3.scedilla = 556;
      e3.iacute = 278;
      e3.lozenge = 494;
      e3.Rcaron = 722;
      e3.Gcommaaccent = 778;
      e3.ucircumflex = 611;
      e3.acircumflex = 556;
      e3.Amacron = 722;
      e3.rcaron = 389;
      e3.ccedilla = 556;
      e3.Zdotaccent = 611;
      e3.Thorn = 667;
      e3.Omacron = 778;
      e3.Racute = 722;
      e3.Sacute = 667;
      e3.dcaron = 743;
      e3.Umacron = 722;
      e3.uring = 611;
      e3.threesuperior = 333;
      e3.Ograve = 778;
      e3.Agrave = 722;
      e3.Abreve = 722;
      e3.multiply = 584;
      e3.uacute = 611;
      e3.Tcaron = 611;
      e3.partialdiff = 494;
      e3.ydieresis = 556;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 667;
      e3.adieresis = 556;
      e3.edieresis = 556;
      e3.cacute = 556;
      e3.nacute = 611;
      e3.umacron = 611;
      e3.Ncaron = 722;
      e3.Iacute = 278;
      e3.plusminus = 584;
      e3.brokenbar = 280;
      e3.registered = 737;
      e3.Gbreve = 778;
      e3.Idotaccent = 278;
      e3.summation = 600;
      e3.Egrave = 667;
      e3.racute = 389;
      e3.omacron = 611;
      e3.Zacute = 611;
      e3.Zcaron = 611;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 722;
      e3.lcommaaccent = 278;
      e3.tcaron = 389;
      e3.eogonek = 556;
      e3.Uogonek = 722;
      e3.Aacute = 722;
      e3.Adieresis = 722;
      e3.egrave = 556;
      e3.zacute = 500;
      e3.iogonek = 278;
      e3.Oacute = 778;
      e3.oacute = 611;
      e3.amacron = 556;
      e3.sacute = 556;
      e3.idieresis = 278;
      e3.Ocircumflex = 778;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 611;
      e3.twosuperior = 333;
      e3.Odieresis = 778;
      e3.mu = 611;
      e3.igrave = 278;
      e3.ohungarumlaut = 611;
      e3.Eogonek = 667;
      e3.dcroat = 611;
      e3.threequarters = 834;
      e3.Scedilla = 667;
      e3.lcaron = 400;
      e3.Kcommaaccent = 722;
      e3.Lacute = 611;
      e3.trademark = 1e3;
      e3.edotaccent = 556;
      e3.Igrave = 278;
      e3.Imacron = 278;
      e3.Lcaron = 611;
      e3.onehalf = 834;
      e3.lessequal = 549;
      e3.ocircumflex = 611;
      e3.ntilde = 611;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 667;
      e3.emacron = 556;
      e3.gbreve = 611;
      e3.onequarter = 834;
      e3.Scaron = 667;
      e3.Scommaaccent = 667;
      e3.Ohungarumlaut = 778;
      e3.degree = 400;
      e3.ograve = 611;
      e3.Ccaron = 722;
      e3.ugrave = 611;
      e3.radical = 549;
      e3.Dcaron = 722;
      e3.rcommaaccent = 389;
      e3.Ntilde = 722;
      e3.otilde = 611;
      e3.Rcommaaccent = 722;
      e3.Lcommaaccent = 611;
      e3.Atilde = 722;
      e3.Aogonek = 722;
      e3.Aring = 722;
      e3.Otilde = 778;
      e3.zdotaccent = 500;
      e3.Ecaron = 667;
      e3.Iogonek = 278;
      e3.kcommaaccent = 556;
      e3.minus = 584;
      e3.Icircumflex = 278;
      e3.ncaron = 611;
      e3.tcommaaccent = 333;
      e3.logicalnot = 584;
      e3.odieresis = 611;
      e3.udieresis = 611;
      e3.notequal = 549;
      e3.gcommaaccent = 611;
      e3.eth = 611;
      e3.zcaron = 500;
      e3.ncommaaccent = 611;
      e3.onesuperior = 333;
      e3.imacron = 278;
      e3.Euro = 556;
    });
    e2["Helvetica-BoldOblique"] = getLookupTableFactory(function(e3) {
      e3.space = 278;
      e3.exclam = 333;
      e3.quotedbl = 474;
      e3.numbersign = 556;
      e3.dollar = 556;
      e3.percent = 889;
      e3.ampersand = 722;
      e3.quoteright = 278;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 389;
      e3.plus = 584;
      e3.comma = 278;
      e3.hyphen = 333;
      e3.period = 278;
      e3.slash = 278;
      e3.zero = 556;
      e3.one = 556;
      e3.two = 556;
      e3.three = 556;
      e3.four = 556;
      e3.five = 556;
      e3.six = 556;
      e3.seven = 556;
      e3.eight = 556;
      e3.nine = 556;
      e3.colon = 333;
      e3.semicolon = 333;
      e3.less = 584;
      e3.equal = 584;
      e3.greater = 584;
      e3.question = 611;
      e3.at = 975;
      e3.A = 722;
      e3.B = 722;
      e3.C = 722;
      e3.D = 722;
      e3.E = 667;
      e3.F = 611;
      e3.G = 778;
      e3.H = 722;
      e3.I = 278;
      e3.J = 556;
      e3.K = 722;
      e3.L = 611;
      e3.M = 833;
      e3.N = 722;
      e3.O = 778;
      e3.P = 667;
      e3.Q = 778;
      e3.R = 722;
      e3.S = 667;
      e3.T = 611;
      e3.U = 722;
      e3.V = 667;
      e3.W = 944;
      e3.X = 667;
      e3.Y = 667;
      e3.Z = 611;
      e3.bracketleft = 333;
      e3.backslash = 278;
      e3.bracketright = 333;
      e3.asciicircum = 584;
      e3.underscore = 556;
      e3.quoteleft = 278;
      e3.a = 556;
      e3.b = 611;
      e3.c = 556;
      e3.d = 611;
      e3.e = 556;
      e3.f = 333;
      e3.g = 611;
      e3.h = 611;
      e3.i = 278;
      e3.j = 278;
      e3.k = 556;
      e3.l = 278;
      e3.m = 889;
      e3.n = 611;
      e3.o = 611;
      e3.p = 611;
      e3.q = 611;
      e3.r = 389;
      e3.s = 556;
      e3.t = 333;
      e3.u = 611;
      e3.v = 556;
      e3.w = 778;
      e3.x = 556;
      e3.y = 556;
      e3.z = 500;
      e3.braceleft = 389;
      e3.bar = 280;
      e3.braceright = 389;
      e3.asciitilde = 584;
      e3.exclamdown = 333;
      e3.cent = 556;
      e3.sterling = 556;
      e3.fraction = 167;
      e3.yen = 556;
      e3.florin = 556;
      e3.section = 556;
      e3.currency = 556;
      e3.quotesingle = 238;
      e3.quotedblleft = 500;
      e3.guillemotleft = 556;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 611;
      e3.fl = 611;
      e3.endash = 556;
      e3.dagger = 556;
      e3.daggerdbl = 556;
      e3.periodcentered = 278;
      e3.paragraph = 556;
      e3.bullet = 350;
      e3.quotesinglbase = 278;
      e3.quotedblbase = 500;
      e3.quotedblright = 500;
      e3.guillemotright = 556;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 611;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 1e3;
      e3.ordfeminine = 370;
      e3.Lslash = 611;
      e3.Oslash = 778;
      e3.OE = 1e3;
      e3.ordmasculine = 365;
      e3.ae = 889;
      e3.dotlessi = 278;
      e3.lslash = 278;
      e3.oslash = 611;
      e3.oe = 944;
      e3.germandbls = 611;
      e3.Idieresis = 278;
      e3.eacute = 556;
      e3.abreve = 556;
      e3.uhungarumlaut = 611;
      e3.ecaron = 556;
      e3.Ydieresis = 667;
      e3.divide = 584;
      e3.Yacute = 667;
      e3.Acircumflex = 722;
      e3.aacute = 556;
      e3.Ucircumflex = 722;
      e3.yacute = 556;
      e3.scommaaccent = 556;
      e3.ecircumflex = 556;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 556;
      e3.Uacute = 722;
      e3.uogonek = 611;
      e3.Edieresis = 667;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 737;
      e3.Emacron = 667;
      e3.ccaron = 556;
      e3.aring = 556;
      e3.Ncommaaccent = 722;
      e3.lacute = 278;
      e3.agrave = 556;
      e3.Tcommaaccent = 611;
      e3.Cacute = 722;
      e3.atilde = 556;
      e3.Edotaccent = 667;
      e3.scaron = 556;
      e3.scedilla = 556;
      e3.iacute = 278;
      e3.lozenge = 494;
      e3.Rcaron = 722;
      e3.Gcommaaccent = 778;
      e3.ucircumflex = 611;
      e3.acircumflex = 556;
      e3.Amacron = 722;
      e3.rcaron = 389;
      e3.ccedilla = 556;
      e3.Zdotaccent = 611;
      e3.Thorn = 667;
      e3.Omacron = 778;
      e3.Racute = 722;
      e3.Sacute = 667;
      e3.dcaron = 743;
      e3.Umacron = 722;
      e3.uring = 611;
      e3.threesuperior = 333;
      e3.Ograve = 778;
      e3.Agrave = 722;
      e3.Abreve = 722;
      e3.multiply = 584;
      e3.uacute = 611;
      e3.Tcaron = 611;
      e3.partialdiff = 494;
      e3.ydieresis = 556;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 667;
      e3.adieresis = 556;
      e3.edieresis = 556;
      e3.cacute = 556;
      e3.nacute = 611;
      e3.umacron = 611;
      e3.Ncaron = 722;
      e3.Iacute = 278;
      e3.plusminus = 584;
      e3.brokenbar = 280;
      e3.registered = 737;
      e3.Gbreve = 778;
      e3.Idotaccent = 278;
      e3.summation = 600;
      e3.Egrave = 667;
      e3.racute = 389;
      e3.omacron = 611;
      e3.Zacute = 611;
      e3.Zcaron = 611;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 722;
      e3.lcommaaccent = 278;
      e3.tcaron = 389;
      e3.eogonek = 556;
      e3.Uogonek = 722;
      e3.Aacute = 722;
      e3.Adieresis = 722;
      e3.egrave = 556;
      e3.zacute = 500;
      e3.iogonek = 278;
      e3.Oacute = 778;
      e3.oacute = 611;
      e3.amacron = 556;
      e3.sacute = 556;
      e3.idieresis = 278;
      e3.Ocircumflex = 778;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 611;
      e3.twosuperior = 333;
      e3.Odieresis = 778;
      e3.mu = 611;
      e3.igrave = 278;
      e3.ohungarumlaut = 611;
      e3.Eogonek = 667;
      e3.dcroat = 611;
      e3.threequarters = 834;
      e3.Scedilla = 667;
      e3.lcaron = 400;
      e3.Kcommaaccent = 722;
      e3.Lacute = 611;
      e3.trademark = 1e3;
      e3.edotaccent = 556;
      e3.Igrave = 278;
      e3.Imacron = 278;
      e3.Lcaron = 611;
      e3.onehalf = 834;
      e3.lessequal = 549;
      e3.ocircumflex = 611;
      e3.ntilde = 611;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 667;
      e3.emacron = 556;
      e3.gbreve = 611;
      e3.onequarter = 834;
      e3.Scaron = 667;
      e3.Scommaaccent = 667;
      e3.Ohungarumlaut = 778;
      e3.degree = 400;
      e3.ograve = 611;
      e3.Ccaron = 722;
      e3.ugrave = 611;
      e3.radical = 549;
      e3.Dcaron = 722;
      e3.rcommaaccent = 389;
      e3.Ntilde = 722;
      e3.otilde = 611;
      e3.Rcommaaccent = 722;
      e3.Lcommaaccent = 611;
      e3.Atilde = 722;
      e3.Aogonek = 722;
      e3.Aring = 722;
      e3.Otilde = 778;
      e3.zdotaccent = 500;
      e3.Ecaron = 667;
      e3.Iogonek = 278;
      e3.kcommaaccent = 556;
      e3.minus = 584;
      e3.Icircumflex = 278;
      e3.ncaron = 611;
      e3.tcommaaccent = 333;
      e3.logicalnot = 584;
      e3.odieresis = 611;
      e3.udieresis = 611;
      e3.notequal = 549;
      e3.gcommaaccent = 611;
      e3.eth = 611;
      e3.zcaron = 500;
      e3.ncommaaccent = 611;
      e3.onesuperior = 333;
      e3.imacron = 278;
      e3.Euro = 556;
    });
    e2["Helvetica-Oblique"] = getLookupTableFactory(function(e3) {
      e3.space = 278;
      e3.exclam = 278;
      e3.quotedbl = 355;
      e3.numbersign = 556;
      e3.dollar = 556;
      e3.percent = 889;
      e3.ampersand = 667;
      e3.quoteright = 222;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 389;
      e3.plus = 584;
      e3.comma = 278;
      e3.hyphen = 333;
      e3.period = 278;
      e3.slash = 278;
      e3.zero = 556;
      e3.one = 556;
      e3.two = 556;
      e3.three = 556;
      e3.four = 556;
      e3.five = 556;
      e3.six = 556;
      e3.seven = 556;
      e3.eight = 556;
      e3.nine = 556;
      e3.colon = 278;
      e3.semicolon = 278;
      e3.less = 584;
      e3.equal = 584;
      e3.greater = 584;
      e3.question = 556;
      e3.at = 1015;
      e3.A = 667;
      e3.B = 667;
      e3.C = 722;
      e3.D = 722;
      e3.E = 667;
      e3.F = 611;
      e3.G = 778;
      e3.H = 722;
      e3.I = 278;
      e3.J = 500;
      e3.K = 667;
      e3.L = 556;
      e3.M = 833;
      e3.N = 722;
      e3.O = 778;
      e3.P = 667;
      e3.Q = 778;
      e3.R = 722;
      e3.S = 667;
      e3.T = 611;
      e3.U = 722;
      e3.V = 667;
      e3.W = 944;
      e3.X = 667;
      e3.Y = 667;
      e3.Z = 611;
      e3.bracketleft = 278;
      e3.backslash = 278;
      e3.bracketright = 278;
      e3.asciicircum = 469;
      e3.underscore = 556;
      e3.quoteleft = 222;
      e3.a = 556;
      e3.b = 556;
      e3.c = 500;
      e3.d = 556;
      e3.e = 556;
      e3.f = 278;
      e3.g = 556;
      e3.h = 556;
      e3.i = 222;
      e3.j = 222;
      e3.k = 500;
      e3.l = 222;
      e3.m = 833;
      e3.n = 556;
      e3.o = 556;
      e3.p = 556;
      e3.q = 556;
      e3.r = 333;
      e3.s = 500;
      e3.t = 278;
      e3.u = 556;
      e3.v = 500;
      e3.w = 722;
      e3.x = 500;
      e3.y = 500;
      e3.z = 500;
      e3.braceleft = 334;
      e3.bar = 260;
      e3.braceright = 334;
      e3.asciitilde = 584;
      e3.exclamdown = 333;
      e3.cent = 556;
      e3.sterling = 556;
      e3.fraction = 167;
      e3.yen = 556;
      e3.florin = 556;
      e3.section = 556;
      e3.currency = 556;
      e3.quotesingle = 191;
      e3.quotedblleft = 333;
      e3.guillemotleft = 556;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 500;
      e3.fl = 500;
      e3.endash = 556;
      e3.dagger = 556;
      e3.daggerdbl = 556;
      e3.periodcentered = 278;
      e3.paragraph = 537;
      e3.bullet = 350;
      e3.quotesinglbase = 222;
      e3.quotedblbase = 333;
      e3.quotedblright = 333;
      e3.guillemotright = 556;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 611;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 1e3;
      e3.ordfeminine = 370;
      e3.Lslash = 556;
      e3.Oslash = 778;
      e3.OE = 1e3;
      e3.ordmasculine = 365;
      e3.ae = 889;
      e3.dotlessi = 278;
      e3.lslash = 222;
      e3.oslash = 611;
      e3.oe = 944;
      e3.germandbls = 611;
      e3.Idieresis = 278;
      e3.eacute = 556;
      e3.abreve = 556;
      e3.uhungarumlaut = 556;
      e3.ecaron = 556;
      e3.Ydieresis = 667;
      e3.divide = 584;
      e3.Yacute = 667;
      e3.Acircumflex = 667;
      e3.aacute = 556;
      e3.Ucircumflex = 722;
      e3.yacute = 500;
      e3.scommaaccent = 500;
      e3.ecircumflex = 556;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 556;
      e3.Uacute = 722;
      e3.uogonek = 556;
      e3.Edieresis = 667;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 737;
      e3.Emacron = 667;
      e3.ccaron = 500;
      e3.aring = 556;
      e3.Ncommaaccent = 722;
      e3.lacute = 222;
      e3.agrave = 556;
      e3.Tcommaaccent = 611;
      e3.Cacute = 722;
      e3.atilde = 556;
      e3.Edotaccent = 667;
      e3.scaron = 500;
      e3.scedilla = 500;
      e3.iacute = 278;
      e3.lozenge = 471;
      e3.Rcaron = 722;
      e3.Gcommaaccent = 778;
      e3.ucircumflex = 556;
      e3.acircumflex = 556;
      e3.Amacron = 667;
      e3.rcaron = 333;
      e3.ccedilla = 500;
      e3.Zdotaccent = 611;
      e3.Thorn = 667;
      e3.Omacron = 778;
      e3.Racute = 722;
      e3.Sacute = 667;
      e3.dcaron = 643;
      e3.Umacron = 722;
      e3.uring = 556;
      e3.threesuperior = 333;
      e3.Ograve = 778;
      e3.Agrave = 667;
      e3.Abreve = 667;
      e3.multiply = 584;
      e3.uacute = 556;
      e3.Tcaron = 611;
      e3.partialdiff = 476;
      e3.ydieresis = 500;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 667;
      e3.adieresis = 556;
      e3.edieresis = 556;
      e3.cacute = 500;
      e3.nacute = 556;
      e3.umacron = 556;
      e3.Ncaron = 722;
      e3.Iacute = 278;
      e3.plusminus = 584;
      e3.brokenbar = 260;
      e3.registered = 737;
      e3.Gbreve = 778;
      e3.Idotaccent = 278;
      e3.summation = 600;
      e3.Egrave = 667;
      e3.racute = 333;
      e3.omacron = 556;
      e3.Zacute = 611;
      e3.Zcaron = 611;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 722;
      e3.lcommaaccent = 222;
      e3.tcaron = 317;
      e3.eogonek = 556;
      e3.Uogonek = 722;
      e3.Aacute = 667;
      e3.Adieresis = 667;
      e3.egrave = 556;
      e3.zacute = 500;
      e3.iogonek = 222;
      e3.Oacute = 778;
      e3.oacute = 556;
      e3.amacron = 556;
      e3.sacute = 500;
      e3.idieresis = 278;
      e3.Ocircumflex = 778;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 556;
      e3.twosuperior = 333;
      e3.Odieresis = 778;
      e3.mu = 556;
      e3.igrave = 278;
      e3.ohungarumlaut = 556;
      e3.Eogonek = 667;
      e3.dcroat = 556;
      e3.threequarters = 834;
      e3.Scedilla = 667;
      e3.lcaron = 299;
      e3.Kcommaaccent = 667;
      e3.Lacute = 556;
      e3.trademark = 1e3;
      e3.edotaccent = 556;
      e3.Igrave = 278;
      e3.Imacron = 278;
      e3.Lcaron = 556;
      e3.onehalf = 834;
      e3.lessequal = 549;
      e3.ocircumflex = 556;
      e3.ntilde = 556;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 667;
      e3.emacron = 556;
      e3.gbreve = 556;
      e3.onequarter = 834;
      e3.Scaron = 667;
      e3.Scommaaccent = 667;
      e3.Ohungarumlaut = 778;
      e3.degree = 400;
      e3.ograve = 556;
      e3.Ccaron = 722;
      e3.ugrave = 556;
      e3.radical = 453;
      e3.Dcaron = 722;
      e3.rcommaaccent = 333;
      e3.Ntilde = 722;
      e3.otilde = 556;
      e3.Rcommaaccent = 722;
      e3.Lcommaaccent = 556;
      e3.Atilde = 667;
      e3.Aogonek = 667;
      e3.Aring = 667;
      e3.Otilde = 778;
      e3.zdotaccent = 500;
      e3.Ecaron = 667;
      e3.Iogonek = 278;
      e3.kcommaaccent = 500;
      e3.minus = 584;
      e3.Icircumflex = 278;
      e3.ncaron = 556;
      e3.tcommaaccent = 278;
      e3.logicalnot = 584;
      e3.odieresis = 556;
      e3.udieresis = 556;
      e3.notequal = 549;
      e3.gcommaaccent = 556;
      e3.eth = 556;
      e3.zcaron = 500;
      e3.ncommaaccent = 556;
      e3.onesuperior = 333;
      e3.imacron = 278;
      e3.Euro = 556;
    });
    e2.Symbol = getLookupTableFactory(function(e3) {
      e3.space = 250;
      e3.exclam = 333;
      e3.universal = 713;
      e3.numbersign = 500;
      e3.existential = 549;
      e3.percent = 833;
      e3.ampersand = 778;
      e3.suchthat = 439;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asteriskmath = 500;
      e3.plus = 549;
      e3.comma = 250;
      e3.minus = 549;
      e3.period = 250;
      e3.slash = 278;
      e3.zero = 500;
      e3.one = 500;
      e3.two = 500;
      e3.three = 500;
      e3.four = 500;
      e3.five = 500;
      e3.six = 500;
      e3.seven = 500;
      e3.eight = 500;
      e3.nine = 500;
      e3.colon = 278;
      e3.semicolon = 278;
      e3.less = 549;
      e3.equal = 549;
      e3.greater = 549;
      e3.question = 444;
      e3.congruent = 549;
      e3.Alpha = 722;
      e3.Beta = 667;
      e3.Chi = 722;
      e3.Delta = 612;
      e3.Epsilon = 611;
      e3.Phi = 763;
      e3.Gamma = 603;
      e3.Eta = 722;
      e3.Iota = 333;
      e3.theta1 = 631;
      e3.Kappa = 722;
      e3.Lambda = 686;
      e3.Mu = 889;
      e3.Nu = 722;
      e3.Omicron = 722;
      e3.Pi = 768;
      e3.Theta = 741;
      e3.Rho = 556;
      e3.Sigma = 592;
      e3.Tau = 611;
      e3.Upsilon = 690;
      e3.sigma1 = 439;
      e3.Omega = 768;
      e3.Xi = 645;
      e3.Psi = 795;
      e3.Zeta = 611;
      e3.bracketleft = 333;
      e3.therefore = 863;
      e3.bracketright = 333;
      e3.perpendicular = 658;
      e3.underscore = 500;
      e3.radicalex = 500;
      e3.alpha = 631;
      e3.beta = 549;
      e3.chi = 549;
      e3.delta = 494;
      e3.epsilon = 439;
      e3.phi = 521;
      e3.gamma = 411;
      e3.eta = 603;
      e3.iota = 329;
      e3.phi1 = 603;
      e3.kappa = 549;
      e3.lambda = 549;
      e3.mu = 576;
      e3.nu = 521;
      e3.omicron = 549;
      e3.pi = 549;
      e3.theta = 521;
      e3.rho = 549;
      e3.sigma = 603;
      e3.tau = 439;
      e3.upsilon = 576;
      e3.omega1 = 713;
      e3.omega = 686;
      e3.xi = 493;
      e3.psi = 686;
      e3.zeta = 494;
      e3.braceleft = 480;
      e3.bar = 200;
      e3.braceright = 480;
      e3.similar = 549;
      e3.Euro = 750;
      e3.Upsilon1 = 620;
      e3.minute = 247;
      e3.lessequal = 549;
      e3.fraction = 167;
      e3.infinity = 713;
      e3.florin = 500;
      e3.club = 753;
      e3.diamond = 753;
      e3.heart = 753;
      e3.spade = 753;
      e3.arrowboth = 1042;
      e3.arrowleft = 987;
      e3.arrowup = 603;
      e3.arrowright = 987;
      e3.arrowdown = 603;
      e3.degree = 400;
      e3.plusminus = 549;
      e3.second = 411;
      e3.greaterequal = 549;
      e3.multiply = 549;
      e3.proportional = 713;
      e3.partialdiff = 494;
      e3.bullet = 460;
      e3.divide = 549;
      e3.notequal = 549;
      e3.equivalence = 549;
      e3.approxequal = 549;
      e3.ellipsis = 1e3;
      e3.arrowvertex = 603;
      e3.arrowhorizex = 1e3;
      e3.carriagereturn = 658;
      e3.aleph = 823;
      e3.Ifraktur = 686;
      e3.Rfraktur = 795;
      e3.weierstrass = 987;
      e3.circlemultiply = 768;
      e3.circleplus = 768;
      e3.emptyset = 823;
      e3.intersection = 768;
      e3.union = 768;
      e3.propersuperset = 713;
      e3.reflexsuperset = 713;
      e3.notsubset = 713;
      e3.propersubset = 713;
      e3.reflexsubset = 713;
      e3.element = 713;
      e3.notelement = 713;
      e3.angle = 768;
      e3.gradient = 713;
      e3.registerserif = 790;
      e3.copyrightserif = 790;
      e3.trademarkserif = 890;
      e3.product = 823;
      e3.radical = 549;
      e3.dotmath = 250;
      e3.logicalnot = 713;
      e3.logicaland = 603;
      e3.logicalor = 603;
      e3.arrowdblboth = 1042;
      e3.arrowdblleft = 987;
      e3.arrowdblup = 603;
      e3.arrowdblright = 987;
      e3.arrowdbldown = 603;
      e3.lozenge = 494;
      e3.angleleft = 329;
      e3.registersans = 790;
      e3.copyrightsans = 790;
      e3.trademarksans = 786;
      e3.summation = 713;
      e3.parenlefttp = 384;
      e3.parenleftex = 384;
      e3.parenleftbt = 384;
      e3.bracketlefttp = 384;
      e3.bracketleftex = 384;
      e3.bracketleftbt = 384;
      e3.bracelefttp = 494;
      e3.braceleftmid = 494;
      e3.braceleftbt = 494;
      e3.braceex = 494;
      e3.angleright = 329;
      e3.integral = 274;
      e3.integraltp = 686;
      e3.integralex = 686;
      e3.integralbt = 686;
      e3.parenrighttp = 384;
      e3.parenrightex = 384;
      e3.parenrightbt = 384;
      e3.bracketrighttp = 384;
      e3.bracketrightex = 384;
      e3.bracketrightbt = 384;
      e3.bracerighttp = 494;
      e3.bracerightmid = 494;
      e3.bracerightbt = 494;
      e3.apple = 790;
    });
    e2["Times-Roman"] = getLookupTableFactory(function(e3) {
      e3.space = 250;
      e3.exclam = 333;
      e3.quotedbl = 408;
      e3.numbersign = 500;
      e3.dollar = 500;
      e3.percent = 833;
      e3.ampersand = 778;
      e3.quoteright = 333;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 500;
      e3.plus = 564;
      e3.comma = 250;
      e3.hyphen = 333;
      e3.period = 250;
      e3.slash = 278;
      e3.zero = 500;
      e3.one = 500;
      e3.two = 500;
      e3.three = 500;
      e3.four = 500;
      e3.five = 500;
      e3.six = 500;
      e3.seven = 500;
      e3.eight = 500;
      e3.nine = 500;
      e3.colon = 278;
      e3.semicolon = 278;
      e3.less = 564;
      e3.equal = 564;
      e3.greater = 564;
      e3.question = 444;
      e3.at = 921;
      e3.A = 722;
      e3.B = 667;
      e3.C = 667;
      e3.D = 722;
      e3.E = 611;
      e3.F = 556;
      e3.G = 722;
      e3.H = 722;
      e3.I = 333;
      e3.J = 389;
      e3.K = 722;
      e3.L = 611;
      e3.M = 889;
      e3.N = 722;
      e3.O = 722;
      e3.P = 556;
      e3.Q = 722;
      e3.R = 667;
      e3.S = 556;
      e3.T = 611;
      e3.U = 722;
      e3.V = 722;
      e3.W = 944;
      e3.X = 722;
      e3.Y = 722;
      e3.Z = 611;
      e3.bracketleft = 333;
      e3.backslash = 278;
      e3.bracketright = 333;
      e3.asciicircum = 469;
      e3.underscore = 500;
      e3.quoteleft = 333;
      e3.a = 444;
      e3.b = 500;
      e3.c = 444;
      e3.d = 500;
      e3.e = 444;
      e3.f = 333;
      e3.g = 500;
      e3.h = 500;
      e3.i = 278;
      e3.j = 278;
      e3.k = 500;
      e3.l = 278;
      e3.m = 778;
      e3.n = 500;
      e3.o = 500;
      e3.p = 500;
      e3.q = 500;
      e3.r = 333;
      e3.s = 389;
      e3.t = 278;
      e3.u = 500;
      e3.v = 500;
      e3.w = 722;
      e3.x = 500;
      e3.y = 500;
      e3.z = 444;
      e3.braceleft = 480;
      e3.bar = 200;
      e3.braceright = 480;
      e3.asciitilde = 541;
      e3.exclamdown = 333;
      e3.cent = 500;
      e3.sterling = 500;
      e3.fraction = 167;
      e3.yen = 500;
      e3.florin = 500;
      e3.section = 500;
      e3.currency = 500;
      e3.quotesingle = 180;
      e3.quotedblleft = 444;
      e3.guillemotleft = 500;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 556;
      e3.fl = 556;
      e3.endash = 500;
      e3.dagger = 500;
      e3.daggerdbl = 500;
      e3.periodcentered = 250;
      e3.paragraph = 453;
      e3.bullet = 350;
      e3.quotesinglbase = 333;
      e3.quotedblbase = 444;
      e3.quotedblright = 444;
      e3.guillemotright = 500;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 444;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 889;
      e3.ordfeminine = 276;
      e3.Lslash = 611;
      e3.Oslash = 722;
      e3.OE = 889;
      e3.ordmasculine = 310;
      e3.ae = 667;
      e3.dotlessi = 278;
      e3.lslash = 278;
      e3.oslash = 500;
      e3.oe = 722;
      e3.germandbls = 500;
      e3.Idieresis = 333;
      e3.eacute = 444;
      e3.abreve = 444;
      e3.uhungarumlaut = 500;
      e3.ecaron = 444;
      e3.Ydieresis = 722;
      e3.divide = 564;
      e3.Yacute = 722;
      e3.Acircumflex = 722;
      e3.aacute = 444;
      e3.Ucircumflex = 722;
      e3.yacute = 500;
      e3.scommaaccent = 389;
      e3.ecircumflex = 444;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 444;
      e3.Uacute = 722;
      e3.uogonek = 500;
      e3.Edieresis = 611;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 760;
      e3.Emacron = 611;
      e3.ccaron = 444;
      e3.aring = 444;
      e3.Ncommaaccent = 722;
      e3.lacute = 278;
      e3.agrave = 444;
      e3.Tcommaaccent = 611;
      e3.Cacute = 667;
      e3.atilde = 444;
      e3.Edotaccent = 611;
      e3.scaron = 389;
      e3.scedilla = 389;
      e3.iacute = 278;
      e3.lozenge = 471;
      e3.Rcaron = 667;
      e3.Gcommaaccent = 722;
      e3.ucircumflex = 500;
      e3.acircumflex = 444;
      e3.Amacron = 722;
      e3.rcaron = 333;
      e3.ccedilla = 444;
      e3.Zdotaccent = 611;
      e3.Thorn = 556;
      e3.Omacron = 722;
      e3.Racute = 667;
      e3.Sacute = 556;
      e3.dcaron = 588;
      e3.Umacron = 722;
      e3.uring = 500;
      e3.threesuperior = 300;
      e3.Ograve = 722;
      e3.Agrave = 722;
      e3.Abreve = 722;
      e3.multiply = 564;
      e3.uacute = 500;
      e3.Tcaron = 611;
      e3.partialdiff = 476;
      e3.ydieresis = 500;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 611;
      e3.adieresis = 444;
      e3.edieresis = 444;
      e3.cacute = 444;
      e3.nacute = 500;
      e3.umacron = 500;
      e3.Ncaron = 722;
      e3.Iacute = 333;
      e3.plusminus = 564;
      e3.brokenbar = 200;
      e3.registered = 760;
      e3.Gbreve = 722;
      e3.Idotaccent = 333;
      e3.summation = 600;
      e3.Egrave = 611;
      e3.racute = 333;
      e3.omacron = 500;
      e3.Zacute = 611;
      e3.Zcaron = 611;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 667;
      e3.lcommaaccent = 278;
      e3.tcaron = 326;
      e3.eogonek = 444;
      e3.Uogonek = 722;
      e3.Aacute = 722;
      e3.Adieresis = 722;
      e3.egrave = 444;
      e3.zacute = 444;
      e3.iogonek = 278;
      e3.Oacute = 722;
      e3.oacute = 500;
      e3.amacron = 444;
      e3.sacute = 389;
      e3.idieresis = 278;
      e3.Ocircumflex = 722;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 500;
      e3.twosuperior = 300;
      e3.Odieresis = 722;
      e3.mu = 500;
      e3.igrave = 278;
      e3.ohungarumlaut = 500;
      e3.Eogonek = 611;
      e3.dcroat = 500;
      e3.threequarters = 750;
      e3.Scedilla = 556;
      e3.lcaron = 344;
      e3.Kcommaaccent = 722;
      e3.Lacute = 611;
      e3.trademark = 980;
      e3.edotaccent = 444;
      e3.Igrave = 333;
      e3.Imacron = 333;
      e3.Lcaron = 611;
      e3.onehalf = 750;
      e3.lessequal = 549;
      e3.ocircumflex = 500;
      e3.ntilde = 500;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 611;
      e3.emacron = 444;
      e3.gbreve = 500;
      e3.onequarter = 750;
      e3.Scaron = 556;
      e3.Scommaaccent = 556;
      e3.Ohungarumlaut = 722;
      e3.degree = 400;
      e3.ograve = 500;
      e3.Ccaron = 667;
      e3.ugrave = 500;
      e3.radical = 453;
      e3.Dcaron = 722;
      e3.rcommaaccent = 333;
      e3.Ntilde = 722;
      e3.otilde = 500;
      e3.Rcommaaccent = 667;
      e3.Lcommaaccent = 611;
      e3.Atilde = 722;
      e3.Aogonek = 722;
      e3.Aring = 722;
      e3.Otilde = 722;
      e3.zdotaccent = 444;
      e3.Ecaron = 611;
      e3.Iogonek = 333;
      e3.kcommaaccent = 500;
      e3.minus = 564;
      e3.Icircumflex = 333;
      e3.ncaron = 500;
      e3.tcommaaccent = 278;
      e3.logicalnot = 564;
      e3.odieresis = 500;
      e3.udieresis = 500;
      e3.notequal = 549;
      e3.gcommaaccent = 500;
      e3.eth = 500;
      e3.zcaron = 444;
      e3.ncommaaccent = 500;
      e3.onesuperior = 300;
      e3.imacron = 278;
      e3.Euro = 500;
    });
    e2["Times-Bold"] = getLookupTableFactory(function(e3) {
      e3.space = 250;
      e3.exclam = 333;
      e3.quotedbl = 555;
      e3.numbersign = 500;
      e3.dollar = 500;
      e3.percent = 1e3;
      e3.ampersand = 833;
      e3.quoteright = 333;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 500;
      e3.plus = 570;
      e3.comma = 250;
      e3.hyphen = 333;
      e3.period = 250;
      e3.slash = 278;
      e3.zero = 500;
      e3.one = 500;
      e3.two = 500;
      e3.three = 500;
      e3.four = 500;
      e3.five = 500;
      e3.six = 500;
      e3.seven = 500;
      e3.eight = 500;
      e3.nine = 500;
      e3.colon = 333;
      e3.semicolon = 333;
      e3.less = 570;
      e3.equal = 570;
      e3.greater = 570;
      e3.question = 500;
      e3.at = 930;
      e3.A = 722;
      e3.B = 667;
      e3.C = 722;
      e3.D = 722;
      e3.E = 667;
      e3.F = 611;
      e3.G = 778;
      e3.H = 778;
      e3.I = 389;
      e3.J = 500;
      e3.K = 778;
      e3.L = 667;
      e3.M = 944;
      e3.N = 722;
      e3.O = 778;
      e3.P = 611;
      e3.Q = 778;
      e3.R = 722;
      e3.S = 556;
      e3.T = 667;
      e3.U = 722;
      e3.V = 722;
      e3.W = 1e3;
      e3.X = 722;
      e3.Y = 722;
      e3.Z = 667;
      e3.bracketleft = 333;
      e3.backslash = 278;
      e3.bracketright = 333;
      e3.asciicircum = 581;
      e3.underscore = 500;
      e3.quoteleft = 333;
      e3.a = 500;
      e3.b = 556;
      e3.c = 444;
      e3.d = 556;
      e3.e = 444;
      e3.f = 333;
      e3.g = 500;
      e3.h = 556;
      e3.i = 278;
      e3.j = 333;
      e3.k = 556;
      e3.l = 278;
      e3.m = 833;
      e3.n = 556;
      e3.o = 500;
      e3.p = 556;
      e3.q = 556;
      e3.r = 444;
      e3.s = 389;
      e3.t = 333;
      e3.u = 556;
      e3.v = 500;
      e3.w = 722;
      e3.x = 500;
      e3.y = 500;
      e3.z = 444;
      e3.braceleft = 394;
      e3.bar = 220;
      e3.braceright = 394;
      e3.asciitilde = 520;
      e3.exclamdown = 333;
      e3.cent = 500;
      e3.sterling = 500;
      e3.fraction = 167;
      e3.yen = 500;
      e3.florin = 500;
      e3.section = 500;
      e3.currency = 500;
      e3.quotesingle = 278;
      e3.quotedblleft = 500;
      e3.guillemotleft = 500;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 556;
      e3.fl = 556;
      e3.endash = 500;
      e3.dagger = 500;
      e3.daggerdbl = 500;
      e3.periodcentered = 250;
      e3.paragraph = 540;
      e3.bullet = 350;
      e3.quotesinglbase = 333;
      e3.quotedblbase = 500;
      e3.quotedblright = 500;
      e3.guillemotright = 500;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 500;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 1e3;
      e3.ordfeminine = 300;
      e3.Lslash = 667;
      e3.Oslash = 778;
      e3.OE = 1e3;
      e3.ordmasculine = 330;
      e3.ae = 722;
      e3.dotlessi = 278;
      e3.lslash = 278;
      e3.oslash = 500;
      e3.oe = 722;
      e3.germandbls = 556;
      e3.Idieresis = 389;
      e3.eacute = 444;
      e3.abreve = 500;
      e3.uhungarumlaut = 556;
      e3.ecaron = 444;
      e3.Ydieresis = 722;
      e3.divide = 570;
      e3.Yacute = 722;
      e3.Acircumflex = 722;
      e3.aacute = 500;
      e3.Ucircumflex = 722;
      e3.yacute = 500;
      e3.scommaaccent = 389;
      e3.ecircumflex = 444;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 500;
      e3.Uacute = 722;
      e3.uogonek = 556;
      e3.Edieresis = 667;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 747;
      e3.Emacron = 667;
      e3.ccaron = 444;
      e3.aring = 500;
      e3.Ncommaaccent = 722;
      e3.lacute = 278;
      e3.agrave = 500;
      e3.Tcommaaccent = 667;
      e3.Cacute = 722;
      e3.atilde = 500;
      e3.Edotaccent = 667;
      e3.scaron = 389;
      e3.scedilla = 389;
      e3.iacute = 278;
      e3.lozenge = 494;
      e3.Rcaron = 722;
      e3.Gcommaaccent = 778;
      e3.ucircumflex = 556;
      e3.acircumflex = 500;
      e3.Amacron = 722;
      e3.rcaron = 444;
      e3.ccedilla = 444;
      e3.Zdotaccent = 667;
      e3.Thorn = 611;
      e3.Omacron = 778;
      e3.Racute = 722;
      e3.Sacute = 556;
      e3.dcaron = 672;
      e3.Umacron = 722;
      e3.uring = 556;
      e3.threesuperior = 300;
      e3.Ograve = 778;
      e3.Agrave = 722;
      e3.Abreve = 722;
      e3.multiply = 570;
      e3.uacute = 556;
      e3.Tcaron = 667;
      e3.partialdiff = 494;
      e3.ydieresis = 500;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 667;
      e3.adieresis = 500;
      e3.edieresis = 444;
      e3.cacute = 444;
      e3.nacute = 556;
      e3.umacron = 556;
      e3.Ncaron = 722;
      e3.Iacute = 389;
      e3.plusminus = 570;
      e3.brokenbar = 220;
      e3.registered = 747;
      e3.Gbreve = 778;
      e3.Idotaccent = 389;
      e3.summation = 600;
      e3.Egrave = 667;
      e3.racute = 444;
      e3.omacron = 500;
      e3.Zacute = 667;
      e3.Zcaron = 667;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 722;
      e3.lcommaaccent = 278;
      e3.tcaron = 416;
      e3.eogonek = 444;
      e3.Uogonek = 722;
      e3.Aacute = 722;
      e3.Adieresis = 722;
      e3.egrave = 444;
      e3.zacute = 444;
      e3.iogonek = 278;
      e3.Oacute = 778;
      e3.oacute = 500;
      e3.amacron = 500;
      e3.sacute = 389;
      e3.idieresis = 278;
      e3.Ocircumflex = 778;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 556;
      e3.twosuperior = 300;
      e3.Odieresis = 778;
      e3.mu = 556;
      e3.igrave = 278;
      e3.ohungarumlaut = 500;
      e3.Eogonek = 667;
      e3.dcroat = 556;
      e3.threequarters = 750;
      e3.Scedilla = 556;
      e3.lcaron = 394;
      e3.Kcommaaccent = 778;
      e3.Lacute = 667;
      e3.trademark = 1e3;
      e3.edotaccent = 444;
      e3.Igrave = 389;
      e3.Imacron = 389;
      e3.Lcaron = 667;
      e3.onehalf = 750;
      e3.lessequal = 549;
      e3.ocircumflex = 500;
      e3.ntilde = 556;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 667;
      e3.emacron = 444;
      e3.gbreve = 500;
      e3.onequarter = 750;
      e3.Scaron = 556;
      e3.Scommaaccent = 556;
      e3.Ohungarumlaut = 778;
      e3.degree = 400;
      e3.ograve = 500;
      e3.Ccaron = 722;
      e3.ugrave = 556;
      e3.radical = 549;
      e3.Dcaron = 722;
      e3.rcommaaccent = 444;
      e3.Ntilde = 722;
      e3.otilde = 500;
      e3.Rcommaaccent = 722;
      e3.Lcommaaccent = 667;
      e3.Atilde = 722;
      e3.Aogonek = 722;
      e3.Aring = 722;
      e3.Otilde = 778;
      e3.zdotaccent = 444;
      e3.Ecaron = 667;
      e3.Iogonek = 389;
      e3.kcommaaccent = 556;
      e3.minus = 570;
      e3.Icircumflex = 389;
      e3.ncaron = 556;
      e3.tcommaaccent = 333;
      e3.logicalnot = 570;
      e3.odieresis = 500;
      e3.udieresis = 556;
      e3.notequal = 549;
      e3.gcommaaccent = 500;
      e3.eth = 500;
      e3.zcaron = 444;
      e3.ncommaaccent = 556;
      e3.onesuperior = 300;
      e3.imacron = 278;
      e3.Euro = 500;
    });
    e2["Times-BoldItalic"] = getLookupTableFactory(function(e3) {
      e3.space = 250;
      e3.exclam = 389;
      e3.quotedbl = 555;
      e3.numbersign = 500;
      e3.dollar = 500;
      e3.percent = 833;
      e3.ampersand = 778;
      e3.quoteright = 333;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 500;
      e3.plus = 570;
      e3.comma = 250;
      e3.hyphen = 333;
      e3.period = 250;
      e3.slash = 278;
      e3.zero = 500;
      e3.one = 500;
      e3.two = 500;
      e3.three = 500;
      e3.four = 500;
      e3.five = 500;
      e3.six = 500;
      e3.seven = 500;
      e3.eight = 500;
      e3.nine = 500;
      e3.colon = 333;
      e3.semicolon = 333;
      e3.less = 570;
      e3.equal = 570;
      e3.greater = 570;
      e3.question = 500;
      e3.at = 832;
      e3.A = 667;
      e3.B = 667;
      e3.C = 667;
      e3.D = 722;
      e3.E = 667;
      e3.F = 667;
      e3.G = 722;
      e3.H = 778;
      e3.I = 389;
      e3.J = 500;
      e3.K = 667;
      e3.L = 611;
      e3.M = 889;
      e3.N = 722;
      e3.O = 722;
      e3.P = 611;
      e3.Q = 722;
      e3.R = 667;
      e3.S = 556;
      e3.T = 611;
      e3.U = 722;
      e3.V = 667;
      e3.W = 889;
      e3.X = 667;
      e3.Y = 611;
      e3.Z = 611;
      e3.bracketleft = 333;
      e3.backslash = 278;
      e3.bracketright = 333;
      e3.asciicircum = 570;
      e3.underscore = 500;
      e3.quoteleft = 333;
      e3.a = 500;
      e3.b = 500;
      e3.c = 444;
      e3.d = 500;
      e3.e = 444;
      e3.f = 333;
      e3.g = 500;
      e3.h = 556;
      e3.i = 278;
      e3.j = 278;
      e3.k = 500;
      e3.l = 278;
      e3.m = 778;
      e3.n = 556;
      e3.o = 500;
      e3.p = 500;
      e3.q = 500;
      e3.r = 389;
      e3.s = 389;
      e3.t = 278;
      e3.u = 556;
      e3.v = 444;
      e3.w = 667;
      e3.x = 500;
      e3.y = 444;
      e3.z = 389;
      e3.braceleft = 348;
      e3.bar = 220;
      e3.braceright = 348;
      e3.asciitilde = 570;
      e3.exclamdown = 389;
      e3.cent = 500;
      e3.sterling = 500;
      e3.fraction = 167;
      e3.yen = 500;
      e3.florin = 500;
      e3.section = 500;
      e3.currency = 500;
      e3.quotesingle = 278;
      e3.quotedblleft = 500;
      e3.guillemotleft = 500;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 556;
      e3.fl = 556;
      e3.endash = 500;
      e3.dagger = 500;
      e3.daggerdbl = 500;
      e3.periodcentered = 250;
      e3.paragraph = 500;
      e3.bullet = 350;
      e3.quotesinglbase = 333;
      e3.quotedblbase = 500;
      e3.quotedblright = 500;
      e3.guillemotright = 500;
      e3.ellipsis = 1e3;
      e3.perthousand = 1e3;
      e3.questiondown = 500;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 1e3;
      e3.AE = 944;
      e3.ordfeminine = 266;
      e3.Lslash = 611;
      e3.Oslash = 722;
      e3.OE = 944;
      e3.ordmasculine = 300;
      e3.ae = 722;
      e3.dotlessi = 278;
      e3.lslash = 278;
      e3.oslash = 500;
      e3.oe = 722;
      e3.germandbls = 500;
      e3.Idieresis = 389;
      e3.eacute = 444;
      e3.abreve = 500;
      e3.uhungarumlaut = 556;
      e3.ecaron = 444;
      e3.Ydieresis = 611;
      e3.divide = 570;
      e3.Yacute = 611;
      e3.Acircumflex = 667;
      e3.aacute = 500;
      e3.Ucircumflex = 722;
      e3.yacute = 444;
      e3.scommaaccent = 389;
      e3.ecircumflex = 444;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 500;
      e3.Uacute = 722;
      e3.uogonek = 556;
      e3.Edieresis = 667;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 747;
      e3.Emacron = 667;
      e3.ccaron = 444;
      e3.aring = 500;
      e3.Ncommaaccent = 722;
      e3.lacute = 278;
      e3.agrave = 500;
      e3.Tcommaaccent = 611;
      e3.Cacute = 667;
      e3.atilde = 500;
      e3.Edotaccent = 667;
      e3.scaron = 389;
      e3.scedilla = 389;
      e3.iacute = 278;
      e3.lozenge = 494;
      e3.Rcaron = 667;
      e3.Gcommaaccent = 722;
      e3.ucircumflex = 556;
      e3.acircumflex = 500;
      e3.Amacron = 667;
      e3.rcaron = 389;
      e3.ccedilla = 444;
      e3.Zdotaccent = 611;
      e3.Thorn = 611;
      e3.Omacron = 722;
      e3.Racute = 667;
      e3.Sacute = 556;
      e3.dcaron = 608;
      e3.Umacron = 722;
      e3.uring = 556;
      e3.threesuperior = 300;
      e3.Ograve = 722;
      e3.Agrave = 667;
      e3.Abreve = 667;
      e3.multiply = 570;
      e3.uacute = 556;
      e3.Tcaron = 611;
      e3.partialdiff = 494;
      e3.ydieresis = 444;
      e3.Nacute = 722;
      e3.icircumflex = 278;
      e3.Ecircumflex = 667;
      e3.adieresis = 500;
      e3.edieresis = 444;
      e3.cacute = 444;
      e3.nacute = 556;
      e3.umacron = 556;
      e3.Ncaron = 722;
      e3.Iacute = 389;
      e3.plusminus = 570;
      e3.brokenbar = 220;
      e3.registered = 747;
      e3.Gbreve = 722;
      e3.Idotaccent = 389;
      e3.summation = 600;
      e3.Egrave = 667;
      e3.racute = 389;
      e3.omacron = 500;
      e3.Zacute = 611;
      e3.Zcaron = 611;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 667;
      e3.lcommaaccent = 278;
      e3.tcaron = 366;
      e3.eogonek = 444;
      e3.Uogonek = 722;
      e3.Aacute = 667;
      e3.Adieresis = 667;
      e3.egrave = 444;
      e3.zacute = 389;
      e3.iogonek = 278;
      e3.Oacute = 722;
      e3.oacute = 500;
      e3.amacron = 500;
      e3.sacute = 389;
      e3.idieresis = 278;
      e3.Ocircumflex = 722;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 500;
      e3.twosuperior = 300;
      e3.Odieresis = 722;
      e3.mu = 576;
      e3.igrave = 278;
      e3.ohungarumlaut = 500;
      e3.Eogonek = 667;
      e3.dcroat = 500;
      e3.threequarters = 750;
      e3.Scedilla = 556;
      e3.lcaron = 382;
      e3.Kcommaaccent = 667;
      e3.Lacute = 611;
      e3.trademark = 1e3;
      e3.edotaccent = 444;
      e3.Igrave = 389;
      e3.Imacron = 389;
      e3.Lcaron = 611;
      e3.onehalf = 750;
      e3.lessequal = 549;
      e3.ocircumflex = 500;
      e3.ntilde = 556;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 667;
      e3.emacron = 444;
      e3.gbreve = 500;
      e3.onequarter = 750;
      e3.Scaron = 556;
      e3.Scommaaccent = 556;
      e3.Ohungarumlaut = 722;
      e3.degree = 400;
      e3.ograve = 500;
      e3.Ccaron = 667;
      e3.ugrave = 556;
      e3.radical = 549;
      e3.Dcaron = 722;
      e3.rcommaaccent = 389;
      e3.Ntilde = 722;
      e3.otilde = 500;
      e3.Rcommaaccent = 667;
      e3.Lcommaaccent = 611;
      e3.Atilde = 667;
      e3.Aogonek = 667;
      e3.Aring = 667;
      e3.Otilde = 722;
      e3.zdotaccent = 389;
      e3.Ecaron = 667;
      e3.Iogonek = 389;
      e3.kcommaaccent = 500;
      e3.minus = 606;
      e3.Icircumflex = 389;
      e3.ncaron = 556;
      e3.tcommaaccent = 278;
      e3.logicalnot = 606;
      e3.odieresis = 500;
      e3.udieresis = 556;
      e3.notequal = 549;
      e3.gcommaaccent = 500;
      e3.eth = 500;
      e3.zcaron = 389;
      e3.ncommaaccent = 556;
      e3.onesuperior = 300;
      e3.imacron = 278;
      e3.Euro = 500;
    });
    e2["Times-Italic"] = getLookupTableFactory(function(e3) {
      e3.space = 250;
      e3.exclam = 333;
      e3.quotedbl = 420;
      e3.numbersign = 500;
      e3.dollar = 500;
      e3.percent = 833;
      e3.ampersand = 778;
      e3.quoteright = 333;
      e3.parenleft = 333;
      e3.parenright = 333;
      e3.asterisk = 500;
      e3.plus = 675;
      e3.comma = 250;
      e3.hyphen = 333;
      e3.period = 250;
      e3.slash = 278;
      e3.zero = 500;
      e3.one = 500;
      e3.two = 500;
      e3.three = 500;
      e3.four = 500;
      e3.five = 500;
      e3.six = 500;
      e3.seven = 500;
      e3.eight = 500;
      e3.nine = 500;
      e3.colon = 333;
      e3.semicolon = 333;
      e3.less = 675;
      e3.equal = 675;
      e3.greater = 675;
      e3.question = 500;
      e3.at = 920;
      e3.A = 611;
      e3.B = 611;
      e3.C = 667;
      e3.D = 722;
      e3.E = 611;
      e3.F = 611;
      e3.G = 722;
      e3.H = 722;
      e3.I = 333;
      e3.J = 444;
      e3.K = 667;
      e3.L = 556;
      e3.M = 833;
      e3.N = 667;
      e3.O = 722;
      e3.P = 611;
      e3.Q = 722;
      e3.R = 611;
      e3.S = 500;
      e3.T = 556;
      e3.U = 722;
      e3.V = 611;
      e3.W = 833;
      e3.X = 611;
      e3.Y = 556;
      e3.Z = 556;
      e3.bracketleft = 389;
      e3.backslash = 278;
      e3.bracketright = 389;
      e3.asciicircum = 422;
      e3.underscore = 500;
      e3.quoteleft = 333;
      e3.a = 500;
      e3.b = 500;
      e3.c = 444;
      e3.d = 500;
      e3.e = 444;
      e3.f = 278;
      e3.g = 500;
      e3.h = 500;
      e3.i = 278;
      e3.j = 278;
      e3.k = 444;
      e3.l = 278;
      e3.m = 722;
      e3.n = 500;
      e3.o = 500;
      e3.p = 500;
      e3.q = 500;
      e3.r = 389;
      e3.s = 389;
      e3.t = 278;
      e3.u = 500;
      e3.v = 444;
      e3.w = 667;
      e3.x = 444;
      e3.y = 444;
      e3.z = 389;
      e3.braceleft = 400;
      e3.bar = 275;
      e3.braceright = 400;
      e3.asciitilde = 541;
      e3.exclamdown = 389;
      e3.cent = 500;
      e3.sterling = 500;
      e3.fraction = 167;
      e3.yen = 500;
      e3.florin = 500;
      e3.section = 500;
      e3.currency = 500;
      e3.quotesingle = 214;
      e3.quotedblleft = 556;
      e3.guillemotleft = 500;
      e3.guilsinglleft = 333;
      e3.guilsinglright = 333;
      e3.fi = 500;
      e3.fl = 500;
      e3.endash = 500;
      e3.dagger = 500;
      e3.daggerdbl = 500;
      e3.periodcentered = 250;
      e3.paragraph = 523;
      e3.bullet = 350;
      e3.quotesinglbase = 333;
      e3.quotedblbase = 556;
      e3.quotedblright = 556;
      e3.guillemotright = 500;
      e3.ellipsis = 889;
      e3.perthousand = 1e3;
      e3.questiondown = 500;
      e3.grave = 333;
      e3.acute = 333;
      e3.circumflex = 333;
      e3.tilde = 333;
      e3.macron = 333;
      e3.breve = 333;
      e3.dotaccent = 333;
      e3.dieresis = 333;
      e3.ring = 333;
      e3.cedilla = 333;
      e3.hungarumlaut = 333;
      e3.ogonek = 333;
      e3.caron = 333;
      e3.emdash = 889;
      e3.AE = 889;
      e3.ordfeminine = 276;
      e3.Lslash = 556;
      e3.Oslash = 722;
      e3.OE = 944;
      e3.ordmasculine = 310;
      e3.ae = 667;
      e3.dotlessi = 278;
      e3.lslash = 278;
      e3.oslash = 500;
      e3.oe = 667;
      e3.germandbls = 500;
      e3.Idieresis = 333;
      e3.eacute = 444;
      e3.abreve = 500;
      e3.uhungarumlaut = 500;
      e3.ecaron = 444;
      e3.Ydieresis = 556;
      e3.divide = 675;
      e3.Yacute = 556;
      e3.Acircumflex = 611;
      e3.aacute = 500;
      e3.Ucircumflex = 722;
      e3.yacute = 444;
      e3.scommaaccent = 389;
      e3.ecircumflex = 444;
      e3.Uring = 722;
      e3.Udieresis = 722;
      e3.aogonek = 500;
      e3.Uacute = 722;
      e3.uogonek = 500;
      e3.Edieresis = 611;
      e3.Dcroat = 722;
      e3.commaaccent = 250;
      e3.copyright = 760;
      e3.Emacron = 611;
      e3.ccaron = 444;
      e3.aring = 500;
      e3.Ncommaaccent = 667;
      e3.lacute = 278;
      e3.agrave = 500;
      e3.Tcommaaccent = 556;
      e3.Cacute = 667;
      e3.atilde = 500;
      e3.Edotaccent = 611;
      e3.scaron = 389;
      e3.scedilla = 389;
      e3.iacute = 278;
      e3.lozenge = 471;
      e3.Rcaron = 611;
      e3.Gcommaaccent = 722;
      e3.ucircumflex = 500;
      e3.acircumflex = 500;
      e3.Amacron = 611;
      e3.rcaron = 389;
      e3.ccedilla = 444;
      e3.Zdotaccent = 556;
      e3.Thorn = 611;
      e3.Omacron = 722;
      e3.Racute = 611;
      e3.Sacute = 500;
      e3.dcaron = 544;
      e3.Umacron = 722;
      e3.uring = 500;
      e3.threesuperior = 300;
      e3.Ograve = 722;
      e3.Agrave = 611;
      e3.Abreve = 611;
      e3.multiply = 675;
      e3.uacute = 500;
      e3.Tcaron = 556;
      e3.partialdiff = 476;
      e3.ydieresis = 444;
      e3.Nacute = 667;
      e3.icircumflex = 278;
      e3.Ecircumflex = 611;
      e3.adieresis = 500;
      e3.edieresis = 444;
      e3.cacute = 444;
      e3.nacute = 500;
      e3.umacron = 500;
      e3.Ncaron = 667;
      e3.Iacute = 333;
      e3.plusminus = 675;
      e3.brokenbar = 275;
      e3.registered = 760;
      e3.Gbreve = 722;
      e3.Idotaccent = 333;
      e3.summation = 600;
      e3.Egrave = 611;
      e3.racute = 389;
      e3.omacron = 500;
      e3.Zacute = 556;
      e3.Zcaron = 556;
      e3.greaterequal = 549;
      e3.Eth = 722;
      e3.Ccedilla = 667;
      e3.lcommaaccent = 278;
      e3.tcaron = 300;
      e3.eogonek = 444;
      e3.Uogonek = 722;
      e3.Aacute = 611;
      e3.Adieresis = 611;
      e3.egrave = 444;
      e3.zacute = 389;
      e3.iogonek = 278;
      e3.Oacute = 722;
      e3.oacute = 500;
      e3.amacron = 500;
      e3.sacute = 389;
      e3.idieresis = 278;
      e3.Ocircumflex = 722;
      e3.Ugrave = 722;
      e3.Delta = 612;
      e3.thorn = 500;
      e3.twosuperior = 300;
      e3.Odieresis = 722;
      e3.mu = 500;
      e3.igrave = 278;
      e3.ohungarumlaut = 500;
      e3.Eogonek = 611;
      e3.dcroat = 500;
      e3.threequarters = 750;
      e3.Scedilla = 500;
      e3.lcaron = 300;
      e3.Kcommaaccent = 667;
      e3.Lacute = 556;
      e3.trademark = 980;
      e3.edotaccent = 444;
      e3.Igrave = 333;
      e3.Imacron = 333;
      e3.Lcaron = 611;
      e3.onehalf = 750;
      e3.lessequal = 549;
      e3.ocircumflex = 500;
      e3.ntilde = 500;
      e3.Uhungarumlaut = 722;
      e3.Eacute = 611;
      e3.emacron = 444;
      e3.gbreve = 500;
      e3.onequarter = 750;
      e3.Scaron = 500;
      e3.Scommaaccent = 500;
      e3.Ohungarumlaut = 722;
      e3.degree = 400;
      e3.ograve = 500;
      e3.Ccaron = 667;
      e3.ugrave = 500;
      e3.radical = 453;
      e3.Dcaron = 722;
      e3.rcommaaccent = 389;
      e3.Ntilde = 667;
      e3.otilde = 500;
      e3.Rcommaaccent = 611;
      e3.Lcommaaccent = 556;
      e3.Atilde = 611;
      e3.Aogonek = 611;
      e3.Aring = 611;
      e3.Otilde = 722;
      e3.zdotaccent = 389;
      e3.Ecaron = 611;
      e3.Iogonek = 333;
      e3.kcommaaccent = 444;
      e3.minus = 675;
      e3.Icircumflex = 333;
      e3.ncaron = 500;
      e3.tcommaaccent = 278;
      e3.logicalnot = 675;
      e3.odieresis = 500;
      e3.udieresis = 500;
      e3.notequal = 549;
      e3.gcommaaccent = 500;
      e3.eth = 500;
      e3.zcaron = 389;
      e3.ncommaaccent = 500;
      e3.onesuperior = 300;
      e3.imacron = 278;
      e3.Euro = 500;
    });
    e2.ZapfDingbats = getLookupTableFactory(function(e3) {
      e3.space = 278;
      e3.a1 = 974;
      e3.a2 = 961;
      e3.a202 = 974;
      e3.a3 = 980;
      e3.a4 = 719;
      e3.a5 = 789;
      e3.a119 = 790;
      e3.a118 = 791;
      e3.a117 = 690;
      e3.a11 = 960;
      e3.a12 = 939;
      e3.a13 = 549;
      e3.a14 = 855;
      e3.a15 = 911;
      e3.a16 = 933;
      e3.a105 = 911;
      e3.a17 = 945;
      e3.a18 = 974;
      e3.a19 = 755;
      e3.a20 = 846;
      e3.a21 = 762;
      e3.a22 = 761;
      e3.a23 = 571;
      e3.a24 = 677;
      e3.a25 = 763;
      e3.a26 = 760;
      e3.a27 = 759;
      e3.a28 = 754;
      e3.a6 = 494;
      e3.a7 = 552;
      e3.a8 = 537;
      e3.a9 = 577;
      e3.a10 = 692;
      e3.a29 = 786;
      e3.a30 = 788;
      e3.a31 = 788;
      e3.a32 = 790;
      e3.a33 = 793;
      e3.a34 = 794;
      e3.a35 = 816;
      e3.a36 = 823;
      e3.a37 = 789;
      e3.a38 = 841;
      e3.a39 = 823;
      e3.a40 = 833;
      e3.a41 = 816;
      e3.a42 = 831;
      e3.a43 = 923;
      e3.a44 = 744;
      e3.a45 = 723;
      e3.a46 = 749;
      e3.a47 = 790;
      e3.a48 = 792;
      e3.a49 = 695;
      e3.a50 = 776;
      e3.a51 = 768;
      e3.a52 = 792;
      e3.a53 = 759;
      e3.a54 = 707;
      e3.a55 = 708;
      e3.a56 = 682;
      e3.a57 = 701;
      e3.a58 = 826;
      e3.a59 = 815;
      e3.a60 = 789;
      e3.a61 = 789;
      e3.a62 = 707;
      e3.a63 = 687;
      e3.a64 = 696;
      e3.a65 = 689;
      e3.a66 = 786;
      e3.a67 = 787;
      e3.a68 = 713;
      e3.a69 = 791;
      e3.a70 = 785;
      e3.a71 = 791;
      e3.a72 = 873;
      e3.a73 = 761;
      e3.a74 = 762;
      e3.a203 = 762;
      e3.a75 = 759;
      e3.a204 = 759;
      e3.a76 = 892;
      e3.a77 = 892;
      e3.a78 = 788;
      e3.a79 = 784;
      e3.a81 = 438;
      e3.a82 = 138;
      e3.a83 = 277;
      e3.a84 = 415;
      e3.a97 = 392;
      e3.a98 = 392;
      e3.a99 = 668;
      e3.a100 = 668;
      e3.a89 = 390;
      e3.a90 = 390;
      e3.a93 = 317;
      e3.a94 = 317;
      e3.a91 = 276;
      e3.a92 = 276;
      e3.a205 = 509;
      e3.a85 = 509;
      e3.a206 = 410;
      e3.a86 = 410;
      e3.a87 = 234;
      e3.a88 = 234;
      e3.a95 = 334;
      e3.a96 = 334;
      e3.a101 = 732;
      e3.a102 = 544;
      e3.a103 = 544;
      e3.a104 = 910;
      e3.a106 = 667;
      e3.a107 = 760;
      e3.a108 = 760;
      e3.a112 = 776;
      e3.a111 = 595;
      e3.a110 = 694;
      e3.a109 = 626;
      e3.a120 = 788;
      e3.a121 = 788;
      e3.a122 = 788;
      e3.a123 = 788;
      e3.a124 = 788;
      e3.a125 = 788;
      e3.a126 = 788;
      e3.a127 = 788;
      e3.a128 = 788;
      e3.a129 = 788;
      e3.a130 = 788;
      e3.a131 = 788;
      e3.a132 = 788;
      e3.a133 = 788;
      e3.a134 = 788;
      e3.a135 = 788;
      e3.a136 = 788;
      e3.a137 = 788;
      e3.a138 = 788;
      e3.a139 = 788;
      e3.a140 = 788;
      e3.a141 = 788;
      e3.a142 = 788;
      e3.a143 = 788;
      e3.a144 = 788;
      e3.a145 = 788;
      e3.a146 = 788;
      e3.a147 = 788;
      e3.a148 = 788;
      e3.a149 = 788;
      e3.a150 = 788;
      e3.a151 = 788;
      e3.a152 = 788;
      e3.a153 = 788;
      e3.a154 = 788;
      e3.a155 = 788;
      e3.a156 = 788;
      e3.a157 = 788;
      e3.a158 = 788;
      e3.a159 = 788;
      e3.a160 = 894;
      e3.a161 = 838;
      e3.a163 = 1016;
      e3.a164 = 458;
      e3.a196 = 748;
      e3.a165 = 924;
      e3.a192 = 748;
      e3.a166 = 918;
      e3.a167 = 927;
      e3.a168 = 928;
      e3.a169 = 928;
      e3.a170 = 834;
      e3.a171 = 873;
      e3.a172 = 828;
      e3.a173 = 924;
      e3.a162 = 924;
      e3.a174 = 917;
      e3.a175 = 930;
      e3.a176 = 931;
      e3.a177 = 463;
      e3.a178 = 883;
      e3.a179 = 836;
      e3.a193 = 836;
      e3.a180 = 867;
      e3.a199 = 867;
      e3.a181 = 696;
      e3.a200 = 696;
      e3.a182 = 874;
      e3.a201 = 874;
      e3.a183 = 760;
      e3.a184 = 946;
      e3.a197 = 771;
      e3.a185 = 865;
      e3.a194 = 771;
      e3.a198 = 888;
      e3.a186 = 967;
      e3.a195 = 888;
      e3.a187 = 831;
      e3.a188 = 873;
      e3.a189 = 927;
      e3.a190 = 970;
      e3.a191 = 918;
    });
  }), sa = getLookupTableFactory(function(e2) {
    e2.Courier = {
      ascent: 629,
      descent: -157,
      capHeight: 562,
      xHeight: -426
    };
    e2["Courier-Bold"] = {
      ascent: 629,
      descent: -157,
      capHeight: 562,
      xHeight: 439
    };
    e2["Courier-Oblique"] = {
      ascent: 629,
      descent: -157,
      capHeight: 562,
      xHeight: 426
    };
    e2["Courier-BoldOblique"] = {
      ascent: 629,
      descent: -157,
      capHeight: 562,
      xHeight: 426
    };
    e2.Helvetica = {
      ascent: 718,
      descent: -207,
      capHeight: 718,
      xHeight: 523
    };
    e2["Helvetica-Bold"] = {
      ascent: 718,
      descent: -207,
      capHeight: 718,
      xHeight: 532
    };
    e2["Helvetica-Oblique"] = {
      ascent: 718,
      descent: -207,
      capHeight: 718,
      xHeight: 523
    };
    e2["Helvetica-BoldOblique"] = {
      ascent: 718,
      descent: -207,
      capHeight: 718,
      xHeight: 532
    };
    e2["Times-Roman"] = {
      ascent: 683,
      descent: -217,
      capHeight: 662,
      xHeight: 450
    };
    e2["Times-Bold"] = {
      ascent: 683,
      descent: -217,
      capHeight: 676,
      xHeight: 461
    };
    e2["Times-Italic"] = {
      ascent: 683,
      descent: -217,
      capHeight: 653,
      xHeight: 441
    };
    e2["Times-BoldItalic"] = {
      ascent: 683,
      descent: -217,
      capHeight: 669,
      xHeight: 462
    };
    e2.Symbol = {
      ascent: Math.NaN,
      descent: Math.NaN,
      capHeight: Math.NaN,
      xHeight: Math.NaN
    };
    e2.ZapfDingbats = {
      ascent: Math.NaN,
      descent: Math.NaN,
      capHeight: Math.NaN,
      xHeight: Math.NaN
    };
  });
  class GlyfTable {
    constructor({ glyfTable: e2, isGlyphLocationsLong: t2, locaTable: i2, numGlyphs: a2 }) {
      this.glyphs = [];
      const r2 = new DataView(i2.buffer, i2.byteOffset, i2.byteLength), s2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), n2 = t2 ? 4 : 2;
      let o2 = t2 ? r2.getUint32(0) : 2 * r2.getUint16(0), g2 = 0;
      for (let e3 = 0; e3 < a2; e3++) {
        g2 += n2;
        const e4 = t2 ? r2.getUint32(g2) : 2 * r2.getUint16(g2);
        if (e4 === o2) {
          this.glyphs.push(new Glyph({}));
          continue;
        }
        const i3 = Glyph.parse(o2, s2);
        this.glyphs.push(i3);
        o2 = e4;
      }
    }
    getSize() {
      return this.glyphs.reduce((e2, t2) => e2 + (t2.getSize() + 3 & -4), 0);
    }
    write() {
      const e2 = this.getSize(), t2 = new DataView(new ArrayBuffer(e2)), i2 = e2 > 131070, a2 = i2 ? 4 : 2, r2 = new DataView(new ArrayBuffer((this.glyphs.length + 1) * a2));
      i2 ? r2.setUint32(0, 0) : r2.setUint16(0, 0);
      let s2 = 0, n2 = 0;
      for (const e3 of this.glyphs) {
        s2 += e3.write(s2, t2);
        s2 = s2 + 3 & -4;
        n2 += a2;
        i2 ? r2.setUint32(n2, s2) : r2.setUint16(n2, s2 >> 1);
      }
      return {
        isLocationLong: i2,
        loca: new Uint8Array(r2.buffer),
        glyf: new Uint8Array(t2.buffer)
      };
    }
    scale(e2) {
      for (let t2 = 0, i2 = this.glyphs.length; t2 < i2; t2++) this.glyphs[t2].scale(e2[t2]);
    }
  }
  class Glyph {
    constructor({ header: e2 = null, simple: t2 = null, composites: i2 = null }) {
      this.header = e2;
      this.simple = t2;
      this.composites = i2;
    }
    static parse(e2, t2) {
      const [i2, a2] = GlyphHeader.parse(e2, t2);
      e2 += i2;
      if (a2.numberOfContours < 0) {
        const i3 = [];
        for (; ; ) {
          const [a3, r3] = CompositeGlyph.parse(e2, t2);
          e2 += a3;
          i3.push(r3);
          if (!(32 & r3.flags)) break;
        }
        return new Glyph({
          header: a2,
          composites: i3
        });
      }
      const r2 = SimpleGlyph.parse(e2, t2, a2.numberOfContours);
      return new Glyph({
        header: a2,
        simple: r2
      });
    }
    getSize() {
      if (!this.header) return 0;
      const e2 = this.simple ? this.simple.getSize() : this.composites.reduce((e3, t2) => e3 + t2.getSize(), 0);
      return this.header.getSize() + e2;
    }
    write(e2, t2) {
      if (!this.header) return 0;
      const i2 = e2;
      e2 += this.header.write(e2, t2);
      if (this.simple) e2 += this.simple.write(e2, t2);
      else for (const i3 of this.composites) e2 += i3.write(e2, t2);
      return e2 - i2;
    }
    scale(e2) {
      if (!this.header) return;
      const t2 = (this.header.xMin + this.header.xMax) / 2;
      this.header.scale(t2, e2);
      if (this.simple) this.simple.scale(t2, e2);
      else for (const i2 of this.composites) i2.scale(t2, e2);
    }
  }
  class GlyphHeader {
    constructor({ numberOfContours: e2, xMin: t2, yMin: i2, xMax: a2, yMax: r2 }) {
      this.numberOfContours = e2;
      this.xMin = t2;
      this.yMin = i2;
      this.xMax = a2;
      this.yMax = r2;
    }
    static parse(e2, t2) {
      return [
        10,
        new GlyphHeader({
          numberOfContours: t2.getInt16(e2),
          xMin: t2.getInt16(e2 + 2),
          yMin: t2.getInt16(e2 + 4),
          xMax: t2.getInt16(e2 + 6),
          yMax: t2.getInt16(e2 + 8)
        })
      ];
    }
    getSize() {
      return 10;
    }
    write(e2, t2) {
      t2.setInt16(e2, this.numberOfContours);
      t2.setInt16(e2 + 2, this.xMin);
      t2.setInt16(e2 + 4, this.yMin);
      t2.setInt16(e2 + 6, this.xMax);
      t2.setInt16(e2 + 8, this.yMax);
      return 10;
    }
    scale(e2, t2) {
      this.xMin = Math.round(e2 + (this.xMin - e2) * t2);
      this.xMax = Math.round(e2 + (this.xMax - e2) * t2);
    }
  }
  class Contour {
    constructor({ flags: e2, xCoordinates: t2, yCoordinates: i2 }) {
      this.xCoordinates = t2;
      this.yCoordinates = i2;
      this.flags = e2;
    }
  }
  class SimpleGlyph {
    constructor({ contours: e2, instructions: t2 }) {
      this.contours = e2;
      this.instructions = t2;
    }
    static parse(e2, t2, i2) {
      const a2 = [];
      for (let r3 = 0; r3 < i2; r3++) {
        const i3 = t2.getUint16(e2);
        e2 += 2;
        a2.push(i3);
      }
      const r2 = a2[i2 - 1] + 1, s2 = t2.getUint16(e2);
      e2 += 2;
      const n2 = new Uint8Array(t2).slice(e2, e2 + s2);
      e2 += s2;
      const o2 = [];
      for (let i3 = 0; i3 < r2; e2++, i3++) {
        let a3 = t2.getUint8(e2);
        o2.push(a3);
        if (8 & a3) {
          const r3 = t2.getUint8(++e2);
          a3 ^= 8;
          for (let e3 = 0; e3 < r3; e3++) o2.push(a3);
          i3 += r3;
        }
      }
      const g2 = [];
      let c2 = [], C2 = [], h2 = [];
      const l2 = [];
      let Q2 = 0, E2 = 0;
      for (let i3 = 0; i3 < r2; i3++) {
        const r3 = o2[i3];
        if (2 & r3) {
          const i4 = t2.getUint8(e2++);
          E2 += 16 & r3 ? i4 : -i4;
          c2.push(E2);
        } else if (16 & r3) c2.push(E2);
        else {
          E2 += t2.getInt16(e2);
          e2 += 2;
          c2.push(E2);
        }
        if (a2[Q2] === i3) {
          Q2++;
          g2.push(c2);
          c2 = [];
        }
      }
      E2 = 0;
      Q2 = 0;
      for (let i3 = 0; i3 < r2; i3++) {
        const r3 = o2[i3];
        if (4 & r3) {
          const i4 = t2.getUint8(e2++);
          E2 += 32 & r3 ? i4 : -i4;
          C2.push(E2);
        } else if (32 & r3) C2.push(E2);
        else {
          E2 += t2.getInt16(e2);
          e2 += 2;
          C2.push(E2);
        }
        h2.push(1 & r3 | 64 & r3);
        if (a2[Q2] === i3) {
          c2 = g2[Q2];
          Q2++;
          l2.push(new Contour({
            flags: h2,
            xCoordinates: c2,
            yCoordinates: C2
          }));
          C2 = [];
          h2 = [];
        }
      }
      return new SimpleGlyph({
        contours: l2,
        instructions: n2
      });
    }
    getSize() {
      let e2 = 2 * this.contours.length + 2 + this.instructions.length, t2 = 0, i2 = 0;
      for (const a2 of this.contours) {
        e2 += a2.flags.length;
        for (let r2 = 0, s2 = a2.xCoordinates.length; r2 < s2; r2++) {
          const s3 = a2.xCoordinates[r2], n2 = a2.yCoordinates[r2];
          let o2 = Math.abs(s3 - t2);
          o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1);
          t2 = s3;
          o2 = Math.abs(n2 - i2);
          o2 > 255 ? e2 += 2 : o2 > 0 && (e2 += 1);
          i2 = n2;
        }
      }
      return e2;
    }
    write(e2, t2) {
      const i2 = e2, a2 = [], r2 = [], s2 = [];
      let n2 = 0, o2 = 0;
      for (const i3 of this.contours) {
        for (let e3 = 0, t3 = i3.xCoordinates.length; e3 < t3; e3++) {
          let t4 = i3.flags[e3];
          const g2 = i3.xCoordinates[e3];
          let c2 = g2 - n2;
          if (0 === c2) {
            t4 |= 16;
            a2.push(0);
          } else {
            const e4 = Math.abs(c2);
            if (e4 <= 255) {
              t4 |= c2 >= 0 ? 18 : 2;
              a2.push(e4);
            } else a2.push(c2);
          }
          n2 = g2;
          const C2 = i3.yCoordinates[e3];
          c2 = C2 - o2;
          if (0 === c2) {
            t4 |= 32;
            r2.push(0);
          } else {
            const e4 = Math.abs(c2);
            if (e4 <= 255) {
              t4 |= c2 >= 0 ? 36 : 4;
              r2.push(e4);
            } else r2.push(c2);
          }
          o2 = C2;
          s2.push(t4);
        }
        t2.setUint16(e2, a2.length - 1);
        e2 += 2;
      }
      t2.setUint16(e2, this.instructions.length);
      e2 += 2;
      if (this.instructions.length) {
        new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2);
        e2 += this.instructions.length;
      }
      for (const i3 of s2) t2.setUint8(e2++, i3);
      for (let i3 = 0, r3 = a2.length; i3 < r3; i3++) {
        const r4 = a2[i3], n3 = s2[i3];
        if (2 & n3) t2.setUint8(e2++, r4);
        else if (!(16 & n3)) {
          t2.setInt16(e2, r4);
          e2 += 2;
        }
      }
      for (let i3 = 0, a3 = r2.length; i3 < a3; i3++) {
        const a4 = r2[i3], n3 = s2[i3];
        if (4 & n3) t2.setUint8(e2++, a4);
        else if (!(32 & n3)) {
          t2.setInt16(e2, a4);
          e2 += 2;
        }
      }
      return e2 - i2;
    }
    scale(e2, t2) {
      for (const i2 of this.contours) if (0 !== i2.xCoordinates.length) for (let a2 = 0, r2 = i2.xCoordinates.length; a2 < r2; a2++) i2.xCoordinates[a2] = Math.round(e2 + (i2.xCoordinates[a2] - e2) * t2);
    }
  }
  class CompositeGlyph {
    constructor({ flags: e2, glyphIndex: t2, argument1: i2, argument2: a2, transf: r2, instructions: s2 }) {
      this.flags = e2;
      this.glyphIndex = t2;
      this.argument1 = i2;
      this.argument2 = a2;
      this.transf = r2;
      this.instructions = s2;
    }
    static parse(e2, t2) {
      const i2 = e2, a2 = [];
      let r2 = t2.getUint16(e2);
      const s2 = t2.getUint16(e2 + 2);
      e2 += 4;
      let n2, o2;
      if (1 & r2) {
        if (2 & r2) {
          n2 = t2.getInt16(e2);
          o2 = t2.getInt16(e2 + 2);
        } else {
          n2 = t2.getUint16(e2);
          o2 = t2.getUint16(e2 + 2);
        }
        e2 += 4;
        r2 ^= 1;
      } else {
        if (2 & r2) {
          n2 = t2.getInt8(e2);
          o2 = t2.getInt8(e2 + 1);
        } else {
          n2 = t2.getUint8(e2);
          o2 = t2.getUint8(e2 + 1);
        }
        e2 += 2;
      }
      if (8 & r2) {
        a2.push(t2.getUint16(e2));
        e2 += 2;
      } else if (64 & r2) {
        a2.push(t2.getUint16(e2), t2.getUint16(e2 + 2));
        e2 += 4;
      } else if (128 & r2) {
        a2.push(t2.getUint16(e2), t2.getUint16(e2 + 2), t2.getUint16(e2 + 4), t2.getUint16(e2 + 6));
        e2 += 8;
      }
      let g2 = null;
      if (256 & r2) {
        const i3 = t2.getUint16(e2);
        e2 += 2;
        g2 = new Uint8Array(t2).slice(e2, e2 + i3);
        e2 += i3;
      }
      return [
        e2 - i2,
        new CompositeGlyph({
          flags: r2,
          glyphIndex: s2,
          argument1: n2,
          argument2: o2,
          transf: a2,
          instructions: g2
        })
      ];
    }
    getSize() {
      let e2 = 4 + 2 * this.transf.length;
      256 & this.flags && (e2 += 2 + this.instructions.length);
      e2 += 2;
      2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (e2 += 2) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (e2 += 2);
      return e2;
    }
    write(e2, t2) {
      const i2 = e2;
      2 & this.flags ? this.argument1 >= -128 && this.argument1 <= 127 && this.argument2 >= -128 && this.argument2 <= 127 || (this.flags |= 1) : this.argument1 >= 0 && this.argument1 <= 255 && this.argument2 >= 0 && this.argument2 <= 255 || (this.flags |= 1);
      t2.setUint16(e2, this.flags);
      t2.setUint16(e2 + 2, this.glyphIndex);
      e2 += 4;
      if (1 & this.flags) {
        if (2 & this.flags) {
          t2.setInt16(e2, this.argument1);
          t2.setInt16(e2 + 2, this.argument2);
        } else {
          t2.setUint16(e2, this.argument1);
          t2.setUint16(e2 + 2, this.argument2);
        }
        e2 += 4;
      } else {
        t2.setUint8(e2, this.argument1);
        t2.setUint8(e2 + 1, this.argument2);
        e2 += 2;
      }
      if (256 & this.flags) {
        t2.setUint16(e2, this.instructions.length);
        e2 += 2;
        if (this.instructions.length) {
          new Uint8Array(t2.buffer, 0, t2.buffer.byteLength).set(this.instructions, e2);
          e2 += this.instructions.length;
        }
      }
      return e2 - i2;
    }
    scale(e2, t2) {
    }
  }
  function writeInt16(e2, t2, i2) {
    e2[t2] = i2 >> 8 & 255;
    e2[t2 + 1] = 255 & i2;
  }
  function writeInt32(e2, t2, i2) {
    e2[t2] = i2 >> 24 & 255;
    e2[t2 + 1] = i2 >> 16 & 255;
    e2[t2 + 2] = i2 >> 8 & 255;
    e2[t2 + 3] = 255 & i2;
  }
  function writeData(e2, t2, i2) {
    if (i2 instanceof Uint8Array) e2.set(i2, t2);
    else if ("string" == typeof i2) for (let a2 = 0, r2 = i2.length; a2 < r2; a2++) e2[t2++] = 255 & i2.charCodeAt(a2);
    else for (const a2 of i2) e2[t2++] = 255 & a2;
  }
  class OpenTypeFileBuilder {
    constructor(e2) {
      this.sfnt = e2;
      this.tables = /* @__PURE__ */ Object.create(null);
    }
    static getSearchParams(e2, t2) {
      let i2 = 1, a2 = 0;
      for (; (i2 ^ e2) > i2; ) {
        i2 <<= 1;
        a2++;
      }
      const r2 = i2 * t2;
      return {
        range: r2,
        entry: a2,
        rangeShift: t2 * e2 - r2
      };
    }
    toArray() {
      let e2 = this.sfnt;
      const t2 = this.tables, i2 = Object.keys(t2);
      i2.sort();
      const a2 = i2.length;
      let r2, s2, n2, o2, g2, c2 = 12 + 16 * a2;
      const C2 = [
        c2
      ];
      for (r2 = 0; r2 < a2; r2++) {
        o2 = t2[i2[r2]];
        c2 += (o2.length + 3 & -4) >>> 0;
        C2.push(c2);
      }
      const h2 = new Uint8Array(c2);
      for (r2 = 0; r2 < a2; r2++) {
        o2 = t2[i2[r2]];
        writeData(h2, C2[r2], o2);
      }
      "true" === e2 && (e2 = string32(65536));
      h2[0] = 255 & e2.charCodeAt(0);
      h2[1] = 255 & e2.charCodeAt(1);
      h2[2] = 255 & e2.charCodeAt(2);
      h2[3] = 255 & e2.charCodeAt(3);
      writeInt16(h2, 4, a2);
      const l2 = OpenTypeFileBuilder.getSearchParams(a2, 16);
      writeInt16(h2, 6, l2.range);
      writeInt16(h2, 8, l2.entry);
      writeInt16(h2, 10, l2.rangeShift);
      c2 = 12;
      for (r2 = 0; r2 < a2; r2++) {
        g2 = i2[r2];
        h2[c2] = 255 & g2.charCodeAt(0);
        h2[c2 + 1] = 255 & g2.charCodeAt(1);
        h2[c2 + 2] = 255 & g2.charCodeAt(2);
        h2[c2 + 3] = 255 & g2.charCodeAt(3);
        let e3 = 0;
        for (s2 = C2[r2], n2 = C2[r2 + 1]; s2 < n2; s2 += 4) {
          e3 = e3 + readUint32(h2, s2) >>> 0;
        }
        writeInt32(h2, c2 + 4, e3);
        writeInt32(h2, c2 + 8, C2[r2]);
        writeInt32(h2, c2 + 12, t2[g2].length);
        c2 += 16;
      }
      return h2;
    }
    addTable(e2, t2) {
      if (e2 in this.tables) throw new Error("Table " + e2 + " already exists");
      this.tables[e2] = t2;
    }
  }
  const na = [
    4
  ], oa = [
    5
  ], ga = [
    6
  ], Ia = [
    7
  ], ca = [
    8
  ], Ca = [
    12,
    35
  ], ha = [
    14
  ], la = [
    21
  ], Ba = [
    22
  ], Qa = [
    30
  ], Ea = [
    31
  ];
  class Type1CharString {
    constructor() {
      this.width = 0;
      this.lsb = 0;
      this.flexing = false;
      this.output = [];
      this.stack = [];
    }
    convert(e2, t2, i2) {
      const a2 = e2.length;
      let r2, s2, n2, o2 = false;
      for (let g2 = 0; g2 < a2; g2++) {
        let a3 = e2[g2];
        if (a3 < 32) {
          12 === a3 && (a3 = (a3 << 8) + e2[++g2]);
          switch (a3) {
            case 1:
            case 3:
            case 9:
            case 3072:
            case 3073:
            case 3074:
            case 3105:
              this.stack = [];
              break;
            case 4:
              if (this.flexing) {
                if (this.stack.length < 1) {
                  o2 = true;
                  break;
                }
                const e4 = this.stack.pop();
                this.stack.push(0, e4);
                break;
              }
              o2 = this.executeCommand(1, na);
              break;
            case 5:
              o2 = this.executeCommand(2, oa);
              break;
            case 6:
              o2 = this.executeCommand(1, ga);
              break;
            case 7:
              o2 = this.executeCommand(1, Ia);
              break;
            case 8:
              o2 = this.executeCommand(6, ca);
              break;
            case 10:
              if (this.stack.length < 1) {
                o2 = true;
                break;
              }
              n2 = this.stack.pop();
              if (!t2[n2]) {
                o2 = true;
                break;
              }
              o2 = this.convert(t2[n2], t2, i2);
              break;
            case 11:
              return o2;
            case 13:
              if (this.stack.length < 2) {
                o2 = true;
                break;
              }
              r2 = this.stack.pop();
              s2 = this.stack.pop();
              this.lsb = s2;
              this.width = r2;
              this.stack.push(r2, s2);
              o2 = this.executeCommand(2, Ba);
              break;
            case 14:
              this.output.push(ha[0]);
              break;
            case 21:
              if (this.flexing) break;
              o2 = this.executeCommand(2, la);
              break;
            case 22:
              if (this.flexing) {
                this.stack.push(0);
                break;
              }
              o2 = this.executeCommand(1, Ba);
              break;
            case 30:
              o2 = this.executeCommand(4, Qa);
              break;
            case 31:
              o2 = this.executeCommand(4, Ea);
              break;
            case 3078:
              if (i2) {
                const e4 = this.stack.at(-5);
                this.seac = this.stack.splice(-4, 4);
                this.seac[0] += this.lsb - e4;
                o2 = this.executeCommand(0, ha);
              } else o2 = this.executeCommand(4, ha);
              break;
            case 3079:
              if (this.stack.length < 4) {
                o2 = true;
                break;
              }
              this.stack.pop();
              r2 = this.stack.pop();
              const e3 = this.stack.pop();
              s2 = this.stack.pop();
              this.lsb = s2;
              this.width = r2;
              this.stack.push(r2, s2, e3);
              o2 = this.executeCommand(3, la);
              break;
            case 3084:
              if (this.stack.length < 2) {
                o2 = true;
                break;
              }
              const g3 = this.stack.pop(), c2 = this.stack.pop();
              this.stack.push(c2 / g3);
              break;
            case 3088:
              if (this.stack.length < 2) {
                o2 = true;
                break;
              }
              n2 = this.stack.pop();
              const C2 = this.stack.pop();
              if (0 === n2 && 3 === C2) {
                const e4 = this.stack.splice(-17, 17);
                this.stack.push(e4[2] + e4[0], e4[3] + e4[1], e4[4], e4[5], e4[6], e4[7], e4[8], e4[9], e4[10], e4[11], e4[12], e4[13], e4[14]);
                o2 = this.executeCommand(13, Ca, true);
                this.flexing = false;
                this.stack.push(e4[15], e4[16]);
              } else 1 === n2 && 0 === C2 && (this.flexing = true);
              break;
            case 3089:
              break;
            default:
              warn('Unknown type 1 charstring command of "' + a3 + '"');
          }
          if (o2) break;
        } else {
          a3 <= 246 ? a3 -= 139 : a3 = a3 <= 250 ? 256 * (a3 - 247) + e2[++g2] + 108 : a3 <= 254 ? -256 * (a3 - 251) - e2[++g2] - 108 : (255 & e2[++g2]) << 24 | (255 & e2[++g2]) << 16 | (255 & e2[++g2]) << 8 | (255 & e2[++g2]) << 0;
          this.stack.push(a3);
        }
      }
      return o2;
    }
    executeCommand(e2, t2, i2) {
      const a2 = this.stack.length;
      if (e2 > a2) return true;
      const r2 = a2 - e2;
      for (let e3 = r2; e3 < a2; e3++) {
        let t3 = this.stack[e3];
        if (Number.isInteger(t3)) this.output.push(28, t3 >> 8 & 255, 255 & t3);
        else {
          t3 = 65536 * t3 | 0;
          this.output.push(255, t3 >> 24 & 255, t3 >> 16 & 255, t3 >> 8 & 255, 255 & t3);
        }
      }
      this.output.push(...t2);
      i2 ? this.stack.splice(r2, e2) : this.stack.length = 0;
      return false;
    }
  }
  function isHexDigit(e2) {
    return e2 >= 48 && e2 <= 57 || e2 >= 65 && e2 <= 70 || e2 >= 97 && e2 <= 102;
  }
  function decrypt(e2, t2, i2) {
    if (i2 >= e2.length) return new Uint8Array(0);
    let a2, r2, s2 = 0 | t2;
    for (a2 = 0; a2 < i2; a2++) s2 = 52845 * (e2[a2] + s2) + 22719 & 65535;
    const n2 = e2.length - i2, o2 = new Uint8Array(n2);
    for (a2 = i2, r2 = 0; r2 < n2; a2++, r2++) {
      const t3 = e2[a2];
      o2[r2] = t3 ^ s2 >> 8;
      s2 = 52845 * (t3 + s2) + 22719 & 65535;
    }
    return o2;
  }
  function isSpecial(e2) {
    return 47 === e2 || 91 === e2 || 93 === e2 || 123 === e2 || 125 === e2 || 40 === e2 || 41 === e2;
  }
  class Type1Parser {
    constructor(e2, t2, i2) {
      if (t2) {
        const t3 = e2.getBytes(), i3 = !((isHexDigit(t3[0]) || isWhiteSpace(t3[0])) && isHexDigit(t3[1]) && isHexDigit(t3[2]) && isHexDigit(t3[3]) && isHexDigit(t3[4]) && isHexDigit(t3[5]) && isHexDigit(t3[6]) && isHexDigit(t3[7]));
        e2 = new Stream(i3 ? decrypt(t3, 55665, 4) : function decryptAscii(e3, t4, i4) {
          let a2 = 0 | t4;
          const r2 = e3.length, s2 = new Uint8Array(r2 >>> 1);
          let n2, o2;
          for (n2 = 0, o2 = 0; n2 < r2; n2++) {
            const t5 = e3[n2];
            if (!isHexDigit(t5)) continue;
            n2++;
            let i5;
            for (; n2 < r2 && !isHexDigit(i5 = e3[n2]); ) n2++;
            if (n2 < r2) {
              const e4 = parseInt(String.fromCharCode(t5, i5), 16);
              s2[o2++] = e4 ^ a2 >> 8;
              a2 = 52845 * (e4 + a2) + 22719 & 65535;
            }
          }
          return s2.slice(i4, o2);
        }(t3, 55665, 4));
      }
      this.seacAnalysisEnabled = !!i2;
      this.stream = e2;
      this.nextChar();
    }
    readNumberArray() {
      this.getToken();
      const e2 = [];
      for (; ; ) {
        const t2 = this.getToken();
        if (null === t2 || "]" === t2 || "}" === t2) break;
        e2.push(parseFloat(t2 || 0));
      }
      return e2;
    }
    readNumber() {
      const e2 = this.getToken();
      return parseFloat(e2 || 0);
    }
    readInt() {
      const e2 = this.getToken();
      return 0 | parseInt(e2 || 0, 10);
    }
    readBoolean() {
      return "true" === this.getToken() ? 1 : 0;
    }
    nextChar() {
      return this.currentChar = this.stream.getByte();
    }
    prevChar() {
      this.stream.skip(-2);
      return this.currentChar = this.stream.getByte();
    }
    getToken() {
      let e2 = false, t2 = this.currentChar;
      for (; ; ) {
        if (-1 === t2) return null;
        if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
        else if (37 === t2) e2 = true;
        else if (!isWhiteSpace(t2)) break;
        t2 = this.nextChar();
      }
      if (isSpecial(t2)) {
        this.nextChar();
        return String.fromCharCode(t2);
      }
      let i2 = "";
      do {
        i2 += String.fromCharCode(t2);
        t2 = this.nextChar();
      } while (t2 >= 0 && !isWhiteSpace(t2) && !isSpecial(t2));
      return i2;
    }
    readCharStrings(e2, t2) {
      return -1 === t2 ? e2 : decrypt(e2, 4330, t2);
    }
    extractFontProgram(e2) {
      const t2 = this.stream, i2 = [], a2 = [], r2 = /* @__PURE__ */ Object.create(null);
      r2.lenIV = 4;
      const s2 = {
        subrs: [],
        charstrings: [],
        properties: {
          privateData: r2
        }
      };
      let n2, o2, g2, c2;
      for (; null !== (n2 = this.getToken()); ) if ("/" === n2) {
        n2 = this.getToken();
        switch (n2) {
          case "CharStrings":
            this.getToken();
            this.getToken();
            this.getToken();
            this.getToken();
            for (; ; ) {
              n2 = this.getToken();
              if (null === n2 || "end" === n2) break;
              if ("/" !== n2) continue;
              const e4 = this.getToken();
              o2 = this.readInt();
              this.getToken();
              g2 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0);
              c2 = s2.properties.privateData.lenIV;
              const i3 = this.readCharStrings(g2, c2);
              this.nextChar();
              n2 = this.getToken();
              "noaccess" === n2 ? this.getToken() : "/" === n2 && this.prevChar();
              a2.push({
                glyph: e4,
                encoded: i3
              });
            }
            break;
          case "Subrs":
            this.readInt();
            this.getToken();
            for (; "dup" === this.getToken(); ) {
              const e4 = this.readInt();
              o2 = this.readInt();
              this.getToken();
              g2 = o2 > 0 ? t2.getBytes(o2) : new Uint8Array(0);
              c2 = s2.properties.privateData.lenIV;
              const a3 = this.readCharStrings(g2, c2);
              this.nextChar();
              n2 = this.getToken();
              "noaccess" === n2 && this.getToken();
              i2[e4] = a3;
            }
            break;
          case "BlueValues":
          case "OtherBlues":
          case "FamilyBlues":
          case "FamilyOtherBlues":
            const e3 = this.readNumberArray();
            e3.length > 0 && e3.length;
            break;
          case "StemSnapH":
          case "StemSnapV":
            s2.properties.privateData[n2] = this.readNumberArray();
            break;
          case "StdHW":
          case "StdVW":
            s2.properties.privateData[n2] = this.readNumberArray()[0];
            break;
          case "BlueShift":
          case "lenIV":
          case "BlueFuzz":
          case "BlueScale":
          case "LanguageGroup":
            s2.properties.privateData[n2] = this.readNumber();
            break;
          case "ExpansionFactor":
            s2.properties.privateData[n2] = this.readNumber() || 0.06;
            break;
          case "ForceBold":
            s2.properties.privateData[n2] = this.readBoolean();
        }
      }
      for (const { encoded: t3, glyph: r3 } of a2) {
        const a3 = new Type1CharString(), n3 = a3.convert(t3, i2, this.seacAnalysisEnabled);
        let o3 = a3.output;
        n3 && (o3 = [
          14
        ]);
        const g3 = {
          glyphName: r3,
          charstring: o3,
          width: a3.width,
          lsb: a3.lsb,
          seac: a3.seac
        };
        ".notdef" === r3 ? s2.charstrings.unshift(g3) : s2.charstrings.push(g3);
        if (e2.builtInEncoding) {
          const t4 = e2.builtInEncoding.indexOf(r3);
          t4 > -1 && void 0 === e2.widths[t4] && t4 >= e2.firstChar && t4 <= e2.lastChar && (e2.widths[t4] = a3.width);
        }
      }
      return s2;
    }
    extractFontHeader(e2) {
      let t2;
      for (; null !== (t2 = this.getToken()); ) if ("/" === t2) {
        t2 = this.getToken();
        switch (t2) {
          case "FontMatrix":
            const i2 = this.readNumberArray();
            e2.fontMatrix = i2;
            break;
          case "Encoding":
            const a2 = this.getToken();
            let r2;
            if (/^\d+$/.test(a2)) {
              r2 = [];
              const e3 = 0 | parseInt(a2, 10);
              this.getToken();
              for (let i3 = 0; i3 < e3; i3++) {
                t2 = this.getToken();
                for (; "dup" !== t2 && "def" !== t2; ) {
                  t2 = this.getToken();
                  if (null === t2) return;
                }
                if ("def" === t2) break;
                const e4 = this.readInt();
                this.getToken();
                const i4 = this.getToken();
                r2[e4] = i4;
                this.getToken();
              }
            } else r2 = getEncoding(a2);
            e2.builtInEncoding = r2;
            break;
          case "FontBBox":
            const s2 = this.readNumberArray();
            e2.ascent = Math.max(s2[3], s2[1]);
            e2.descent = Math.min(s2[1], s2[3]);
            e2.ascentScaled = true;
        }
      }
    }
  }
  function findBlock(e2, t2, i2) {
    const a2 = e2.length, r2 = t2.length, s2 = a2 - r2;
    let n2 = i2, o2 = false;
    for (; n2 < s2; ) {
      let i3 = 0;
      for (; i3 < r2 && e2[n2 + i3] === t2[i3]; ) i3++;
      if (i3 >= r2) {
        n2 += i3;
        for (; n2 < a2 && isWhiteSpace(e2[n2]); ) n2++;
        o2 = true;
        break;
      }
      n2++;
    }
    return {
      found: o2,
      length: n2
    };
  }
  class Type1Font {
    constructor(e2, t2, i2) {
      let a2 = i2.length1;
      i2.length2;
      let s2 = t2.peekBytes(6);
      const n2 = 128 === s2[0] && 1 === s2[1];
      if (n2) {
        t2.skip(6);
        a2 = s2[5] << 24 | s2[4] << 16 | s2[3] << 8 | s2[2];
      }
      const o2 = function getHeaderBlock(e3, t3) {
        const i3 = [
          101,
          101,
          120,
          101,
          99
        ], a3 = e3.pos;
        let r2, s3, n3, o3;
        try {
          r2 = e3.getBytes(t3);
          s3 = r2.length;
        } catch {
        }
        if (s3 === t3) {
          n3 = findBlock(r2, i3, t3 - 2 * i3.length);
          if (n3.found && n3.length === t3) return {
            stream: new Stream(r2),
            length: t3
          };
        }
        warn('Invalid "Length1" property in Type1 font -- trying to recover.');
        e3.pos = a3;
        for (; ; ) {
          n3 = findBlock(e3.peekBytes(2048), i3, 0);
          if (0 === n3.length) break;
          e3.pos += n3.length;
          if (n3.found) {
            o3 = e3.pos - a3;
            break;
          }
        }
        e3.pos = a3;
        if (o3) return {
          stream: new Stream(e3.getBytes(o3)),
          length: o3
        };
        warn('Unable to recover "Length1" property in Type1 font -- using as is.');
        return {
          stream: new Stream(e3.getBytes(t3)),
          length: t3
        };
      }(t2, a2);
      new Type1Parser(o2.stream, false, qi).extractFontHeader(i2);
      if (n2) {
        s2 = t2.getBytes(6);
        s2[5] << 24 | s2[4] << 16 | s2[3] << 8 | s2[2];
      }
      const g2 = function getEexecBlock(e3, t3) {
        const i3 = e3.getBytes();
        if (0 === i3.length) throw new FormatError("getEexecBlock - no font program found.");
        return {
          stream: new Stream(i3),
          length: i3.length
        };
      }(t2), c2 = new Type1Parser(g2.stream, true, qi).extractFontProgram(i2);
      for (const e3 in c2.properties) i2[e3] = c2.properties[e3];
      const C2 = c2.charstrings, h2 = this.getType2Charstrings(C2), l2 = this.getType2Subrs(c2.subrs);
      this.charstrings = C2;
      this.data = this.wrap(e2, h2, this.charstrings, l2, i2);
      this.seacs = this.getSeacs(c2.charstrings);
    }
    get numGlyphs() {
      return this.charstrings.length + 1;
    }
    getCharset() {
      const e2 = [
        ".notdef"
      ];
      for (const { glyphName: t2 } of this.charstrings) e2.push(t2);
      return e2;
    }
    getGlyphMapping(e2) {
      const t2 = this.charstrings;
      if (e2.composite) {
        const i3 = /* @__PURE__ */ Object.create(null);
        for (let a3 = 0, r3 = t2.length; a3 < r3; a3++) {
          i3[e2.cMap.charCodeOf(a3)] = a3 + 1;
        }
        return i3;
      }
      const i2 = [
        ".notdef"
      ];
      let a2, r2;
      for (r2 = 0; r2 < t2.length; r2++) i2.push(t2[r2].glyphName);
      const s2 = e2.builtInEncoding;
      if (s2) {
        a2 = /* @__PURE__ */ Object.create(null);
        for (const e3 in s2) {
          r2 = i2.indexOf(s2[e3]);
          r2 >= 0 && (a2[e3] = r2);
        }
      }
      return type1FontGlyphMapping(e2, a2, i2);
    }
    hasGlyphId(e2) {
      if (e2 < 0 || e2 >= this.numGlyphs) return false;
      if (0 === e2) return true;
      return this.charstrings[e2 - 1].charstring.length > 0;
    }
    getSeacs(e2) {
      const t2 = [];
      for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
        const a3 = e2[i2];
        a3.seac && (t2[i2 + 1] = a3.seac);
      }
      return t2;
    }
    getType2Charstrings(e2) {
      const t2 = [];
      for (const i2 of e2) t2.push(i2.charstring);
      return t2;
    }
    getType2Subrs(e2) {
      let t2 = 0;
      const i2 = e2.length;
      t2 = i2 < 1133 ? 107 : i2 < 33769 ? 1131 : 32768;
      const a2 = [];
      let r2;
      for (r2 = 0; r2 < t2; r2++) a2.push([
        11
      ]);
      for (r2 = 0; r2 < i2; r2++) a2.push(e2[r2]);
      return a2;
    }
    wrap(e2, t2, i2, a2, r2) {
      const s2 = new CFF();
      s2.header = new CFFHeader(1, 0, 4, 4);
      s2.names = [
        e2
      ];
      const n2 = new CFFTopDict();
      n2.setByName("version", 391);
      n2.setByName("Notice", 392);
      n2.setByName("FullName", 393);
      n2.setByName("FamilyName", 394);
      n2.setByName("Weight", 395);
      n2.setByName("Encoding", null);
      n2.setByName("FontMatrix", r2.fontMatrix);
      n2.setByName("FontBBox", r2.bbox);
      n2.setByName("charset", null);
      n2.setByName("CharStrings", null);
      n2.setByName("Private", null);
      s2.topDict = n2;
      const o2 = new CFFStrings();
      o2.add("Version 0.11");
      o2.add("See original notice");
      o2.add(e2);
      o2.add(e2);
      o2.add("Medium");
      s2.strings = o2;
      s2.globalSubrIndex = new CFFIndex();
      const g2 = t2.length, c2 = [
        ".notdef"
      ];
      let C2, h2;
      for (C2 = 0; C2 < g2; C2++) {
        const e3 = i2[C2].glyphName;
        -1 === Si.indexOf(e3) && o2.add(e3);
        c2.push(e3);
      }
      s2.charset = new CFFCharset(false, 0, c2);
      const l2 = new CFFIndex();
      l2.add([
        139,
        14
      ]);
      for (C2 = 0; C2 < g2; C2++) l2.add(t2[C2]);
      s2.charStrings = l2;
      const Q2 = new CFFPrivateDict();
      Q2.setByName("Subrs", null);
      const E2 = [
        "BlueValues",
        "OtherBlues",
        "FamilyBlues",
        "FamilyOtherBlues",
        "StemSnapH",
        "StemSnapV",
        "BlueShift",
        "BlueFuzz",
        "BlueScale",
        "LanguageGroup",
        "ExpansionFactor",
        "ForceBold",
        "StdHW",
        "StdVW"
      ];
      for (C2 = 0, h2 = E2.length; C2 < h2; C2++) {
        const e3 = E2[C2];
        if (!(e3 in r2.privateData)) continue;
        const t3 = r2.privateData[e3];
        if (Array.isArray(t3)) for (let e4 = t3.length - 1; e4 > 0; e4--) t3[e4] -= t3[e4 - 1];
        Q2.setByName(e3, t3);
      }
      s2.topDict.privateDict = Q2;
      const u2 = new CFFIndex();
      for (C2 = 0, h2 = a2.length; C2 < h2; C2++) u2.add(a2[C2]);
      Q2.subrsIndex = u2;
      return new CFFCompiler(s2).compile();
    }
  }
  const ua = [
    [
      57344,
      63743
    ],
    [
      1048576,
      1114109
    ]
  ], da = 1e3, fa = [
    "ascent",
    "bbox",
    "black",
    "bold",
    "charProcOperatorList",
    "composite",
    "cssFontInfo",
    "data",
    "defaultVMetrics",
    "defaultWidth",
    "descent",
    "fallbackName",
    "fontMatrix",
    "isInvalidPDFjsFont",
    "isType3Font",
    "italic",
    "loadedName",
    "mimetype",
    "missingFile",
    "name",
    "remeasure",
    "subtype",
    "systemFontInfo",
    "type",
    "vertical"
  ], pa = [
    "cMap",
    "defaultEncoding",
    "differences",
    "isMonospace",
    "isSerifFont",
    "isSymbolicFont",
    "seacMap",
    "toFontChar",
    "toUnicode",
    "vmetrics",
    "widths"
  ];
  function adjustWidths(e2) {
    if (!e2.fontMatrix) return;
    if (e2.fontMatrix[0] === r[0]) return;
    const t2 = 1e-3 / e2.fontMatrix[0], i2 = e2.widths;
    for (const e3 in i2) i2[e3] *= t2;
    e2.defaultWidth *= t2;
  }
  function amendFallbackToUnicode(e2) {
    if (!e2.fallbackToUnicode) return;
    if (e2.toUnicode instanceof IdentityToUnicodeMap) return;
    const t2 = [];
    for (const i2 in e2.fallbackToUnicode) e2.toUnicode.has(i2) || (t2[i2] = e2.fallbackToUnicode[i2]);
    t2.length > 0 && e2.toUnicode.amend(t2);
  }
  class fonts_Glyph {
    constructor(e2, t2, i2, a2, r2, s2, n2, o2, g2) {
      this.originalCharCode = e2;
      this.fontChar = t2;
      this.unicode = i2;
      this.accent = a2;
      this.width = r2;
      this.vmetric = s2;
      this.operatorListId = n2;
      this.isSpace = o2;
      this.isInFont = g2;
    }
    get category() {
      return shadow(this, "category", function getCharUnicodeCategory(e2) {
        const t2 = Ki.get(e2);
        if (t2) return t2;
        const i2 = e2.match(Ti), a2 = {
          isWhitespace: !!(i2 == null ? void 0 : i2[1]),
          isZeroWidthDiacritic: !!(i2 == null ? void 0 : i2[2]),
          isInvisibleFormatMark: !!(i2 == null ? void 0 : i2[3])
        };
        Ki.set(e2, a2);
        return a2;
      }(this.unicode), true);
    }
  }
  function int16(e2, t2) {
    return (e2 << 8) + t2;
  }
  function writeSignedInt16(e2, t2, i2) {
    e2[t2 + 1] = i2;
    e2[t2] = i2 >>> 8;
  }
  function signedInt16(e2, t2) {
    const i2 = (e2 << 8) + t2;
    return 32768 & i2 ? i2 - 65536 : i2;
  }
  function string16(e2) {
    return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
  }
  function safeString16(e2) {
    e2 > 32767 ? e2 = 32767 : e2 < -32768 && (e2 = -32768);
    return String.fromCharCode(e2 >> 8 & 255, 255 & e2);
  }
  function isTrueTypeCollectionFile(e2) {
    return "ttcf" === bytesToString(e2.peekBytes(4));
  }
  function getFontFileType(e2, { type: t2, subtype: i2, composite: a2 }) {
    let r2, s2;
    if (function isTrueTypeFile(e3) {
      const t3 = e3.peekBytes(4);
      return 65536 === readUint32(t3, 0) || "true" === bytesToString(t3);
    }(e2) || isTrueTypeCollectionFile(e2)) r2 = a2 ? "CIDFontType2" : "TrueType";
    else if (function isOpenTypeFile(e3) {
      return "OTTO" === bytesToString(e3.peekBytes(4));
    }(e2)) r2 = a2 ? "CIDFontType2" : "OpenType";
    else if (function isType1File(e3) {
      const t3 = e3.peekBytes(2);
      return 37 === t3[0] && 33 === t3[1] || 128 === t3[0] && 1 === t3[1];
    }(e2)) r2 = a2 ? "CIDFontType0" : "MMType1" === t2 ? "MMType1" : "Type1";
    else if (function isCFFFile(e3) {
      const t3 = e3.peekBytes(4);
      return t3[0] >= 1 && t3[3] >= 1 && t3[3] <= 4;
    }(e2)) if (a2) {
      r2 = "CIDFontType0";
      s2 = "CIDFontType0C";
    } else {
      r2 = "MMType1" === t2 ? "MMType1" : "Type1";
      s2 = "Type1C";
    }
    else {
      warn("getFontFileType: Unable to detect correct font file Type/Subtype.");
      r2 = t2;
      s2 = i2;
    }
    return [
      r2,
      s2
    ];
  }
  function applyStandardFontGlyphMap(e2, t2) {
    for (const i2 in t2) e2[+i2] = t2[i2];
  }
  function buildToFontChar(e2, t2, i2) {
    const a2 = [];
    let r2;
    for (let i3 = 0, s2 = e2.length; i3 < s2; i3++) {
      r2 = getUnicodeForGlyph(e2[i3], t2);
      -1 !== r2 && (a2[i3] = r2);
    }
    for (const e3 in i2) {
      r2 = getUnicodeForGlyph(i2[e3], t2);
      -1 !== r2 && (a2[+e3] = r2);
    }
    return a2;
  }
  function isMacNameRecord(e2) {
    return 1 === e2.platform && 0 === e2.encoding && 0 === e2.language;
  }
  function isWinNameRecord(e2) {
    return 3 === e2.platform && 1 === e2.encoding && 1033 === e2.language;
  }
  function convertCidString(e2, t2, i2 = false) {
    switch (t2.length) {
      case 1:
        return t2.charCodeAt(0);
      case 2:
        return t2.charCodeAt(0) << 8 | t2.charCodeAt(1);
    }
    const a2 = `Unsupported CID string (charCode ${e2}): "${t2}".`;
    if (i2) throw new FormatError(a2);
    warn(a2);
    return t2;
  }
  function adjustMapping(e2, t2, i2, a2) {
    const r2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), n2 = [], o2 = /* @__PURE__ */ new Set();
    let g2 = 0;
    let c2 = ua[g2][0], C2 = ua[g2][1];
    for (const l2 in e2) {
      let Q2 = e2[l2];
      if (!t2(Q2)) continue;
      if (c2 > C2) {
        g2++;
        if (g2 >= ua.length) {
          warn("Ran out of space in font private use area.");
          break;
        }
        c2 = ua[g2][0];
        C2 = ua[g2][1];
      }
      const E2 = c2++;
      0 === Q2 && (Q2 = i2);
      let u2 = a2.get(l2);
      "string" == typeof u2 && (u2 = u2.codePointAt(0));
      if (u2 && !(h2 = u2, ua[0][0] <= h2 && h2 <= ua[0][1] || ua[1][0] <= h2 && h2 <= ua[1][1]) && !o2.has(Q2)) {
        s2.set(u2, Q2);
        o2.add(Q2);
      }
      r2[E2] = Q2;
      n2[l2] = E2;
    }
    var h2;
    return {
      toFontChar: n2,
      charCodeToGlyphId: r2,
      toUnicodeExtraMap: s2,
      nextAvailableFontCharCode: c2
    };
  }
  function createCmapTable(e2, t2, i2) {
    const a2 = function getRanges(e3, t3, i3) {
      const a3 = [];
      for (const t4 in e3) e3[t4] >= i3 || a3.push({
        fontCharCode: 0 | t4,
        glyphId: e3[t4]
      });
      if (t3) for (const [e4, r4] of t3) r4 >= i3 || a3.push({
        fontCharCode: e4,
        glyphId: r4
      });
      0 === a3.length && a3.push({
        fontCharCode: 0,
        glyphId: 0
      });
      a3.sort(function fontGetRangesSort(e4, t4) {
        return e4.fontCharCode - t4.fontCharCode;
      });
      const r3 = [], s3 = a3.length;
      for (let e4 = 0; e4 < s3; ) {
        const t4 = a3[e4].fontCharCode, i4 = [
          a3[e4].glyphId
        ];
        ++e4;
        let n3 = t4;
        for (; e4 < s3 && n3 + 1 === a3[e4].fontCharCode; ) {
          i4.push(a3[e4].glyphId);
          ++n3;
          ++e4;
          if (65535 === n3) break;
        }
        r3.push([
          t4,
          n3,
          i4
        ]);
      }
      return r3;
    }(e2, t2, i2), r2 = a2.at(-1)[1] > 65535 ? 2 : 1;
    let s2, n2, o2, g2, c2 = "\0\0" + string16(r2) + "\0\0" + string32(4 + 8 * r2);
    for (s2 = a2.length - 1; s2 >= 0 && !(a2[s2][0] <= 65535); --s2) ;
    const C2 = s2 + 1;
    a2[s2][0] < 65535 && 65535 === a2[s2][1] && (a2[s2][1] = 65534);
    const h2 = a2[s2][1] < 65535 ? 1 : 0, l2 = C2 + h2, Q2 = OpenTypeFileBuilder.getSearchParams(l2, 2);
    let E2, u2, d2, f2, p2 = "", m2 = "", y2 = "", w2 = "", b2 = "", D2 = 0;
    for (s2 = 0, n2 = C2; s2 < n2; s2++) {
      E2 = a2[s2];
      u2 = E2[0];
      d2 = E2[1];
      p2 += string16(u2);
      m2 += string16(d2);
      f2 = E2[2];
      let e3 = true;
      for (o2 = 1, g2 = f2.length; o2 < g2; ++o2) if (f2[o2] !== f2[o2 - 1] + 1) {
        e3 = false;
        break;
      }
      if (e3) {
        y2 += string16(f2[0] - u2 & 65535);
        w2 += string16(0);
      } else {
        const e4 = 2 * (l2 - s2) + 2 * D2;
        D2 += d2 - u2 + 1;
        y2 += string16(0);
        w2 += string16(e4);
        for (o2 = 0, g2 = f2.length; o2 < g2; ++o2) b2 += string16(f2[o2]);
      }
    }
    if (h2 > 0) {
      m2 += "\xFF\xFF";
      p2 += "\xFF\xFF";
      y2 += "\0";
      w2 += "\0\0";
    }
    const S2 = "\0\0" + string16(2 * l2) + string16(Q2.range) + string16(Q2.entry) + string16(Q2.rangeShift) + m2 + "\0\0" + p2 + y2 + w2 + b2;
    let k2 = "", R2 = "";
    if (r2 > 1) {
      c2 += "\0\0\n" + string32(4 + 8 * r2 + 4 + S2.length);
      k2 = "";
      for (s2 = 0, n2 = a2.length; s2 < n2; s2++) {
        E2 = a2[s2];
        u2 = E2[0];
        f2 = E2[2];
        let e3 = f2[0];
        for (o2 = 1, g2 = f2.length; o2 < g2; ++o2) if (f2[o2] !== f2[o2 - 1] + 1) {
          d2 = E2[0] + o2 - 1;
          k2 += string32(u2) + string32(d2) + string32(e3);
          u2 = d2 + 1;
          e3 = f2[o2];
        }
        k2 += string32(u2) + string32(E2[1]) + string32(e3);
      }
      R2 = "\0\f\0\0" + string32(k2.length + 16) + "\0\0\0\0" + string32(k2.length / 12);
    }
    return c2 + "\0" + string16(S2.length + 4) + S2 + R2 + k2;
  }
  function createOS2Table(e2, t2, i2) {
    i2 || (i2 = {
      unitsPerEm: 0,
      yMax: 0,
      yMin: 0,
      ascent: 0,
      descent: 0
    });
    let a2 = 0, r2 = 0, s2 = 0, n2 = 0, o2 = null, g2 = 0, c2 = -1;
    if (t2) {
      for (let e3 in t2) {
        e3 |= 0;
        (o2 > e3 || !o2) && (o2 = e3);
        g2 < e3 && (g2 = e3);
        c2 = getUnicodeRangeFor(e3, c2);
        if (c2 < 32) a2 |= 1 << c2;
        else if (c2 < 64) r2 |= 1 << c2 - 32;
        else if (c2 < 96) s2 |= 1 << c2 - 64;
        else {
          if (!(c2 < 123)) throw new FormatError("Unicode ranges Bits > 123 are reserved for internal usage");
          n2 |= 1 << c2 - 96;
        }
      }
      g2 > 65535 && (g2 = 65535);
    } else {
      o2 = 0;
      g2 = 255;
    }
    const C2 = e2.bbox || [
      0,
      0,
      0,
      0
    ], h2 = i2.unitsPerEm || (e2.fontMatrix ? 1 / Math.max(...e2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3), l2 = e2.ascentScaled ? 1 : h2 / da, Q2 = i2.ascent || Math.round(l2 * (e2.ascent || C2[3]));
    let E2 = i2.descent || Math.round(l2 * (e2.descent || C2[1]));
    E2 > 0 && e2.descent > 0 && C2[1] < 0 && (E2 = -E2);
    const u2 = i2.yMax || Q2, d2 = -i2.yMin || -E2;
    return "\0$\xF4\0\0\0\x8A\xBB\0\0\0\x8C\x8A\xBB\0\0\xDF\x001\0\0\0\0" + String.fromCharCode(e2.fixedPitch ? 9 : 0) + "\0\0\0\0\0\0" + string32(a2) + string32(r2) + string32(s2) + string32(n2) + "*21*" + string16(e2.italicAngle ? 1 : 0) + string16(o2 || e2.firstChar) + string16(g2 || e2.lastChar) + string16(Q2) + string16(E2) + "\0d" + string16(u2) + string16(d2) + "\0\0\0\0\0\0\0\0" + string16(e2.xHeight) + string16(e2.capHeight) + string16(0) + string16(o2 || e2.firstChar) + "\0";
  }
  function createPostTable(e2) {
    return "\0\0\0" + string32(Math.floor(65536 * e2.italicAngle)) + "\0\0\0\0" + string32(e2.fixedPitch ? 1 : 0) + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
  }
  function createPostscriptName(e2) {
    return e2.replaceAll(/[^\x21-\x7E]|[[\](){}<>/%]/g, "").slice(0, 63);
  }
  function createNameTable(e2, t2) {
    t2 || (t2 = [
      [],
      []
    ]);
    const i2 = [
      t2[0][0] || "Original licence",
      t2[0][1] || e2,
      t2[0][2] || "Unknown",
      t2[0][3] || "uniqueID",
      t2[0][4] || e2,
      t2[0][5] || "Version 0.11",
      t2[0][6] || createPostscriptName(e2),
      t2[0][7] || "Unknown",
      t2[0][8] || "Unknown",
      t2[0][9] || "Unknown"
    ], a2 = [];
    let r2, s2, n2, o2, g2;
    for (r2 = 0, s2 = i2.length; r2 < s2; r2++) {
      g2 = t2[1][r2] || i2[r2];
      const e3 = [];
      for (n2 = 0, o2 = g2.length; n2 < o2; n2++) e3.push(string16(g2.charCodeAt(n2)));
      a2.push(e3.join(""));
    }
    const c2 = [
      i2,
      a2
    ], C2 = [
      "\0",
      "\0"
    ], h2 = [
      "\0\0",
      "\0"
    ], l2 = [
      "\0\0",
      "	"
    ], Q2 = i2.length * C2.length;
    let E2 = "\0\0" + string16(Q2) + string16(12 * Q2 + 6), u2 = 0;
    for (r2 = 0, s2 = C2.length; r2 < s2; r2++) {
      const e3 = c2[r2];
      for (n2 = 0, o2 = e3.length; n2 < o2; n2++) {
        g2 = e3[n2];
        E2 += C2[r2] + h2[r2] + l2[r2] + string16(n2) + string16(g2.length) + string16(u2);
        u2 += g2.length;
      }
    }
    E2 += i2.join("") + a2.join("");
    return E2;
  }
  class Font {
    constructor(e2, t2, i2) {
      var _a4;
      this.name = e2;
      this.psName = null;
      this.mimetype = null;
      this.disableFontFace = false;
      this.loadedName = i2.loadedName;
      this.isType3Font = i2.isType3Font;
      this.missingFile = false;
      this.cssFontInfo = i2.cssFontInfo;
      this._charsCache = /* @__PURE__ */ Object.create(null);
      this._glyphCache = /* @__PURE__ */ Object.create(null);
      let a2 = !!(i2.flags & Pi);
      if (!a2 && !i2.isSimulatedFlags) {
        const t3 = e2.replaceAll(/[,_]/g, "-").split("-", 1)[0], i3 = $i();
        for (const e3 of t3.split("+")) if (i3[e3]) {
          a2 = true;
          break;
        }
      }
      this.isSerifFont = a2;
      this.isSymbolicFont = !!(i2.flags & Wi);
      this.isMonospace = !!(i2.flags & Oi);
      let { type: r2, subtype: s2 } = i2;
      this.type = r2;
      this.subtype = s2;
      this.systemFontInfo = i2.systemFontInfo;
      const n2 = e2.match(/^InvalidPDFjsFont_(.*)_\d+$/);
      this.isInvalidPDFjsFont = !!n2;
      this.isInvalidPDFjsFont ? this.fallbackName = n2[1] : this.isMonospace ? this.fallbackName = "monospace" : this.isSerifFont ? this.fallbackName = "serif" : this.fallbackName = "sans-serif";
      if ((_a4 = this.systemFontInfo) == null ? void 0 : _a4.guessFallback) {
        this.systemFontInfo.guessFallback = false;
        this.systemFontInfo.css += `,${this.fallbackName}`;
      }
      this.differences = i2.differences;
      this.widths = i2.widths;
      this.defaultWidth = i2.defaultWidth;
      this.composite = i2.composite;
      this.cMap = i2.cMap;
      this.capHeight = i2.capHeight / da;
      this.ascent = i2.ascent / da;
      this.descent = i2.descent / da;
      this.lineHeight = this.ascent - this.descent;
      this.fontMatrix = i2.fontMatrix;
      this.bbox = i2.bbox;
      this.defaultEncoding = i2.defaultEncoding;
      this.toUnicode = i2.toUnicode;
      this.toFontChar = [];
      if ("Type3" === i2.type) {
        for (let e3 = 0; e3 < 256; e3++) this.toFontChar[e3] = this.differences[e3] || i2.defaultEncoding[e3];
        return;
      }
      this.cidEncoding = i2.cidEncoding || "";
      this.vertical = !!i2.vertical;
      if (this.vertical) {
        this.vmetrics = i2.vmetrics;
        this.defaultVMetrics = i2.defaultVMetrics;
      }
      if (!t2 || t2.isEmpty) {
        t2 && warn('Font file is empty in "' + e2 + '" (' + this.loadedName + ")");
        this.fallbackToSystemFont(i2);
        return;
      }
      [r2, s2] = getFontFileType(t2, i2);
      r2 === this.type && s2 === this.subtype || info(`Inconsistent font file Type/SubType, expected: ${this.type}/${this.subtype} but found: ${r2}/${s2}.`);
      let o2;
      try {
        switch (r2) {
          case "MMType1":
            info("MMType1 font (" + e2 + "), falling back to Type1.");
          case "Type1":
          case "CIDFontType0":
            this.mimetype = "font/opentype";
            const a3 = "Type1C" === s2 || "CIDFontType0C" === s2 ? new CFFFont(t2, i2) : new Type1Font(e2, t2, i2);
            adjustWidths(i2);
            o2 = this.convert(e2, a3, i2);
            break;
          case "OpenType":
          case "TrueType":
          case "CIDFontType2":
            this.mimetype = "font/opentype";
            o2 = this.checkAndRepair(e2, t2, i2);
            if (this.isOpenType) {
              adjustWidths(i2);
              r2 = "OpenType";
            }
            break;
          default:
            throw new FormatError(`Font ${r2} is not supported`);
        }
      } catch (e3) {
        warn(e3);
        this.fallbackToSystemFont(i2);
        return;
      }
      amendFallbackToUnicode(i2);
      this.data = o2;
      this.type = r2;
      this.subtype = s2;
      this.fontMatrix = i2.fontMatrix;
      this.widths = i2.widths;
      this.defaultWidth = i2.defaultWidth;
      this.toUnicode = i2.toUnicode;
      this.seacMap = i2.seacMap;
    }
    get renderer() {
      return shadow(this, "renderer", FontRendererFactory.create(this, qi));
    }
    exportData(e2 = false) {
      const t2 = e2 ? [
        ...fa,
        ...pa
      ] : fa, i2 = /* @__PURE__ */ Object.create(null);
      let a2, r2;
      for (a2 of t2) {
        r2 = this[a2];
        void 0 !== r2 && (i2[a2] = r2);
      }
      return i2;
    }
    fallbackToSystemFont(e2) {
      this.missingFile = true;
      const { name: t2, type: i2 } = this;
      let a2 = normalizeFontName(t2);
      const r2 = Vi(), s2 = zi(), n2 = !!r2[a2], o2 = !(!s2[a2] || !r2[s2[a2]]);
      a2 = r2[a2] || s2[a2] || a2;
      const g2 = sa()[a2];
      if (g2) {
        isNaN(this.ascent) && (this.ascent = g2.ascent / da);
        isNaN(this.descent) && (this.descent = g2.descent / da);
        isNaN(this.capHeight) && (this.capHeight = g2.capHeight / da);
      }
      this.bold = /bold/gi.test(a2);
      this.italic = /oblique|italic/gi.test(a2);
      this.black = /Black/g.test(t2);
      const c2 = /Narrow/g.test(t2);
      this.remeasure = (!n2 || c2) && Object.keys(this.widths).length > 0;
      if ((n2 || o2) && "CIDFontType2" === i2 && this.cidEncoding.startsWith("Identity-")) {
        const i3 = e2.cidToGidMap, a3 = [];
        applyStandardFontGlyphMap(a3, ea());
        /Arial-?Black/i.test(t2) ? applyStandardFontGlyphMap(a3, ta()) : /Calibri/i.test(t2) && applyStandardFontGlyphMap(a3, ia());
        if (i3) {
          for (const e3 in a3) {
            const t3 = a3[e3];
            void 0 !== i3[t3] && (a3[+e3] = i3[t3]);
          }
          i3.length !== this.toUnicode.length && e2.hasIncludedToUnicodeMap && this.toUnicode instanceof IdentityToUnicodeMap && this.toUnicode.forEach(function(e3, t3) {
            const r3 = a3[e3];
            void 0 === i3[r3] && (a3[+e3] = t3);
          });
        }
        this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(e3, t3) {
          a3[+e3] = t3;
        });
        this.toFontChar = a3;
        this.toUnicode = new ToUnicodeMap(a3);
      } else if (/Symbol/i.test(a2)) this.toFontChar = buildToFontChar(Di, Hi(), this.differences);
      else if (/Dingbats/i.test(a2)) this.toFontChar = buildToFontChar(Fi, Ji(), this.differences);
      else if (n2 || o2) {
        const e3 = buildToFontChar(this.defaultEncoding, Hi(), this.differences);
        "CIDFontType2" !== i2 || this.cidEncoding.startsWith("Identity-") || this.toUnicode instanceof IdentityToUnicodeMap || this.toUnicode.forEach(function(t3, i3) {
          e3[+t3] = i3;
        });
        this.toFontChar = e3;
      } else {
        const e3 = Hi(), i3 = [];
        this.toUnicode.forEach((t3, a3) => {
          if (!this.composite) {
            const i4 = getUnicodeForGlyph(this.differences[t3] || this.defaultEncoding[t3], e3);
            -1 !== i4 && (a3 = i4);
          }
          i3[+t3] = a3;
        });
        this.composite && this.toUnicode instanceof IdentityToUnicodeMap && /Tahoma|Verdana/i.test(t2) && applyStandardFontGlyphMap(i3, ea());
        this.toFontChar = i3;
      }
      amendFallbackToUnicode(e2);
      this.loadedName = a2.split("-", 1)[0];
    }
    checkAndRepair(e2, t2, i2) {
      var _a4, _b, _c;
      const a2 = [
        "OS/2",
        "cmap",
        "head",
        "hhea",
        "hmtx",
        "maxp",
        "name",
        "post",
        "loca",
        "glyf",
        "fpgm",
        "prep",
        "cvt ",
        "CFF "
      ];
      function readTables(e3, t3) {
        const i3 = /* @__PURE__ */ Object.create(null);
        i3["OS/2"] = null;
        i3.cmap = null;
        i3.head = null;
        i3.hhea = null;
        i3.hmtx = null;
        i3.maxp = null;
        i3.name = null;
        i3.post = null;
        for (let r3 = 0; r3 < t3; r3++) {
          const t4 = readTableEntry(e3);
          a2.includes(t4.tag) && (0 !== t4.length && (i3[t4.tag] = t4));
        }
        return i3;
      }
      function readTableEntry(e3) {
        const t3 = e3.getString(4), i3 = e3.getInt32() >>> 0, a3 = e3.getInt32() >>> 0, r3 = e3.getInt32() >>> 0, s3 = e3.pos;
        e3.pos = e3.start || 0;
        e3.skip(a3);
        const n3 = e3.getBytes(r3);
        e3.pos = s3;
        if ("head" === t3) {
          n3[8] = n3[9] = n3[10] = n3[11] = 0;
          n3[17] |= 32;
        }
        return {
          tag: t3,
          checksum: i3,
          length: r3,
          offset: a3,
          data: n3
        };
      }
      function readOpenTypeHeader(e3) {
        return {
          version: e3.getString(4),
          numTables: e3.getUint16(),
          searchRange: e3.getUint16(),
          entrySelector: e3.getUint16(),
          rangeShift: e3.getUint16()
        };
      }
      function sanitizeGlyph(e3, t3, i3, a3, r3, s3) {
        const n3 = {
          length: 0,
          sizeOfInstructions: 0
        };
        if (t3 < 0 || t3 >= e3.length || i3 > e3.length || i3 - t3 <= 12) return n3;
        const o3 = e3.subarray(t3, i3), g3 = signedInt16(o3[2], o3[3]), c3 = signedInt16(o3[4], o3[5]), C3 = signedInt16(o3[6], o3[7]), h3 = signedInt16(o3[8], o3[9]);
        if (g3 > C3) {
          writeSignedInt16(o3, 2, C3);
          writeSignedInt16(o3, 6, g3);
        }
        if (c3 > h3) {
          writeSignedInt16(o3, 4, h3);
          writeSignedInt16(o3, 8, c3);
        }
        const l3 = signedInt16(o3[0], o3[1]);
        if (l3 < 0) {
          if (l3 < -1) return n3;
          a3.set(o3, r3);
          n3.length = o3.length;
          return n3;
        }
        let Q3, E3 = 10, u3 = 0;
        for (Q3 = 0; Q3 < l3; Q3++) {
          u3 = (o3[E3] << 8 | o3[E3 + 1]) + 1;
          E3 += 2;
        }
        const d3 = E3, f3 = o3[E3] << 8 | o3[E3 + 1];
        n3.sizeOfInstructions = f3;
        E3 += 2 + f3;
        const p3 = E3;
        let m3 = 0;
        for (Q3 = 0; Q3 < u3; Q3++) {
          const e4 = o3[E3++];
          192 & e4 && (o3[E3 - 1] = 63 & e4);
          let t4 = 2;
          2 & e4 ? t4 = 1 : 16 & e4 && (t4 = 0);
          let i4 = 2;
          4 & e4 ? i4 = 1 : 32 & e4 && (i4 = 0);
          const a4 = t4 + i4;
          m3 += a4;
          if (8 & e4) {
            const e5 = o3[E3++];
            0 === e5 && (o3[E3 - 1] ^= 8);
            Q3 += e5;
            m3 += e5 * a4;
          }
        }
        if (0 === m3) return n3;
        let y3 = E3 + m3;
        if (y3 > o3.length) return n3;
        if (!s3 && f3 > 0) {
          a3.set(o3.subarray(0, d3), r3);
          a3.set([
            0,
            0
          ], r3 + d3);
          a3.set(o3.subarray(p3, y3), r3 + d3 + 2);
          y3 -= f3;
          o3.length - y3 > 3 && (y3 = y3 + 3 & -4);
          n3.length = y3;
          return n3;
        }
        if (o3.length - y3 > 3) {
          y3 = y3 + 3 & -4;
          a3.set(o3.subarray(0, y3), r3);
          n3.length = y3;
          return n3;
        }
        a3.set(o3, r3);
        n3.length = o3.length;
        return n3;
      }
      function readNameTable(e3) {
        const i3 = (t2.start || 0) + e3.offset;
        t2.pos = i3;
        const a3 = [
          [],
          []
        ], r3 = [], s3 = e3.length, n3 = i3 + s3;
        if (0 !== t2.getUint16() || s3 < 6) return [
          a3,
          r3
        ];
        const o3 = t2.getUint16(), g3 = t2.getUint16();
        let c3, C3;
        for (c3 = 0; c3 < o3 && t2.pos + 12 <= n3; c3++) {
          const e4 = {
            platform: t2.getUint16(),
            encoding: t2.getUint16(),
            language: t2.getUint16(),
            name: t2.getUint16(),
            length: t2.getUint16(),
            offset: t2.getUint16()
          };
          (isMacNameRecord(e4) || isWinNameRecord(e4)) && r3.push(e4);
        }
        for (c3 = 0, C3 = r3.length; c3 < C3; c3++) {
          const e4 = r3[c3];
          if (e4.length <= 0) continue;
          const s4 = i3 + g3 + e4.offset;
          if (s4 + e4.length > n3) continue;
          t2.pos = s4;
          const o4 = e4.name;
          if (e4.encoding) {
            let i4 = "";
            for (let a4 = 0, r4 = e4.length; a4 < r4; a4 += 2) i4 += String.fromCharCode(t2.getUint16());
            a3[1][o4] = i4;
          } else a3[0][o4] = t2.getString(e4.length);
        }
        return [
          a3,
          r3
        ];
      }
      const r2 = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -2,
        -2,
        -2,
        -2,
        0,
        0,
        -2,
        -5,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        -1,
        0,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -999,
        0,
        1,
        0,
        -1,
        -2,
        0,
        -1,
        -2,
        -1,
        -1,
        0,
        -1,
        -1,
        0,
        0,
        -999,
        -999,
        -1,
        -1,
        -1,
        -1,
        -2,
        -999,
        -2,
        -2,
        -999,
        0,
        -2,
        -2,
        0,
        0,
        -2,
        0,
        -2,
        0,
        0,
        0,
        -2,
        -1,
        -1,
        1,
        1,
        0,
        0,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        -1,
        0,
        -1,
        -1,
        0,
        -999,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        -2,
        -999,
        -999,
        -999,
        -999,
        -999,
        -1,
        -1,
        -2,
        -2,
        0,
        0,
        0,
        0,
        -1,
        -1,
        -999,
        -2,
        -2,
        0,
        0,
        -1,
        -2,
        -2,
        0,
        0,
        0,
        -1,
        -1,
        -1,
        -2
      ];
      function sanitizeTTProgram(e3, t3) {
        let i3, a3, s3, n3, o3, g3 = e3.data, c3 = 0, C3 = 0, h3 = 0;
        const l3 = [], Q3 = [], E3 = [];
        let u3 = t3.tooComplexToFollowFunctions, d3 = false, f3 = 0, p3 = 0;
        for (let e4 = g3.length; c3 < e4; ) {
          const e5 = g3[c3++];
          if (64 === e5) {
            a3 = g3[c3++];
            if (d3 || p3) c3 += a3;
            else for (i3 = 0; i3 < a3; i3++) l3.push(g3[c3++]);
          } else if (65 === e5) {
            a3 = g3[c3++];
            if (d3 || p3) c3 += 2 * a3;
            else for (i3 = 0; i3 < a3; i3++) {
              s3 = g3[c3++];
              l3.push(s3 << 8 | g3[c3++]);
            }
          } else if (176 == (248 & e5)) {
            a3 = e5 - 176 + 1;
            if (d3 || p3) c3 += a3;
            else for (i3 = 0; i3 < a3; i3++) l3.push(g3[c3++]);
          } else if (184 == (248 & e5)) {
            a3 = e5 - 184 + 1;
            if (d3 || p3) c3 += 2 * a3;
            else for (i3 = 0; i3 < a3; i3++) {
              s3 = g3[c3++];
              l3.push(signedInt16(s3, g3[c3++]));
            }
          } else if (43 !== e5 || u3) if (44 !== e5 || u3) {
            if (45 === e5) if (d3) {
              d3 = false;
              C3 = c3;
            } else {
              o3 = Q3.pop();
              if (!o3) {
                warn("TT: ENDF bad stack");
                t3.hintsValid = false;
                return;
              }
              n3 = E3.pop();
              g3 = o3.data;
              c3 = o3.i;
              t3.functionsStackDeltas[n3] = l3.length - o3.stackTop;
            }
            else if (137 === e5) {
              if (d3 || p3) {
                warn("TT: nested IDEFs not allowed");
                u3 = true;
              }
              d3 = true;
              h3 = c3;
            } else if (88 === e5) ++f3;
            else if (27 === e5) p3 = f3;
            else if (89 === e5) {
              p3 === f3 && (p3 = 0);
              --f3;
            } else if (28 === e5 && !d3 && !p3) {
              const e6 = l3.at(-1);
              e6 > 0 && (c3 += e6 - 1);
            }
          } else {
            if (d3 || p3) {
              warn("TT: nested FDEFs not allowed");
              u3 = true;
            }
            d3 = true;
            h3 = c3;
            n3 = l3.pop();
            t3.functionsDefined[n3] = {
              data: g3,
              i: c3
            };
          }
          else if (!d3 && !p3) {
            n3 = l3.at(-1);
            if (isNaN(n3)) info("TT: CALL empty stack (or invalid entry).");
            else {
              t3.functionsUsed[n3] = true;
              if (n3 in t3.functionsStackDeltas) {
                const e6 = l3.length + t3.functionsStackDeltas[n3];
                if (e6 < 0) {
                  warn("TT: CALL invalid functions stack delta.");
                  t3.hintsValid = false;
                  return;
                }
                l3.length = e6;
              } else if (n3 in t3.functionsDefined && !E3.includes(n3)) {
                Q3.push({
                  data: g3,
                  i: c3,
                  stackTop: l3.length - 1
                });
                E3.push(n3);
                o3 = t3.functionsDefined[n3];
                if (!o3) {
                  warn("TT: CALL non-existent function");
                  t3.hintsValid = false;
                  return;
                }
                g3 = o3.data;
                c3 = o3.i;
              }
            }
          }
          if (!d3 && !p3) {
            let t4 = 0;
            e5 <= 142 ? t4 = r2[e5] : e5 >= 192 && e5 <= 223 ? t4 = -1 : e5 >= 224 && (t4 = -2);
            if (e5 >= 113 && e5 <= 117) {
              a3 = l3.pop();
              isNaN(a3) || (t4 = 2 * -a3);
            }
            for (; t4 < 0 && l3.length > 0; ) {
              l3.pop();
              t4++;
            }
            for (; t4 > 0; ) {
              l3.push(NaN);
              t4--;
            }
          }
        }
        t3.tooComplexToFollowFunctions = u3;
        const m3 = [
          g3
        ];
        c3 > g3.length && m3.push(new Uint8Array(c3 - g3.length));
        if (h3 > C3) {
          warn("TT: complementing a missing function tail");
          m3.push(new Uint8Array([
            34,
            45
          ]));
        }
        !function foldTTTable(e4, t4) {
          if (t4.length > 1) {
            let i4, a4, r3 = 0;
            for (i4 = 0, a4 = t4.length; i4 < a4; i4++) r3 += t4[i4].length;
            r3 = r3 + 3 & -4;
            const s4 = new Uint8Array(r3);
            let n4 = 0;
            for (i4 = 0, a4 = t4.length; i4 < a4; i4++) {
              s4.set(t4[i4], n4);
              n4 += t4[i4].length;
            }
            e4.data = s4;
            e4.length = r3;
          }
        }(e3, m3);
      }
      let s2, n2, o2, g2;
      if (isTrueTypeCollectionFile(t2 = new Stream(new Uint8Array(t2.getBytes())))) {
        const e3 = function readTrueTypeCollectionData(e4, t3) {
          var _a5;
          const { numFonts: i3, offsetTable: a3 } = function readTrueTypeCollectionHeader(e5) {
            const t4 = e5.getString(4);
            assert("ttcf" === t4, "Must be a TrueType Collection font.");
            const i4 = e5.getUint16(), a4 = e5.getUint16(), r4 = e5.getInt32() >>> 0, s4 = [];
            for (let t5 = 0; t5 < r4; t5++) s4.push(e5.getInt32() >>> 0);
            const n3 = {
              ttcTag: t4,
              majorVersion: i4,
              minorVersion: a4,
              numFonts: r4,
              offsetTable: s4
            };
            switch (i4) {
              case 1:
                return n3;
              case 2:
                n3.dsigTag = e5.getInt32() >>> 0;
                n3.dsigLength = e5.getInt32() >>> 0;
                n3.dsigOffset = e5.getInt32() >>> 0;
                return n3;
            }
            throw new FormatError(`Invalid TrueType Collection majorVersion: ${i4}.`);
          }(e4), r3 = t3.split("+");
          let s3;
          for (let n3 = 0; n3 < i3; n3++) {
            e4.pos = (e4.start || 0) + a3[n3];
            const i4 = readOpenTypeHeader(e4), o3 = readTables(e4, i4.numTables);
            if (!o3.name) throw new FormatError('TrueType Collection font must contain a "name" table.');
            const [g3] = readNameTable(o3.name);
            for (let e5 = 0, a4 = g3.length; e5 < a4; e5++) for (let a5 = 0, n4 = g3[e5].length; a5 < n4; a5++) {
              const n5 = (_a5 = g3[e5][a5]) == null ? void 0 : _a5.replaceAll(/\s/g, "");
              if (n5) {
                if (n5 === t3) return {
                  header: i4,
                  tables: o3
                };
                if (!(r3.length < 2)) for (const e6 of r3) n5 === e6 && (s3 = {
                  name: e6,
                  header: i4,
                  tables: o3
                });
              }
            }
          }
          if (s3) {
            warn(`TrueType Collection does not contain "${t3}" font, falling back to "${s3.name}" font instead.`);
            return {
              header: s3.header,
              tables: s3.tables
            };
          }
          throw new FormatError(`TrueType Collection does not contain "${t3}" font.`);
        }(t2, this.name);
        s2 = e3.header;
        n2 = e3.tables;
      } else {
        s2 = readOpenTypeHeader(t2);
        n2 = readTables(t2, s2.numTables);
      }
      const c2 = !n2["CFF "];
      if (c2) {
        if (!n2.loca) throw new FormatError('Required "loca" table is not found');
        if (!n2.glyf) {
          warn('Required "glyf" table is not found -- trying to recover.');
          n2.glyf = {
            tag: "glyf",
            data: new Uint8Array(0)
          };
        }
        this.isOpenType = false;
      } else {
        const t3 = i2.composite && (((_a4 = i2.cidToGidMap) == null ? void 0 : _a4.length) > 0 || !(i2.cMap instanceof IdentityCMap));
        if ("OTTO" === s2.version && !t3 || !n2.head || !n2.hhea || !n2.maxp || !n2.post) {
          g2 = new Stream(n2["CFF "].data);
          o2 = new CFFFont(g2, i2);
          adjustWidths(i2);
          return this.convert(e2, o2, i2);
        }
        delete n2.glyf;
        delete n2.loca;
        delete n2.fpgm;
        delete n2.prep;
        delete n2["cvt "];
        this.isOpenType = true;
      }
      if (!n2.maxp) throw new FormatError('Required "maxp" table is not found');
      t2.pos = (t2.start || 0) + n2.maxp.offset;
      let C2 = t2.getInt32();
      const h2 = t2.getUint16();
      if (65536 !== C2 && 20480 !== C2) {
        if (6 === n2.maxp.length) C2 = 20480;
        else {
          if (!(n2.maxp.length >= 32)) throw new FormatError('"maxp" table has a wrong version number');
          C2 = 65536;
        }
        !function writeUint32(e3, t3, i3) {
          e3[t3 + 3] = 255 & i3;
          e3[t3 + 2] = i3 >>> 8;
          e3[t3 + 1] = i3 >>> 16;
          e3[t3] = i3 >>> 24;
        }(n2.maxp.data, 0, C2);
      }
      if (((_b = i2.scaleFactors) == null ? void 0 : _b.length) === h2 && c2) {
        const { scaleFactors: e3 } = i2, t3 = int16(n2.head.data[50], n2.head.data[51]), a3 = new GlyfTable({
          glyfTable: n2.glyf.data,
          isGlyphLocationsLong: t3,
          locaTable: n2.loca.data,
          numGlyphs: h2
        });
        a3.scale(e3);
        const { glyf: r3, loca: s3, isLocationLong: o3 } = a3.write();
        n2.glyf.data = r3;
        n2.loca.data = s3;
        if (o3 !== !!t3) {
          n2.head.data[50] = 0;
          n2.head.data[51] = o3 ? 1 : 0;
        }
        const g3 = n2.hmtx.data;
        for (let t4 = 0; t4 < h2; t4++) {
          const i3 = 4 * t4, a4 = Math.round(e3[t4] * int16(g3[i3], g3[i3 + 1]));
          g3[i3] = a4 >> 8 & 255;
          g3[i3 + 1] = 255 & a4;
          writeSignedInt16(g3, i3 + 2, Math.round(e3[t4] * signedInt16(g3[i3 + 2], g3[i3 + 3])));
        }
      }
      let l2 = h2 + 1, Q2 = true;
      if (l2 > 65535) {
        Q2 = false;
        l2 = h2;
        warn("Not enough space in glyfs to duplicate first glyph.");
      }
      let E2 = 0, u2 = 0;
      if (C2 >= 65536 && n2.maxp.length >= 32) {
        t2.pos += 8;
        if (t2.getUint16() > 2) {
          n2.maxp.data[14] = 0;
          n2.maxp.data[15] = 2;
        }
        t2.pos += 4;
        E2 = t2.getUint16();
        t2.pos += 4;
        u2 = t2.getUint16();
      }
      n2.maxp.data[4] = l2 >> 8;
      n2.maxp.data[5] = 255 & l2;
      const d2 = function sanitizeTTPrograms(e3, t3, i3, a3) {
        const r3 = {
          functionsDefined: [],
          functionsUsed: [],
          functionsStackDeltas: [],
          tooComplexToFollowFunctions: false,
          hintsValid: true
        };
        e3 && sanitizeTTProgram(e3, r3);
        t3 && sanitizeTTProgram(t3, r3);
        e3 && function checkInvalidFunctions(e4, t4) {
          if (!e4.tooComplexToFollowFunctions) if (e4.functionsDefined.length > t4) {
            warn("TT: more functions defined than expected");
            e4.hintsValid = false;
          } else for (let i4 = 0, a4 = e4.functionsUsed.length; i4 < a4; i4++) {
            if (i4 > t4) {
              warn("TT: invalid function id: " + i4);
              e4.hintsValid = false;
              return;
            }
            if (e4.functionsUsed[i4] && !e4.functionsDefined[i4]) {
              warn("TT: undefined function: " + i4);
              e4.hintsValid = false;
              return;
            }
          }
        }(r3, a3);
        if (i3 && 1 & i3.length) {
          const e4 = new Uint8Array(i3.length + 1);
          e4.set(i3.data);
          i3.data = e4;
        }
        return r3.hintsValid;
      }(n2.fpgm, n2.prep, n2["cvt "], E2);
      if (!d2) {
        delete n2.fpgm;
        delete n2.prep;
        delete n2["cvt "];
      }
      !function sanitizeMetrics(e3, t3, i3, a3, r3, s3) {
        if (!t3) {
          i3 && (i3.data = null);
          return;
        }
        e3.pos = (e3.start || 0) + t3.offset;
        e3.pos += 4;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        e3.pos += 2;
        const n3 = e3.getUint16();
        e3.pos += 8;
        e3.pos += 2;
        let o3 = e3.getUint16();
        if (0 !== n3) {
          if (!(2 & int16(a3.data[44], a3.data[45]))) {
            t3.data[22] = 0;
            t3.data[23] = 0;
          }
        }
        if (o3 > r3) {
          info(`The numOfMetrics (${o3}) should not be greater than the numGlyphs (${r3}).`);
          o3 = r3;
          t3.data[34] = (65280 & o3) >> 8;
          t3.data[35] = 255 & o3;
        }
        const g3 = r3 - o3 - (i3.length - 4 * o3 >> 1);
        if (g3 > 0) {
          const e4 = new Uint8Array(i3.length + 2 * g3);
          e4.set(i3.data);
          if (s3) {
            e4[i3.length] = i3.data[2];
            e4[i3.length + 1] = i3.data[3];
          }
          i3.data = e4;
        }
      }(t2, n2.hhea, n2.hmtx, n2.head, l2, Q2);
      if (!n2.head) throw new FormatError('Required "head" table is not found');
      !function sanitizeHead(e3, t3, i3) {
        const a3 = e3.data, r3 = function int32(e4, t4, i4, a4) {
          return (e4 << 24) + (t4 << 16) + (i4 << 8) + a4;
        }(a3[0], a3[1], a3[2], a3[3]);
        if (r3 >> 16 != 1) {
          info("Attempting to fix invalid version in head table: " + r3);
          a3[0] = 0;
          a3[1] = 1;
          a3[2] = 0;
          a3[3] = 0;
        }
        const s3 = int16(a3[50], a3[51]);
        if (s3 < 0 || s3 > 1) {
          info("Attempting to fix invalid indexToLocFormat in head table: " + s3);
          const e4 = t3 + 1;
          if (i3 === e4 << 1) {
            a3[50] = 0;
            a3[51] = 0;
          } else {
            if (i3 !== e4 << 2) throw new FormatError("Could not fix indexToLocFormat: " + s3);
            a3[50] = 0;
            a3[51] = 1;
          }
        }
      }(n2.head, h2, c2 ? n2.loca.length : 0);
      let f2 = /* @__PURE__ */ Object.create(null);
      if (c2) {
        const e3 = int16(n2.head.data[50], n2.head.data[51]), t3 = function sanitizeGlyphLocations(e4, t4, i3, a3, r3, s3, n3) {
          let o3, g3, c3;
          if (a3) {
            o3 = 4;
            g3 = function fontItemDecodeLong(e5, t5) {
              return e5[t5] << 24 | e5[t5 + 1] << 16 | e5[t5 + 2] << 8 | e5[t5 + 3];
            };
            c3 = function fontItemEncodeLong(e5, t5, i4) {
              e5[t5] = i4 >>> 24 & 255;
              e5[t5 + 1] = i4 >> 16 & 255;
              e5[t5 + 2] = i4 >> 8 & 255;
              e5[t5 + 3] = 255 & i4;
            };
          } else {
            o3 = 2;
            g3 = function fontItemDecode(e5, t5) {
              return e5[t5] << 9 | e5[t5 + 1] << 1;
            };
            c3 = function fontItemEncode(e5, t5, i4) {
              e5[t5] = i4 >> 9 & 255;
              e5[t5 + 1] = i4 >> 1 & 255;
            };
          }
          const C3 = s3 ? i3 + 1 : i3, h3 = o3 * (1 + C3), l3 = new Uint8Array(h3);
          l3.set(e4.data.subarray(0, h3));
          e4.data = l3;
          const Q3 = t4.data, E3 = Q3.length, u3 = new Uint8Array(E3);
          let d3, f3;
          const p3 = [];
          for (d3 = 0, f3 = 0; d3 < i3 + 1; d3++, f3 += o3) {
            let e5 = g3(l3, f3);
            e5 > E3 && (e5 = E3);
            p3.push({
              index: d3,
              offset: e5,
              endOffset: 0
            });
          }
          p3.sort((e5, t5) => e5.offset - t5.offset);
          for (d3 = 0; d3 < i3; d3++) p3[d3].endOffset = p3[d3 + 1].offset;
          p3.sort((e5, t5) => e5.index - t5.index);
          for (d3 = 0; d3 < i3; d3++) {
            const { offset: e5, endOffset: t5 } = p3[d3];
            if (0 !== e5 || 0 !== t5) break;
            const i4 = p3[d3 + 1].offset;
            if (0 !== i4) {
              p3[d3].endOffset = i4;
              break;
            }
          }
          const m3 = p3.at(-2);
          0 !== m3.offset && 0 === m3.endOffset && (m3.endOffset = E3);
          const y3 = /* @__PURE__ */ Object.create(null);
          let w3 = 0;
          c3(l3, 0, w3);
          for (d3 = 0, f3 = o3; d3 < i3; d3++, f3 += o3) {
            const e5 = sanitizeGlyph(Q3, p3[d3].offset, p3[d3].endOffset, u3, w3, r3), t5 = e5.length;
            0 === t5 && (y3[d3] = true);
            e5.sizeOfInstructions > n3 && (n3 = e5.sizeOfInstructions);
            w3 += t5;
            c3(l3, f3, w3);
          }
          if (0 === w3) {
            const e5 = new Uint8Array([
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              49,
              0
            ]);
            for (d3 = 0, f3 = o3; d3 < C3; d3++, f3 += o3) c3(l3, f3, e5.length);
            t4.data = e5;
          } else if (s3) {
            const i4 = g3(l3, o3);
            if (u3.length > i4 + w3) t4.data = u3.subarray(0, i4 + w3);
            else {
              t4.data = new Uint8Array(i4 + w3);
              t4.data.set(u3.subarray(0, w3));
            }
            t4.data.set(u3.subarray(0, i4), w3);
            c3(e4.data, l3.length - o3, w3 + i4);
          } else t4.data = u3.subarray(0, w3);
          return {
            missingGlyphs: y3,
            maxSizeOfInstructions: n3
          };
        }(n2.loca, n2.glyf, h2, e3, d2, Q2, u2);
        f2 = t3.missingGlyphs;
        if (C2 >= 65536 && n2.maxp.length >= 32) {
          n2.maxp.data[26] = t3.maxSizeOfInstructions >> 8;
          n2.maxp.data[27] = 255 & t3.maxSizeOfInstructions;
        }
      }
      if (!n2.hhea) throw new FormatError('Required "hhea" table is not found');
      if (0 === n2.hhea.data[10] && 0 === n2.hhea.data[11]) {
        n2.hhea.data[10] = 255;
        n2.hhea.data[11] = 255;
      }
      const p2 = {
        unitsPerEm: int16(n2.head.data[18], n2.head.data[19]),
        yMax: signedInt16(n2.head.data[42], n2.head.data[43]),
        yMin: signedInt16(n2.head.data[38], n2.head.data[39]),
        ascent: signedInt16(n2.hhea.data[4], n2.hhea.data[5]),
        descent: signedInt16(n2.hhea.data[6], n2.hhea.data[7]),
        lineGap: signedInt16(n2.hhea.data[8], n2.hhea.data[9])
      };
      this.ascent = p2.ascent / p2.unitsPerEm;
      this.descent = p2.descent / p2.unitsPerEm;
      this.lineGap = p2.lineGap / p2.unitsPerEm;
      if ((_c = this.cssFontInfo) == null ? void 0 : _c.lineHeight) {
        this.lineHeight = this.cssFontInfo.metrics.lineHeight;
        this.lineGap = this.cssFontInfo.metrics.lineGap;
      } else this.lineHeight = this.ascent - this.descent + this.lineGap;
      n2.post && function readPostScriptTable(e3, i3, a3) {
        const r3 = (t2.start || 0) + e3.offset;
        t2.pos = r3;
        const s3 = r3 + e3.length, n3 = t2.getInt32();
        t2.skip(28);
        let o3, g3, c3 = true;
        switch (n3) {
          case 65536:
            o3 = Xi;
            break;
          case 131072:
            const e4 = t2.getUint16();
            if (e4 !== a3) {
              c3 = false;
              break;
            }
            const r4 = [];
            for (g3 = 0; g3 < e4; ++g3) {
              const e5 = t2.getUint16();
              if (e5 >= 32768) {
                c3 = false;
                break;
              }
              r4.push(e5);
            }
            if (!c3) break;
            const C3 = [], h3 = [];
            for (; t2.pos < s3; ) {
              const e5 = t2.getByte();
              h3.length = e5;
              for (g3 = 0; g3 < e5; ++g3) h3[g3] = String.fromCharCode(t2.getByte());
              C3.push(h3.join(""));
            }
            o3 = [];
            for (g3 = 0; g3 < e4; ++g3) {
              const e5 = r4[g3];
              e5 < 258 ? o3.push(Xi[e5]) : o3.push(C3[e5 - 258]);
            }
            break;
          case 196608:
            break;
          default:
            warn("Unknown/unsupported post table version " + n3);
            c3 = false;
            i3.defaultEncoding && (o3 = i3.defaultEncoding);
        }
        i3.glyphNames = o3;
        return c3;
      }(n2.post, i2, h2);
      n2.post = {
        tag: "post",
        data: createPostTable(i2)
      };
      const m2 = /* @__PURE__ */ Object.create(null);
      function hasGlyph(e3) {
        return !f2[e3];
      }
      if (i2.composite) {
        const e3 = i2.cidToGidMap || [], t3 = 0 === e3.length;
        i2.cMap.forEach(function(i3, a3) {
          "string" == typeof a3 && (a3 = convertCidString(i3, a3, true));
          if (a3 > 65535) throw new FormatError("Max size of CID is 65,535");
          let r3 = -1;
          t3 ? r3 = a3 : void 0 !== e3[a3] && (r3 = e3[a3]);
          r3 >= 0 && r3 < h2 && hasGlyph(r3) && (m2[i3] = r3);
        });
      } else {
        const e3 = function readCmapTable(e4, t3, i3, a4) {
          if (!e4) {
            warn("No cmap table available.");
            return {
              platformId: -1,
              encodingId: -1,
              mappings: [],
              hasShortCmap: false
            };
          }
          let r4, s4 = (t3.start || 0) + e4.offset;
          t3.pos = s4;
          t3.skip(2);
          const n3 = t3.getUint16();
          let o4, g4 = false;
          for (let e5 = 0; e5 < n3; e5++) {
            const r5 = t3.getUint16(), s5 = t3.getUint16(), c4 = t3.getInt32() >>> 0;
            let C4 = false;
            if ((o4 == null ? void 0 : o4.platformId) !== r5 || (o4 == null ? void 0 : o4.encodingId) !== s5) {
              if (0 !== r5 || 0 !== s5 && 1 !== s5 && 3 !== s5) if (1 === r5 && 0 === s5) C4 = true;
              else if (3 !== r5 || 1 !== s5 || !a4 && o4) {
                if (i3 && 3 === r5 && 0 === s5) {
                  C4 = true;
                  let i4 = true;
                  if (e5 < n3 - 1) {
                    const e6 = t3.peekBytes(2);
                    int16(e6[0], e6[1]) < r5 && (i4 = false);
                  }
                  i4 && (g4 = true);
                }
              } else {
                C4 = true;
                i3 || (g4 = true);
              }
              else C4 = true;
              C4 && (o4 = {
                platformId: r5,
                encodingId: s5,
                offset: c4
              });
              if (g4) break;
            }
          }
          o4 && (t3.pos = s4 + o4.offset);
          if (!o4 || -1 === t3.peekByte()) {
            warn("Could not find a preferred cmap table.");
            return {
              platformId: -1,
              encodingId: -1,
              mappings: [],
              hasShortCmap: false
            };
          }
          const c3 = t3.getUint16();
          let C3 = false;
          const h3 = [];
          let l3, Q3;
          if (0 === c3) {
            t3.skip(4);
            for (l3 = 0; l3 < 256; l3++) {
              const e5 = t3.getByte();
              e5 && h3.push({
                charCode: l3,
                glyphId: e5
              });
            }
            C3 = true;
          } else if (2 === c3) {
            t3.skip(4);
            const e5 = [];
            let i4 = 0;
            for (let a6 = 0; a6 < 256; a6++) {
              const a7 = t3.getUint16() >> 3;
              e5.push(a7);
              i4 = Math.max(a7, i4);
            }
            const a5 = [];
            for (let e6 = 0; e6 <= i4; e6++) a5.push({
              firstCode: t3.getUint16(),
              entryCount: t3.getUint16(),
              idDelta: signedInt16(t3.getByte(), t3.getByte()),
              idRangePos: t3.pos + t3.getUint16()
            });
            for (let i5 = 0; i5 < 256; i5++) if (0 === e5[i5]) {
              t3.pos = a5[0].idRangePos + 2 * i5;
              Q3 = t3.getUint16();
              h3.push({
                charCode: i5,
                glyphId: Q3
              });
            } else {
              const r5 = a5[e5[i5]];
              for (l3 = 0; l3 < r5.entryCount; l3++) {
                const e6 = (i5 << 8) + l3 + r5.firstCode;
                t3.pos = r5.idRangePos + 2 * l3;
                Q3 = t3.getUint16();
                0 !== Q3 && (Q3 = (Q3 + r5.idDelta) % 65536);
                h3.push({
                  charCode: e6,
                  glyphId: Q3
                });
              }
            }
          } else if (4 === c3) {
            t3.skip(4);
            const e5 = t3.getUint16() >> 1;
            t3.skip(6);
            const i4 = [];
            let a5;
            for (a5 = 0; a5 < e5; a5++) i4.push({
              end: t3.getUint16()
            });
            t3.skip(2);
            for (a5 = 0; a5 < e5; a5++) i4[a5].start = t3.getUint16();
            for (a5 = 0; a5 < e5; a5++) i4[a5].delta = t3.getUint16();
            let n4, o5 = 0;
            for (a5 = 0; a5 < e5; a5++) {
              r4 = i4[a5];
              const s5 = t3.getUint16();
              if (s5) {
                n4 = (s5 >> 1) - (e5 - a5);
                r4.offsetIndex = n4;
                o5 = Math.max(o5, n4 + r4.end - r4.start + 1);
              } else r4.offsetIndex = -1;
            }
            const g5 = [];
            for (l3 = 0; l3 < o5; l3++) g5.push(t3.getUint16());
            for (a5 = 0; a5 < e5; a5++) {
              r4 = i4[a5];
              s4 = r4.start;
              const e6 = r4.end, t4 = r4.delta;
              n4 = r4.offsetIndex;
              for (l3 = s4; l3 <= e6; l3++) if (65535 !== l3) {
                Q3 = n4 < 0 ? l3 : g5[n4 + l3 - s4];
                Q3 = Q3 + t4 & 65535;
                h3.push({
                  charCode: l3,
                  glyphId: Q3
                });
              }
            }
          } else if (6 === c3) {
            t3.skip(4);
            const e5 = t3.getUint16(), i4 = t3.getUint16();
            for (l3 = 0; l3 < i4; l3++) {
              Q3 = t3.getUint16();
              const i5 = e5 + l3;
              h3.push({
                charCode: i5,
                glyphId: Q3
              });
            }
          } else {
            if (12 !== c3) {
              warn("cmap table has unsupported format: " + c3);
              return {
                platformId: -1,
                encodingId: -1,
                mappings: [],
                hasShortCmap: false
              };
            }
            {
              t3.skip(10);
              const e5 = t3.getInt32() >>> 0;
              for (l3 = 0; l3 < e5; l3++) {
                const e6 = t3.getInt32() >>> 0, i4 = t3.getInt32() >>> 0;
                let a5 = t3.getInt32() >>> 0;
                for (let t4 = e6; t4 <= i4; t4++) h3.push({
                  charCode: t4,
                  glyphId: a5++
                });
              }
            }
          }
          h3.sort(function(e5, t4) {
            return e5.charCode - t4.charCode;
          });
          for (let e5 = 1; e5 < h3.length; e5++) if (h3[e5 - 1].charCode === h3[e5].charCode) {
            h3.splice(e5, 1);
            e5--;
          }
          return {
            platformId: o4.platformId,
            encodingId: o4.encodingId,
            mappings: h3,
            hasShortCmap: C3
          };
        }(n2.cmap, t2, this.isSymbolicFont, i2.hasEncoding), a3 = e3.platformId, r3 = e3.encodingId, s3 = e3.mappings;
        let o3 = [], g3 = false;
        !i2.hasEncoding || "MacRomanEncoding" !== i2.baseEncodingName && "WinAnsiEncoding" !== i2.baseEncodingName || (o3 = getEncoding(i2.baseEncodingName));
        if (i2.hasEncoding && !this.isSymbolicFont && (3 === a3 && 1 === r3 || 1 === a3 && 0 === r3)) {
          const e4 = Hi();
          for (let t3 = 0; t3 < 256; t3++) {
            let n3;
            n3 = void 0 !== this.differences[t3] ? this.differences[t3] : o3.length && "" !== o3[t3] ? o3[t3] : wi[t3];
            if (!n3) continue;
            const g4 = recoverGlyphName(n3, e4);
            let c3;
            3 === a3 && 1 === r3 ? c3 = e4[g4] : 1 === a3 && 0 === r3 && (c3 = yi.indexOf(g4));
            if (void 0 === c3) {
              if (!i2.glyphNames && i2.hasIncludedToUnicodeMap && !(this.toUnicode instanceof IdentityToUnicodeMap)) {
                const e5 = this.toUnicode.get(t3);
                e5 && (c3 = e5.codePointAt(0));
              }
              if (void 0 === c3) continue;
            }
            for (const e5 of s3) if (e5.charCode === c3) {
              m2[t3] = e5.glyphId;
              break;
            }
          }
        } else if (0 === a3) {
          for (const e4 of s3) m2[e4.charCode] = e4.glyphId;
          g3 = true;
        } else if (3 === a3 && 0 === r3) for (const e4 of s3) {
          let t3 = e4.charCode;
          t3 >= 61440 && t3 <= 61695 && (t3 &= 255);
          m2[t3] = e4.glyphId;
        }
        else for (const e4 of s3) m2[e4.charCode] = e4.glyphId;
        if (i2.glyphNames && (o3.length || this.differences.length)) for (let e4 = 0; e4 < 256; ++e4) {
          if (!g3 && void 0 !== m2[e4]) continue;
          const t3 = this.differences[e4] || o3[e4];
          if (!t3) continue;
          const a4 = i2.glyphNames.indexOf(t3);
          a4 > 0 && hasGlyph(a4) && (m2[e4] = a4);
        }
      }
      0 === m2.length && (m2[0] = 0);
      let y2 = l2 - 1;
      Q2 || (y2 = 0);
      if (!i2.cssFontInfo) {
        const e3 = adjustMapping(m2, hasGlyph, y2, this.toUnicode);
        this.toFontChar = e3.toFontChar;
        n2.cmap = {
          tag: "cmap",
          data: createCmapTable(e3.charCodeToGlyphId, e3.toUnicodeExtraMap, l2)
        };
        n2["OS/2"] && function validateOS2Table(e4, t3) {
          t3.pos = (t3.start || 0) + e4.offset;
          const i3 = t3.getUint16();
          t3.skip(60);
          const a3 = t3.getUint16();
          if (i3 < 4 && 768 & a3) return false;
          if (t3.getUint16() > t3.getUint16()) return false;
          t3.skip(6);
          if (0 === t3.getUint16()) return false;
          e4.data[8] = e4.data[9] = 0;
          return true;
        }(n2["OS/2"], t2) || (n2["OS/2"] = {
          tag: "OS/2",
          data: createOS2Table(i2, e3.charCodeToGlyphId, p2)
        });
      }
      if (!c2) try {
        g2 = new Stream(n2["CFF "].data);
        o2 = new CFFParser(g2, i2, qi).parse();
        o2.duplicateFirstGlyph();
        const e3 = new CFFCompiler(o2);
        n2["CFF "].data = e3.compile();
      } catch {
        warn("Failed to compile font " + i2.loadedName);
      }
      if (n2.name) {
        const [t3, a3] = readNameTable(n2.name);
        n2.name.data = createNameTable(e2, t3);
        this.psName = t3[0][6] || null;
        i2.composite || function adjustTrueTypeToUnicode(e3, t4, i3) {
          if (e3.isInternalFont) return;
          if (e3.hasIncludedToUnicodeMap) return;
          if (e3.hasEncoding) return;
          if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
          if (!t4) return;
          if (0 === i3.length) return;
          if (e3.defaultEncoding === bi) return;
          for (const e4 of i3) if (!isWinNameRecord(e4)) return;
          const a4 = bi, r3 = [], s3 = Hi();
          for (const e4 in a4) {
            const t5 = a4[e4];
            if ("" === t5) continue;
            const i4 = s3[t5];
            void 0 !== i4 && (r3[e4] = String.fromCharCode(i4));
          }
          r3.length > 0 && e3.toUnicode.amend(r3);
        }(i2, this.isSymbolicFont, a3);
      } else n2.name = {
        tag: "name",
        data: createNameTable(this.name)
      };
      const w2 = new OpenTypeFileBuilder(s2.version);
      for (const e3 in n2) w2.addTable(e3, n2[e3].data);
      return w2.toArray();
    }
    convert(e2, t2, i2) {
      i2.fixedPitch = false;
      i2.builtInEncoding && function adjustType1ToUnicode(e3, t3) {
        if (e3.isInternalFont) return;
        if (e3.hasIncludedToUnicodeMap) return;
        if (t3 === e3.defaultEncoding) return;
        if (e3.toUnicode instanceof IdentityToUnicodeMap) return;
        const i3 = [], a3 = Hi();
        for (const r2 in t3) {
          if (e3.hasEncoding && (e3.baseEncodingName || void 0 !== e3.differences[r2])) continue;
          const s3 = getUnicodeForGlyph(t3[r2], a3);
          -1 !== s3 && (i3[r2] = String.fromCharCode(s3));
        }
        i3.length > 0 && e3.toUnicode.amend(i3);
      }(i2, i2.builtInEncoding);
      let a2 = 1;
      t2 instanceof CFFFont && (a2 = t2.numGlyphs - 1);
      const s2 = t2.getGlyphMapping(i2);
      let n2 = null, o2 = s2, g2 = null;
      if (!i2.cssFontInfo) {
        n2 = adjustMapping(s2, t2.hasGlyphId.bind(t2), a2, this.toUnicode);
        this.toFontChar = n2.toFontChar;
        o2 = n2.charCodeToGlyphId;
        g2 = n2.toUnicodeExtraMap;
      }
      const c2 = t2.numGlyphs;
      function getCharCodes(e3, t3) {
        let i3 = null;
        for (const a3 in e3) t3 === e3[a3] && (i3 || (i3 = [])).push(0 | a3);
        return i3;
      }
      function createCharCode(e3, t3) {
        for (const i3 in e3) if (t3 === e3[i3]) return 0 | i3;
        n2.charCodeToGlyphId[n2.nextAvailableFontCharCode] = t3;
        return n2.nextAvailableFontCharCode++;
      }
      const C2 = t2.seacs;
      if (n2 && (C2 == null ? void 0 : C2.length)) {
        const e3 = i2.fontMatrix || r, a3 = t2.getCharset(), o3 = /* @__PURE__ */ Object.create(null);
        for (let t3 in C2) {
          t3 |= 0;
          const i3 = C2[t3], r2 = wi[i3[2]], g3 = wi[i3[3]], c3 = a3.indexOf(r2), h3 = a3.indexOf(g3);
          if (c3 < 0 || h3 < 0) continue;
          const l3 = {
            x: i3[0] * e3[0] + i3[1] * e3[2] + e3[4],
            y: i3[0] * e3[1] + i3[1] * e3[3] + e3[5]
          }, Q2 = getCharCodes(s2, t3);
          if (Q2) for (const e4 of Q2) {
            const t4 = n2.charCodeToGlyphId, i4 = createCharCode(t4, c3), a4 = createCharCode(t4, h3);
            o3[e4] = {
              baseFontCharCode: i4,
              accentFontCharCode: a4,
              accentOffset: l3
            };
          }
        }
        i2.seacMap = o3;
      }
      const h2 = i2.fontMatrix ? 1 / Math.max(...i2.fontMatrix.slice(0, 4).map(Math.abs)) : 1e3, l2 = new OpenTypeFileBuilder("OTTO");
      l2.addTable("CFF ", t2.data);
      l2.addTable("OS/2", createOS2Table(i2, o2));
      l2.addTable("cmap", createCmapTable(o2, g2, c2));
      l2.addTable("head", "\0\0\0\0\0\0\0\0\0\0_<\xF5\0\0" + safeString16(h2) + "\0\0\0\0\x9E\v~'\0\0\0\0\x9E\v~'\0\0" + safeString16(i2.descent) + "\xFF" + safeString16(i2.ascent) + string16(i2.italicAngle ? 2 : 0) + "\0\0\0\0\0\0\0");
      l2.addTable("hhea", "\0\0\0" + safeString16(i2.ascent) + safeString16(i2.descent) + "\0\0\xFF\xFF\0\0\0\0\0\0" + safeString16(i2.capHeight) + safeString16(Math.tan(i2.italicAngle) * i2.xHeight) + "\0\0\0\0\0\0\0\0\0\0\0\0" + string16(c2));
      l2.addTable("hmtx", function fontFieldsHmtx() {
        const e3 = t2.charstrings, i3 = t2.cff ? t2.cff.widths : null;
        let a3 = "\0\0\0\0";
        for (let t3 = 1, r2 = c2; t3 < r2; t3++) {
          let r3 = 0;
          if (e3) {
            const i4 = e3[t3 - 1];
            r3 = "width" in i4 ? i4.width : 0;
          } else i3 && (r3 = Math.ceil(i3[t3] || 0));
          a3 += string16(r3) + string16(0);
        }
        return a3;
      }());
      l2.addTable("maxp", "\0\0P\0" + string16(c2));
      l2.addTable("name", createNameTable(e2));
      l2.addTable("post", createPostTable(i2));
      return l2.toArray();
    }
    get _spaceWidth() {
      const e2 = [
        "space",
        "minus",
        "one",
        "i",
        "I"
      ];
      let t2;
      for (const i2 of e2) {
        if (i2 in this.widths) {
          t2 = this.widths[i2];
          break;
        }
        const e3 = Hi()[i2];
        let a2 = 0;
        if (this.composite && this.cMap.contains(e3)) {
          a2 = this.cMap.lookup(e3);
          "string" == typeof a2 && (a2 = convertCidString(e3, a2));
        }
        !a2 && this.toUnicode && (a2 = this.toUnicode.charCodeOf(e3));
        a2 <= 0 && (a2 = e3);
        t2 = this.widths[a2];
        if (t2) break;
      }
      return shadow(this, "_spaceWidth", t2 || this.defaultWidth);
    }
    _charToGlyph(e2, t2 = false) {
      var _a4, _b, _c;
      let i2, a2, r2, s2 = this._glyphCache[e2];
      if ((s2 == null ? void 0 : s2.isSpace) === t2) return s2;
      let n2 = e2;
      if ((_a4 = this.cMap) == null ? void 0 : _a4.contains(e2)) {
        n2 = this.cMap.lookup(e2);
        "string" == typeof n2 && (n2 = convertCidString(e2, n2));
      }
      a2 = this.widths[n2];
      "number" != typeof a2 && (a2 = this.defaultWidth);
      const o2 = (_b = this.vmetrics) == null ? void 0 : _b[n2];
      let g2 = this.toUnicode.get(e2) || e2;
      "number" == typeof g2 && (g2 = String.fromCharCode(g2));
      let c2 = void 0 !== this.toFontChar[e2];
      i2 = this.toFontChar[e2] || e2;
      if (this.missingFile) {
        const t3 = this.differences[e2] || this.defaultEncoding[e2];
        if ((".notdef" === t3 || "" === t3) && "Type1" === this.type) {
          i2 = 32;
          if ("" === t3) {
            a2 || (a2 = this._spaceWidth);
            g2 = String.fromCharCode(i2);
          }
        }
        i2 = function mapSpecialUnicodeValues(e3) {
          return e3 >= 65520 && e3 <= 65535 ? 0 : e3 >= 62976 && e3 <= 63743 ? vi()[e3] || e3 : 173 === e3 ? 45 : e3;
        }(i2);
      }
      this.isType3Font && (r2 = i2);
      let C2 = null;
      if ((_c = this.seacMap) == null ? void 0 : _c[e2]) {
        c2 = true;
        const t3 = this.seacMap[e2];
        i2 = t3.baseFontCharCode;
        C2 = {
          fontChar: String.fromCodePoint(t3.accentFontCharCode),
          offset: t3.accentOffset
        };
      }
      let h2 = "";
      "number" == typeof i2 && (i2 <= 1114111 ? h2 = String.fromCodePoint(i2) : warn(`charToGlyph - invalid fontCharCode: ${i2}`));
      if (this.missingFile && this.vertical && 1 === h2.length) {
        const e3 = Zi()[h2.charCodeAt(0)];
        e3 && (h2 = g2 = String.fromCharCode(e3));
      }
      s2 = new fonts_Glyph(e2, h2, g2, C2, a2, o2, r2, t2, c2);
      return this._glyphCache[e2] = s2;
    }
    charsToGlyphs(e2) {
      let t2 = this._charsCache[e2];
      if (t2) return t2;
      t2 = [];
      if (this.cMap) {
        const i2 = /* @__PURE__ */ Object.create(null), a2 = e2.length;
        let r2 = 0;
        for (; r2 < a2; ) {
          this.cMap.readCharCode(e2, r2, i2);
          const { charcode: a3, length: s2 } = i2;
          r2 += s2;
          const n2 = this._charToGlyph(a3, 1 === s2 && 32 === e2.charCodeAt(r2 - 1));
          t2.push(n2);
        }
      } else for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2) {
        const a3 = e2.charCodeAt(i2), r2 = this._charToGlyph(a3, 32 === a3);
        t2.push(r2);
      }
      return this._charsCache[e2] = t2;
    }
    getCharPositions(e2) {
      const t2 = [];
      if (this.cMap) {
        const i2 = /* @__PURE__ */ Object.create(null);
        let a2 = 0;
        for (; a2 < e2.length; ) {
          this.cMap.readCharCode(e2, a2, i2);
          const r2 = i2.length;
          t2.push([
            a2,
            a2 + r2
          ]);
          a2 += r2;
        }
      } else for (let i2 = 0, a2 = e2.length; i2 < a2; ++i2) t2.push([
        i2,
        i2 + 1
      ]);
      return t2;
    }
    get glyphCacheValues() {
      return Object.values(this._glyphCache);
    }
    encodeString(e2) {
      const t2 = [], i2 = [], hasCurrentBufErrors = () => t2.length % 2 == 1, a2 = this.toUnicode instanceof IdentityToUnicodeMap ? (e3) => this.toUnicode.charCodeOf(e3) : (e3) => this.toUnicode.charCodeOf(String.fromCodePoint(e3));
      for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
        const s3 = e2.codePointAt(r2);
        s3 > 55295 && (s3 < 57344 || s3 > 65533) && r2++;
        if (this.toUnicode) {
          const e3 = a2(s3);
          if (-1 !== e3) {
            if (hasCurrentBufErrors()) {
              t2.push(i2.join(""));
              i2.length = 0;
            }
            for (let t3 = (this.cMap ? this.cMap.getCharCodeLength(e3) : 1) - 1; t3 >= 0; t3--) i2.push(String.fromCharCode(e3 >> 8 * t3 & 255));
            continue;
          }
        }
        if (!hasCurrentBufErrors()) {
          t2.push(i2.join(""));
          i2.length = 0;
        }
        i2.push(String.fromCodePoint(s3));
      }
      t2.push(i2.join(""));
      return t2;
    }
  }
  class ErrorFont {
    constructor(e2) {
      this.error = e2;
      this.loadedName = "g_font_error";
      this.missingFile = true;
    }
    charsToGlyphs() {
      return [];
    }
    encodeString(e2) {
      return [
        e2
      ];
    }
    exportData(e2 = false) {
      return {
        error: this.error
      };
    }
  }
  const ma = 2, ya = 3, wa = 4, ba = 5, Da = 6, Fa = 7;
  class Pattern {
    constructor() {
      unreachable("Cannot initialize Pattern.");
    }
    static parseShading(e2, t2, i2, a2, r2) {
      const s2 = e2 instanceof BaseStream ? e2.dict : e2, n2 = s2.get("ShadingType");
      try {
        switch (n2) {
          case ma:
          case ya:
            return new RadialAxialShading(s2, t2, i2, a2, r2);
          case wa:
          case ba:
          case Da:
          case Fa:
            return new MeshShading(e2, t2, i2, a2, r2);
          default:
            throw new FormatError("Unsupported ShadingType: " + n2);
        }
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(e3);
        return new DummyShading();
      }
    }
  }
  class BaseShading {
    getIR() {
      unreachable("Abstract method `getIR` called.");
    }
  }
  __publicField(BaseShading, "SMALL_NUMBER", 1e-6);
  class RadialAxialShading extends BaseShading {
    constructor(e2, t2, i2, a2, r2) {
      super();
      this.shadingType = e2.get("ShadingType");
      let s2 = 0;
      this.shadingType === ma ? s2 = 4 : this.shadingType === ya && (s2 = 6);
      this.coordsArr = e2.getArray("Coords");
      if (!isNumberArray(this.coordsArr, s2)) throw new FormatError("RadialAxialShading: Invalid /Coords array.");
      const n2 = ColorSpace.parse({
        cs: e2.getRaw("CS") || e2.getRaw("ColorSpace"),
        xref: t2,
        resources: i2,
        pdfFunctionFactory: a2,
        localColorSpaceCache: r2
      });
      this.bbox = lookupNormalRect(e2.getArray("BBox"), null);
      let o2 = 0, g2 = 1;
      const c2 = e2.getArray("Domain");
      isNumberArray(c2, 2) && ([o2, g2] = c2);
      let C2 = false, h2 = false;
      const l2 = e2.getArray("Extend");
      (function isBooleanArray(e3, t3) {
        return Array.isArray(e3) && e3.length === t3 && e3.every((e4) => "boolean" == typeof e4);
      })(l2, 2) && ([C2, h2] = l2);
      if (!(this.shadingType !== ya || C2 && h2)) {
        const [e3, t3, i3, a3, r3, s3] = this.coordsArr, n3 = Math.hypot(e3 - a3, t3 - r3);
        i3 <= s3 + n3 && s3 <= i3 + n3 && warn("Unsupported radial gradient.");
      }
      this.extendStart = C2;
      this.extendEnd = h2;
      const Q2 = e2.getRaw("Function"), E2 = a2.createFromArray(Q2), u2 = (g2 - o2) / 840, d2 = this.colorStops = [];
      if (o2 >= g2 || u2 <= 0) {
        info("Bad shading domain.");
        return;
      }
      const f2 = new Float32Array(n2.numComps), p2 = new Float32Array(1);
      let m2, y2 = 0;
      p2[0] = o2;
      E2(p2, 0, f2, 0);
      let w2 = n2.getRgb(f2, 0);
      const b2 = Util.makeHexColor(w2[0], w2[1], w2[2]);
      d2.push([
        0,
        b2
      ]);
      let D2 = 1;
      p2[0] = o2 + u2;
      E2(p2, 0, f2, 0);
      let S2 = n2.getRgb(f2, 0), k2 = S2[0] - w2[0] + 1, R2 = S2[1] - w2[1] + 1, N2 = S2[2] - w2[2] + 1, G2 = S2[0] - w2[0] - 1, x2 = S2[1] - w2[1] - 1, U2 = S2[2] - w2[2] - 1;
      for (let e3 = 2; e3 < 840; e3++) {
        p2[0] = o2 + e3 * u2;
        E2(p2, 0, f2, 0);
        m2 = n2.getRgb(f2, 0);
        const t3 = e3 - y2;
        k2 = Math.min(k2, (m2[0] - w2[0] + 1) / t3);
        R2 = Math.min(R2, (m2[1] - w2[1] + 1) / t3);
        N2 = Math.min(N2, (m2[2] - w2[2] + 1) / t3);
        G2 = Math.max(G2, (m2[0] - w2[0] - 1) / t3);
        x2 = Math.max(x2, (m2[1] - w2[1] - 1) / t3);
        U2 = Math.max(U2, (m2[2] - w2[2] - 1) / t3);
        if (!(G2 <= k2 && x2 <= R2 && U2 <= N2)) {
          const e4 = Util.makeHexColor(S2[0], S2[1], S2[2]);
          d2.push([
            D2 / 840,
            e4
          ]);
          k2 = m2[0] - S2[0] + 1;
          R2 = m2[1] - S2[1] + 1;
          N2 = m2[2] - S2[2] + 1;
          G2 = m2[0] - S2[0] - 1;
          x2 = m2[1] - S2[1] - 1;
          U2 = m2[2] - S2[2] - 1;
          y2 = D2;
          w2 = S2;
        }
        D2 = e3;
        S2 = m2;
      }
      const M2 = Util.makeHexColor(S2[0], S2[1], S2[2]);
      d2.push([
        1,
        M2
      ]);
      let L2 = "transparent";
      if (e2.has("Background")) {
        m2 = n2.getRgb(e2.get("Background"), 0);
        L2 = Util.makeHexColor(m2[0], m2[1], m2[2]);
      }
      if (!C2) {
        d2.unshift([
          0,
          L2
        ]);
        d2[1][0] += BaseShading.SMALL_NUMBER;
      }
      if (!h2) {
        d2.at(-1)[0] -= BaseShading.SMALL_NUMBER;
        d2.push([
          1,
          L2
        ]);
      }
      this.colorStops = d2;
    }
    getIR() {
      const { coordsArr: e2, shadingType: t2 } = this;
      let i2, a2, r2, s2, n2;
      if (t2 === ma) {
        a2 = [
          e2[0],
          e2[1]
        ];
        r2 = [
          e2[2],
          e2[3]
        ];
        s2 = null;
        n2 = null;
        i2 = "axial";
      } else if (t2 === ya) {
        a2 = [
          e2[0],
          e2[1]
        ];
        r2 = [
          e2[3],
          e2[4]
        ];
        s2 = e2[2];
        n2 = e2[5];
        i2 = "radial";
      } else unreachable(`getPattern type unknown: ${t2}`);
      return [
        "RadialAxial",
        i2,
        this.bbox,
        this.colorStops,
        a2,
        r2,
        s2,
        n2
      ];
    }
  }
  class MeshStreamReader {
    constructor(e2, t2) {
      this.stream = e2;
      this.context = t2;
      this.buffer = 0;
      this.bufferLength = 0;
      const i2 = t2.numComps;
      this.tmpCompsBuf = new Float32Array(i2);
      const a2 = t2.colorSpace.numComps;
      this.tmpCsCompsBuf = t2.colorFn ? new Float32Array(a2) : this.tmpCompsBuf;
    }
    get hasData() {
      if (this.stream.end) return this.stream.pos < this.stream.end;
      if (this.bufferLength > 0) return true;
      const e2 = this.stream.getByte();
      if (e2 < 0) return false;
      this.buffer = e2;
      this.bufferLength = 8;
      return true;
    }
    readBits(e2) {
      let t2 = this.buffer, i2 = this.bufferLength;
      if (32 === e2) {
        if (0 === i2) return (this.stream.getByte() << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte()) >>> 0;
        t2 = t2 << 24 | this.stream.getByte() << 16 | this.stream.getByte() << 8 | this.stream.getByte();
        const e3 = this.stream.getByte();
        this.buffer = e3 & (1 << i2) - 1;
        return (t2 << 8 - i2 | (255 & e3) >> i2) >>> 0;
      }
      if (8 === e2 && 0 === i2) return this.stream.getByte();
      for (; i2 < e2; ) {
        t2 = t2 << 8 | this.stream.getByte();
        i2 += 8;
      }
      i2 -= e2;
      this.bufferLength = i2;
      this.buffer = t2 & (1 << i2) - 1;
      return t2 >> i2;
    }
    align() {
      this.buffer = 0;
      this.bufferLength = 0;
    }
    readFlag() {
      return this.readBits(this.context.bitsPerFlag);
    }
    readCoordinate() {
      const e2 = this.context.bitsPerCoordinate, t2 = this.readBits(e2), i2 = this.readBits(e2), a2 = this.context.decode, r2 = e2 < 32 ? 1 / ((1 << e2) - 1) : 23283064365386963e-26;
      return [
        t2 * r2 * (a2[1] - a2[0]) + a2[0],
        i2 * r2 * (a2[3] - a2[2]) + a2[2]
      ];
    }
    readComponents() {
      const e2 = this.context.numComps, t2 = this.context.bitsPerComponent, i2 = t2 < 32 ? 1 / ((1 << t2) - 1) : 23283064365386963e-26, a2 = this.context.decode, r2 = this.tmpCompsBuf;
      for (let s3 = 0, n2 = 4; s3 < e2; s3++, n2 += 2) {
        const e3 = this.readBits(t2);
        r2[s3] = e3 * i2 * (a2[n2 + 1] - a2[n2]) + a2[n2];
      }
      const s2 = this.tmpCsCompsBuf;
      this.context.colorFn && this.context.colorFn(r2, 0, s2, 0);
      return this.context.colorSpace.getRgb(s2, 0);
    }
  }
  let Sa = /* @__PURE__ */ Object.create(null);
  function getB(e2) {
    return Sa[e2] || (Sa[e2] = function buildB(e3) {
      const t2 = [];
      for (let i2 = 0; i2 <= e3; i2++) {
        const a2 = i2 / e3, r2 = 1 - a2;
        t2.push(new Float32Array([
          r2 ** 3,
          3 * a2 * r2 ** 2,
          3 * a2 ** 2 * r2,
          a2 ** 3
        ]));
      }
      return t2;
    }(e2));
  }
  const _MeshShading = class _MeshShading extends BaseShading {
    constructor(e2, t2, i2, a2, r2) {
      super();
      if (!(e2 instanceof BaseStream)) throw new FormatError("Mesh data is not a stream");
      const s2 = e2.dict;
      this.shadingType = s2.get("ShadingType");
      this.bbox = lookupNormalRect(s2.getArray("BBox"), null);
      const n2 = ColorSpace.parse({
        cs: s2.getRaw("CS") || s2.getRaw("ColorSpace"),
        xref: t2,
        resources: i2,
        pdfFunctionFactory: a2,
        localColorSpaceCache: r2
      });
      this.background = s2.has("Background") ? n2.getRgb(s2.get("Background"), 0) : null;
      const o2 = s2.getRaw("Function"), g2 = o2 ? a2.createFromArray(o2) : null;
      this.coords = [];
      this.colors = [];
      this.figures = [];
      const c2 = {
        bitsPerCoordinate: s2.get("BitsPerCoordinate"),
        bitsPerComponent: s2.get("BitsPerComponent"),
        bitsPerFlag: s2.get("BitsPerFlag"),
        decode: s2.getArray("Decode"),
        colorFn: g2,
        colorSpace: n2,
        numComps: g2 ? 1 : n2.numComps
      }, C2 = new MeshStreamReader(e2, c2);
      let h2 = false;
      switch (this.shadingType) {
        case wa:
          this._decodeType4Shading(C2);
          break;
        case ba:
          const e3 = 0 | s2.get("VerticesPerRow");
          if (e3 < 2) throw new FormatError("Invalid VerticesPerRow");
          this._decodeType5Shading(C2, e3);
          break;
        case Da:
          this._decodeType6Shading(C2);
          h2 = true;
          break;
        case Fa:
          this._decodeType7Shading(C2);
          h2 = true;
          break;
        default:
          unreachable("Unsupported mesh type.");
      }
      if (h2) {
        this._updateBounds();
        for (let e3 = 0, t3 = this.figures.length; e3 < t3; e3++) this._buildFigureFromPatch(e3);
      }
      this._updateBounds();
      this._packData();
    }
    _decodeType4Shading(e2) {
      const t2 = this.coords, i2 = this.colors, r2 = [];
      let s2 = 0;
      for (; e2.hasData; ) {
        const n2 = e2.readFlag(), o2 = e2.readCoordinate(), g2 = e2.readComponents();
        if (0 === s2) {
          if (!(0 <= n2 && n2 <= 2)) throw new FormatError("Unknown type4 flag");
          switch (n2) {
            case 0:
              s2 = 3;
              break;
            case 1:
              r2.push(r2.at(-2), r2.at(-1));
              s2 = 1;
              break;
            case 2:
              r2.push(r2.at(-3), r2.at(-1));
              s2 = 1;
          }
        }
        r2.push(t2.length);
        t2.push(o2);
        i2.push(g2);
        s2--;
        e2.align();
      }
      this.figures.push({
        type: "triangles",
        coords: new Int32Array(r2),
        colors: new Int32Array(r2)
      });
    }
    _decodeType5Shading(e2, t2) {
      const i2 = this.coords, a2 = this.colors, r2 = [];
      for (; e2.hasData; ) {
        const t3 = e2.readCoordinate(), s2 = e2.readComponents();
        r2.push(i2.length);
        i2.push(t3);
        a2.push(s2);
      }
      this.figures.push({
        type: "lattice",
        coords: new Int32Array(r2),
        colors: new Int32Array(r2),
        verticesPerRow: t2
      });
    }
    _decodeType6Shading(e2) {
      const t2 = this.coords, i2 = this.colors, a2 = new Int32Array(16), r2 = new Int32Array(4);
      for (; e2.hasData; ) {
        const s2 = e2.readFlag();
        if (!(0 <= s2 && s2 <= 3)) throw new FormatError("Unknown type6 flag");
        const n2 = t2.length;
        for (let i3 = 0, a3 = 0 !== s2 ? 8 : 12; i3 < a3; i3++) t2.push(e2.readCoordinate());
        const o2 = i2.length;
        for (let t3 = 0, a3 = 0 !== s2 ? 2 : 4; t3 < a3; t3++) i2.push(e2.readComponents());
        let g2, c2, C2, h2;
        switch (s2) {
          case 0:
            a2[12] = n2 + 3;
            a2[13] = n2 + 4;
            a2[14] = n2 + 5;
            a2[15] = n2 + 6;
            a2[8] = n2 + 2;
            a2[11] = n2 + 7;
            a2[4] = n2 + 1;
            a2[7] = n2 + 8;
            a2[0] = n2;
            a2[1] = n2 + 11;
            a2[2] = n2 + 10;
            a2[3] = n2 + 9;
            r2[2] = o2 + 1;
            r2[3] = o2 + 2;
            r2[0] = o2;
            r2[1] = o2 + 3;
            break;
          case 1:
            g2 = a2[12];
            c2 = a2[13];
            C2 = a2[14];
            h2 = a2[15];
            a2[12] = h2;
            a2[13] = n2 + 0;
            a2[14] = n2 + 1;
            a2[15] = n2 + 2;
            a2[8] = C2;
            a2[11] = n2 + 3;
            a2[4] = c2;
            a2[7] = n2 + 4;
            a2[0] = g2;
            a2[1] = n2 + 7;
            a2[2] = n2 + 6;
            a2[3] = n2 + 5;
            g2 = r2[2];
            c2 = r2[3];
            r2[2] = c2;
            r2[3] = o2;
            r2[0] = g2;
            r2[1] = o2 + 1;
            break;
          case 2:
            g2 = a2[15];
            c2 = a2[11];
            a2[12] = a2[3];
            a2[13] = n2 + 0;
            a2[14] = n2 + 1;
            a2[15] = n2 + 2;
            a2[8] = a2[7];
            a2[11] = n2 + 3;
            a2[4] = c2;
            a2[7] = n2 + 4;
            a2[0] = g2;
            a2[1] = n2 + 7;
            a2[2] = n2 + 6;
            a2[3] = n2 + 5;
            g2 = r2[3];
            r2[2] = r2[1];
            r2[3] = o2;
            r2[0] = g2;
            r2[1] = o2 + 1;
            break;
          case 3:
            a2[12] = a2[0];
            a2[13] = n2 + 0;
            a2[14] = n2 + 1;
            a2[15] = n2 + 2;
            a2[8] = a2[1];
            a2[11] = n2 + 3;
            a2[4] = a2[2];
            a2[7] = n2 + 4;
            a2[0] = a2[3];
            a2[1] = n2 + 7;
            a2[2] = n2 + 6;
            a2[3] = n2 + 5;
            r2[2] = r2[0];
            r2[3] = o2;
            r2[0] = r2[1];
            r2[1] = o2 + 1;
        }
        a2[5] = t2.length;
        t2.push([
          (-4 * t2[a2[0]][0] - t2[a2[15]][0] + 6 * (t2[a2[4]][0] + t2[a2[1]][0]) - 2 * (t2[a2[12]][0] + t2[a2[3]][0]) + 3 * (t2[a2[13]][0] + t2[a2[7]][0])) / 9,
          (-4 * t2[a2[0]][1] - t2[a2[15]][1] + 6 * (t2[a2[4]][1] + t2[a2[1]][1]) - 2 * (t2[a2[12]][1] + t2[a2[3]][1]) + 3 * (t2[a2[13]][1] + t2[a2[7]][1])) / 9
        ]);
        a2[6] = t2.length;
        t2.push([
          (-4 * t2[a2[3]][0] - t2[a2[12]][0] + 6 * (t2[a2[2]][0] + t2[a2[7]][0]) - 2 * (t2[a2[0]][0] + t2[a2[15]][0]) + 3 * (t2[a2[4]][0] + t2[a2[14]][0])) / 9,
          (-4 * t2[a2[3]][1] - t2[a2[12]][1] + 6 * (t2[a2[2]][1] + t2[a2[7]][1]) - 2 * (t2[a2[0]][1] + t2[a2[15]][1]) + 3 * (t2[a2[4]][1] + t2[a2[14]][1])) / 9
        ]);
        a2[9] = t2.length;
        t2.push([
          (-4 * t2[a2[12]][0] - t2[a2[3]][0] + 6 * (t2[a2[8]][0] + t2[a2[13]][0]) - 2 * (t2[a2[0]][0] + t2[a2[15]][0]) + 3 * (t2[a2[11]][0] + t2[a2[1]][0])) / 9,
          (-4 * t2[a2[12]][1] - t2[a2[3]][1] + 6 * (t2[a2[8]][1] + t2[a2[13]][1]) - 2 * (t2[a2[0]][1] + t2[a2[15]][1]) + 3 * (t2[a2[11]][1] + t2[a2[1]][1])) / 9
        ]);
        a2[10] = t2.length;
        t2.push([
          (-4 * t2[a2[15]][0] - t2[a2[0]][0] + 6 * (t2[a2[11]][0] + t2[a2[14]][0]) - 2 * (t2[a2[12]][0] + t2[a2[3]][0]) + 3 * (t2[a2[2]][0] + t2[a2[8]][0])) / 9,
          (-4 * t2[a2[15]][1] - t2[a2[0]][1] + 6 * (t2[a2[11]][1] + t2[a2[14]][1]) - 2 * (t2[a2[12]][1] + t2[a2[3]][1]) + 3 * (t2[a2[2]][1] + t2[a2[8]][1])) / 9
        ]);
        this.figures.push({
          type: "patch",
          coords: new Int32Array(a2),
          colors: new Int32Array(r2)
        });
      }
    }
    _decodeType7Shading(e2) {
      const t2 = this.coords, i2 = this.colors, a2 = new Int32Array(16), r2 = new Int32Array(4);
      for (; e2.hasData; ) {
        const s2 = e2.readFlag();
        if (!(0 <= s2 && s2 <= 3)) throw new FormatError("Unknown type7 flag");
        const n2 = t2.length;
        for (let i3 = 0, a3 = 0 !== s2 ? 12 : 16; i3 < a3; i3++) t2.push(e2.readCoordinate());
        const o2 = i2.length;
        for (let t3 = 0, a3 = 0 !== s2 ? 2 : 4; t3 < a3; t3++) i2.push(e2.readComponents());
        let g2, c2, C2, h2;
        switch (s2) {
          case 0:
            a2[12] = n2 + 3;
            a2[13] = n2 + 4;
            a2[14] = n2 + 5;
            a2[15] = n2 + 6;
            a2[8] = n2 + 2;
            a2[9] = n2 + 13;
            a2[10] = n2 + 14;
            a2[11] = n2 + 7;
            a2[4] = n2 + 1;
            a2[5] = n2 + 12;
            a2[6] = n2 + 15;
            a2[7] = n2 + 8;
            a2[0] = n2;
            a2[1] = n2 + 11;
            a2[2] = n2 + 10;
            a2[3] = n2 + 9;
            r2[2] = o2 + 1;
            r2[3] = o2 + 2;
            r2[0] = o2;
            r2[1] = o2 + 3;
            break;
          case 1:
            g2 = a2[12];
            c2 = a2[13];
            C2 = a2[14];
            h2 = a2[15];
            a2[12] = h2;
            a2[13] = n2 + 0;
            a2[14] = n2 + 1;
            a2[15] = n2 + 2;
            a2[8] = C2;
            a2[9] = n2 + 9;
            a2[10] = n2 + 10;
            a2[11] = n2 + 3;
            a2[4] = c2;
            a2[5] = n2 + 8;
            a2[6] = n2 + 11;
            a2[7] = n2 + 4;
            a2[0] = g2;
            a2[1] = n2 + 7;
            a2[2] = n2 + 6;
            a2[3] = n2 + 5;
            g2 = r2[2];
            c2 = r2[3];
            r2[2] = c2;
            r2[3] = o2;
            r2[0] = g2;
            r2[1] = o2 + 1;
            break;
          case 2:
            g2 = a2[15];
            c2 = a2[11];
            a2[12] = a2[3];
            a2[13] = n2 + 0;
            a2[14] = n2 + 1;
            a2[15] = n2 + 2;
            a2[8] = a2[7];
            a2[9] = n2 + 9;
            a2[10] = n2 + 10;
            a2[11] = n2 + 3;
            a2[4] = c2;
            a2[5] = n2 + 8;
            a2[6] = n2 + 11;
            a2[7] = n2 + 4;
            a2[0] = g2;
            a2[1] = n2 + 7;
            a2[2] = n2 + 6;
            a2[3] = n2 + 5;
            g2 = r2[3];
            r2[2] = r2[1];
            r2[3] = o2;
            r2[0] = g2;
            r2[1] = o2 + 1;
            break;
          case 3:
            a2[12] = a2[0];
            a2[13] = n2 + 0;
            a2[14] = n2 + 1;
            a2[15] = n2 + 2;
            a2[8] = a2[1];
            a2[9] = n2 + 9;
            a2[10] = n2 + 10;
            a2[11] = n2 + 3;
            a2[4] = a2[2];
            a2[5] = n2 + 8;
            a2[6] = n2 + 11;
            a2[7] = n2 + 4;
            a2[0] = a2[3];
            a2[1] = n2 + 7;
            a2[2] = n2 + 6;
            a2[3] = n2 + 5;
            r2[2] = r2[0];
            r2[3] = o2;
            r2[0] = r2[1];
            r2[1] = o2 + 1;
        }
        this.figures.push({
          type: "patch",
          coords: new Int32Array(a2),
          colors: new Int32Array(r2)
        });
      }
    }
    _buildFigureFromPatch(e2) {
      const t2 = this.figures[e2];
      assert("patch" === t2.type, "Unexpected patch mesh figure");
      const i2 = this.coords, a2 = this.colors, r2 = t2.coords, s2 = t2.colors, n2 = Math.min(i2[r2[0]][0], i2[r2[3]][0], i2[r2[12]][0], i2[r2[15]][0]), o2 = Math.min(i2[r2[0]][1], i2[r2[3]][1], i2[r2[12]][1], i2[r2[15]][1]), g2 = Math.max(i2[r2[0]][0], i2[r2[3]][0], i2[r2[12]][0], i2[r2[15]][0]), c2 = Math.max(i2[r2[0]][1], i2[r2[3]][1], i2[r2[12]][1], i2[r2[15]][1]);
      let C2 = Math.ceil((g2 - n2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[2] - this.bounds[0]));
      C2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, C2));
      let h2 = Math.ceil((c2 - o2) * _MeshShading.TRIANGLE_DENSITY / (this.bounds[3] - this.bounds[1]));
      h2 = Math.max(_MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT, Math.min(_MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT, h2));
      const l2 = C2 + 1, Q2 = new Int32Array((h2 + 1) * l2), E2 = new Int32Array((h2 + 1) * l2);
      let u2 = 0;
      const d2 = new Uint8Array(3), f2 = new Uint8Array(3), p2 = a2[s2[0]], m2 = a2[s2[1]], y2 = a2[s2[2]], w2 = a2[s2[3]], b2 = getB(h2), D2 = getB(C2);
      for (let e3 = 0; e3 <= h2; e3++) {
        d2[0] = (p2[0] * (h2 - e3) + y2[0] * e3) / h2 | 0;
        d2[1] = (p2[1] * (h2 - e3) + y2[1] * e3) / h2 | 0;
        d2[2] = (p2[2] * (h2 - e3) + y2[2] * e3) / h2 | 0;
        f2[0] = (m2[0] * (h2 - e3) + w2[0] * e3) / h2 | 0;
        f2[1] = (m2[1] * (h2 - e3) + w2[1] * e3) / h2 | 0;
        f2[2] = (m2[2] * (h2 - e3) + w2[2] * e3) / h2 | 0;
        for (let t3 = 0; t3 <= C2; t3++, u2++) {
          if (!(0 !== e3 && e3 !== h2 || 0 !== t3 && t3 !== C2)) continue;
          let s3 = 0, n3 = 0, o3 = 0;
          for (let a3 = 0; a3 <= 3; a3++) for (let g4 = 0; g4 <= 3; g4++, o3++) {
            const c3 = b2[e3][a3] * D2[t3][g4];
            s3 += i2[r2[o3]][0] * c3;
            n3 += i2[r2[o3]][1] * c3;
          }
          Q2[u2] = i2.length;
          i2.push([
            s3,
            n3
          ]);
          E2[u2] = a2.length;
          const g3 = new Uint8Array(3);
          g3[0] = (d2[0] * (C2 - t3) + f2[0] * t3) / C2 | 0;
          g3[1] = (d2[1] * (C2 - t3) + f2[1] * t3) / C2 | 0;
          g3[2] = (d2[2] * (C2 - t3) + f2[2] * t3) / C2 | 0;
          a2.push(g3);
        }
      }
      Q2[0] = r2[0];
      E2[0] = s2[0];
      Q2[C2] = r2[3];
      E2[C2] = s2[1];
      Q2[l2 * h2] = r2[12];
      E2[l2 * h2] = s2[2];
      Q2[l2 * h2 + C2] = r2[15];
      E2[l2 * h2 + C2] = s2[3];
      this.figures[e2] = {
        type: "lattice",
        coords: Q2,
        colors: E2,
        verticesPerRow: l2
      };
    }
    _updateBounds() {
      let e2 = this.coords[0][0], t2 = this.coords[0][1], i2 = e2, a2 = t2;
      for (let r2 = 1, s2 = this.coords.length; r2 < s2; r2++) {
        const s3 = this.coords[r2][0], n2 = this.coords[r2][1];
        e2 = e2 > s3 ? s3 : e2;
        t2 = t2 > n2 ? n2 : t2;
        i2 = i2 < s3 ? s3 : i2;
        a2 = a2 < n2 ? n2 : a2;
      }
      this.bounds = [
        e2,
        t2,
        i2,
        a2
      ];
    }
    _packData() {
      let e2, t2, i2, a2;
      const r2 = this.coords, s2 = new Float32Array(2 * r2.length);
      for (e2 = 0, i2 = 0, t2 = r2.length; e2 < t2; e2++) {
        const t3 = r2[e2];
        s2[i2++] = t3[0];
        s2[i2++] = t3[1];
      }
      this.coords = s2;
      const n2 = this.colors, o2 = new Uint8Array(3 * n2.length);
      for (e2 = 0, i2 = 0, t2 = n2.length; e2 < t2; e2++) {
        const t3 = n2[e2];
        o2[i2++] = t3[0];
        o2[i2++] = t3[1];
        o2[i2++] = t3[2];
      }
      this.colors = o2;
      const g2 = this.figures;
      for (e2 = 0, t2 = g2.length; e2 < t2; e2++) {
        const t3 = g2[e2], r3 = t3.coords, s3 = t3.colors;
        for (i2 = 0, a2 = r3.length; i2 < a2; i2++) {
          r3[i2] *= 2;
          s3[i2] *= 3;
        }
      }
    }
    getIR() {
      const { bounds: e2 } = this;
      if (e2[2] - e2[0] == 0 || e2[3] - e2[1] == 0) throw new FormatError(`Invalid MeshShading bounds: [${e2}].`);
      return [
        "Mesh",
        this.shadingType,
        this.coords,
        this.colors,
        this.figures,
        e2,
        this.bbox,
        this.background
      ];
    }
  };
  __publicField(_MeshShading, "MIN_SPLIT_PATCH_CHUNKS_AMOUNT", 3);
  __publicField(_MeshShading, "MAX_SPLIT_PATCH_CHUNKS_AMOUNT", 20);
  __publicField(_MeshShading, "TRIANGLE_DENSITY", 20);
  let MeshShading = _MeshShading;
  class DummyShading extends BaseShading {
    getIR() {
      return [
        "Dummy"
      ];
    }
  }
  function getTilingPatternIR(e2, t2, i2) {
    const r2 = lookupMatrix(t2.getArray("Matrix"), a), s2 = lookupNormalRect(t2.getArray("BBox"), null);
    if (!s2 || s2[2] - s2[0] == 0 || s2[3] - s2[1] == 0) throw new FormatError("Invalid getTilingPatternIR /BBox array.");
    const n2 = t2.get("XStep");
    if ("number" != typeof n2) throw new FormatError("Invalid getTilingPatternIR /XStep value.");
    const o2 = t2.get("YStep");
    if ("number" != typeof o2) throw new FormatError("Invalid getTilingPatternIR /YStep value.");
    const g2 = t2.get("PaintType");
    if (!Number.isInteger(g2)) throw new FormatError("Invalid getTilingPatternIR /PaintType value.");
    const c2 = t2.get("TilingType");
    if (!Number.isInteger(c2)) throw new FormatError("Invalid getTilingPatternIR /TilingType value.");
    return [
      "TilingPattern",
      i2,
      e2,
      r2,
      s2,
      n2,
      o2,
      g2,
      c2
    ];
  }
  const ka = [
    1.3877,
    1,
    1,
    1,
    0.97801,
    0.92482,
    0.89552,
    0.91133,
    0.81988,
    0.97566,
    0.98152,
    0.93548,
    0.93548,
    1.2798,
    0.85284,
    0.92794,
    1,
    0.96134,
    1.54657,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.82845,
    0.82845,
    0.85284,
    0.85284,
    0.85284,
    0.75859,
    0.92138,
    0.83908,
    0.7762,
    0.73293,
    0.87289,
    0.73133,
    0.7514,
    0.81921,
    0.87356,
    0.95958,
    0.59526,
    0.75727,
    0.69225,
    1.04924,
    0.9121,
    0.86943,
    0.79795,
    0.88198,
    0.77958,
    0.70864,
    0.81055,
    0.90399,
    0.88653,
    0.96017,
    0.82577,
    0.77892,
    0.78257,
    0.97507,
    1.54657,
    0.97507,
    0.85284,
    0.89552,
    0.90176,
    0.88762,
    0.8785,
    0.75241,
    0.8785,
    0.90518,
    0.95015,
    0.77618,
    0.8785,
    0.88401,
    0.91916,
    0.86304,
    0.88401,
    0.91488,
    0.8785,
    0.8801,
    0.8785,
    0.8785,
    0.91343,
    0.7173,
    1.04106,
    0.8785,
    0.85075,
    0.95794,
    0.82616,
    0.85162,
    0.79492,
    0.88331,
    1.69808,
    0.88331,
    0.85284,
    0.97801,
    0.89552,
    0.91133,
    0.89552,
    0.91133,
    1.7801,
    0.89552,
    1.24487,
    1.13254,
    1.12401,
    0.96839,
    0.85284,
    0.68787,
    0.70645,
    0.85592,
    0.90747,
    1.01466,
    1.0088,
    0.90323,
    1,
    1.07463,
    1,
    0.91056,
    0.75806,
    1.19118,
    0.96839,
    0.78864,
    0.82845,
    0.84133,
    0.75859,
    0.83908,
    0.83908,
    0.83908,
    0.83908,
    0.83908,
    0.83908,
    0.77539,
    0.73293,
    0.73133,
    0.73133,
    0.73133,
    0.73133,
    0.95958,
    0.95958,
    0.95958,
    0.95958,
    0.88506,
    0.9121,
    0.86943,
    0.86943,
    0.86943,
    0.86943,
    0.86943,
    0.85284,
    0.87508,
    0.90399,
    0.90399,
    0.90399,
    0.90399,
    0.77892,
    0.79795,
    0.90807,
    0.88762,
    0.88762,
    0.88762,
    0.88762,
    0.88762,
    0.88762,
    0.8715,
    0.75241,
    0.90518,
    0.90518,
    0.90518,
    0.90518,
    0.88401,
    0.88401,
    0.88401,
    0.88401,
    0.8785,
    0.8785,
    0.8801,
    0.8801,
    0.8801,
    0.8801,
    0.8801,
    0.90747,
    0.89049,
    0.8785,
    0.8785,
    0.8785,
    0.8785,
    0.85162,
    0.8785,
    0.85162,
    0.83908,
    0.88762,
    0.83908,
    0.88762,
    0.83908,
    0.88762,
    0.73293,
    0.75241,
    0.73293,
    0.75241,
    0.73293,
    0.75241,
    0.73293,
    0.75241,
    0.87289,
    0.83016,
    0.88506,
    0.93125,
    0.73133,
    0.90518,
    0.73133,
    0.90518,
    0.73133,
    0.90518,
    0.73133,
    0.90518,
    0.73133,
    0.90518,
    0.81921,
    0.77618,
    0.81921,
    0.77618,
    0.81921,
    0.77618,
    1,
    1,
    0.87356,
    0.8785,
    0.91075,
    0.89608,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.76229,
    0.90167,
    0.59526,
    0.91916,
    1,
    1,
    0.86304,
    0.69225,
    0.88401,
    1,
    1,
    0.70424,
    0.79468,
    0.91926,
    0.88175,
    0.70823,
    0.94903,
    0.9121,
    0.8785,
    1,
    1,
    0.9121,
    0.8785,
    0.87802,
    0.88656,
    0.8785,
    0.86943,
    0.8801,
    0.86943,
    0.8801,
    0.86943,
    0.8801,
    0.87402,
    0.89291,
    0.77958,
    0.91343,
    1,
    1,
    0.77958,
    0.91343,
    0.70864,
    0.7173,
    0.70864,
    0.7173,
    0.70864,
    0.7173,
    0.70864,
    0.7173,
    1,
    1,
    0.81055,
    0.75841,
    0.81055,
    1.06452,
    0.90399,
    0.8785,
    0.90399,
    0.8785,
    0.90399,
    0.8785,
    0.90399,
    0.8785,
    0.90399,
    0.8785,
    0.90399,
    0.8785,
    0.96017,
    0.95794,
    0.77892,
    0.85162,
    0.77892,
    0.78257,
    0.79492,
    0.78257,
    0.79492,
    0.78257,
    0.79492,
    0.9297,
    0.56892,
    0.83908,
    0.88762,
    0.77539,
    0.8715,
    0.87508,
    0.89049,
    1,
    1,
    0.81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    0.70674,
    0.98387,
    0.94721,
    1.33431,
    1.45894,
    0.95161,
    1.06303,
    0.83908,
    0.80352,
    0.57184,
    0.6965,
    0.56289,
    0.82001,
    0.56029,
    0.81235,
    1.02988,
    0.83908,
    0.7762,
    0.68156,
    0.80367,
    0.73133,
    0.78257,
    0.87356,
    0.86943,
    0.95958,
    0.75727,
    0.89019,
    1.04924,
    0.9121,
    0.7648,
    0.86943,
    0.87356,
    0.79795,
    0.78275,
    0.81055,
    0.77892,
    0.9762,
    0.82577,
    0.99819,
    0.84896,
    0.95958,
    0.77892,
    0.96108,
    1.01407,
    0.89049,
    1.02988,
    0.94211,
    0.96108,
    0.8936,
    0.84021,
    0.87842,
    0.96399,
    0.79109,
    0.89049,
    1.00813,
    1.02988,
    0.86077,
    0.87445,
    0.92099,
    0.84723,
    0.86513,
    0.8801,
    0.75638,
    0.85714,
    0.78216,
    0.79586,
    0.87965,
    0.94211,
    0.97747,
    0.78287,
    0.97926,
    0.84971,
    1.02988,
    0.94211,
    0.8801,
    0.94211,
    0.84971,
    0.73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90264,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90518,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90548,
    1,
    1,
    1,
    1,
    1,
    1,
    0.96017,
    0.95794,
    0.96017,
    0.95794,
    0.96017,
    0.95794,
    0.77892,
    0.85162,
    1,
    1,
    0.89552,
    0.90527,
    1,
    0.90363,
    0.92794,
    0.92794,
    0.92794,
    0.92794,
    0.87012,
    0.87012,
    0.87012,
    0.89552,
    0.89552,
    1.42259,
    0.71143,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    0.97171,
    1.4956,
    2.2807,
    0.93835,
    0.83406,
    0.91133,
    0.84107,
    0.91133,
    1,
    1,
    1,
    0.72021,
    1,
    1.23108,
    0.83489,
    0.88525,
    0.88525,
    0.81499,
    0.90527,
    1.81055,
    0.90527,
    1.81055,
    1.31006,
    1.53711,
    0.94434,
    1.08696,
    1,
    0.95018,
    0.77192,
    0.85284,
    0.90747,
    1.17534,
    0.69825,
    0.9716,
    1.37077,
    0.90747,
    0.90747,
    0.85356,
    0.90747,
    0.90747,
    1.44947,
    0.85284,
    0.8941,
    0.8941,
    0.70572,
    0.8,
    0.70572,
    0.70572,
    0.70572,
    0.70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99862,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    0.91027,
    1,
    1,
    1,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90727,
    0.90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ra = {
    lineHeight: 1.2207,
    lineGap: 0.2207
  }, Na = [
    1.3877,
    1,
    1,
    1,
    0.97801,
    0.92482,
    0.89552,
    0.91133,
    0.81988,
    0.97566,
    0.98152,
    0.93548,
    0.93548,
    1.2798,
    0.85284,
    0.92794,
    1,
    0.96134,
    1.56239,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.82845,
    0.82845,
    0.85284,
    0.85284,
    0.85284,
    0.75859,
    0.92138,
    0.83908,
    0.7762,
    0.71805,
    0.87289,
    0.73133,
    0.7514,
    0.81921,
    0.87356,
    0.95958,
    0.59526,
    0.75727,
    0.69225,
    1.04924,
    0.90872,
    0.85938,
    0.79795,
    0.87068,
    0.77958,
    0.69766,
    0.81055,
    0.90399,
    0.88653,
    0.96068,
    0.82577,
    0.77892,
    0.78257,
    0.97507,
    1.529,
    0.97507,
    0.85284,
    0.89552,
    0.90176,
    0.94908,
    0.86411,
    0.74012,
    0.86411,
    0.88323,
    0.95015,
    0.86411,
    0.86331,
    0.88401,
    0.91916,
    0.86304,
    0.88401,
    0.9039,
    0.86331,
    0.86331,
    0.86411,
    0.86411,
    0.90464,
    0.70852,
    1.04106,
    0.86331,
    0.84372,
    0.95794,
    0.82616,
    0.84548,
    0.79492,
    0.88331,
    1.69808,
    0.88331,
    0.85284,
    0.97801,
    0.89552,
    0.91133,
    0.89552,
    0.91133,
    1.7801,
    0.89552,
    1.24487,
    1.13254,
    1.19129,
    0.96839,
    0.85284,
    0.68787,
    0.70645,
    0.85592,
    0.90747,
    1.01466,
    1.0088,
    0.90323,
    1,
    1.07463,
    1,
    0.91056,
    0.75806,
    1.19118,
    0.96839,
    0.78864,
    0.82845,
    0.84133,
    0.75859,
    0.83908,
    0.83908,
    0.83908,
    0.83908,
    0.83908,
    0.83908,
    0.77539,
    0.71805,
    0.73133,
    0.73133,
    0.73133,
    0.73133,
    0.95958,
    0.95958,
    0.95958,
    0.95958,
    0.88506,
    0.90872,
    0.85938,
    0.85938,
    0.85938,
    0.85938,
    0.85938,
    0.85284,
    0.87068,
    0.90399,
    0.90399,
    0.90399,
    0.90399,
    0.77892,
    0.79795,
    0.90807,
    0.94908,
    0.94908,
    0.94908,
    0.94908,
    0.94908,
    0.94908,
    0.85887,
    0.74012,
    0.88323,
    0.88323,
    0.88323,
    0.88323,
    0.88401,
    0.88401,
    0.88401,
    0.88401,
    0.8785,
    0.86331,
    0.86331,
    0.86331,
    0.86331,
    0.86331,
    0.86331,
    0.90747,
    0.89049,
    0.86331,
    0.86331,
    0.86331,
    0.86331,
    0.84548,
    0.86411,
    0.84548,
    0.83908,
    0.94908,
    0.83908,
    0.94908,
    0.83908,
    0.94908,
    0.71805,
    0.74012,
    0.71805,
    0.74012,
    0.71805,
    0.74012,
    0.71805,
    0.74012,
    0.87289,
    0.79538,
    0.88506,
    0.92726,
    0.73133,
    0.88323,
    0.73133,
    0.88323,
    0.73133,
    0.88323,
    0.73133,
    0.88323,
    0.73133,
    0.88323,
    0.81921,
    0.86411,
    0.81921,
    0.86411,
    0.81921,
    0.86411,
    1,
    1,
    0.87356,
    0.86331,
    0.91075,
    0.8777,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.95958,
    0.88401,
    0.76467,
    0.90167,
    0.59526,
    0.91916,
    1,
    1,
    0.86304,
    0.69225,
    0.88401,
    1,
    1,
    0.70424,
    0.77312,
    0.91926,
    0.88175,
    0.70823,
    0.94903,
    0.90872,
    0.86331,
    1,
    1,
    0.90872,
    0.86331,
    0.86906,
    0.88116,
    0.86331,
    0.85938,
    0.86331,
    0.85938,
    0.86331,
    0.85938,
    0.86331,
    0.87402,
    0.86549,
    0.77958,
    0.90464,
    1,
    1,
    0.77958,
    0.90464,
    0.69766,
    0.70852,
    0.69766,
    0.70852,
    0.69766,
    0.70852,
    0.69766,
    0.70852,
    1,
    1,
    0.81055,
    0.75841,
    0.81055,
    1.06452,
    0.90399,
    0.86331,
    0.90399,
    0.86331,
    0.90399,
    0.86331,
    0.90399,
    0.86331,
    0.90399,
    0.86331,
    0.90399,
    0.86331,
    0.96068,
    0.95794,
    0.77892,
    0.84548,
    0.77892,
    0.78257,
    0.79492,
    0.78257,
    0.79492,
    0.78257,
    0.79492,
    0.9297,
    0.56892,
    0.83908,
    0.94908,
    0.77539,
    0.85887,
    0.87068,
    0.89049,
    1,
    1,
    0.81055,
    1.04106,
    1.20528,
    1.20528,
    1,
    1.15543,
    0.70088,
    0.98387,
    0.94721,
    1.33431,
    1.45894,
    0.95161,
    1.48387,
    0.83908,
    0.80352,
    0.57118,
    0.6965,
    0.56347,
    0.79179,
    0.55853,
    0.80346,
    1.02988,
    0.83908,
    0.7762,
    0.67174,
    0.86036,
    0.73133,
    0.78257,
    0.87356,
    0.86441,
    0.95958,
    0.75727,
    0.89019,
    1.04924,
    0.90872,
    0.74889,
    0.85938,
    0.87891,
    0.79795,
    0.7957,
    0.81055,
    0.77892,
    0.97447,
    0.82577,
    0.97466,
    0.87179,
    0.95958,
    0.77892,
    0.94252,
    0.95612,
    0.8753,
    1.02988,
    0.92733,
    0.94252,
    0.87411,
    0.84021,
    0.8728,
    0.95612,
    0.74081,
    0.8753,
    1.02189,
    1.02988,
    0.84814,
    0.87445,
    0.91822,
    0.84723,
    0.85668,
    0.86331,
    0.81344,
    0.87581,
    0.76422,
    0.82046,
    0.96057,
    0.92733,
    0.99375,
    0.78022,
    0.95452,
    0.86015,
    1.02988,
    0.92733,
    0.86331,
    0.92733,
    0.86015,
    0.73133,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90631,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.88323,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.85174,
    1,
    1,
    1,
    1,
    1,
    1,
    0.96068,
    0.95794,
    0.96068,
    0.95794,
    0.96068,
    0.95794,
    0.77892,
    0.84548,
    1,
    1,
    0.89552,
    0.90527,
    1,
    0.90363,
    0.92794,
    0.92794,
    0.92794,
    0.89807,
    0.87012,
    0.87012,
    0.87012,
    0.89552,
    0.89552,
    1.42259,
    0.71094,
    1.06152,
    1,
    1,
    1.03372,
    1.03372,
    0.97171,
    1.4956,
    2.2807,
    0.92972,
    0.83406,
    0.91133,
    0.83326,
    0.91133,
    1,
    1,
    1,
    0.72021,
    1,
    1.23108,
    0.83489,
    0.88525,
    0.88525,
    0.81499,
    0.90616,
    1.81055,
    0.90527,
    1.81055,
    1.3107,
    1.53711,
    0.94434,
    1.08696,
    1,
    0.95018,
    0.77192,
    0.85284,
    0.90747,
    1.17534,
    0.69825,
    0.9716,
    1.37077,
    0.90747,
    0.90747,
    0.85356,
    0.90747,
    0.90747,
    1.44947,
    0.85284,
    0.8941,
    0.8941,
    0.70572,
    0.8,
    0.70572,
    0.70572,
    0.70572,
    0.70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99862,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.08004,
    0.91027,
    1,
    1,
    1,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90727,
    0.90727,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ga = {
    lineHeight: 1.2207,
    lineGap: 0.2207
  }, xa = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    0.89552,
    0.91133,
    0.80395,
    1.02269,
    1.15601,
    0.91056,
    0.91056,
    1.2798,
    0.85284,
    0.89807,
    1,
    0.90861,
    1.39543,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.96309,
    0.96309,
    0.85284,
    0.85284,
    0.85284,
    0.83319,
    0.88071,
    0.8675,
    0.81552,
    0.72346,
    0.85193,
    0.73206,
    0.7522,
    0.81105,
    0.86275,
    0.90685,
    0.6377,
    0.77892,
    0.75593,
    1.02638,
    0.89249,
    0.84118,
    0.77452,
    0.85374,
    0.75186,
    0.67789,
    0.79776,
    0.88844,
    0.85066,
    0.94309,
    0.77818,
    0.7306,
    0.76659,
    1.10369,
    1.38313,
    1.10369,
    1.06139,
    0.89552,
    0.8739,
    0.9245,
    0.9245,
    0.83203,
    0.9245,
    0.85865,
    1.09842,
    0.9245,
    0.9245,
    1.03297,
    1.07692,
    0.90918,
    1.03297,
    0.94959,
    0.9245,
    0.92274,
    0.9245,
    0.9245,
    1.02933,
    0.77832,
    1.20562,
    0.9245,
    0.8916,
    0.98986,
    0.86621,
    0.89453,
    0.79004,
    0.94152,
    1.77256,
    0.94152,
    0.85284,
    0.97801,
    0.89552,
    0.91133,
    0.89552,
    0.91133,
    1.91729,
    0.89552,
    1.17889,
    1.13254,
    1.16359,
    0.92098,
    0.85284,
    0.68787,
    0.71353,
    0.84737,
    0.90747,
    1.0088,
    1.0044,
    0.87683,
    1,
    1.09091,
    1,
    0.92229,
    0.739,
    1.15642,
    0.92098,
    0.76288,
    0.80504,
    0.80972,
    0.75859,
    0.8675,
    0.8675,
    0.8675,
    0.8675,
    0.8675,
    0.8675,
    0.76318,
    0.72346,
    0.73206,
    0.73206,
    0.73206,
    0.73206,
    0.90685,
    0.90685,
    0.90685,
    0.90685,
    0.86477,
    0.89249,
    0.84118,
    0.84118,
    0.84118,
    0.84118,
    0.84118,
    0.85284,
    0.84557,
    0.88844,
    0.88844,
    0.88844,
    0.88844,
    0.7306,
    0.77452,
    0.86331,
    0.9245,
    0.9245,
    0.9245,
    0.9245,
    0.9245,
    0.9245,
    0.84843,
    0.83203,
    0.85865,
    0.85865,
    0.85865,
    0.85865,
    0.82601,
    0.82601,
    0.82601,
    0.82601,
    0.94469,
    0.9245,
    0.92274,
    0.92274,
    0.92274,
    0.92274,
    0.92274,
    0.90747,
    0.86651,
    0.9245,
    0.9245,
    0.9245,
    0.9245,
    0.89453,
    0.9245,
    0.89453,
    0.8675,
    0.9245,
    0.8675,
    0.9245,
    0.8675,
    0.9245,
    0.72346,
    0.83203,
    0.72346,
    0.83203,
    0.72346,
    0.83203,
    0.72346,
    0.83203,
    0.85193,
    0.8875,
    0.86477,
    0.99034,
    0.73206,
    0.85865,
    0.73206,
    0.85865,
    0.73206,
    0.85865,
    0.73206,
    0.85865,
    0.73206,
    0.85865,
    0.81105,
    0.9245,
    0.81105,
    0.9245,
    0.81105,
    0.9245,
    1,
    1,
    0.86275,
    0.9245,
    0.90872,
    0.93591,
    0.90685,
    0.82601,
    0.90685,
    0.82601,
    0.90685,
    0.82601,
    0.90685,
    1.03297,
    0.90685,
    0.82601,
    0.77896,
    1.05611,
    0.6377,
    1.07692,
    1,
    1,
    0.90918,
    0.75593,
    1.03297,
    1,
    1,
    0.76032,
    0.9375,
    0.98156,
    0.93407,
    0.77261,
    1.11429,
    0.89249,
    0.9245,
    1,
    1,
    0.89249,
    0.9245,
    0.92534,
    0.86698,
    0.9245,
    0.84118,
    0.92274,
    0.84118,
    0.92274,
    0.84118,
    0.92274,
    0.8667,
    0.86291,
    0.75186,
    1.02933,
    1,
    1,
    0.75186,
    1.02933,
    0.67789,
    0.77832,
    0.67789,
    0.77832,
    0.67789,
    0.77832,
    0.67789,
    0.77832,
    1,
    1,
    0.79776,
    0.97655,
    0.79776,
    1.23023,
    0.88844,
    0.9245,
    0.88844,
    0.9245,
    0.88844,
    0.9245,
    0.88844,
    0.9245,
    0.88844,
    0.9245,
    0.88844,
    0.9245,
    0.94309,
    0.98986,
    0.7306,
    0.89453,
    0.7306,
    0.76659,
    0.79004,
    0.76659,
    0.79004,
    0.76659,
    0.79004,
    1.09231,
    0.54873,
    0.8675,
    0.9245,
    0.76318,
    0.84843,
    0.84557,
    0.86651,
    1,
    1,
    0.79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    0.67009,
    0.96334,
    0.93695,
    1.35191,
    1.40909,
    0.95161,
    1.48387,
    0.8675,
    0.90861,
    0.6192,
    0.7363,
    0.64824,
    0.82411,
    0.56321,
    0.85696,
    1.23516,
    0.8675,
    0.81552,
    0.7286,
    0.84134,
    0.73206,
    0.76659,
    0.86275,
    0.84369,
    0.90685,
    0.77892,
    0.85871,
    1.02638,
    0.89249,
    0.75828,
    0.84118,
    0.85984,
    0.77452,
    0.76466,
    0.79776,
    0.7306,
    0.90782,
    0.77818,
    0.903,
    0.87291,
    0.90685,
    0.7306,
    0.99058,
    1.03667,
    0.94635,
    1.23516,
    0.9849,
    0.99058,
    0.92393,
    0.8916,
    0.942,
    1.03667,
    0.75026,
    0.94635,
    1.0297,
    1.23516,
    0.90918,
    0.94048,
    0.98217,
    0.89746,
    0.84153,
    0.92274,
    0.82507,
    0.88832,
    0.84438,
    0.88178,
    1.03525,
    0.9849,
    1.00225,
    0.78086,
    0.97248,
    0.89404,
    1.23516,
    0.9849,
    0.92274,
    0.9849,
    0.89404,
    0.73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.89693,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.85865,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.90933,
    1,
    1,
    1,
    1,
    1,
    1,
    0.94309,
    0.98986,
    0.94309,
    0.98986,
    0.94309,
    0.98986,
    0.7306,
    0.89453,
    1,
    1,
    0.89552,
    0.90527,
    1,
    0.90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    0.89552,
    0.89552,
    1.42259,
    0.68994,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    0.97858,
    0.82616,
    0.91133,
    0.83437,
    0.91133,
    1,
    1,
    1,
    0.70508,
    1,
    1.23108,
    0.79801,
    0.84426,
    0.84426,
    0.774,
    0.90572,
    1.81055,
    0.90749,
    1.81055,
    1.28809,
    1.55469,
    0.94434,
    1.07806,
    1,
    0.97094,
    0.7589,
    0.85284,
    0.90747,
    1.19658,
    0.69825,
    0.97622,
    1.33512,
    0.90747,
    0.90747,
    0.85284,
    0.90747,
    0.90747,
    1.44947,
    0.85284,
    0.8941,
    0.8941,
    0.70572,
    0.8,
    0.70572,
    0.70572,
    0.70572,
    0.70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99862,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    0.91027,
    1,
    1,
    1,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ua = {
    lineHeight: 1.2207,
    lineGap: 0.2207
  }, Ma = [
    1.3877,
    1,
    1,
    1,
    1.17223,
    1.1293,
    0.89552,
    0.91133,
    0.80395,
    1.02269,
    1.15601,
    0.91056,
    0.91056,
    1.2798,
    0.85284,
    0.89807,
    1,
    0.90861,
    1.39016,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.91133,
    0.96309,
    0.96309,
    0.85284,
    0.85284,
    0.85284,
    0.83319,
    0.88071,
    0.8675,
    0.81552,
    0.73834,
    0.85193,
    0.73206,
    0.7522,
    0.81105,
    0.86275,
    0.90685,
    0.6377,
    0.77892,
    0.75593,
    1.02638,
    0.89385,
    0.85122,
    0.77452,
    0.86503,
    0.75186,
    0.68887,
    0.79776,
    0.88844,
    0.85066,
    0.94258,
    0.77818,
    0.7306,
    0.76659,
    1.10369,
    1.39016,
    1.10369,
    1.06139,
    0.89552,
    0.8739,
    0.86128,
    0.94469,
    0.8457,
    0.94469,
    0.89464,
    1.09842,
    0.84636,
    0.94469,
    1.03297,
    1.07692,
    0.90918,
    1.03297,
    0.95897,
    0.94469,
    0.9482,
    0.94469,
    0.94469,
    1.04692,
    0.78223,
    1.20562,
    0.94469,
    0.90332,
    0.98986,
    0.86621,
    0.90527,
    0.79004,
    0.94152,
    1.77256,
    0.94152,
    0.85284,
    0.97801,
    0.89552,
    0.91133,
    0.89552,
    0.91133,
    1.91729,
    0.89552,
    1.17889,
    1.13254,
    1.08707,
    0.92098,
    0.85284,
    0.68787,
    0.71353,
    0.84737,
    0.90747,
    1.0088,
    1.0044,
    0.87683,
    1,
    1.09091,
    1,
    0.92229,
    0.739,
    1.15642,
    0.92098,
    0.76288,
    0.80504,
    0.80972,
    0.75859,
    0.8675,
    0.8675,
    0.8675,
    0.8675,
    0.8675,
    0.8675,
    0.76318,
    0.73834,
    0.73206,
    0.73206,
    0.73206,
    0.73206,
    0.90685,
    0.90685,
    0.90685,
    0.90685,
    0.86477,
    0.89385,
    0.85122,
    0.85122,
    0.85122,
    0.85122,
    0.85122,
    0.85284,
    0.85311,
    0.88844,
    0.88844,
    0.88844,
    0.88844,
    0.7306,
    0.77452,
    0.86331,
    0.86128,
    0.86128,
    0.86128,
    0.86128,
    0.86128,
    0.86128,
    0.8693,
    0.8457,
    0.89464,
    0.89464,
    0.89464,
    0.89464,
    0.82601,
    0.82601,
    0.82601,
    0.82601,
    0.94469,
    0.94469,
    0.9482,
    0.9482,
    0.9482,
    0.9482,
    0.9482,
    0.90747,
    0.86651,
    0.94469,
    0.94469,
    0.94469,
    0.94469,
    0.90527,
    0.94469,
    0.90527,
    0.8675,
    0.86128,
    0.8675,
    0.86128,
    0.8675,
    0.86128,
    0.73834,
    0.8457,
    0.73834,
    0.8457,
    0.73834,
    0.8457,
    0.73834,
    0.8457,
    0.85193,
    0.92454,
    0.86477,
    0.9921,
    0.73206,
    0.89464,
    0.73206,
    0.89464,
    0.73206,
    0.89464,
    0.73206,
    0.89464,
    0.73206,
    0.89464,
    0.81105,
    0.84636,
    0.81105,
    0.84636,
    0.81105,
    0.84636,
    1,
    1,
    0.86275,
    0.94469,
    0.90872,
    0.95786,
    0.90685,
    0.82601,
    0.90685,
    0.82601,
    0.90685,
    0.82601,
    0.90685,
    1.03297,
    0.90685,
    0.82601,
    0.77741,
    1.05611,
    0.6377,
    1.07692,
    1,
    1,
    0.90918,
    0.75593,
    1.03297,
    1,
    1,
    0.76032,
    0.90452,
    0.98156,
    1.11842,
    0.77261,
    1.11429,
    0.89385,
    0.94469,
    1,
    1,
    0.89385,
    0.94469,
    0.95877,
    0.86901,
    0.94469,
    0.85122,
    0.9482,
    0.85122,
    0.9482,
    0.85122,
    0.9482,
    0.8667,
    0.90016,
    0.75186,
    1.04692,
    1,
    1,
    0.75186,
    1.04692,
    0.68887,
    0.78223,
    0.68887,
    0.78223,
    0.68887,
    0.78223,
    0.68887,
    0.78223,
    1,
    1,
    0.79776,
    0.92188,
    0.79776,
    1.23023,
    0.88844,
    0.94469,
    0.88844,
    0.94469,
    0.88844,
    0.94469,
    0.88844,
    0.94469,
    0.88844,
    0.94469,
    0.88844,
    0.94469,
    0.94258,
    0.98986,
    0.7306,
    0.90527,
    0.7306,
    0.76659,
    0.79004,
    0.76659,
    0.79004,
    0.76659,
    0.79004,
    1.09231,
    0.54873,
    0.8675,
    0.86128,
    0.76318,
    0.8693,
    0.85311,
    0.86651,
    1,
    1,
    0.79776,
    1.20562,
    1.18622,
    1.18622,
    1,
    1.1437,
    0.67742,
    0.96334,
    0.93695,
    1.35191,
    1.40909,
    0.95161,
    1.48387,
    0.86686,
    0.90861,
    0.62267,
    0.74359,
    0.65649,
    0.85498,
    0.56963,
    0.88254,
    1.23516,
    0.8675,
    0.81552,
    0.75443,
    0.84503,
    0.73206,
    0.76659,
    0.86275,
    0.85122,
    0.90685,
    0.77892,
    0.85746,
    1.02638,
    0.89385,
    0.75657,
    0.85122,
    0.86275,
    0.77452,
    0.74171,
    0.79776,
    0.7306,
    0.95165,
    0.77818,
    0.89772,
    0.88831,
    0.90685,
    0.7306,
    0.98142,
    1.02191,
    0.96576,
    1.23516,
    0.99018,
    0.98142,
    0.9236,
    0.89258,
    0.94035,
    1.02191,
    0.78848,
    0.96576,
    0.9561,
    1.23516,
    0.90918,
    0.92578,
    0.95424,
    0.89746,
    0.83969,
    0.9482,
    0.80113,
    0.89442,
    0.85208,
    0.86155,
    0.98022,
    0.99018,
    1.00452,
    0.81209,
    0.99247,
    0.89181,
    1.23516,
    0.99018,
    0.9482,
    0.99018,
    0.89181,
    0.73206,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.88844,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.89464,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.96766,
    1,
    1,
    1,
    1,
    1,
    1,
    0.94258,
    0.98986,
    0.94258,
    0.98986,
    0.94258,
    0.98986,
    0.7306,
    0.90527,
    1,
    1,
    0.89552,
    0.90527,
    1,
    0.90186,
    1.12308,
    1.12308,
    1.12308,
    1.12308,
    1.2566,
    1.2566,
    1.2566,
    0.89552,
    0.89552,
    1.42259,
    0.69043,
    1.03809,
    1,
    1,
    1.0176,
    1.0176,
    1.11523,
    1.4956,
    2.01462,
    0.99331,
    0.82616,
    0.91133,
    0.84286,
    0.91133,
    1,
    1,
    1,
    0.70508,
    1,
    1.23108,
    0.79801,
    0.84426,
    0.84426,
    0.774,
    0.90527,
    1.81055,
    0.90527,
    1.81055,
    1.28809,
    1.55469,
    0.94434,
    1.07806,
    1,
    0.97094,
    0.7589,
    0.85284,
    0.90747,
    1.19658,
    0.69825,
    0.97622,
    1.33512,
    0.90747,
    0.90747,
    0.85356,
    0.90747,
    0.90747,
    1.44947,
    0.85284,
    0.8941,
    0.8941,
    0.70572,
    0.8,
    0.70572,
    0.70572,
    0.70572,
    0.70572,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99862,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.0336,
    0.91027,
    1,
    1,
    1,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05859,
    1.05859,
    1,
    1,
    1,
    1.07185,
    0.99413,
    0.96334,
    1.08065,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], La = {
    lineHeight: 1.2207,
    lineGap: 0.2207
  }, Ha = [
    0.76116,
    1,
    1,
    1.0006,
    0.99998,
    0.99974,
    0.99973,
    0.99973,
    0.99982,
    0.99977,
    1.00087,
    0.99998,
    0.99998,
    0.99959,
    1.00003,
    1.0006,
    0.99998,
    1.0006,
    1.0006,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    0.9999,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1.00001,
    1.00026,
    1.00022,
    0.99977,
    1.0006,
    0.99973,
    0.99977,
    1.00026,
    0.99999,
    0.99977,
    1.00022,
    1.00001,
    1.00022,
    0.99977,
    1.00001,
    1.00026,
    0.99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    0.99998,
    1.0006,
    0.99998,
    1.00003,
    0.99973,
    0.99998,
    0.99973,
    1.00026,
    0.99973,
    1.00026,
    0.99973,
    0.99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    0.99973,
    1.0006,
    0.99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.99959,
    0.99973,
    0.99998,
    1.00026,
    0.99973,
    1.00022,
    0.99973,
    0.99973,
    1,
    0.99959,
    1.00077,
    0.99959,
    1.00003,
    0.99998,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.00077,
    0.99973,
    0.99998,
    1.00025,
    0.99968,
    0.99973,
    1.00003,
    1.00025,
    0.60299,
    1.00024,
    1.06409,
    1,
    1,
    0.99998,
    1,
    0.99973,
    1.0006,
    0.99998,
    1,
    0.99936,
    0.99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1,
    0.99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99977,
    0.99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1.00001,
    1.00001,
    1.00026,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99982,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.99973,
    1.00026,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    1.03374,
    0.99977,
    1.00026,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00042,
    0.99973,
    0.99973,
    1.0006,
    0.99977,
    0.99973,
    0.99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.03828,
    1.00026,
    0.99999,
    1.00026,
    1.0006,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.9993,
    0.9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    0.99977,
    0.99959,
    0.99977,
    0.99959,
    0.99977,
    0.99959,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00026,
    0.99998,
    1.00026,
    0.8121,
    1.00026,
    0.99998,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    0.99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    0.99973,
    0.99977,
    0.99973,
    1,
    0.99982,
    1.00022,
    1.00026,
    1.00001,
    0.99973,
    1.00026,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    1.00034,
    0.99977,
    1,
    0.99997,
    1.00026,
    1.00078,
    1.00036,
    0.99973,
    1.00013,
    1.0006,
    0.99977,
    0.99977,
    0.99988,
    0.85148,
    1.00001,
    1.00026,
    0.99977,
    1.00022,
    1.0006,
    0.99977,
    1.00001,
    0.99999,
    0.99977,
    1.00069,
    1.00022,
    0.99977,
    1.00001,
    0.99984,
    1.00026,
    1.00001,
    1.00024,
    1.00001,
    0.9999,
    1,
    1.0006,
    1.00001,
    1.00041,
    0.99962,
    1.00026,
    1.0006,
    0.99995,
    1.00041,
    0.99942,
    0.99973,
    0.99927,
    1.00082,
    0.99902,
    1.00026,
    1.00087,
    1.0006,
    1.00069,
    0.99973,
    0.99867,
    0.99973,
    0.9993,
    1.00026,
    1.00049,
    1.00056,
    1,
    0.99988,
    0.99935,
    0.99995,
    0.99954,
    1.00055,
    0.99945,
    1.00032,
    1.0006,
    0.99995,
    1.00026,
    0.99995,
    1.00032,
    1.00001,
    1.00008,
    0.99971,
    1.00019,
    0.9994,
    1.00001,
    1.0006,
    1.00044,
    0.99973,
    1.00023,
    1.00047,
    1,
    0.99942,
    0.99561,
    0.99989,
    1.00035,
    0.99977,
    1.00035,
    0.99977,
    1.00019,
    0.99944,
    1.00001,
    1.00021,
    0.99926,
    1.00035,
    1.00035,
    0.99942,
    1.00048,
    0.99999,
    0.99977,
    1.00022,
    1.00035,
    1.00001,
    0.99977,
    1.00026,
    0.99989,
    1.00057,
    1.00001,
    0.99936,
    1.00052,
    1.00012,
    0.99996,
    1.00043,
    1,
    1.00035,
    0.9994,
    0.99976,
    1.00035,
    0.99973,
    1.00052,
    1.00041,
    1.00119,
    1.00037,
    0.99973,
    1.00002,
    0.99986,
    1.00041,
    1.00041,
    0.99902,
    0.9996,
    1.00034,
    0.99999,
    1.00026,
    0.99999,
    1.00026,
    0.99973,
    1.00052,
    0.99973,
    1,
    0.99973,
    1.00041,
    1.00075,
    0.9994,
    1.0003,
    0.99999,
    1,
    1.00041,
    0.99955,
    1,
    0.99915,
    0.99973,
    0.99973,
    1.00026,
    1.00119,
    0.99955,
    0.99973,
    1.0006,
    0.99911,
    1.0006,
    1.00026,
    0.99972,
    1.00026,
    0.99902,
    1.00041,
    0.99973,
    0.99999,
    1,
    1,
    1.00038,
    1.0005,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    0.99973,
    1,
    1,
    0.99973,
    1,
    1,
    0.99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    0.99973,
    0.99973,
    0.99972,
    1,
    1,
    1.00106,
    0.99999,
    0.99998,
    0.99998,
    0.99999,
    0.99998,
    1.66475,
    1,
    0.99973,
    0.99973,
    1.00023,
    0.99973,
    0.99971,
    1.00047,
    1.00023,
    1,
    0.99991,
    0.99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    0.99561,
    1.00027,
    1.00031,
    1.00031,
    0.99915,
    1.00031,
    1.00031,
    0.99999,
    1.00003,
    0.99999,
    0.99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    0.99999,
    1,
    0.99861,
    0.99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.99972,
    0.99999,
    0.99999,
    0.99999,
    0.99999,
    1.40483,
    1,
    0.99977,
    1.00054,
    1,
    1,
    0.99953,
    0.99962,
    1.00042,
    0.9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ja = {
    lineHeight: 1.2,
    lineGap: 0.2
  }, va = [
    0.76116,
    1,
    1,
    1.0006,
    0.99998,
    0.99974,
    0.99973,
    0.99973,
    0.99982,
    0.99977,
    1.00087,
    0.99998,
    0.99998,
    0.99959,
    1.00003,
    1.0006,
    0.99998,
    1.0006,
    1.0006,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99998,
    1,
    1.00003,
    1.00003,
    1.00003,
    1.00026,
    0.9999,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1.00001,
    1.00026,
    1.00022,
    0.99977,
    1.0006,
    0.99973,
    0.99977,
    1.00026,
    0.99999,
    0.99977,
    1.00022,
    1.00001,
    1.00022,
    0.99977,
    1.00001,
    1.00026,
    0.99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    0.99998,
    1.0006,
    0.99998,
    1.00003,
    0.99973,
    0.99998,
    0.99973,
    1.00026,
    0.99973,
    1.00026,
    0.99973,
    0.99998,
    1.00026,
    1.00026,
    1.0006,
    1.0006,
    0.99973,
    1.0006,
    0.99982,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.99959,
    0.99973,
    0.99998,
    1.00026,
    0.99973,
    1.00022,
    0.99973,
    0.99973,
    1,
    0.99959,
    1.00077,
    0.99959,
    1.00003,
    0.99998,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.00077,
    0.99973,
    0.99998,
    1.00025,
    0.99968,
    0.99973,
    1.00003,
    1.00025,
    0.60299,
    1.00024,
    1.06409,
    1,
    1,
    0.99998,
    1,
    0.99973,
    1.0006,
    0.99998,
    1,
    0.99936,
    0.99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1,
    0.99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99977,
    0.99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1.00001,
    1.00001,
    1.00026,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99982,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.06409,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.99973,
    1.00026,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    1.0044,
    0.99977,
    1.00026,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99971,
    0.99973,
    0.99973,
    1.0006,
    0.99977,
    0.99973,
    0.99973,
    1.00026,
    1.0006,
    1.00026,
    1.0006,
    1.00026,
    1.01011,
    1.00026,
    0.99999,
    1.00026,
    1.0006,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.9993,
    0.9998,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1.00022,
    1.00026,
    1,
    1.00016,
    0.99977,
    0.99959,
    0.99977,
    0.99959,
    0.99977,
    0.99959,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00026,
    0.99998,
    1.00026,
    0.8121,
    1.00026,
    0.99998,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    0.99977,
    1.00026,
    1.00016,
    1.00022,
    1.00001,
    0.99973,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    1.0006,
    0.99973,
    0.99977,
    0.99973,
    1,
    0.99982,
    1.00022,
    1.00026,
    1.00001,
    0.99973,
    1.00026,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99977,
    1,
    1,
    1.00026,
    0.99969,
    0.99972,
    0.99981,
    0.9998,
    1.0006,
    0.99977,
    0.99977,
    1.00022,
    0.91155,
    1.00001,
    1.00026,
    0.99977,
    1.00022,
    1.0006,
    0.99977,
    1.00001,
    0.99999,
    0.99977,
    0.99966,
    1.00022,
    1.00032,
    1.00001,
    0.99944,
    1.00026,
    1.00001,
    0.99968,
    1.00001,
    1.00047,
    1,
    1.0006,
    1.00001,
    0.99981,
    1.00101,
    1.00026,
    1.0006,
    0.99948,
    0.99981,
    1.00064,
    0.99973,
    0.99942,
    1.00101,
    1.00061,
    1.00026,
    1.00069,
    1.0006,
    1.00014,
    0.99973,
    1.01322,
    0.99973,
    1.00065,
    1.00026,
    1.00012,
    0.99923,
    1,
    1.00064,
    1.00076,
    0.99948,
    1.00055,
    1.00063,
    1.00007,
    0.99943,
    1.0006,
    0.99948,
    1.00026,
    0.99948,
    0.99943,
    1.00001,
    1.00001,
    1.00029,
    1.00038,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    0.99973,
    0.99978,
    1.00001,
    1.00057,
    0.99989,
    0.99967,
    0.99964,
    0.99967,
    0.99977,
    0.99999,
    0.99977,
    1.00038,
    0.99977,
    1.00001,
    0.99973,
    1.00066,
    0.99967,
    0.99967,
    1.00041,
    0.99998,
    0.99999,
    0.99977,
    1.00022,
    0.99967,
    1.00001,
    0.99977,
    1.00026,
    0.99964,
    1.00031,
    1.00001,
    0.99999,
    0.99999,
    1,
    1.00023,
    1,
    1,
    0.99999,
    1.00035,
    1.00001,
    0.99999,
    0.99973,
    0.99977,
    0.99999,
    1.00058,
    0.99973,
    0.99973,
    0.99955,
    0.9995,
    1.00026,
    1.00026,
    1.00032,
    0.99989,
    1.00034,
    0.99999,
    1.00026,
    1.00026,
    1.00026,
    0.99973,
    0.45998,
    0.99973,
    1.00026,
    0.99973,
    1.00001,
    0.99999,
    0.99982,
    0.99994,
    0.99996,
    1,
    1.00042,
    1.00044,
    1.00029,
    1.00023,
    0.99973,
    0.99973,
    1.00026,
    0.99949,
    1.00002,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    0.99975,
    1.00026,
    1.00026,
    1.00032,
    0.98685,
    0.99973,
    1.00026,
    1,
    1,
    0.99966,
    1.00044,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00016,
    1.00022,
    1.00001,
    0.99973,
    1,
    1,
    0.99973,
    1,
    1,
    0.99955,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1,
    1,
    1,
    0.99973,
    0.99973,
    0.99972,
    1,
    1,
    1.00106,
    0.99999,
    0.99998,
    0.99998,
    0.99999,
    0.99998,
    1.66475,
    1,
    0.99973,
    0.99973,
    1,
    0.99973,
    0.99971,
    0.99978,
    1,
    1,
    0.99991,
    0.99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00098,
    1,
    1,
    1,
    1.00049,
    1,
    1,
    0.99972,
    1,
    1.20985,
    1.39713,
    1.00003,
    1.00031,
    1.00015,
    1,
    0.99561,
    1.00027,
    1.00031,
    1.00031,
    0.99915,
    1.00031,
    1.00031,
    0.99999,
    1.00003,
    0.99999,
    0.99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    0.99999,
    1,
    0.99861,
    0.99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.99972,
    0.99999,
    0.99999,
    0.99999,
    0.99999,
    1.40483,
    1,
    0.99977,
    1.00054,
    1,
    1,
    0.99953,
    0.99962,
    1.00042,
    0.9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ya = {
    lineHeight: 1.35,
    lineGap: 0.2
  }, Ta = [
    0.76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    0.99973,
    0.99973,
    0.99982,
    1.00001,
    1.00043,
    0.99998,
    0.99998,
    0.99959,
    1.00003,
    1.0006,
    0.99998,
    1.0006,
    1.0006,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    0.99973,
    0.99987,
    1.00001,
    1.00001,
    0.99977,
    0.99977,
    1.00001,
    1.00026,
    1.00022,
    0.99977,
    1.0006,
    1,
    1.00001,
    0.99973,
    0.99999,
    0.99977,
    1.00022,
    1.00001,
    1.00022,
    0.99977,
    1.00001,
    1.00026,
    0.99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    0.99949,
    0.99973,
    0.99998,
    0.99973,
    0.99973,
    1,
    0.99973,
    0.99973,
    1.0006,
    0.99973,
    0.99973,
    0.99924,
    0.99924,
    1,
    0.99924,
    0.99999,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99998,
    1,
    1.0006,
    0.99973,
    1,
    0.99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    0.99998,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0009,
    0.99973,
    0.99998,
    1.00025,
    0.99968,
    0.99973,
    1.00003,
    1.00025,
    0.60299,
    1.00024,
    1.06409,
    1,
    1,
    0.99998,
    1,
    0.9998,
    1.0006,
    0.99998,
    1,
    0.99936,
    0.99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    0.99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99977,
    0.99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1.00001,
    1.00001,
    1.00026,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99982,
    1,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.06409,
    1.00026,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1,
    0.99973,
    1,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    0.99977,
    1,
    0.99977,
    1,
    0.99977,
    1,
    0.99977,
    1,
    0.99977,
    1.0288,
    0.99977,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99924,
    1.0006,
    1.0006,
    0.99946,
    1.00034,
    1,
    0.99924,
    1.00001,
    1,
    1,
    0.99973,
    0.99924,
    0.99973,
    0.99924,
    0.99973,
    1.06311,
    0.99973,
    1.00024,
    0.99973,
    0.99924,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    1.00041,
    0.9998,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1,
    1.00016,
    0.99977,
    0.99998,
    0.99977,
    0.99998,
    0.99977,
    0.99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    0.89547,
    1.00026,
    1.0006,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    1.00016,
    0.99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    0.99924,
    0.99973,
    1.00001,
    0.99973,
    1,
    0.99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    1.00001,
    1,
    1.00054,
    0.99977,
    1.00084,
    1.00007,
    0.99973,
    1.00013,
    0.99924,
    1.00001,
    1.00001,
    0.99945,
    0.91221,
    1.00001,
    1.00026,
    0.99977,
    1.00022,
    1.0006,
    1.00001,
    1.00001,
    0.99999,
    0.99977,
    0.99933,
    1.00022,
    1.00054,
    1.00001,
    1.00065,
    1.00026,
    1.00001,
    1.0001,
    1.00001,
    1.00052,
    1,
    1.0006,
    1.00001,
    0.99945,
    0.99897,
    0.99968,
    0.99924,
    1.00036,
    0.99945,
    0.99949,
    1,
    1.0006,
    0.99897,
    0.99918,
    0.99968,
    0.99911,
    0.99924,
    1,
    0.99962,
    1.01487,
    1,
    1.0005,
    0.99973,
    1.00012,
    1.00043,
    1,
    0.99995,
    0.99994,
    1.00036,
    0.99947,
    1.00019,
    1.00063,
    1.00025,
    0.99924,
    1.00036,
    0.99973,
    1.00036,
    1.00025,
    1.00001,
    1.00001,
    1.00027,
    1.0001,
    1.00068,
    1.00001,
    1.0006,
    1.0006,
    1,
    1.00008,
    0.99957,
    0.99972,
    0.9994,
    0.99954,
    0.99975,
    1.00051,
    1.00001,
    1.00019,
    1.00001,
    1.0001,
    0.99986,
    1.00001,
    1.00001,
    1.00038,
    0.99954,
    0.99954,
    0.9994,
    1.00066,
    0.99999,
    0.99977,
    1.00022,
    1.00054,
    1.00001,
    0.99977,
    1.00026,
    0.99975,
    1.0001,
    1.00001,
    0.99993,
    0.9995,
    0.99955,
    1.00016,
    0.99978,
    0.99974,
    1.00019,
    1.00022,
    0.99955,
    1.00053,
    0.99973,
    1.00089,
    1.00005,
    0.99967,
    1.00048,
    0.99973,
    1.00002,
    1.00034,
    0.99973,
    0.99973,
    0.99964,
    1.00006,
    1.00066,
    0.99947,
    0.99973,
    0.98894,
    0.99973,
    1,
    0.44898,
    1,
    0.99946,
    1,
    1.00039,
    1.00082,
    0.99991,
    0.99991,
    0.99985,
    1.00022,
    1.00023,
    1.00061,
    1.00006,
    0.99966,
    0.99973,
    0.99973,
    0.99973,
    1.00019,
    1.0008,
    1,
    0.99924,
    0.99924,
    0.99924,
    0.99983,
    1.00044,
    0.99973,
    0.99964,
    0.98332,
    1,
    0.99973,
    1,
    1,
    0.99962,
    0.99895,
    1.00016,
    0.99977,
    1.00016,
    0.99977,
    1.00016,
    0.99977,
    1.00001,
    1,
    1,
    1,
    0.99973,
    1,
    1,
    0.99955,
    0.99924,
    0.99924,
    0.99924,
    0.99924,
    0.99998,
    0.99998,
    0.99998,
    0.99973,
    0.99973,
    0.99972,
    1,
    1,
    1.00267,
    0.99999,
    0.99998,
    0.99998,
    1,
    0.99998,
    1.66475,
    1,
    0.99973,
    0.99973,
    1.00023,
    0.99973,
    1.00423,
    0.99925,
    0.99999,
    1,
    0.99991,
    0.99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1.00049,
    1,
    1.00245,
    1,
    1,
    1,
    1,
    0.96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    0.8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    1.00003,
    1.00031,
    1.00031,
    0.99999,
    1.00003,
    0.99999,
    0.99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    0.99999,
    1,
    0.99861,
    0.99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.95317,
    0.99999,
    0.99999,
    0.99999,
    0.99999,
    1.40483,
    1,
    0.99977,
    1.00054,
    1,
    1,
    0.99953,
    0.99962,
    1.00042,
    0.9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ka = {
    lineHeight: 1.35,
    lineGap: 0.2
  }, qa = [
    0.76116,
    1,
    1,
    1.0006,
    1.0006,
    1.00006,
    0.99973,
    0.99973,
    0.99982,
    1.00001,
    1.00043,
    0.99998,
    0.99998,
    0.99959,
    1.00003,
    1.0006,
    0.99998,
    1.0006,
    1.0006,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0006,
    1,
    1.00003,
    1.00003,
    1.00003,
    0.99973,
    0.99987,
    1.00001,
    1.00001,
    0.99977,
    0.99977,
    1.00001,
    1.00026,
    1.00022,
    0.99977,
    1.0006,
    1,
    1.00001,
    0.99973,
    0.99999,
    0.99977,
    1.00022,
    1.00001,
    1.00022,
    0.99977,
    1.00001,
    1.00026,
    0.99977,
    1.00001,
    1.00016,
    1.00001,
    1.00001,
    1.00026,
    1.0006,
    1.0006,
    1.0006,
    0.99949,
    0.99973,
    0.99998,
    0.99973,
    0.99973,
    1,
    0.99973,
    0.99973,
    1.0006,
    0.99973,
    0.99973,
    0.99924,
    0.99924,
    1,
    0.99924,
    0.99999,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99998,
    1,
    1.0006,
    0.99973,
    1,
    0.99977,
    1,
    1,
    1,
    1.00005,
    1.0009,
    1.00005,
    1.00003,
    0.99998,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0009,
    0.99973,
    0.99998,
    1.00025,
    0.99968,
    0.99973,
    1.00003,
    1.00025,
    0.60299,
    1.00024,
    1.06409,
    1,
    1,
    0.99998,
    1,
    0.9998,
    1.0006,
    0.99998,
    1,
    0.99936,
    0.99973,
    1.00002,
    1.00002,
    1.00002,
    1.00026,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1,
    0.99977,
    1.00001,
    1.00001,
    1.00001,
    1.00001,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99977,
    0.99977,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00022,
    1.00003,
    1.00022,
    0.99977,
    0.99977,
    0.99977,
    0.99977,
    1.00001,
    1.00001,
    1.00026,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99982,
    1,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1.06409,
    1.00026,
    0.99973,
    0.99973,
    0.99973,
    0.99973,
    1,
    0.99973,
    1,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    0.99977,
    1,
    0.99977,
    1,
    0.99977,
    1,
    0.99977,
    1,
    0.99977,
    1.04596,
    0.99977,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00001,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    1.0006,
    0.99924,
    1.0006,
    1.0006,
    1.00019,
    1.00034,
    1,
    0.99924,
    1.00001,
    1,
    1,
    0.99973,
    0.99924,
    0.99973,
    0.99924,
    0.99973,
    1.02572,
    0.99973,
    1.00005,
    0.99973,
    0.99924,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99999,
    0.9998,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1.00022,
    0.99973,
    1,
    1.00016,
    0.99977,
    0.99998,
    0.99977,
    0.99998,
    0.99977,
    0.99998,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00001,
    1,
    1.00026,
    1.0006,
    1.00026,
    0.84533,
    1.00026,
    1.0006,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    0.99977,
    0.99973,
    1.00016,
    0.99977,
    1.00001,
    1,
    1.00001,
    1.00026,
    1,
    1.00026,
    1,
    1.00026,
    1,
    0.99924,
    0.99973,
    1.00001,
    0.99973,
    1,
    0.99982,
    1.00022,
    1.00026,
    1.00001,
    1,
    1.00026,
    1.0006,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99998,
    0.99928,
    1,
    0.99977,
    1.00013,
    1.00055,
    0.99947,
    0.99945,
    0.99941,
    0.99924,
    1.00001,
    1.00001,
    1.0004,
    0.91621,
    1.00001,
    1.00026,
    0.99977,
    1.00022,
    1.0006,
    1.00001,
    1.00005,
    0.99999,
    0.99977,
    1.00015,
    1.00022,
    0.99977,
    1.00001,
    0.99973,
    1.00026,
    1.00001,
    1.00019,
    1.00001,
    0.99946,
    1,
    1.0006,
    1.00001,
    0.99978,
    1.00045,
    0.99973,
    0.99924,
    1.00023,
    0.99978,
    0.99966,
    1,
    1.00065,
    1.00045,
    1.00019,
    0.99973,
    0.99973,
    0.99924,
    1,
    1,
    0.96499,
    1,
    1.00055,
    0.99973,
    1.00008,
    1.00027,
    1,
    0.9997,
    0.99995,
    1.00023,
    0.99933,
    1.00019,
    1.00015,
    1.00031,
    0.99924,
    1.00023,
    0.99973,
    1.00023,
    1.00031,
    1.00001,
    0.99928,
    1.00029,
    1.00092,
    1.00035,
    1.00001,
    1.0006,
    1.0006,
    1,
    0.99988,
    0.99975,
    1,
    1.00082,
    0.99561,
    0.9996,
    1.00035,
    1.00001,
    0.99962,
    1.00001,
    1.00092,
    0.99964,
    1.00001,
    0.99963,
    0.99999,
    1.00035,
    1.00035,
    1.00082,
    0.99962,
    0.99999,
    0.99977,
    1.00022,
    1.00035,
    1.00001,
    0.99977,
    1.00026,
    0.9996,
    0.99967,
    1.00001,
    1.00034,
    1.00074,
    1.00054,
    1.00053,
    1.00063,
    0.99971,
    0.99962,
    1.00035,
    0.99975,
    0.99977,
    0.99973,
    1.00043,
    0.99953,
    1.0007,
    0.99915,
    0.99973,
    1.00008,
    0.99892,
    1.00073,
    1.00073,
    1.00114,
    0.99915,
    1.00073,
    0.99955,
    0.99973,
    1.00092,
    0.99973,
    1,
    0.99998,
    1,
    1.0003,
    1,
    1.00043,
    1.00001,
    0.99969,
    1.0003,
    1,
    1.00035,
    1.00001,
    0.9995,
    1,
    1.00092,
    0.99973,
    0.99973,
    0.99973,
    1.0007,
    0.9995,
    1,
    0.99924,
    1.0006,
    0.99924,
    0.99972,
    1.00062,
    0.99973,
    1.00114,
    1.00073,
    1,
    0.99955,
    1,
    1,
    1.00047,
    0.99968,
    1.00016,
    0.99977,
    1.00016,
    0.99977,
    1.00016,
    0.99977,
    1.00001,
    1,
    1,
    1,
    0.99973,
    1,
    1,
    0.99955,
    0.99924,
    0.99924,
    0.99924,
    0.99924,
    0.99998,
    0.99998,
    0.99998,
    0.99973,
    0.99973,
    0.99972,
    1,
    1,
    1.00267,
    0.99999,
    0.99998,
    0.99998,
    1,
    0.99998,
    1.66475,
    1,
    0.99973,
    0.99973,
    1.00023,
    0.99973,
    0.99971,
    0.99925,
    1.00023,
    1,
    0.99991,
    0.99984,
    1.00002,
    1.00002,
    1.00002,
    1.00002,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.96329,
    1,
    1.20985,
    1.39713,
    1.00003,
    0.8254,
    1.00015,
    1,
    1.00035,
    1.00027,
    1.00031,
    1.00031,
    0.99915,
    1.00031,
    1.00031,
    0.99999,
    1.00003,
    0.99999,
    0.99999,
    1.41144,
    1.6,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.41144,
    1.40579,
    1.40579,
    1.36625,
    0.99999,
    1,
    0.99861,
    0.99861,
    1,
    1.00026,
    1.00026,
    1.00026,
    1.00026,
    0.95317,
    0.99999,
    0.99999,
    0.99999,
    0.99999,
    1.40483,
    1,
    0.99977,
    1.00054,
    1,
    1,
    0.99953,
    0.99962,
    1.00042,
    0.9995,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Oa = {
    lineHeight: 1.2,
    lineGap: 0.2
  }, Pa = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    719,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    785,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    385,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    465,
    722,
    333,
    853,
    906,
    474,
    825,
    927,
    838,
    278,
    722,
    722,
    601,
    719,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    644,
    778,
    722,
    667,
    600,
    611,
    667,
    821,
    667,
    809,
    802,
    278,
    667,
    615,
    451,
    611,
    278,
    582,
    615,
    610,
    556,
    606,
    475,
    460,
    611,
    541,
    278,
    558,
    556,
    612,
    556,
    445,
    611,
    766,
    619,
    520,
    684,
    446,
    582,
    715,
    576,
    753,
    845,
    278,
    582,
    611,
    582,
    845,
    667,
    669,
    885,
    567,
    711,
    667,
    278,
    276,
    556,
    1094,
    1062,
    875,
    610,
    722,
    622,
    719,
    722,
    719,
    722,
    567,
    712,
    667,
    904,
    626,
    719,
    719,
    610,
    702,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    622,
    854,
    667,
    730,
    703,
    1005,
    1019,
    870,
    979,
    719,
    711,
    1031,
    719,
    556,
    618,
    615,
    417,
    635,
    556,
    709,
    497,
    615,
    615,
    500,
    635,
    740,
    604,
    611,
    604,
    611,
    556,
    490,
    556,
    875,
    556,
    615,
    581,
    833,
    844,
    729,
    854,
    615,
    552,
    854,
    583,
    556,
    556,
    611,
    417,
    552,
    556,
    278,
    281,
    278,
    969,
    906,
    611,
    500,
    615,
    556,
    604,
    778,
    611,
    487,
    447,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1094,
    556,
    885,
    489,
    1115,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
  ], Wa = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ], ja = [
    365,
    0,
    333,
    278,
    333,
    474,
    556,
    556,
    889,
    722,
    238,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    333,
    333,
    584,
    584,
    584,
    611,
    975,
    722,
    722,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    556,
    722,
    611,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    333,
    278,
    333,
    584,
    556,
    333,
    556,
    611,
    556,
    611,
    556,
    333,
    611,
    611,
    278,
    278,
    556,
    278,
    889,
    611,
    611,
    611,
    611,
    389,
    556,
    333,
    611,
    556,
    778,
    556,
    556,
    500,
    389,
    280,
    389,
    584,
    333,
    556,
    556,
    556,
    556,
    280,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    556,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    722,
    722,
    722,
    722,
    722,
    722,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    611,
    611,
    611,
    611,
    611,
    611,
    611,
    549,
    611,
    611,
    611,
    611,
    611,
    556,
    611,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    740,
    722,
    611,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    722,
    611,
    722,
    611,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    782,
    556,
    556,
    278,
    722,
    556,
    556,
    611,
    278,
    611,
    278,
    611,
    396,
    611,
    479,
    611,
    278,
    722,
    611,
    722,
    611,
    722,
    611,
    708,
    723,
    611,
    778,
    611,
    778,
    611,
    778,
    611,
    1e3,
    944,
    722,
    389,
    722,
    389,
    722,
    389,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    611,
    333,
    611,
    479,
    611,
    333,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    722,
    611,
    944,
    778,
    667,
    556,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    278,
    556,
    722,
    556,
    1e3,
    889,
    778,
    611,
    667,
    556,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    722,
    333,
    854,
    906,
    473,
    844,
    930,
    847,
    278,
    722,
    722,
    610,
    671,
    667,
    611,
    722,
    778,
    278,
    722,
    667,
    833,
    722,
    657,
    778,
    718,
    667,
    590,
    611,
    667,
    822,
    667,
    829,
    781,
    278,
    667,
    620,
    479,
    611,
    278,
    591,
    620,
    621,
    556,
    610,
    479,
    492,
    611,
    558,
    278,
    566,
    556,
    603,
    556,
    450,
    611,
    712,
    605,
    532,
    664,
    409,
    591,
    704,
    578,
    773,
    834,
    278,
    591,
    611,
    591,
    834,
    667,
    667,
    886,
    614,
    719,
    667,
    278,
    278,
    556,
    1094,
    1042,
    854,
    622,
    719,
    677,
    719,
    722,
    708,
    722,
    614,
    722,
    667,
    927,
    643,
    719,
    719,
    615,
    687,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    677,
    781,
    667,
    729,
    708,
    979,
    989,
    854,
    1e3,
    708,
    719,
    1042,
    729,
    556,
    619,
    604,
    534,
    618,
    556,
    736,
    510,
    611,
    611,
    507,
    622,
    740,
    604,
    611,
    611,
    611,
    556,
    889,
    556,
    885,
    556,
    646,
    583,
    889,
    935,
    707,
    854,
    594,
    552,
    865,
    589,
    556,
    556,
    611,
    469,
    563,
    556,
    278,
    278,
    278,
    969,
    906,
    611,
    507,
    619,
    556,
    611,
    778,
    611,
    575,
    467,
    944,
    778,
    944,
    778,
    944,
    778,
    667,
    556,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    278,
    278,
    278,
    278,
    500,
    500,
    500,
    556,
    556,
    350,
    1e3,
    1e3,
    240,
    479,
    333,
    333,
    604,
    333,
    167,
    396,
    556,
    556,
    1104,
    556,
    885,
    516,
    1146,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    999,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    722,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    611,
    611,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333
  ], Xa = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ], Za = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    625,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    733,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    281,
    556,
    400,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    615,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    354,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    789,
    846,
    389,
    794,
    865,
    775,
    222,
    667,
    667,
    570,
    671,
    667,
    611,
    722,
    778,
    278,
    667,
    667,
    833,
    722,
    648,
    778,
    725,
    667,
    600,
    611,
    667,
    837,
    667,
    831,
    761,
    278,
    667,
    570,
    439,
    555,
    222,
    550,
    570,
    571,
    500,
    556,
    439,
    463,
    555,
    542,
    222,
    500,
    492,
    548,
    500,
    447,
    556,
    670,
    573,
    486,
    603,
    374,
    550,
    652,
    546,
    728,
    779,
    222,
    550,
    556,
    550,
    779,
    667,
    667,
    843,
    544,
    708,
    667,
    278,
    278,
    500,
    1066,
    982,
    844,
    589,
    715,
    639,
    724,
    667,
    651,
    667,
    544,
    704,
    667,
    917,
    614,
    715,
    715,
    589,
    686,
    833,
    722,
    778,
    725,
    667,
    722,
    611,
    639,
    795,
    667,
    727,
    673,
    920,
    923,
    805,
    886,
    651,
    694,
    1022,
    682,
    556,
    562,
    522,
    493,
    553,
    556,
    688,
    465,
    556,
    556,
    472,
    564,
    686,
    550,
    556,
    556,
    556,
    500,
    833,
    500,
    835,
    500,
    572,
    518,
    830,
    851,
    621,
    736,
    526,
    492,
    752,
    534,
    556,
    556,
    556,
    378,
    496,
    500,
    222,
    222,
    222,
    910,
    828,
    556,
    472,
    565,
    500,
    556,
    778,
    556,
    492,
    339,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1083,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    998,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    584,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
  ], Va = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ], _a = [
    365,
    0,
    333,
    278,
    278,
    355,
    556,
    556,
    889,
    667,
    191,
    333,
    333,
    389,
    584,
    278,
    333,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    278,
    278,
    584,
    584,
    584,
    556,
    1015,
    667,
    667,
    722,
    722,
    667,
    611,
    778,
    722,
    278,
    500,
    667,
    556,
    833,
    722,
    778,
    667,
    778,
    722,
    667,
    611,
    722,
    667,
    944,
    667,
    667,
    611,
    278,
    278,
    278,
    469,
    556,
    333,
    556,
    556,
    500,
    556,
    556,
    278,
    556,
    556,
    222,
    222,
    500,
    222,
    833,
    556,
    556,
    556,
    556,
    333,
    500,
    278,
    556,
    500,
    722,
    500,
    500,
    500,
    334,
    260,
    334,
    584,
    333,
    556,
    556,
    556,
    556,
    260,
    556,
    333,
    737,
    370,
    556,
    584,
    737,
    552,
    400,
    549,
    333,
    333,
    333,
    576,
    537,
    278,
    333,
    333,
    365,
    556,
    834,
    834,
    834,
    611,
    667,
    667,
    667,
    667,
    667,
    667,
    1e3,
    722,
    667,
    667,
    667,
    667,
    278,
    278,
    278,
    278,
    722,
    722,
    778,
    778,
    778,
    778,
    778,
    584,
    778,
    722,
    722,
    722,
    722,
    667,
    667,
    611,
    556,
    556,
    556,
    556,
    556,
    556,
    889,
    500,
    556,
    556,
    556,
    556,
    278,
    278,
    278,
    278,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    549,
    611,
    556,
    556,
    556,
    556,
    500,
    556,
    500,
    667,
    556,
    667,
    556,
    667,
    556,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    500,
    722,
    615,
    722,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    667,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    722,
    556,
    722,
    556,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    222,
    278,
    278,
    735,
    444,
    500,
    222,
    667,
    500,
    500,
    556,
    222,
    556,
    222,
    556,
    292,
    556,
    334,
    556,
    222,
    722,
    556,
    722,
    556,
    722,
    556,
    604,
    723,
    556,
    778,
    556,
    778,
    556,
    778,
    556,
    1e3,
    944,
    722,
    333,
    722,
    333,
    722,
    333,
    667,
    500,
    667,
    500,
    667,
    500,
    667,
    500,
    611,
    278,
    611,
    375,
    611,
    278,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    722,
    556,
    944,
    722,
    667,
    500,
    667,
    611,
    500,
    611,
    500,
    611,
    500,
    222,
    556,
    667,
    556,
    1e3,
    889,
    778,
    611,
    667,
    500,
    611,
    278,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    667,
    278,
    784,
    838,
    384,
    774,
    855,
    752,
    222,
    667,
    667,
    551,
    668,
    667,
    611,
    722,
    778,
    278,
    667,
    668,
    833,
    722,
    650,
    778,
    722,
    667,
    618,
    611,
    667,
    798,
    667,
    835,
    748,
    278,
    667,
    578,
    446,
    556,
    222,
    547,
    578,
    575,
    500,
    557,
    446,
    441,
    556,
    556,
    222,
    500,
    500,
    576,
    500,
    448,
    556,
    690,
    569,
    482,
    617,
    395,
    547,
    648,
    525,
    713,
    781,
    222,
    547,
    556,
    547,
    781,
    667,
    667,
    865,
    542,
    719,
    667,
    278,
    278,
    500,
    1057,
    1010,
    854,
    583,
    722,
    635,
    719,
    667,
    656,
    667,
    542,
    677,
    667,
    923,
    604,
    719,
    719,
    583,
    656,
    833,
    722,
    778,
    719,
    667,
    722,
    611,
    635,
    760,
    667,
    740,
    667,
    917,
    938,
    792,
    885,
    656,
    719,
    1010,
    722,
    556,
    573,
    531,
    365,
    583,
    556,
    669,
    458,
    559,
    559,
    438,
    583,
    688,
    552,
    556,
    542,
    556,
    500,
    458,
    500,
    823,
    500,
    573,
    521,
    802,
    823,
    625,
    719,
    521,
    510,
    750,
    542,
    556,
    556,
    556,
    365,
    510,
    500,
    222,
    278,
    222,
    906,
    812,
    556,
    438,
    559,
    500,
    552,
    778,
    556,
    489,
    411,
    944,
    722,
    944,
    722,
    944,
    722,
    667,
    500,
    333,
    333,
    556,
    1e3,
    1e3,
    552,
    222,
    222,
    222,
    222,
    333,
    333,
    333,
    556,
    556,
    350,
    1e3,
    1e3,
    188,
    354,
    333,
    333,
    500,
    333,
    167,
    365,
    556,
    556,
    1094,
    556,
    885,
    323,
    1073,
    1e3,
    768,
    600,
    834,
    834,
    834,
    834,
    1e3,
    500,
    1e3,
    500,
    1e3,
    500,
    500,
    494,
    612,
    823,
    713,
    584,
    549,
    713,
    979,
    719,
    274,
    549,
    549,
    583,
    549,
    549,
    604,
    584,
    604,
    604,
    708,
    625,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    708,
    729,
    604,
    604,
    354,
    354,
    1e3,
    990,
    990,
    990,
    990,
    494,
    604,
    604,
    604,
    604,
    354,
    1021,
    1052,
    917,
    750,
    750,
    531,
    656,
    594,
    510,
    500,
    750,
    750,
    500,
    500,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    222,
    222,
    294,
    294,
    324,
    324,
    316,
    328,
    398,
    285
  ], za = [
    -1,
    -1,
    -1,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378,
    379,
    380,
    381,
    382,
    383,
    402,
    506,
    507,
    508,
    509,
    510,
    511,
    536,
    537,
    538,
    539,
    710,
    711,
    713,
    728,
    729,
    730,
    731,
    732,
    733,
    900,
    901,
    902,
    903,
    904,
    905,
    906,
    908,
    910,
    911,
    912,
    913,
    914,
    915,
    916,
    917,
    918,
    919,
    920,
    921,
    922,
    923,
    924,
    925,
    926,
    927,
    928,
    929,
    931,
    932,
    933,
    934,
    935,
    936,
    937,
    938,
    939,
    940,
    941,
    942,
    943,
    944,
    945,
    946,
    947,
    948,
    949,
    950,
    951,
    952,
    953,
    954,
    955,
    956,
    957,
    958,
    959,
    960,
    961,
    962,
    963,
    964,
    965,
    966,
    967,
    968,
    969,
    970,
    971,
    972,
    973,
    974,
    1024,
    1025,
    1026,
    1027,
    1028,
    1029,
    1030,
    1031,
    1032,
    1033,
    1034,
    1035,
    1036,
    1037,
    1038,
    1039,
    1040,
    1041,
    1042,
    1043,
    1044,
    1045,
    1046,
    1047,
    1048,
    1049,
    1050,
    1051,
    1052,
    1053,
    1054,
    1055,
    1056,
    1057,
    1058,
    1059,
    1060,
    1061,
    1062,
    1063,
    1064,
    1065,
    1066,
    1067,
    1068,
    1069,
    1070,
    1071,
    1072,
    1073,
    1074,
    1075,
    1076,
    1077,
    1078,
    1079,
    1080,
    1081,
    1082,
    1083,
    1084,
    1085,
    1086,
    1087,
    1088,
    1089,
    1090,
    1091,
    1092,
    1093,
    1094,
    1095,
    1096,
    1097,
    1098,
    1099,
    1100,
    1101,
    1102,
    1103,
    1104,
    1105,
    1106,
    1107,
    1108,
    1109,
    1110,
    1111,
    1112,
    1113,
    1114,
    1115,
    1116,
    1117,
    1118,
    1119,
    1138,
    1139,
    1168,
    1169,
    7808,
    7809,
    7810,
    7811,
    7812,
    7813,
    7922,
    7923,
    8208,
    8209,
    8211,
    8212,
    8213,
    8215,
    8216,
    8217,
    8218,
    8219,
    8220,
    8221,
    8222,
    8224,
    8225,
    8226,
    8230,
    8240,
    8242,
    8243,
    8249,
    8250,
    8252,
    8254,
    8260,
    8319,
    8355,
    8356,
    8359,
    8364,
    8453,
    8467,
    8470,
    8482,
    8486,
    8494,
    8539,
    8540,
    8541,
    8542,
    8592,
    8593,
    8594,
    8595,
    8596,
    8597,
    8616,
    8706,
    8710,
    8719,
    8721,
    8722,
    8730,
    8734,
    8735,
    8745,
    8747,
    8776,
    8800,
    8801,
    8804,
    8805,
    8962,
    8976,
    8992,
    8993,
    9472,
    9474,
    9484,
    9488,
    9492,
    9496,
    9500,
    9508,
    9516,
    9524,
    9532,
    9552,
    9553,
    9554,
    9555,
    9556,
    9557,
    9558,
    9559,
    9560,
    9561,
    9562,
    9563,
    9564,
    9565,
    9566,
    9567,
    9568,
    9569,
    9570,
    9571,
    9572,
    9573,
    9574,
    9575,
    9576,
    9577,
    9578,
    9579,
    9580,
    9600,
    9604,
    9608,
    9612,
    9616,
    9617,
    9618,
    9619,
    9632,
    9633,
    9642,
    9643,
    9644,
    9650,
    9658,
    9660,
    9668,
    9674,
    9675,
    9679,
    9688,
    9689,
    9702,
    9786,
    9787,
    9788,
    9792,
    9794,
    9824,
    9827,
    9829,
    9830,
    9834,
    9835,
    9836,
    61441,
    61442,
    61445,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ], $a = [
    1.36898,
    1,
    1,
    0.72706,
    0.80479,
    0.83734,
    0.98894,
    0.99793,
    0.9897,
    0.93884,
    0.86209,
    0.94292,
    0.94292,
    1.16661,
    1.02058,
    0.93582,
    0.96694,
    0.93582,
    1.19137,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    0.78076,
    0.78076,
    1.02058,
    1.02058,
    1.02058,
    0.72851,
    0.78966,
    0.90838,
    0.83637,
    0.82391,
    0.96376,
    0.80061,
    0.86275,
    0.8768,
    0.95407,
    1.0258,
    0.73901,
    0.85022,
    0.83655,
    1.0156,
    0.95546,
    0.92179,
    0.87107,
    0.92179,
    0.82114,
    0.8096,
    0.89713,
    0.94438,
    0.95353,
    0.94083,
    0.91905,
    0.90406,
    0.9446,
    0.94292,
    1.18777,
    0.94292,
    1.02058,
    0.89903,
    0.90088,
    0.94938,
    0.97898,
    0.81093,
    0.97571,
    0.94938,
    1.024,
    0.9577,
    0.95933,
    0.98621,
    1.0474,
    0.97455,
    0.98981,
    0.9672,
    0.95933,
    0.9446,
    0.97898,
    0.97407,
    0.97646,
    0.78036,
    1.10208,
    0.95442,
    0.95298,
    0.97579,
    0.9332,
    0.94039,
    0.938,
    0.80687,
    1.01149,
    0.80687,
    1.02058,
    0.80479,
    0.99793,
    0.99793,
    0.99793,
    0.99793,
    1.01149,
    1.00872,
    0.90088,
    0.91882,
    1.0213,
    0.8361,
    1.02058,
    0.62295,
    0.54324,
    0.89022,
    1.08595,
    1,
    1,
    0.90088,
    1,
    0.97455,
    0.93582,
    0.90088,
    1,
    1.05686,
    0.8361,
    0.99642,
    0.99642,
    0.99642,
    0.72851,
    0.90838,
    0.90838,
    0.90838,
    0.90838,
    0.90838,
    0.90838,
    0.868,
    0.82391,
    0.80061,
    0.80061,
    0.80061,
    0.80061,
    1.0258,
    1.0258,
    1.0258,
    1.0258,
    0.97484,
    0.95546,
    0.92179,
    0.92179,
    0.92179,
    0.92179,
    0.92179,
    1.02058,
    0.92179,
    0.94438,
    0.94438,
    0.94438,
    0.94438,
    0.90406,
    0.86958,
    0.98225,
    0.94938,
    0.94938,
    0.94938,
    0.94938,
    0.94938,
    0.94938,
    0.9031,
    0.81093,
    0.94938,
    0.94938,
    0.94938,
    0.94938,
    0.98621,
    0.98621,
    0.98621,
    0.98621,
    0.93969,
    0.95933,
    0.9446,
    0.9446,
    0.9446,
    0.9446,
    0.9446,
    1.08595,
    0.9446,
    0.95442,
    0.95442,
    0.95442,
    0.95442,
    0.94039,
    0.97898,
    0.94039,
    0.90838,
    0.94938,
    0.90838,
    0.94938,
    0.90838,
    0.94938,
    0.82391,
    0.81093,
    0.82391,
    0.81093,
    0.82391,
    0.81093,
    0.82391,
    0.81093,
    0.96376,
    0.84313,
    0.97484,
    0.97571,
    0.80061,
    0.94938,
    0.80061,
    0.94938,
    0.80061,
    0.94938,
    0.80061,
    0.94938,
    0.80061,
    0.94938,
    0.8768,
    0.9577,
    0.8768,
    0.9577,
    0.8768,
    0.9577,
    1,
    1,
    0.95407,
    0.95933,
    0.97069,
    0.95933,
    1.0258,
    0.98621,
    1.0258,
    0.98621,
    1.0258,
    0.98621,
    1.0258,
    0.98621,
    1.0258,
    0.98621,
    0.887,
    1.01591,
    0.73901,
    1.0474,
    1,
    1,
    0.97455,
    0.83655,
    0.98981,
    1,
    1,
    0.83655,
    0.73977,
    0.83655,
    0.73903,
    0.84638,
    1.033,
    0.95546,
    0.95933,
    1,
    1,
    0.95546,
    0.95933,
    0.8271,
    0.95417,
    0.95933,
    0.92179,
    0.9446,
    0.92179,
    0.9446,
    0.92179,
    0.9446,
    0.936,
    0.91964,
    0.82114,
    0.97646,
    1,
    1,
    0.82114,
    0.97646,
    0.8096,
    0.78036,
    0.8096,
    0.78036,
    1,
    1,
    0.8096,
    0.78036,
    1,
    1,
    0.89713,
    0.77452,
    0.89713,
    1.10208,
    0.94438,
    0.95442,
    0.94438,
    0.95442,
    0.94438,
    0.95442,
    0.94438,
    0.95442,
    0.94438,
    0.95442,
    0.94438,
    0.95442,
    0.94083,
    0.97579,
    0.90406,
    0.94039,
    0.90406,
    0.9446,
    0.938,
    0.9446,
    0.938,
    0.9446,
    0.938,
    1,
    0.99793,
    0.90838,
    0.94938,
    0.868,
    0.9031,
    0.92179,
    0.9446,
    1,
    1,
    0.89713,
    1.10208,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90989,
    0.9358,
    0.91945,
    0.83181,
    0.75261,
    0.87992,
    0.82976,
    0.96034,
    0.83689,
    0.97268,
    1.0078,
    0.90838,
    0.83637,
    0.8019,
    0.90157,
    0.80061,
    0.9446,
    0.95407,
    0.92436,
    1.0258,
    0.85022,
    0.97153,
    1.0156,
    0.95546,
    0.89192,
    0.92179,
    0.92361,
    0.87107,
    0.96318,
    0.89713,
    0.93704,
    0.95638,
    0.91905,
    0.91709,
    0.92796,
    1.0258,
    0.93704,
    0.94836,
    1.0373,
    0.95933,
    1.0078,
    0.95871,
    0.94836,
    0.96174,
    0.92601,
    0.9498,
    0.98607,
    0.95776,
    0.95933,
    1.05453,
    1.0078,
    0.98275,
    0.9314,
    0.95617,
    0.91701,
    1.05993,
    0.9446,
    0.78367,
    0.9553,
    1,
    0.86832,
    1.0128,
    0.95871,
    0.99394,
    0.87548,
    0.96361,
    0.86774,
    1.0078,
    0.95871,
    0.9446,
    0.95871,
    0.86774,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.94083,
    0.97579,
    0.94083,
    0.97579,
    0.94083,
    0.97579,
    0.90406,
    0.94039,
    0.96694,
    1,
    0.89903,
    1,
    1,
    1,
    0.93582,
    0.93582,
    0.93582,
    1,
    0.908,
    0.908,
    0.918,
    0.94219,
    0.94219,
    0.96544,
    1,
    1.285,
    1,
    1,
    0.81079,
    0.81079,
    1,
    1,
    0.74854,
    1,
    1,
    1,
    1,
    0.99793,
    1,
    1,
    1,
    0.65,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.17173,
    1,
    0.80535,
    0.76169,
    1.02058,
    1.0732,
    1.05486,
    1,
    1,
    1.30692,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.16161,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ar = {
    lineHeight: 1.2,
    lineGap: 0.2
  }, er = [
    1.36898,
    1,
    1,
    0.66227,
    0.80779,
    0.81625,
    0.97276,
    0.97276,
    0.97733,
    0.92222,
    0.83266,
    0.94292,
    0.94292,
    1.16148,
    1.02058,
    0.93582,
    0.96694,
    0.93582,
    1.17337,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.78076,
    0.78076,
    1.02058,
    1.02058,
    1.02058,
    0.71541,
    0.76813,
    0.85576,
    0.80591,
    0.80729,
    0.94299,
    0.77512,
    0.83655,
    0.86523,
    0.92222,
    0.98621,
    0.71743,
    0.81698,
    0.79726,
    0.98558,
    0.92222,
    0.90637,
    0.83809,
    0.90637,
    0.80729,
    0.76463,
    0.86275,
    0.90699,
    0.91605,
    0.9154,
    0.85308,
    0.85458,
    0.90531,
    0.94292,
    1.21296,
    0.94292,
    1.02058,
    0.89903,
    1.18616,
    0.99613,
    0.91677,
    0.78216,
    0.91677,
    0.90083,
    0.98796,
    0.9135,
    0.92168,
    0.95381,
    0.98981,
    0.95298,
    0.95381,
    0.93459,
    0.92168,
    0.91513,
    0.92004,
    0.91677,
    0.95077,
    0.748,
    1.04502,
    0.91677,
    0.92061,
    0.94236,
    0.89544,
    0.89364,
    0.9,
    0.80687,
    0.8578,
    0.80687,
    1.02058,
    0.80779,
    0.97276,
    0.97276,
    0.97276,
    0.97276,
    0.8578,
    0.99973,
    1.18616,
    0.91339,
    1.08074,
    0.82891,
    1.02058,
    0.55509,
    0.71526,
    0.89022,
    1.08595,
    1,
    1,
    1.18616,
    1,
    0.96736,
    0.93582,
    1.18616,
    1,
    1.04864,
    0.82711,
    0.99043,
    0.99043,
    0.99043,
    0.71541,
    0.85576,
    0.85576,
    0.85576,
    0.85576,
    0.85576,
    0.85576,
    0.845,
    0.80729,
    0.77512,
    0.77512,
    0.77512,
    0.77512,
    0.98621,
    0.98621,
    0.98621,
    0.98621,
    0.95961,
    0.92222,
    0.90637,
    0.90637,
    0.90637,
    0.90637,
    0.90637,
    1.02058,
    0.90251,
    0.90699,
    0.90699,
    0.90699,
    0.90699,
    0.85458,
    0.83659,
    0.94951,
    0.99613,
    0.99613,
    0.99613,
    0.99613,
    0.99613,
    0.99613,
    0.85811,
    0.78216,
    0.90083,
    0.90083,
    0.90083,
    0.90083,
    0.95381,
    0.95381,
    0.95381,
    0.95381,
    0.9135,
    0.92168,
    0.91513,
    0.91513,
    0.91513,
    0.91513,
    0.91513,
    1.08595,
    0.91677,
    0.91677,
    0.91677,
    0.91677,
    0.91677,
    0.89364,
    0.92332,
    0.89364,
    0.85576,
    0.99613,
    0.85576,
    0.99613,
    0.85576,
    0.99613,
    0.80729,
    0.78216,
    0.80729,
    0.78216,
    0.80729,
    0.78216,
    0.80729,
    0.78216,
    0.94299,
    0.76783,
    0.95961,
    0.91677,
    0.77512,
    0.90083,
    0.77512,
    0.90083,
    0.77512,
    0.90083,
    0.77512,
    0.90083,
    0.77512,
    0.90083,
    0.86523,
    0.9135,
    0.86523,
    0.9135,
    0.86523,
    0.9135,
    1,
    1,
    0.92222,
    0.92168,
    0.92222,
    0.92168,
    0.98621,
    0.95381,
    0.98621,
    0.95381,
    0.98621,
    0.95381,
    0.98621,
    0.95381,
    0.98621,
    0.95381,
    0.86036,
    0.97096,
    0.71743,
    0.98981,
    1,
    1,
    0.95298,
    0.79726,
    0.95381,
    1,
    1,
    0.79726,
    0.6894,
    0.79726,
    0.74321,
    0.81691,
    1.0006,
    0.92222,
    0.92168,
    1,
    1,
    0.92222,
    0.92168,
    0.79464,
    0.92098,
    0.92168,
    0.90637,
    0.91513,
    0.90637,
    0.91513,
    0.90637,
    0.91513,
    0.909,
    0.87514,
    0.80729,
    0.95077,
    1,
    1,
    0.80729,
    0.95077,
    0.76463,
    0.748,
    0.76463,
    0.748,
    1,
    1,
    0.76463,
    0.748,
    1,
    1,
    0.86275,
    0.72651,
    0.86275,
    1.04502,
    0.90699,
    0.91677,
    0.90699,
    0.91677,
    0.90699,
    0.91677,
    0.90699,
    0.91677,
    0.90699,
    0.91677,
    0.90699,
    0.91677,
    0.9154,
    0.94236,
    0.85458,
    0.89364,
    0.85458,
    0.90531,
    0.9,
    0.90531,
    0.9,
    0.90531,
    0.9,
    1,
    0.97276,
    0.85576,
    0.99613,
    0.845,
    0.85811,
    0.90251,
    0.91677,
    1,
    1,
    0.86275,
    1.04502,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.18616,
    1.00899,
    1.30628,
    0.85576,
    0.80178,
    0.66862,
    0.7927,
    0.69323,
    0.88127,
    0.72459,
    0.89711,
    0.95381,
    0.85576,
    0.80591,
    0.7805,
    0.94729,
    0.77512,
    0.90531,
    0.92222,
    0.90637,
    0.98621,
    0.81698,
    0.92655,
    0.98558,
    0.92222,
    0.85359,
    0.90637,
    0.90976,
    0.83809,
    0.94523,
    0.86275,
    0.83509,
    0.93157,
    0.85308,
    0.83392,
    0.92346,
    0.98621,
    0.83509,
    0.92886,
    0.91324,
    0.92168,
    0.95381,
    0.90646,
    0.92886,
    0.90557,
    0.86847,
    0.90276,
    0.91324,
    0.86842,
    0.92168,
    0.99531,
    0.95381,
    0.9224,
    0.85408,
    0.92699,
    0.86847,
    1.0051,
    0.91513,
    0.80487,
    0.93481,
    1,
    0.88159,
    1.05214,
    0.90646,
    0.97355,
    0.81539,
    0.89398,
    0.85923,
    0.95381,
    0.90646,
    0.91513,
    0.90646,
    0.85923,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.9154,
    0.94236,
    0.9154,
    0.94236,
    0.9154,
    0.94236,
    0.85458,
    0.89364,
    0.96694,
    1,
    0.89903,
    1,
    1,
    1,
    0.91782,
    0.91782,
    0.91782,
    1,
    0.896,
    0.896,
    0.896,
    0.9332,
    0.9332,
    0.95973,
    1,
    1.26,
    1,
    1,
    0.80479,
    0.80178,
    1,
    1,
    0.85633,
    1,
    1,
    1,
    1,
    0.97276,
    1,
    1,
    1,
    0.698,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.14542,
    1,
    0.79199,
    0.78694,
    1.02058,
    1.03493,
    1.05486,
    1,
    1,
    1.23026,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.20006,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], tr = {
    lineHeight: 1.2,
    lineGap: 0.2
  }, ir = [
    1.36898,
    1,
    1,
    0.65507,
    0.84943,
    0.85639,
    0.88465,
    0.88465,
    0.86936,
    0.88307,
    0.86948,
    0.85283,
    0.85283,
    1.06383,
    1.02058,
    0.75945,
    0.9219,
    0.75945,
    1.17337,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.75945,
    0.75945,
    1.02058,
    1.02058,
    1.02058,
    0.69046,
    0.70926,
    0.85158,
    0.77812,
    0.76852,
    0.89591,
    0.70466,
    0.76125,
    0.80094,
    0.86822,
    0.83864,
    0.728,
    0.77212,
    0.79475,
    0.93637,
    0.87514,
    0.8588,
    0.76013,
    0.8588,
    0.72421,
    0.69866,
    0.77598,
    0.85991,
    0.80811,
    0.87832,
    0.78112,
    0.77512,
    0.8562,
    1.0222,
    1.18417,
    1.0222,
    1.27014,
    0.89903,
    1.15012,
    0.93859,
    0.94399,
    0.846,
    0.94399,
    0.81453,
    1.0186,
    0.94219,
    0.96017,
    1.03075,
    1.02175,
    0.912,
    1.03075,
    0.96998,
    0.96017,
    0.93859,
    0.94399,
    0.94399,
    0.95493,
    0.746,
    1.12658,
    0.94578,
    0.91,
    0.979,
    0.882,
    0.882,
    0.83,
    0.85034,
    0.83537,
    0.85034,
    1.02058,
    0.70869,
    0.88465,
    0.88465,
    0.88465,
    0.88465,
    0.83537,
    0.90083,
    1.15012,
    0.9161,
    0.94565,
    0.73541,
    1.02058,
    0.53609,
    0.69353,
    0.79519,
    1.08595,
    1,
    1,
    1.15012,
    1,
    0.91974,
    0.75945,
    1.15012,
    1,
    0.9446,
    0.73361,
    0.9005,
    0.9005,
    0.9005,
    0.62864,
    0.85158,
    0.85158,
    0.85158,
    0.85158,
    0.85158,
    0.85158,
    0.773,
    0.76852,
    0.70466,
    0.70466,
    0.70466,
    0.70466,
    0.83864,
    0.83864,
    0.83864,
    0.83864,
    0.90561,
    0.87514,
    0.8588,
    0.8588,
    0.8588,
    0.8588,
    0.8588,
    1.02058,
    0.85751,
    0.85991,
    0.85991,
    0.85991,
    0.85991,
    0.77512,
    0.76013,
    0.88075,
    0.93859,
    0.93859,
    0.93859,
    0.93859,
    0.93859,
    0.93859,
    0.8075,
    0.846,
    0.81453,
    0.81453,
    0.81453,
    0.81453,
    0.82424,
    0.82424,
    0.82424,
    0.82424,
    0.9278,
    0.96017,
    0.93859,
    0.93859,
    0.93859,
    0.93859,
    0.93859,
    1.08595,
    0.8562,
    0.94578,
    0.94578,
    0.94578,
    0.94578,
    0.882,
    0.94578,
    0.882,
    0.85158,
    0.93859,
    0.85158,
    0.93859,
    0.85158,
    0.93859,
    0.76852,
    0.846,
    0.76852,
    0.846,
    0.76852,
    0.846,
    0.76852,
    0.846,
    0.89591,
    0.8544,
    0.90561,
    0.94399,
    0.70466,
    0.81453,
    0.70466,
    0.81453,
    0.70466,
    0.81453,
    0.70466,
    0.81453,
    0.70466,
    0.81453,
    0.80094,
    0.94219,
    0.80094,
    0.94219,
    0.80094,
    0.94219,
    1,
    1,
    0.86822,
    0.96017,
    0.86822,
    0.96017,
    0.83864,
    0.82424,
    0.83864,
    0.82424,
    0.83864,
    0.82424,
    0.83864,
    1.03075,
    0.83864,
    0.82424,
    0.81402,
    1.02738,
    0.728,
    1.02175,
    1,
    1,
    0.912,
    0.79475,
    1.03075,
    1,
    1,
    0.79475,
    0.83911,
    0.79475,
    0.66266,
    0.80553,
    1.06676,
    0.87514,
    0.96017,
    1,
    1,
    0.87514,
    0.96017,
    0.86865,
    0.87396,
    0.96017,
    0.8588,
    0.93859,
    0.8588,
    0.93859,
    0.8588,
    0.93859,
    0.867,
    0.84759,
    0.72421,
    0.95493,
    1,
    1,
    0.72421,
    0.95493,
    0.69866,
    0.746,
    0.69866,
    0.746,
    1,
    1,
    0.69866,
    0.746,
    1,
    1,
    0.77598,
    0.88417,
    0.77598,
    1.12658,
    0.85991,
    0.94578,
    0.85991,
    0.94578,
    0.85991,
    0.94578,
    0.85991,
    0.94578,
    0.85991,
    0.94578,
    0.85991,
    0.94578,
    0.87832,
    0.979,
    0.77512,
    0.882,
    0.77512,
    0.8562,
    0.83,
    0.8562,
    0.83,
    0.8562,
    0.83,
    1,
    0.88465,
    0.85158,
    0.93859,
    0.773,
    0.8075,
    0.85751,
    0.8562,
    1,
    1,
    0.77598,
    1.12658,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15012,
    1.15313,
    1.15012,
    1.15012,
    1.15012,
    1.08106,
    1.03901,
    0.85158,
    0.77025,
    0.62264,
    0.7646,
    0.65351,
    0.86026,
    0.69461,
    0.89947,
    1.03075,
    0.85158,
    0.77812,
    0.76449,
    0.88836,
    0.70466,
    0.8562,
    0.86822,
    0.8588,
    0.83864,
    0.77212,
    0.85308,
    0.93637,
    0.87514,
    0.82352,
    0.8588,
    0.85701,
    0.76013,
    0.89058,
    0.77598,
    0.8156,
    0.82565,
    0.78112,
    0.77899,
    0.89386,
    0.83864,
    0.8156,
    0.9486,
    0.92388,
    0.96186,
    1.03075,
    0.91123,
    0.9486,
    0.93298,
    0.878,
    0.93942,
    0.92388,
    0.84596,
    0.96186,
    0.95119,
    1.03075,
    0.922,
    0.88787,
    0.95829,
    0.88,
    0.93559,
    0.93859,
    0.78815,
    0.93758,
    1,
    0.89217,
    1.03737,
    0.91123,
    0.93969,
    0.77487,
    0.85769,
    0.86799,
    1.03075,
    0.91123,
    0.93859,
    0.91123,
    0.86799,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.87832,
    0.979,
    0.87832,
    0.979,
    0.87832,
    0.979,
    0.77512,
    0.882,
    0.9219,
    1,
    0.89903,
    1,
    1,
    1,
    0.87321,
    0.87321,
    0.87321,
    1,
    1.027,
    1.027,
    1.027,
    0.86847,
    0.86847,
    0.79121,
    1,
    1.124,
    1,
    1,
    0.73572,
    0.73572,
    1,
    1,
    0.85034,
    1,
    1,
    1,
    1,
    0.88465,
    1,
    1,
    1,
    0.669,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04828,
    1,
    0.74948,
    0.75187,
    1.02058,
    0.98391,
    1.02119,
    1,
    1,
    1.06233,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05233,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], ar = {
    lineHeight: 1.2,
    lineGap: 0.2
  }, rr = [
    1.36898,
    1,
    1,
    0.76305,
    0.82784,
    0.94935,
    0.89364,
    0.92241,
    0.89073,
    0.90706,
    0.98472,
    0.85283,
    0.85283,
    1.0664,
    1.02058,
    0.74505,
    0.9219,
    0.74505,
    1.23456,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.74505,
    0.74505,
    1.02058,
    1.02058,
    1.02058,
    0.73002,
    0.72601,
    0.91755,
    0.8126,
    0.80314,
    0.92222,
    0.73764,
    0.79726,
    0.83051,
    0.90284,
    0.86023,
    0.74,
    0.8126,
    0.84869,
    0.96518,
    0.91115,
    0.8858,
    0.79761,
    0.8858,
    0.74498,
    0.73914,
    0.81363,
    0.89591,
    0.83659,
    0.89633,
    0.85608,
    0.8111,
    0.90531,
    1.0222,
    1.22736,
    1.0222,
    1.27014,
    0.89903,
    0.90088,
    0.86667,
    1.0231,
    0.896,
    1.01411,
    0.90083,
    1.05099,
    1.00512,
    0.99793,
    1.05326,
    1.09377,
    0.938,
    1.06226,
    1.00119,
    0.99793,
    0.98714,
    1.0231,
    1.01231,
    0.98196,
    0.792,
    1.19137,
    0.99074,
    0.962,
    1.01915,
    0.926,
    0.942,
    0.856,
    0.85034,
    0.92006,
    0.85034,
    1.02058,
    0.69067,
    0.92241,
    0.92241,
    0.92241,
    0.92241,
    0.92006,
    0.9332,
    0.90088,
    0.91882,
    0.93484,
    0.75339,
    1.02058,
    0.56866,
    0.54324,
    0.79519,
    1.08595,
    1,
    1,
    0.90088,
    1,
    0.95325,
    0.74505,
    0.90088,
    1,
    0.97198,
    0.75339,
    0.91009,
    0.91009,
    0.91009,
    0.66466,
    0.91755,
    0.91755,
    0.91755,
    0.91755,
    0.91755,
    0.91755,
    0.788,
    0.80314,
    0.73764,
    0.73764,
    0.73764,
    0.73764,
    0.86023,
    0.86023,
    0.86023,
    0.86023,
    0.92915,
    0.91115,
    0.8858,
    0.8858,
    0.8858,
    0.8858,
    0.8858,
    1.02058,
    0.8858,
    0.89591,
    0.89591,
    0.89591,
    0.89591,
    0.8111,
    0.79611,
    0.89713,
    0.86667,
    0.86667,
    0.86667,
    0.86667,
    0.86667,
    0.86667,
    0.86936,
    0.896,
    0.90083,
    0.90083,
    0.90083,
    0.90083,
    0.84224,
    0.84224,
    0.84224,
    0.84224,
    0.97276,
    0.99793,
    0.98714,
    0.98714,
    0.98714,
    0.98714,
    0.98714,
    1.08595,
    0.89876,
    0.99074,
    0.99074,
    0.99074,
    0.99074,
    0.942,
    1.0231,
    0.942,
    0.91755,
    0.86667,
    0.91755,
    0.86667,
    0.91755,
    0.86667,
    0.80314,
    0.896,
    0.80314,
    0.896,
    0.80314,
    0.896,
    0.80314,
    0.896,
    0.92222,
    0.93372,
    0.92915,
    1.01411,
    0.73764,
    0.90083,
    0.73764,
    0.90083,
    0.73764,
    0.90083,
    0.73764,
    0.90083,
    0.73764,
    0.90083,
    0.83051,
    1.00512,
    0.83051,
    1.00512,
    0.83051,
    1.00512,
    1,
    1,
    0.90284,
    0.99793,
    0.90976,
    0.99793,
    0.86023,
    0.84224,
    0.86023,
    0.84224,
    0.86023,
    0.84224,
    0.86023,
    1.05326,
    0.86023,
    0.84224,
    0.82873,
    1.07469,
    0.74,
    1.09377,
    1,
    1,
    0.938,
    0.84869,
    1.06226,
    1,
    1,
    0.84869,
    0.83704,
    0.84869,
    0.81441,
    0.85588,
    1.08927,
    0.91115,
    0.99793,
    1,
    1,
    0.91115,
    0.99793,
    0.91887,
    0.90991,
    0.99793,
    0.8858,
    0.98714,
    0.8858,
    0.98714,
    0.8858,
    0.98714,
    0.894,
    0.91434,
    0.74498,
    0.98196,
    1,
    1,
    0.74498,
    0.98196,
    0.73914,
    0.792,
    0.73914,
    0.792,
    1,
    1,
    0.73914,
    0.792,
    1,
    1,
    0.81363,
    0.904,
    0.81363,
    1.19137,
    0.89591,
    0.99074,
    0.89591,
    0.99074,
    0.89591,
    0.99074,
    0.89591,
    0.99074,
    0.89591,
    0.99074,
    0.89591,
    0.99074,
    0.89633,
    1.01915,
    0.8111,
    0.942,
    0.8111,
    0.90531,
    0.856,
    0.90531,
    0.856,
    0.90531,
    0.856,
    1,
    0.92241,
    0.91755,
    0.86667,
    0.788,
    0.86936,
    0.8858,
    0.89876,
    1,
    1,
    0.81363,
    1.19137,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90088,
    0.90388,
    1.03901,
    0.92138,
    0.78105,
    0.7154,
    0.86169,
    0.80513,
    0.94007,
    0.82528,
    0.98612,
    1.06226,
    0.91755,
    0.8126,
    0.81884,
    0.92819,
    0.73764,
    0.90531,
    0.90284,
    0.8858,
    0.86023,
    0.8126,
    0.91172,
    0.96518,
    0.91115,
    0.83089,
    0.8858,
    0.87791,
    0.79761,
    0.89297,
    0.81363,
    0.88157,
    0.89992,
    0.85608,
    0.81992,
    0.94307,
    0.86023,
    0.88157,
    0.95308,
    0.98699,
    0.99793,
    1.06226,
    0.95817,
    0.95308,
    0.97358,
    0.928,
    0.98088,
    0.98699,
    0.92761,
    0.99793,
    0.96017,
    1.06226,
    0.986,
    0.944,
    0.95978,
    0.938,
    0.96705,
    0.98714,
    0.80442,
    0.98972,
    1,
    0.89762,
    1.04552,
    0.95817,
    0.99007,
    0.87064,
    0.91879,
    0.88888,
    1.06226,
    0.95817,
    0.98714,
    0.95817,
    0.88888,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.89633,
    1.01915,
    0.89633,
    1.01915,
    0.89633,
    1.01915,
    0.8111,
    0.942,
    0.9219,
    1,
    0.89903,
    1,
    1,
    1,
    0.93173,
    0.93173,
    0.93173,
    1,
    1.06304,
    1.06304,
    1.06904,
    0.89903,
    0.89903,
    0.80549,
    1,
    1.156,
    1,
    1,
    0.76575,
    0.76575,
    1,
    1,
    0.72458,
    1,
    1,
    1,
    1,
    0.92241,
    1,
    1,
    1,
    0.619,
    1,
    1.36145,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.07257,
    1,
    0.74705,
    0.71119,
    1.02058,
    1.024,
    1.02119,
    1,
    1,
    1.1536,
    1.08595,
    1.08595,
    1,
    1.08595,
    1.08595,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.05638,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], sr = {
    lineHeight: 1.2,
    lineGap: 0.2
  }, nr = [
    1.76738,
    1,
    1,
    0.99297,
    0.9824,
    1.04016,
    1.06497,
    1.03424,
    0.97529,
    1.17647,
    1.23203,
    1.1085,
    1.1085,
    1.16939,
    1.2107,
    0.9754,
    1.21408,
    0.9754,
    1.59578,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    1.03424,
    0.81378,
    0.81378,
    1.2107,
    1.2107,
    1.2107,
    0.71703,
    0.97847,
    0.97363,
    0.88776,
    0.8641,
    1.02096,
    0.79795,
    0.85132,
    0.914,
    1.06085,
    1.1406,
    0.8007,
    0.89858,
    0.83693,
    1.14889,
    1.09398,
    0.97489,
    0.92094,
    0.97489,
    0.90399,
    0.84041,
    0.95923,
    1.00135,
    1,
    1.06467,
    0.98243,
    0.90996,
    0.99361,
    1.1085,
    1.56942,
    1.1085,
    1.2107,
    0.74627,
    0.94282,
    0.96752,
    1.01519,
    0.86304,
    1.01359,
    0.97278,
    1.15103,
    1.01359,
    0.98561,
    1.02285,
    1.02285,
    1.00527,
    1.02285,
    1.0302,
    0.99041,
    1.0008,
    1.01519,
    1.01359,
    1.02258,
    0.79104,
    1.16862,
    0.99041,
    0.97454,
    1.02511,
    0.99298,
    0.96752,
    0.95801,
    0.94856,
    1.16579,
    0.94856,
    1.2107,
    0.9824,
    1.03424,
    1.03424,
    1,
    1.03424,
    1.16579,
    0.8727,
    1.3871,
    1.18622,
    1.10818,
    1.04478,
    1.2107,
    1.18622,
    0.75155,
    0.94994,
    1.28826,
    1.21408,
    1.21408,
    0.91056,
    1,
    0.91572,
    0.9754,
    0.64663,
    1.18328,
    1.24866,
    1.04478,
    1.14169,
    1.15749,
    1.17389,
    0.71703,
    0.97363,
    0.97363,
    0.97363,
    0.97363,
    0.97363,
    0.97363,
    0.93506,
    0.8641,
    0.79795,
    0.79795,
    0.79795,
    0.79795,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.02096,
    1.09398,
    0.97426,
    0.97426,
    0.97426,
    0.97426,
    0.97426,
    1.2107,
    0.97489,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    0.90996,
    0.92094,
    1.02798,
    0.96752,
    0.96752,
    0.96752,
    0.96752,
    0.96752,
    0.96752,
    0.93136,
    0.86304,
    0.97278,
    0.97278,
    0.97278,
    0.97278,
    1.02285,
    1.02285,
    1.02285,
    1.02285,
    0.97122,
    0.99041,
    1,
    1,
    1,
    1,
    1,
    1.28826,
    1.0008,
    0.99041,
    0.99041,
    0.99041,
    0.99041,
    0.96752,
    1.01519,
    0.96752,
    0.97363,
    0.96752,
    0.97363,
    0.96752,
    0.97363,
    0.96752,
    0.8641,
    0.86304,
    0.8641,
    0.86304,
    0.8641,
    0.86304,
    0.8641,
    0.86304,
    1.02096,
    1.03057,
    1.02096,
    1.03517,
    0.79795,
    0.97278,
    0.79795,
    0.97278,
    0.79795,
    0.97278,
    0.79795,
    0.97278,
    0.79795,
    0.97278,
    0.914,
    1.01359,
    0.914,
    1.01359,
    0.914,
    1.01359,
    1,
    1,
    1.06085,
    0.98561,
    1.06085,
    1.00879,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    1.1406,
    1.02285,
    0.97138,
    1.08692,
    0.8007,
    1.02285,
    1,
    1,
    1.00527,
    0.83693,
    1.02285,
    1,
    1,
    0.83693,
    0.9455,
    0.83693,
    0.90418,
    0.83693,
    1.13005,
    1.09398,
    0.99041,
    1,
    1,
    1.09398,
    0.99041,
    0.96692,
    1.09251,
    0.99041,
    0.97489,
    1.0008,
    0.97489,
    1.0008,
    0.97489,
    1.0008,
    0.93994,
    0.97931,
    0.90399,
    1.02258,
    1,
    1,
    0.90399,
    1.02258,
    0.84041,
    0.79104,
    0.84041,
    0.79104,
    0.84041,
    0.79104,
    0.84041,
    0.79104,
    1,
    1,
    0.95923,
    1.07034,
    0.95923,
    1.16862,
    1.00135,
    0.99041,
    1.00135,
    0.99041,
    1.00135,
    0.99041,
    1.00135,
    0.99041,
    1.00135,
    0.99041,
    1.00135,
    0.99041,
    1.06467,
    1.02511,
    0.90996,
    0.96752,
    0.90996,
    0.99361,
    0.95801,
    0.99361,
    0.95801,
    0.99361,
    0.95801,
    1.07733,
    1.03424,
    0.97363,
    0.96752,
    0.93506,
    0.93136,
    0.97489,
    1.0008,
    1,
    1,
    0.95923,
    1.16862,
    1.15103,
    1.15103,
    1.01173,
    1.03959,
    0.75953,
    0.81378,
    0.79912,
    1.15103,
    1.21994,
    0.95161,
    0.87815,
    1.01149,
    0.81525,
    0.7676,
    0.98167,
    1.01134,
    1.02546,
    0.84097,
    1.03089,
    1.18102,
    0.97363,
    0.88776,
    0.85134,
    0.97826,
    0.79795,
    0.99361,
    1.06085,
    0.97489,
    1.1406,
    0.89858,
    1.0388,
    1.14889,
    1.09398,
    0.86039,
    0.97489,
    1.0595,
    0.92094,
    0.94793,
    0.95923,
    0.90996,
    0.99346,
    0.98243,
    1.02112,
    0.95493,
    1.1406,
    0.90996,
    1.03574,
    1.02597,
    1.0008,
    1.18102,
    1.06628,
    1.03574,
    1.0192,
    1.01932,
    1.00886,
    0.97531,
    1.0106,
    1.0008,
    1.13189,
    1.18102,
    1.02277,
    0.98683,
    1.0016,
    0.99561,
    1.07237,
    1.0008,
    0.90434,
    0.99921,
    0.93803,
    0.8965,
    1.23085,
    1.06628,
    1.04983,
    0.96268,
    1.0499,
    0.98439,
    1.18102,
    1.06628,
    1.0008,
    1.06628,
    0.98439,
    0.79795,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09466,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.97278,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.02065,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    1.06467,
    1.02511,
    0.90996,
    0.96752,
    1,
    1.21408,
    0.89903,
    1,
    1,
    0.75155,
    1.04394,
    1.04394,
    1.04394,
    1.04394,
    0.98633,
    0.98633,
    0.98633,
    0.73047,
    0.73047,
    1.20642,
    0.91211,
    1.25635,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    0.96039,
    1.24633,
    1,
    1.12454,
    0.93503,
    1.03424,
    1.19687,
    1.03424,
    1,
    1,
    1,
    0.771,
    1,
    1,
    1.15749,
    1.15749,
    1.15749,
    1.10948,
    0.86279,
    0.94434,
    0.86279,
    0.94434,
    0.86182,
    1,
    1,
    1.16897,
    1,
    0.96085,
    0.90137,
    1.2107,
    1.18416,
    1.13973,
    0.69825,
    0.9716,
    2.10339,
    1.29004,
    1.29004,
    1.21172,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    0.99862,
    0.99862,
    1,
    0.87025,
    0.87025,
    0.87025,
    0.87025,
    1.18874,
    1.42603,
    1,
    1.42603,
    1.42603,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.09193,
    1.09193,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], or = {
    lineHeight: 1.33008,
    lineGap: 0
  }, gr = [
    1.76738,
    1,
    1,
    0.98946,
    1.03959,
    1.04016,
    1.02809,
    1.036,
    0.97639,
    1.10953,
    1.23203,
    1.11144,
    1.11144,
    1.16939,
    1.21237,
    0.9754,
    1.21261,
    0.9754,
    1.59754,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    1.036,
    0.81378,
    0.81378,
    1.21237,
    1.21237,
    1.21237,
    0.73541,
    0.97847,
    0.97363,
    0.89723,
    0.87897,
    1.0426,
    0.79429,
    0.85292,
    0.91149,
    1.05815,
    1.1406,
    0.79631,
    0.90128,
    0.83853,
    1.04396,
    1.10615,
    0.97552,
    0.94436,
    0.97552,
    0.88641,
    0.80527,
    0.96083,
    1.00135,
    1,
    1.06777,
    0.9817,
    0.91142,
    0.99361,
    1.11144,
    1.57293,
    1.11144,
    1.21237,
    0.74627,
    1.31818,
    1.06585,
    0.97042,
    0.83055,
    0.97042,
    0.93503,
    1.1261,
    0.97042,
    0.97922,
    1.14236,
    0.94552,
    1.01054,
    1.14236,
    1.02471,
    0.97922,
    0.94165,
    0.97042,
    0.97042,
    1.0276,
    0.78929,
    1.1261,
    0.97922,
    0.95874,
    1.02197,
    0.98507,
    0.96752,
    0.97168,
    0.95107,
    1.16579,
    0.95107,
    1.21237,
    1.03959,
    1.036,
    1.036,
    1,
    1.036,
    1.16579,
    0.87357,
    1.31818,
    1.18754,
    1.26781,
    1.05356,
    1.21237,
    1.18622,
    0.79487,
    0.94994,
    1.29004,
    1.24047,
    1.24047,
    1.31818,
    1,
    0.91484,
    0.9754,
    1.31818,
    1.1349,
    1.24866,
    1.05356,
    1.13934,
    1.15574,
    1.17389,
    0.73541,
    0.97363,
    0.97363,
    0.97363,
    0.97363,
    0.97363,
    0.97363,
    0.94385,
    0.87897,
    0.79429,
    0.79429,
    0.79429,
    0.79429,
    1.1406,
    1.1406,
    1.1406,
    1.1406,
    1.0426,
    1.10615,
    0.97552,
    0.97552,
    0.97552,
    0.97552,
    0.97552,
    1.21237,
    0.97552,
    1.00135,
    1.00135,
    1.00135,
    1.00135,
    0.91142,
    0.94436,
    0.98721,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    1.06585,
    0.96705,
    0.83055,
    0.93503,
    0.93503,
    0.93503,
    0.93503,
    1.14236,
    1.14236,
    1.14236,
    1.14236,
    0.93125,
    0.97922,
    0.94165,
    0.94165,
    0.94165,
    0.94165,
    0.94165,
    1.29004,
    0.94165,
    0.97922,
    0.97922,
    0.97922,
    0.97922,
    0.96752,
    0.97042,
    0.96752,
    0.97363,
    1.06585,
    0.97363,
    1.06585,
    0.97363,
    1.06585,
    0.87897,
    0.83055,
    0.87897,
    0.83055,
    0.87897,
    0.83055,
    0.87897,
    0.83055,
    1.0426,
    1.0033,
    1.0426,
    0.97042,
    0.79429,
    0.93503,
    0.79429,
    0.93503,
    0.79429,
    0.93503,
    0.79429,
    0.93503,
    0.79429,
    0.93503,
    0.91149,
    0.97042,
    0.91149,
    0.97042,
    0.91149,
    0.97042,
    1,
    1,
    1.05815,
    0.97922,
    1.05815,
    0.97922,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    1.1406,
    1.14236,
    0.97441,
    1.04302,
    0.79631,
    1.01582,
    1,
    1,
    1.01054,
    0.83853,
    1.14236,
    1,
    1,
    0.83853,
    1.09125,
    0.83853,
    0.90418,
    0.83853,
    1.19508,
    1.10615,
    0.97922,
    1,
    1,
    1.10615,
    0.97922,
    1.01034,
    1.10466,
    0.97922,
    0.97552,
    0.94165,
    0.97552,
    0.94165,
    0.97552,
    0.94165,
    0.91602,
    0.91981,
    0.88641,
    1.0276,
    1,
    1,
    0.88641,
    1.0276,
    0.80527,
    0.78929,
    0.80527,
    0.78929,
    0.80527,
    0.78929,
    0.80527,
    0.78929,
    1,
    1,
    0.96083,
    1.05403,
    0.95923,
    1.16862,
    1.00135,
    0.97922,
    1.00135,
    0.97922,
    1.00135,
    0.97922,
    1.00135,
    0.97922,
    1.00135,
    0.97922,
    1.00135,
    0.97922,
    1.06777,
    1.02197,
    0.91142,
    0.96752,
    0.91142,
    0.99361,
    0.97168,
    0.99361,
    0.97168,
    0.99361,
    0.97168,
    1.23199,
    1.036,
    0.97363,
    1.06585,
    0.94385,
    0.96705,
    0.97552,
    0.94165,
    1,
    1,
    0.96083,
    1.1261,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    1.31818,
    0.95161,
    1.27126,
    1.00811,
    0.83284,
    0.77702,
    0.99137,
    0.95253,
    1.0347,
    0.86142,
    1.07205,
    1.14236,
    0.97363,
    0.89723,
    0.86869,
    1.09818,
    0.79429,
    0.99361,
    1.05815,
    0.97552,
    1.1406,
    0.90128,
    1.06662,
    1.04396,
    1.10615,
    0.84918,
    0.97552,
    1.04694,
    0.94436,
    0.98015,
    0.96083,
    0.91142,
    1.00356,
    0.9817,
    1.01945,
    0.98999,
    1.1406,
    0.91142,
    1.04961,
    0.9898,
    1.00639,
    1.14236,
    1.07514,
    1.04961,
    0.99607,
    1.02897,
    1.008,
    0.9898,
    0.95134,
    1.00639,
    1.11121,
    1.14236,
    1.00518,
    0.97981,
    1.02186,
    1,
    1.08578,
    0.94165,
    0.99314,
    0.98387,
    0.93028,
    0.93377,
    1.35125,
    1.07514,
    1.10687,
    0.93491,
    1.04232,
    1.00351,
    1.14236,
    1.07514,
    0.94165,
    1.07514,
    1.00351,
    0.79429,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.09097,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.93503,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.96609,
    1,
    1,
    1,
    1,
    1,
    1,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    1.06777,
    1.02197,
    0.91142,
    0.96752,
    1,
    1.21261,
    0.89903,
    1,
    1,
    0.75155,
    1.04745,
    1.04745,
    1.04745,
    1.04394,
    0.98633,
    0.98633,
    0.98633,
    0.72959,
    0.72959,
    1.20502,
    0.91406,
    1.26514,
    1.222,
    1.02956,
    1.03372,
    1.03372,
    0.96039,
    1.24633,
    1,
    1.09125,
    0.93327,
    1.03336,
    1.16541,
    1.036,
    1,
    1,
    1,
    0.771,
    1,
    1,
    1.15574,
    1.15574,
    1.15574,
    1.15574,
    0.86364,
    0.94434,
    0.86279,
    0.94434,
    0.86224,
    1,
    1,
    1.16798,
    1,
    0.96085,
    0.90068,
    1.21237,
    1.18416,
    1.13904,
    0.69825,
    0.9716,
    2.10339,
    1.29004,
    1.29004,
    1.21339,
    1.29004,
    1.29004,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    0.99862,
    0.99862,
    1,
    0.87025,
    0.87025,
    0.87025,
    0.87025,
    1.18775,
    1.42603,
    1,
    1.42603,
    1.42603,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.13269,
    1.13269,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Ir = {
    lineHeight: 1.33008,
    lineGap: 0
  }, cr = [
    1.76738,
    1,
    1,
    0.98946,
    1.14763,
    1.05365,
    1.06234,
    0.96927,
    0.92586,
    1.15373,
    1.18414,
    0.91349,
    0.91349,
    1.07403,
    1.17308,
    0.78383,
    1.20088,
    0.78383,
    1.42531,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.78383,
    0.78383,
    1.17308,
    1.17308,
    1.17308,
    0.77349,
    0.94565,
    0.94729,
    0.85944,
    0.88506,
    0.9858,
    0.74817,
    0.80016,
    0.88449,
    0.98039,
    0.95782,
    0.69238,
    0.89898,
    0.83231,
    0.98183,
    1.03989,
    0.96924,
    0.86237,
    0.96924,
    0.80595,
    0.74524,
    0.86091,
    0.95402,
    0.94143,
    0.98448,
    0.8858,
    0.83089,
    0.93285,
    1.0949,
    1.39016,
    1.0949,
    1.45994,
    0.74627,
    1.04839,
    0.97454,
    0.97454,
    0.87207,
    0.97454,
    0.87533,
    1.06151,
    0.97454,
    1.00176,
    1.16484,
    1.08132,
    0.98047,
    1.16484,
    1.02989,
    1.01054,
    0.96225,
    0.97454,
    0.97454,
    1.06598,
    0.79004,
    1.16344,
    1.00351,
    0.94629,
    0.9973,
    0.91016,
    0.96777,
    0.9043,
    0.91082,
    0.92481,
    0.91082,
    1.17308,
    0.95748,
    0.96927,
    0.96927,
    1,
    0.96927,
    0.92481,
    0.80597,
    1.04839,
    1.23393,
    1.1781,
    0.9245,
    1.17308,
    1.20808,
    0.63218,
    0.94261,
    1.24822,
    1.09971,
    1.09971,
    1.04839,
    1,
    0.85273,
    0.78032,
    1.04839,
    1.09971,
    1.22326,
    0.9245,
    1.09836,
    1.13525,
    1.15222,
    0.70424,
    0.94729,
    0.94729,
    0.94729,
    0.94729,
    0.94729,
    0.94729,
    0.85498,
    0.88506,
    0.74817,
    0.74817,
    0.74817,
    0.74817,
    0.95782,
    0.95782,
    0.95782,
    0.95782,
    0.9858,
    1.03989,
    0.96924,
    0.96924,
    0.96924,
    0.96924,
    0.96924,
    1.17308,
    0.96924,
    0.95402,
    0.95402,
    0.95402,
    0.95402,
    0.83089,
    0.86237,
    0.88409,
    0.97454,
    0.97454,
    0.97454,
    0.97454,
    0.97454,
    0.97454,
    0.92916,
    0.87207,
    0.87533,
    0.87533,
    0.87533,
    0.87533,
    0.93146,
    0.93146,
    0.93146,
    0.93146,
    0.93854,
    1.01054,
    0.96225,
    0.96225,
    0.96225,
    0.96225,
    0.96225,
    1.24822,
    0.8761,
    1.00351,
    1.00351,
    1.00351,
    1.00351,
    0.96777,
    0.97454,
    0.96777,
    0.94729,
    0.97454,
    0.94729,
    0.97454,
    0.94729,
    0.97454,
    0.88506,
    0.87207,
    0.88506,
    0.87207,
    0.88506,
    0.87207,
    0.88506,
    0.87207,
    0.9858,
    0.95391,
    0.9858,
    0.97454,
    0.74817,
    0.87533,
    0.74817,
    0.87533,
    0.74817,
    0.87533,
    0.74817,
    0.87533,
    0.74817,
    0.87533,
    0.88449,
    0.97454,
    0.88449,
    0.97454,
    0.88449,
    0.97454,
    1,
    1,
    0.98039,
    1.00176,
    0.98039,
    1.00176,
    0.95782,
    0.93146,
    0.95782,
    0.93146,
    0.95782,
    0.93146,
    0.95782,
    1.16484,
    0.95782,
    0.93146,
    0.84421,
    1.12761,
    0.69238,
    1.08132,
    1,
    1,
    0.98047,
    0.83231,
    1.16484,
    1,
    1,
    0.84723,
    1.04861,
    0.84723,
    0.78755,
    0.83231,
    1.23736,
    1.03989,
    1.01054,
    1,
    1,
    1.03989,
    1.01054,
    0.9857,
    1.03849,
    1.01054,
    0.96924,
    0.96225,
    0.96924,
    0.96225,
    0.96924,
    0.96225,
    0.92383,
    0.90171,
    0.80595,
    1.06598,
    1,
    1,
    0.80595,
    1.06598,
    0.74524,
    0.79004,
    0.74524,
    0.79004,
    0.74524,
    0.79004,
    0.74524,
    0.79004,
    1,
    1,
    0.86091,
    1.02759,
    0.85771,
    1.16344,
    0.95402,
    1.00351,
    0.95402,
    1.00351,
    0.95402,
    1.00351,
    0.95402,
    1.00351,
    0.95402,
    1.00351,
    0.95402,
    1.00351,
    0.98448,
    0.9973,
    0.83089,
    0.96777,
    0.83089,
    0.93285,
    0.9043,
    0.93285,
    0.9043,
    0.93285,
    0.9043,
    1.31868,
    0.96927,
    0.94729,
    0.97454,
    0.85498,
    0.92916,
    0.96924,
    0.8761,
    1,
    1,
    0.86091,
    1.16344,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    1.04839,
    0.81965,
    0.81965,
    0.94729,
    0.78032,
    0.71022,
    0.90883,
    0.84171,
    0.99877,
    0.77596,
    1.05734,
    1.2,
    0.94729,
    0.85944,
    0.82791,
    0.9607,
    0.74817,
    0.93285,
    0.98039,
    0.96924,
    0.95782,
    0.89898,
    0.98316,
    0.98183,
    1.03989,
    0.78614,
    0.96924,
    0.97642,
    0.86237,
    0.86075,
    0.86091,
    0.83089,
    0.90082,
    0.8858,
    0.97296,
    1.01284,
    0.95782,
    0.83089,
    1.0976,
    1.04,
    1.03342,
    1.2,
    1.0675,
    1.0976,
    0.98205,
    1.03809,
    1.05097,
    1.04,
    0.95364,
    1.03342,
    1.05401,
    1.2,
    1.02148,
    1.0119,
    1.04724,
    1.0127,
    1.02732,
    0.96225,
    0.8965,
    0.97783,
    0.93574,
    0.94818,
    1.30679,
    1.0675,
    1.11826,
    0.99821,
    1.0557,
    1.0326,
    1.2,
    1.0675,
    0.96225,
    1.0675,
    1.0326,
    0.74817,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03754,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.87533,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.98705,
    1,
    1,
    1,
    1,
    1,
    1,
    0.98448,
    0.9973,
    0.98448,
    0.9973,
    0.98448,
    0.9973,
    0.83089,
    0.96777,
    1,
    1.20088,
    0.89903,
    1,
    1,
    0.75155,
    0.94945,
    0.94945,
    0.94945,
    0.94945,
    1.12317,
    1.12317,
    1.12317,
    0.67603,
    0.67603,
    1.15621,
    0.73584,
    1.21191,
    1.22135,
    1.06483,
    0.94868,
    0.94868,
    0.95996,
    1.24633,
    1,
    1.07497,
    0.87709,
    0.96927,
    1.01473,
    0.96927,
    1,
    1,
    1,
    0.77295,
    1,
    1,
    1.09836,
    1.09836,
    1.09836,
    1.01522,
    0.86321,
    0.94434,
    0.8649,
    0.94434,
    0.86182,
    1,
    1,
    1.083,
    1,
    0.91578,
    0.86438,
    1.17308,
    1.18416,
    1.14589,
    0.69825,
    0.97622,
    1.96791,
    1.24822,
    1.24822,
    1.17308,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    0.99862,
    0.99862,
    1,
    0.87025,
    0.87025,
    0.87025,
    0.87025,
    1.17984,
    1.42603,
    1,
    1.42603,
    1.42603,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10742,
    1.10742,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], Cr = {
    lineHeight: 1.33008,
    lineGap: 0
  }, hr = [
    1.76738,
    1,
    1,
    0.98594,
    1.02285,
    1.10454,
    1.06234,
    0.96927,
    0.92037,
    1.19985,
    1.2046,
    0.90616,
    0.90616,
    1.07152,
    1.1714,
    0.78032,
    1.20088,
    0.78032,
    1.40246,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.96927,
    0.78032,
    0.78032,
    1.1714,
    1.1714,
    1.1714,
    0.80597,
    0.94084,
    0.96706,
    0.85944,
    0.85734,
    0.97093,
    0.75842,
    0.79936,
    0.88198,
    0.9831,
    0.95782,
    0.71387,
    0.86969,
    0.84636,
    1.07796,
    1.03584,
    0.96924,
    0.83968,
    0.96924,
    0.82826,
    0.79649,
    0.85771,
    0.95132,
    0.93119,
    0.98965,
    0.88433,
    0.8287,
    0.93365,
    1.08612,
    1.3638,
    1.08612,
    1.45786,
    0.74627,
    0.80499,
    0.91484,
    1.05707,
    0.92383,
    1.05882,
    0.9403,
    1.12654,
    1.05882,
    1.01756,
    1.09011,
    1.09011,
    0.99414,
    1.09011,
    1.034,
    1.01756,
    1.05356,
    1.05707,
    1.05882,
    1.04399,
    0.84863,
    1.21968,
    1.01756,
    0.95801,
    1.00068,
    0.91797,
    0.96777,
    0.9043,
    0.90351,
    0.92105,
    0.90351,
    1.1714,
    0.85337,
    0.96927,
    0.96927,
    0.99912,
    0.96927,
    0.92105,
    0.80597,
    1.2434,
    1.20808,
    1.05937,
    0.90957,
    1.1714,
    1.20808,
    0.75155,
    0.94261,
    1.24644,
    1.09971,
    1.09971,
    0.84751,
    1,
    0.85273,
    0.78032,
    0.61584,
    1.05425,
    1.17914,
    0.90957,
    1.08665,
    1.11593,
    1.14169,
    0.73381,
    0.96706,
    0.96706,
    0.96706,
    0.96706,
    0.96706,
    0.96706,
    0.86035,
    0.85734,
    0.75842,
    0.75842,
    0.75842,
    0.75842,
    0.95782,
    0.95782,
    0.95782,
    0.95782,
    0.97093,
    1.03584,
    0.96924,
    0.96924,
    0.96924,
    0.96924,
    0.96924,
    1.1714,
    0.96924,
    0.95132,
    0.95132,
    0.95132,
    0.95132,
    0.8287,
    0.83968,
    0.89049,
    0.91484,
    0.91484,
    0.91484,
    0.91484,
    0.91484,
    0.91484,
    0.93575,
    0.92383,
    0.9403,
    0.9403,
    0.9403,
    0.9403,
    0.8717,
    0.8717,
    0.8717,
    0.8717,
    1.00527,
    1.01756,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.05356,
    1.24644,
    0.95923,
    1.01756,
    1.01756,
    1.01756,
    1.01756,
    0.96777,
    1.05707,
    0.96777,
    0.96706,
    0.91484,
    0.96706,
    0.91484,
    0.96706,
    0.91484,
    0.85734,
    0.92383,
    0.85734,
    0.92383,
    0.85734,
    0.92383,
    0.85734,
    0.92383,
    0.97093,
    1.0969,
    0.97093,
    1.05882,
    0.75842,
    0.9403,
    0.75842,
    0.9403,
    0.75842,
    0.9403,
    0.75842,
    0.9403,
    0.75842,
    0.9403,
    0.88198,
    1.05882,
    0.88198,
    1.05882,
    0.88198,
    1.05882,
    1,
    1,
    0.9831,
    1.01756,
    0.9831,
    1.01756,
    0.95782,
    0.8717,
    0.95782,
    0.8717,
    0.95782,
    0.8717,
    0.95782,
    1.09011,
    0.95782,
    0.8717,
    0.84784,
    1.11551,
    0.71387,
    1.09011,
    1,
    1,
    0.99414,
    0.84636,
    1.09011,
    1,
    1,
    0.84636,
    1.0536,
    0.84636,
    0.94298,
    0.84636,
    1.23297,
    1.03584,
    1.01756,
    1,
    1,
    1.03584,
    1.01756,
    1.00323,
    1.03444,
    1.01756,
    0.96924,
    1.05356,
    0.96924,
    1.05356,
    0.96924,
    1.05356,
    0.93066,
    0.98293,
    0.82826,
    1.04399,
    1,
    1,
    0.82826,
    1.04399,
    0.79649,
    0.84863,
    0.79649,
    0.84863,
    0.79649,
    0.84863,
    0.79649,
    0.84863,
    1,
    1,
    0.85771,
    1.17318,
    0.85771,
    1.21968,
    0.95132,
    1.01756,
    0.95132,
    1.01756,
    0.95132,
    1.01756,
    0.95132,
    1.01756,
    0.95132,
    1.01756,
    0.95132,
    1.01756,
    0.98965,
    1.00068,
    0.8287,
    0.96777,
    0.8287,
    0.93365,
    0.9043,
    0.93365,
    0.9043,
    0.93365,
    0.9043,
    1.08571,
    0.96927,
    0.96706,
    0.91484,
    0.86035,
    0.93575,
    0.96924,
    0.95923,
    1,
    1,
    0.85771,
    1.21968,
    1.11437,
    1.11437,
    0.93109,
    0.91202,
    0.60411,
    0.84164,
    0.55572,
    1.01173,
    0.97361,
    0.81818,
    0.81818,
    0.96635,
    0.78032,
    0.72727,
    0.92366,
    0.98601,
    1.03405,
    0.77968,
    1.09799,
    1.2,
    0.96706,
    0.85944,
    0.85638,
    0.96491,
    0.75842,
    0.93365,
    0.9831,
    0.96924,
    0.95782,
    0.86969,
    0.94152,
    1.07796,
    1.03584,
    0.78437,
    0.96924,
    0.98715,
    0.83968,
    0.83491,
    0.85771,
    0.8287,
    0.94492,
    0.88433,
    0.9287,
    1.0098,
    0.95782,
    0.8287,
    1.0625,
    0.98248,
    1.03424,
    1.2,
    1.01071,
    1.0625,
    0.95246,
    1.03809,
    1.04912,
    0.98248,
    1.00221,
    1.03424,
    1.05443,
    1.2,
    1.04785,
    0.99609,
    1.00169,
    1.05176,
    0.99346,
    1.05356,
    0.9087,
    1.03004,
    0.95542,
    0.93117,
    1.23362,
    1.01071,
    1.07831,
    1.02512,
    1.05205,
    1.03502,
    1.2,
    1.01071,
    1.05356,
    1.01071,
    1.03502,
    0.75842,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.03719,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0.9403,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.04021,
    1,
    1,
    1,
    1,
    1,
    1,
    0.98965,
    1.00068,
    0.98965,
    1.00068,
    0.98965,
    1.00068,
    0.8287,
    0.96777,
    1,
    1.20088,
    0.89903,
    1,
    1,
    0.75155,
    1.03077,
    1.03077,
    1.03077,
    1.03077,
    1.13196,
    1.13196,
    1.13196,
    0.67428,
    0.67428,
    1.16039,
    0.73291,
    1.20996,
    1.22135,
    1.06483,
    0.94868,
    0.94868,
    0.95996,
    1.24633,
    1,
    1.07497,
    0.87796,
    0.96927,
    1.01518,
    0.96927,
    1,
    1,
    1,
    0.77295,
    1,
    1,
    1.10539,
    1.10539,
    1.11358,
    1.06967,
    0.86279,
    0.94434,
    0.86279,
    0.94434,
    0.86182,
    1,
    1,
    1.083,
    1,
    0.91578,
    0.86507,
    1.1714,
    1.18416,
    1.14589,
    0.69825,
    0.97622,
    1.9697,
    1.24822,
    1.24822,
    1.17238,
    1.24822,
    1.24822,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1.42603,
    1,
    0.99862,
    0.99862,
    1,
    0.87025,
    0.87025,
    0.87025,
    0.87025,
    1.18083,
    1.42603,
    1,
    1.42603,
    1.42603,
    0.99862,
    1,
    1,
    1,
    1,
    1,
    1.2886,
    1.04315,
    1.15296,
    1.34163,
    1,
    1,
    1,
    1.10938,
    1.10938,
    1,
    1,
    1,
    1.05425,
    1.09971,
    1.09971,
    1.09971,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ], lr = {
    lineHeight: 1.33008,
    lineGap: 0
  }, Qr = getLookupTableFactory(function(e2) {
    e2["MyriadPro-Regular"] = e2["PdfJS-Fallback-Regular"] = {
      name: "LiberationSans-Regular",
      factors: rr,
      baseWidths: _a,
      baseMapping: za,
      metrics: sr
    };
    e2["MyriadPro-Bold"] = e2["PdfJS-Fallback-Bold"] = {
      name: "LiberationSans-Bold",
      factors: $a,
      baseWidths: Pa,
      baseMapping: Wa,
      metrics: Ar
    };
    e2["MyriadPro-It"] = e2["MyriadPro-Italic"] = e2["PdfJS-Fallback-Italic"] = {
      name: "LiberationSans-Italic",
      factors: ir,
      baseWidths: Za,
      baseMapping: Va,
      metrics: ar
    };
    e2["MyriadPro-BoldIt"] = e2["MyriadPro-BoldItalic"] = e2["PdfJS-Fallback-BoldItalic"] = {
      name: "LiberationSans-BoldItalic",
      factors: er,
      baseWidths: ja,
      baseMapping: Xa,
      metrics: tr
    };
    e2.ArialMT = e2.Arial = e2["Arial-Regular"] = {
      name: "LiberationSans-Regular",
      baseWidths: _a,
      baseMapping: za
    };
    e2["Arial-BoldMT"] = e2["Arial-Bold"] = {
      name: "LiberationSans-Bold",
      baseWidths: Pa,
      baseMapping: Wa
    };
    e2["Arial-ItalicMT"] = e2["Arial-Italic"] = {
      name: "LiberationSans-Italic",
      baseWidths: Za,
      baseMapping: Va
    };
    e2["Arial-BoldItalicMT"] = e2["Arial-BoldItalic"] = {
      name: "LiberationSans-BoldItalic",
      baseWidths: ja,
      baseMapping: Xa
    };
    e2["Calibri-Regular"] = {
      name: "LiberationSans-Regular",
      factors: Ma,
      baseWidths: _a,
      baseMapping: za,
      metrics: La
    };
    e2["Calibri-Bold"] = {
      name: "LiberationSans-Bold",
      factors: ka,
      baseWidths: Pa,
      baseMapping: Wa,
      metrics: Ra
    };
    e2["Calibri-Italic"] = {
      name: "LiberationSans-Italic",
      factors: xa,
      baseWidths: Za,
      baseMapping: Va,
      metrics: Ua
    };
    e2["Calibri-BoldItalic"] = {
      name: "LiberationSans-BoldItalic",
      factors: Na,
      baseWidths: ja,
      baseMapping: Xa,
      metrics: Ga
    };
    e2["Segoeui-Regular"] = {
      name: "LiberationSans-Regular",
      factors: hr,
      baseWidths: _a,
      baseMapping: za,
      metrics: lr
    };
    e2["Segoeui-Bold"] = {
      name: "LiberationSans-Bold",
      factors: nr,
      baseWidths: Pa,
      baseMapping: Wa,
      metrics: or
    };
    e2["Segoeui-Italic"] = {
      name: "LiberationSans-Italic",
      factors: cr,
      baseWidths: Za,
      baseMapping: Va,
      metrics: Cr
    };
    e2["Segoeui-BoldItalic"] = {
      name: "LiberationSans-BoldItalic",
      factors: gr,
      baseWidths: ja,
      baseMapping: Xa,
      metrics: Ir
    };
    e2["Helvetica-Regular"] = e2.Helvetica = {
      name: "LiberationSans-Regular",
      factors: qa,
      baseWidths: _a,
      baseMapping: za,
      metrics: Oa
    };
    e2["Helvetica-Bold"] = {
      name: "LiberationSans-Bold",
      factors: Ha,
      baseWidths: Pa,
      baseMapping: Wa,
      metrics: Ja
    };
    e2["Helvetica-Italic"] = {
      name: "LiberationSans-Italic",
      factors: Ta,
      baseWidths: Za,
      baseMapping: Va,
      metrics: Ka
    };
    e2["Helvetica-BoldItalic"] = {
      name: "LiberationSans-BoldItalic",
      factors: va,
      baseWidths: ja,
      baseMapping: Xa,
      metrics: Ya
    };
  });
  function getXfaFontName(e2) {
    const t2 = normalizeFontName(e2);
    return Qr()[t2];
  }
  function getXfaFontDict(e2) {
    const t2 = function getXfaFontWidths(e3) {
      const t3 = getXfaFontName(e3);
      if (!t3) return null;
      const { baseWidths: i3, baseMapping: a3, factors: r3 } = t3, s2 = r3 ? i3.map((e4, t4) => e4 * r3[t4]) : i3;
      let n2, o2 = -2;
      const g2 = [];
      for (const [e4, t4] of a3.map((e5, t5) => [
        e5,
        t5
      ]).sort(([e5], [t5]) => e5 - t5)) if (-1 !== e4) if (e4 === o2 + 1) {
        n2.push(s2[t4]);
        o2 += 1;
      } else {
        o2 = e4;
        n2 = [
          s2[t4]
        ];
        g2.push(e4, n2);
      }
      return g2;
    }(e2), i2 = new Dict(null);
    i2.set("BaseFont", Name.get(e2));
    i2.set("Type", Name.get("Font"));
    i2.set("Subtype", Name.get("CIDFontType2"));
    i2.set("Encoding", Name.get("Identity-H"));
    i2.set("CIDToGIDMap", Name.get("Identity"));
    i2.set("W", t2);
    i2.set("FirstChar", t2[0]);
    i2.set("LastChar", t2.at(-2) + t2.at(-1).length - 1);
    const a2 = new Dict(null);
    i2.set("FontDescriptor", a2);
    const r2 = new Dict(null);
    r2.set("Ordering", "Identity");
    r2.set("Registry", "Adobe");
    r2.set("Supplement", 0);
    i2.set("CIDSystemInfo", r2);
    return i2;
  }
  class PostScriptParser {
    constructor(e2) {
      this.lexer = e2;
      this.operators = [];
      this.token = null;
      this.prev = null;
    }
    nextToken() {
      this.prev = this.token;
      this.token = this.lexer.getToken();
    }
    accept(e2) {
      if (this.token.type === e2) {
        this.nextToken();
        return true;
      }
      return false;
    }
    expect(e2) {
      if (this.accept(e2)) return true;
      throw new FormatError(`Unexpected symbol: found ${this.token.type} expected ${e2}.`);
    }
    parse() {
      this.nextToken();
      this.expect(Er.LBRACE);
      this.parseBlock();
      this.expect(Er.RBRACE);
      return this.operators;
    }
    parseBlock() {
      for (; ; ) if (this.accept(Er.NUMBER)) this.operators.push(this.prev.value);
      else if (this.accept(Er.OPERATOR)) this.operators.push(this.prev.value);
      else {
        if (!this.accept(Er.LBRACE)) return;
        this.parseCondition();
      }
    }
    parseCondition() {
      const e2 = this.operators.length;
      this.operators.push(null, null);
      this.parseBlock();
      this.expect(Er.RBRACE);
      if (this.accept(Er.IF)) {
        this.operators[e2] = this.operators.length;
        this.operators[e2 + 1] = "jz";
      } else {
        if (!this.accept(Er.LBRACE)) throw new FormatError("PS Function: error parsing conditional.");
        {
          const t2 = this.operators.length;
          this.operators.push(null, null);
          const i2 = this.operators.length;
          this.parseBlock();
          this.expect(Er.RBRACE);
          this.expect(Er.IFELSE);
          this.operators[t2] = this.operators.length;
          this.operators[t2 + 1] = "j";
          this.operators[e2] = i2;
          this.operators[e2 + 1] = "jz";
        }
      }
    }
  }
  const Er = {
    LBRACE: 0,
    RBRACE: 1,
    NUMBER: 2,
    OPERATOR: 3,
    IF: 4,
    IFELSE: 5
  };
  class PostScriptToken {
    static get opCache() {
      return shadow(this, "opCache", /* @__PURE__ */ Object.create(null));
    }
    constructor(e2, t2) {
      this.type = e2;
      this.value = t2;
    }
    static getOperator(e2) {
      var _a4;
      return (_a4 = PostScriptToken.opCache)[e2] || (_a4[e2] = new PostScriptToken(Er.OPERATOR, e2));
    }
    static get LBRACE() {
      return shadow(this, "LBRACE", new PostScriptToken(Er.LBRACE, "{"));
    }
    static get RBRACE() {
      return shadow(this, "RBRACE", new PostScriptToken(Er.RBRACE, "}"));
    }
    static get IF() {
      return shadow(this, "IF", new PostScriptToken(Er.IF, "IF"));
    }
    static get IFELSE() {
      return shadow(this, "IFELSE", new PostScriptToken(Er.IFELSE, "IFELSE"));
    }
  }
  class PostScriptLexer {
    constructor(e2) {
      this.stream = e2;
      this.nextChar();
      this.strBuf = [];
    }
    nextChar() {
      return this.currentChar = this.stream.getByte();
    }
    getToken() {
      let e2 = false, t2 = this.currentChar;
      for (; ; ) {
        if (t2 < 0) return bt;
        if (e2) 10 !== t2 && 13 !== t2 || (e2 = false);
        else if (37 === t2) e2 = true;
        else if (!isWhiteSpace(t2)) break;
        t2 = this.nextChar();
      }
      switch (0 | t2) {
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 43:
        case 45:
        case 46:
          return new PostScriptToken(Er.NUMBER, this.getNumber());
        case 123:
          this.nextChar();
          return PostScriptToken.LBRACE;
        case 125:
          this.nextChar();
          return PostScriptToken.RBRACE;
      }
      const i2 = this.strBuf;
      i2.length = 0;
      i2[0] = String.fromCharCode(t2);
      for (; (t2 = this.nextChar()) >= 0 && (t2 >= 65 && t2 <= 90 || t2 >= 97 && t2 <= 122); ) i2.push(String.fromCharCode(t2));
      const a2 = i2.join("");
      switch (a2.toLowerCase()) {
        case "if":
          return PostScriptToken.IF;
        case "ifelse":
          return PostScriptToken.IFELSE;
        default:
          return PostScriptToken.getOperator(a2);
      }
    }
    getNumber() {
      let e2 = this.currentChar;
      const t2 = this.strBuf;
      t2.length = 0;
      t2[0] = String.fromCharCode(e2);
      for (; (e2 = this.nextChar()) >= 0 && (e2 >= 48 && e2 <= 57 || 45 === e2 || 46 === e2); ) t2.push(String.fromCharCode(e2));
      const i2 = parseFloat(t2.join(""));
      if (isNaN(i2)) throw new FormatError(`Invalid floating point number: ${i2}`);
      return i2;
    }
  }
  class BaseLocalCache {
    constructor(e2) {
      this._onlyRefs = true === (e2 == null ? void 0 : e2.onlyRefs);
      if (!this._onlyRefs) {
        this._nameRefMap = /* @__PURE__ */ new Map();
        this._imageMap = /* @__PURE__ */ new Map();
      }
      this._imageCache = new RefSetCache();
    }
    getByName(e2) {
      this._onlyRefs && unreachable("Should not call `getByName` method.");
      const t2 = this._nameRefMap.get(e2);
      return t2 ? this.getByRef(t2) : this._imageMap.get(e2) || null;
    }
    getByRef(e2) {
      return this._imageCache.get(e2) || null;
    }
    set(e2, t2, i2) {
      unreachable("Abstract method `set` called.");
    }
  }
  class LocalImageCache extends BaseLocalCache {
    set(e2, t2 = null, i2) {
      if ("string" != typeof e2) throw new Error('LocalImageCache.set - expected "name" argument.');
      if (t2) {
        if (this._imageCache.has(t2)) return;
        this._nameRefMap.set(e2, t2);
        this._imageCache.put(t2, i2);
      } else this._imageMap.has(e2) || this._imageMap.set(e2, i2);
    }
  }
  class LocalColorSpaceCache extends BaseLocalCache {
    set(e2 = null, t2 = null, i2) {
      if ("string" != typeof e2 && !t2) throw new Error('LocalColorSpaceCache.set - expected "name" and/or "ref" argument.');
      if (t2) {
        if (this._imageCache.has(t2)) return;
        null !== e2 && this._nameRefMap.set(e2, t2);
        this._imageCache.put(t2, i2);
      } else this._imageMap.has(e2) || this._imageMap.set(e2, i2);
    }
  }
  class LocalFunctionCache extends BaseLocalCache {
    constructor(e2) {
      super({
        onlyRefs: true
      });
    }
    set(e2 = null, t2, i2) {
      if (!t2) throw new Error('LocalFunctionCache.set - expected "ref" argument.');
      this._imageCache.has(t2) || this._imageCache.put(t2, i2);
    }
  }
  class LocalGStateCache extends BaseLocalCache {
    set(e2, t2 = null, i2) {
      if ("string" != typeof e2) throw new Error('LocalGStateCache.set - expected "name" argument.');
      if (t2) {
        if (this._imageCache.has(t2)) return;
        this._nameRefMap.set(e2, t2);
        this._imageCache.put(t2, i2);
      } else this._imageMap.has(e2) || this._imageMap.set(e2, i2);
    }
  }
  class LocalTilingPatternCache extends BaseLocalCache {
    constructor(e2) {
      super({
        onlyRefs: true
      });
    }
    set(e2 = null, t2, i2) {
      if (!t2) throw new Error('LocalTilingPatternCache.set - expected "ref" argument.');
      this._imageCache.has(t2) || this._imageCache.put(t2, i2);
    }
  }
  class RegionalImageCache extends BaseLocalCache {
    constructor(e2) {
      super({
        onlyRefs: true
      });
    }
    set(e2 = null, t2, i2) {
      if (!t2) throw new Error('RegionalImageCache.set - expected "ref" argument.');
      this._imageCache.has(t2) || this._imageCache.put(t2, i2);
    }
  }
  const _GlobalImageCache = class _GlobalImageCache {
    constructor() {
      __privateAdd(this, _GlobalImageCache_instances);
      __privateAdd(this, _D, new RefSet());
      this._refCache = new RefSetCache();
      this._imageCache = new RefSetCache();
    }
    shouldCache(e2, t2) {
      let i2 = this._refCache.get(e2);
      if (!i2) {
        i2 = /* @__PURE__ */ new Set();
        this._refCache.put(e2, i2);
      }
      i2.add(t2);
      return !(i2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) && !(!this._imageCache.has(e2) && __privateGet(this, _GlobalImageCache_instances, S_get));
    }
    addDecodeFailed(e2) {
      __privateGet(this, _D).put(e2);
    }
    hasDecodeFailed(e2) {
      return __privateGet(this, _D).has(e2);
    }
    addByteSize(e2, t2) {
      const i2 = this._imageCache.get(e2);
      i2 && (i2.byteSize || (i2.byteSize = t2));
    }
    getData(e2, t2) {
      const i2 = this._refCache.get(e2);
      if (!i2) return null;
      if (i2.size < _GlobalImageCache.NUM_PAGES_THRESHOLD) return null;
      const a2 = this._imageCache.get(e2);
      if (!a2) return null;
      i2.add(t2);
      return a2;
    }
    setData(e2, t2) {
      if (!this._refCache.has(e2)) throw new Error('GlobalImageCache.setData - expected "shouldCache" to have been called.');
      this._imageCache.has(e2) || (__privateGet(this, _GlobalImageCache_instances, S_get) ? warn("GlobalImageCache.setData - cache limit reached.") : this._imageCache.put(e2, t2));
    }
    clear(e2 = false) {
      if (!e2) {
        __privateGet(this, _D).clear();
        this._refCache.clear();
      }
      this._imageCache.clear();
    }
  };
  _D = new WeakMap();
  _GlobalImageCache_instances = new WeakSet();
  F_get = function() {
    let e2 = 0;
    for (const t2 of this._imageCache) e2 += t2.byteSize;
    return e2;
  };
  S_get = function() {
    return !(this._imageCache.size < _GlobalImageCache.MIN_IMAGES_TO_CACHE) && !(__privateGet(this, _GlobalImageCache_instances, F_get) < _GlobalImageCache.MAX_BYTE_SIZE);
  };
  __publicField(_GlobalImageCache, "NUM_PAGES_THRESHOLD", 2);
  __publicField(_GlobalImageCache, "MIN_IMAGES_TO_CACHE", 10);
  __publicField(_GlobalImageCache, "MAX_BYTE_SIZE", 5e7);
  let GlobalImageCache = _GlobalImageCache;
  class PDFFunctionFactory {
    constructor({ xref: e2, isEvalSupported: t2 = true }) {
      this.xref = e2;
      this.isEvalSupported = false !== t2;
    }
    create(e2) {
      const t2 = this.getCached(e2);
      if (t2) return t2;
      const i2 = PDFFunction.parse({
        xref: this.xref,
        isEvalSupported: this.isEvalSupported,
        fn: e2 instanceof Ref ? this.xref.fetch(e2) : e2
      });
      this._cache(e2, i2);
      return i2;
    }
    createFromArray(e2) {
      const t2 = this.getCached(e2);
      if (t2) return t2;
      const i2 = PDFFunction.parseArray({
        xref: this.xref,
        isEvalSupported: this.isEvalSupported,
        fnObj: e2 instanceof Ref ? this.xref.fetch(e2) : e2
      });
      this._cache(e2, i2);
      return i2;
    }
    getCached(e2) {
      var _a4;
      let t2;
      e2 instanceof Ref ? t2 = e2 : e2 instanceof Dict ? t2 = e2.objId : e2 instanceof BaseStream && (t2 = (_a4 = e2.dict) == null ? void 0 : _a4.objId);
      if (t2) {
        const e3 = this._localFunctionCache.getByRef(t2);
        if (e3) return e3;
      }
      return null;
    }
    _cache(e2, t2) {
      var _a4;
      if (!t2) throw new Error('PDFFunctionFactory._cache - expected "parsedFunction" argument.');
      let i2;
      e2 instanceof Ref ? i2 = e2 : e2 instanceof Dict ? i2 = e2.objId : e2 instanceof BaseStream && (i2 = (_a4 = e2.dict) == null ? void 0 : _a4.objId);
      i2 && this._localFunctionCache.set(null, i2, t2);
    }
    get _localFunctionCache() {
      return shadow(this, "_localFunctionCache", new LocalFunctionCache());
    }
  }
  function toNumberArray(e2) {
    return Array.isArray(e2) ? isNumberArray(e2, null) ? e2 : e2.map((e3) => +e3) : null;
  }
  class PDFFunction {
    static getSampleArray(e2, t2, i2, a2) {
      let r2, s2, n2 = 1;
      for (r2 = 0, s2 = e2.length; r2 < s2; r2++) n2 *= e2[r2];
      n2 *= t2;
      const o2 = new Array(n2);
      let g2 = 0, c2 = 0;
      const C2 = 1 / (2 ** i2 - 1), h2 = a2.getBytes((n2 * i2 + 7) / 8);
      let l2 = 0;
      for (r2 = 0; r2 < n2; r2++) {
        for (; g2 < i2; ) {
          c2 <<= 8;
          c2 |= h2[l2++];
          g2 += 8;
        }
        g2 -= i2;
        o2[r2] = (c2 >> g2) * C2;
        c2 &= (1 << g2) - 1;
      }
      return o2;
    }
    static parse({ xref: e2, isEvalSupported: t2, fn: i2 }) {
      const a2 = i2.dict || i2;
      switch (a2.get("FunctionType")) {
        case 0:
          return this.constructSampled({
            xref: e2,
            isEvalSupported: t2,
            fn: i2,
            dict: a2
          });
        case 1:
          break;
        case 2:
          return this.constructInterpolated({
            xref: e2,
            isEvalSupported: t2,
            dict: a2
          });
        case 3:
          return this.constructStiched({
            xref: e2,
            isEvalSupported: t2,
            dict: a2
          });
        case 4:
          return this.constructPostScript({
            xref: e2,
            isEvalSupported: t2,
            fn: i2,
            dict: a2
          });
      }
      throw new FormatError("Unknown type of function");
    }
    static parseArray({ xref: e2, isEvalSupported: t2, fnObj: i2 }) {
      if (!Array.isArray(i2)) return this.parse({
        xref: e2,
        isEvalSupported: t2,
        fn: i2
      });
      const a2 = [];
      for (const r2 of i2) a2.push(this.parse({
        xref: e2,
        isEvalSupported: t2,
        fn: e2.fetchIfRef(r2)
      }));
      return function(e3, t3, i3, r2) {
        for (let s2 = 0, n2 = a2.length; s2 < n2; s2++) a2[s2](e3, t3, i3, r2 + s2);
      };
    }
    static constructSampled({ xref: e2, isEvalSupported: t2, fn: i2, dict: a2 }) {
      function toMultiArray(e3) {
        const t3 = e3.length, i3 = [];
        let a3 = 0;
        for (let r3 = 0; r3 < t3; r3 += 2) i3[a3++] = [
          e3[r3],
          e3[r3 + 1]
        ];
        return i3;
      }
      function interpolate(e3, t3, i3, a3, r3) {
        return a3 + (r3 - a3) / (i3 - t3) * (e3 - t3);
      }
      let r2 = toNumberArray(a2.getArray("Domain")), s2 = toNumberArray(a2.getArray("Range"));
      if (!r2 || !s2) throw new FormatError("No domain or range");
      const n2 = r2.length / 2, o2 = s2.length / 2;
      r2 = toMultiArray(r2);
      s2 = toMultiArray(s2);
      const g2 = toNumberArray(a2.getArray("Size")), c2 = a2.get("BitsPerSample"), C2 = a2.get("Order") || 1;
      1 !== C2 && info("No support for cubic spline interpolation: " + C2);
      let h2 = toNumberArray(a2.getArray("Encode"));
      if (h2) h2 = toMultiArray(h2);
      else {
        h2 = [];
        for (let e3 = 0; e3 < n2; ++e3) h2.push([
          0,
          g2[e3] - 1
        ]);
      }
      let l2 = toNumberArray(a2.getArray("Decode"));
      l2 = l2 ? toMultiArray(l2) : s2;
      const Q2 = this.getSampleArray(g2, o2, c2, i2);
      return function constructSampledFn(e3, t3, i3, a3) {
        const c3 = 1 << n2, C3 = new Float64Array(c3), E2 = new Uint32Array(c3);
        let u2, d2;
        for (d2 = 0; d2 < c3; d2++) C3[d2] = 1;
        let f2 = o2, p2 = 1;
        for (u2 = 0; u2 < n2; ++u2) {
          const i4 = r2[u2][0], a4 = r2[u2][1];
          let s3 = interpolate(Math.min(Math.max(e3[t3 + u2], i4), a4), i4, a4, h2[u2][0], h2[u2][1]);
          const n3 = g2[u2];
          s3 = Math.min(Math.max(s3, 0), n3 - 1);
          const o3 = s3 < n3 - 1 ? Math.floor(s3) : s3 - 1, l3 = o3 + 1 - s3, Q3 = s3 - o3, m2 = o3 * f2, y2 = m2 + f2;
          for (d2 = 0; d2 < c3; d2++) if (d2 & p2) {
            C3[d2] *= Q3;
            E2[d2] += y2;
          } else {
            C3[d2] *= l3;
            E2[d2] += m2;
          }
          f2 *= n3;
          p2 <<= 1;
        }
        for (d2 = 0; d2 < o2; ++d2) {
          let e4 = 0;
          for (u2 = 0; u2 < c3; u2++) e4 += Q2[E2[u2] + d2] * C3[u2];
          e4 = interpolate(e4, 0, 1, l2[d2][0], l2[d2][1]);
          i3[a3 + d2] = Math.min(Math.max(e4, s2[d2][0]), s2[d2][1]);
        }
      };
    }
    static constructInterpolated({ xref: e2, isEvalSupported: t2, dict: i2 }) {
      const a2 = toNumberArray(i2.getArray("C0")) || [
        0
      ], r2 = toNumberArray(i2.getArray("C1")) || [
        1
      ], s2 = i2.get("N"), n2 = [];
      for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3) n2.push(r2[e3] - a2[e3]);
      const o2 = n2.length;
      return function constructInterpolatedFn(e3, t3, i3, r3) {
        const g2 = 1 === s2 ? e3[t3] : e3[t3] ** s2;
        for (let e4 = 0; e4 < o2; ++e4) i3[r3 + e4] = a2[e4] + g2 * n2[e4];
      };
    }
    static constructStiched({ xref: e2, isEvalSupported: t2, dict: i2 }) {
      const a2 = toNumberArray(i2.getArray("Domain"));
      if (!a2) throw new FormatError("No domain");
      if (1 !== a2.length / 2) throw new FormatError("Bad domain for stiched function");
      const r2 = [];
      for (const a3 of i2.get("Functions")) r2.push(this.parse({
        xref: e2,
        isEvalSupported: t2,
        fn: e2.fetchIfRef(a3)
      }));
      const s2 = toNumberArray(i2.getArray("Bounds")), n2 = toNumberArray(i2.getArray("Encode")), o2 = new Float32Array(1);
      return function constructStichedFn(e3, t3, i3, g2) {
        const c2 = function constructStichedFromIRClip(e4, t4, i4) {
          e4 > i4 ? e4 = i4 : e4 < t4 && (e4 = t4);
          return e4;
        }(e3[t3], a2[0], a2[1]), C2 = s2.length;
        let h2;
        for (h2 = 0; h2 < C2 && !(c2 < s2[h2]); ++h2) ;
        let l2 = a2[0];
        h2 > 0 && (l2 = s2[h2 - 1]);
        let Q2 = a2[1];
        h2 < s2.length && (Q2 = s2[h2]);
        const E2 = n2[2 * h2], u2 = n2[2 * h2 + 1];
        o2[0] = l2 === Q2 ? E2 : E2 + (c2 - l2) * (u2 - E2) / (Q2 - l2);
        r2[h2](o2, 0, i3, g2);
      };
    }
    static constructPostScript({ xref: e2, isEvalSupported: t2, fn: i2, dict: a2 }) {
      const r2 = toNumberArray(a2.getArray("Domain")), s2 = toNumberArray(a2.getArray("Range"));
      if (!r2) throw new FormatError("No domain.");
      if (!s2) throw new FormatError("No range.");
      const n2 = new PostScriptLexer(i2), o2 = new PostScriptParser(n2).parse();
      if (t2 && FeatureTest.isEvalSupported) {
        const e3 = new PostScriptCompiler().compile(o2, r2, s2);
        if (e3) return new Function("src", "srcOffset", "dest", "destOffset", e3);
      }
      info("Unable to compile PS function");
      const g2 = s2.length >> 1, c2 = r2.length >> 1, C2 = new PostScriptEvaluator(o2), h2 = /* @__PURE__ */ Object.create(null);
      let l2 = 8192;
      const Q2 = new Float32Array(c2);
      return function constructPostScriptFn(e3, t3, i3, a3) {
        let r3, n3, o3 = "";
        const E2 = Q2;
        for (r3 = 0; r3 < c2; r3++) {
          n3 = e3[t3 + r3];
          E2[r3] = n3;
          o3 += n3 + "_";
        }
        const u2 = h2[o3];
        if (void 0 !== u2) {
          i3.set(u2, a3);
          return;
        }
        const d2 = new Float32Array(g2), f2 = C2.execute(E2), p2 = f2.length - g2;
        for (r3 = 0; r3 < g2; r3++) {
          n3 = f2[p2 + r3];
          let e4 = s2[2 * r3];
          if (n3 < e4) n3 = e4;
          else {
            e4 = s2[2 * r3 + 1];
            n3 > e4 && (n3 = e4);
          }
          d2[r3] = n3;
        }
        if (l2 > 0) {
          l2--;
          h2[o3] = d2;
        }
        i3.set(d2, a3);
      };
    }
  }
  function isPDFFunction(e2) {
    let t2;
    if (e2 instanceof Dict) t2 = e2;
    else {
      if (!(e2 instanceof BaseStream)) return false;
      t2 = e2.dict;
    }
    return t2.has("FunctionType");
  }
  const _PostScriptStack = class _PostScriptStack {
    constructor(e2) {
      this.stack = e2 ? Array.from(e2) : [];
    }
    push(e2) {
      if (this.stack.length >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
      this.stack.push(e2);
    }
    pop() {
      if (this.stack.length <= 0) throw new Error("PostScript function stack underflow.");
      return this.stack.pop();
    }
    copy(e2) {
      if (this.stack.length + e2 >= _PostScriptStack.MAX_STACK_SIZE) throw new Error("PostScript function stack overflow.");
      const t2 = this.stack;
      for (let i2 = t2.length - e2, a2 = e2 - 1; a2 >= 0; a2--, i2++) t2.push(t2[i2]);
    }
    index(e2) {
      this.push(this.stack[this.stack.length - e2 - 1]);
    }
    roll(e2, t2) {
      const i2 = this.stack, a2 = i2.length - e2, r2 = i2.length - 1, s2 = a2 + (t2 - Math.floor(t2 / e2) * e2);
      for (let e3 = a2, t3 = r2; e3 < t3; e3++, t3--) {
        const a3 = i2[e3];
        i2[e3] = i2[t3];
        i2[t3] = a3;
      }
      for (let e3 = a2, t3 = s2 - 1; e3 < t3; e3++, t3--) {
        const a3 = i2[e3];
        i2[e3] = i2[t3];
        i2[t3] = a3;
      }
      for (let e3 = s2, t3 = r2; e3 < t3; e3++, t3--) {
        const a3 = i2[e3];
        i2[e3] = i2[t3];
        i2[t3] = a3;
      }
    }
  };
  __publicField(_PostScriptStack, "MAX_STACK_SIZE", 100);
  let PostScriptStack = _PostScriptStack;
  class PostScriptEvaluator {
    constructor(e2) {
      this.operators = e2;
    }
    execute(e2) {
      const t2 = new PostScriptStack(e2);
      let i2 = 0;
      const a2 = this.operators, r2 = a2.length;
      let s2, n2, o2;
      for (; i2 < r2; ) {
        s2 = a2[i2++];
        if ("number" != typeof s2) switch (s2) {
          case "jz":
            o2 = t2.pop();
            n2 = t2.pop();
            n2 || (i2 = o2);
            break;
          case "j":
            n2 = t2.pop();
            i2 = n2;
            break;
          case "abs":
            n2 = t2.pop();
            t2.push(Math.abs(n2));
            break;
          case "add":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 + o2);
            break;
          case "and":
            o2 = t2.pop();
            n2 = t2.pop();
            "boolean" == typeof n2 && "boolean" == typeof o2 ? t2.push(n2 && o2) : t2.push(n2 & o2);
            break;
          case "atan":
            o2 = t2.pop();
            n2 = t2.pop();
            n2 = Math.atan2(n2, o2) / Math.PI * 180;
            n2 < 0 && (n2 += 360);
            t2.push(n2);
            break;
          case "bitshift":
            o2 = t2.pop();
            n2 = t2.pop();
            n2 > 0 ? t2.push(n2 << o2) : t2.push(n2 >> o2);
            break;
          case "ceiling":
            n2 = t2.pop();
            t2.push(Math.ceil(n2));
            break;
          case "copy":
            n2 = t2.pop();
            t2.copy(n2);
            break;
          case "cos":
            n2 = t2.pop();
            t2.push(Math.cos(n2 % 360 / 180 * Math.PI));
            break;
          case "cvi":
            n2 = 0 | t2.pop();
            t2.push(n2);
            break;
          case "cvr":
            break;
          case "div":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 / o2);
            break;
          case "dup":
            t2.copy(1);
            break;
          case "eq":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 === o2);
            break;
          case "exch":
            t2.roll(2, 1);
            break;
          case "exp":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 ** o2);
            break;
          case "false":
            t2.push(false);
            break;
          case "floor":
            n2 = t2.pop();
            t2.push(Math.floor(n2));
            break;
          case "ge":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 >= o2);
            break;
          case "gt":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 > o2);
            break;
          case "idiv":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 / o2 | 0);
            break;
          case "index":
            n2 = t2.pop();
            t2.index(n2);
            break;
          case "le":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 <= o2);
            break;
          case "ln":
            n2 = t2.pop();
            t2.push(Math.log(n2));
            break;
          case "log":
            n2 = t2.pop();
            t2.push(Math.log10(n2));
            break;
          case "lt":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 < o2);
            break;
          case "mod":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 % o2);
            break;
          case "mul":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 * o2);
            break;
          case "ne":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 !== o2);
            break;
          case "neg":
            n2 = t2.pop();
            t2.push(-n2);
            break;
          case "not":
            n2 = t2.pop();
            "boolean" == typeof n2 ? t2.push(!n2) : t2.push(~n2);
            break;
          case "or":
            o2 = t2.pop();
            n2 = t2.pop();
            "boolean" == typeof n2 && "boolean" == typeof o2 ? t2.push(n2 || o2) : t2.push(n2 | o2);
            break;
          case "pop":
            t2.pop();
            break;
          case "roll":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.roll(n2, o2);
            break;
          case "round":
            n2 = t2.pop();
            t2.push(Math.round(n2));
            break;
          case "sin":
            n2 = t2.pop();
            t2.push(Math.sin(n2 % 360 / 180 * Math.PI));
            break;
          case "sqrt":
            n2 = t2.pop();
            t2.push(Math.sqrt(n2));
            break;
          case "sub":
            o2 = t2.pop();
            n2 = t2.pop();
            t2.push(n2 - o2);
            break;
          case "true":
            t2.push(true);
            break;
          case "truncate":
            n2 = t2.pop();
            n2 = n2 < 0 ? Math.ceil(n2) : Math.floor(n2);
            t2.push(n2);
            break;
          case "xor":
            o2 = t2.pop();
            n2 = t2.pop();
            "boolean" == typeof n2 && "boolean" == typeof o2 ? t2.push(n2 !== o2) : t2.push(n2 ^ o2);
            break;
          default:
            throw new FormatError(`Unknown operator ${s2}`);
        }
        else t2.push(s2);
      }
      return t2.stack;
    }
  }
  class AstNode {
    constructor(e2) {
      this.type = e2;
    }
    visit(e2) {
      unreachable("abstract method");
    }
  }
  class AstArgument extends AstNode {
    constructor(e2, t2, i2) {
      super("args");
      this.index = e2;
      this.min = t2;
      this.max = i2;
    }
    visit(e2) {
      e2.visitArgument(this);
    }
  }
  class AstLiteral extends AstNode {
    constructor(e2) {
      super("literal");
      this.number = e2;
      this.min = e2;
      this.max = e2;
    }
    visit(e2) {
      e2.visitLiteral(this);
    }
  }
  class AstBinaryOperation extends AstNode {
    constructor(e2, t2, i2, a2, r2) {
      super("binary");
      this.op = e2;
      this.arg1 = t2;
      this.arg2 = i2;
      this.min = a2;
      this.max = r2;
    }
    visit(e2) {
      e2.visitBinaryOperation(this);
    }
  }
  class AstMin extends AstNode {
    constructor(e2, t2) {
      super("max");
      this.arg = e2;
      this.min = e2.min;
      this.max = t2;
    }
    visit(e2) {
      e2.visitMin(this);
    }
  }
  class AstVariable extends AstNode {
    constructor(e2, t2, i2) {
      super("var");
      this.index = e2;
      this.min = t2;
      this.max = i2;
    }
    visit(e2) {
      e2.visitVariable(this);
    }
  }
  class AstVariableDefinition extends AstNode {
    constructor(e2, t2) {
      super("definition");
      this.variable = e2;
      this.arg = t2;
    }
    visit(e2) {
      e2.visitVariableDefinition(this);
    }
  }
  class ExpressionBuilderVisitor {
    constructor() {
      this.parts = [];
    }
    visitArgument(e2) {
      this.parts.push("Math.max(", e2.min, ", Math.min(", e2.max, ", src[srcOffset + ", e2.index, "]))");
    }
    visitVariable(e2) {
      this.parts.push("v", e2.index);
    }
    visitLiteral(e2) {
      this.parts.push(e2.number);
    }
    visitBinaryOperation(e2) {
      this.parts.push("(");
      e2.arg1.visit(this);
      this.parts.push(" ", e2.op, " ");
      e2.arg2.visit(this);
      this.parts.push(")");
    }
    visitVariableDefinition(e2) {
      this.parts.push("var ");
      e2.variable.visit(this);
      this.parts.push(" = ");
      e2.arg.visit(this);
      this.parts.push(";");
    }
    visitMin(e2) {
      this.parts.push("Math.min(");
      e2.arg.visit(this);
      this.parts.push(", ", e2.max, ")");
    }
    toString() {
      return this.parts.join("");
    }
  }
  function buildAddOperation(e2, t2) {
    return "literal" === t2.type && 0 === t2.number ? e2 : "literal" === e2.type && 0 === e2.number ? t2 : "literal" === t2.type && "literal" === e2.type ? new AstLiteral(e2.number + t2.number) : new AstBinaryOperation("+", e2, t2, e2.min + t2.min, e2.max + t2.max);
  }
  function buildMulOperation(e2, t2) {
    if ("literal" === t2.type) {
      if (0 === t2.number) return new AstLiteral(0);
      if (1 === t2.number) return e2;
      if ("literal" === e2.type) return new AstLiteral(e2.number * t2.number);
    }
    if ("literal" === e2.type) {
      if (0 === e2.number) return new AstLiteral(0);
      if (1 === e2.number) return t2;
    }
    const i2 = Math.min(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max), a2 = Math.max(e2.min * t2.min, e2.min * t2.max, e2.max * t2.min, e2.max * t2.max);
    return new AstBinaryOperation("*", e2, t2, i2, a2);
  }
  function buildSubOperation(e2, t2) {
    if ("literal" === t2.type) {
      if (0 === t2.number) return e2;
      if ("literal" === e2.type) return new AstLiteral(e2.number - t2.number);
    }
    return "binary" === t2.type && "-" === t2.op && "literal" === e2.type && 1 === e2.number && "literal" === t2.arg1.type && 1 === t2.arg1.number ? t2.arg2 : new AstBinaryOperation("-", e2, t2, e2.min - t2.max, e2.max - t2.min);
  }
  function buildMinOperation(e2, t2) {
    return e2.min >= t2 ? new AstLiteral(t2) : e2.max <= t2 ? e2 : new AstMin(e2, t2);
  }
  class PostScriptCompiler {
    compile(e2, t2, i2) {
      const a2 = [], r2 = [], s2 = t2.length >> 1, n2 = i2.length >> 1;
      let o2, g2, c2, C2, h2, l2, Q2, E2, u2 = 0;
      for (let e3 = 0; e3 < s2; e3++) a2.push(new AstArgument(e3, t2[2 * e3], t2[2 * e3 + 1]));
      for (let t3 = 0, i3 = e2.length; t3 < i3; t3++) {
        E2 = e2[t3];
        if ("number" != typeof E2) switch (E2) {
          case "add":
            if (a2.length < 2) return null;
            C2 = a2.pop();
            c2 = a2.pop();
            a2.push(buildAddOperation(c2, C2));
            break;
          case "cvr":
            if (a2.length < 1) return null;
            break;
          case "mul":
            if (a2.length < 2) return null;
            C2 = a2.pop();
            c2 = a2.pop();
            a2.push(buildMulOperation(c2, C2));
            break;
          case "sub":
            if (a2.length < 2) return null;
            C2 = a2.pop();
            c2 = a2.pop();
            a2.push(buildSubOperation(c2, C2));
            break;
          case "exch":
            if (a2.length < 2) return null;
            h2 = a2.pop();
            l2 = a2.pop();
            a2.push(h2, l2);
            break;
          case "pop":
            if (a2.length < 1) return null;
            a2.pop();
            break;
          case "index":
            if (a2.length < 1) return null;
            c2 = a2.pop();
            if ("literal" !== c2.type) return null;
            o2 = c2.number;
            if (o2 < 0 || !Number.isInteger(o2) || a2.length < o2) return null;
            h2 = a2[a2.length - o2 - 1];
            if ("literal" === h2.type || "var" === h2.type) {
              a2.push(h2);
              break;
            }
            Q2 = new AstVariable(u2++, h2.min, h2.max);
            a2[a2.length - o2 - 1] = Q2;
            a2.push(Q2);
            r2.push(new AstVariableDefinition(Q2, h2));
            break;
          case "dup":
            if (a2.length < 1) return null;
            if ("number" == typeof e2[t3 + 1] && "gt" === e2[t3 + 2] && e2[t3 + 3] === t3 + 7 && "jz" === e2[t3 + 4] && "pop" === e2[t3 + 5] && e2[t3 + 6] === e2[t3 + 1]) {
              c2 = a2.pop();
              a2.push(buildMinOperation(c2, e2[t3 + 1]));
              t3 += 6;
              break;
            }
            h2 = a2.at(-1);
            if ("literal" === h2.type || "var" === h2.type) {
              a2.push(h2);
              break;
            }
            Q2 = new AstVariable(u2++, h2.min, h2.max);
            a2[a2.length - 1] = Q2;
            a2.push(Q2);
            r2.push(new AstVariableDefinition(Q2, h2));
            break;
          case "roll":
            if (a2.length < 2) return null;
            C2 = a2.pop();
            c2 = a2.pop();
            if ("literal" !== C2.type || "literal" !== c2.type) return null;
            g2 = C2.number;
            o2 = c2.number;
            if (o2 <= 0 || !Number.isInteger(o2) || !Number.isInteger(g2) || a2.length < o2) return null;
            g2 = (g2 % o2 + o2) % o2;
            if (0 === g2) break;
            a2.push(...a2.splice(a2.length - o2, o2 - g2));
            break;
          default:
            return null;
        }
        else a2.push(new AstLiteral(E2));
      }
      if (a2.length !== n2) return null;
      const d2 = [];
      for (const e3 of r2) {
        const t3 = new ExpressionBuilderVisitor();
        e3.visit(t3);
        d2.push(t3.toString());
      }
      for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        const t4 = a2[e3], r3 = new ExpressionBuilderVisitor();
        t4.visit(r3);
        const s3 = i2[2 * e3], n3 = i2[2 * e3 + 1], o3 = [
          r3.toString()
        ];
        if (s3 > t4.min) {
          o3.unshift("Math.max(", s3, ", ");
          o3.push(")");
        }
        if (n3 < t4.max) {
          o3.unshift("Math.min(", n3, ", ");
          o3.push(")");
        }
        o3.unshift("dest[destOffset + ", e3, "] = ");
        o3.push(";");
        d2.push(o3.join(""));
      }
      return d2.join("\n");
    }
  }
  const ur = [
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "S",
    "B",
    "S",
    "WS",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "B",
    "B",
    "S",
    "WS",
    "ON",
    "ON",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ES",
    "CS",
    "ES",
    "CS",
    "CS",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "CS",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "B",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "BN",
    "CS",
    "ON",
    "ET",
    "ET",
    "ET",
    "ET",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "ON",
    "ON",
    "BN",
    "ON",
    "ON",
    "ET",
    "ET",
    "EN",
    "EN",
    "ON",
    "L",
    "ON",
    "ON",
    "ON",
    "EN",
    "L",
    "ON",
    "ON",
    "ON",
    "ON",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "ON",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L",
    "L"
  ], dr = [
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ON",
    "ON",
    "AL",
    "ET",
    "ET",
    "AL",
    "CS",
    "AL",
    "ON",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "AN",
    "ET",
    "AN",
    "AN",
    "AL",
    "AL",
    "AL",
    "NSM",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AN",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "NSM",
    "NSM",
    "ON",
    "NSM",
    "NSM",
    "NSM",
    "NSM",
    "AL",
    "AL",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "EN",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL",
    "AL"
  ];
  function isOdd(e2) {
    return 0 != (1 & e2);
  }
  function isEven(e2) {
    return 0 == (1 & e2);
  }
  function findUnequal(e2, t2, i2) {
    let a2, r2;
    for (a2 = t2, r2 = e2.length; a2 < r2; ++a2) if (e2[a2] !== i2) return a2;
    return a2;
  }
  function setValues(e2, t2, i2, a2) {
    for (let r2 = t2; r2 < i2; ++r2) e2[r2] = a2;
  }
  function reverseValues(e2, t2, i2) {
    for (let a2 = t2, r2 = i2 - 1; a2 < r2; ++a2, --r2) {
      const t3 = e2[a2];
      e2[a2] = e2[r2];
      e2[r2] = t3;
    }
  }
  function createBidiText(e2, t2, i2 = false) {
    let a2 = "ltr";
    i2 ? a2 = "ttb" : t2 || (a2 = "rtl");
    return {
      str: e2,
      dir: a2
    };
  }
  const fr = [], pr = [];
  function bidi(e2, t2 = -1, i2 = false) {
    let a2 = true;
    const r2 = e2.length;
    if (0 === r2 || i2) return createBidiText(e2, a2, i2);
    fr.length = r2;
    pr.length = r2;
    let s2, n2, o2 = 0;
    for (s2 = 0; s2 < r2; ++s2) {
      fr[s2] = e2.charAt(s2);
      const t3 = e2.charCodeAt(s2);
      let i3 = "L";
      if (t3 <= 255) i3 = ur[t3];
      else if (1424 <= t3 && t3 <= 1524) i3 = "R";
      else if (1536 <= t3 && t3 <= 1791) {
        i3 = dr[255 & t3];
        i3 || warn("Bidi: invalid Unicode character " + t3.toString(16));
      } else (1792 <= t3 && t3 <= 2220 || 64336 <= t3 && t3 <= 65023 || 65136 <= t3 && t3 <= 65279) && (i3 = "AL");
      "R" !== i3 && "AL" !== i3 && "AN" !== i3 || o2++;
      pr[s2] = i3;
    }
    if (0 === o2) {
      a2 = true;
      return createBidiText(e2, a2);
    }
    if (-1 === t2) if (o2 / r2 < 0.3 && r2 > 4) {
      a2 = true;
      t2 = 0;
    } else {
      a2 = false;
      t2 = 1;
    }
    const g2 = [];
    for (s2 = 0; s2 < r2; ++s2) g2[s2] = t2;
    const c2 = isOdd(t2) ? "R" : "L", C2 = c2, h2 = C2;
    let l2, Q2 = C2;
    for (s2 = 0; s2 < r2; ++s2) "NSM" === pr[s2] ? pr[s2] = Q2 : Q2 = pr[s2];
    Q2 = C2;
    for (s2 = 0; s2 < r2; ++s2) {
      l2 = pr[s2];
      "EN" === l2 ? pr[s2] = "AL" === Q2 ? "AN" : "EN" : "R" !== l2 && "L" !== l2 && "AL" !== l2 || (Q2 = l2);
    }
    for (s2 = 0; s2 < r2; ++s2) {
      l2 = pr[s2];
      "AL" === l2 && (pr[s2] = "R");
    }
    for (s2 = 1; s2 < r2 - 1; ++s2) {
      "ES" === pr[s2] && "EN" === pr[s2 - 1] && "EN" === pr[s2 + 1] && (pr[s2] = "EN");
      "CS" !== pr[s2] || "EN" !== pr[s2 - 1] && "AN" !== pr[s2 - 1] || pr[s2 + 1] !== pr[s2 - 1] || (pr[s2] = pr[s2 - 1]);
    }
    for (s2 = 0; s2 < r2; ++s2) if ("EN" === pr[s2]) {
      for (let e3 = s2 - 1; e3 >= 0 && "ET" === pr[e3]; --e3) pr[e3] = "EN";
      for (let e3 = s2 + 1; e3 < r2 && "ET" === pr[e3]; ++e3) pr[e3] = "EN";
    }
    for (s2 = 0; s2 < r2; ++s2) {
      l2 = pr[s2];
      "WS" !== l2 && "ES" !== l2 && "ET" !== l2 && "CS" !== l2 || (pr[s2] = "ON");
    }
    Q2 = C2;
    for (s2 = 0; s2 < r2; ++s2) {
      l2 = pr[s2];
      "EN" === l2 ? pr[s2] = "L" === Q2 ? "L" : "EN" : "R" !== l2 && "L" !== l2 || (Q2 = l2);
    }
    for (s2 = 0; s2 < r2; ++s2) if ("ON" === pr[s2]) {
      const e3 = findUnequal(pr, s2 + 1, "ON");
      let t3 = C2;
      s2 > 0 && (t3 = pr[s2 - 1]);
      let i3 = h2;
      e3 + 1 < r2 && (i3 = pr[e3 + 1]);
      "L" !== t3 && (t3 = "R");
      "L" !== i3 && (i3 = "R");
      t3 === i3 && setValues(pr, s2, e3, t3);
      s2 = e3 - 1;
    }
    for (s2 = 0; s2 < r2; ++s2) "ON" === pr[s2] && (pr[s2] = c2);
    for (s2 = 0; s2 < r2; ++s2) {
      l2 = pr[s2];
      isEven(g2[s2]) ? "R" === l2 ? g2[s2] += 1 : "AN" !== l2 && "EN" !== l2 || (g2[s2] += 2) : "L" !== l2 && "AN" !== l2 && "EN" !== l2 || (g2[s2] += 1);
    }
    let E2, u2 = -1, d2 = 99;
    for (s2 = 0, n2 = g2.length; s2 < n2; ++s2) {
      E2 = g2[s2];
      u2 < E2 && (u2 = E2);
      d2 > E2 && isOdd(E2) && (d2 = E2);
    }
    for (E2 = u2; E2 >= d2; --E2) {
      let e3 = -1;
      for (s2 = 0, n2 = g2.length; s2 < n2; ++s2) if (g2[s2] < E2) {
        if (e3 >= 0) {
          reverseValues(fr, e3, s2);
          e3 = -1;
        }
      } else e3 < 0 && (e3 = s2);
      e3 >= 0 && reverseValues(fr, e3, g2.length);
    }
    for (s2 = 0, n2 = fr.length; s2 < n2; ++s2) {
      const e3 = fr[s2];
      "<" !== e3 && ">" !== e3 || (fr[s2] = "");
    }
    return createBidiText(fr.join(""), a2);
  }
  const mr = {
    style: "normal",
    weight: "normal"
  }, yr = {
    style: "normal",
    weight: "bold"
  }, wr = {
    style: "italic",
    weight: "normal"
  }, br = {
    style: "italic",
    weight: "bold"
  }, Dr = /* @__PURE__ */ new Map([
    [
      "Times-Roman",
      {
        local: [
          "Times New Roman",
          "Times-Roman",
          "Times",
          "Liberation Serif",
          "Nimbus Roman",
          "Nimbus Roman L",
          "Tinos",
          "Thorndale",
          "TeX Gyre Termes",
          "FreeSerif",
          "Linux Libertine O",
          "Libertinus Serif",
          "DejaVu Serif",
          "Bitstream Vera Serif",
          "Ubuntu"
        ],
        style: mr,
        ultimate: "serif"
      }
    ],
    [
      "Times-Bold",
      {
        alias: "Times-Roman",
        style: yr,
        ultimate: "serif"
      }
    ],
    [
      "Times-Italic",
      {
        alias: "Times-Roman",
        style: wr,
        ultimate: "serif"
      }
    ],
    [
      "Times-BoldItalic",
      {
        alias: "Times-Roman",
        style: br,
        ultimate: "serif"
      }
    ],
    [
      "Helvetica",
      {
        local: [
          "Helvetica",
          "Helvetica Neue",
          "Arial",
          "Arial Nova",
          "Liberation Sans",
          "Arimo",
          "Nimbus Sans",
          "Nimbus Sans L",
          "A030",
          "TeX Gyre Heros",
          "FreeSans",
          "DejaVu Sans",
          "Albany",
          "Bitstream Vera Sans",
          "Arial Unicode MS",
          "Microsoft Sans Serif",
          "Apple Symbols",
          "Cantarell"
        ],
        path: "LiberationSans-Regular.ttf",
        style: mr,
        ultimate: "sans-serif"
      }
    ],
    [
      "Helvetica-Bold",
      {
        alias: "Helvetica",
        path: "LiberationSans-Bold.ttf",
        style: yr,
        ultimate: "sans-serif"
      }
    ],
    [
      "Helvetica-Oblique",
      {
        alias: "Helvetica",
        path: "LiberationSans-Italic.ttf",
        style: wr,
        ultimate: "sans-serif"
      }
    ],
    [
      "Helvetica-BoldOblique",
      {
        alias: "Helvetica",
        path: "LiberationSans-BoldItalic.ttf",
        style: br,
        ultimate: "sans-serif"
      }
    ],
    [
      "Courier",
      {
        local: [
          "Courier",
          "Courier New",
          "Liberation Mono",
          "Nimbus Mono",
          "Nimbus Mono L",
          "Cousine",
          "Cumberland",
          "TeX Gyre Cursor",
          "FreeMono",
          "Linux Libertine Mono O",
          "Libertinus Mono"
        ],
        style: mr,
        ultimate: "monospace"
      }
    ],
    [
      "Courier-Bold",
      {
        alias: "Courier",
        style: yr,
        ultimate: "monospace"
      }
    ],
    [
      "Courier-Oblique",
      {
        alias: "Courier",
        style: wr,
        ultimate: "monospace"
      }
    ],
    [
      "Courier-BoldOblique",
      {
        alias: "Courier",
        style: br,
        ultimate: "monospace"
      }
    ],
    [
      "ArialBlack",
      {
        local: [
          "Arial Black"
        ],
        style: {
          style: "normal",
          weight: "900"
        },
        fallback: "Helvetica-Bold"
      }
    ],
    [
      "ArialBlack-Bold",
      {
        alias: "ArialBlack"
      }
    ],
    [
      "ArialBlack-Italic",
      {
        alias: "ArialBlack",
        style: {
          style: "italic",
          weight: "900"
        },
        fallback: "Helvetica-BoldOblique"
      }
    ],
    [
      "ArialBlack-BoldItalic",
      {
        alias: "ArialBlack-Italic"
      }
    ],
    [
      "ArialNarrow",
      {
        local: [
          "Arial Narrow",
          "Liberation Sans Narrow",
          "Helvetica Condensed",
          "Nimbus Sans Narrow",
          "TeX Gyre Heros Cn"
        ],
        style: mr,
        fallback: "Helvetica"
      }
    ],
    [
      "ArialNarrow-Bold",
      {
        alias: "ArialNarrow",
        style: yr,
        fallback: "Helvetica-Bold"
      }
    ],
    [
      "ArialNarrow-Italic",
      {
        alias: "ArialNarrow",
        style: wr,
        fallback: "Helvetica-Oblique"
      }
    ],
    [
      "ArialNarrow-BoldItalic",
      {
        alias: "ArialNarrow",
        style: br,
        fallback: "Helvetica-BoldOblique"
      }
    ],
    [
      "Calibri",
      {
        local: [
          "Calibri",
          "Carlito"
        ],
        style: mr,
        fallback: "Helvetica"
      }
    ],
    [
      "Calibri-Bold",
      {
        alias: "Calibri",
        style: yr,
        fallback: "Helvetica-Bold"
      }
    ],
    [
      "Calibri-Italic",
      {
        alias: "Calibri",
        style: wr,
        fallback: "Helvetica-Oblique"
      }
    ],
    [
      "Calibri-BoldItalic",
      {
        alias: "Calibri",
        style: br,
        fallback: "Helvetica-BoldOblique"
      }
    ],
    [
      "Wingdings",
      {
        local: [
          "Wingdings",
          "URW Dingbats"
        ],
        style: mr
      }
    ],
    [
      "Wingdings-Regular",
      {
        alias: "Wingdings"
      }
    ],
    [
      "Wingdings-Bold",
      {
        alias: "Wingdings"
      }
    ]
  ]), Fr = /* @__PURE__ */ new Map([
    [
      "Arial-Black",
      "ArialBlack"
    ]
  ]);
  function getFamilyName(e2) {
    const t2 = /* @__PURE__ */ new Set([
      "thin",
      "extralight",
      "ultralight",
      "demilight",
      "semilight",
      "light",
      "book",
      "regular",
      "normal",
      "medium",
      "demibold",
      "semibold",
      "bold",
      "extrabold",
      "ultrabold",
      "black",
      "heavy",
      "extrablack",
      "ultrablack",
      "roman",
      "italic",
      "oblique",
      "ultracondensed",
      "extracondensed",
      "condensed",
      "semicondensed",
      "normal",
      "semiexpanded",
      "expanded",
      "extraexpanded",
      "ultraexpanded",
      "bolditalic"
    ]);
    return e2.split(/[- ,+]+/g).filter((e3) => !t2.has(e3.toLowerCase())).join(" ");
  }
  function generateFont({ alias: e2, local: t2, path: i2, fallback: a2, style: r2, ultimate: s2 }, n2, o2, g2 = true, c2 = true, C2 = "") {
    const h2 = {
      style: null,
      ultimate: null
    };
    if (t2) {
      const e3 = C2 ? ` ${C2}` : "";
      for (const i3 of t2) n2.push(`local(${i3}${e3})`);
    }
    if (e2) {
      const t3 = Dr.get(e2), s3 = C2 || function getStyleToAppend(e3) {
        switch (e3) {
          case yr:
            return "Bold";
          case wr:
            return "Italic";
          case br:
            return "Bold Italic";
          default:
            if ("bold" === (e3 == null ? void 0 : e3.weight)) return "Bold";
            if ("italic" === (e3 == null ? void 0 : e3.style)) return "Italic";
        }
        return "";
      }(r2);
      Object.assign(h2, generateFont(t3, n2, o2, g2 && !a2, c2 && !i2, s3));
    }
    r2 && (h2.style = r2);
    s2 && (h2.ultimate = s2);
    if (g2 && a2) {
      const e3 = Dr.get(a2), { ultimate: t3 } = generateFont(e3, n2, o2, g2, c2 && !i2, C2);
      h2.ultimate || (h2.ultimate = t3);
    }
    c2 && i2 && o2 && n2.push(`url(${o2}${i2})`);
    return h2;
  }
  function getFontSubstitution(e2, t2, i2, a2, r2, s2) {
    if (a2.startsWith("InvalidPDFjsFont_")) return null;
    "TrueType" !== s2 && "Type1" !== s2 || !/^[A-Z]{6}\+/.test(a2) || (a2 = a2.slice(7));
    const n2 = a2 = normalizeFontName(a2);
    let o2 = e2.get(n2);
    if (o2) return o2;
    let g2 = Dr.get(a2);
    if (!g2) {
      for (const [e3, t3] of Fr) if (a2.startsWith(e3)) {
        a2 = `${t3}${a2.substring(e3.length)}`;
        g2 = Dr.get(a2);
        break;
      }
    }
    let c2 = false;
    if (!g2) {
      g2 = Dr.get(r2);
      c2 = true;
    }
    const C2 = `${t2.getDocId()}_s${t2.createFontId()}`;
    if (!g2) {
      if (!validateFontName(a2)) {
        warn(`Cannot substitute the font because of its name: ${a2}`);
        e2.set(n2, null);
        return null;
      }
      const t3 = /bold/gi.test(a2), i3 = /oblique|italic/gi.test(a2), r3 = t3 && i3 && br || t3 && yr || i3 && wr || mr;
      o2 = {
        css: `"${getFamilyName(a2)}",${C2}`,
        guessFallback: true,
        loadedName: C2,
        baseFontName: a2,
        src: `local(${a2})`,
        style: r3
      };
      e2.set(n2, o2);
      return o2;
    }
    const h2 = [];
    c2 && validateFontName(a2) && h2.push(`local(${a2})`);
    const { style: l2, ultimate: Q2 } = generateFont(g2, h2, i2), E2 = null === Q2, u2 = E2 ? "" : `,${Q2}`;
    o2 = {
      css: `"${getFamilyName(a2)}",${C2}${u2}`,
      guessFallback: E2,
      loadedName: C2,
      baseFontName: a2,
      src: h2.join(","),
      style: l2
    };
    e2.set(n2, o2);
    return o2;
  }
  const _ImageResizer = class _ImageResizer {
    constructor(e2, t2) {
      this._imgData = e2;
      this._isMask = t2;
    }
    static get canUseImageDecoder() {
      return shadow(this, "canUseImageDecoder", __privateGet(this, _R) || "undefined" == typeof ImageDecoder ? Promise.resolve(false) : ImageDecoder.isTypeSupported("image/bmp"));
    }
    static needsToBeResized(e2, t2) {
      if (e2 <= __privateGet(this, _k) && t2 <= __privateGet(this, _k)) return false;
      const { MAX_DIM: i2 } = this;
      if (e2 > i2 || t2 > i2) return true;
      const a2 = e2 * t2;
      if (this._hasMaxArea) return a2 > this.MAX_AREA;
      if (a2 < __privateGet(this, _k) ** 2) return false;
      if (this._areGoodDims(e2, t2)) {
        __privateSet(this, _k, Math.max(__privateGet(this, _k), Math.floor(Math.sqrt(e2 * t2))));
        return false;
      }
      __privateSet(this, _k, this._guessMax(__privateGet(this, _k), i2, 128, 0));
      return a2 > (this.MAX_AREA = __privateGet(this, _k) ** 2);
    }
    static get MAX_DIM() {
      return shadow(this, "MAX_DIM", this._guessMax(2048, 65537, 0, 1));
    }
    static get MAX_AREA() {
      this._hasMaxArea = true;
      return shadow(this, "MAX_AREA", this._guessMax(__privateGet(this, _k), this.MAX_DIM, 128, 0) ** 2);
    }
    static set MAX_AREA(e2) {
      if (e2 >= 0) {
        this._hasMaxArea = true;
        shadow(this, "MAX_AREA", e2);
      }
    }
    static setMaxArea(e2) {
      this._hasMaxArea || (this.MAX_AREA = e2 >> 2);
    }
    static setOptions(e2) {
      this.setMaxArea(e2.maxArea ?? -1);
      __privateSet(this, _R, e2.isChrome ?? false);
    }
    static _areGoodDims(e2, t2) {
      try {
        const i2 = new OffscreenCanvas(e2, t2), a2 = i2.getContext("2d");
        a2.fillRect(0, 0, 1, 1);
        const r2 = a2.getImageData(0, 0, 1, 1).data[3];
        i2.width = i2.height = 1;
        return 0 !== r2;
      } catch {
        return false;
      }
    }
    static _guessMax(e2, t2, i2, a2) {
      for (; e2 + i2 + 1 < t2; ) {
        const i3 = Math.floor((e2 + t2) / 2), r2 = a2 || i3;
        this._areGoodDims(i3, r2) ? e2 = i3 : t2 = i3;
      }
      return e2;
    }
    static async createImage(e2, t2 = false) {
      return new _ImageResizer(e2, t2)._createImage();
    }
    async _createImage() {
      const e2 = this._encodeBMP();
      let t2, i2;
      if (await _ImageResizer.canUseImageDecoder) {
        t2 = new ImageDecoder({
          data: e2,
          type: "image/bmp",
          preferAnimation: false,
          transfer: [
            e2.buffer
          ]
        });
        i2 = t2.decode().catch((e3) => {
          warn(`BMP image decoding failed: ${e3}`);
          return createImageBitmap(new Blob([
            this._encodeBMP().buffer
          ], {
            type: "image/bmp"
          }));
        }).finally(() => {
          t2.close();
        });
      } else i2 = createImageBitmap(new Blob([
        e2.buffer
      ], {
        type: "image/bmp"
      }));
      const { MAX_AREA: a2, MAX_DIM: r2 } = _ImageResizer, { _imgData: s2 } = this, { width: n2, height: o2 } = s2, g2 = Math.max(n2 / r2, o2 / r2, Math.sqrt(n2 * o2 / a2)), c2 = Math.max(g2, 2), C2 = Math.round(10 * (g2 + 1.25)) / 10 / c2, h2 = Math.floor(Math.log2(C2)), l2 = new Array(h2 + 2).fill(2);
      l2[0] = c2;
      l2.splice(-1, 1, C2 / (1 << h2));
      let Q2 = n2, E2 = o2;
      const u2 = await i2;
      let d2 = u2.image || u2;
      for (const e3 of l2) {
        const t3 = Q2, i3 = E2;
        Q2 = Math.floor(Q2 / e3) - 1;
        E2 = Math.floor(E2 / e3) - 1;
        const a3 = new OffscreenCanvas(Q2, E2);
        a3.getContext("2d").drawImage(d2, 0, 0, t3, i3, 0, 0, Q2, E2);
        d2.close();
        d2 = a3.transferToImageBitmap();
      }
      s2.data = null;
      s2.bitmap = d2;
      s2.width = Q2;
      s2.height = E2;
      return s2;
    }
    _encodeBMP() {
      const { width: e2, height: t2, kind: i2 } = this._imgData;
      let a2, r2 = this._imgData.data, s2 = new Uint8Array(0), n2 = s2, o2 = 0;
      switch (i2) {
        case S: {
          a2 = 1;
          s2 = new Uint8Array(this._isMask ? [
            255,
            255,
            255,
            255,
            0,
            0,
            0,
            0
          ] : [
            0,
            0,
            0,
            0,
            255,
            255,
            255,
            255
          ]);
          const i4 = e2 + 7 >> 3, n3 = i4 + 3 & -4;
          if (i4 !== n3) {
            const e3 = new Uint8Array(n3 * t2);
            let a3 = 0;
            for (let s3 = 0, o3 = t2 * i4; s3 < o3; s3 += i4, a3 += n3) e3.set(r2.subarray(s3, s3 + i4), a3);
            r2 = e3;
          }
          break;
        }
        case k:
          a2 = 24;
          if (3 & e2) {
            const i4 = 3 * e2, a3 = i4 + 3 & -4, s3 = a3 - i4, n3 = new Uint8Array(a3 * t2);
            let o3 = 0;
            for (let e3 = 0, a4 = t2 * i4; e3 < a4; e3 += i4) {
              const t3 = r2.subarray(e3, e3 + i4);
              for (let e4 = 0; e4 < i4; e4 += 3) {
                n3[o3++] = t3[e4 + 2];
                n3[o3++] = t3[e4 + 1];
                n3[o3++] = t3[e4];
              }
              o3 += s3;
            }
            r2 = n3;
          } else for (let e3 = 0, t3 = r2.length; e3 < t3; e3 += 3) {
            const t4 = r2[e3];
            r2[e3] = r2[e3 + 2];
            r2[e3 + 2] = t4;
          }
          break;
        case R:
          a2 = 32;
          o2 = 3;
          n2 = new Uint8Array(68);
          const i3 = new DataView(n2.buffer);
          if (FeatureTest.isLittleEndian) {
            i3.setUint32(0, 255, true);
            i3.setUint32(4, 65280, true);
            i3.setUint32(8, 16711680, true);
            i3.setUint32(12, 4278190080, true);
          } else {
            i3.setUint32(0, 4278190080, true);
            i3.setUint32(4, 16711680, true);
            i3.setUint32(8, 65280, true);
            i3.setUint32(12, 255, true);
          }
          break;
        default:
          throw new Error("invalid format");
      }
      let g2 = 0;
      const c2 = 40 + n2.length, C2 = 14 + c2 + s2.length + r2.length, h2 = new Uint8Array(C2), l2 = new DataView(h2.buffer);
      l2.setUint16(g2, 19778, true);
      g2 += 2;
      l2.setUint32(g2, C2, true);
      g2 += 4;
      l2.setUint32(g2, 0, true);
      g2 += 4;
      l2.setUint32(g2, 14 + c2 + s2.length, true);
      g2 += 4;
      l2.setUint32(g2, c2, true);
      g2 += 4;
      l2.setInt32(g2, e2, true);
      g2 += 4;
      l2.setInt32(g2, -t2, true);
      g2 += 4;
      l2.setUint16(g2, 1, true);
      g2 += 2;
      l2.setUint16(g2, a2, true);
      g2 += 2;
      l2.setUint32(g2, o2, true);
      g2 += 4;
      l2.setUint32(g2, 0, true);
      g2 += 4;
      l2.setInt32(g2, 0, true);
      g2 += 4;
      l2.setInt32(g2, 0, true);
      g2 += 4;
      l2.setUint32(g2, s2.length / 4, true);
      g2 += 4;
      l2.setUint32(g2, 0, true);
      g2 += 4;
      h2.set(n2, g2);
      g2 += n2.length;
      h2.set(s2, g2);
      g2 += s2.length;
      h2.set(r2, g2);
      return h2;
    }
  };
  _k = new WeakMap();
  _R = new WeakMap();
  __privateAdd(_ImageResizer, _k, 2048);
  __privateAdd(_ImageResizer, _R, false);
  let ImageResizer = _ImageResizer;
  const Sr = 3285377520, kr = 4294901760, Rr = 65535;
  class MurmurHash3_64 {
    constructor(e2) {
      this.h1 = e2 ? 4294967295 & e2 : Sr;
      this.h2 = e2 ? 4294967295 & e2 : Sr;
    }
    update(e2) {
      let t2, i2;
      if ("string" == typeof e2) {
        t2 = new Uint8Array(2 * e2.length);
        i2 = 0;
        for (let a3 = 0, r3 = e2.length; a3 < r3; a3++) {
          const r4 = e2.charCodeAt(a3);
          if (r4 <= 255) t2[i2++] = r4;
          else {
            t2[i2++] = r4 >>> 8;
            t2[i2++] = 255 & r4;
          }
        }
      } else {
        if (!ArrayBuffer.isView(e2)) throw new Error("Invalid data format, must be a string or TypedArray.");
        t2 = e2.slice();
        i2 = t2.byteLength;
      }
      const a2 = i2 >> 2, r2 = i2 - 4 * a2, s2 = new Uint32Array(t2.buffer, 0, a2);
      let n2 = 0, o2 = 0, g2 = this.h1, c2 = this.h2;
      const C2 = 3432918353, h2 = 461845907, l2 = 11601, Q2 = 13715;
      for (let e3 = 0; e3 < a2; e3++) if (1 & e3) {
        n2 = s2[e3];
        n2 = n2 * C2 & kr | n2 * l2 & Rr;
        n2 = n2 << 15 | n2 >>> 17;
        n2 = n2 * h2 & kr | n2 * Q2 & Rr;
        g2 ^= n2;
        g2 = g2 << 13 | g2 >>> 19;
        g2 = 5 * g2 + 3864292196;
      } else {
        o2 = s2[e3];
        o2 = o2 * C2 & kr | o2 * l2 & Rr;
        o2 = o2 << 15 | o2 >>> 17;
        o2 = o2 * h2 & kr | o2 * Q2 & Rr;
        c2 ^= o2;
        c2 = c2 << 13 | c2 >>> 19;
        c2 = 5 * c2 + 3864292196;
      }
      n2 = 0;
      switch (r2) {
        case 3:
          n2 ^= t2[4 * a2 + 2] << 16;
        case 2:
          n2 ^= t2[4 * a2 + 1] << 8;
        case 1:
          n2 ^= t2[4 * a2];
          n2 = n2 * C2 & kr | n2 * l2 & Rr;
          n2 = n2 << 15 | n2 >>> 17;
          n2 = n2 * h2 & kr | n2 * Q2 & Rr;
          1 & a2 ? g2 ^= n2 : c2 ^= n2;
      }
      this.h1 = g2;
      this.h2 = c2;
    }
    hexdigest() {
      let e2 = this.h1, t2 = this.h2;
      e2 ^= t2 >>> 1;
      e2 = 3981806797 * e2 & kr | 36045 * e2 & Rr;
      t2 = 4283543511 * t2 & kr | (2950163797 * (t2 << 16 | e2 >>> 16) & kr) >>> 16;
      e2 ^= t2 >>> 1;
      e2 = 444984403 * e2 & kr | 60499 * e2 & Rr;
      t2 = 3301882366 * t2 & kr | (3120437893 * (t2 << 16 | e2 >>> 16) & kr) >>> 16;
      e2 ^= t2 >>> 1;
      return (e2 >>> 0).toString(16).padStart(8, "0") + (t2 >>> 0).toString(16).padStart(8, "0");
    }
  }
  function addState(e2, t2, i2, a2, r2) {
    let s2 = e2;
    for (let e3 = 0, i3 = t2.length - 1; e3 < i3; e3++) {
      const i4 = t2[e3];
      s2 = s2[i4] || (s2[i4] = []);
    }
    s2[t2.at(-1)] = {
      checkFn: i2,
      iterateFn: a2,
      processFn: r2
    };
  }
  const Nr = [];
  addState(Nr, [
    UA,
    LA,
    $e,
    MA
  ], null, function iterateInlineImageGroup(e2, t2) {
    const i2 = e2.fnArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
    switch (a2) {
      case 0:
        return i2[t2] === UA;
      case 1:
        return i2[t2] === LA;
      case 2:
        return i2[t2] === $e;
      case 3:
        return i2[t2] === MA;
    }
    throw new Error(`iterateInlineImageGroup - invalid pos: ${a2}`);
  }, function foundInlineImageGroup(e2, t2) {
    const i2 = e2.fnArray, a2 = e2.argsArray, r2 = e2.iCurr, s2 = r2 - 3, n2 = r2 - 2, o2 = r2 - 1, g2 = Math.min(Math.floor((t2 - s2) / 4), 200);
    if (g2 < 10) return t2 - (t2 - s2) % 4;
    let c2 = 0;
    const C2 = [];
    let h2 = 0, l2 = 1, Q2 = 1;
    for (let e3 = 0; e3 < g2; e3++) {
      const t3 = a2[n2 + (e3 << 2)], i3 = a2[o2 + (e3 << 2)][0];
      if (l2 + i3.width > 1e3) {
        c2 = Math.max(c2, l2);
        Q2 += h2 + 2;
        l2 = 0;
        h2 = 0;
      }
      C2.push({
        transform: t3,
        x: l2,
        y: Q2,
        w: i3.width,
        h: i3.height
      });
      l2 += i3.width + 2;
      h2 = Math.max(h2, i3.height);
    }
    const E2 = Math.max(c2, l2) + 1, u2 = Q2 + h2 + 1, d2 = new Uint8Array(E2 * u2 * 4), f2 = E2 << 2;
    for (let e3 = 0; e3 < g2; e3++) {
      const t3 = a2[o2 + (e3 << 2)][0].data, i3 = C2[e3].w << 2;
      let r3 = 0, s3 = C2[e3].x + C2[e3].y * E2 << 2;
      d2.set(t3.subarray(0, i3), s3 - f2);
      for (let a3 = 0, n3 = C2[e3].h; a3 < n3; a3++) {
        d2.set(t3.subarray(r3, r3 + i3), s3);
        r3 += i3;
        s3 += f2;
      }
      d2.set(t3.subarray(r3 - i3, r3), s3);
      for (; s3 >= 0; ) {
        t3[s3 - 4] = t3[s3];
        t3[s3 - 3] = t3[s3 + 1];
        t3[s3 - 2] = t3[s3 + 2];
        t3[s3 - 1] = t3[s3 + 3];
        t3[s3 + i3] = t3[s3 + i3 - 4];
        t3[s3 + i3 + 1] = t3[s3 + i3 - 3];
        t3[s3 + i3 + 2] = t3[s3 + i3 - 2];
        t3[s3 + i3 + 3] = t3[s3 + i3 - 1];
        s3 -= f2;
      }
    }
    const p2 = {
      width: E2,
      height: u2
    };
    if (e2.isOffscreenCanvasSupported) {
      const e3 = new OffscreenCanvas(E2, u2);
      e3.getContext("2d").putImageData(new ImageData(new Uint8ClampedArray(d2.buffer), E2, u2), 0, 0);
      p2.bitmap = e3.transferToImageBitmap();
      p2.data = null;
    } else {
      p2.kind = R;
      p2.data = d2;
    }
    i2.splice(s2, 4 * g2, At);
    a2.splice(s2, 4 * g2, [
      p2,
      C2
    ]);
    return s2 + 1;
  });
  addState(Nr, [
    UA,
    LA,
    Ve,
    MA
  ], null, function iterateImageMaskGroup(e2, t2) {
    const i2 = e2.fnArray, a2 = (t2 - (e2.iCurr - 3)) % 4;
    switch (a2) {
      case 0:
        return i2[t2] === UA;
      case 1:
        return i2[t2] === LA;
      case 2:
        return i2[t2] === Ve;
      case 3:
        return i2[t2] === MA;
    }
    throw new Error(`iterateImageMaskGroup - invalid pos: ${a2}`);
  }, function foundImageMaskGroup(e2, t2) {
    const i2 = e2.fnArray, a2 = e2.argsArray, r2 = e2.iCurr, s2 = r2 - 3, n2 = r2 - 2, o2 = r2 - 1;
    let g2 = Math.floor((t2 - s2) / 4);
    if (g2 < 10) return t2 - (t2 - s2) % 4;
    let c2, C2, h2 = false;
    const l2 = a2[o2][0], Q2 = a2[n2][0], E2 = a2[n2][1], u2 = a2[n2][2], d2 = a2[n2][3];
    if (E2 === u2) {
      h2 = true;
      c2 = n2 + 4;
      let e3 = o2 + 4;
      for (let t3 = 1; t3 < g2; t3++, c2 += 4, e3 += 4) {
        C2 = a2[c2];
        if (a2[e3][0] !== l2 || C2[0] !== Q2 || C2[1] !== E2 || C2[2] !== u2 || C2[3] !== d2) {
          t3 < 10 ? h2 = false : g2 = t3;
          break;
        }
      }
    }
    if (h2) {
      g2 = Math.min(g2, 1e3);
      const e3 = new Float32Array(2 * g2);
      c2 = n2;
      for (let t3 = 0; t3 < g2; t3++, c2 += 4) {
        C2 = a2[c2];
        e3[t3 << 1] = C2[4];
        e3[1 + (t3 << 1)] = C2[5];
      }
      i2.splice(s2, 4 * g2, tt);
      a2.splice(s2, 4 * g2, [
        l2,
        Q2,
        E2,
        u2,
        d2,
        e3
      ]);
    } else {
      g2 = Math.min(g2, 100);
      const e3 = [];
      for (let t3 = 0; t3 < g2; t3++) {
        C2 = a2[n2 + (t3 << 2)];
        const i3 = a2[o2 + (t3 << 2)][0];
        e3.push({
          data: i3.data,
          width: i3.width,
          height: i3.height,
          interpolate: i3.interpolate,
          count: i3.count,
          transform: C2
        });
      }
      i2.splice(s2, 4 * g2, _e);
      a2.splice(s2, 4 * g2, [
        e3
      ]);
    }
    return s2 + 1;
  });
  addState(Nr, [
    UA,
    LA,
    ze,
    MA
  ], function(e2) {
    const t2 = e2.argsArray, i2 = e2.iCurr - 2;
    return 0 === t2[i2][1] && 0 === t2[i2][2];
  }, function iterateImageGroup(e2, t2) {
    const i2 = e2.fnArray, a2 = e2.argsArray, r2 = (t2 - (e2.iCurr - 3)) % 4;
    switch (r2) {
      case 0:
        return i2[t2] === UA;
      case 1:
        if (i2[t2] !== LA) return false;
        const r3 = e2.iCurr - 2, s2 = a2[r3][0], n2 = a2[r3][3];
        return a2[t2][0] === s2 && 0 === a2[t2][1] && 0 === a2[t2][2] && a2[t2][3] === n2;
      case 2:
        if (i2[t2] !== ze) return false;
        const o2 = a2[e2.iCurr - 1][0];
        return a2[t2][0] === o2;
      case 3:
        return i2[t2] === MA;
    }
    throw new Error(`iterateImageGroup - invalid pos: ${r2}`);
  }, function(e2, t2) {
    const i2 = e2.fnArray, a2 = e2.argsArray, r2 = e2.iCurr, s2 = r2 - 3, n2 = r2 - 2, o2 = a2[r2 - 1][0], g2 = a2[n2][0], c2 = a2[n2][3], C2 = Math.min(Math.floor((t2 - s2) / 4), 1e3);
    if (C2 < 3) return t2 - (t2 - s2) % 4;
    const h2 = new Float32Array(2 * C2);
    let l2 = n2;
    for (let e3 = 0; e3 < C2; e3++, l2 += 4) {
      const t3 = a2[l2];
      h2[e3 << 1] = t3[4];
      h2[1 + (e3 << 1)] = t3[5];
    }
    const Q2 = [
      o2,
      g2,
      c2,
      h2
    ];
    i2.splice(s2, 4 * C2, et);
    a2.splice(s2, 4 * C2, Q2);
    return s2 + 1;
  });
  addState(Nr, [
    ee,
    ne,
    Ce,
    le,
    te
  ], null, function iterateShowTextGroup(e2, t2) {
    const i2 = e2.fnArray, a2 = e2.argsArray, r2 = (t2 - (e2.iCurr - 4)) % 5;
    switch (r2) {
      case 0:
        return i2[t2] === ee;
      case 1:
        return i2[t2] === ne;
      case 2:
        return i2[t2] === Ce;
      case 3:
        if (i2[t2] !== le) return false;
        const r3 = e2.iCurr - 3, s2 = a2[r3][0], n2 = a2[r3][1];
        return a2[t2][0] === s2 && a2[t2][1] === n2;
      case 4:
        return i2[t2] === te;
    }
    throw new Error(`iterateShowTextGroup - invalid pos: ${r2}`);
  }, function(e2, t2) {
    const i2 = e2.fnArray, a2 = e2.argsArray, r2 = e2.iCurr, s2 = r2 - 4, n2 = r2 - 3, o2 = r2 - 2, g2 = r2 - 1, c2 = r2, C2 = a2[n2][0], h2 = a2[n2][1];
    let l2 = Math.min(Math.floor((t2 - s2) / 5), 1e3);
    if (l2 < 3) return t2 - (t2 - s2) % 5;
    let Q2 = s2;
    if (s2 >= 4 && i2[s2 - 4] === i2[n2] && i2[s2 - 3] === i2[o2] && i2[s2 - 2] === i2[g2] && i2[s2 - 1] === i2[c2] && a2[s2 - 4][0] === C2 && a2[s2 - 4][1] === h2) {
      l2++;
      Q2 -= 5;
    }
    let E2 = Q2 + 4;
    for (let e3 = 1; e3 < l2; e3++) {
      i2.splice(E2, 3);
      a2.splice(E2, 3);
      E2 += 2;
    }
    return E2 + 1;
  });
  class NullOptimizer {
    constructor(e2) {
      this.queue = e2;
    }
    _optimize() {
    }
    push(e2, t2) {
      this.queue.fnArray.push(e2);
      this.queue.argsArray.push(t2);
      this._optimize();
    }
    flush() {
    }
    reset() {
    }
  }
  class QueueOptimizer extends NullOptimizer {
    constructor(e2) {
      super(e2);
      this.state = null;
      this.context = {
        iCurr: 0,
        fnArray: e2.fnArray,
        argsArray: e2.argsArray,
        isOffscreenCanvasSupported: false
      };
      this.match = null;
      this.lastProcessed = 0;
    }
    set isOffscreenCanvasSupported(e2) {
      this.context.isOffscreenCanvasSupported = e2;
    }
    _optimize() {
      const e2 = this.queue.fnArray;
      let t2 = this.lastProcessed, i2 = e2.length, a2 = this.state, r2 = this.match;
      if (!a2 && !r2 && t2 + 1 === i2 && !Nr[e2[t2]]) {
        this.lastProcessed = i2;
        return;
      }
      const s2 = this.context;
      for (; t2 < i2; ) {
        if (r2) {
          if ((0, r2.iterateFn)(s2, t2)) {
            t2++;
            continue;
          }
          t2 = (0, r2.processFn)(s2, t2 + 1);
          i2 = e2.length;
          r2 = null;
          a2 = null;
          if (t2 >= i2) break;
        }
        a2 = (a2 || Nr)[e2[t2]];
        if (a2 && !Array.isArray(a2)) {
          s2.iCurr = t2;
          t2++;
          if (!a2.checkFn || (0, a2.checkFn)(s2)) {
            r2 = a2;
            a2 = null;
          } else a2 = null;
        } else t2++;
      }
      this.state = a2;
      this.match = r2;
      this.lastProcessed = t2;
    }
    flush() {
      for (; this.match; ) {
        const e2 = this.queue.fnArray.length;
        this.lastProcessed = (0, this.match.processFn)(this.context, e2);
        this.match = null;
        this.state = null;
        this._optimize();
      }
    }
    reset() {
      this.state = null;
      this.match = null;
      this.lastProcessed = 0;
    }
  }
  const _OperatorList = class _OperatorList {
    constructor(e2 = 0, t2) {
      this._streamSink = t2;
      this.fnArray = [];
      this.argsArray = [];
      this.optimizer = !t2 || e2 & u ? new NullOptimizer(this) : new QueueOptimizer(this);
      this.dependencies = /* @__PURE__ */ new Set();
      this._totalLength = 0;
      this.weight = 0;
      this._resolved = t2 ? null : Promise.resolve();
    }
    set isOffscreenCanvasSupported(e2) {
      this.optimizer.isOffscreenCanvasSupported = e2;
    }
    get length() {
      return this.argsArray.length;
    }
    get ready() {
      return this._resolved || this._streamSink.ready;
    }
    get totalLength() {
      return this._totalLength + this.length;
    }
    addOp(e2, t2) {
      this.optimizer.push(e2, t2);
      this.weight++;
      this._streamSink && (this.weight >= _OperatorList.CHUNK_SIZE || this.weight >= _OperatorList.CHUNK_SIZE_ABOUT && (e2 === MA || e2 === te)) && this.flush();
    }
    addImageOps(e2, t2, i2) {
      void 0 !== i2 && this.addOp(Ye, [
        "OC",
        i2
      ]);
      this.addOp(e2, t2);
      void 0 !== i2 && this.addOp(Te, []);
    }
    addDependency(e2) {
      if (!this.dependencies.has(e2)) {
        this.dependencies.add(e2);
        this.addOp(bA, [
          e2
        ]);
      }
    }
    addDependencies(e2) {
      for (const t2 of e2) this.addDependency(t2);
    }
    addOpList(e2) {
      if (e2 instanceof _OperatorList) {
        for (const t2 of e2.dependencies) this.dependencies.add(t2);
        for (let t2 = 0, i2 = e2.length; t2 < i2; t2++) this.addOp(e2.fnArray[t2], e2.argsArray[t2]);
      } else warn('addOpList - ignoring invalid "opList" parameter.');
    }
    getIR() {
      return {
        fnArray: this.fnArray,
        argsArray: this.argsArray,
        length: this.length
      };
    }
    get _transfers() {
      var _a4;
      const e2 = [], { fnArray: t2, argsArray: i2, length: a2 } = this;
      for (let r2 = 0; r2 < a2; r2++) switch (t2[r2]) {
        case $e:
        case At:
        case Ve:
          const t3 = i2[r2][0];
          !t3.cached && ((_a4 = t3.data) == null ? void 0 : _a4.buffer) instanceof ArrayBuffer && e2.push(t3.data.buffer);
      }
      return e2;
    }
    flush(e2 = false, t2 = null) {
      this.optimizer.flush();
      const i2 = this.length;
      this._totalLength += i2;
      this._streamSink.enqueue({
        fnArray: this.fnArray,
        argsArray: this.argsArray,
        lastChunk: e2,
        separateAnnots: t2,
        length: i2
      }, 1, this._transfers);
      this.dependencies.clear();
      this.fnArray.length = 0;
      this.argsArray.length = 0;
      this.weight = 0;
      this.optimizer.reset();
    }
  };
  __publicField(_OperatorList, "CHUNK_SIZE", 1e3);
  __publicField(_OperatorList, "CHUNK_SIZE_ABOUT", _OperatorList.CHUNK_SIZE - 5);
  let OperatorList = _OperatorList;
  function decodeAndClamp(e2, t2, i2, a2) {
    (e2 = t2 + e2 * i2) < 0 ? e2 = 0 : e2 > a2 && (e2 = a2);
    return e2;
  }
  function resizeImageMask(e2, t2, i2, a2, r2, s2) {
    const n2 = r2 * s2;
    let o2;
    o2 = t2 <= 8 ? new Uint8Array(n2) : t2 <= 16 ? new Uint16Array(n2) : new Uint32Array(n2);
    const g2 = i2 / r2, c2 = a2 / s2;
    let C2, h2, l2, Q2, E2 = 0;
    const u2 = new Uint16Array(r2), d2 = i2;
    for (C2 = 0; C2 < r2; C2++) u2[C2] = Math.floor(C2 * g2);
    for (C2 = 0; C2 < s2; C2++) {
      l2 = Math.floor(C2 * c2) * d2;
      for (h2 = 0; h2 < r2; h2++) {
        Q2 = l2 + u2[h2];
        o2[E2++] = e2[Q2];
      }
    }
    return o2;
  }
  const _PDFImage = class _PDFImage {
    constructor({ xref: e2, res: t2, image: i2, isInline: a2 = false, smask: r2 = null, mask: s2 = null, isMask: n2 = false, pdfFunctionFactory: o2, localColorSpaceCache: g2 }) {
      __privateAdd(this, _PDFImage_instances);
      var _a4, _b;
      this.image = i2;
      const c2 = i2.dict, C2 = c2.get("F", "Filter");
      let h2;
      if (C2 instanceof Name) h2 = C2.name;
      else if (Array.isArray(C2)) {
        const t3 = e2.fetchIfRef(C2[0]);
        t3 instanceof Name && (h2 = t3.name);
      }
      switch (h2) {
        case "JPXDecode":
          ({ width: i2.width, height: i2.height, componentsCount: i2.numComps, bitsPerComponent: i2.bitsPerComponent } = JpxImage.parseImageProperties(i2.stream));
          i2.stream.reset();
          this.jpxDecoderOptions = {
            numComponents: 0,
            isIndexedColormap: false,
            smaskInData: c2.has("SMaskInData")
          };
          break;
        case "JBIG2Decode":
          i2.bitsPerComponent = 1;
          i2.numComps = 1;
      }
      let l2 = c2.get("W", "Width"), Q2 = c2.get("H", "Height");
      if (Number.isInteger(i2.width) && i2.width > 0 && Number.isInteger(i2.height) && i2.height > 0 && (i2.width !== l2 || i2.height !== Q2)) {
        warn("PDFImage - using the Width/Height of the image data, rather than the image dictionary.");
        l2 = i2.width;
        Q2 = i2.height;
      }
      if (l2 < 1 || Q2 < 1) throw new FormatError(`Invalid image width: ${l2} or height: ${Q2}`);
      this.width = l2;
      this.height = Q2;
      this.interpolate = c2.get("I", "Interpolate");
      this.imageMask = c2.get("IM", "ImageMask") || false;
      this.matte = c2.get("Matte") || false;
      let E2 = i2.bitsPerComponent;
      if (!E2) {
        E2 = c2.get("BPC", "BitsPerComponent");
        if (!E2) {
          if (!this.imageMask) throw new FormatError(`Bits per component missing in image: ${this.imageMask}`);
          E2 = 1;
        }
      }
      this.bpc = E2;
      if (!this.imageMask) {
        let r3 = c2.getRaw("CS") || c2.getRaw("ColorSpace");
        const s3 = !!r3;
        if (s3) ((_a4 = this.jpxDecoderOptions) == null ? void 0 : _a4.smaskInData) && (r3 = Name.get("DeviceRGBA"));
        else if (this.jpxDecoderOptions) r3 = Name.get("DeviceRGBA");
        else switch (i2.numComps) {
          case 1:
            r3 = Name.get("DeviceGray");
            break;
          case 3:
            r3 = Name.get("DeviceRGB");
            break;
          case 4:
            r3 = Name.get("DeviceCMYK");
            break;
          default:
            throw new Error(`Images with ${i2.numComps} color components not supported.`);
        }
        this.colorSpace = ColorSpace.parse({
          cs: r3,
          xref: e2,
          resources: a2 ? t2 : null,
          pdfFunctionFactory: o2,
          localColorSpaceCache: g2
        });
        this.numComps = this.colorSpace.numComps;
        if (this.jpxDecoderOptions) {
          this.jpxDecoderOptions.numComponents = s3 ? this.numComp : 0;
          this.jpxDecoderOptions.isIndexedColormap = "Indexed" === this.colorSpace.name;
        }
      }
      this.decode = c2.getArray("D", "Decode");
      this.needsDecode = false;
      if (this.decode && (this.colorSpace && !this.colorSpace.isDefaultDecode(this.decode, E2) || n2 && !ColorSpace.isDefaultDecode(this.decode, 1))) {
        this.needsDecode = true;
        const e3 = (1 << E2) - 1;
        this.decodeCoefficients = [];
        this.decodeAddends = [];
        const t3 = "Indexed" === ((_b = this.colorSpace) == null ? void 0 : _b.name);
        for (let i3 = 0, a3 = 0; i3 < this.decode.length; i3 += 2, ++a3) {
          const r3 = this.decode[i3], s3 = this.decode[i3 + 1];
          this.decodeCoefficients[a3] = t3 ? (s3 - r3) / e3 : s3 - r3;
          this.decodeAddends[a3] = t3 ? r3 : e3 * r3;
        }
      }
      if (r2) this.smask = new _PDFImage({
        xref: e2,
        res: t2,
        image: r2,
        isInline: a2,
        pdfFunctionFactory: o2,
        localColorSpaceCache: g2
      });
      else if (s2) if (s2 instanceof BaseStream) {
        s2.dict.get("IM", "ImageMask") ? this.mask = new _PDFImage({
          xref: e2,
          res: t2,
          image: s2,
          isInline: a2,
          isMask: true,
          pdfFunctionFactory: o2,
          localColorSpaceCache: g2
        }) : warn("Ignoring /Mask in image without /ImageMask.");
      } else this.mask = s2;
    }
    static async buildImage({ xref: e2, res: t2, image: i2, isInline: a2 = false, pdfFunctionFactory: r2, localColorSpaceCache: s2 }) {
      const n2 = i2;
      let o2 = null, g2 = null;
      const c2 = i2.dict.get("SMask"), C2 = i2.dict.get("Mask");
      c2 ? c2 instanceof BaseStream ? o2 = c2 : warn("Unsupported /SMask format.") : C2 && (C2 instanceof BaseStream || Array.isArray(C2) ? g2 = C2 : warn("Unsupported /Mask format."));
      return new _PDFImage({
        xref: e2,
        res: t2,
        image: n2,
        isInline: a2,
        smask: o2,
        mask: g2,
        pdfFunctionFactory: r2,
        localColorSpaceCache: s2
      });
    }
    static createRawMask({ imgArray: e2, width: t2, height: i2, imageIsFromDecodeStream: a2, inverseDecode: r2, interpolate: s2 }) {
      const n2 = (t2 + 7 >> 3) * i2, o2 = e2.byteLength;
      let g2, c2;
      if (!a2 || r2 && !(n2 === o2)) if (r2) {
        g2 = new Uint8Array(n2);
        g2.set(e2);
        g2.fill(255, o2);
      } else g2 = new Uint8Array(e2);
      else g2 = e2;
      if (r2) for (c2 = 0; c2 < o2; c2++) g2[c2] ^= 255;
      return {
        data: g2,
        width: t2,
        height: i2,
        interpolate: s2
      };
    }
    static async createMask({ imgArray: e2, width: t2, height: i2, imageIsFromDecodeStream: a2, inverseDecode: r2, interpolate: s2, isOffscreenCanvasSupported: n2 = false }) {
      const o2 = 1 === t2 && 1 === i2 && r2 === (0 === e2.length || !!(128 & e2[0]));
      if (o2) return {
        isSingleOpaquePixel: o2
      };
      if (n2) {
        if (ImageResizer.needsToBeResized(t2, i2)) {
          const a4 = new Uint8ClampedArray(t2 * i2 * 4);
          convertBlackAndWhiteToRGBA({
            src: e2,
            dest: a4,
            width: t2,
            height: i2,
            nonBlackColor: 0,
            inverseDecode: r2
          });
          return ImageResizer.createImage({
            kind: R,
            data: a4,
            width: t2,
            height: i2,
            interpolate: s2
          });
        }
        const a3 = new OffscreenCanvas(t2, i2), n3 = a3.getContext("2d"), o3 = n3.createImageData(t2, i2);
        convertBlackAndWhiteToRGBA({
          src: e2,
          dest: o3.data,
          width: t2,
          height: i2,
          nonBlackColor: 0,
          inverseDecode: r2
        });
        n3.putImageData(o3, 0, 0);
        return {
          data: null,
          width: t2,
          height: i2,
          interpolate: s2,
          bitmap: a3.transferToImageBitmap()
        };
      }
      return this.createRawMask({
        imgArray: e2,
        width: t2,
        height: i2,
        inverseDecode: r2,
        imageIsFromDecodeStream: a2,
        interpolate: s2
      });
    }
    get drawWidth() {
      var _a4, _b;
      return Math.max(this.width, ((_a4 = this.smask) == null ? void 0 : _a4.width) || 0, ((_b = this.mask) == null ? void 0 : _b.width) || 0);
    }
    get drawHeight() {
      var _a4, _b;
      return Math.max(this.height, ((_a4 = this.smask) == null ? void 0 : _a4.height) || 0, ((_b = this.mask) == null ? void 0 : _b.height) || 0);
    }
    decodeBuffer(e2) {
      const t2 = this.bpc, i2 = this.numComps, a2 = this.decodeAddends, r2 = this.decodeCoefficients, s2 = (1 << t2) - 1;
      let n2, o2;
      if (1 === t2) {
        for (n2 = 0, o2 = e2.length; n2 < o2; n2++) e2[n2] = +!e2[n2];
        return;
      }
      let g2 = 0;
      for (n2 = 0, o2 = this.width * this.height; n2 < o2; n2++) for (let t3 = 0; t3 < i2; t3++) {
        e2[g2] = decodeAndClamp(e2[g2], a2[t3], r2[t3], s2);
        g2++;
      }
    }
    getComponents(e2) {
      const t2 = this.bpc;
      if (8 === t2) return e2;
      const i2 = this.width, a2 = this.height, r2 = this.numComps, s2 = i2 * a2 * r2;
      let n2, o2 = 0;
      n2 = t2 <= 8 ? new Uint8Array(s2) : t2 <= 16 ? new Uint16Array(s2) : new Uint32Array(s2);
      const g2 = i2 * r2, c2 = (1 << t2) - 1;
      let C2, h2, l2 = 0;
      if (1 === t2) {
        let t3, i3, r3;
        for (let s3 = 0; s3 < a2; s3++) {
          i3 = l2 + (-8 & g2);
          r3 = l2 + g2;
          for (; l2 < i3; ) {
            h2 = e2[o2++];
            n2[l2] = h2 >> 7 & 1;
            n2[l2 + 1] = h2 >> 6 & 1;
            n2[l2 + 2] = h2 >> 5 & 1;
            n2[l2 + 3] = h2 >> 4 & 1;
            n2[l2 + 4] = h2 >> 3 & 1;
            n2[l2 + 5] = h2 >> 2 & 1;
            n2[l2 + 6] = h2 >> 1 & 1;
            n2[l2 + 7] = 1 & h2;
            l2 += 8;
          }
          if (l2 < r3) {
            h2 = e2[o2++];
            t3 = 128;
            for (; l2 < r3; ) {
              n2[l2++] = +!!(h2 & t3);
              t3 >>= 1;
            }
          }
        }
      } else {
        let i3 = 0;
        h2 = 0;
        for (l2 = 0, C2 = s2; l2 < C2; ++l2) {
          if (l2 % g2 == 0) {
            h2 = 0;
            i3 = 0;
          }
          for (; i3 < t2; ) {
            h2 = h2 << 8 | e2[o2++];
            i3 += 8;
          }
          const a3 = i3 - t2;
          let r3 = h2 >> a3;
          r3 < 0 ? r3 = 0 : r3 > c2 && (r3 = c2);
          n2[l2] = r3;
          h2 &= (1 << a3) - 1;
          i3 = a3;
        }
      }
      return n2;
    }
    async fillOpacity(e2, t2, i2, a2, r2) {
      const s2 = this.smask, n2 = this.mask;
      let o2, g2, c2, C2, h2, l2;
      if (s2) {
        g2 = s2.width;
        c2 = s2.height;
        o2 = new Uint8ClampedArray(g2 * c2);
        await s2.fillGrayBuffer(o2);
        g2 === t2 && c2 === i2 || (o2 = resizeImageMask(o2, s2.bpc, g2, c2, t2, i2));
      } else if (n2) if (n2 instanceof _PDFImage) {
        g2 = n2.width;
        c2 = n2.height;
        o2 = new Uint8ClampedArray(g2 * c2);
        n2.numComps = 1;
        await n2.fillGrayBuffer(o2);
        for (C2 = 0, h2 = g2 * c2; C2 < h2; ++C2) o2[C2] = 255 - o2[C2];
        g2 === t2 && c2 === i2 || (o2 = resizeImageMask(o2, n2.bpc, g2, c2, t2, i2));
      } else {
        if (!Array.isArray(n2)) throw new FormatError("Unknown mask format.");
        {
          o2 = new Uint8ClampedArray(t2 * i2);
          const e3 = this.numComps;
          for (C2 = 0, h2 = t2 * i2; C2 < h2; ++C2) {
            let t3 = 0;
            const i3 = C2 * e3;
            for (l2 = 0; l2 < e3; ++l2) {
              const e4 = r2[i3 + l2], a3 = 2 * l2;
              if (e4 < n2[a3] || e4 > n2[a3 + 1]) {
                t3 = 255;
                break;
              }
            }
            o2[C2] = t3;
          }
        }
      }
      if (o2) for (C2 = 0, l2 = 3, h2 = t2 * a2; C2 < h2; ++C2, l2 += 4) e2[l2] = o2[C2];
      else for (C2 = 0, l2 = 3, h2 = t2 * a2; C2 < h2; ++C2, l2 += 4) e2[l2] = 255;
    }
    undoPreblend(e2, t2, i2) {
      var _a4;
      const a2 = (_a4 = this.smask) == null ? void 0 : _a4.matte;
      if (!a2) return;
      const r2 = this.colorSpace.getRgb(a2, 0), s2 = r2[0], n2 = r2[1], o2 = r2[2], g2 = t2 * i2 * 4;
      for (let t3 = 0; t3 < g2; t3 += 4) {
        const i3 = e2[t3 + 3];
        if (0 === i3) {
          e2[t3] = 255;
          e2[t3 + 1] = 255;
          e2[t3 + 2] = 255;
          continue;
        }
        const a3 = 255 / i3;
        e2[t3] = (e2[t3] - s2) * a3 + s2;
        e2[t3 + 1] = (e2[t3 + 1] - n2) * a3 + n2;
        e2[t3 + 2] = (e2[t3 + 2] - o2) * a3 + o2;
      }
    }
    async createImageData(e2 = false, t2 = false) {
      const i2 = this.drawWidth, a2 = this.drawHeight, r2 = {
        width: i2,
        height: a2,
        interpolate: this.interpolate,
        kind: 0,
        data: null
      }, s2 = this.numComps, n2 = this.width, o2 = this.height, g2 = this.bpc, c2 = n2 * s2 * g2 + 7 >> 3, C2 = t2 && ImageResizer.needsToBeResized(i2, a2);
      if (!this.smask && !this.mask && "DeviceRGBA" === this.colorSpace.name) {
        r2.kind = R;
        const e3 = r2.data = await this.getImageBytes(o2 * n2 * 4, {});
        return t2 ? C2 ? ImageResizer.createImage(r2, false) : this.createBitmap(R, i2, a2, e3) : r2;
      }
      if (!e2) {
        let e3;
        "DeviceGray" === this.colorSpace.name && 1 === g2 ? e3 = S : "DeviceRGB" !== this.colorSpace.name || 8 !== g2 || this.needsDecode || (e3 = k);
        if (e3 && !this.smask && !this.mask && i2 === n2 && a2 === o2) {
          const s3 = await __privateMethod(this, _PDFImage_instances, N_fn).call(this, n2, o2);
          if (s3) return s3;
          const g3 = await this.getImageBytes(o2 * c2, {});
          if (t2) return C2 ? ImageResizer.createImage({
            data: g3,
            kind: e3,
            width: i2,
            height: a2,
            interpolate: this.interpolate
          }, this.needsDecode) : this.createBitmap(e3, n2, o2, g3);
          r2.kind = e3;
          r2.data = g3;
          if (this.needsDecode) {
            assert(e3 === S, "PDFImage.createImageData: The image must be grayscale.");
            const t3 = r2.data;
            for (let e4 = 0, i3 = t3.length; e4 < i3; e4++) t3[e4] ^= 255;
          }
          return r2;
        }
        if (this.image instanceof JpegStream && !this.smask && !this.mask && !this.needsDecode) {
          let e4 = o2 * c2;
          if (t2 && !C2) {
            let t3 = false;
            switch (this.colorSpace.name) {
              case "DeviceGray":
                e4 *= 4;
                t3 = true;
                break;
              case "DeviceRGB":
                e4 = e4 / 3 * 4;
                t3 = true;
                break;
              case "DeviceCMYK":
                t3 = true;
            }
            if (t3) {
              const t4 = await __privateMethod(this, _PDFImage_instances, N_fn).call(this, i2, a2);
              if (t4) return t4;
              const r3 = await this.getImageBytes(e4, {
                drawWidth: i2,
                drawHeight: a2,
                forceRGBA: true
              });
              return this.createBitmap(R, i2, a2, r3);
            }
          } else switch (this.colorSpace.name) {
            case "DeviceGray":
              e4 *= 3;
            case "DeviceRGB":
            case "DeviceCMYK":
              r2.kind = k;
              r2.data = await this.getImageBytes(e4, {
                drawWidth: i2,
                drawHeight: a2,
                forceRGB: true
              });
              return C2 ? ImageResizer.createImage(r2) : r2;
          }
        }
      }
      const h2 = await this.getImageBytes(o2 * c2, {
        internal: true
      }), l2 = 0 | h2.length / c2 * a2 / o2, Q2 = this.getComponents(h2);
      let E2, u2, d2, f2, p2, m2;
      if (t2 && !C2) {
        d2 = new OffscreenCanvas(i2, a2);
        f2 = d2.getContext("2d");
        p2 = f2.createImageData(i2, a2);
        m2 = p2.data;
      }
      r2.kind = R;
      if (e2 || this.smask || this.mask) {
        t2 && !C2 || (m2 = new Uint8ClampedArray(i2 * a2 * 4));
        E2 = 1;
        u2 = true;
        await this.fillOpacity(m2, i2, a2, l2, Q2);
      } else {
        if (!t2 || C2) {
          r2.kind = k;
          m2 = new Uint8ClampedArray(i2 * a2 * 3);
          E2 = 0;
        } else {
          new Uint32Array(m2.buffer).fill(FeatureTest.isLittleEndian ? 4278190080 : 255);
          E2 = 1;
        }
        u2 = false;
      }
      this.needsDecode && this.decodeBuffer(Q2);
      this.colorSpace.fillRgb(m2, n2, o2, i2, a2, l2, g2, Q2, E2);
      u2 && this.undoPreblend(m2, i2, l2);
      if (t2 && !C2) {
        f2.putImageData(p2, 0, 0);
        return {
          data: null,
          width: i2,
          height: a2,
          bitmap: d2.transferToImageBitmap(),
          interpolate: this.interpolate
        };
      }
      r2.data = m2;
      return C2 ? ImageResizer.createImage(r2) : r2;
    }
    async fillGrayBuffer(e2) {
      const t2 = this.numComps;
      if (1 !== t2) throw new FormatError(`Reading gray scale from a color image: ${t2}`);
      const i2 = this.width, a2 = this.height, r2 = this.bpc, s2 = i2 * t2 * r2 + 7 >> 3, n2 = await this.getImageBytes(a2 * s2, {
        internal: true
      }), o2 = this.getComponents(n2);
      let g2, c2;
      if (1 === r2) {
        c2 = i2 * a2;
        if (this.needsDecode) for (g2 = 0; g2 < c2; ++g2) e2[g2] = o2[g2] - 1 & 255;
        else for (g2 = 0; g2 < c2; ++g2) e2[g2] = 255 & -o2[g2];
        return;
      }
      this.needsDecode && this.decodeBuffer(o2);
      c2 = i2 * a2;
      const C2 = 255 / ((1 << r2) - 1);
      for (g2 = 0; g2 < c2; ++g2) e2[g2] = C2 * o2[g2];
    }
    createBitmap(e2, t2, i2, a2) {
      const r2 = new OffscreenCanvas(t2, i2), s2 = r2.getContext("2d");
      let n2;
      if (e2 === R) n2 = new ImageData(a2, t2, i2);
      else {
        n2 = s2.createImageData(t2, i2);
        convertToRGBA({
          kind: e2,
          src: a2,
          dest: new Uint32Array(n2.data.buffer),
          width: t2,
          height: i2,
          inverseDecode: this.needsDecode
        });
      }
      s2.putImageData(n2, 0, 0);
      return {
        data: null,
        width: t2,
        height: i2,
        bitmap: r2.transferToImageBitmap(),
        interpolate: this.interpolate
      };
    }
    async getImageBytes(e2, { drawWidth: t2, drawHeight: i2, forceRGBA: a2 = false, forceRGB: r2 = false, internal: s2 = false }) {
      this.image.reset();
      this.image.drawWidth = t2 || this.width;
      this.image.drawHeight = i2 || this.height;
      this.image.forceRGBA = !!a2;
      this.image.forceRGB = !!r2;
      const n2 = await this.image.getImageData(e2, this.jpxDecoderOptions);
      if (s2 || this.image instanceof DecodeStream) return n2;
      assert(n2 instanceof Uint8Array, 'PDFImage.getImageBytes: Unsupported "imageBytes" type.');
      return new Uint8Array(n2);
    }
  };
  _PDFImage_instances = new WeakSet();
  N_fn = async function(e2, t2) {
    const i2 = await this.image.getTransferableImage();
    return i2 ? {
      data: null,
      width: e2,
      height: t2,
      bitmap: i2,
      interpolate: this.interpolate
    } : null;
  };
  let PDFImage = _PDFImage;
  const Gr = Object.freeze({
    maxImageSize: -1,
    disableFontFace: false,
    ignoreErrors: false,
    isEvalSupported: true,
    isOffscreenCanvasSupported: false,
    isChrome: false,
    canvasMaxAreaInBytes: -1,
    fontExtraProperties: false,
    useSystemFonts: true,
    cMapUrl: null,
    standardFontDataUrl: null
  }), xr = 1, Ur = 2, Mr = Promise.resolve();
  function normalizeBlendMode(e2, t2 = false) {
    if (Array.isArray(e2)) {
      for (const t3 of e2) {
        const e3 = normalizeBlendMode(t3, true);
        if (e3) return e3;
      }
      warn(`Unsupported blend mode Array: ${e2}`);
      return "source-over";
    }
    if (!(e2 instanceof Name)) return t2 ? null : "source-over";
    switch (e2.name) {
      case "Normal":
      case "Compatible":
        return "source-over";
      case "Multiply":
        return "multiply";
      case "Screen":
        return "screen";
      case "Overlay":
        return "overlay";
      case "Darken":
        return "darken";
      case "Lighten":
        return "lighten";
      case "ColorDodge":
        return "color-dodge";
      case "ColorBurn":
        return "color-burn";
      case "HardLight":
        return "hard-light";
      case "SoftLight":
        return "soft-light";
      case "Difference":
        return "difference";
      case "Exclusion":
        return "exclusion";
      case "Hue":
        return "hue";
      case "Saturation":
        return "saturation";
      case "Color":
        return "color";
      case "Luminosity":
        return "luminosity";
    }
    if (t2) return null;
    warn(`Unsupported blend mode: ${e2.name}`);
    return "source-over";
  }
  function addLocallyCachedImageOps(e2, t2) {
    var _a4;
    t2.objId && e2.addDependency(t2.objId);
    e2.addImageOps(t2.fn, t2.args, t2.optionalContent);
    t2.fn === Ve && ((_a4 = t2.args[0]) == null ? void 0 : _a4.count) > 0 && t2.args[0].count++;
  }
  const _TimeSlotManager = class _TimeSlotManager {
    constructor() {
      this.reset();
    }
    check() {
      if (++this.checked < _TimeSlotManager.CHECK_TIME_EVERY) return false;
      this.checked = 0;
      return this.endTime <= Date.now();
    }
    reset() {
      this.endTime = Date.now() + _TimeSlotManager.TIME_SLOT_DURATION_MS;
      this.checked = 0;
    }
  };
  __publicField(_TimeSlotManager, "TIME_SLOT_DURATION_MS", 20);
  __publicField(_TimeSlotManager, "CHECK_TIME_EVERY", 100);
  let TimeSlotManager = _TimeSlotManager;
  class PartialEvaluator {
    constructor({ xref: e2, handler: t2, pageIndex: i2, idFactory: a2, fontCache: r2, builtInCMapCache: s2, standardFontDataCache: n2, globalImageCache: o2, systemFontCache: g2, options: c2 = null }) {
      this.xref = e2;
      this.handler = t2;
      this.pageIndex = i2;
      this.idFactory = a2;
      this.fontCache = r2;
      this.builtInCMapCache = s2;
      this.standardFontDataCache = n2;
      this.globalImageCache = o2;
      this.systemFontCache = g2;
      this.options = c2 || Gr;
      this.type3FontRefs = null;
      this._regionalImageCache = new RegionalImageCache();
      this._fetchBuiltInCMapBound = this.fetchBuiltInCMap.bind(this);
      ImageResizer.setOptions({
        isChrome: this.options.isChrome,
        maxArea: this.options.canvasMaxAreaInBytes
      });
    }
    get _pdfFunctionFactory() {
      return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({
        xref: this.xref,
        isEvalSupported: this.options.isEvalSupported
      }));
    }
    get parsingType3Font() {
      return !!this.type3FontRefs;
    }
    clone(e2 = null) {
      const t2 = Object.create(this);
      t2.options = Object.assign(/* @__PURE__ */ Object.create(null), this.options, e2);
      return t2;
    }
    hasBlendModes(e2, t2) {
      if (!(e2 instanceof Dict)) return false;
      if (e2.objId && t2.has(e2.objId)) return false;
      const i2 = new RefSet(t2);
      e2.objId && i2.put(e2.objId);
      const a2 = [
        e2
      ], r2 = this.xref;
      for (; a2.length; ) {
        const e3 = a2.shift(), t3 = e3.get("ExtGState");
        if (t3 instanceof Dict) for (let e4 of t3.getRawValues()) {
          if (e4 instanceof Ref) {
            if (i2.has(e4)) continue;
            try {
              e4 = r2.fetch(e4);
            } catch (t5) {
              i2.put(e4);
              info(`hasBlendModes - ignoring ExtGState: "${t5}".`);
              continue;
            }
          }
          if (!(e4 instanceof Dict)) continue;
          e4.objId && i2.put(e4.objId);
          const t4 = e4.get("BM");
          if (t4 instanceof Name) {
            if ("Normal" !== t4.name) return true;
          } else if (void 0 !== t4 && Array.isArray(t4)) {
            for (const e5 of t4) if (e5 instanceof Name && "Normal" !== e5.name) return true;
          }
        }
        const s2 = e3.get("XObject");
        if (s2 instanceof Dict) for (let e4 of s2.getRawValues()) {
          if (e4 instanceof Ref) {
            if (i2.has(e4)) continue;
            try {
              e4 = r2.fetch(e4);
            } catch (t5) {
              i2.put(e4);
              info(`hasBlendModes - ignoring XObject: "${t5}".`);
              continue;
            }
          }
          if (!(e4 instanceof BaseStream)) continue;
          e4.dict.objId && i2.put(e4.dict.objId);
          const t4 = e4.dict.get("Resources");
          if (t4 instanceof Dict && (!t4.objId || !i2.has(t4.objId))) {
            a2.push(t4);
            t4.objId && i2.put(t4.objId);
          }
        }
      }
      for (const e3 of i2) t2.put(e3);
      return false;
    }
    async fetchBuiltInCMap(e2) {
      const t2 = this.builtInCMapCache.get(e2);
      if (t2) return t2;
      let i2;
      if (null !== this.options.cMapUrl) {
        const t3 = `${this.options.cMapUrl}${e2}.bcmap`, a2 = await fetch(t3);
        if (!a2.ok) throw new Error(`fetchBuiltInCMap: failed to fetch file "${t3}" with "${a2.statusText}".`);
        i2 = {
          cMapData: new Uint8Array(await a2.arrayBuffer()),
          isCompressed: true
        };
      } else i2 = await this.handler.sendWithPromise("FetchBuiltInCMap", {
        name: e2
      });
      this.builtInCMapCache.set(e2, i2);
      return i2;
    }
    async fetchStandardFontData(e2) {
      const t2 = this.standardFontDataCache.get(e2);
      if (t2) return new Stream(t2);
      if (this.options.useSystemFonts && "Symbol" !== e2 && "ZapfDingbats" !== e2) return null;
      const i2 = _i()[e2];
      let a2;
      if (null !== this.options.standardFontDataUrl) {
        const e3 = `${this.options.standardFontDataUrl}${i2}`, t3 = await fetch(e3);
        t3.ok ? a2 = new Uint8Array(await t3.arrayBuffer()) : warn(`fetchStandardFontData: failed to fetch file "${e3}" with "${t3.statusText}".`);
      } else try {
        a2 = await this.handler.sendWithPromise("FetchStandardFontData", {
          filename: i2
        });
      } catch (e3) {
        warn(`fetchStandardFontData: failed to fetch file "${i2}" with "${e3}".`);
      }
      if (!a2) return null;
      this.standardFontDataCache.set(e2, a2);
      return new Stream(a2);
    }
    async buildFormXObject(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = t2.dict, g2 = lookupMatrix(o2.getArray("Matrix"), null), c2 = lookupNormalRect(o2.getArray("BBox"), null);
      let C2, h2;
      o2.has("OC") && (C2 = await this.parseMarkedContentProps(o2.get("OC"), e2));
      void 0 !== C2 && a2.addOp(Ye, [
        "OC",
        C2
      ]);
      const l2 = o2.get("Group");
      if (l2) {
        h2 = {
          matrix: g2,
          bbox: c2,
          smask: i2,
          isolated: false,
          knockout: false
        };
        let t3 = null;
        if (isName(l2.get("S"), "Transparency")) {
          h2.isolated = l2.get("I") || false;
          h2.knockout = l2.get("K") || false;
          if (l2.has("CS")) {
            const i3 = l2.getRaw("CS"), a3 = ColorSpace.getCached(i3, this.xref, n2);
            t3 = a3 || await this.parseColorSpace({
              cs: i3,
              resources: e2,
              localColorSpaceCache: n2
            });
          }
        }
        if (i2 == null ? void 0 : i2.backdrop) {
          t3 || (t3 = ColorSpace.singletons.rgb);
          i2.backdrop = t3.getRgb(i2.backdrop, 0);
        }
        a2.addOp(We, [
          h2
        ]);
      }
      const Q2 = l2 ? [
        g2,
        null
      ] : [
        g2,
        c2
      ];
      a2.addOp(Oe, Q2);
      await this.getOperatorList({
        stream: t2,
        task: r2,
        resources: o2.get("Resources") || e2,
        operatorList: a2,
        initialState: s2
      });
      a2.addOp(Pe, []);
      l2 && a2.addOp(je, [
        h2
      ]);
      void 0 !== C2 && a2.addOp(Te, []);
    }
    _sendImgData(e2, t2, i2 = false) {
      const a2 = t2 ? [
        t2.bitmap || t2.data.buffer
      ] : null;
      return this.parsingType3Font || i2 ? this.handler.send("commonobj", [
        e2,
        "Image",
        t2
      ], a2) : this.handler.send("obj", [
        e2,
        this.pageIndex,
        "Image",
        t2
      ], a2);
    }
    async buildPaintImageXObject({ resources: e2, image: t2, isInline: i2 = false, operatorList: a2, cacheKey: r2, localImageCache: s2, localColorSpaceCache: n2 }) {
      const o2 = t2.dict, g2 = o2.objId, c2 = o2.get("W", "Width"), C2 = o2.get("H", "Height");
      if (!c2 || "number" != typeof c2 || !C2 || "number" != typeof C2) {
        warn("Image dimensions are missing, or not numbers.");
        return;
      }
      const h2 = this.options.maxImageSize;
      if (-1 !== h2 && c2 * C2 > h2) {
        const e3 = "Image exceeded maximum allowed size and was removed.";
        if (this.options.ignoreErrors) {
          warn(e3);
          return;
        }
        throw new Error(e3);
      }
      let l2;
      o2.has("OC") && (l2 = await this.parseMarkedContentProps(o2.get("OC"), e2));
      let Q2, E2;
      if (o2.get("IM", "ImageMask") || false) {
        const e3 = o2.get("I", "Interpolate"), i3 = c2 + 7 >> 3, n3 = t2.getBytes(i3 * C2), h3 = o2.getArray("D", "Decode");
        if (this.parsingType3Font) {
          Q2 = PDFImage.createRawMask({
            imgArray: n3,
            width: c2,
            height: C2,
            imageIsFromDecodeStream: t2 instanceof DecodeStream,
            inverseDecode: (h3 == null ? void 0 : h3[0]) > 0,
            interpolate: e3
          });
          Q2.cached = !!r2;
          E2 = [
            Q2
          ];
          a2.addImageOps(Ve, E2, l2);
          if (r2) {
            const e4 = {
              fn: Ve,
              args: E2,
              optionalContent: l2
            };
            s2.set(r2, g2, e4);
            g2 && this._regionalImageCache.set(null, g2, e4);
          }
          return;
        }
        Q2 = await PDFImage.createMask({
          imgArray: n3,
          width: c2,
          height: C2,
          imageIsFromDecodeStream: t2 instanceof DecodeStream,
          inverseDecode: (h3 == null ? void 0 : h3[0]) > 0,
          interpolate: e3,
          isOffscreenCanvasSupported: this.options.isOffscreenCanvasSupported
        });
        if (Q2.isSingleOpaquePixel) {
          a2.addImageOps(it, [], l2);
          if (r2) {
            const e4 = {
              fn: it,
              args: [],
              optionalContent: l2
            };
            s2.set(r2, g2, e4);
            g2 && this._regionalImageCache.set(null, g2, e4);
          }
          return;
        }
        const u3 = `mask_${this.idFactory.createObjId()}`;
        a2.addDependency(u3);
        Q2.dataLen = Q2.bitmap ? Q2.width * Q2.height * 4 : Q2.data.length;
        this._sendImgData(u3, Q2);
        E2 = [
          {
            data: u3,
            width: Q2.width,
            height: Q2.height,
            interpolate: Q2.interpolate,
            count: 1
          }
        ];
        a2.addImageOps(Ve, E2, l2);
        if (r2) {
          const e4 = {
            objId: u3,
            fn: Ve,
            args: E2,
            optionalContent: l2
          };
          s2.set(r2, g2, e4);
          g2 && this._regionalImageCache.set(null, g2, e4);
        }
        return;
      }
      if (i2 && c2 + C2 < 200 && !o2.has("SMask") && !o2.has("Mask")) {
        try {
          const r3 = new PDFImage({
            xref: this.xref,
            res: e2,
            image: t2,
            isInline: i2,
            pdfFunctionFactory: this._pdfFunctionFactory,
            localColorSpaceCache: n2
          });
          Q2 = await r3.createImageData(true, false);
          a2.isOffscreenCanvasSupported = this.options.isOffscreenCanvasSupported;
          a2.addImageOps($e, [
            Q2
          ], l2);
        } catch (e3) {
          const t3 = `Unable to decode inline image: "${e3}".`;
          if (!this.options.ignoreErrors) throw new Error(t3);
          warn(t3);
        }
        return;
      }
      let u2 = `img_${this.idFactory.createObjId()}`, d2 = false;
      if (this.parsingType3Font) u2 = `${this.idFactory.getDocId()}_type3_${u2}`;
      else if (r2 && g2) {
        d2 = this.globalImageCache.shouldCache(g2, this.pageIndex);
        if (d2) {
          assert(!i2, "Cannot cache an inline image globally.");
          u2 = `${this.idFactory.getDocId()}_${u2}`;
        }
      }
      a2.addDependency(u2);
      E2 = [
        u2,
        c2,
        C2
      ];
      a2.addImageOps(ze, E2, l2);
      if (d2) {
        if (this.globalImageCache.hasDecodeFailed(g2)) {
          this.globalImageCache.setData(g2, {
            objId: u2,
            fn: ze,
            args: E2,
            optionalContent: l2,
            byteSize: 0
          });
          this._sendImgData(u2, null, d2);
          return;
        }
        if (c2 * C2 > 25e4 || o2.has("SMask") || o2.has("Mask")) {
          const e3 = await this.handler.sendWithPromise("commonobj", [
            u2,
            "CopyLocalImage",
            {
              imageRef: g2
            }
          ]);
          if (e3) {
            this.globalImageCache.setData(g2, {
              objId: u2,
              fn: ze,
              args: E2,
              optionalContent: l2,
              byteSize: 0
            });
            this.globalImageCache.addByteSize(g2, e3);
            return;
          }
        }
      }
      PDFImage.buildImage({
        xref: this.xref,
        res: e2,
        image: t2,
        isInline: i2,
        pdfFunctionFactory: this._pdfFunctionFactory,
        localColorSpaceCache: n2
      }).then(async (e3) => {
        Q2 = await e3.createImageData(false, this.options.isOffscreenCanvasSupported);
        Q2.dataLen = Q2.bitmap ? Q2.width * Q2.height * 4 : Q2.data.length;
        Q2.ref = g2;
        d2 && this.globalImageCache.addByteSize(g2, Q2.dataLen);
        return this._sendImgData(u2, Q2, d2);
      }).catch((e3) => {
        warn(`Unable to decode image "${u2}": "${e3}".`);
        g2 && this.globalImageCache.addDecodeFailed(g2);
        return this._sendImgData(u2, null, d2);
      });
      if (r2) {
        const e3 = {
          objId: u2,
          fn: ze,
          args: E2,
          optionalContent: l2
        };
        s2.set(r2, g2, e3);
        if (g2) {
          this._regionalImageCache.set(null, g2, e3);
          d2 && this.globalImageCache.setData(g2, {
            objId: u2,
            fn: ze,
            args: E2,
            optionalContent: l2,
            byteSize: 0
          });
        }
      }
    }
    handleSMask(e2, t2, i2, a2, r2, s2) {
      const n2 = e2.get("G"), o2 = {
        subtype: e2.get("S").name,
        backdrop: e2.get("BC")
      }, g2 = e2.get("TR");
      if (isPDFFunction(g2)) {
        const e3 = this._pdfFunctionFactory.create(g2), t3 = new Uint8Array(256), i3 = new Float32Array(1);
        for (let a3 = 0; a3 < 256; a3++) {
          i3[0] = a3 / 255;
          e3(i3, 0, i3, 0);
          t3[a3] = 255 * i3[0] | 0;
        }
        o2.transferMap = t3;
      }
      return this.buildFormXObject(t2, n2, o2, i2, a2, r2.state.clone(), s2);
    }
    handleTransferFunction(e2) {
      let t2;
      if (Array.isArray(e2)) t2 = e2;
      else {
        if (!isPDFFunction(e2)) return null;
        t2 = [
          e2
        ];
      }
      const i2 = [];
      let a2 = 0, r2 = 0;
      for (const e3 of t2) {
        const t3 = this.xref.fetchIfRef(e3);
        a2++;
        if (isName(t3, "Identity")) {
          i2.push(null);
          continue;
        }
        if (!isPDFFunction(t3)) return null;
        const s2 = this._pdfFunctionFactory.create(t3), n2 = new Uint8Array(256), o2 = new Float32Array(1);
        for (let e4 = 0; e4 < 256; e4++) {
          o2[0] = e4 / 255;
          s2(o2, 0, o2, 0);
          n2[e4] = 255 * o2[0] | 0;
        }
        i2.push(n2);
        r2++;
      }
      return 1 !== a2 && 4 !== a2 || 0 === r2 ? null : i2;
    }
    handleTilingType(e2, t2, i2, a2, r2, s2, n2, o2) {
      const g2 = new OperatorList(), c2 = Dict.merge({
        xref: this.xref,
        dictArray: [
          r2.get("Resources"),
          i2
        ]
      });
      return this.getOperatorList({
        stream: a2,
        task: n2,
        resources: c2,
        operatorList: g2
      }).then(function() {
        const i3 = g2.getIR(), a3 = getTilingPatternIR(i3, r2, t2);
        s2.addDependencies(g2.dependencies);
        s2.addOp(e2, a3);
        r2.objId && o2.set(null, r2.objId, {
          operatorListIR: i3,
          dict: r2
        });
      }).catch((e3) => {
        if (!(e3 instanceof AbortException)) {
          if (!this.options.ignoreErrors) throw e3;
          warn(`handleTilingType - ignoring pattern: "${e3}".`);
        }
      });
    }
    async handleSetFont(e2, t2, i2, a2, r2, s2, n2 = null, o2 = null) {
      const g2 = (t2 == null ? void 0 : t2[0]) instanceof Name ? t2[0].name : null;
      let c2 = await this.loadFont(g2, i2, e2, n2, o2);
      if (c2.font.isType3Font) try {
        await c2.loadType3Data(this, e2, r2);
        a2.addDependencies(c2.type3Dependencies);
      } catch (e3) {
        c2 = new TranslatedFont({
          loadedName: "g_font_error",
          font: new ErrorFont(`Type3 font load error: ${e3}`),
          dict: c2.font,
          evaluatorOptions: this.options
        });
      }
      s2.font = c2.font;
      c2.send(this.handler);
      return c2.loadedName;
    }
    handleText(e2, t2) {
      const i2 = t2.font, a2 = i2.charsToGlyphs(e2);
      if (i2.data) {
        (!!(t2.textRenderingMode & D) || "Pattern" === t2.fillColorSpace.name || i2.disableFontFace || this.options.disableFontFace) && PartialEvaluator.buildFontPaths(i2, a2, this.handler, this.options);
      }
      return a2;
    }
    ensureStateFont(e2) {
      if (e2.font) return;
      const t2 = new FormatError("Missing setFont (Tf) operator before text rendering operator.");
      if (!this.options.ignoreErrors) throw t2;
      warn(`ensureStateFont: "${t2}".`);
    }
    async setGState({ resources: e2, gState: t2, operatorList: i2, cacheKey: a2, task: r2, stateManager: s2, localGStateCache: n2, localColorSpaceCache: o2 }) {
      const g2 = t2.objId;
      let c2 = true;
      const C2 = [];
      let h2 = Promise.resolve();
      for (const a3 of t2.getKeys()) {
        const n3 = t2.get(a3);
        switch (a3) {
          case "Type":
            break;
          case "LW":
          case "LC":
          case "LJ":
          case "ML":
          case "D":
          case "RI":
          case "FL":
          case "CA":
          case "ca":
            C2.push([
              a3,
              n3
            ]);
            break;
          case "Font":
            c2 = false;
            h2 = h2.then(() => this.handleSetFont(e2, null, n3[0], i2, r2, s2.state).then(function(e3) {
              i2.addDependency(e3);
              C2.push([
                a3,
                [
                  e3,
                  n3[1]
                ]
              ]);
            }));
            break;
          case "BM":
            C2.push([
              a3,
              normalizeBlendMode(n3)
            ]);
            break;
          case "SMask":
            if (isName(n3, "None")) {
              C2.push([
                a3,
                false
              ]);
              break;
            }
            if (n3 instanceof Dict) {
              c2 = false;
              h2 = h2.then(() => this.handleSMask(n3, e2, i2, r2, s2, o2));
              C2.push([
                a3,
                true
              ]);
            } else warn("Unsupported SMask type");
            break;
          case "TR":
            const t3 = this.handleTransferFunction(n3);
            C2.push([
              a3,
              t3
            ]);
            break;
          case "OP":
          case "op":
          case "OPM":
          case "BG":
          case "BG2":
          case "UCR":
          case "UCR2":
          case "TR2":
          case "HT":
          case "SM":
          case "SA":
          case "AIS":
          case "TK":
            info("graphic state operator " + a3);
            break;
          default:
            info("Unknown graphic state operator " + a3);
        }
      }
      await h2;
      C2.length > 0 && i2.addOp(xA, [
        C2
      ]);
      c2 && n2.set(a2, g2, C2);
    }
    loadFont(e2, t2, i2, a2 = null, r2 = null) {
      var _a4;
      const errorFont = async () => new TranslatedFont({
        loadedName: "g_font_error",
        font: new ErrorFont(`Font "${e2}" is not available.`),
        dict: t2,
        evaluatorOptions: this.options
      });
      let s2;
      if (t2) t2 instanceof Ref && (s2 = t2);
      else {
        const t3 = i2.get("Font");
        t3 && (s2 = t3.getRaw(e2));
      }
      if (s2) {
        if ((_a4 = this.type3FontRefs) == null ? void 0 : _a4.has(s2)) return errorFont();
        if (this.fontCache.has(s2)) return this.fontCache.get(s2);
        try {
          t2 = this.xref.fetchIfRef(s2);
        } catch (e3) {
          warn(`loadFont - lookup failed: "${e3}".`);
        }
      }
      if (!(t2 instanceof Dict)) {
        if (!this.options.ignoreErrors && !this.parsingType3Font) {
          warn(`Font "${e2}" is not available.`);
          return errorFont();
        }
        warn(`Font "${e2}" is not available -- attempting to fallback to a default font.`);
        t2 = a2 || PartialEvaluator.fallbackFontDict;
      }
      if (t2.cacheKey && this.fontCache.has(t2.cacheKey)) return this.fontCache.get(t2.cacheKey);
      const { promise: n2, resolve: o2 } = Promise.withResolvers();
      let g2;
      try {
        g2 = this.preEvaluateFont(t2);
        g2.cssFontInfo = r2;
      } catch (e3) {
        warn(`loadFont - preEvaluateFont failed: "${e3}".`);
        return errorFont();
      }
      const { descriptor: c2, hash: C2 } = g2, h2 = s2 instanceof Ref;
      let l2;
      if (C2 && c2 instanceof Dict) {
        const e3 = c2.fontAliases || (c2.fontAliases = /* @__PURE__ */ Object.create(null));
        if (e3[C2]) {
          const t3 = e3[C2].aliasRef;
          if (h2 && t3 && this.fontCache.has(t3)) {
            this.fontCache.putAlias(s2, t3);
            return this.fontCache.get(s2);
          }
        } else e3[C2] = {
          fontID: this.idFactory.createFontId()
        };
        h2 && (e3[C2].aliasRef = s2);
        l2 = e3[C2].fontID;
      } else l2 = this.idFactory.createFontId();
      assert(l2 == null ? void 0 : l2.startsWith("f"), 'The "fontID" must be (correctly) defined.');
      if (h2) this.fontCache.put(s2, n2);
      else {
        t2.cacheKey = `cacheKey_${l2}`;
        this.fontCache.put(t2.cacheKey, n2);
      }
      t2.loadedName = `${this.idFactory.getDocId()}_${l2}`;
      this.translateFont(g2).then((e3) => {
        o2(new TranslatedFont({
          loadedName: t2.loadedName,
          font: e3,
          dict: t2,
          evaluatorOptions: this.options
        }));
      }).catch((e3) => {
        warn(`loadFont - translateFont failed: "${e3}".`);
        o2(new TranslatedFont({
          loadedName: t2.loadedName,
          font: new ErrorFont(e3 instanceof Error ? e3.message : e3),
          dict: t2,
          evaluatorOptions: this.options
        }));
      });
      return n2;
    }
    buildPath(e2, t2, i2, a2 = false) {
      const r2 = e2.length - 1;
      i2 || (i2 = []);
      if (r2 < 0 || e2.fnArray[r2] !== at) {
        if (a2) {
          warn(`Encountered path operator "${t2}" inside of a text object.`);
          e2.addOp(UA, null);
        }
        let r3;
        switch (t2) {
          case qA:
            const e3 = i2[0] + i2[2], t3 = i2[1] + i2[3];
            r3 = [
              Math.min(i2[0], e3),
              Math.min(i2[1], t3),
              Math.max(i2[0], e3),
              Math.max(i2[1], t3)
            ];
            break;
          case HA:
          case JA:
            r3 = [
              i2[0],
              i2[1],
              i2[0],
              i2[1]
            ];
            break;
          default:
            r3 = [
              1 / 0,
              1 / 0,
              -1 / 0,
              -1 / 0
            ];
        }
        e2.addOp(at, [
          [
            t2
          ],
          i2,
          r3
        ]);
        a2 && e2.addOp(MA, null);
      } else {
        const a3 = e2.argsArray[r2];
        a3[0].push(t2);
        a3[1].push(...i2);
        const s2 = a3[2];
        switch (t2) {
          case qA:
            const e3 = i2[0] + i2[2], t3 = i2[1] + i2[3];
            s2[0] = Math.min(s2[0], i2[0], e3);
            s2[1] = Math.min(s2[1], i2[1], t3);
            s2[2] = Math.max(s2[2], i2[0], e3);
            s2[3] = Math.max(s2[3], i2[1], t3);
            break;
          case HA:
          case JA:
            s2[0] = Math.min(s2[0], i2[0]);
            s2[1] = Math.min(s2[1], i2[1]);
            s2[2] = Math.max(s2[2], i2[0]);
            s2[3] = Math.max(s2[3], i2[1]);
        }
      }
    }
    parseColorSpace({ cs: e2, resources: t2, localColorSpaceCache: i2 }) {
      return ColorSpace.parseAsync({
        cs: e2,
        xref: this.xref,
        resources: t2,
        pdfFunctionFactory: this._pdfFunctionFactory,
        localColorSpaceCache: i2
      }).catch((e3) => {
        if (e3 instanceof AbortException) return null;
        if (this.options.ignoreErrors) {
          warn(`parseColorSpace - ignoring ColorSpace: "${e3}".`);
          return null;
        }
        throw e3;
      });
    }
    parseShading({ shading: e2, resources: t2, localColorSpaceCache: i2, localShadingPatternCache: a2 }) {
      let r2, s2 = a2.get(e2);
      if (s2) return s2;
      try {
        r2 = Pattern.parseShading(e2, this.xref, t2, this._pdfFunctionFactory, i2).getIR();
      } catch (t3) {
        if (t3 instanceof AbortException) return null;
        if (this.options.ignoreErrors) {
          warn(`parseShading - ignoring shading: "${t3}".`);
          a2.set(e2, null);
          return null;
        }
        throw t3;
      }
      s2 = `pattern_${this.idFactory.createObjId()}`;
      this.parsingType3Font && (s2 = `${this.idFactory.getDocId()}_type3_${s2}`);
      a2.set(e2, s2);
      this.parsingType3Font ? this.handler.send("commonobj", [
        s2,
        "Pattern",
        r2
      ]) : this.handler.send("obj", [
        s2,
        this.pageIndex,
        "Pattern",
        r2
      ]);
      return s2;
    }
    handleColorN(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2) {
      const C2 = i2.pop();
      if (C2 instanceof Name) {
        const h2 = r2.getRaw(C2.name), l2 = h2 instanceof Ref && g2.getByRef(h2);
        if (l2) try {
          const r3 = a2.base ? a2.base.getRgb(i2, 0) : null, s3 = getTilingPatternIR(l2.operatorListIR, l2.dict, r3);
          e2.addOp(t2, s3);
          return;
        } catch {
        }
        const Q2 = this.xref.fetchIfRef(h2);
        if (Q2) {
          const r3 = Q2 instanceof BaseStream ? Q2.dict : Q2, C3 = r3.get("PatternType");
          if (C3 === xr) {
            const o3 = a2.base ? a2.base.getRgb(i2, 0) : null;
            return this.handleTilingType(t2, o3, s2, Q2, r3, e2, n2, g2);
          }
          if (C3 === Ur) {
            const i3 = r3.get("Shading"), a3 = this.parseShading({
              shading: i3,
              resources: s2,
              localColorSpaceCache: o2,
              localShadingPatternCache: c2
            });
            if (a3) {
              const i4 = lookupMatrix(r3.getArray("Matrix"), null);
              e2.addOp(t2, [
                "Shading",
                a3,
                i4
              ]);
            }
            return;
          }
          throw new FormatError(`Unknown PatternType: ${C3}`);
        }
      }
      throw new FormatError(`Unknown PatternName: ${C2}`);
    }
    _parseVisibilityExpression(e2, t2, i2) {
      if (++t2 > 10) {
        warn("Visibility expression is too deeply nested");
        return;
      }
      const a2 = e2.length, r2 = this.xref.fetchIfRef(e2[0]);
      if (!(a2 < 2) && r2 instanceof Name) {
        switch (r2.name) {
          case "And":
          case "Or":
          case "Not":
            i2.push(r2.name);
            break;
          default:
            warn(`Invalid operator ${r2.name} in visibility expression`);
            return;
        }
        for (let r3 = 1; r3 < a2; r3++) {
          const a3 = e2[r3], s2 = this.xref.fetchIfRef(a3);
          if (Array.isArray(s2)) {
            const e3 = [];
            i2.push(e3);
            this._parseVisibilityExpression(s2, t2, e3);
          } else a3 instanceof Ref && i2.push(a3.toString());
        }
      } else warn("Invalid visibility expression");
    }
    async parseMarkedContentProps(e2, t2) {
      var _a4;
      let i2;
      if (e2 instanceof Name) {
        i2 = t2.get("Properties").get(e2.name);
      } else {
        if (!(e2 instanceof Dict)) throw new FormatError("Optional content properties malformed.");
        i2 = e2;
      }
      const a2 = (_a4 = i2.get("Type")) == null ? void 0 : _a4.name;
      if ("OCG" === a2) return {
        type: a2,
        id: i2.objId
      };
      if ("OCMD" === a2) {
        const e3 = i2.get("VE");
        if (Array.isArray(e3)) {
          const t4 = [];
          this._parseVisibilityExpression(e3, 0, t4);
          if (t4.length > 0) return {
            type: "OCMD",
            expression: t4
          };
        }
        const t3 = i2.get("OCGs");
        if (Array.isArray(t3) || t3 instanceof Dict) {
          const e4 = [];
          if (Array.isArray(t3)) for (const i3 of t3) e4.push(i3.toString());
          else e4.push(t3.objId);
          return {
            type: a2,
            ids: e4,
            policy: i2.get("P") instanceof Name ? i2.get("P").name : null,
            expression: null
          };
        }
        if (t3 instanceof Ref) return {
          type: a2,
          id: t3.toString()
        };
      }
      return null;
    }
    getOperatorList({ stream: e2, task: t2, resources: i2, operatorList: a2, initialState: r2 = null, fallbackFontDict: s2 = null }) {
      i2 || (i2 = Dict.empty);
      r2 || (r2 = new EvalState());
      if (!a2) throw new Error('getOperatorList: missing "operatorList" parameter');
      const n2 = this, o2 = this.xref;
      let g2 = false;
      const c2 = new LocalImageCache(), C2 = new LocalColorSpaceCache(), h2 = new LocalGStateCache(), l2 = new LocalTilingPatternCache(), Q2 = /* @__PURE__ */ new Map(), E2 = i2.get("XObject") || Dict.empty, u2 = i2.get("Pattern") || Dict.empty, d2 = new StateManager(r2), f2 = new EvaluatorPreprocessor(e2, o2, d2), p2 = new TimeSlotManager();
      function closePendingRestoreOPS(e3) {
        for (let e4 = 0, t3 = f2.savedStatesDepth; e4 < t3; e4++) a2.addOp(MA, []);
      }
      return new Promise(function promiseBody(e3, r3) {
        const next = function(t3) {
          Promise.all([
            t3,
            a2.ready
          ]).then(function() {
            try {
              promiseBody(e3, r3);
            } catch (e4) {
              r3(e4);
            }
          }, r3);
        };
        t2.ensureNotTerminated();
        p2.reset();
        const m2 = {};
        let y2, w2, b2, D2, S2, k2;
        for (; !(y2 = p2.check()); ) {
          m2.args = null;
          if (!f2.read(m2)) break;
          let e4 = m2.args, r4 = m2.fn;
          switch (0 | r4) {
            case Le:
              k2 = e4[0] instanceof Name;
              S2 = e4[0].name;
              if (k2) {
                const t3 = c2.getByName(S2);
                if (t3) {
                  addLocallyCachedImageOps(a2, t3);
                  e4 = null;
                  continue;
                }
              }
              next(new Promise(function(e5, r5) {
                if (!k2) throw new FormatError("XObject must be referred to by name.");
                let s3 = E2.getRaw(S2);
                if (s3 instanceof Ref) {
                  const t3 = c2.getByRef(s3) || n2._regionalImageCache.getByRef(s3);
                  if (t3) {
                    addLocallyCachedImageOps(a2, t3);
                    e5();
                    return;
                  }
                  const i3 = n2.globalImageCache.getData(s3, n2.pageIndex);
                  if (i3) {
                    a2.addDependency(i3.objId);
                    a2.addImageOps(i3.fn, i3.args, i3.optionalContent);
                    e5();
                    return;
                  }
                  s3 = o2.fetch(s3);
                }
                if (!(s3 instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                const g3 = s3.dict.get("Subtype");
                if (!(g3 instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                if ("Form" !== g3.name) if ("Image" !== g3.name) {
                  if ("PS" !== g3.name) throw new FormatError(`Unhandled XObject subtype ${g3.name}`);
                  info("Ignored XObject subtype PS");
                  e5();
                } else n2.buildPaintImageXObject({
                  resources: i2,
                  image: s3,
                  operatorList: a2,
                  cacheKey: S2,
                  localImageCache: c2,
                  localColorSpaceCache: C2
                }).then(e5, r5);
                else {
                  d2.save();
                  n2.buildFormXObject(i2, s3, null, a2, t2, d2.state.clone(), C2).then(function() {
                    d2.restore();
                    e5();
                  }, r5);
                }
              }).catch(function(e5) {
                if (!(e5 instanceof AbortException)) {
                  if (!n2.options.ignoreErrors) throw e5;
                  warn(`getOperatorList - ignoring XObject: "${e5}".`);
                }
              }));
              return;
            case ne:
              var R2 = e4[1];
              next(n2.handleSetFont(i2, e4, null, a2, t2, d2.state, s2).then(function(e5) {
                a2.addDependency(e5);
                a2.addOp(ne, [
                  e5,
                  R2
                ]);
              }));
              return;
            case ee:
              g2 = true;
              break;
            case te:
              g2 = false;
              break;
            case Me:
              var N2 = e4[0].cacheKey;
              if (N2) {
                const t3 = c2.getByName(N2);
                if (t3) {
                  addLocallyCachedImageOps(a2, t3);
                  e4 = null;
                  continue;
                }
              }
              next(n2.buildPaintImageXObject({
                resources: i2,
                image: e4[0],
                isInline: true,
                operatorList: a2,
                cacheKey: N2,
                localImageCache: c2,
                localColorSpaceCache: C2
              }));
              return;
            case le:
              if (!d2.state.font) {
                n2.ensureStateFont(d2.state);
                continue;
              }
              e4[0] = n2.handleText(e4[0], d2.state);
              break;
            case Be:
              if (!d2.state.font) {
                n2.ensureStateFont(d2.state);
                continue;
              }
              var G2 = [], x2 = d2.state;
              for (const t3 of e4[0]) "string" == typeof t3 ? G2.push(...n2.handleText(t3, x2)) : "number" == typeof t3 && G2.push(t3);
              e4[0] = G2;
              r4 = le;
              break;
            case Qe:
              if (!d2.state.font) {
                n2.ensureStateFont(d2.state);
                continue;
              }
              a2.addOp(he);
              e4[0] = n2.handleText(e4[0], d2.state);
              r4 = le;
              break;
            case Ee:
              if (!d2.state.font) {
                n2.ensureStateFont(d2.state);
                continue;
              }
              a2.addOp(he);
              a2.addOp(ae, [
                e4.shift()
              ]);
              a2.addOp(ie, [
                e4.shift()
              ]);
              e4[0] = n2.handleText(e4[0], d2.state);
              r4 = le;
              break;
            case oe:
              d2.state.textRenderingMode = e4[0];
              break;
            case pe: {
              const t3 = ColorSpace.getCached(e4[0], o2, C2);
              if (t3) {
                d2.state.fillColorSpace = t3;
                continue;
              }
              next(n2.parseColorSpace({
                cs: e4[0],
                resources: i2,
                localColorSpaceCache: C2
              }).then(function(e5) {
                d2.state.fillColorSpace = e5 || ColorSpace.singletons.gray;
              }));
              return;
            }
            case fe: {
              const t3 = ColorSpace.getCached(e4[0], o2, C2);
              if (t3) {
                d2.state.strokeColorSpace = t3;
                continue;
              }
              next(n2.parseColorSpace({
                cs: e4[0],
                resources: i2,
                localColorSpaceCache: C2
              }).then(function(e5) {
                d2.state.strokeColorSpace = e5 || ColorSpace.singletons.gray;
              }));
              return;
            }
            case we:
              D2 = d2.state.fillColorSpace;
              e4 = D2.getRgb(e4, 0);
              r4 = ke;
              break;
            case me:
              D2 = d2.state.strokeColorSpace;
              e4 = D2.getRgb(e4, 0);
              r4 = Se;
              break;
            case Fe:
              d2.state.fillColorSpace = ColorSpace.singletons.gray;
              e4 = ColorSpace.singletons.gray.getRgb(e4, 0);
              r4 = ke;
              break;
            case De:
              d2.state.strokeColorSpace = ColorSpace.singletons.gray;
              e4 = ColorSpace.singletons.gray.getRgb(e4, 0);
              r4 = Se;
              break;
            case Ne:
              d2.state.fillColorSpace = ColorSpace.singletons.cmyk;
              e4 = ColorSpace.singletons.cmyk.getRgb(e4, 0);
              r4 = ke;
              break;
            case Re:
              d2.state.strokeColorSpace = ColorSpace.singletons.cmyk;
              e4 = ColorSpace.singletons.cmyk.getRgb(e4, 0);
              r4 = Se;
              break;
            case ke:
              d2.state.fillColorSpace = ColorSpace.singletons.rgb;
              e4 = ColorSpace.singletons.rgb.getRgb(e4, 0);
              break;
            case Se:
              d2.state.strokeColorSpace = ColorSpace.singletons.rgb;
              e4 = ColorSpace.singletons.rgb.getRgb(e4, 0);
              break;
            case be:
              D2 = d2.state.patternFillColorSpace;
              if (!D2) {
                if (isNumberArray(e4, null)) {
                  e4 = ColorSpace.singletons.gray.getRgb(e4, 0);
                  r4 = ke;
                  break;
                }
                e4 = [];
                r4 = st;
                break;
              }
              if ("Pattern" === D2.name) {
                next(n2.handleColorN(a2, be, e4, D2, u2, i2, t2, C2, l2, Q2));
                return;
              }
              e4 = D2.getRgb(e4, 0);
              r4 = ke;
              break;
            case ye:
              D2 = d2.state.patternStrokeColorSpace;
              if (!D2) {
                if (isNumberArray(e4, null)) {
                  e4 = ColorSpace.singletons.gray.getRgb(e4, 0);
                  r4 = Se;
                  break;
                }
                e4 = [];
                r4 = rt;
                break;
              }
              if ("Pattern" === D2.name) {
                next(n2.handleColorN(a2, ye, e4, D2, u2, i2, t2, C2, l2, Q2));
                return;
              }
              e4 = D2.getRgb(e4, 0);
              r4 = Se;
              break;
            case Ge:
              let f3;
              try {
                const t3 = i2.get("Shading");
                if (!t3) throw new FormatError("No shading resource found");
                f3 = t3.get(e4[0].name);
                if (!f3) throw new FormatError("No shading object found");
              } catch (e5) {
                if (e5 instanceof AbortException) continue;
                if (n2.options.ignoreErrors) {
                  warn(`getOperatorList - ignoring Shading: "${e5}".`);
                  continue;
                }
                throw e5;
              }
              const p3 = n2.parseShading({
                shading: f3,
                resources: i2,
                localColorSpaceCache: C2,
                localShadingPatternCache: Q2
              });
              if (!p3) continue;
              e4 = [
                p3
              ];
              r4 = Ge;
              break;
            case xA:
              k2 = e4[0] instanceof Name;
              S2 = e4[0].name;
              if (k2) {
                const t3 = h2.getByName(S2);
                if (t3) {
                  t3.length > 0 && a2.addOp(xA, [
                    t3
                  ]);
                  e4 = null;
                  continue;
                }
              }
              next(new Promise(function(e5, r5) {
                if (!k2) throw new FormatError("GState must be referred to by name.");
                const s3 = i2.get("ExtGState");
                if (!(s3 instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                const o3 = s3.get(S2);
                if (!(o3 instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                n2.setGState({
                  resources: i2,
                  gState: o3,
                  operatorList: a2,
                  cacheKey: S2,
                  task: t2,
                  stateManager: d2,
                  localGStateCache: h2,
                  localColorSpaceCache: C2
                }).then(e5, r5);
              }).catch(function(e5) {
                if (!(e5 instanceof AbortException)) {
                  if (!n2.options.ignoreErrors) throw e5;
                  warn(`getOperatorList - ignoring ExtGState: "${e5}".`);
                }
              }));
              return;
            case HA:
            case JA:
            case vA:
            case YA:
            case TA:
            case KA:
            case qA:
              n2.buildPath(a2, r4, e4, g2);
              continue;
            case He:
            case Je:
            case Ke:
            case qe:
              continue;
            case Ye:
              if (!(e4[0] instanceof Name)) {
                warn(`Expected name for beginMarkedContentProps arg0=${e4[0]}`);
                a2.addOp(Ye, [
                  "OC",
                  null
                ]);
                continue;
              }
              if ("OC" === e4[0].name) {
                next(n2.parseMarkedContentProps(e4[1], i2).then((e5) => {
                  a2.addOp(Ye, [
                    "OC",
                    e5
                  ]);
                }).catch((e5) => {
                  if (!(e5 instanceof AbortException)) {
                    if (!n2.options.ignoreErrors) throw e5;
                    warn(`getOperatorList - ignoring beginMarkedContentProps: "${e5}".`);
                    a2.addOp(Ye, [
                      "OC",
                      null
                    ]);
                  }
                }));
                return;
              }
              e4 = [
                e4[0].name,
                e4[1] instanceof Dict ? e4[1].get("MCID") : null
              ];
              break;
            default:
              if (null !== e4) {
                for (w2 = 0, b2 = e4.length; w2 < b2 && !(e4[w2] instanceof Dict); w2++) ;
                if (w2 < b2) {
                  warn("getOperatorList - ignoring operator: " + r4);
                  continue;
                }
              }
          }
          a2.addOp(r4, e4);
        }
        if (y2) next(Mr);
        else {
          closePendingRestoreOPS();
          e3();
        }
      }).catch((e3) => {
        if (!(e3 instanceof AbortException)) {
          if (!this.options.ignoreErrors) throw e3;
          warn(`getOperatorList - ignoring errors during "${t2.name}" task: "${e3}".`);
          closePendingRestoreOPS();
        }
      });
    }
    getTextContent({ stream: e2, task: t2, resources: i2, stateManager: s2 = null, includeMarkedContent: n2 = false, sink: o2, seenStyles: g2 = /* @__PURE__ */ new Set(), viewBox: c2, lang: C2 = null, markedContentData: h2 = null, disableNormalization: l2 = false, keepWhiteSpace: Q2 = false }) {
      i2 || (i2 = Dict.empty);
      s2 || (s2 = new StateManager(new TextState()));
      n2 && (h2 || (h2 = {
        level: 0
      }));
      const E2 = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: C2
      }, u2 = {
        initialized: false,
        str: [],
        totalWidth: 0,
        totalHeight: 0,
        width: 0,
        height: 0,
        vertical: false,
        prevTransform: null,
        textAdvanceScale: 0,
        spaceInFlowMin: 0,
        spaceInFlowMax: 0,
        trackingSpaceMin: 1 / 0,
        negativeSpaceMax: -1 / 0,
        notASpace: -1 / 0,
        transform: null,
        fontName: null,
        hasEOL: false
      }, d2 = [
        " ",
        " "
      ];
      let f2 = 0;
      function saveLastChar(e3) {
        const t3 = (f2 + 1) % 2, i3 = " " !== d2[f2] && " " === d2[t3];
        d2[f2] = e3;
        f2 = t3;
        return !Q2 && i3;
      }
      function shouldAddWhitepsace() {
        return !Q2 && " " !== d2[f2] && " " === d2[(f2 + 1) % 2];
      }
      function resetLastChars() {
        d2[0] = d2[1] = " ";
        f2 = 0;
      }
      const p2 = this, m2 = this.xref, y2 = [];
      let w2 = null;
      const b2 = new LocalImageCache(), D2 = new LocalGStateCache(), S2 = new EvaluatorPreprocessor(e2, m2, s2);
      let k2;
      function pushWhitespace({ width: e3 = 0, height: t3 = 0, transform: i3 = u2.prevTransform, fontName: a2 = u2.fontName }) {
        E2.items.push({
          str: " ",
          dir: "ltr",
          width: e3,
          height: t3,
          transform: i3,
          fontName: a2,
          hasEOL: false
        });
      }
      function getCurrentTextTransform() {
        const e3 = k2.font, t3 = [
          k2.fontSize * k2.textHScale,
          0,
          0,
          k2.fontSize,
          0,
          k2.textRise
        ];
        if (e3.isType3Font && (k2.fontSize <= 1 || e3.isCharBBox) && !isArrayEqual(k2.fontMatrix, r)) {
          const i3 = e3.bbox[3] - e3.bbox[1];
          i3 > 0 && (t3[3] *= i3 * k2.fontMatrix[3]);
        }
        return Util.transform(k2.ctm, Util.transform(k2.textMatrix, t3));
      }
      function ensureTextContentItem() {
        if (u2.initialized) return u2;
        const { font: e3, loadedName: t3 } = k2;
        if (!g2.has(t3)) {
          g2.add(t3);
          E2.styles[t3] = {
            fontFamily: e3.fallbackName,
            ascent: e3.ascent,
            descent: e3.descent,
            vertical: e3.vertical
          };
          if (p2.options.fontExtraProperties && e3.systemFontInfo) {
            const i4 = E2.styles[t3];
            i4.fontSubstitution = e3.systemFontInfo.css;
            i4.fontSubstitutionLoadedName = e3.systemFontInfo.loadedName;
          }
        }
        u2.fontName = t3;
        const i3 = u2.transform = getCurrentTextTransform();
        if (e3.vertical) {
          u2.width = u2.totalWidth = Math.hypot(i3[0], i3[1]);
          u2.height = u2.totalHeight = 0;
          u2.vertical = true;
        } else {
          u2.width = u2.totalWidth = 0;
          u2.height = u2.totalHeight = Math.hypot(i3[2], i3[3]);
          u2.vertical = false;
        }
        const a2 = Math.hypot(k2.textLineMatrix[0], k2.textLineMatrix[1]), r2 = Math.hypot(k2.ctm[0], k2.ctm[1]);
        u2.textAdvanceScale = r2 * a2;
        const { fontSize: s3 } = k2;
        u2.trackingSpaceMin = 0.102 * s3;
        u2.notASpace = 0.03 * s3;
        u2.negativeSpaceMax = -0.2 * s3;
        u2.spaceInFlowMin = 0.102 * s3;
        u2.spaceInFlowMax = 0.6 * s3;
        u2.hasEOL = false;
        u2.initialized = true;
        return u2;
      }
      function updateAdvanceScale() {
        if (!u2.initialized) return;
        const e3 = Math.hypot(k2.textLineMatrix[0], k2.textLineMatrix[1]), t3 = Math.hypot(k2.ctm[0], k2.ctm[1]) * e3;
        if (t3 !== u2.textAdvanceScale) {
          if (u2.vertical) {
            u2.totalHeight += u2.height * u2.textAdvanceScale;
            u2.height = 0;
          } else {
            u2.totalWidth += u2.width * u2.textAdvanceScale;
            u2.width = 0;
          }
          u2.textAdvanceScale = t3;
        }
      }
      function runBidiTransform(e3) {
        let t3 = e3.str.join("");
        l2 || (t3 = function normalizeUnicode(e4) {
          if (!ht) {
            ht = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
            lt = /* @__PURE__ */ new Map([
              [
                "\uFB05",
                "\u017Ft"
              ]
            ]);
          }
          return e4.replaceAll(ht, (e5, t4, i4) => t4 ? t4.normalize("NFKC") : lt.get(i4));
        }(t3));
        const i3 = bidi(t3, -1, e3.vertical);
        return {
          str: i3.str,
          dir: i3.dir,
          width: Math.abs(e3.totalWidth),
          height: Math.abs(e3.totalHeight),
          transform: e3.transform,
          fontName: e3.fontName,
          hasEOL: e3.hasEOL
        };
      }
      async function handleSetFont(e3, a2) {
        const s3 = await p2.loadFont(e3, a2, i2);
        if (s3.font.isType3Font) try {
          await s3.loadType3Data(p2, i2, t2);
        } catch {
        }
        k2.loadedName = s3.loadedName;
        k2.font = s3.font;
        k2.fontMatrix = s3.font.fontMatrix || r;
      }
      function applyInverseRotation(e3, t3, i3) {
        const a2 = Math.hypot(i3[0], i3[1]);
        return [
          (i3[0] * e3 + i3[1] * t3) / a2,
          (i3[2] * e3 + i3[3] * t3) / a2
        ];
      }
      function compareWithLastPosition(e3) {
        var _a4;
        const t3 = getCurrentTextTransform();
        let i3 = t3[4], a2 = t3[5];
        if ((_a4 = k2.font) == null ? void 0 : _a4.vertical) {
          if (i3 < c2[0] || i3 > c2[2] || a2 + e3 < c2[1] || a2 > c2[3]) return false;
        } else if (i3 + e3 < c2[0] || i3 > c2[2] || a2 < c2[1] || a2 > c2[3]) return false;
        if (!k2.font || !u2.prevTransform) return true;
        let r2 = u2.prevTransform[4], s3 = u2.prevTransform[5];
        if (r2 === i3 && s3 === a2) return true;
        let n3 = -1;
        t3[0] && 0 === t3[1] && 0 === t3[2] ? n3 = t3[0] > 0 ? 0 : 180 : t3[1] && 0 === t3[0] && 0 === t3[3] && (n3 = t3[1] > 0 ? 90 : 270);
        switch (n3) {
          case 0:
            break;
          case 90:
            [i3, a2] = [
              a2,
              i3
            ];
            [r2, s3] = [
              s3,
              r2
            ];
            break;
          case 180:
            [i3, a2, r2, s3] = [
              -i3,
              -a2,
              -r2,
              -s3
            ];
            break;
          case 270:
            [i3, a2] = [
              -a2,
              -i3
            ];
            [r2, s3] = [
              -s3,
              -r2
            ];
            break;
          default:
            [i3, a2] = applyInverseRotation(i3, a2, t3);
            [r2, s3] = applyInverseRotation(r2, s3, u2.prevTransform);
        }
        if (k2.font.vertical) {
          const e4 = (s3 - a2) / u2.textAdvanceScale, t4 = i3 - r2, n4 = Math.sign(u2.height);
          if (e4 < n4 * u2.negativeSpaceMax) {
            if (Math.abs(t4) > 0.5 * u2.width) {
              appendEOL();
              return true;
            }
            resetLastChars();
            flushTextContentItem();
            return true;
          }
          if (Math.abs(t4) > u2.width) {
            appendEOL();
            return true;
          }
          e4 <= n4 * u2.notASpace && resetLastChars();
          if (e4 <= n4 * u2.trackingSpaceMin) if (shouldAddWhitepsace()) {
            resetLastChars();
            flushTextContentItem();
            pushWhitespace({
              height: Math.abs(e4)
            });
          } else u2.height += e4;
          else if (!addFakeSpaces(e4, u2.prevTransform, n4)) if (0 === u2.str.length) {
            resetLastChars();
            pushWhitespace({
              height: Math.abs(e4)
            });
          } else u2.height += e4;
          Math.abs(t4) > 0.25 * u2.width && flushTextContentItem();
          return true;
        }
        const o3 = (i3 - r2) / u2.textAdvanceScale, g3 = a2 - s3, C3 = Math.sign(u2.width);
        if (o3 < C3 * u2.negativeSpaceMax) {
          if (Math.abs(g3) > 0.5 * u2.height) {
            appendEOL();
            return true;
          }
          resetLastChars();
          flushTextContentItem();
          return true;
        }
        if (Math.abs(g3) > u2.height) {
          appendEOL();
          return true;
        }
        o3 <= C3 * u2.notASpace && resetLastChars();
        if (o3 <= C3 * u2.trackingSpaceMin) if (shouldAddWhitepsace()) {
          resetLastChars();
          flushTextContentItem();
          pushWhitespace({
            width: Math.abs(o3)
          });
        } else u2.width += o3;
        else if (!addFakeSpaces(o3, u2.prevTransform, C3)) if (0 === u2.str.length) {
          resetLastChars();
          pushWhitespace({
            width: Math.abs(o3)
          });
        } else u2.width += o3;
        Math.abs(g3) > 0.25 * u2.height && flushTextContentItem();
        return true;
      }
      function buildTextContentItem({ chars: e3, extraSpacing: t3 }) {
        const i3 = k2.font;
        if (!e3) {
          const e4 = k2.charSpacing + t3;
          e4 && (i3.vertical ? k2.translateTextMatrix(0, -e4) : k2.translateTextMatrix(e4 * k2.textHScale, 0));
          Q2 && compareWithLastPosition(0);
          return;
        }
        const a2 = i3.charsToGlyphs(e3), r2 = k2.fontMatrix[0] * k2.fontSize;
        for (let e4 = 0, s3 = a2.length; e4 < s3; e4++) {
          const n3 = a2[e4], { category: o3 } = n3;
          if (o3.isInvisibleFormatMark) continue;
          let g3 = k2.charSpacing + (e4 + 1 === s3 ? t3 : 0), c3 = n3.width;
          i3.vertical && (c3 = n3.vmetric ? n3.vmetric[0] : -c3);
          let C3 = c3 * r2;
          if (!Q2 && o3.isWhitespace) {
            if (i3.vertical) {
              g3 += -C3 + k2.wordSpacing;
              k2.translateTextMatrix(0, -g3);
            } else {
              g3 += C3 + k2.wordSpacing;
              k2.translateTextMatrix(g3 * k2.textHScale, 0);
            }
            saveLastChar(" ");
            continue;
          }
          if (!o3.isZeroWidthDiacritic && !compareWithLastPosition(C3)) {
            i3.vertical ? k2.translateTextMatrix(0, C3) : k2.translateTextMatrix(C3 * k2.textHScale, 0);
            continue;
          }
          const h3 = ensureTextContentItem();
          o3.isZeroWidthDiacritic && (C3 = 0);
          if (i3.vertical) {
            k2.translateTextMatrix(0, C3);
            C3 = Math.abs(C3);
            h3.height += C3;
          } else {
            C3 *= k2.textHScale;
            k2.translateTextMatrix(C3, 0);
            h3.width += C3;
          }
          C3 && (h3.prevTransform = getCurrentTextTransform());
          const l3 = n3.unicode;
          saveLastChar(l3) && h3.str.push(" ");
          h3.str.push(l3);
          g3 && (i3.vertical ? k2.translateTextMatrix(0, -g3) : k2.translateTextMatrix(g3 * k2.textHScale, 0));
        }
      }
      function appendEOL() {
        resetLastChars();
        if (u2.initialized) {
          u2.hasEOL = true;
          flushTextContentItem();
        } else E2.items.push({
          str: "",
          dir: "ltr",
          width: 0,
          height: 0,
          transform: getCurrentTextTransform(),
          fontName: k2.loadedName,
          hasEOL: true
        });
      }
      function addFakeSpaces(e3, t3, i3) {
        if (i3 * u2.spaceInFlowMin <= e3 && e3 <= i3 * u2.spaceInFlowMax) {
          if (u2.initialized) {
            resetLastChars();
            u2.str.push(" ");
          }
          return false;
        }
        const a2 = u2.fontName;
        let r2 = 0;
        if (u2.vertical) {
          r2 = e3;
          e3 = 0;
        }
        flushTextContentItem();
        resetLastChars();
        pushWhitespace({
          width: Math.abs(e3),
          height: Math.abs(r2),
          transform: t3 || getCurrentTextTransform(),
          fontName: a2
        });
        return true;
      }
      function flushTextContentItem() {
        if (u2.initialized && u2.str) {
          u2.vertical ? u2.totalHeight += u2.height * u2.textAdvanceScale : u2.totalWidth += u2.width * u2.textAdvanceScale;
          E2.items.push(runBidiTransform(u2));
          u2.initialized = false;
          u2.str.length = 0;
        }
      }
      function enqueueChunk(e3 = false) {
        const t3 = E2.items.length;
        if (0 !== t3 && !(e3 && t3 < 10)) {
          o2.enqueue(E2, t3);
          E2.items = [];
          E2.styles = /* @__PURE__ */ Object.create(null);
        }
      }
      const R2 = new TimeSlotManager();
      return new Promise(function promiseBody(e3, r2) {
        const next = function(t3) {
          enqueueChunk(true);
          Promise.all([
            t3,
            o2.ready
          ]).then(function() {
            try {
              promiseBody(e3, r2);
            } catch (e4) {
              r2(e4);
            }
          }, r2);
        };
        t2.ensureNotTerminated();
        R2.reset();
        const u3 = {};
        let d3, f3 = [];
        for (; !(d3 = R2.check()); ) {
          f3.length = 0;
          u3.args = f3;
          if (!S2.read(u3)) break;
          const e4 = k2;
          k2 = s2.state;
          const r3 = u3.fn;
          f3 = u3.args;
          switch (0 | r3) {
            case ne:
              var N2 = f3[0].name, G2 = f3[1];
              if (k2.font && N2 === k2.fontName && G2 === k2.fontSize) break;
              flushTextContentItem();
              k2.fontName = N2;
              k2.fontSize = G2;
              next(handleSetFont(N2, null));
              return;
            case ge:
              k2.textRise = f3[0];
              break;
            case re:
              k2.textHScale = f3[0] / 100;
              break;
            case se:
              k2.leading = f3[0];
              break;
            case Ie:
              k2.translateTextLineMatrix(f3[0], f3[1]);
              k2.textMatrix = k2.textLineMatrix.slice();
              break;
            case ce:
              k2.leading = -f3[1];
              k2.translateTextLineMatrix(f3[0], f3[1]);
              k2.textMatrix = k2.textLineMatrix.slice();
              break;
            case he:
              k2.carriageReturn();
              break;
            case Ce:
              k2.setTextMatrix(f3[0], f3[1], f3[2], f3[3], f3[4], f3[5]);
              k2.setTextLineMatrix(f3[0], f3[1], f3[2], f3[3], f3[4], f3[5]);
              updateAdvanceScale();
              break;
            case ie:
              k2.charSpacing = f3[0];
              break;
            case ae:
              k2.wordSpacing = f3[0];
              break;
            case ee:
              k2.textMatrix = a.slice();
              k2.textLineMatrix = a.slice();
              break;
            case Be:
              if (!s2.state.font) {
                p2.ensureStateFont(s2.state);
                continue;
              }
              const r4 = (k2.font.vertical ? 1 : -1) * k2.fontSize / 1e3, u4 = f3[0];
              for (let e5 = 0, t3 = u4.length; e5 < t3; e5++) {
                const t4 = u4[e5];
                if ("string" == typeof t4) y2.push(t4);
                else if ("number" == typeof t4 && 0 !== t4) {
                  const e6 = y2.join("");
                  y2.length = 0;
                  buildTextContentItem({
                    chars: e6,
                    extraSpacing: t4 * r4
                  });
                }
              }
              if (y2.length > 0) {
                const e5 = y2.join("");
                y2.length = 0;
                buildTextContentItem({
                  chars: e5,
                  extraSpacing: 0
                });
              }
              break;
            case le:
              if (!s2.state.font) {
                p2.ensureStateFont(s2.state);
                continue;
              }
              buildTextContentItem({
                chars: f3[0],
                extraSpacing: 0
              });
              break;
            case Qe:
              if (!s2.state.font) {
                p2.ensureStateFont(s2.state);
                continue;
              }
              k2.carriageReturn();
              buildTextContentItem({
                chars: f3[0],
                extraSpacing: 0
              });
              break;
            case Ee:
              if (!s2.state.font) {
                p2.ensureStateFont(s2.state);
                continue;
              }
              k2.wordSpacing = f3[0];
              k2.charSpacing = f3[1];
              k2.carriageReturn();
              buildTextContentItem({
                chars: f3[2],
                extraSpacing: 0
              });
              break;
            case Le:
              flushTextContentItem();
              w2 || (w2 = i2.get("XObject") || Dict.empty);
              var x2 = f3[0] instanceof Name, U2 = f3[0].name;
              if (x2 && b2.getByName(U2)) break;
              next(new Promise(function(e5, a2) {
                if (!x2) throw new FormatError("XObject must be referred to by name.");
                let r5 = w2.getRaw(U2);
                if (r5 instanceof Ref) {
                  if (b2.getByRef(r5)) {
                    e5();
                    return;
                  }
                  if (p2.globalImageCache.getData(r5, p2.pageIndex)) {
                    e5();
                    return;
                  }
                  r5 = m2.fetch(r5);
                }
                if (!(r5 instanceof BaseStream)) throw new FormatError("XObject should be a stream");
                const E3 = r5.dict.get("Subtype");
                if (!(E3 instanceof Name)) throw new FormatError("XObject should have a Name subtype");
                if ("Form" !== E3.name) {
                  b2.set(U2, r5.dict.objId, true);
                  e5();
                  return;
                }
                const u5 = s2.state.clone(), d4 = new StateManager(u5), f4 = lookupMatrix(r5.dict.getArray("Matrix"), null);
                f4 && d4.transform(f4);
                enqueueChunk();
                const y3 = {
                  enqueueInvoked: false,
                  enqueue(e6, t3) {
                    this.enqueueInvoked = true;
                    o2.enqueue(e6, t3);
                  },
                  get desiredSize() {
                    return o2.desiredSize;
                  },
                  get ready() {
                    return o2.ready;
                  }
                };
                p2.getTextContent({
                  stream: r5,
                  task: t2,
                  resources: r5.dict.get("Resources") || i2,
                  stateManager: d4,
                  includeMarkedContent: n2,
                  sink: y3,
                  seenStyles: g2,
                  viewBox: c2,
                  lang: C2,
                  markedContentData: h2,
                  disableNormalization: l2,
                  keepWhiteSpace: Q2
                }).then(function() {
                  y3.enqueueInvoked || b2.set(U2, r5.dict.objId, true);
                  e5();
                }, a2);
              }).catch(function(e5) {
                if (!(e5 instanceof AbortException)) {
                  if (!p2.options.ignoreErrors) throw e5;
                  warn(`getTextContent - ignoring XObject: "${e5}".`);
                }
              }));
              return;
            case xA:
              x2 = f3[0] instanceof Name;
              U2 = f3[0].name;
              if (x2 && D2.getByName(U2)) break;
              next(new Promise(function(e5, t3) {
                if (!x2) throw new FormatError("GState must be referred to by name.");
                const a2 = i2.get("ExtGState");
                if (!(a2 instanceof Dict)) throw new FormatError("ExtGState should be a dictionary.");
                const r5 = a2.get(U2);
                if (!(r5 instanceof Dict)) throw new FormatError("GState should be a dictionary.");
                const s3 = r5.get("Font");
                if (s3) {
                  flushTextContentItem();
                  k2.fontName = null;
                  k2.fontSize = s3[1];
                  handleSetFont(null, s3[0]).then(e5, t3);
                } else {
                  D2.set(U2, r5.objId, true);
                  e5();
                }
              }).catch(function(e5) {
                if (!(e5 instanceof AbortException)) {
                  if (!p2.options.ignoreErrors) throw e5;
                  warn(`getTextContent - ignoring ExtGState: "${e5}".`);
                }
              }));
              return;
            case ve:
              flushTextContentItem();
              if (n2) {
                h2.level++;
                E2.items.push({
                  type: "beginMarkedContent",
                  tag: f3[0] instanceof Name ? f3[0].name : null
                });
              }
              break;
            case Ye:
              flushTextContentItem();
              if (n2) {
                h2.level++;
                let e5 = null;
                f3[1] instanceof Dict && (e5 = f3[1].get("MCID"));
                E2.items.push({
                  type: "beginMarkedContentProps",
                  id: Number.isInteger(e5) ? `${p2.idFactory.getPageObjId()}_mc${e5}` : null,
                  tag: f3[0] instanceof Name ? f3[0].name : null
                });
              }
              break;
            case Te:
              flushTextContentItem();
              if (n2) {
                if (0 === h2.level) break;
                h2.level--;
                E2.items.push({
                  type: "endMarkedContent"
                });
              }
              break;
            case MA:
              !e4 || e4.font === k2.font && e4.fontSize === k2.fontSize && e4.fontName === k2.fontName || flushTextContentItem();
          }
          if (E2.items.length >= o2.desiredSize) {
            d3 = true;
            break;
          }
        }
        if (d3) next(Mr);
        else {
          flushTextContentItem();
          enqueueChunk();
          e3();
        }
      }).catch((e3) => {
        if (!(e3 instanceof AbortException)) {
          if (!this.options.ignoreErrors) throw e3;
          warn(`getTextContent - ignoring errors during "${t2.name}" task: "${e3}".`);
          flushTextContentItem();
          enqueueChunk();
        }
      });
    }
    async extractDataStructures(e2, t2) {
      const i2 = this.xref;
      let a2;
      const r2 = this.readToUnicode(t2.toUnicode);
      if (t2.composite) {
        const i3 = e2.get("CIDSystemInfo");
        i3 instanceof Dict && (t2.cidSystemInfo = {
          registry: stringToPDFString(i3.get("Registry")),
          ordering: stringToPDFString(i3.get("Ordering")),
          supplement: i3.get("Supplement")
        });
        try {
          const t3 = e2.get("CIDToGIDMap");
          t3 instanceof BaseStream && (a2 = t3.getBytes());
        } catch (e3) {
          if (!this.options.ignoreErrors) throw e3;
          warn(`extractDataStructures - ignoring CIDToGIDMap data: "${e3}".`);
        }
      }
      const s2 = [];
      let n2, o2 = null;
      if (e2.has("Encoding")) {
        n2 = e2.get("Encoding");
        if (n2 instanceof Dict) {
          o2 = n2.get("BaseEncoding");
          o2 = o2 instanceof Name ? o2.name : null;
          if (n2.has("Differences")) {
            const e3 = n2.get("Differences");
            let t3 = 0;
            for (const a3 of e3) {
              const e4 = i2.fetchIfRef(a3);
              if ("number" == typeof e4) t3 = e4;
              else {
                if (!(e4 instanceof Name)) throw new FormatError(`Invalid entry in 'Differences' array: ${e4}`);
                s2[t3++] = e4.name;
              }
            }
          }
        } else if (n2 instanceof Name) o2 = n2.name;
        else {
          const e3 = "Encoding is not a Name nor a Dict";
          if (!this.options.ignoreErrors) throw new FormatError(e3);
          warn(e3);
        }
        "MacRomanEncoding" !== o2 && "MacExpertEncoding" !== o2 && "WinAnsiEncoding" !== o2 && (o2 = null);
      }
      const g2 = !t2.file || t2.isInternalFont, c2 = Aa()[t2.name];
      o2 && g2 && c2 && (o2 = null);
      if (o2) t2.defaultEncoding = getEncoding(o2);
      else {
        const e3 = !!(t2.flags & Wi), i3 = !!(t2.flags & ji);
        n2 = wi;
        "TrueType" !== t2.type || i3 || (n2 = bi);
        if (e3 || c2) {
          n2 = yi;
          g2 && (/Symbol/i.test(t2.name) ? n2 = Di : /Dingbats/i.test(t2.name) ? n2 = Fi : /Wingdings/i.test(t2.name) && (n2 = bi));
        }
        t2.defaultEncoding = n2;
      }
      t2.differences = s2;
      t2.baseEncodingName = o2;
      t2.hasEncoding = !!o2 || s2.length > 0;
      t2.dict = e2;
      t2.toUnicode = await r2;
      const C2 = await this.buildToUnicode(t2);
      t2.toUnicode = C2;
      a2 && (t2.cidToGidMap = this.readCidToGidMap(a2, C2));
      return t2;
    }
    _simpleFontToUnicode(e2, t2 = false) {
      assert(!e2.composite, "Must be a simple font.");
      const i2 = [], a2 = e2.defaultEncoding.slice(), r2 = e2.baseEncodingName, s2 = e2.differences;
      for (const e3 in s2) {
        const t3 = s2[e3];
        ".notdef" !== t3 && (a2[e3] = t3);
      }
      const n2 = Hi();
      for (const s3 in a2) {
        let o2 = a2[s3];
        if ("" === o2) continue;
        let g2 = n2[o2];
        if (void 0 !== g2) {
          i2[s3] = String.fromCharCode(g2);
          continue;
        }
        let c2 = 0;
        switch (o2[0]) {
          case "G":
            3 === o2.length && (c2 = parseInt(o2.substring(1), 16));
            break;
          case "g":
            5 === o2.length && (c2 = parseInt(o2.substring(1), 16));
            break;
          case "C":
          case "c":
            if (o2.length >= 3 && o2.length <= 4) {
              const i3 = o2.substring(1);
              if (t2) {
                c2 = parseInt(i3, 16);
                break;
              }
              c2 = +i3;
              if (Number.isNaN(c2) && Number.isInteger(parseInt(i3, 16))) return this._simpleFontToUnicode(e2, true);
            }
            break;
          case "u":
            g2 = getUnicodeForGlyph(o2, n2);
            -1 !== g2 && (c2 = g2);
            break;
          default:
            switch (o2) {
              case "f_h":
              case "f_t":
              case "T_h":
                i2[s3] = o2.replaceAll("_", "");
                continue;
            }
        }
        if (c2 > 0 && c2 <= 1114111 && Number.isInteger(c2)) {
          if (r2 && c2 === +s3) {
            const e3 = getEncoding(r2);
            if (e3 && (o2 = e3[s3])) {
              i2[s3] = String.fromCharCode(n2[o2]);
              continue;
            }
          }
          i2[s3] = String.fromCodePoint(c2);
        }
      }
      return i2;
    }
    async buildToUnicode(e2) {
      var _a4, _b;
      e2.hasIncludedToUnicodeMap = ((_a4 = e2.toUnicode) == null ? void 0 : _a4.length) > 0;
      if (e2.hasIncludedToUnicodeMap) {
        !e2.composite && e2.hasEncoding && (e2.fallbackToUnicode = this._simpleFontToUnicode(e2));
        return e2.toUnicode;
      }
      if (!e2.composite) return new ToUnicodeMap(this._simpleFontToUnicode(e2));
      if (e2.composite && (e2.cMap.builtInCMap && !(e2.cMap instanceof IdentityCMap) || "Adobe" === ((_b = e2.cidSystemInfo) == null ? void 0 : _b.registry) && ("GB1" === e2.cidSystemInfo.ordering || "CNS1" === e2.cidSystemInfo.ordering || "Japan1" === e2.cidSystemInfo.ordering || "Korea1" === e2.cidSystemInfo.ordering))) {
        const { registry: t2, ordering: i2 } = e2.cidSystemInfo, a2 = Name.get(`${t2}-${i2}-UCS2`), r2 = await CMapFactory.create({
          encoding: a2,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        }), s2 = [], n2 = [];
        e2.cMap.forEach(function(e3, t3) {
          if (t3 > 65535) throw new FormatError("Max size of CID is 65,535");
          const i3 = r2.lookup(t3);
          if (i3) {
            n2.length = 0;
            for (let e4 = 0, t4 = i3.length; e4 < t4; e4 += 2) n2.push((i3.charCodeAt(e4) << 8) + i3.charCodeAt(e4 + 1));
            s2[e3] = String.fromCharCode(...n2);
          }
        });
        return new ToUnicodeMap(s2);
      }
      return new IdentityToUnicodeMap(e2.firstChar, e2.lastChar);
    }
    async readToUnicode(e2) {
      if (!e2) return null;
      if (e2 instanceof Name) {
        const t2 = await CMapFactory.create({
          encoding: e2,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        });
        return t2 instanceof IdentityCMap ? new IdentityToUnicodeMap(0, 65535) : new ToUnicodeMap(t2.getMap());
      }
      if (e2 instanceof BaseStream) try {
        const t2 = await CMapFactory.create({
          encoding: e2,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        });
        if (t2 instanceof IdentityCMap) return new IdentityToUnicodeMap(0, 65535);
        const i2 = new Array(t2.length);
        t2.forEach(function(e3, t3) {
          if ("number" == typeof t3) {
            i2[e3] = String.fromCodePoint(t3);
            return;
          }
          t3.length % 2 != 0 && (t3 = "\0" + t3);
          const a2 = [];
          for (let e4 = 0; e4 < t3.length; e4 += 2) {
            const i3 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
            if (55296 != (63488 & i3)) {
              a2.push(i3);
              continue;
            }
            e4 += 2;
            const r2 = t3.charCodeAt(e4) << 8 | t3.charCodeAt(e4 + 1);
            a2.push(((1023 & i3) << 10) + (1023 & r2) + 65536);
          }
          i2[e3] = String.fromCodePoint(...a2);
        });
        return new ToUnicodeMap(i2);
      } catch (e3) {
        if (e3 instanceof AbortException) return null;
        if (this.options.ignoreErrors) {
          warn(`readToUnicode - ignoring ToUnicode data: "${e3}".`);
          return null;
        }
        throw e3;
      }
      return null;
    }
    readCidToGidMap(e2, t2) {
      const i2 = [];
      for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) {
        const r3 = e2[a2++] << 8 | e2[a2], s2 = a2 >> 1;
        (0 !== r3 || t2.has(s2)) && (i2[s2] = r3);
      }
      return i2;
    }
    extractWidths(e2, t2, i2) {
      const a2 = this.xref;
      let r2 = [], s2 = 0;
      const n2 = [];
      let o2;
      if (i2.composite) {
        const t3 = e2.get("DW");
        s2 = "number" == typeof t3 ? Math.ceil(t3) : 1e3;
        const g3 = e2.get("W");
        if (Array.isArray(g3)) for (let e3 = 0, t4 = g3.length; e3 < t4; e3++) {
          let t5 = a2.fetchIfRef(g3[e3++]);
          if (!Number.isInteger(t5)) break;
          const i3 = a2.fetchIfRef(g3[e3]);
          if (Array.isArray(i3)) for (const e4 of i3) {
            const i4 = a2.fetchIfRef(e4);
            "number" == typeof i4 && (r2[t5] = i4);
            t5++;
          }
          else {
            if (!Number.isInteger(i3)) break;
            {
              const s3 = a2.fetchIfRef(g3[++e3]);
              if ("number" != typeof s3) continue;
              for (let e4 = t5; e4 <= i3; e4++) r2[e4] = s3;
            }
          }
        }
        if (i2.vertical) {
          const t4 = e2.getArray("DW2");
          let i3 = isNumberArray(t4, 2) ? t4 : [
            880,
            -1e3
          ];
          o2 = [
            i3[1],
            0.5 * s2,
            i3[0]
          ];
          i3 = e2.get("W2");
          if (Array.isArray(i3)) for (let e3 = 0, t5 = i3.length; e3 < t5; e3++) {
            let t6 = a2.fetchIfRef(i3[e3++]);
            if (!Number.isInteger(t6)) break;
            const r3 = a2.fetchIfRef(i3[e3]);
            if (Array.isArray(r3)) for (let e4 = 0, i4 = r3.length; e4 < i4; e4++) {
              const i5 = [
                a2.fetchIfRef(r3[e4++]),
                a2.fetchIfRef(r3[e4++]),
                a2.fetchIfRef(r3[e4])
              ];
              isNumberArray(i5, null) && (n2[t6] = i5);
              t6++;
            }
            else {
              if (!Number.isInteger(r3)) break;
              {
                const s3 = [
                  a2.fetchIfRef(i3[++e3]),
                  a2.fetchIfRef(i3[++e3]),
                  a2.fetchIfRef(i3[++e3])
                ];
                if (!isNumberArray(s3, null)) continue;
                for (let e4 = t6; e4 <= r3; e4++) n2[e4] = s3;
              }
            }
          }
        }
      } else {
        const n3 = e2.get("Widths");
        if (Array.isArray(n3)) {
          let e3 = i2.firstChar;
          for (const t3 of n3) {
            const i3 = a2.fetchIfRef(t3);
            "number" == typeof i3 && (r2[e3] = i3);
            e3++;
          }
          const o3 = t2.get("MissingWidth");
          s2 = "number" == typeof o3 ? o3 : 0;
        } else {
          const t3 = e2.get("BaseFont");
          if (t3 instanceof Name) {
            const e3 = this.getBaseFontMetrics(t3.name);
            r2 = this.buildCharCodeToWidth(e3.widths, i2);
            s2 = e3.defaultWidth;
          }
        }
      }
      let g2 = true, c2 = s2;
      for (const e3 in r2) {
        const t3 = r2[e3];
        if (t3) if (c2) {
          if (c2 !== t3) {
            g2 = false;
            break;
          }
        } else c2 = t3;
      }
      g2 ? i2.flags |= Oi : i2.flags &= ~Oi;
      i2.defaultWidth = s2;
      i2.widths = r2;
      i2.defaultVMetrics = o2;
      i2.vmetrics = n2;
    }
    isSerifFont(e2) {
      const t2 = e2.split("-", 1)[0];
      return t2 in $i() || /serif/gi.test(t2);
    }
    getBaseFontMetrics(e2) {
      let t2 = 0, i2 = /* @__PURE__ */ Object.create(null), a2 = false;
      let r2 = Vi()[e2] || e2;
      const s2 = ra();
      r2 in s2 || (r2 = this.isSerifFont(e2) ? "Times-Roman" : "Helvetica");
      const n2 = s2[r2];
      if ("number" == typeof n2) {
        t2 = n2;
        a2 = true;
      } else i2 = n2();
      return {
        defaultWidth: t2,
        monospace: a2,
        widths: i2
      };
    }
    buildCharCodeToWidth(e2, t2) {
      const i2 = /* @__PURE__ */ Object.create(null), a2 = t2.differences, r2 = t2.defaultEncoding;
      for (let t3 = 0; t3 < 256; t3++) t3 in a2 && e2[a2[t3]] ? i2[t3] = e2[a2[t3]] : t3 in r2 && e2[r2[t3]] && (i2[t3] = e2[r2[t3]]);
      return i2;
    }
    preEvaluateFont(e2) {
      const t2 = e2;
      let i2 = e2.get("Subtype");
      if (!(i2 instanceof Name)) throw new FormatError("invalid font Subtype");
      let a2, r2 = false;
      if ("Type0" === i2.name) {
        const t3 = e2.get("DescendantFonts");
        if (!t3) throw new FormatError("Descendant fonts are not specified");
        if (!((e2 = Array.isArray(t3) ? this.xref.fetchIfRef(t3[0]) : t3) instanceof Dict)) throw new FormatError("Descendant font is not a dictionary.");
        i2 = e2.get("Subtype");
        if (!(i2 instanceof Name)) throw new FormatError("invalid font Subtype");
        r2 = true;
      }
      let s2 = e2.get("FirstChar");
      Number.isInteger(s2) || (s2 = 0);
      let n2 = e2.get("LastChar");
      Number.isInteger(n2) || (n2 = r2 ? 65535 : 255);
      const o2 = e2.get("FontDescriptor"), g2 = e2.get("ToUnicode") || t2.get("ToUnicode");
      if (o2) {
        a2 = new MurmurHash3_64();
        const i3 = t2.getRaw("Encoding");
        if (i3 instanceof Name) a2.update(i3.name);
        else if (i3 instanceof Ref) a2.update(i3.toString());
        else if (i3 instanceof Dict) {
          for (const e3 of i3.getRawValues()) if (e3 instanceof Name) a2.update(e3.name);
          else if (e3 instanceof Ref) a2.update(e3.toString());
          else if (Array.isArray(e3)) {
            const t3 = e3.length, i4 = new Array(t3);
            for (let a3 = 0; a3 < t3; a3++) {
              const t4 = e3[a3];
              t4 instanceof Name ? i4[a3] = t4.name : ("number" == typeof t4 || t4 instanceof Ref) && (i4[a3] = t4.toString());
            }
            a2.update(i4.join());
          }
        }
        a2.update(`${s2}-${n2}`);
        if (g2 instanceof BaseStream) {
          const e3 = g2.str || g2, t3 = e3.buffer ? new Uint8Array(e3.buffer.buffer, 0, e3.bufferLength) : new Uint8Array(e3.bytes.buffer, e3.start, e3.end - e3.start);
          a2.update(t3);
        } else g2 instanceof Name && a2.update(g2.name);
        const o3 = e2.get("Widths") || t2.get("Widths");
        if (Array.isArray(o3)) {
          const e3 = [];
          for (const t3 of o3) ("number" == typeof t3 || t3 instanceof Ref) && e3.push(t3.toString());
          a2.update(e3.join());
        }
        if (r2) {
          a2.update("compositeFont");
          const i4 = e2.get("W") || t2.get("W");
          if (Array.isArray(i4)) {
            const e3 = [];
            for (const t3 of i4) if ("number" == typeof t3 || t3 instanceof Ref) e3.push(t3.toString());
            else if (Array.isArray(t3)) {
              const i5 = [];
              for (const e4 of t3) ("number" == typeof e4 || e4 instanceof Ref) && i5.push(e4.toString());
              e3.push(`[${i5.join()}]`);
            }
            a2.update(e3.join());
          }
          const r3 = e2.getRaw("CIDToGIDMap") || t2.getRaw("CIDToGIDMap");
          r3 instanceof Name ? a2.update(r3.name) : r3 instanceof Ref ? a2.update(r3.toString()) : r3 instanceof BaseStream && a2.update(r3.peekBytes());
        }
      }
      return {
        descriptor: o2,
        dict: e2,
        baseDict: t2,
        composite: r2,
        type: i2.name,
        firstChar: s2,
        lastChar: n2,
        toUnicode: g2,
        hash: a2 ? a2.hexdigest() : ""
      };
    }
    async translateFont({ descriptor: e2, dict: t2, baseDict: i2, composite: a2, type: s2, firstChar: n2, lastChar: o2, toUnicode: g2, cssFontInfo: c2 }) {
      const C2 = "Type3" === s2;
      if (!e2) {
        if (!C2) {
          let e3 = t2.get("BaseFont");
          if (!(e3 instanceof Name)) throw new FormatError("Base font is not specified");
          e3 = e3.name.replaceAll(/[,_]/g, "-");
          const a3 = this.getBaseFontMetrics(e3), r2 = e3.split("-", 1)[0], c3 = (this.isSerifFont(r2) ? Pi : 0) | (a3.monospace ? Oi : 0) | (Aa()[r2] ? Wi : ji), h3 = {
            type: s2,
            name: e3,
            loadedName: i2.loadedName,
            systemFontInfo: null,
            widths: a3.widths,
            defaultWidth: a3.defaultWidth,
            isSimulatedFlags: true,
            flags: c3,
            firstChar: n2,
            lastChar: o2,
            toUnicode: g2,
            xHeight: 0,
            capHeight: 0,
            italicAngle: 0,
            isType3Font: C2
          }, l3 = t2.get("Widths"), Q3 = getStandardFontName(e3);
          let E3 = null;
          if (Q3) {
            E3 = await this.fetchStandardFontData(Q3);
            h3.isInternalFont = !!E3;
          }
          !h3.isInternalFont && this.options.useSystemFonts && (h3.systemFontInfo = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, e3, Q3, s2));
          const u3 = await this.extractDataStructures(t2, h3);
          if (Array.isArray(l3)) {
            const e4 = [];
            let t3 = n2;
            for (const i3 of l3) {
              const a4 = this.xref.fetchIfRef(i3);
              "number" == typeof a4 && (e4[t3] = a4);
              t3++;
            }
            u3.widths = e4;
          } else u3.widths = this.buildCharCodeToWidth(a3.widths, u3);
          return new Font(e3, E3, u3);
        }
        {
          const i3 = lookupNormalRect(t2.getArray("FontBBox"), [
            0,
            0,
            0,
            0
          ]);
          (e2 = new Dict(null)).set("FontName", Name.get(s2));
          e2.set("FontBBox", i3);
        }
      }
      let h2 = e2.get("FontName"), l2 = t2.get("BaseFont");
      "string" == typeof h2 && (h2 = Name.get(h2));
      "string" == typeof l2 && (l2 = Name.get(l2));
      const Q2 = h2 == null ? void 0 : h2.name, E2 = l2 == null ? void 0 : l2.name;
      if (!C2 && Q2 !== E2) {
        info(`The FontDescriptor's FontName is "${Q2}" but should be the same as the Font's BaseFont "${E2}".`);
        Q2 && E2 && (E2.startsWith(Q2) || !isKnownFontName(Q2) && isKnownFontName(E2)) && (h2 = null);
      }
      h2 || (h2 = l2);
      if (!(h2 instanceof Name)) throw new FormatError("invalid font name");
      let u2, d2, f2, p2, m2;
      try {
        u2 = e2.get("FontFile", "FontFile2", "FontFile3");
        if (u2) {
          if (!(u2 instanceof BaseStream)) throw new FormatError("FontFile should be a stream");
          if (u2.isEmpty) throw new FormatError("FontFile is empty");
        }
      } catch (e3) {
        if (!this.options.ignoreErrors) throw e3;
        warn(`translateFont - fetching "${h2.name}" font file: "${e3}".`);
        u2 = null;
      }
      let y2 = false, w2 = null, b2 = null;
      if (u2) {
        if (u2.dict) {
          const e3 = u2.dict.get("Subtype");
          e3 instanceof Name && (d2 = e3.name);
          f2 = u2.dict.get("Length1");
          p2 = u2.dict.get("Length2");
          m2 = u2.dict.get("Length3");
        }
      } else if (c2) {
        const e3 = getXfaFontName(h2.name);
        if (e3) {
          c2.fontFamily = `${c2.fontFamily}-PdfJS-XFA`;
          c2.metrics = e3.metrics || null;
          w2 = e3.factors || null;
          u2 = await this.fetchStandardFontData(e3.name);
          y2 = !!u2;
          i2 = t2 = getXfaFontDict(h2.name);
          a2 = true;
        }
      } else if (!C2) {
        const e3 = getStandardFontName(h2.name);
        if (e3) {
          u2 = await this.fetchStandardFontData(e3);
          y2 = !!u2;
        }
        !y2 && this.options.useSystemFonts && (b2 = getFontSubstitution(this.systemFontCache, this.idFactory, this.options.standardFontDataUrl, h2.name, e3, s2));
      }
      const D2 = lookupMatrix(t2.getArray("FontMatrix"), r), S2 = lookupNormalRect(e2.getArray("FontBBox") || t2.getArray("FontBBox"), void 0);
      let k2 = e2.get("Ascent");
      "number" != typeof k2 && (k2 = void 0);
      let R2 = e2.get("Descent");
      "number" != typeof R2 && (R2 = void 0);
      let N2 = e2.get("XHeight");
      "number" != typeof N2 && (N2 = 0);
      let G2 = e2.get("CapHeight");
      "number" != typeof G2 && (G2 = 0);
      let x2 = e2.get("Flags");
      Number.isInteger(x2) || (x2 = 0);
      let U2 = e2.get("ItalicAngle");
      "number" != typeof U2 && (U2 = 0);
      const M2 = {
        type: s2,
        name: h2.name,
        subtype: d2,
        file: u2,
        length1: f2,
        length2: p2,
        length3: m2,
        isInternalFont: y2,
        loadedName: i2.loadedName,
        composite: a2,
        fixedPitch: false,
        fontMatrix: D2,
        firstChar: n2,
        lastChar: o2,
        toUnicode: g2,
        bbox: S2,
        ascent: k2,
        descent: R2,
        xHeight: N2,
        capHeight: G2,
        flags: x2,
        italicAngle: U2,
        isType3Font: C2,
        cssFontInfo: c2,
        scaleFactors: w2,
        systemFontInfo: b2
      };
      if (a2) {
        const e3 = i2.get("Encoding");
        e3 instanceof Name && (M2.cidEncoding = e3.name);
        const t3 = await CMapFactory.create({
          encoding: e3,
          fetchBuiltInCMap: this._fetchBuiltInCMapBound,
          useCMap: null
        });
        M2.cMap = t3;
        M2.vertical = M2.cMap.vertical;
      }
      const L2 = await this.extractDataStructures(t2, M2);
      this.extractWidths(t2, e2, L2);
      return new Font(h2.name, u2, L2);
    }
    static buildFontPaths(e2, t2, i2, a2) {
      function buildPath(t3) {
        const r2 = `${e2.loadedName}_path_${t3}`;
        try {
          if (e2.renderer.hasBuiltPath(t3)) return;
          i2.send("commonobj", [
            r2,
            "FontPath",
            e2.renderer.getPathJs(t3)
          ]);
        } catch (e3) {
          if (a2.ignoreErrors) {
            warn(`buildFontPaths - ignoring ${r2} glyph: "${e3}".`);
            return;
          }
          throw e3;
        }
      }
      for (const e3 of t2) {
        buildPath(e3.fontChar);
        const t3 = e3.accent;
        (t3 == null ? void 0 : t3.fontChar) && buildPath(t3.fontChar);
      }
    }
    static get fallbackFontDict() {
      const e2 = new Dict();
      e2.set("BaseFont", Name.get("Helvetica"));
      e2.set("Type", Name.get("FallbackType"));
      e2.set("Subtype", Name.get("FallbackType"));
      e2.set("Encoding", Name.get("WinAnsiEncoding"));
      return shadow(this, "fallbackFontDict", e2);
    }
  }
  class TranslatedFont {
    constructor({ loadedName: e2, font: t2, dict: i2, evaluatorOptions: a2 }) {
      this.loadedName = e2;
      this.font = t2;
      this.dict = i2;
      this._evaluatorOptions = a2 || Gr;
      this.type3Loaded = null;
      this.type3Dependencies = t2.isType3Font ? /* @__PURE__ */ new Set() : null;
      this.sent = false;
    }
    send(e2) {
      if (!this.sent) {
        this.sent = true;
        e2.send("commonobj", [
          this.loadedName,
          "Font",
          this.font.exportData(this._evaluatorOptions.fontExtraProperties)
        ]);
      }
    }
    fallback(e2) {
      if (this.font.data) {
        this.font.disableFontFace = true;
        PartialEvaluator.buildFontPaths(this.font, this.font.glyphCacheValues, e2, this._evaluatorOptions);
      }
    }
    loadType3Data(e2, t2, i2) {
      if (this.type3Loaded) return this.type3Loaded;
      if (!this.font.isType3Font) throw new Error("Must be a Type3 font.");
      const a2 = e2.clone({
        ignoreErrors: false
      }), r2 = new RefSet(e2.type3FontRefs);
      this.dict.objId && !r2.has(this.dict.objId) && r2.put(this.dict.objId);
      a2.type3FontRefs = r2;
      const s2 = this.font, n2 = this.type3Dependencies;
      let o2 = Promise.resolve();
      const g2 = this.dict.get("CharProcs"), c2 = this.dict.get("Resources") || t2, C2 = /* @__PURE__ */ Object.create(null), h2 = Util.normalizeRect(s2.bbox || [
        0,
        0,
        0,
        0
      ]), l2 = h2[2] - h2[0], Q2 = h2[3] - h2[1], E2 = Math.hypot(l2, Q2);
      for (const e3 of g2.getKeys()) o2 = o2.then(() => {
        const t3 = g2.get(e3), r3 = new OperatorList();
        return a2.getOperatorList({
          stream: t3,
          task: i2,
          resources: c2,
          operatorList: r3
        }).then(() => {
          r3.fnArray[0] === de && this._removeType3ColorOperators(r3, E2);
          C2[e3] = r3.getIR();
          for (const e4 of r3.dependencies) n2.add(e4);
        }).catch(function(t4) {
          warn(`Type3 font resource "${e3}" is not available.`);
          const i3 = new OperatorList();
          C2[e3] = i3.getIR();
        });
      });
      this.type3Loaded = o2.then(() => {
        s2.charProcOperatorList = C2;
        if (this._bbox) {
          s2.isCharBBox = true;
          s2.bbox = this._bbox;
        }
      });
      return this.type3Loaded;
    }
    _removeType3ColorOperators(e2, t2 = NaN) {
      const i2 = Util.normalizeRect(e2.argsArray[0].slice(2)), a2 = i2[2] - i2[0], r2 = i2[3] - i2[1], s2 = Math.hypot(a2, r2);
      if (0 === a2 || 0 === r2) {
        e2.fnArray.splice(0, 1);
        e2.argsArray.splice(0, 1);
      } else if (0 === t2 || Math.round(s2 / t2) >= 10) {
        this._bbox || (this._bbox = [
          1 / 0,
          1 / 0,
          -1 / 0,
          -1 / 0
        ]);
        this._bbox[0] = Math.min(this._bbox[0], i2[0]);
        this._bbox[1] = Math.min(this._bbox[1], i2[1]);
        this._bbox[2] = Math.max(this._bbox[2], i2[2]);
        this._bbox[3] = Math.max(this._bbox[3], i2[3]);
      }
      let n2 = 0, o2 = e2.length;
      for (; n2 < o2; ) {
        switch (e2.fnArray[n2]) {
          case de:
            break;
          case fe:
          case pe:
          case me:
          case ye:
          case we:
          case be:
          case De:
          case Fe:
          case Se:
          case ke:
          case Re:
          case Ne:
          case Ge:
          case NA:
            e2.fnArray.splice(n2, 1);
            e2.argsArray.splice(n2, 1);
            o2--;
            continue;
          case xA:
            const [t3] = e2.argsArray[n2];
            let i3 = 0, a3 = t3.length;
            for (; i3 < a3; ) {
              const [e3] = t3[i3];
              switch (e3) {
                case "TR":
                case "TR2":
                case "HT":
                case "BG":
                case "BG2":
                case "UCR":
                case "UCR2":
                  t3.splice(i3, 1);
                  a3--;
                  continue;
              }
              i3++;
            }
        }
        n2++;
      }
    }
  }
  class StateManager {
    constructor(e2 = new EvalState()) {
      this.state = e2;
      this.stateStack = [];
    }
    save() {
      const e2 = this.state;
      this.stateStack.push(this.state);
      this.state = e2.clone();
    }
    restore() {
      const e2 = this.stateStack.pop();
      e2 && (this.state = e2);
    }
    transform(e2) {
      this.state.ctm = Util.transform(this.state.ctm, e2);
    }
  }
  class TextState {
    constructor() {
      this.ctm = new Float32Array(a);
      this.fontName = null;
      this.fontSize = 0;
      this.loadedName = null;
      this.font = null;
      this.fontMatrix = r;
      this.textMatrix = a.slice();
      this.textLineMatrix = a.slice();
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.leading = 0;
      this.textHScale = 1;
      this.textRise = 0;
    }
    setTextMatrix(e2, t2, i2, a2, r2, s2) {
      const n2 = this.textMatrix;
      n2[0] = e2;
      n2[1] = t2;
      n2[2] = i2;
      n2[3] = a2;
      n2[4] = r2;
      n2[5] = s2;
    }
    setTextLineMatrix(e2, t2, i2, a2, r2, s2) {
      const n2 = this.textLineMatrix;
      n2[0] = e2;
      n2[1] = t2;
      n2[2] = i2;
      n2[3] = a2;
      n2[4] = r2;
      n2[5] = s2;
    }
    translateTextMatrix(e2, t2) {
      const i2 = this.textMatrix;
      i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4];
      i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
    }
    translateTextLineMatrix(e2, t2) {
      const i2 = this.textLineMatrix;
      i2[4] = i2[0] * e2 + i2[2] * t2 + i2[4];
      i2[5] = i2[1] * e2 + i2[3] * t2 + i2[5];
    }
    carriageReturn() {
      this.translateTextLineMatrix(0, -this.leading);
      this.textMatrix = this.textLineMatrix.slice();
    }
    clone() {
      const e2 = Object.create(this);
      e2.textMatrix = this.textMatrix.slice();
      e2.textLineMatrix = this.textLineMatrix.slice();
      e2.fontMatrix = this.fontMatrix.slice();
      return e2;
    }
  }
  class EvalState {
    constructor() {
      this.ctm = new Float32Array(a);
      this.font = null;
      this.textRenderingMode = b;
      this._fillColorSpace = ColorSpace.singletons.gray;
      this._strokeColorSpace = ColorSpace.singletons.gray;
      this.patternFillColorSpace = null;
      this.patternStrokeColorSpace = null;
    }
    get fillColorSpace() {
      return this._fillColorSpace;
    }
    set fillColorSpace(e2) {
      this._fillColorSpace = this.patternFillColorSpace = e2;
    }
    get strokeColorSpace() {
      return this._strokeColorSpace;
    }
    set strokeColorSpace(e2) {
      this._strokeColorSpace = this.patternStrokeColorSpace = e2;
    }
    clone() {
      return Object.create(this);
    }
  }
  const _EvaluatorPreprocessor = class _EvaluatorPreprocessor {
    static get opMap() {
      return shadow(this, "opMap", Object.assign(/* @__PURE__ */ Object.create(null), {
        w: {
          id: DA,
          numArgs: 1,
          variableArgs: false
        },
        J: {
          id: FA,
          numArgs: 1,
          variableArgs: false
        },
        j: {
          id: SA,
          numArgs: 1,
          variableArgs: false
        },
        M: {
          id: kA,
          numArgs: 1,
          variableArgs: false
        },
        d: {
          id: RA,
          numArgs: 2,
          variableArgs: false
        },
        ri: {
          id: NA,
          numArgs: 1,
          variableArgs: false
        },
        i: {
          id: GA,
          numArgs: 1,
          variableArgs: false
        },
        gs: {
          id: xA,
          numArgs: 1,
          variableArgs: false
        },
        q: {
          id: UA,
          numArgs: 0,
          variableArgs: false
        },
        Q: {
          id: MA,
          numArgs: 0,
          variableArgs: false
        },
        cm: {
          id: LA,
          numArgs: 6,
          variableArgs: false
        },
        m: {
          id: HA,
          numArgs: 2,
          variableArgs: false
        },
        l: {
          id: JA,
          numArgs: 2,
          variableArgs: false
        },
        c: {
          id: vA,
          numArgs: 6,
          variableArgs: false
        },
        v: {
          id: YA,
          numArgs: 4,
          variableArgs: false
        },
        y: {
          id: TA,
          numArgs: 4,
          variableArgs: false
        },
        h: {
          id: KA,
          numArgs: 0,
          variableArgs: false
        },
        re: {
          id: qA,
          numArgs: 4,
          variableArgs: false
        },
        S: {
          id: OA,
          numArgs: 0,
          variableArgs: false
        },
        s: {
          id: PA,
          numArgs: 0,
          variableArgs: false
        },
        f: {
          id: WA,
          numArgs: 0,
          variableArgs: false
        },
        F: {
          id: WA,
          numArgs: 0,
          variableArgs: false
        },
        "f*": {
          id: jA,
          numArgs: 0,
          variableArgs: false
        },
        B: {
          id: XA,
          numArgs: 0,
          variableArgs: false
        },
        "B*": {
          id: ZA,
          numArgs: 0,
          variableArgs: false
        },
        b: {
          id: VA,
          numArgs: 0,
          variableArgs: false
        },
        "b*": {
          id: _A,
          numArgs: 0,
          variableArgs: false
        },
        n: {
          id: zA,
          numArgs: 0,
          variableArgs: false
        },
        W: {
          id: $A,
          numArgs: 0,
          variableArgs: false
        },
        "W*": {
          id: Ae,
          numArgs: 0,
          variableArgs: false
        },
        BT: {
          id: ee,
          numArgs: 0,
          variableArgs: false
        },
        ET: {
          id: te,
          numArgs: 0,
          variableArgs: false
        },
        Tc: {
          id: ie,
          numArgs: 1,
          variableArgs: false
        },
        Tw: {
          id: ae,
          numArgs: 1,
          variableArgs: false
        },
        Tz: {
          id: re,
          numArgs: 1,
          variableArgs: false
        },
        TL: {
          id: se,
          numArgs: 1,
          variableArgs: false
        },
        Tf: {
          id: ne,
          numArgs: 2,
          variableArgs: false
        },
        Tr: {
          id: oe,
          numArgs: 1,
          variableArgs: false
        },
        Ts: {
          id: ge,
          numArgs: 1,
          variableArgs: false
        },
        Td: {
          id: Ie,
          numArgs: 2,
          variableArgs: false
        },
        TD: {
          id: ce,
          numArgs: 2,
          variableArgs: false
        },
        Tm: {
          id: Ce,
          numArgs: 6,
          variableArgs: false
        },
        "T*": {
          id: he,
          numArgs: 0,
          variableArgs: false
        },
        Tj: {
          id: le,
          numArgs: 1,
          variableArgs: false
        },
        TJ: {
          id: Be,
          numArgs: 1,
          variableArgs: false
        },
        "'": {
          id: Qe,
          numArgs: 1,
          variableArgs: false
        },
        '"': {
          id: Ee,
          numArgs: 3,
          variableArgs: false
        },
        d0: {
          id: ue,
          numArgs: 2,
          variableArgs: false
        },
        d1: {
          id: de,
          numArgs: 6,
          variableArgs: false
        },
        CS: {
          id: fe,
          numArgs: 1,
          variableArgs: false
        },
        cs: {
          id: pe,
          numArgs: 1,
          variableArgs: false
        },
        SC: {
          id: me,
          numArgs: 4,
          variableArgs: true
        },
        SCN: {
          id: ye,
          numArgs: 33,
          variableArgs: true
        },
        sc: {
          id: we,
          numArgs: 4,
          variableArgs: true
        },
        scn: {
          id: be,
          numArgs: 33,
          variableArgs: true
        },
        G: {
          id: De,
          numArgs: 1,
          variableArgs: false
        },
        g: {
          id: Fe,
          numArgs: 1,
          variableArgs: false
        },
        RG: {
          id: Se,
          numArgs: 3,
          variableArgs: false
        },
        rg: {
          id: ke,
          numArgs: 3,
          variableArgs: false
        },
        K: {
          id: Re,
          numArgs: 4,
          variableArgs: false
        },
        k: {
          id: Ne,
          numArgs: 4,
          variableArgs: false
        },
        sh: {
          id: Ge,
          numArgs: 1,
          variableArgs: false
        },
        BI: {
          id: xe,
          numArgs: 0,
          variableArgs: false
        },
        ID: {
          id: Ue,
          numArgs: 0,
          variableArgs: false
        },
        EI: {
          id: Me,
          numArgs: 1,
          variableArgs: false
        },
        Do: {
          id: Le,
          numArgs: 1,
          variableArgs: false
        },
        MP: {
          id: He,
          numArgs: 1,
          variableArgs: false
        },
        DP: {
          id: Je,
          numArgs: 2,
          variableArgs: false
        },
        BMC: {
          id: ve,
          numArgs: 1,
          variableArgs: false
        },
        BDC: {
          id: Ye,
          numArgs: 2,
          variableArgs: false
        },
        EMC: {
          id: Te,
          numArgs: 0,
          variableArgs: false
        },
        BX: {
          id: Ke,
          numArgs: 0,
          variableArgs: false
        },
        EX: {
          id: qe,
          numArgs: 0,
          variableArgs: false
        },
        BM: null,
        BD: null,
        true: null,
        fa: null,
        fal: null,
        fals: null,
        false: null,
        nu: null,
        nul: null,
        null: null
      }));
    }
    constructor(e2, t2, i2 = new StateManager()) {
      this.parser = new Parser({
        lexer: new Lexer(e2, _EvaluatorPreprocessor.opMap),
        xref: t2
      });
      this.stateManager = i2;
      this.nonProcessedArgs = [];
      this._isPathOp = false;
      this._numInvalidPathOPS = 0;
    }
    get savedStatesDepth() {
      return this.stateManager.stateStack.length;
    }
    read(e2) {
      let t2 = e2.args;
      for (; ; ) {
        const i2 = this.parser.getObj();
        if (i2 instanceof Cmd) {
          const a2 = i2.cmd, r2 = _EvaluatorPreprocessor.opMap[a2];
          if (!r2) {
            warn(`Unknown command "${a2}".`);
            continue;
          }
          const s2 = r2.id, n2 = r2.numArgs;
          let o2 = null !== t2 ? t2.length : 0;
          this._isPathOp || (this._numInvalidPathOPS = 0);
          this._isPathOp = s2 >= HA && s2 <= zA;
          if (r2.variableArgs) o2 > n2 && info(`Command ${a2}: expected [0, ${n2}] args, but received ${o2} args.`);
          else {
            if (o2 !== n2) {
              const e3 = this.nonProcessedArgs;
              for (; o2 > n2; ) {
                e3.push(t2.shift());
                o2--;
              }
              for (; o2 < n2 && 0 !== e3.length; ) {
                null === t2 && (t2 = []);
                t2.unshift(e3.pop());
                o2++;
              }
            }
            if (o2 < n2) {
              const e3 = `command ${a2}: expected ${n2} args, but received ${o2} args.`;
              if (this._isPathOp && ++this._numInvalidPathOPS > _EvaluatorPreprocessor.MAX_INVALID_PATH_OPS) throw new FormatError(`Invalid ${e3}`);
              warn(`Skipping ${e3}`);
              null !== t2 && (t2.length = 0);
              continue;
            }
          }
          this.preprocessCommand(s2, t2);
          e2.fn = s2;
          e2.args = t2;
          return true;
        }
        if (i2 === bt) return false;
        if (null !== i2) {
          null === t2 && (t2 = []);
          t2.push(i2);
          if (t2.length > 33) throw new FormatError("Too many arguments");
        }
      }
    }
    preprocessCommand(e2, t2) {
      switch (0 | e2) {
        case UA:
          this.stateManager.save();
          break;
        case MA:
          this.stateManager.restore();
          break;
        case LA:
          this.stateManager.transform(t2);
      }
    }
  };
  __publicField(_EvaluatorPreprocessor, "MAX_INVALID_PATH_OPS", 10);
  let EvaluatorPreprocessor = _EvaluatorPreprocessor;
  class DefaultAppearanceEvaluator extends EvaluatorPreprocessor {
    constructor(e2) {
      super(new StringStream(e2));
    }
    parse() {
      const e2 = {
        fn: 0,
        args: []
      }, t2 = {
        fontSize: 0,
        fontName: "",
        fontColor: new Uint8ClampedArray(3)
      };
      try {
        for (; ; ) {
          e2.args.length = 0;
          if (!this.read(e2)) break;
          if (0 !== this.savedStatesDepth) continue;
          const { fn: i2, args: a2 } = e2;
          switch (0 | i2) {
            case ne:
              const [e3, i3] = a2;
              e3 instanceof Name && (t2.fontName = e3.name);
              "number" == typeof i3 && i3 > 0 && (t2.fontSize = i3);
              break;
            case ke:
              ColorSpace.singletons.rgb.getRgbItem(a2, 0, t2.fontColor, 0);
              break;
            case Fe:
              ColorSpace.singletons.gray.getRgbItem(a2, 0, t2.fontColor, 0);
              break;
            case Ne:
              ColorSpace.singletons.cmyk.getRgbItem(a2, 0, t2.fontColor, 0);
          }
        }
      } catch (e3) {
        warn(`parseDefaultAppearance - ignoring errors: "${e3}".`);
      }
      return t2;
    }
  }
  function parseDefaultAppearance(e2) {
    return new DefaultAppearanceEvaluator(e2).parse();
  }
  class AppearanceStreamEvaluator extends EvaluatorPreprocessor {
    constructor(e2, t2, i2) {
      var _a4;
      super(e2);
      this.stream = e2;
      this.evaluatorOptions = t2;
      this.xref = i2;
      this.resources = (_a4 = e2.dict) == null ? void 0 : _a4.get("Resources");
    }
    parse() {
      const e2 = {
        fn: 0,
        args: []
      };
      let t2 = {
        scaleFactor: 1,
        fontSize: 0,
        fontName: "",
        fontColor: new Uint8ClampedArray(3),
        fillColorSpace: ColorSpace.singletons.gray
      }, i2 = false;
      const a2 = [];
      try {
        for (; ; ) {
          e2.args.length = 0;
          if (i2 || !this.read(e2)) break;
          const { fn: r2, args: s2 } = e2;
          switch (0 | r2) {
            case UA:
              a2.push({
                scaleFactor: t2.scaleFactor,
                fontSize: t2.fontSize,
                fontName: t2.fontName,
                fontColor: t2.fontColor.slice(),
                fillColorSpace: t2.fillColorSpace
              });
              break;
            case MA:
              t2 = a2.pop() || t2;
              break;
            case Ce:
              t2.scaleFactor *= Math.hypot(s2[0], s2[1]);
              break;
            case ne:
              const [e3, r3] = s2;
              e3 instanceof Name && (t2.fontName = e3.name);
              "number" == typeof r3 && r3 > 0 && (t2.fontSize = r3 * t2.scaleFactor);
              break;
            case pe:
              t2.fillColorSpace = ColorSpace.parse({
                cs: s2[0],
                xref: this.xref,
                resources: this.resources,
                pdfFunctionFactory: this._pdfFunctionFactory,
                localColorSpaceCache: this._localColorSpaceCache
              });
              break;
            case we:
              t2.fillColorSpace.getRgbItem(s2, 0, t2.fontColor, 0);
              break;
            case ke:
              ColorSpace.singletons.rgb.getRgbItem(s2, 0, t2.fontColor, 0);
              break;
            case Fe:
              ColorSpace.singletons.gray.getRgbItem(s2, 0, t2.fontColor, 0);
              break;
            case Ne:
              ColorSpace.singletons.cmyk.getRgbItem(s2, 0, t2.fontColor, 0);
              break;
            case le:
            case Be:
            case Qe:
            case Ee:
              i2 = true;
          }
        }
      } catch (e3) {
        warn(`parseAppearanceStream - ignoring errors: "${e3}".`);
      }
      this.stream.reset();
      delete t2.scaleFactor;
      delete t2.fillColorSpace;
      return t2;
    }
    get _localColorSpaceCache() {
      return shadow(this, "_localColorSpaceCache", new LocalColorSpaceCache());
    }
    get _pdfFunctionFactory() {
      return shadow(this, "_pdfFunctionFactory", new PDFFunctionFactory({
        xref: this.xref,
        isEvalSupported: this.evaluatorOptions.isEvalSupported
      }));
    }
  }
  function getPdfColor(e2, t2) {
    if (e2[0] === e2[1] && e2[1] === e2[2]) {
      return `${numberToString(e2[0] / 255)} ${t2 ? "g" : "G"}`;
    }
    return Array.from(e2, (e3) => numberToString(e3 / 255)).join(" ") + " " + (t2 ? "rg" : "RG");
  }
  class FakeUnicodeFont {
    constructor(e2, t2) {
      this.xref = e2;
      this.widths = null;
      this.firstChar = 1 / 0;
      this.lastChar = -1 / 0;
      this.fontFamily = t2;
      const i2 = new OffscreenCanvas(1, 1);
      this.ctxMeasure = i2.getContext("2d", {
        willReadFrequently: true
      });
      FakeUnicodeFont._fontNameId || (FakeUnicodeFont._fontNameId = 1);
      this.fontName = Name.get(`InvalidPDFjsFont_${t2}_${FakeUnicodeFont._fontNameId++}`);
    }
    get fontDescriptorRef() {
      if (!FakeUnicodeFont._fontDescriptorRef) {
        const e2 = new Dict(this.xref);
        e2.set("Type", Name.get("FontDescriptor"));
        e2.set("FontName", this.fontName);
        e2.set("FontFamily", "MyriadPro Regular");
        e2.set("FontBBox", [
          0,
          0,
          0,
          0
        ]);
        e2.set("FontStretch", Name.get("Normal"));
        e2.set("FontWeight", 400);
        e2.set("ItalicAngle", 0);
        FakeUnicodeFont._fontDescriptorRef = this.xref.getNewPersistentRef(e2);
      }
      return FakeUnicodeFont._fontDescriptorRef;
    }
    get descendantFontRef() {
      const e2 = new Dict(this.xref);
      e2.set("BaseFont", this.fontName);
      e2.set("Type", Name.get("Font"));
      e2.set("Subtype", Name.get("CIDFontType0"));
      e2.set("CIDToGIDMap", Name.get("Identity"));
      e2.set("FirstChar", this.firstChar);
      e2.set("LastChar", this.lastChar);
      e2.set("FontDescriptor", this.fontDescriptorRef);
      e2.set("DW", 1e3);
      const t2 = [], i2 = [
        ...this.widths.entries()
      ].sort();
      let a2 = null, r2 = null;
      for (const [e3, s3] of i2) if (a2) if (e3 === a2 + r2.length) r2.push(s3);
      else {
        t2.push(a2, r2);
        a2 = e3;
        r2 = [
          s3
        ];
      }
      else {
        a2 = e3;
        r2 = [
          s3
        ];
      }
      a2 && t2.push(a2, r2);
      e2.set("W", t2);
      const s2 = new Dict(this.xref);
      s2.set("Ordering", "Identity");
      s2.set("Registry", "Adobe");
      s2.set("Supplement", 0);
      e2.set("CIDSystemInfo", s2);
      return this.xref.getNewPersistentRef(e2);
    }
    get baseFontRef() {
      const e2 = new Dict(this.xref);
      e2.set("BaseFont", this.fontName);
      e2.set("Type", Name.get("Font"));
      e2.set("Subtype", Name.get("Type0"));
      e2.set("Encoding", Name.get("Identity-H"));
      e2.set("DescendantFonts", [
        this.descendantFontRef
      ]);
      e2.set("ToUnicode", Name.get("Identity-H"));
      return this.xref.getNewPersistentRef(e2);
    }
    get resources() {
      const e2 = new Dict(this.xref), t2 = new Dict(this.xref);
      t2.set(this.fontName.name, this.baseFontRef);
      e2.set("Font", t2);
      return e2;
    }
    _createContext() {
      this.widths = /* @__PURE__ */ new Map();
      this.ctxMeasure.font = `1000px ${this.fontFamily}`;
      return this.ctxMeasure;
    }
    createFontResources(e2) {
      const t2 = this._createContext();
      for (const i2 of e2.split(/\r\n?|\n/)) for (const e3 of i2.split("")) {
        const i3 = e3.charCodeAt(0);
        if (this.widths.has(i3)) continue;
        const a2 = t2.measureText(e3), r2 = Math.ceil(a2.width);
        this.widths.set(i3, r2);
        this.firstChar = Math.min(i3, this.firstChar);
        this.lastChar = Math.max(i3, this.lastChar);
      }
      return this.resources;
    }
    static getFirstPositionInfo(e2, t2, i2) {
      const [a2, r2, o2, g2] = e2;
      let c2 = o2 - a2, C2 = g2 - r2;
      t2 % 180 != 0 && ([c2, C2] = [
        C2,
        c2
      ]);
      const h2 = s * i2;
      return {
        coords: [
          0,
          C2 + n * i2 - h2
        ],
        bbox: [
          0,
          0,
          c2,
          C2
        ],
        matrix: 0 !== t2 ? getRotationMatrix(t2, C2, h2) : void 0
      };
    }
    createAppearance(e2, t2, i2, a2, r2, o2) {
      const g2 = this._createContext(), c2 = [];
      let C2 = -1 / 0;
      for (const t3 of e2.split(/\r\n?|\n/)) {
        c2.push(t3);
        const e3 = g2.measureText(t3).width;
        C2 = Math.max(C2, e3);
        for (const e4 of codePointIter(t3)) {
          const t4 = String.fromCodePoint(e4);
          let i3 = this.widths.get(e4);
          if (void 0 === i3) {
            const a3 = g2.measureText(t4);
            i3 = Math.ceil(a3.width);
            this.widths.set(e4, i3);
            this.firstChar = Math.min(e4, this.firstChar);
            this.lastChar = Math.max(e4, this.lastChar);
          }
        }
      }
      C2 *= a2 / 1e3;
      const [h2, l2, Q2, E2] = t2;
      let u2 = Q2 - h2, d2 = E2 - l2;
      i2 % 180 != 0 && ([u2, d2] = [
        d2,
        u2
      ]);
      let f2 = 1;
      C2 > u2 && (f2 = u2 / C2);
      let p2 = 1;
      const m2 = s * a2, y2 = n * a2, w2 = m2 * c2.length;
      w2 > d2 && (p2 = d2 / w2);
      const b2 = a2 * Math.min(f2, p2), D2 = [
        "q",
        `0 0 ${numberToString(u2)} ${numberToString(d2)} re W n`,
        "BT",
        `1 0 0 1 0 ${numberToString(d2 + y2)} Tm 0 Tc ${getPdfColor(r2, true)}`,
        `/${this.fontName.name} ${numberToString(b2)} Tf`
      ], { resources: S2 } = this;
      if (1 !== (o2 = "number" == typeof o2 && o2 >= 0 && o2 <= 1 ? o2 : 1)) {
        D2.push("/R0 gs");
        const e3 = new Dict(this.xref), t3 = new Dict(this.xref);
        t3.set("ca", o2);
        t3.set("CA", o2);
        t3.set("Type", Name.get("ExtGState"));
        e3.set("R0", t3);
        S2.set("ExtGState", e3);
      }
      const k2 = numberToString(m2);
      for (const e3 of c2) D2.push(`0 -${k2} Td <${stringToUTF16HexString(e3)}> Tj`);
      D2.push("ET", "Q");
      const R2 = D2.join("\n"), N2 = new Dict(this.xref);
      N2.set("Subtype", Name.get("Form"));
      N2.set("Type", Name.get("XObject"));
      N2.set("BBox", [
        0,
        0,
        u2,
        d2
      ]);
      N2.set("Length", R2.length);
      N2.set("Resources", S2);
      if (i2) {
        const e3 = getRotationMatrix(i2, u2, d2);
        N2.set("Matrix", e3);
      }
      const G2 = new StringStream(R2);
      G2.dict = N2;
      return G2;
    }
  }
  class NameOrNumberTree {
    constructor(e2, t2, i2) {
      this.root = e2;
      this.xref = t2;
      this._type = i2;
    }
    getAll() {
      const e2 = /* @__PURE__ */ new Map();
      if (!this.root) return e2;
      const t2 = this.xref, i2 = new RefSet();
      i2.put(this.root);
      const a2 = [
        this.root
      ];
      for (; a2.length > 0; ) {
        const r2 = t2.fetchIfRef(a2.shift());
        if (!(r2 instanceof Dict)) continue;
        if (r2.has("Kids")) {
          const e3 = r2.get("Kids");
          if (!Array.isArray(e3)) continue;
          for (const t3 of e3) {
            if (i2.has(t3)) throw new FormatError(`Duplicate entry in "${this._type}" tree.`);
            a2.push(t3);
            i2.put(t3);
          }
          continue;
        }
        const s2 = r2.get(this._type);
        if (Array.isArray(s2)) for (let i3 = 0, a3 = s2.length; i3 < a3; i3 += 2) e2.set(t2.fetchIfRef(s2[i3]), t2.fetchIfRef(s2[i3 + 1]));
      }
      return e2;
    }
    getRaw(e2) {
      if (!this.root) return null;
      const t2 = this.xref;
      let i2 = t2.fetchIfRef(this.root), a2 = 0;
      for (; i2.has("Kids"); ) {
        if (++a2 > 10) {
          warn(`Search depth limit reached for "${this._type}" tree.`);
          return null;
        }
        const r3 = i2.get("Kids");
        if (!Array.isArray(r3)) return null;
        let s2 = 0, n2 = r3.length - 1;
        for (; s2 <= n2; ) {
          const a3 = s2 + n2 >> 1, o2 = t2.fetchIfRef(r3[a3]), g2 = o2.get("Limits");
          if (e2 < t2.fetchIfRef(g2[0])) n2 = a3 - 1;
          else {
            if (!(e2 > t2.fetchIfRef(g2[1]))) {
              i2 = o2;
              break;
            }
            s2 = a3 + 1;
          }
        }
        if (s2 > n2) return null;
      }
      const r2 = i2.get(this._type);
      if (Array.isArray(r2)) {
        let i3 = 0, a3 = r2.length - 2;
        for (; i3 <= a3; ) {
          const s2 = i3 + a3 >> 1, n2 = s2 + (1 & s2), o2 = t2.fetchIfRef(r2[n2]);
          if (e2 < o2) a3 = n2 - 2;
          else {
            if (!(e2 > o2)) return r2[n2 + 1];
            i3 = n2 + 2;
          }
        }
      }
      return null;
    }
    get(e2) {
      return this.xref.fetchIfRef(this.getRaw(e2));
    }
  }
  class NameTree extends NameOrNumberTree {
    constructor(e2, t2) {
      super(e2, t2, "Names");
    }
  }
  class NumberTree extends NameOrNumberTree {
    constructor(e2, t2) {
      super(e2, t2, "Nums");
    }
  }
  function clearGlobalCaches() {
    !function clearPatternCaches() {
      Sa = /* @__PURE__ */ Object.create(null);
    }();
    !function clearPrimitiveCaches() {
      Dt = /* @__PURE__ */ Object.create(null);
      Ft = /* @__PURE__ */ Object.create(null);
      St = /* @__PURE__ */ Object.create(null);
    }();
    !function clearUnicodeCaches() {
      Ki.clear();
    }();
    JpxImage.cleanup();
  }
  function pickPlatformItem(e2) {
    return e2 instanceof Dict ? e2.has("UF") ? e2.get("UF") : e2.has("F") ? e2.get("F") : e2.has("Unix") ? e2.get("Unix") : e2.has("Mac") ? e2.get("Mac") : e2.has("DOS") ? e2.get("DOS") : null : null;
  }
  class FileSpec {
    constructor(e2, t2, i2 = false) {
      __privateAdd(this, _G, false);
      if (e2 instanceof Dict) {
        this.xref = t2;
        this.root = e2;
        e2.has("FS") && (this.fs = e2.get("FS"));
        e2.has("RF") && warn("Related file specifications are not supported");
        i2 || (e2.has("EF") ? __privateSet(this, _G, true) : warn("Non-embedded file specifications are not supported"));
      }
    }
    get filename() {
      let e2 = "";
      const t2 = pickPlatformItem(this.root);
      t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2).replaceAll("\\\\", "\\").replaceAll("\\/", "/").replaceAll("\\", "/"));
      return shadow(this, "filename", e2 || "unnamed");
    }
    get content() {
      var _a4;
      if (!__privateGet(this, _G)) return null;
      this._contentRef || (this._contentRef = pickPlatformItem((_a4 = this.root) == null ? void 0 : _a4.get("EF")));
      let e2 = null;
      if (this._contentRef) {
        const t2 = this.xref.fetchIfRef(this._contentRef);
        t2 instanceof BaseStream ? e2 = t2.getBytes() : warn("Embedded file specification points to non-existing/invalid content");
      } else warn("Embedded file specification does not have any content");
      return e2;
    }
    get description() {
      var _a4;
      let e2 = "";
      const t2 = (_a4 = this.root) == null ? void 0 : _a4.get("Desc");
      t2 && "string" == typeof t2 && (e2 = stringToPDFString(t2));
      return shadow(this, "description", e2);
    }
    get serializable() {
      return {
        rawFilename: this.filename,
        filename: (e2 = this.filename, e2.substring(e2.lastIndexOf("/") + 1)),
        content: this.content,
        description: this.description
      };
      var e2;
    }
  }
  _G = new WeakMap();
  const Lr = 0, Hr = -2, Jr = -3, vr = -4, Yr = -5, Tr = -6, Kr = -9;
  function isWhitespace(e2, t2) {
    const i2 = e2[t2];
    return " " === i2 || "\n" === i2 || "\r" === i2 || "	" === i2;
  }
  class XMLParserBase {
    _resolveEntities(e2) {
      return e2.replaceAll(/&([^;]+);/g, (e3, t2) => {
        if ("#x" === t2.substring(0, 2)) return String.fromCodePoint(parseInt(t2.substring(2), 16));
        if ("#" === t2.substring(0, 1)) return String.fromCodePoint(parseInt(t2.substring(1), 10));
        switch (t2) {
          case "lt":
            return "<";
          case "gt":
            return ">";
          case "amp":
            return "&";
          case "quot":
            return '"';
          case "apos":
            return "'";
        }
        return this.onResolveEntity(t2);
      });
    }
    _parseContent(e2, t2) {
      const i2 = [];
      let a2 = t2;
      function skipWs() {
        for (; a2 < e2.length && isWhitespace(e2, a2); ) ++a2;
      }
      for (; a2 < e2.length && !isWhitespace(e2, a2) && ">" !== e2[a2] && "/" !== e2[a2]; ) ++a2;
      const r2 = e2.substring(t2, a2);
      skipWs();
      for (; a2 < e2.length && ">" !== e2[a2] && "/" !== e2[a2] && "?" !== e2[a2]; ) {
        skipWs();
        let t3 = "", r3 = "";
        for (; a2 < e2.length && !isWhitespace(e2, a2) && "=" !== e2[a2]; ) {
          t3 += e2[a2];
          ++a2;
        }
        skipWs();
        if ("=" !== e2[a2]) return null;
        ++a2;
        skipWs();
        const s2 = e2[a2];
        if ('"' !== s2 && "'" !== s2) return null;
        const n2 = e2.indexOf(s2, ++a2);
        if (n2 < 0) return null;
        r3 = e2.substring(a2, n2);
        i2.push({
          name: t3,
          value: this._resolveEntities(r3)
        });
        a2 = n2 + 1;
        skipWs();
      }
      return {
        name: r2,
        attributes: i2,
        parsed: a2 - t2
      };
    }
    _parseProcessingInstruction(e2, t2) {
      let i2 = t2;
      for (; i2 < e2.length && !isWhitespace(e2, i2) && ">" !== e2[i2] && "?" !== e2[i2] && "/" !== e2[i2]; ) ++i2;
      const a2 = e2.substring(t2, i2);
      !function skipWs() {
        for (; i2 < e2.length && isWhitespace(e2, i2); ) ++i2;
      }();
      const r2 = i2;
      for (; i2 < e2.length && ("?" !== e2[i2] || ">" !== e2[i2 + 1]); ) ++i2;
      return {
        name: a2,
        value: e2.substring(r2, i2),
        parsed: i2 - t2
      };
    }
    parseXml(e2) {
      let t2 = 0;
      for (; t2 < e2.length; ) {
        let i2 = t2;
        if ("<" === e2[t2]) {
          ++i2;
          let t3;
          switch (e2[i2]) {
            case "/":
              ++i2;
              t3 = e2.indexOf(">", i2);
              if (t3 < 0) {
                this.onError(Kr);
                return;
              }
              this.onEndElement(e2.substring(i2, t3));
              i2 = t3 + 1;
              break;
            case "?":
              ++i2;
              const a2 = this._parseProcessingInstruction(e2, i2);
              if ("?>" !== e2.substring(i2 + a2.parsed, i2 + a2.parsed + 2)) {
                this.onError(Jr);
                return;
              }
              this.onPi(a2.name, a2.value);
              i2 += a2.parsed + 2;
              break;
            case "!":
              if ("--" === e2.substring(i2 + 1, i2 + 3)) {
                t3 = e2.indexOf("-->", i2 + 3);
                if (t3 < 0) {
                  this.onError(Yr);
                  return;
                }
                this.onComment(e2.substring(i2 + 3, t3));
                i2 = t3 + 3;
              } else if ("[CDATA[" === e2.substring(i2 + 1, i2 + 8)) {
                t3 = e2.indexOf("]]>", i2 + 8);
                if (t3 < 0) {
                  this.onError(Hr);
                  return;
                }
                this.onCdata(e2.substring(i2 + 8, t3));
                i2 = t3 + 3;
              } else {
                if ("DOCTYPE" !== e2.substring(i2 + 1, i2 + 8)) {
                  this.onError(Tr);
                  return;
                }
                {
                  const a3 = e2.indexOf("[", i2 + 8);
                  let r3 = false;
                  t3 = e2.indexOf(">", i2 + 8);
                  if (t3 < 0) {
                    this.onError(vr);
                    return;
                  }
                  if (a3 > 0 && t3 > a3) {
                    t3 = e2.indexOf("]>", i2 + 8);
                    if (t3 < 0) {
                      this.onError(vr);
                      return;
                    }
                    r3 = true;
                  }
                  const s3 = e2.substring(i2 + 8, t3 + (r3 ? 1 : 0));
                  this.onDoctype(s3);
                  i2 = t3 + (r3 ? 2 : 1);
                }
              }
              break;
            default:
              const r2 = this._parseContent(e2, i2);
              if (null === r2) {
                this.onError(Tr);
                return;
              }
              let s2 = false;
              if ("/>" === e2.substring(i2 + r2.parsed, i2 + r2.parsed + 2)) s2 = true;
              else if (">" !== e2.substring(i2 + r2.parsed, i2 + r2.parsed + 1)) {
                this.onError(Kr);
                return;
              }
              this.onBeginElement(r2.name, r2.attributes, s2);
              i2 += r2.parsed + (s2 ? 2 : 1);
          }
        } else {
          for (; i2 < e2.length && "<" !== e2[i2]; ) i2++;
          const a2 = e2.substring(t2, i2);
          this.onText(this._resolveEntities(a2));
        }
        t2 = i2;
      }
    }
    onResolveEntity(e2) {
      return `&${e2};`;
    }
    onPi(e2, t2) {
    }
    onComment(e2) {
    }
    onCdata(e2) {
    }
    onDoctype(e2) {
    }
    onText(e2) {
    }
    onBeginElement(e2, t2, i2) {
    }
    onEndElement(e2) {
    }
    onError(e2) {
    }
  }
  class SimpleDOMNode {
    constructor(e2, t2) {
      this.nodeName = e2;
      this.nodeValue = t2;
      Object.defineProperty(this, "parentNode", {
        value: null,
        writable: true
      });
    }
    get firstChild() {
      var _a4;
      return (_a4 = this.childNodes) == null ? void 0 : _a4[0];
    }
    get nextSibling() {
      const e2 = this.parentNode.childNodes;
      if (!e2) return;
      const t2 = e2.indexOf(this);
      return -1 !== t2 ? e2[t2 + 1] : void 0;
    }
    get textContent() {
      return this.childNodes ? this.childNodes.map(function(e2) {
        return e2.textContent;
      }).join("") : this.nodeValue || "";
    }
    get children() {
      return this.childNodes || [];
    }
    hasChildNodes() {
      var _a4;
      return ((_a4 = this.childNodes) == null ? void 0 : _a4.length) > 0;
    }
    searchNode(e2, t2) {
      var _a4;
      if (t2 >= e2.length) return this;
      const i2 = e2[t2];
      if (i2.name.startsWith("#") && t2 < e2.length - 1) return this.searchNode(e2, t2 + 1);
      const a2 = [];
      let r2 = this;
      for (; ; ) {
        if (i2.name === r2.nodeName) {
          if (0 !== i2.pos) {
            if (0 === a2.length) return null;
            {
              const [s2] = a2.pop();
              let n2 = 0;
              for (const a3 of s2.childNodes) if (i2.name === a3.nodeName) {
                if (n2 === i2.pos) return a3.searchNode(e2, t2 + 1);
                n2++;
              }
              return r2.searchNode(e2, t2 + 1);
            }
          }
          {
            const i3 = r2.searchNode(e2, t2 + 1);
            if (null !== i3) return i3;
          }
        }
        if (((_a4 = r2.childNodes) == null ? void 0 : _a4.length) > 0) {
          a2.push([
            r2,
            0
          ]);
          r2 = r2.childNodes[0];
        } else {
          if (0 === a2.length) return null;
          for (; 0 !== a2.length; ) {
            const [e3, t3] = a2.pop(), i3 = t3 + 1;
            if (i3 < e3.childNodes.length) {
              a2.push([
                e3,
                i3
              ]);
              r2 = e3.childNodes[i3];
              break;
            }
          }
          if (0 === a2.length) return null;
        }
      }
    }
    dump(e2) {
      if ("#text" !== this.nodeName) {
        e2.push(`<${this.nodeName}`);
        if (this.attributes) for (const t2 of this.attributes) e2.push(` ${t2.name}="${encodeToXmlString(t2.value)}"`);
        if (this.hasChildNodes()) {
          e2.push(">");
          for (const t2 of this.childNodes) t2.dump(e2);
          e2.push(`</${this.nodeName}>`);
        } else this.nodeValue ? e2.push(`>${encodeToXmlString(this.nodeValue)}</${this.nodeName}>`) : e2.push("/>");
      } else e2.push(encodeToXmlString(this.nodeValue));
    }
  }
  class SimpleXMLParser extends XMLParserBase {
    constructor({ hasAttributes: e2 = false, lowerCaseName: t2 = false }) {
      super();
      this._currentFragment = null;
      this._stack = null;
      this._errorCode = Lr;
      this._hasAttributes = e2;
      this._lowerCaseName = t2;
    }
    parseFromString(e2) {
      this._currentFragment = [];
      this._stack = [];
      this._errorCode = Lr;
      this.parseXml(e2);
      if (this._errorCode !== Lr) return;
      const [t2] = this._currentFragment;
      return t2 ? {
        documentElement: t2
      } : void 0;
    }
    onText(e2) {
      if (function isWhitespaceString(e3) {
        for (let t3 = 0, i2 = e3.length; t3 < i2; t3++) if (!isWhitespace(e3, t3)) return false;
        return true;
      }(e2)) return;
      const t2 = new SimpleDOMNode("#text", e2);
      this._currentFragment.push(t2);
    }
    onCdata(e2) {
      const t2 = new SimpleDOMNode("#text", e2);
      this._currentFragment.push(t2);
    }
    onBeginElement(e2, t2, i2) {
      this._lowerCaseName && (e2 = e2.toLowerCase());
      const a2 = new SimpleDOMNode(e2);
      a2.childNodes = [];
      this._hasAttributes && (a2.attributes = t2);
      this._currentFragment.push(a2);
      if (!i2) {
        this._stack.push(this._currentFragment);
        this._currentFragment = a2.childNodes;
      }
    }
    onEndElement(e2) {
      this._currentFragment = this._stack.pop() || [];
      const t2 = this._currentFragment.at(-1);
      if (!t2) return null;
      for (const e3 of t2.childNodes) e3.parentNode = t2;
      return t2;
    }
    onError(e2) {
      this._errorCode = e2;
    }
  }
  class MetadataParser {
    constructor(e2) {
      e2 = this._repair(e2);
      const t2 = new SimpleXMLParser({
        lowerCaseName: true
      }).parseFromString(e2);
      this._metadataMap = /* @__PURE__ */ new Map();
      this._data = e2;
      t2 && this._parse(t2);
    }
    _repair(e2) {
      return e2.replace(/^[^<]+/, "").replaceAll(/>\\376\\377([^<]+)/g, function(e3, t2) {
        const i2 = t2.replaceAll(/\\([0-3])([0-7])([0-7])/g, function(e4, t3, i3, a3) {
          return String.fromCharCode(64 * t3 + 8 * i3 + 1 * a3);
        }).replaceAll(/&(amp|apos|gt|lt|quot);/g, function(e4, t3) {
          switch (t3) {
            case "amp":
              return "&";
            case "apos":
              return "'";
            case "gt":
              return ">";
            case "lt":
              return "<";
            case "quot":
              return '"';
          }
          throw new Error(`_repair: ${t3} isn't defined.`);
        }), a2 = [
          ">"
        ];
        for (let e4 = 0, t3 = i2.length; e4 < t3; e4 += 2) {
          const t4 = 256 * i2.charCodeAt(e4) + i2.charCodeAt(e4 + 1);
          t4 >= 32 && t4 < 127 && 60 !== t4 && 62 !== t4 && 38 !== t4 ? a2.push(String.fromCharCode(t4)) : a2.push("&#x" + (65536 + t4).toString(16).substring(1) + ";");
        }
        return a2.join("");
      });
    }
    _getSequence(e2) {
      const t2 = e2.nodeName;
      return "rdf:bag" !== t2 && "rdf:seq" !== t2 && "rdf:alt" !== t2 ? null : e2.childNodes.filter((e3) => "rdf:li" === e3.nodeName);
    }
    _parseArray(e2) {
      if (!e2.hasChildNodes()) return;
      const [t2] = e2.childNodes, i2 = this._getSequence(t2) || [];
      this._metadataMap.set(e2.nodeName, i2.map((e3) => e3.textContent.trim()));
    }
    _parse(e2) {
      let t2 = e2.documentElement;
      if ("rdf:rdf" !== t2.nodeName) {
        t2 = t2.firstChild;
        for (; t2 && "rdf:rdf" !== t2.nodeName; ) t2 = t2.nextSibling;
      }
      if (t2 && "rdf:rdf" === t2.nodeName && t2.hasChildNodes()) {
        for (const e3 of t2.childNodes) if ("rdf:description" === e3.nodeName) for (const t3 of e3.childNodes) {
          const e4 = t3.nodeName;
          switch (e4) {
            case "#text":
              continue;
            case "dc:creator":
            case "dc:subject":
              this._parseArray(t3);
              continue;
          }
          this._metadataMap.set(e4, t3.textContent.trim());
        }
      }
    }
    get serializable() {
      return {
        parsedData: this._metadataMap,
        rawData: this._data
      };
    }
  }
  class DecryptStream extends DecodeStream {
    constructor(e2, t2, i2) {
      super(t2);
      this.str = e2;
      this.dict = e2.dict;
      this.decrypt = i2;
      this.nextChunk = null;
      this.initialized = false;
    }
    readBlock() {
      var _a4;
      let e2;
      if (this.initialized) e2 = this.nextChunk;
      else {
        e2 = this.str.getBytes(512);
        this.initialized = true;
      }
      if (!e2 || 0 === e2.length) {
        this.eof = true;
        return;
      }
      this.nextChunk = this.str.getBytes(512);
      const t2 = ((_a4 = this.nextChunk) == null ? void 0 : _a4.length) > 0;
      e2 = (0, this.decrypt)(e2, !t2);
      const i2 = this.bufferLength, a2 = i2 + e2.length;
      this.ensureBuffer(a2).set(e2, i2);
      this.bufferLength = a2;
    }
  }
  class ARCFourCipher {
    constructor(e2) {
      this.a = 0;
      this.b = 0;
      const t2 = new Uint8Array(256), i2 = e2.length;
      for (let e3 = 0; e3 < 256; ++e3) t2[e3] = e3;
      for (let a2 = 0, r2 = 0; a2 < 256; ++a2) {
        const s2 = t2[a2];
        r2 = r2 + s2 + e2[a2 % i2] & 255;
        t2[a2] = t2[r2];
        t2[r2] = s2;
      }
      this.s = t2;
    }
    encryptBlock(e2) {
      let t2 = this.a, i2 = this.b;
      const a2 = this.s, r2 = e2.length, s2 = new Uint8Array(r2);
      for (let n2 = 0; n2 < r2; ++n2) {
        t2 = t2 + 1 & 255;
        const r3 = a2[t2];
        i2 = i2 + r3 & 255;
        const o2 = a2[i2];
        a2[t2] = o2;
        a2[i2] = r3;
        s2[n2] = e2[n2] ^ a2[r3 + o2 & 255];
      }
      this.a = t2;
      this.b = i2;
      return s2;
    }
    decryptBlock(e2) {
      return this.encryptBlock(e2);
    }
    encrypt(e2) {
      return this.encryptBlock(e2);
    }
  }
  const qr = function calculateMD5Closure() {
    const e2 = new Uint8Array([
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21
    ]), t2 = new Int32Array([
      -680876936,
      -389564586,
      606105819,
      -1044525330,
      -176418897,
      1200080426,
      -1473231341,
      -45705983,
      1770035416,
      -1958414417,
      -42063,
      -1990404162,
      1804603682,
      -40341101,
      -1502002290,
      1236535329,
      -165796510,
      -1069501632,
      643717713,
      -373897302,
      -701558691,
      38016083,
      -660478335,
      -405537848,
      568446438,
      -1019803690,
      -187363961,
      1163531501,
      -1444681467,
      -51403784,
      1735328473,
      -1926607734,
      -378558,
      -2022574463,
      1839030562,
      -35309556,
      -1530992060,
      1272893353,
      -155497632,
      -1094730640,
      681279174,
      -358537222,
      -722521979,
      76029189,
      -640364487,
      -421815835,
      530742520,
      -995338651,
      -198630844,
      1126891415,
      -1416354905,
      -57434055,
      1700485571,
      -1894986606,
      -1051523,
      -2054922799,
      1873313359,
      -30611744,
      -1560198380,
      1309151649,
      -145523070,
      -1120210379,
      718787259,
      -343485551
    ]);
    return function hash(i2, a2, r2) {
      let s2 = 1732584193, n2 = -271733879, o2 = -1732584194, g2 = 271733878;
      const c2 = r2 + 72 & -64, C2 = new Uint8Array(c2);
      let h2, l2;
      for (h2 = 0; h2 < r2; ++h2) C2[h2] = i2[a2++];
      C2[h2++] = 128;
      const Q2 = c2 - 8;
      for (; h2 < Q2; ) C2[h2++] = 0;
      C2[h2++] = r2 << 3 & 255;
      C2[h2++] = r2 >> 5 & 255;
      C2[h2++] = r2 >> 13 & 255;
      C2[h2++] = r2 >> 21 & 255;
      C2[h2++] = r2 >>> 29 & 255;
      C2[h2++] = 0;
      C2[h2++] = 0;
      C2[h2++] = 0;
      const E2 = new Int32Array(16);
      for (h2 = 0; h2 < c2; ) {
        for (l2 = 0; l2 < 16; ++l2, h2 += 4) E2[l2] = C2[h2] | C2[h2 + 1] << 8 | C2[h2 + 2] << 16 | C2[h2 + 3] << 24;
        let i3, a3, r3 = s2, c3 = n2, Q3 = o2, u2 = g2;
        for (l2 = 0; l2 < 64; ++l2) {
          if (l2 < 16) {
            i3 = c3 & Q3 | ~c3 & u2;
            a3 = l2;
          } else if (l2 < 32) {
            i3 = u2 & c3 | ~u2 & Q3;
            a3 = 5 * l2 + 1 & 15;
          } else if (l2 < 48) {
            i3 = c3 ^ Q3 ^ u2;
            a3 = 3 * l2 + 5 & 15;
          } else {
            i3 = Q3 ^ (c3 | ~u2);
            a3 = 7 * l2 & 15;
          }
          const s3 = u2, n3 = r3 + i3 + t2[l2] + E2[a3] | 0, o3 = e2[l2];
          u2 = Q3;
          Q3 = c3;
          c3 = c3 + (n3 << o3 | n3 >>> 32 - o3) | 0;
          r3 = s3;
        }
        s2 = s2 + r3 | 0;
        n2 = n2 + c3 | 0;
        o2 = o2 + Q3 | 0;
        g2 = g2 + u2 | 0;
      }
      return new Uint8Array([
        255 & s2,
        s2 >> 8 & 255,
        s2 >> 16 & 255,
        s2 >>> 24 & 255,
        255 & n2,
        n2 >> 8 & 255,
        n2 >> 16 & 255,
        n2 >>> 24 & 255,
        255 & o2,
        o2 >> 8 & 255,
        o2 >> 16 & 255,
        o2 >>> 24 & 255,
        255 & g2,
        g2 >> 8 & 255,
        g2 >> 16 & 255,
        g2 >>> 24 & 255
      ]);
    };
  }();
  class Word64 {
    constructor(e2, t2) {
      this.high = 0 | e2;
      this.low = 0 | t2;
    }
    and(e2) {
      this.high &= e2.high;
      this.low &= e2.low;
    }
    xor(e2) {
      this.high ^= e2.high;
      this.low ^= e2.low;
    }
    or(e2) {
      this.high |= e2.high;
      this.low |= e2.low;
    }
    shiftRight(e2) {
      if (e2 >= 32) {
        this.low = this.high >>> e2 - 32 | 0;
        this.high = 0;
      } else {
        this.low = this.low >>> e2 | this.high << 32 - e2;
        this.high = this.high >>> e2 | 0;
      }
    }
    shiftLeft(e2) {
      if (e2 >= 32) {
        this.high = this.low << e2 - 32;
        this.low = 0;
      } else {
        this.high = this.high << e2 | this.low >>> 32 - e2;
        this.low <<= e2;
      }
    }
    rotateRight(e2) {
      let t2, i2;
      if (32 & e2) {
        i2 = this.low;
        t2 = this.high;
      } else {
        t2 = this.low;
        i2 = this.high;
      }
      e2 &= 31;
      this.low = t2 >>> e2 | i2 << 32 - e2;
      this.high = i2 >>> e2 | t2 << 32 - e2;
    }
    not() {
      this.high = ~this.high;
      this.low = ~this.low;
    }
    add(e2) {
      const t2 = (this.low >>> 0) + (e2.low >>> 0);
      let i2 = (this.high >>> 0) + (e2.high >>> 0);
      t2 > 4294967295 && (i2 += 1);
      this.low = 0 | t2;
      this.high = 0 | i2;
    }
    copyTo(e2, t2) {
      e2[t2] = this.high >>> 24 & 255;
      e2[t2 + 1] = this.high >> 16 & 255;
      e2[t2 + 2] = this.high >> 8 & 255;
      e2[t2 + 3] = 255 & this.high;
      e2[t2 + 4] = this.low >>> 24 & 255;
      e2[t2 + 5] = this.low >> 16 & 255;
      e2[t2 + 6] = this.low >> 8 & 255;
      e2[t2 + 7] = 255 & this.low;
    }
    assign(e2) {
      this.high = e2.high;
      this.low = e2.low;
    }
  }
  const Or = /* @__PURE__ */ function calculateSHA256Closure() {
    function rotr(e3, t2) {
      return e3 >>> t2 | e3 << 32 - t2;
    }
    function ch(e3, t2, i2) {
      return e3 & t2 ^ ~e3 & i2;
    }
    function maj(e3, t2, i2) {
      return e3 & t2 ^ e3 & i2 ^ t2 & i2;
    }
    function sigma(e3) {
      return rotr(e3, 2) ^ rotr(e3, 13) ^ rotr(e3, 22);
    }
    function sigmaPrime(e3) {
      return rotr(e3, 6) ^ rotr(e3, 11) ^ rotr(e3, 25);
    }
    function littleSigma(e3) {
      return rotr(e3, 7) ^ rotr(e3, 18) ^ e3 >>> 3;
    }
    const e2 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    return function hash(t2, i2, a2) {
      let r2 = 1779033703, s2 = 3144134277, n2 = 1013904242, o2 = 2773480762, g2 = 1359893119, c2 = 2600822924, C2 = 528734635, h2 = 1541459225;
      const l2 = 64 * Math.ceil((a2 + 9) / 64), Q2 = new Uint8Array(l2);
      let E2, u2;
      for (E2 = 0; E2 < a2; ++E2) Q2[E2] = t2[i2++];
      Q2[E2++] = 128;
      const d2 = l2 - 8;
      for (; E2 < d2; ) Q2[E2++] = 0;
      Q2[E2++] = 0;
      Q2[E2++] = 0;
      Q2[E2++] = 0;
      Q2[E2++] = a2 >>> 29 & 255;
      Q2[E2++] = a2 >> 21 & 255;
      Q2[E2++] = a2 >> 13 & 255;
      Q2[E2++] = a2 >> 5 & 255;
      Q2[E2++] = a2 << 3 & 255;
      const f2 = new Uint32Array(64);
      for (E2 = 0; E2 < l2; ) {
        for (u2 = 0; u2 < 16; ++u2) {
          f2[u2] = Q2[E2] << 24 | Q2[E2 + 1] << 16 | Q2[E2 + 2] << 8 | Q2[E2 + 3];
          E2 += 4;
        }
        for (u2 = 16; u2 < 64; ++u2) f2[u2] = (rotr(p2 = f2[u2 - 2], 17) ^ rotr(p2, 19) ^ p2 >>> 10) + f2[u2 - 7] + littleSigma(f2[u2 - 15]) + f2[u2 - 16] | 0;
        let t3, i3, a3 = r2, l3 = s2, d3 = n2, m2 = o2, y2 = g2, w2 = c2, b2 = C2, D2 = h2;
        for (u2 = 0; u2 < 64; ++u2) {
          t3 = D2 + sigmaPrime(y2) + ch(y2, w2, b2) + e2[u2] + f2[u2];
          i3 = sigma(a3) + maj(a3, l3, d3);
          D2 = b2;
          b2 = w2;
          w2 = y2;
          y2 = m2 + t3 | 0;
          m2 = d3;
          d3 = l3;
          l3 = a3;
          a3 = t3 + i3 | 0;
        }
        r2 = r2 + a3 | 0;
        s2 = s2 + l3 | 0;
        n2 = n2 + d3 | 0;
        o2 = o2 + m2 | 0;
        g2 = g2 + y2 | 0;
        c2 = c2 + w2 | 0;
        C2 = C2 + b2 | 0;
        h2 = h2 + D2 | 0;
      }
      var p2;
      return new Uint8Array([
        r2 >> 24 & 255,
        r2 >> 16 & 255,
        r2 >> 8 & 255,
        255 & r2,
        s2 >> 24 & 255,
        s2 >> 16 & 255,
        s2 >> 8 & 255,
        255 & s2,
        n2 >> 24 & 255,
        n2 >> 16 & 255,
        n2 >> 8 & 255,
        255 & n2,
        o2 >> 24 & 255,
        o2 >> 16 & 255,
        o2 >> 8 & 255,
        255 & o2,
        g2 >> 24 & 255,
        g2 >> 16 & 255,
        g2 >> 8 & 255,
        255 & g2,
        c2 >> 24 & 255,
        c2 >> 16 & 255,
        c2 >> 8 & 255,
        255 & c2,
        C2 >> 24 & 255,
        C2 >> 16 & 255,
        C2 >> 8 & 255,
        255 & C2,
        h2 >> 24 & 255,
        h2 >> 16 & 255,
        h2 >> 8 & 255,
        255 & h2
      ]);
    };
  }(), Pr = function calculateSHA512Closure() {
    function ch(e3, t2, i2, a2, r2) {
      e3.assign(t2);
      e3.and(i2);
      r2.assign(t2);
      r2.not();
      r2.and(a2);
      e3.xor(r2);
    }
    function maj(e3, t2, i2, a2, r2) {
      e3.assign(t2);
      e3.and(i2);
      r2.assign(t2);
      r2.and(a2);
      e3.xor(r2);
      r2.assign(i2);
      r2.and(a2);
      e3.xor(r2);
    }
    function sigma(e3, t2, i2) {
      e3.assign(t2);
      e3.rotateRight(28);
      i2.assign(t2);
      i2.rotateRight(34);
      e3.xor(i2);
      i2.assign(t2);
      i2.rotateRight(39);
      e3.xor(i2);
    }
    function sigmaPrime(e3, t2, i2) {
      e3.assign(t2);
      e3.rotateRight(14);
      i2.assign(t2);
      i2.rotateRight(18);
      e3.xor(i2);
      i2.assign(t2);
      i2.rotateRight(41);
      e3.xor(i2);
    }
    function littleSigma(e3, t2, i2) {
      e3.assign(t2);
      e3.rotateRight(1);
      i2.assign(t2);
      i2.rotateRight(8);
      e3.xor(i2);
      i2.assign(t2);
      i2.shiftRight(7);
      e3.xor(i2);
    }
    function littleSigmaPrime(e3, t2, i2) {
      e3.assign(t2);
      e3.rotateRight(19);
      i2.assign(t2);
      i2.rotateRight(61);
      e3.xor(i2);
      i2.assign(t2);
      i2.shiftRight(6);
      e3.xor(i2);
    }
    const e2 = [
      new Word64(1116352408, 3609767458),
      new Word64(1899447441, 602891725),
      new Word64(3049323471, 3964484399),
      new Word64(3921009573, 2173295548),
      new Word64(961987163, 4081628472),
      new Word64(1508970993, 3053834265),
      new Word64(2453635748, 2937671579),
      new Word64(2870763221, 3664609560),
      new Word64(3624381080, 2734883394),
      new Word64(310598401, 1164996542),
      new Word64(607225278, 1323610764),
      new Word64(1426881987, 3590304994),
      new Word64(1925078388, 4068182383),
      new Word64(2162078206, 991336113),
      new Word64(2614888103, 633803317),
      new Word64(3248222580, 3479774868),
      new Word64(3835390401, 2666613458),
      new Word64(4022224774, 944711139),
      new Word64(264347078, 2341262773),
      new Word64(604807628, 2007800933),
      new Word64(770255983, 1495990901),
      new Word64(1249150122, 1856431235),
      new Word64(1555081692, 3175218132),
      new Word64(1996064986, 2198950837),
      new Word64(2554220882, 3999719339),
      new Word64(2821834349, 766784016),
      new Word64(2952996808, 2566594879),
      new Word64(3210313671, 3203337956),
      new Word64(3336571891, 1034457026),
      new Word64(3584528711, 2466948901),
      new Word64(113926993, 3758326383),
      new Word64(338241895, 168717936),
      new Word64(666307205, 1188179964),
      new Word64(773529912, 1546045734),
      new Word64(1294757372, 1522805485),
      new Word64(1396182291, 2643833823),
      new Word64(1695183700, 2343527390),
      new Word64(1986661051, 1014477480),
      new Word64(2177026350, 1206759142),
      new Word64(2456956037, 344077627),
      new Word64(2730485921, 1290863460),
      new Word64(2820302411, 3158454273),
      new Word64(3259730800, 3505952657),
      new Word64(3345764771, 106217008),
      new Word64(3516065817, 3606008344),
      new Word64(3600352804, 1432725776),
      new Word64(4094571909, 1467031594),
      new Word64(275423344, 851169720),
      new Word64(430227734, 3100823752),
      new Word64(506948616, 1363258195),
      new Word64(659060556, 3750685593),
      new Word64(883997877, 3785050280),
      new Word64(958139571, 3318307427),
      new Word64(1322822218, 3812723403),
      new Word64(1537002063, 2003034995),
      new Word64(1747873779, 3602036899),
      new Word64(1955562222, 1575990012),
      new Word64(2024104815, 1125592928),
      new Word64(2227730452, 2716904306),
      new Word64(2361852424, 442776044),
      new Word64(2428436474, 593698344),
      new Word64(2756734187, 3733110249),
      new Word64(3204031479, 2999351573),
      new Word64(3329325298, 3815920427),
      new Word64(3391569614, 3928383900),
      new Word64(3515267271, 566280711),
      new Word64(3940187606, 3454069534),
      new Word64(4118630271, 4000239992),
      new Word64(116418474, 1914138554),
      new Word64(174292421, 2731055270),
      new Word64(289380356, 3203993006),
      new Word64(460393269, 320620315),
      new Word64(685471733, 587496836),
      new Word64(852142971, 1086792851),
      new Word64(1017036298, 365543100),
      new Word64(1126000580, 2618297676),
      new Word64(1288033470, 3409855158),
      new Word64(1501505948, 4234509866),
      new Word64(1607167915, 987167468),
      new Word64(1816402316, 1246189591)
    ];
    return function hash(t2, i2, a2, r2 = false) {
      let s2, n2, o2, g2, c2, C2, h2, l2;
      if (r2) {
        s2 = new Word64(3418070365, 3238371032);
        n2 = new Word64(1654270250, 914150663);
        o2 = new Word64(2438529370, 812702999);
        g2 = new Word64(355462360, 4144912697);
        c2 = new Word64(1731405415, 4290775857);
        C2 = new Word64(2394180231, 1750603025);
        h2 = new Word64(3675008525, 1694076839);
        l2 = new Word64(1203062813, 3204075428);
      } else {
        s2 = new Word64(1779033703, 4089235720);
        n2 = new Word64(3144134277, 2227873595);
        o2 = new Word64(1013904242, 4271175723);
        g2 = new Word64(2773480762, 1595750129);
        c2 = new Word64(1359893119, 2917565137);
        C2 = new Word64(2600822924, 725511199);
        h2 = new Word64(528734635, 4215389547);
        l2 = new Word64(1541459225, 327033209);
      }
      const Q2 = 128 * Math.ceil((a2 + 17) / 128), E2 = new Uint8Array(Q2);
      let u2, d2;
      for (u2 = 0; u2 < a2; ++u2) E2[u2] = t2[i2++];
      E2[u2++] = 128;
      const f2 = Q2 - 16;
      for (; u2 < f2; ) E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = 0;
      E2[u2++] = a2 >>> 29 & 255;
      E2[u2++] = a2 >> 21 & 255;
      E2[u2++] = a2 >> 13 & 255;
      E2[u2++] = a2 >> 5 & 255;
      E2[u2++] = a2 << 3 & 255;
      const p2 = new Array(80);
      for (u2 = 0; u2 < 80; u2++) p2[u2] = new Word64(0, 0);
      let m2 = new Word64(0, 0), y2 = new Word64(0, 0), w2 = new Word64(0, 0), b2 = new Word64(0, 0), D2 = new Word64(0, 0), S2 = new Word64(0, 0), k2 = new Word64(0, 0), R2 = new Word64(0, 0);
      const N2 = new Word64(0, 0), G2 = new Word64(0, 0), x2 = new Word64(0, 0), U2 = new Word64(0, 0);
      let M2, L2;
      for (u2 = 0; u2 < Q2; ) {
        for (d2 = 0; d2 < 16; ++d2) {
          p2[d2].high = E2[u2] << 24 | E2[u2 + 1] << 16 | E2[u2 + 2] << 8 | E2[u2 + 3];
          p2[d2].low = E2[u2 + 4] << 24 | E2[u2 + 5] << 16 | E2[u2 + 6] << 8 | E2[u2 + 7];
          u2 += 8;
        }
        for (d2 = 16; d2 < 80; ++d2) {
          M2 = p2[d2];
          littleSigmaPrime(M2, p2[d2 - 2], U2);
          M2.add(p2[d2 - 7]);
          littleSigma(x2, p2[d2 - 15], U2);
          M2.add(x2);
          M2.add(p2[d2 - 16]);
        }
        m2.assign(s2);
        y2.assign(n2);
        w2.assign(o2);
        b2.assign(g2);
        D2.assign(c2);
        S2.assign(C2);
        k2.assign(h2);
        R2.assign(l2);
        for (d2 = 0; d2 < 80; ++d2) {
          N2.assign(R2);
          sigmaPrime(x2, D2, U2);
          N2.add(x2);
          ch(x2, D2, S2, k2, U2);
          N2.add(x2);
          N2.add(e2[d2]);
          N2.add(p2[d2]);
          sigma(G2, m2, U2);
          maj(x2, m2, y2, w2, U2);
          G2.add(x2);
          M2 = R2;
          R2 = k2;
          k2 = S2;
          S2 = D2;
          b2.add(N2);
          D2 = b2;
          b2 = w2;
          w2 = y2;
          y2 = m2;
          M2.assign(N2);
          M2.add(G2);
          m2 = M2;
        }
        s2.add(m2);
        n2.add(y2);
        o2.add(w2);
        g2.add(b2);
        c2.add(D2);
        C2.add(S2);
        h2.add(k2);
        l2.add(R2);
      }
      if (r2) {
        L2 = new Uint8Array(48);
        s2.copyTo(L2, 0);
        n2.copyTo(L2, 8);
        o2.copyTo(L2, 16);
        g2.copyTo(L2, 24);
        c2.copyTo(L2, 32);
        C2.copyTo(L2, 40);
      } else {
        L2 = new Uint8Array(64);
        s2.copyTo(L2, 0);
        n2.copyTo(L2, 8);
        o2.copyTo(L2, 16);
        g2.copyTo(L2, 24);
        c2.copyTo(L2, 32);
        C2.copyTo(L2, 40);
        h2.copyTo(L2, 48);
        l2.copyTo(L2, 56);
      }
      return L2;
    };
  }();
  class NullCipher {
    decryptBlock(e2) {
      return e2;
    }
    encrypt(e2) {
      return e2;
    }
  }
  class AESBaseCipher {
    constructor() {
      this._s = new Uint8Array([
        99,
        124,
        119,
        123,
        242,
        107,
        111,
        197,
        48,
        1,
        103,
        43,
        254,
        215,
        171,
        118,
        202,
        130,
        201,
        125,
        250,
        89,
        71,
        240,
        173,
        212,
        162,
        175,
        156,
        164,
        114,
        192,
        183,
        253,
        147,
        38,
        54,
        63,
        247,
        204,
        52,
        165,
        229,
        241,
        113,
        216,
        49,
        21,
        4,
        199,
        35,
        195,
        24,
        150,
        5,
        154,
        7,
        18,
        128,
        226,
        235,
        39,
        178,
        117,
        9,
        131,
        44,
        26,
        27,
        110,
        90,
        160,
        82,
        59,
        214,
        179,
        41,
        227,
        47,
        132,
        83,
        209,
        0,
        237,
        32,
        252,
        177,
        91,
        106,
        203,
        190,
        57,
        74,
        76,
        88,
        207,
        208,
        239,
        170,
        251,
        67,
        77,
        51,
        133,
        69,
        249,
        2,
        127,
        80,
        60,
        159,
        168,
        81,
        163,
        64,
        143,
        146,
        157,
        56,
        245,
        188,
        182,
        218,
        33,
        16,
        255,
        243,
        210,
        205,
        12,
        19,
        236,
        95,
        151,
        68,
        23,
        196,
        167,
        126,
        61,
        100,
        93,
        25,
        115,
        96,
        129,
        79,
        220,
        34,
        42,
        144,
        136,
        70,
        238,
        184,
        20,
        222,
        94,
        11,
        219,
        224,
        50,
        58,
        10,
        73,
        6,
        36,
        92,
        194,
        211,
        172,
        98,
        145,
        149,
        228,
        121,
        231,
        200,
        55,
        109,
        141,
        213,
        78,
        169,
        108,
        86,
        244,
        234,
        101,
        122,
        174,
        8,
        186,
        120,
        37,
        46,
        28,
        166,
        180,
        198,
        232,
        221,
        116,
        31,
        75,
        189,
        139,
        138,
        112,
        62,
        181,
        102,
        72,
        3,
        246,
        14,
        97,
        53,
        87,
        185,
        134,
        193,
        29,
        158,
        225,
        248,
        152,
        17,
        105,
        217,
        142,
        148,
        155,
        30,
        135,
        233,
        206,
        85,
        40,
        223,
        140,
        161,
        137,
        13,
        191,
        230,
        66,
        104,
        65,
        153,
        45,
        15,
        176,
        84,
        187,
        22
      ]);
      this._inv_s = new Uint8Array([
        82,
        9,
        106,
        213,
        48,
        54,
        165,
        56,
        191,
        64,
        163,
        158,
        129,
        243,
        215,
        251,
        124,
        227,
        57,
        130,
        155,
        47,
        255,
        135,
        52,
        142,
        67,
        68,
        196,
        222,
        233,
        203,
        84,
        123,
        148,
        50,
        166,
        194,
        35,
        61,
        238,
        76,
        149,
        11,
        66,
        250,
        195,
        78,
        8,
        46,
        161,
        102,
        40,
        217,
        36,
        178,
        118,
        91,
        162,
        73,
        109,
        139,
        209,
        37,
        114,
        248,
        246,
        100,
        134,
        104,
        152,
        22,
        212,
        164,
        92,
        204,
        93,
        101,
        182,
        146,
        108,
        112,
        72,
        80,
        253,
        237,
        185,
        218,
        94,
        21,
        70,
        87,
        167,
        141,
        157,
        132,
        144,
        216,
        171,
        0,
        140,
        188,
        211,
        10,
        247,
        228,
        88,
        5,
        184,
        179,
        69,
        6,
        208,
        44,
        30,
        143,
        202,
        63,
        15,
        2,
        193,
        175,
        189,
        3,
        1,
        19,
        138,
        107,
        58,
        145,
        17,
        65,
        79,
        103,
        220,
        234,
        151,
        242,
        207,
        206,
        240,
        180,
        230,
        115,
        150,
        172,
        116,
        34,
        231,
        173,
        53,
        133,
        226,
        249,
        55,
        232,
        28,
        117,
        223,
        110,
        71,
        241,
        26,
        113,
        29,
        41,
        197,
        137,
        111,
        183,
        98,
        14,
        170,
        24,
        190,
        27,
        252,
        86,
        62,
        75,
        198,
        210,
        121,
        32,
        154,
        219,
        192,
        254,
        120,
        205,
        90,
        244,
        31,
        221,
        168,
        51,
        136,
        7,
        199,
        49,
        177,
        18,
        16,
        89,
        39,
        128,
        236,
        95,
        96,
        81,
        127,
        169,
        25,
        181,
        74,
        13,
        45,
        229,
        122,
        159,
        147,
        201,
        156,
        239,
        160,
        224,
        59,
        77,
        174,
        42,
        245,
        176,
        200,
        235,
        187,
        60,
        131,
        83,
        153,
        97,
        23,
        43,
        4,
        126,
        186,
        119,
        214,
        38,
        225,
        105,
        20,
        99,
        85,
        33,
        12,
        125
      ]);
      this._mix = new Uint32Array([
        0,
        235474187,
        470948374,
        303765277,
        941896748,
        908933415,
        607530554,
        708780849,
        1883793496,
        2118214995,
        1817866830,
        1649639237,
        1215061108,
        1181045119,
        1417561698,
        1517767529,
        3767586992,
        4003061179,
        4236429990,
        4069246893,
        3635733660,
        3602770327,
        3299278474,
        3400528769,
        2430122216,
        2664543715,
        2362090238,
        2193862645,
        2835123396,
        2801107407,
        3035535058,
        3135740889,
        3678124923,
        3576870512,
        3341394285,
        3374361702,
        3810496343,
        3977675356,
        4279080257,
        4043610186,
        2876494627,
        2776292904,
        3076639029,
        3110650942,
        2472011535,
        2640243204,
        2403728665,
        2169303058,
        1001089995,
        899835584,
        666464733,
        699432150,
        59727847,
        226906860,
        530400753,
        294930682,
        1273168787,
        1172967064,
        1475418501,
        1509430414,
        1942435775,
        2110667444,
        1876241833,
        1641816226,
        2910219766,
        2743034109,
        2976151520,
        3211623147,
        2505202138,
        2606453969,
        2302690252,
        2269728455,
        3711829422,
        3543599269,
        3240894392,
        3475313331,
        3843699074,
        3943906441,
        4178062228,
        4144047775,
        1306967366,
        1139781709,
        1374988112,
        1610459739,
        1975683434,
        2076935265,
        1775276924,
        1742315127,
        1034867998,
        866637845,
        566021896,
        800440835,
        92987698,
        193195065,
        429456164,
        395441711,
        1984812685,
        2017778566,
        1784663195,
        1683407248,
        1315562145,
        1080094634,
        1383856311,
        1551037884,
        101039829,
        135050206,
        437757123,
        337553864,
        1042385657,
        807962610,
        573804783,
        742039012,
        2531067453,
        2564033334,
        2328828971,
        2227573024,
        2935566865,
        2700099354,
        3001755655,
        3168937228,
        3868552805,
        3902563182,
        4203181171,
        4102977912,
        3736164937,
        3501741890,
        3265478751,
        3433712980,
        1106041591,
        1340463100,
        1576976609,
        1408749034,
        2043211483,
        2009195472,
        1708848333,
        1809054150,
        832877231,
        1068351396,
        766945465,
        599762354,
        159417987,
        126454664,
        361929877,
        463180190,
        2709260871,
        2943682380,
        3178106961,
        3009879386,
        2572697195,
        2538681184,
        2236228733,
        2336434550,
        3509871135,
        3745345300,
        3441850377,
        3274667266,
        3910161971,
        3877198648,
        4110568485,
        4211818798,
        2597806476,
        2497604743,
        2261089178,
        2295101073,
        2733856160,
        2902087851,
        3202437046,
        2968011453,
        3936291284,
        3835036895,
        4136440770,
        4169408201,
        3535486456,
        3702665459,
        3467192302,
        3231722213,
        2051518780,
        1951317047,
        1716890410,
        1750902305,
        1113818384,
        1282050075,
        1584504582,
        1350078989,
        168810852,
        67556463,
        371049330,
        404016761,
        841739592,
        1008918595,
        775550814,
        540080725,
        3969562369,
        3801332234,
        4035489047,
        4269907996,
        3569255213,
        3669462566,
        3366754619,
        3332740144,
        2631065433,
        2463879762,
        2160117071,
        2395588676,
        2767645557,
        2868897406,
        3102011747,
        3069049960,
        202008497,
        33778362,
        270040487,
        504459436,
        875451293,
        975658646,
        675039627,
        641025152,
        2084704233,
        1917518562,
        1615861247,
        1851332852,
        1147550661,
        1248802510,
        1484005843,
        1451044056,
        933301370,
        967311729,
        733156972,
        632953703,
        260388950,
        25965917,
        328671808,
        496906059,
        1206477858,
        1239443753,
        1543208500,
        1441952575,
        2144161806,
        1908694277,
        1675577880,
        1842759443,
        3610369226,
        3644379585,
        3408119516,
        3307916247,
        4011190502,
        3776767469,
        4077384432,
        4245618683,
        2809771154,
        2842737049,
        3144396420,
        3043140495,
        2673705150,
        2438237621,
        2203032232,
        2370213795
      ]);
      this._mixCol = new Uint8Array(256);
      for (let e2 = 0; e2 < 256; e2++) this._mixCol[e2] = e2 < 128 ? e2 << 1 : e2 << 1 ^ 27;
      this.buffer = new Uint8Array(16);
      this.bufferPosition = 0;
    }
    _expandKey(e2) {
      unreachable("Cannot call `_expandKey` on the base class");
    }
    _decrypt(e2, t2) {
      let i2, a2, r2;
      const s2 = new Uint8Array(16);
      s2.set(e2);
      for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3) s2[e3] ^= t2[i3];
      for (let e3 = this._cyclesOfRepetition - 1; e3 >= 1; --e3) {
        i2 = s2[13];
        s2[13] = s2[9];
        s2[9] = s2[5];
        s2[5] = s2[1];
        s2[1] = i2;
        i2 = s2[14];
        a2 = s2[10];
        s2[14] = s2[6];
        s2[10] = s2[2];
        s2[6] = i2;
        s2[2] = a2;
        i2 = s2[15];
        a2 = s2[11];
        r2 = s2[7];
        s2[15] = s2[3];
        s2[11] = i2;
        s2[7] = a2;
        s2[3] = r2;
        for (let e4 = 0; e4 < 16; ++e4) s2[e4] = this._inv_s[s2[e4]];
        for (let i3 = 0, a3 = 16 * e3; i3 < 16; ++i3, ++a3) s2[i3] ^= t2[a3];
        for (let e4 = 0; e4 < 16; e4 += 4) {
          const t3 = this._mix[s2[e4]], a3 = this._mix[s2[e4 + 1]], r3 = this._mix[s2[e4 + 2]], n2 = this._mix[s2[e4 + 3]];
          i2 = t3 ^ a3 >>> 8 ^ a3 << 24 ^ r3 >>> 16 ^ r3 << 16 ^ n2 >>> 24 ^ n2 << 8;
          s2[e4] = i2 >>> 24 & 255;
          s2[e4 + 1] = i2 >> 16 & 255;
          s2[e4 + 2] = i2 >> 8 & 255;
          s2[e4 + 3] = 255 & i2;
        }
      }
      i2 = s2[13];
      s2[13] = s2[9];
      s2[9] = s2[5];
      s2[5] = s2[1];
      s2[1] = i2;
      i2 = s2[14];
      a2 = s2[10];
      s2[14] = s2[6];
      s2[10] = s2[2];
      s2[6] = i2;
      s2[2] = a2;
      i2 = s2[15];
      a2 = s2[11];
      r2 = s2[7];
      s2[15] = s2[3];
      s2[11] = i2;
      s2[7] = a2;
      s2[3] = r2;
      for (let e3 = 0; e3 < 16; ++e3) {
        s2[e3] = this._inv_s[s2[e3]];
        s2[e3] ^= t2[e3];
      }
      return s2;
    }
    _encrypt(e2, t2) {
      const i2 = this._s;
      let a2, r2, s2;
      const n2 = new Uint8Array(16);
      n2.set(e2);
      for (let e3 = 0; e3 < 16; ++e3) n2[e3] ^= t2[e3];
      for (let e3 = 1; e3 < this._cyclesOfRepetition; e3++) {
        for (let e4 = 0; e4 < 16; ++e4) n2[e4] = i2[n2[e4]];
        s2 = n2[1];
        n2[1] = n2[5];
        n2[5] = n2[9];
        n2[9] = n2[13];
        n2[13] = s2;
        s2 = n2[2];
        r2 = n2[6];
        n2[2] = n2[10];
        n2[6] = n2[14];
        n2[10] = s2;
        n2[14] = r2;
        s2 = n2[3];
        r2 = n2[7];
        a2 = n2[11];
        n2[3] = n2[15];
        n2[7] = s2;
        n2[11] = r2;
        n2[15] = a2;
        for (let e4 = 0; e4 < 16; e4 += 4) {
          const t3 = n2[e4 + 0], i3 = n2[e4 + 1], r3 = n2[e4 + 2], s3 = n2[e4 + 3];
          a2 = t3 ^ i3 ^ r3 ^ s3;
          n2[e4 + 0] ^= a2 ^ this._mixCol[t3 ^ i3];
          n2[e4 + 1] ^= a2 ^ this._mixCol[i3 ^ r3];
          n2[e4 + 2] ^= a2 ^ this._mixCol[r3 ^ s3];
          n2[e4 + 3] ^= a2 ^ this._mixCol[s3 ^ t3];
        }
        for (let i3 = 0, a3 = 16 * e3; i3 < 16; ++i3, ++a3) n2[i3] ^= t2[a3];
      }
      for (let e3 = 0; e3 < 16; ++e3) n2[e3] = i2[n2[e3]];
      s2 = n2[1];
      n2[1] = n2[5];
      n2[5] = n2[9];
      n2[9] = n2[13];
      n2[13] = s2;
      s2 = n2[2];
      r2 = n2[6];
      n2[2] = n2[10];
      n2[6] = n2[14];
      n2[10] = s2;
      n2[14] = r2;
      s2 = n2[3];
      r2 = n2[7];
      a2 = n2[11];
      n2[3] = n2[15];
      n2[7] = s2;
      n2[11] = r2;
      n2[15] = a2;
      for (let e3 = 0, i3 = this._keySize; e3 < 16; ++e3, ++i3) n2[e3] ^= t2[i3];
      return n2;
    }
    _decryptBlock2(e2, t2) {
      const i2 = e2.length;
      let a2 = this.buffer, r2 = this.bufferPosition;
      const s2 = [];
      let n2 = this.iv;
      for (let t3 = 0; t3 < i2; ++t3) {
        a2[r2] = e2[t3];
        ++r2;
        if (r2 < 16) continue;
        const i3 = this._decrypt(a2, this._key);
        for (let e3 = 0; e3 < 16; ++e3) i3[e3] ^= n2[e3];
        n2 = a2;
        s2.push(i3);
        a2 = new Uint8Array(16);
        r2 = 0;
      }
      this.buffer = a2;
      this.bufferLength = r2;
      this.iv = n2;
      if (0 === s2.length) return new Uint8Array(0);
      let o2 = 16 * s2.length;
      if (t2) {
        const e3 = s2.at(-1);
        let t3 = e3[15];
        if (t3 <= 16) {
          for (let i3 = 15, a3 = 16 - t3; i3 >= a3; --i3) if (e3[i3] !== t3) {
            t3 = 0;
            break;
          }
          o2 -= t3;
          s2[s2.length - 1] = e3.subarray(0, 16 - t3);
        }
      }
      const g2 = new Uint8Array(o2);
      for (let e3 = 0, t3 = 0, i3 = s2.length; e3 < i3; ++e3, t3 += 16) g2.set(s2[e3], t3);
      return g2;
    }
    decryptBlock(e2, t2, i2 = null) {
      const a2 = e2.length, r2 = this.buffer;
      let s2 = this.bufferPosition;
      if (i2) this.iv = i2;
      else {
        for (let t3 = 0; s2 < 16 && t3 < a2; ++t3, ++s2) r2[s2] = e2[t3];
        if (s2 < 16) {
          this.bufferLength = s2;
          return new Uint8Array(0);
        }
        this.iv = r2;
        e2 = e2.subarray(16);
      }
      this.buffer = new Uint8Array(16);
      this.bufferLength = 0;
      this.decryptBlock = this._decryptBlock2;
      return this.decryptBlock(e2, t2);
    }
    encrypt(e2, t2) {
      const i2 = e2.length;
      let a2 = this.buffer, r2 = this.bufferPosition;
      const s2 = [];
      t2 || (t2 = new Uint8Array(16));
      for (let n3 = 0; n3 < i2; ++n3) {
        a2[r2] = e2[n3];
        ++r2;
        if (r2 < 16) continue;
        for (let e3 = 0; e3 < 16; ++e3) a2[e3] ^= t2[e3];
        const i3 = this._encrypt(a2, this._key);
        t2 = i3;
        s2.push(i3);
        a2 = new Uint8Array(16);
        r2 = 0;
      }
      this.buffer = a2;
      this.bufferLength = r2;
      this.iv = t2;
      if (0 === s2.length) return new Uint8Array(0);
      const n2 = 16 * s2.length, o2 = new Uint8Array(n2);
      for (let e3 = 0, t3 = 0, i3 = s2.length; e3 < i3; ++e3, t3 += 16) o2.set(s2[e3], t3);
      return o2;
    }
  }
  class AES128Cipher extends AESBaseCipher {
    constructor(e2) {
      super();
      this._cyclesOfRepetition = 10;
      this._keySize = 160;
      this._rcon = new Uint8Array([
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141,
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145,
        57,
        114,
        228,
        211,
        189,
        97,
        194,
        159,
        37,
        74,
        148,
        51,
        102,
        204,
        131,
        29,
        58,
        116,
        232,
        203,
        141
      ]);
      this._key = this._expandKey(e2);
    }
    _expandKey(e2) {
      const t2 = this._s, i2 = this._rcon, a2 = new Uint8Array(176);
      a2.set(e2);
      for (let e3 = 16, r2 = 1; e3 < 176; ++r2) {
        let s2 = a2[e3 - 3], n2 = a2[e3 - 2], o2 = a2[e3 - 1], g2 = a2[e3 - 4];
        s2 = t2[s2];
        n2 = t2[n2];
        o2 = t2[o2];
        g2 = t2[g2];
        s2 ^= i2[r2];
        for (let t3 = 0; t3 < 4; ++t3) {
          a2[e3] = s2 ^= a2[e3 - 16];
          e3++;
          a2[e3] = n2 ^= a2[e3 - 16];
          e3++;
          a2[e3] = o2 ^= a2[e3 - 16];
          e3++;
          a2[e3] = g2 ^= a2[e3 - 16];
          e3++;
        }
      }
      return a2;
    }
  }
  class AES256Cipher extends AESBaseCipher {
    constructor(e2) {
      super();
      this._cyclesOfRepetition = 14;
      this._keySize = 224;
      this._key = this._expandKey(e2);
    }
    _expandKey(e2) {
      const t2 = this._s, i2 = new Uint8Array(240);
      i2.set(e2);
      let a2, r2, s2, n2, o2 = 1;
      for (let e3 = 32, g2 = 1; e3 < 240; ++g2) {
        if (e3 % 32 == 16) {
          a2 = t2[a2];
          r2 = t2[r2];
          s2 = t2[s2];
          n2 = t2[n2];
        } else if (e3 % 32 == 0) {
          a2 = i2[e3 - 3];
          r2 = i2[e3 - 2];
          s2 = i2[e3 - 1];
          n2 = i2[e3 - 4];
          a2 = t2[a2];
          r2 = t2[r2];
          s2 = t2[s2];
          n2 = t2[n2];
          a2 ^= o2;
          (o2 <<= 1) >= 256 && (o2 = 255 & (27 ^ o2));
        }
        for (let t3 = 0; t3 < 4; ++t3) {
          i2[e3] = a2 ^= i2[e3 - 32];
          e3++;
          i2[e3] = r2 ^= i2[e3 - 32];
          e3++;
          i2[e3] = s2 ^= i2[e3 - 32];
          e3++;
          i2[e3] = n2 ^= i2[e3 - 32];
          e3++;
        }
      }
      return i2;
    }
  }
  class PDF17 {
    checkOwnerPassword(e2, t2, i2, a2) {
      const r2 = new Uint8Array(e2.length + 56);
      r2.set(e2, 0);
      r2.set(t2, e2.length);
      r2.set(i2, e2.length + t2.length);
      return isArrayEqual(Or(r2, 0, r2.length), a2);
    }
    checkUserPassword(e2, t2, i2) {
      const a2 = new Uint8Array(e2.length + 8);
      a2.set(e2, 0);
      a2.set(t2, e2.length);
      return isArrayEqual(Or(a2, 0, a2.length), i2);
    }
    getOwnerKey(e2, t2, i2, a2) {
      const r2 = new Uint8Array(e2.length + 56);
      r2.set(e2, 0);
      r2.set(t2, e2.length);
      r2.set(i2, e2.length + t2.length);
      const s2 = Or(r2, 0, r2.length);
      return new AES256Cipher(s2).decryptBlock(a2, false, new Uint8Array(16));
    }
    getUserKey(e2, t2, i2) {
      const a2 = new Uint8Array(e2.length + 8);
      a2.set(e2, 0);
      a2.set(t2, e2.length);
      const r2 = Or(a2, 0, a2.length);
      return new AES256Cipher(r2).decryptBlock(i2, false, new Uint8Array(16));
    }
  }
  class PDF20 {
    _hash(e2, t2, i2) {
      let a2 = Or(t2, 0, t2.length).subarray(0, 32), r2 = [
        0
      ], s2 = 0;
      for (; s2 < 64 || r2.at(-1) > s2 - 32; ) {
        const t3 = e2.length + a2.length + i2.length, c2 = new Uint8Array(t3);
        let C2 = 0;
        c2.set(e2, C2);
        C2 += e2.length;
        c2.set(a2, C2);
        C2 += a2.length;
        c2.set(i2, C2);
        const h2 = new Uint8Array(64 * t3);
        for (let e3 = 0, i3 = 0; e3 < 64; e3++, i3 += t3) h2.set(c2, i3);
        r2 = new AES128Cipher(a2.subarray(0, 16)).encrypt(h2, a2.subarray(16, 32));
        const l2 = r2.slice(0, 16).reduce((e3, t4) => e3 + t4, 0) % 3;
        0 === l2 ? a2 = Or(r2, 0, r2.length) : 1 === l2 ? a2 = (n2 = r2, o2 = 0, g2 = r2.length, Pr(n2, o2, g2, true)) : 2 === l2 && (a2 = Pr(r2, 0, r2.length));
        s2++;
      }
      var n2, o2, g2;
      return a2.subarray(0, 32);
    }
    checkOwnerPassword(e2, t2, i2, a2) {
      const r2 = new Uint8Array(e2.length + 56);
      r2.set(e2, 0);
      r2.set(t2, e2.length);
      r2.set(i2, e2.length + t2.length);
      return isArrayEqual(this._hash(e2, r2, i2), a2);
    }
    checkUserPassword(e2, t2, i2) {
      const a2 = new Uint8Array(e2.length + 8);
      a2.set(e2, 0);
      a2.set(t2, e2.length);
      return isArrayEqual(this._hash(e2, a2, []), i2);
    }
    getOwnerKey(e2, t2, i2, a2) {
      const r2 = new Uint8Array(e2.length + 56);
      r2.set(e2, 0);
      r2.set(t2, e2.length);
      r2.set(i2, e2.length + t2.length);
      const s2 = this._hash(e2, r2, i2);
      return new AES256Cipher(s2).decryptBlock(a2, false, new Uint8Array(16));
    }
    getUserKey(e2, t2, i2) {
      const a2 = new Uint8Array(e2.length + 8);
      a2.set(e2, 0);
      a2.set(t2, e2.length);
      const r2 = this._hash(e2, a2, []);
      return new AES256Cipher(r2).decryptBlock(i2, false, new Uint8Array(16));
    }
  }
  class CipherTransform {
    constructor(e2, t2) {
      this.StringCipherConstructor = e2;
      this.StreamCipherConstructor = t2;
    }
    createStream(e2, t2) {
      const i2 = new this.StreamCipherConstructor();
      return new DecryptStream(e2, t2, function cipherTransformDecryptStream(e3, t3) {
        return i2.decryptBlock(e3, t3);
      });
    }
    decryptString(e2) {
      const t2 = new this.StringCipherConstructor();
      let i2 = stringToBytes(e2);
      i2 = t2.decryptBlock(i2, true);
      return bytesToString(i2);
    }
    encryptString(e2) {
      const t2 = new this.StringCipherConstructor();
      if (t2 instanceof AESBaseCipher) {
        const i3 = 16 - e2.length % 16;
        e2 += String.fromCharCode(i3).repeat(i3);
        const a2 = new Uint8Array(16);
        if ("undefined" != typeof crypto) crypto.getRandomValues(a2);
        else for (let e3 = 0; e3 < 16; e3++) a2[e3] = Math.floor(256 * Math.random());
        let r2 = stringToBytes(e2);
        r2 = t2.encrypt(r2, a2);
        const s2 = new Uint8Array(16 + r2.length);
        s2.set(a2);
        s2.set(r2, 16);
        return bytesToString(s2);
      }
      let i2 = stringToBytes(e2);
      i2 = t2.encrypt(i2);
      return bytesToString(i2);
    }
  }
  const _CipherTransformFactory = class _CipherTransformFactory {
    constructor(e2, t2, i2) {
      __privateAdd(this, _CipherTransformFactory_instances);
      const a2 = e2.get("Filter");
      if (!isName(a2, "Standard")) throw new FormatError("unknown encryption method");
      this.filterName = a2.name;
      this.dict = e2;
      const r2 = e2.get("V");
      if (!Number.isInteger(r2) || 1 !== r2 && 2 !== r2 && 4 !== r2 && 5 !== r2) throw new FormatError("unsupported encryption algorithm");
      this.algorithm = r2;
      let s2 = e2.get("Length");
      if (!s2) if (r2 <= 3) s2 = 40;
      else {
        const t3 = e2.get("CF"), i3 = e2.get("StmF");
        if (t3 instanceof Dict && i3 instanceof Name) {
          t3.suppressEncryption = true;
          const e3 = t3.get(i3.name);
          s2 = (e3 == null ? void 0 : e3.get("Length")) || 128;
          s2 < 40 && (s2 <<= 3);
        }
      }
      if (!Number.isInteger(s2) || s2 < 40 || s2 % 8 != 0) throw new FormatError("invalid key length");
      const n2 = stringToBytes(e2.get("O")), o2 = stringToBytes(e2.get("U")), g2 = n2.subarray(0, 32), c2 = o2.subarray(0, 32), C2 = e2.get("P"), h2 = e2.get("R"), l2 = (4 === r2 || 5 === r2) && false !== e2.get("EncryptMetadata");
      this.encryptMetadata = l2;
      const Q2 = stringToBytes(t2);
      let E2, u2;
      if (i2) {
        if (6 === h2) try {
          i2 = utf8StringToString(i2);
        } catch {
          warn("CipherTransformFactory: Unable to convert UTF8 encoded password.");
        }
        E2 = stringToBytes(i2);
      }
      if (5 !== r2) u2 = __privateMethod(this, _CipherTransformFactory_instances, M_fn).call(this, Q2, E2, g2, c2, C2, h2, s2, l2);
      else {
        const t3 = n2.subarray(32, 40), i3 = n2.subarray(40, 48), a3 = o2.subarray(0, 48), r3 = o2.subarray(32, 40), s3 = o2.subarray(40, 48), C3 = stringToBytes(e2.get("OE")), l3 = stringToBytes(e2.get("UE")), Q3 = stringToBytes(e2.get("Perms"));
        u2 = __privateMethod(this, _CipherTransformFactory_instances, U_fn).call(this, h2, E2, g2, t3, i3, a3, c2, r3, s3, C3, l3, Q3);
      }
      if (!u2 && !i2) throw new PasswordException("No password given", nt);
      if (!u2 && i2) {
        const e3 = __privateMethod(this, _CipherTransformFactory_instances, L_fn).call(this, E2, g2, h2, s2);
        u2 = __privateMethod(this, _CipherTransformFactory_instances, M_fn).call(this, Q2, e3, g2, c2, C2, h2, s2, l2);
      }
      if (!u2) throw new PasswordException("Incorrect Password", ot);
      this.encryptionKey = u2;
      if (r2 >= 4) {
        const t3 = e2.get("CF");
        t3 instanceof Dict && (t3.suppressEncryption = true);
        this.cf = t3;
        this.stmf = e2.get("StmF") || Name.get("Identity");
        this.strf = e2.get("StrF") || Name.get("Identity");
        this.eff = e2.get("EFF") || this.stmf;
      }
    }
    createCipherTransform(e2, t2) {
      if (4 === this.algorithm || 5 === this.algorithm) return new CipherTransform(__privateMethod(this, _CipherTransformFactory_instances, J_fn).call(this, this.cf, this.strf, e2, t2, this.encryptionKey), __privateMethod(this, _CipherTransformFactory_instances, J_fn).call(this, this.cf, this.stmf, e2, t2, this.encryptionKey));
      const i2 = __privateMethod(this, _CipherTransformFactory_instances, H_fn).call(this, e2, t2, this.encryptionKey, false), cipherConstructor = function() {
        return new ARCFourCipher(i2);
      };
      return new CipherTransform(cipherConstructor, cipherConstructor);
    }
  };
  _x = new WeakMap();
  _CipherTransformFactory_instances = new WeakSet();
  U_fn = function(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2, C2, h2) {
    if (t2) {
      const e3 = Math.min(127, t2.length);
      t2 = t2.subarray(0, e3);
    } else t2 = [];
    const l2 = 6 === e2 ? new PDF20() : new PDF17();
    return l2.checkUserPassword(t2, o2, n2) ? l2.getUserKey(t2, g2, C2) : t2.length && l2.checkOwnerPassword(t2, a2, s2, i2) ? l2.getOwnerKey(t2, r2, s2, c2) : null;
  };
  M_fn = function(e2, t2, i2, a2, r2, s2, n2, o2) {
    const g2 = 40 + i2.length + e2.length, c2 = new Uint8Array(g2);
    let C2, h2, l2 = 0;
    if (t2) {
      h2 = Math.min(32, t2.length);
      for (; l2 < h2; ++l2) c2[l2] = t2[l2];
    }
    C2 = 0;
    for (; l2 < 32; ) c2[l2++] = __privateGet(_CipherTransformFactory, _x)[C2++];
    for (C2 = 0, h2 = i2.length; C2 < h2; ++C2) c2[l2++] = i2[C2];
    c2[l2++] = 255 & r2;
    c2[l2++] = r2 >> 8 & 255;
    c2[l2++] = r2 >> 16 & 255;
    c2[l2++] = r2 >>> 24 & 255;
    for (C2 = 0, h2 = e2.length; C2 < h2; ++C2) c2[l2++] = e2[C2];
    if (s2 >= 4 && !o2) {
      c2[l2++] = 255;
      c2[l2++] = 255;
      c2[l2++] = 255;
      c2[l2++] = 255;
    }
    let Q2 = qr(c2, 0, l2);
    const E2 = n2 >> 3;
    if (s2 >= 3) for (C2 = 0; C2 < 50; ++C2) Q2 = qr(Q2, 0, E2);
    const u2 = Q2.subarray(0, E2);
    let d2, f2;
    if (s2 >= 3) {
      for (l2 = 0; l2 < 32; ++l2) c2[l2] = __privateGet(_CipherTransformFactory, _x)[l2];
      for (C2 = 0, h2 = e2.length; C2 < h2; ++C2) c2[l2++] = e2[C2];
      d2 = new ARCFourCipher(u2);
      f2 = d2.encryptBlock(qr(c2, 0, l2));
      h2 = u2.length;
      const t3 = new Uint8Array(h2);
      for (C2 = 1; C2 <= 19; ++C2) {
        for (let e3 = 0; e3 < h2; ++e3) t3[e3] = u2[e3] ^ C2;
        d2 = new ARCFourCipher(t3);
        f2 = d2.encryptBlock(f2);
      }
      for (C2 = 0, h2 = f2.length; C2 < h2; ++C2) if (a2[C2] !== f2[C2]) return null;
    } else {
      d2 = new ARCFourCipher(u2);
      f2 = d2.encryptBlock(__privateGet(_CipherTransformFactory, _x));
      for (C2 = 0, h2 = f2.length; C2 < h2; ++C2) if (a2[C2] !== f2[C2]) return null;
    }
    return u2;
  };
  L_fn = function(e2, t2, i2, a2) {
    const r2 = new Uint8Array(32);
    let s2 = 0;
    const n2 = Math.min(32, e2.length);
    for (; s2 < n2; ++s2) r2[s2] = e2[s2];
    let o2 = 0;
    for (; s2 < 32; ) r2[s2++] = __privateGet(_CipherTransformFactory, _x)[o2++];
    let g2 = qr(r2, 0, s2);
    const c2 = a2 >> 3;
    if (i2 >= 3) for (o2 = 0; o2 < 50; ++o2) g2 = qr(g2, 0, g2.length);
    let C2, h2;
    if (i2 >= 3) {
      h2 = t2;
      const e3 = new Uint8Array(c2);
      for (o2 = 19; o2 >= 0; o2--) {
        for (let t3 = 0; t3 < c2; ++t3) e3[t3] = g2[t3] ^ o2;
        C2 = new ARCFourCipher(e3);
        h2 = C2.encryptBlock(h2);
      }
    } else {
      C2 = new ARCFourCipher(g2.subarray(0, c2));
      h2 = C2.encryptBlock(t2);
    }
    return h2;
  };
  H_fn = function(e2, t2, i2, a2 = false) {
    const r2 = new Uint8Array(i2.length + 9), s2 = i2.length;
    let n2;
    for (n2 = 0; n2 < s2; ++n2) r2[n2] = i2[n2];
    r2[n2++] = 255 & e2;
    r2[n2++] = e2 >> 8 & 255;
    r2[n2++] = e2 >> 16 & 255;
    r2[n2++] = 255 & t2;
    r2[n2++] = t2 >> 8 & 255;
    if (a2) {
      r2[n2++] = 115;
      r2[n2++] = 65;
      r2[n2++] = 108;
      r2[n2++] = 84;
    }
    return qr(r2, 0, n2).subarray(0, Math.min(i2.length + 5, 16));
  };
  J_fn = function(e2, t2, i2, a2, r2) {
    if (!(t2 instanceof Name)) throw new FormatError("Invalid crypt filter name.");
    const s2 = this, n2 = e2.get(t2.name), o2 = n2 == null ? void 0 : n2.get("CFM");
    if (!o2 || "None" === o2.name) return function() {
      return new NullCipher();
    };
    if ("V2" === o2.name) return function() {
      var _a4;
      return new ARCFourCipher(__privateMethod(_a4 = s2, _CipherTransformFactory_instances, H_fn).call(_a4, i2, a2, r2, false));
    };
    if ("AESV2" === o2.name) return function() {
      var _a4;
      return new AES128Cipher(__privateMethod(_a4 = s2, _CipherTransformFactory_instances, H_fn).call(_a4, i2, a2, r2, true));
    };
    if ("AESV3" === o2.name) return function() {
      return new AES256Cipher(r2);
    };
    throw new FormatError("Unknown crypto method");
  };
  __privateAdd(_CipherTransformFactory, _x, new Uint8Array([
    40,
    191,
    78,
    94,
    78,
    117,
    138,
    65,
    100,
    0,
    78,
    86,
    255,
    250,
    1,
    8,
    46,
    46,
    0,
    182,
    208,
    104,
    62,
    128,
    47,
    12,
    169,
    254,
    100,
    83,
    105,
    122
  ]));
  let CipherTransformFactory = _CipherTransformFactory;
  async function writeObject(e2, t2, i2, { encrypt: a2 = null }) {
    const r2 = a2 == null ? void 0 : a2.createCipherTransform(e2.num, e2.gen);
    i2.push(`${e2.num} ${e2.gen} obj
`);
    t2 instanceof Dict ? await writeDict(t2, i2, r2) : t2 instanceof BaseStream ? await writeStream(t2, i2, r2) : (Array.isArray(t2) || ArrayBuffer.isView(t2)) && await writeArray(t2, i2, r2);
    i2.push("\nendobj\n");
  }
  async function writeDict(e2, t2, i2) {
    t2.push("<<");
    for (const a2 of e2.getKeys()) {
      t2.push(` /${escapePDFName(a2)} `);
      await writeValue(e2.getRaw(a2), t2, i2);
    }
    t2.push(">>");
  }
  async function writeStream(e2, t2, i2) {
    let a2 = e2.getBytes();
    const { dict: r2 } = e2, [s2, n2] = await Promise.all([
      r2.getAsync("Filter"),
      r2.getAsync("DecodeParms")
    ]), o2 = isName(Array.isArray(s2) ? await r2.xref.fetchIfRefAsync(s2[0]) : s2, "FlateDecode");
    if (a2.length >= 256 || o2) try {
      const e3 = new CompressionStream("deflate"), t3 = e3.writable.getWriter();
      await t3.ready;
      t3.write(a2).then(async () => {
        await t3.ready;
        await t3.close();
      }).catch(() => {
      });
      const i3 = await new Response(e3.readable).arrayBuffer();
      a2 = new Uint8Array(i3);
      let g3, c2;
      if (s2) {
        if (!o2) {
          g3 = Array.isArray(s2) ? [
            Name.get("FlateDecode"),
            ...s2
          ] : [
            Name.get("FlateDecode"),
            s2
          ];
          n2 && (c2 = Array.isArray(n2) ? [
            null,
            ...n2
          ] : [
            null,
            n2
          ]);
        }
      } else g3 = Name.get("FlateDecode");
      g3 && r2.set("Filter", g3);
      c2 && r2.set("DecodeParms", c2);
    } catch (e3) {
      info(`writeStream - cannot compress data: "${e3}".`);
    }
    let g2 = bytesToString(a2);
    i2 && (g2 = i2.encryptString(g2));
    r2.set("Length", g2.length);
    await writeDict(r2, t2, i2);
    t2.push(" stream\n", g2, "\nendstream");
  }
  async function writeArray(e2, t2, i2) {
    t2.push("[");
    let a2 = true;
    for (const r2 of e2) {
      a2 ? a2 = false : t2.push(" ");
      await writeValue(r2, t2, i2);
    }
    t2.push("]");
  }
  async function writeValue(e2, t2, i2) {
    if (e2 instanceof Name) t2.push(`/${escapePDFName(e2.name)}`);
    else if (e2 instanceof Ref) t2.push(`${e2.num} ${e2.gen} R`);
    else if (Array.isArray(e2) || ArrayBuffer.isView(e2)) await writeArray(e2, t2, i2);
    else if ("string" == typeof e2) {
      i2 && (e2 = i2.encryptString(e2));
      t2.push(`(${escapeString(e2)})`);
    } else "number" == typeof e2 ? t2.push(numberToString(e2)) : "boolean" == typeof e2 ? t2.push(e2.toString()) : e2 instanceof Dict ? await writeDict(e2, t2, i2) : e2 instanceof BaseStream ? await writeStream(e2, t2, i2) : null === e2 ? t2.push("null") : warn(`Unhandled value in writer: ${typeof e2}, please file a bug.`);
  }
  function writeInt(e2, t2, i2, a2) {
    for (let r2 = t2 + i2 - 1; r2 > i2 - 1; r2--) {
      a2[r2] = 255 & e2;
      e2 >>= 8;
    }
    return i2 + t2;
  }
  function writeString(e2, t2, i2) {
    for (let a2 = 0, r2 = e2.length; a2 < r2; a2++) i2[t2 + a2] = 255 & e2.charCodeAt(a2);
  }
  function updateXFA({ xfaData: e2, xfaDatasetsRef: t2, newRefs: i2, xref: a2 }) {
    if (null === e2) {
      e2 = function writeXFADataForAcroform(e3, t3) {
        const i3 = new SimpleXMLParser({
          hasAttributes: true
        }).parseFromString(e3);
        for (const { xfa: e4 } of t3) {
          if (!e4) continue;
          const { path: t4, value: a4 } = e4;
          if (!t4) continue;
          const r3 = parseXFAPath(t4);
          let s3 = i3.documentElement.searchNode(r3, 0);
          !s3 && r3.length > 1 && (s3 = i3.documentElement.searchNode([
            r3.at(-1)
          ], 0));
          s3 ? s3.childNodes = Array.isArray(a4) ? a4.map((e5) => new SimpleDOMNode("value", e5)) : [
            new SimpleDOMNode("#text", a4)
          ] : warn(`Node not found for path: ${t4}`);
        }
        const a3 = [];
        i3.documentElement.dump(a3);
        return a3.join("");
      }(a2.fetchIfRef(t2).getString(), i2);
    }
    const r2 = a2.encrypt;
    if (r2) {
      e2 = r2.createCipherTransform(t2.num, t2.gen).encryptString(e2);
    }
    const s2 = `${t2.num} ${t2.gen} obj
<< /Type /EmbeddedFile /Length ${e2.length}>>
stream
` + e2 + "\nendstream\nendobj\n";
    i2.push({
      ref: t2,
      data: s2
    });
  }
  function getIndexes(e2) {
    const t2 = [];
    for (const { ref: i2 } of e2) i2.num === t2.at(-2) + t2.at(-1) ? t2[t2.length - 1] += 1 : t2.push(i2.num, 1);
    return t2;
  }
  function computeIDs(e2, t2, i2) {
    if (Array.isArray(t2.fileIds) && t2.fileIds.length > 0) {
      const a2 = function computeMD5(e3, t3) {
        const i3 = Math.floor(Date.now() / 1e3), a3 = t3.filename || "", r2 = [
          i3.toString(),
          a3,
          e3.toString()
        ];
        let s2 = r2.reduce((e4, t4) => e4 + t4.length, 0);
        for (const e4 of Object.values(t3.info)) {
          r2.push(e4);
          s2 += e4.length;
        }
        const n2 = new Uint8Array(s2);
        let o2 = 0;
        for (const e4 of r2) {
          writeString(e4, o2, n2);
          o2 += e4.length;
        }
        return bytesToString(qr(n2));
      }(e2, t2);
      i2.set("ID", [
        t2.fileIds[0],
        a2
      ]);
    }
  }
  async function incrementalUpdate({ originalData: e2, xrefInfo: t2, newRefs: i2, xref: a2 = null, hasXfa: r2 = false, xfaDatasetsRef: s2 = null, hasXfaDatasetsEntry: n2 = false, needAppearances: o2, acroFormRef: g2 = null, acroForm: c2 = null, xfaData: C2 = null, useXrefStream: h2 = false }) {
    await async function updateAcroform({ xref: e3, acroForm: t3, acroFormRef: i3, hasXfa: a3, hasXfaDatasetsEntry: r3, xfaDatasetsRef: s3, needAppearances: n3, newRefs: o3 }) {
      !a3 || r3 || s3 || warn("XFA - Cannot save it");
      if (!n3 && (!a3 || !s3 || r3)) return;
      const g3 = t3.clone();
      if (a3 && !r3) {
        const e4 = t3.get("XFA").slice();
        e4.splice(2, 0, "datasets");
        e4.splice(3, 0, s3);
        g3.set("XFA", e4);
      }
      n3 && g3.set("NeedAppearances", true);
      const c3 = [];
      await writeObject(i3, g3, c3, e3);
      o3.push({
        ref: i3,
        data: c3.join("")
      });
    }({
      xref: a2,
      acroForm: c2,
      acroFormRef: g2,
      hasXfa: r2,
      hasXfaDatasetsEntry: n2,
      xfaDatasetsRef: s2,
      needAppearances: o2,
      newRefs: i2
    });
    r2 && updateXFA({
      xfaData: C2,
      xfaDatasetsRef: s2,
      newRefs: i2,
      xref: a2
    });
    const l2 = [];
    let Q2 = e2.length;
    const E2 = e2.at(-1);
    if (10 !== E2 && 13 !== E2) {
      l2.push("\n");
      Q2 += 1;
    }
    const u2 = function getTrailerDict(e3, t3, i3) {
      const a3 = new Dict(null);
      a3.set("Prev", e3.startXRef);
      const r3 = e3.newRef;
      if (i3) {
        t3.push({
          ref: r3,
          data: ""
        });
        a3.set("Size", r3.num + 1);
        a3.set("Type", Name.get("XRef"));
      } else a3.set("Size", r3.num);
      null !== e3.rootRef && a3.set("Root", e3.rootRef);
      null !== e3.infoRef && a3.set("Info", e3.infoRef);
      null !== e3.encryptRef && a3.set("Encrypt", e3.encryptRef);
      return a3;
    }(t2, i2, h2);
    i2 = i2.sort((e3, t3) => e3.ref.num - t3.ref.num);
    for (const { data: e3 } of i2) null !== e3 && l2.push(e3);
    await (h2 ? async function getXRefStreamTable(e3, t3, i3, a3, r3) {
      const s3 = [];
      let n3 = 0, o3 = 0;
      for (const { ref: e4, data: a4 } of i3) {
        let i4;
        n3 = Math.max(n3, t3);
        if (null !== a4) {
          i4 = Math.min(e4.gen, 65535);
          s3.push([
            1,
            t3,
            i4
          ]);
          t3 += a4.length;
        } else {
          i4 = Math.min(e4.gen + 1, 65535);
          s3.push([
            0,
            0,
            i4
          ]);
        }
        o3 = Math.max(o3, i4);
      }
      a3.set("Index", getIndexes(i3));
      const g3 = [
        1,
        getSizeInBytes(n3),
        getSizeInBytes(o3)
      ];
      a3.set("W", g3);
      computeIDs(t3, e3, a3);
      const c3 = g3.reduce((e4, t4) => e4 + t4, 0), C3 = new Uint8Array(c3 * s3.length), h3 = new Stream(C3);
      h3.dict = a3;
      let l3 = 0;
      for (const [e4, t4, i4] of s3) {
        l3 = writeInt(e4, g3[0], l3, C3);
        l3 = writeInt(t4, g3[1], l3, C3);
        l3 = writeInt(i4, g3[2], l3, C3);
      }
      await writeObject(e3.newRef, h3, r3, {});
      r3.push("startxref\n", t3.toString(), "\n%%EOF\n");
    }(t2, Q2, i2, u2, l2) : async function getXRefTable(e3, t3, i3, a3, r3) {
      r3.push("xref\n");
      const s3 = getIndexes(i3);
      let n3 = 0;
      for (const { ref: e4, data: a4 } of i3) {
        if (e4.num === s3[n3]) {
          r3.push(`${s3[n3]} ${s3[n3 + 1]}
`);
          n3 += 2;
        }
        if (null !== a4) {
          r3.push(`${t3.toString().padStart(10, "0")} ${Math.min(e4.gen, 65535).toString().padStart(5, "0")} n\r
`);
          t3 += a4.length;
        } else r3.push(`0000000000 ${Math.min(e4.gen + 1, 65535).toString().padStart(5, "0")} f\r
`);
      }
      computeIDs(t3, e3, a3);
      r3.push("trailer\n");
      await writeDict(a3, r3);
      r3.push("\nstartxref\n", t3.toString(), "\n%%EOF\n");
    }(t2, Q2, i2, u2, l2));
    const d2 = l2.reduce((e3, t3) => e3 + t3.length, e2.length), f2 = new Uint8Array(d2);
    f2.set(e2);
    let p2 = e2.length;
    for (const e3 of l2) {
      writeString(e3, p2, f2);
      p2 += e3.length;
    }
    return f2;
  }
  const Wr = 1, jr = 2, Xr = 3, Zr = 4, Vr = 5;
  const _StructTreeRoot = class _StructTreeRoot {
    constructor(e2, t2) {
      __privateAdd(this, _StructTreeRoot_instances);
      this.dict = e2;
      this.ref = t2 instanceof Ref ? t2 : null;
      this.roleMap = /* @__PURE__ */ new Map();
      this.structParentIds = null;
    }
    init() {
      this.readRoleMap();
    }
    addAnnotationIdToPage(e2, t2) {
      __privateMethod(this, _StructTreeRoot_instances, v_fn).call(this, e2, t2, Zr);
    }
    readRoleMap() {
      const e2 = this.dict.get("RoleMap");
      e2 instanceof Dict && e2.forEach((e3, t2) => {
        t2 instanceof Name && this.roleMap.set(e3, t2.name);
      });
    }
    static async canCreateStructureTree({ catalogRef: e2, pdfManager: t2, newAnnotationsByPage: i2 }) {
      var _a4;
      if (!(e2 instanceof Ref)) {
        warn("Cannot save the struct tree: no catalog reference.");
        return false;
      }
      let a2 = 0, r2 = true;
      for (const [e3, s2] of i2) {
        const { ref: i3 } = await t2.getPage(e3);
        if (!(i3 instanceof Ref)) {
          warn(`Cannot save the struct tree: page ${e3} has no ref.`);
          r2 = true;
          break;
        }
        for (const e4 of s2) if ((_a4 = e4.accessibilityData) == null ? void 0 : _a4.type) {
          e4.parentTreeId = a2++;
          r2 = false;
        }
      }
      if (r2) {
        for (const e3 of i2.values()) for (const t3 of e3) delete t3.parentTreeId;
        return false;
      }
      return true;
    }
    static async createStructureTree({ newAnnotationsByPage: e2, xref: t2, catalogRef: i2, pdfManager: a2, newRefs: r2 }) {
      const s2 = a2.catalog.cloneDict(), n2 = new RefSetCache();
      n2.put(i2, s2);
      const o2 = t2.getNewTemporaryRef();
      s2.set("StructTreeRoot", o2);
      const g2 = new Dict(t2);
      g2.set("Type", Name.get("StructTreeRoot"));
      const c2 = t2.getNewTemporaryRef();
      g2.set("ParentTree", c2);
      const C2 = [];
      g2.set("K", C2);
      n2.put(o2, g2);
      const h2 = new Dict(t2), l2 = [];
      h2.set("Nums", l2);
      const Q2 = await __privateMethod(this, _StructTreeRoot_static, Y_fn).call(this, {
        newAnnotationsByPage: e2,
        structTreeRootRef: o2,
        structTreeRoot: null,
        kids: C2,
        nums: l2,
        xref: t2,
        pdfManager: a2,
        newRefs: r2,
        cache: n2
      });
      g2.set("ParentTreeNextKey", Q2);
      n2.put(c2, h2);
      const E2 = [];
      for (const [e3, i3] of n2.items()) {
        E2.length = 0;
        await writeObject(e3, i3, E2, t2);
        r2.push({
          ref: e3,
          data: E2.join("")
        });
      }
    }
    async canUpdateStructTree({ pdfManager: e2, xref: t2, newAnnotationsByPage: i2 }) {
      var _a4, _b;
      if (!this.ref) {
        warn("Cannot update the struct tree: no root reference.");
        return false;
      }
      let a2 = this.dict.get("ParentTreeNextKey");
      if (!Number.isInteger(a2) || a2 < 0) {
        warn("Cannot update the struct tree: invalid next key.");
        return false;
      }
      const r2 = this.dict.get("ParentTree");
      if (!(r2 instanceof Dict)) {
        warn("Cannot update the struct tree: ParentTree isn't a dict.");
        return false;
      }
      const s2 = r2.get("Nums");
      if (!Array.isArray(s2)) {
        warn("Cannot update the struct tree: nums isn't an array.");
        return false;
      }
      const n2 = new NumberTree(r2, t2);
      for (const t3 of i2.keys()) {
        const { pageDict: i3 } = await e2.getPage(t3);
        if (!i3.has("StructParents")) continue;
        const a3 = i3.get("StructParents");
        if (!Number.isInteger(a3) || !Array.isArray(n2.get(a3))) {
          warn(`Cannot save the struct tree: page ${t3} has a wrong id.`);
          return false;
        }
      }
      let o2 = true;
      for (const [t3, r3] of i2) {
        const { pageDict: i3 } = await e2.getPage(t3);
        __privateMethod(_a4 = _StructTreeRoot, _StructTreeRoot_static, T_fn).call(_a4, {
          elements: r3,
          xref: this.dict.xref,
          pageDict: i3,
          numberTree: n2
        });
        for (const e3 of r3) if ((_b = e3.accessibilityData) == null ? void 0 : _b.type) {
          e3.accessibilityData.structParent >= 0 || (e3.parentTreeId = a2++);
          o2 = false;
        }
      }
      if (o2) {
        for (const e3 of i2.values()) for (const t3 of e3) {
          delete t3.parentTreeId;
          delete t3.structTreeParent;
        }
        return false;
      }
      return true;
    }
    async updateStructureTree({ newAnnotationsByPage: e2, pdfManager: t2, newRefs: i2 }) {
      var _a4;
      const a2 = this.dict.xref, r2 = this.dict.clone(), s2 = this.ref, n2 = new RefSetCache();
      n2.put(s2, r2);
      let o2, g2 = r2.getRaw("ParentTree");
      if (g2 instanceof Ref) o2 = a2.fetch(g2);
      else {
        o2 = g2;
        g2 = a2.getNewTemporaryRef();
        r2.set("ParentTree", g2);
      }
      o2 = o2.clone();
      n2.put(g2, o2);
      let c2 = o2.getRaw("Nums"), C2 = null;
      if (c2 instanceof Ref) {
        C2 = c2;
        c2 = a2.fetch(C2);
      }
      c2 = c2.slice();
      C2 || o2.set("Nums", c2);
      const h2 = await __privateMethod(_a4 = _StructTreeRoot, _StructTreeRoot_static, Y_fn).call(_a4, {
        newAnnotationsByPage: e2,
        structTreeRootRef: s2,
        structTreeRoot: this,
        kids: null,
        nums: c2,
        xref: a2,
        pdfManager: t2,
        newRefs: i2,
        cache: n2
      });
      if (-1 === h2) return;
      r2.set("ParentTreeNextKey", h2);
      C2 && n2.put(C2, c2);
      const l2 = [];
      for (const [e3, t3] of n2.items()) {
        l2.length = 0;
        await writeObject(e3, t3, l2, a2);
        i2.push({
          ref: e3,
          data: l2.join("")
        });
      }
    }
  };
  _StructTreeRoot_instances = new WeakSet();
  v_fn = function(e2, t2, i2) {
    if (!(e2 instanceof Ref) || t2 < 0) return;
    this.structParentIds || (this.structParentIds = new RefSetCache());
    let a2 = this.structParentIds.get(e2);
    if (!a2) {
      a2 = [];
      this.structParentIds.put(e2, a2);
    }
    a2.push([
      t2,
      i2
    ]);
  };
  _StructTreeRoot_static = new WeakSet();
  Y_fn = async function({ newAnnotationsByPage: e2, structTreeRootRef: t2, structTreeRoot: i2, kids: a2, nums: r2, xref: s2, pdfManager: n2, newRefs: o2, cache: g2 }) {
    var _a4, _b;
    const c2 = Name.get("OBJR");
    let C2, h2 = -1;
    const l2 = [];
    for (const [Q2, E2] of e2) {
      const e3 = await n2.getPage(Q2), { ref: u2 } = e3, d2 = u2 instanceof Ref;
      for (const { accessibilityData: n3, ref: f2, parentTreeId: p2, structTreeParent: m2 } of E2) {
        if (!(n3 == null ? void 0 : n3.type)) continue;
        const { structParent: E3 } = n3;
        if (i2 && Number.isInteger(E3) && E3 >= 0) {
          let t3 = (C2 || (C2 = /* @__PURE__ */ new Map())).get(Q2);
          if (void 0 === t3) {
            t3 = new StructTreePage(i2, e3.pageDict).collectObjects(u2);
            C2.set(Q2, t3);
          }
          const a3 = t3 == null ? void 0 : t3.get(E3);
          if (a3) {
            const e4 = s2.fetch(a3).clone();
            __privateMethod(_a4 = _StructTreeRoot, _StructTreeRoot_static, K_fn).call(_a4, e4, n3);
            l2.length = 0;
            await writeObject(a3, e4, l2, s2);
            o2.push({
              ref: a3,
              data: l2.join("")
            });
            continue;
          }
        }
        h2 = Math.max(h2, p2);
        const y2 = s2.getNewTemporaryRef(), w2 = new Dict(s2);
        __privateMethod(_b = _StructTreeRoot, _StructTreeRoot_static, K_fn).call(_b, w2, n3);
        await __privateMethod(this, _StructTreeRoot_static, q_fn).call(this, {
          structTreeParent: m2,
          tagDict: w2,
          newTagRef: y2,
          structTreeRootRef: t2,
          fallbackKids: a2,
          xref: s2,
          cache: g2
        });
        const b2 = new Dict(s2);
        w2.set("K", b2);
        b2.set("Type", c2);
        d2 && b2.set("Pg", u2);
        b2.set("Obj", f2);
        g2.put(y2, w2);
        r2.push(p2, y2);
      }
    }
    return h2 + 1;
  };
  K_fn = function(e2, { type: t2, title: i2, lang: a2, alt: r2, expanded: s2, actualText: n2 }) {
    e2.set("S", Name.get(t2));
    i2 && e2.set("T", stringToAsciiOrUTF16BE(i2));
    a2 && e2.set("Lang", stringToAsciiOrUTF16BE(a2));
    r2 && e2.set("Alt", stringToAsciiOrUTF16BE(r2));
    s2 && e2.set("E", stringToAsciiOrUTF16BE(s2));
    n2 && e2.set("ActualText", stringToAsciiOrUTF16BE(n2));
  };
  T_fn = function({ elements: e2, xref: t2, pageDict: i2, numberTree: a2 }) {
    const r2 = /* @__PURE__ */ new Map();
    for (const t3 of e2) if (t3.structTreeParentId) {
      const e3 = parseInt(t3.structTreeParentId.split("_mc")[1], 10);
      let i3 = r2.get(e3);
      if (!i3) {
        i3 = [];
        r2.set(e3, i3);
      }
      i3.push(t3);
    }
    const s2 = i2.get("StructParents");
    if (!Number.isInteger(s2)) return;
    const n2 = a2.get(s2), updateElement = (e3, i3, a3) => {
      const s3 = r2.get(e3);
      if (s3) {
        const e4 = i3.getRaw("P"), r3 = t2.fetchIfRef(e4);
        if (e4 instanceof Ref && r3 instanceof Dict) {
          const e5 = {
            ref: a3,
            dict: i3
          };
          for (const t3 of s3) t3.structTreeParent = e5;
        }
        return true;
      }
      return false;
    };
    for (const e3 of n2) {
      if (!(e3 instanceof Ref)) continue;
      const i3 = t2.fetch(e3), a3 = i3.get("K");
      if (Number.isInteger(a3)) updateElement(a3, i3, e3);
      else if (Array.isArray(a3)) for (let r3 of a3) {
        r3 = t2.fetchIfRef(r3);
        if (Number.isInteger(r3) && updateElement(r3, i3, e3)) break;
        if (!(r3 instanceof Dict)) continue;
        if (!isName(r3.get("Type"), "MCR")) break;
        const a4 = r3.get("MCID");
        if (Number.isInteger(a4) && updateElement(a4, i3, e3)) break;
      }
    }
  };
  q_fn = async function({ structTreeParent: e2, tagDict: t2, newTagRef: i2, structTreeRootRef: a2, fallbackKids: r2, xref: s2, cache: n2 }) {
    let o2, g2 = null;
    if (e2) {
      ({ ref: g2 } = e2);
      o2 = e2.dict.getRaw("P") || a2;
    } else o2 = a2;
    t2.set("P", o2);
    const c2 = s2.fetchIfRef(o2);
    if (!c2) {
      r2.push(i2);
      return;
    }
    let C2 = n2.get(o2);
    if (!C2) {
      C2 = c2.clone();
      n2.put(o2, C2);
    }
    const h2 = C2.getRaw("K");
    let l2 = h2 instanceof Ref ? n2.get(h2) : null;
    if (!l2) {
      l2 = s2.fetchIfRef(h2);
      l2 = Array.isArray(l2) ? l2.slice() : [
        h2
      ];
      const e3 = s2.getNewTemporaryRef();
      C2.set("K", e3);
      n2.put(e3, l2);
    }
    const Q2 = l2.indexOf(g2);
    l2.splice(Q2 >= 0 ? Q2 + 1 : l2.length, 0, i2);
  };
  __privateAdd(_StructTreeRoot, _StructTreeRoot_static);
  let StructTreeRoot = _StructTreeRoot;
  class StructElementNode {
    constructor(e2, t2) {
      this.tree = e2;
      this.dict = t2;
      this.kids = [];
      this.parseKids();
    }
    get role() {
      const e2 = this.dict.get("S"), t2 = e2 instanceof Name ? e2.name : "", { root: i2 } = this.tree;
      return i2.roleMap.has(t2) ? i2.roleMap.get(t2) : t2;
    }
    parseKids() {
      let e2 = null;
      const t2 = this.dict.getRaw("Pg");
      t2 instanceof Ref && (e2 = t2.toString());
      const i2 = this.dict.get("K");
      if (Array.isArray(i2)) for (const t3 of i2) {
        const i3 = this.parseKid(e2, t3);
        i3 && this.kids.push(i3);
      }
      else {
        const t3 = this.parseKid(e2, i2);
        t3 && this.kids.push(t3);
      }
    }
    parseKid(e2, t2) {
      if (Number.isInteger(t2)) return this.tree.pageDict.objId !== e2 ? null : new StructElement({
        type: Wr,
        mcid: t2,
        pageObjId: e2
      });
      let i2 = null;
      t2 instanceof Ref ? i2 = this.dict.xref.fetch(t2) : t2 instanceof Dict && (i2 = t2);
      if (!i2) return null;
      const a2 = i2.getRaw("Pg");
      a2 instanceof Ref && (e2 = a2.toString());
      const r2 = i2.get("Type") instanceof Name ? i2.get("Type").name : null;
      if ("MCR" === r2) {
        if (this.tree.pageDict.objId !== e2) return null;
        const t3 = i2.getRaw("Stm");
        return new StructElement({
          type: jr,
          refObjId: t3 instanceof Ref ? t3.toString() : null,
          pageObjId: e2,
          mcid: i2.get("MCID")
        });
      }
      if ("OBJR" === r2) {
        if (this.tree.pageDict.objId !== e2) return null;
        const t3 = i2.getRaw("Obj");
        return new StructElement({
          type: Xr,
          refObjId: t3 instanceof Ref ? t3.toString() : null,
          pageObjId: e2
        });
      }
      return new StructElement({
        type: Vr,
        dict: i2
      });
    }
  }
  class StructElement {
    constructor({ type: e2, dict: t2 = null, mcid: i2 = null, pageObjId: a2 = null, refObjId: r2 = null }) {
      this.type = e2;
      this.dict = t2;
      this.mcid = i2;
      this.pageObjId = a2;
      this.refObjId = r2;
      this.parentNode = null;
    }
  }
  class StructTreePage {
    constructor(e2, t2) {
      this.root = e2;
      this.rootDict = e2 ? e2.dict : null;
      this.pageDict = t2;
      this.nodes = [];
    }
    collectObjects(e2) {
      var _a4;
      if (!(this.root && this.rootDict && e2 instanceof Ref)) return null;
      const t2 = this.rootDict.get("ParentTree");
      if (!t2) return null;
      const i2 = (_a4 = this.root.structParentIds) == null ? void 0 : _a4.get(e2);
      if (!i2) return null;
      const a2 = /* @__PURE__ */ new Map(), r2 = new NumberTree(t2, this.rootDict.xref);
      for (const [e3] of i2) {
        const t3 = r2.getRaw(e3);
        t3 instanceof Ref && a2.set(e3, t3);
      }
      return a2;
    }
    parse(e2) {
      var _a4, _b;
      if (!(this.root && this.rootDict && e2 instanceof Ref)) return;
      const t2 = this.rootDict.get("ParentTree");
      if (!t2) return;
      const i2 = this.pageDict.get("StructParents"), a2 = (_a4 = this.root.structParentIds) == null ? void 0 : _a4.get(e2);
      if (!Number.isInteger(i2) && !a2) return;
      const r2 = /* @__PURE__ */ new Map(), s2 = new NumberTree(t2, this.rootDict.xref);
      if (Number.isInteger(i2)) {
        const e3 = s2.get(i2);
        if (Array.isArray(e3)) for (const t3 of e3) t3 instanceof Ref && this.addNode(this.rootDict.xref.fetch(t3), r2);
      }
      if (a2) for (const [e3, t3] of a2) {
        const i3 = s2.get(e3);
        if (i3) {
          const e4 = this.addNode(this.rootDict.xref.fetchIfRef(i3), r2);
          1 === ((_b = e4 == null ? void 0 : e4.kids) == null ? void 0 : _b.length) && e4.kids[0].type === Xr && (e4.kids[0].type = t3);
        }
      }
    }
    addNode(e2, t2, i2 = 0) {
      if (i2 > 40) {
        warn("StructTree MAX_DEPTH reached.");
        return null;
      }
      if (!(e2 instanceof Dict)) return null;
      if (t2.has(e2)) return t2.get(e2);
      const a2 = new StructElementNode(this, e2);
      t2.set(e2, a2);
      const r2 = e2.get("P");
      if (!r2 || isName(r2.get("Type"), "StructTreeRoot")) {
        this.addTopLevelNode(e2, a2) || t2.delete(e2);
        return a2;
      }
      const s2 = this.addNode(r2, t2, i2 + 1);
      if (!s2) return a2;
      let n2 = false;
      for (const t3 of s2.kids) if (t3.type === Vr && t3.dict === e2) {
        t3.parentNode = a2;
        n2 = true;
      }
      n2 || t2.delete(e2);
      return a2;
    }
    addTopLevelNode(e2, t2) {
      const i2 = this.rootDict.get("K");
      if (!i2) return false;
      if (i2 instanceof Dict) {
        if (i2.objId !== e2.objId) return false;
        this.nodes[0] = t2;
        return true;
      }
      if (!Array.isArray(i2)) return true;
      let a2 = false;
      for (let r2 = 0; r2 < i2.length; r2++) {
        const s2 = i2[r2];
        if ((s2 == null ? void 0 : s2.toString()) === e2.objId) {
          this.nodes[r2] = t2;
          a2 = true;
        }
      }
      return a2;
    }
    get serializable() {
      function nodeToSerializable(e3, t2, i2 = 0) {
        if (i2 > 40) {
          warn("StructTree too deep to be fully serialized.");
          return;
        }
        const a2 = /* @__PURE__ */ Object.create(null);
        a2.role = e3.role;
        a2.children = [];
        t2.children.push(a2);
        let r2 = e3.dict.get("Alt");
        "string" != typeof r2 && (r2 = e3.dict.get("ActualText"));
        "string" == typeof r2 && (a2.alt = stringToPDFString(r2));
        const s2 = e3.dict.get("A");
        if (s2 instanceof Dict) {
          const e4 = lookupNormalRect(s2.getArray("BBox"), null);
          if (e4) a2.bbox = e4;
          else {
            const e5 = s2.get("Width"), t3 = s2.get("Height");
            "number" == typeof e5 && e5 > 0 && "number" == typeof t3 && t3 > 0 && (a2.bbox = [
              0,
              0,
              e5,
              t3
            ]);
          }
        }
        const n2 = e3.dict.get("Lang");
        "string" == typeof n2 && (a2.lang = stringToPDFString(n2));
        for (const t3 of e3.kids) {
          const e4 = t3.type === Vr ? t3.parentNode : null;
          e4 ? nodeToSerializable(e4, a2, i2 + 1) : t3.type === Wr || t3.type === jr ? a2.children.push({
            type: "content",
            id: `p${t3.pageObjId}_mc${t3.mcid}`
          }) : t3.type === Xr ? a2.children.push({
            type: "object",
            id: t3.refObjId
          }) : t3.type === Zr && a2.children.push({
            type: "annotation",
            id: `pdfjs_internal_id_${t3.refObjId}`
          });
        }
      }
      const e2 = /* @__PURE__ */ Object.create(null);
      e2.children = [];
      e2.role = "Root";
      for (const t2 of this.nodes) t2 && nodeToSerializable(t2, e2);
      return e2;
    }
  }
  function isValidExplicitDest(e2) {
    if (!Array.isArray(e2) || e2.length < 2) return false;
    const [t2, i2, ...a2] = e2;
    if (!(t2 instanceof Ref || Number.isInteger(t2))) return false;
    if (!(i2 instanceof Name)) return false;
    const r2 = a2.length;
    let s2 = true;
    switch (i2.name) {
      case "XYZ":
        if (r2 < 2 || r2 > 3) return false;
        break;
      case "Fit":
      case "FitB":
        return 0 === r2;
      case "FitH":
      case "FitBH":
      case "FitV":
      case "FitBV":
        if (r2 > 1) return false;
        break;
      case "FitR":
        if (4 !== r2) return false;
        s2 = false;
        break;
      default:
        return false;
    }
    for (const e3 of a2) if (!("number" == typeof e3 || s2 && null === e3)) return false;
    return true;
  }
  function fetchDest(e2) {
    e2 instanceof Dict && (e2 = e2.get("D"));
    return isValidExplicitDest(e2) ? e2 : null;
  }
  function fetchRemoteDest(e2) {
    let t2 = e2.get("D");
    if (t2) {
      t2 instanceof Name && (t2 = t2.name);
      if ("string" == typeof t2) return stringToPDFString(t2);
      if (isValidExplicitDest(t2)) return JSON.stringify(t2);
    }
    return null;
  }
  const _Catalog = class _Catalog {
    constructor(e2, t2) {
      __privateAdd(this, _Catalog_instances);
      this.pdfManager = e2;
      this.xref = t2;
      this._catDict = t2.getCatalogObj();
      if (!(this._catDict instanceof Dict)) throw new FormatError("Catalog object is not a dictionary.");
      this.toplevelPagesDict;
      this._actualNumPages = null;
      this.fontCache = new RefSetCache();
      this.builtInCMapCache = /* @__PURE__ */ new Map();
      this.standardFontDataCache = /* @__PURE__ */ new Map();
      this.globalImageCache = new GlobalImageCache();
      this.pageKidsCountCache = new RefSetCache();
      this.pageIndexCache = new RefSetCache();
      this.pageDictCache = new RefSetCache();
      this.nonBlendModesSet = new RefSet();
      this.systemFontCache = /* @__PURE__ */ new Map();
    }
    cloneDict() {
      return this._catDict.clone();
    }
    get version() {
      const e2 = this._catDict.get("Version");
      if (e2 instanceof Name) {
        if (Rt.test(e2.name)) return shadow(this, "version", e2.name);
        warn(`Invalid PDF catalog version: ${e2.name}`);
      }
      return shadow(this, "version", null);
    }
    get lang() {
      const e2 = this._catDict.get("Lang");
      return shadow(this, "lang", e2 && "string" == typeof e2 ? stringToPDFString(e2) : null);
    }
    get needsRendering() {
      const e2 = this._catDict.get("NeedsRendering");
      return shadow(this, "needsRendering", "boolean" == typeof e2 && e2);
    }
    get collection() {
      let e2 = null;
      try {
        const t2 = this._catDict.get("Collection");
        t2 instanceof Dict && t2.size > 0 && (e2 = t2);
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info("Cannot fetch Collection entry; assuming no collection is present.");
      }
      return shadow(this, "collection", e2);
    }
    get acroForm() {
      let e2 = null;
      try {
        const t2 = this._catDict.get("AcroForm");
        t2 instanceof Dict && t2.size > 0 && (e2 = t2);
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info("Cannot fetch AcroForm entry; assuming no forms are present.");
      }
      return shadow(this, "acroForm", e2);
    }
    get acroFormRef() {
      const e2 = this._catDict.getRaw("AcroForm");
      return shadow(this, "acroFormRef", e2 instanceof Ref ? e2 : null);
    }
    get metadata() {
      var _a4;
      const e2 = this._catDict.getRaw("Metadata");
      if (!(e2 instanceof Ref)) return shadow(this, "metadata", null);
      let t2 = null;
      try {
        const i2 = this.xref.fetch(e2, !((_a4 = this.xref.encrypt) == null ? void 0 : _a4.encryptMetadata));
        if (i2 instanceof BaseStream && i2.dict instanceof Dict) {
          const e3 = i2.dict.get("Type"), a2 = i2.dict.get("Subtype");
          if (isName(e3, "Metadata") && isName(a2, "XML")) {
            const e4 = stringToUTF8String(i2.getString());
            e4 && (t2 = new MetadataParser(e4).serializable);
          }
        }
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info(`Skipping invalid Metadata: "${e3}".`);
      }
      return shadow(this, "metadata", t2);
    }
    get markInfo() {
      let e2 = null;
      try {
        e2 = this._readMarkInfo();
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn("Unable to read mark info.");
      }
      return shadow(this, "markInfo", e2);
    }
    _readMarkInfo() {
      const e2 = this._catDict.get("MarkInfo");
      if (!(e2 instanceof Dict)) return null;
      const t2 = {
        Marked: false,
        UserProperties: false,
        Suspects: false
      };
      for (const i2 in t2) {
        const a2 = e2.get(i2);
        "boolean" == typeof a2 && (t2[i2] = a2);
      }
      return t2;
    }
    get structTreeRoot() {
      let e2 = null;
      try {
        e2 = this._readStructTreeRoot();
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn("Unable read to structTreeRoot info.");
      }
      return shadow(this, "structTreeRoot", e2);
    }
    _readStructTreeRoot() {
      const e2 = this._catDict.getRaw("StructTreeRoot"), t2 = this.xref.fetchIfRef(e2);
      if (!(t2 instanceof Dict)) return null;
      const i2 = new StructTreeRoot(t2, e2);
      i2.init();
      return i2;
    }
    get toplevelPagesDict() {
      const e2 = this._catDict.get("Pages");
      if (!(e2 instanceof Dict)) throw new FormatError("Invalid top-level pages dictionary.");
      return shadow(this, "toplevelPagesDict", e2);
    }
    get documentOutline() {
      let e2 = null;
      try {
        e2 = this._readDocumentOutline();
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn("Unable to read document outline.");
      }
      return shadow(this, "documentOutline", e2);
    }
    _readDocumentOutline() {
      let e2 = this._catDict.get("Outlines");
      if (!(e2 instanceof Dict)) return null;
      e2 = e2.getRaw("First");
      if (!(e2 instanceof Ref)) return null;
      const t2 = {
        items: []
      }, i2 = [
        {
          obj: e2,
          parent: t2
        }
      ], a2 = new RefSet();
      a2.put(e2);
      const r2 = this.xref, s2 = new Uint8ClampedArray(3);
      for (; i2.length > 0; ) {
        const t3 = i2.shift(), n2 = r2.fetchIfRef(t3.obj);
        if (null === n2) continue;
        n2.has("Title") || warn("Invalid outline item encountered.");
        const o2 = {
          url: null,
          dest: null,
          action: null
        };
        _Catalog.parseDestDictionary({
          destDict: n2,
          resultObj: o2,
          docBaseUrl: this.baseUrl,
          docAttachments: this.attachments
        });
        const g2 = n2.get("Title"), c2 = n2.get("F") || 0, C2 = n2.getArray("C"), h2 = n2.get("Count");
        let l2 = s2;
        !isNumberArray(C2, 3) || 0 === C2[0] && 0 === C2[1] && 0 === C2[2] || (l2 = ColorSpace.singletons.rgb.getRgb(C2, 0));
        const Q2 = {
          action: o2.action,
          attachment: o2.attachment,
          dest: o2.dest,
          url: o2.url,
          unsafeUrl: o2.unsafeUrl,
          newWindow: o2.newWindow,
          setOCGState: o2.setOCGState,
          title: "string" == typeof g2 ? stringToPDFString(g2) : "",
          color: l2,
          count: Number.isInteger(h2) ? h2 : void 0,
          bold: !!(2 & c2),
          italic: !!(1 & c2),
          items: []
        };
        t3.parent.items.push(Q2);
        e2 = n2.getRaw("First");
        if (e2 instanceof Ref && !a2.has(e2)) {
          i2.push({
            obj: e2,
            parent: Q2
          });
          a2.put(e2);
        }
        e2 = n2.getRaw("Next");
        if (e2 instanceof Ref && !a2.has(e2)) {
          i2.push({
            obj: e2,
            parent: t3.parent
          });
          a2.put(e2);
        }
      }
      return t2.items.length > 0 ? t2.items : null;
    }
    get permissions() {
      let e2 = null;
      try {
        e2 = this._readPermissions();
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn("Unable to read permissions.");
      }
      return shadow(this, "permissions", e2);
    }
    _readPermissions() {
      const e2 = this.xref.trailer.get("Encrypt");
      if (!(e2 instanceof Dict)) return null;
      let t2 = e2.get("P");
      if ("number" != typeof t2) return null;
      t2 += 2 ** 32;
      const i2 = [];
      for (const e3 in w) {
        const a2 = w[e3];
        t2 & a2 && i2.push(a2);
      }
      return i2;
    }
    get optionalContentConfig() {
      let e2 = null;
      try {
        const t2 = this._catDict.get("OCProperties");
        if (!t2) return shadow(this, "optionalContentConfig", null);
        const i2 = t2.get("D");
        if (!i2) return shadow(this, "optionalContentConfig", null);
        const a2 = t2.get("OCGs");
        if (!Array.isArray(a2)) return shadow(this, "optionalContentConfig", null);
        const r2 = new RefSetCache();
        for (const e3 of a2) e3 instanceof Ref && !r2.has(e3) && r2.put(e3, __privateMethod(this, _Catalog_instances, O_fn).call(this, e3));
        e2 = __privateMethod(this, _Catalog_instances, P_fn).call(this, i2, r2);
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(`Unable to read optional content config: ${e3}`);
      }
      return shadow(this, "optionalContentConfig", e2);
    }
    setActualNumPages(e2 = null) {
      this._actualNumPages = e2;
    }
    get hasActualNumPages() {
      return null !== this._actualNumPages;
    }
    get _pagesCount() {
      const e2 = this.toplevelPagesDict.get("Count");
      if (!Number.isInteger(e2)) throw new FormatError("Page count in top-level pages dictionary is not an integer.");
      return shadow(this, "_pagesCount", e2);
    }
    get numPages() {
      return this.hasActualNumPages ? this._actualNumPages : this._pagesCount;
    }
    get destinations() {
      const e2 = this._readDests(), t2 = /* @__PURE__ */ Object.create(null);
      if (e2 instanceof NameTree) for (const [i2, a2] of e2.getAll()) {
        const e3 = fetchDest(a2);
        e3 && (t2[stringToPDFString(i2)] = e3);
      }
      else e2 instanceof Dict && e2.forEach(function(e3, i2) {
        const a2 = fetchDest(i2);
        a2 && (t2[e3] = a2);
      });
      return shadow(this, "destinations", t2);
    }
    getDestination(e2) {
      const t2 = this._readDests();
      if (t2 instanceof NameTree) {
        const i2 = fetchDest(t2.get(e2));
        if (i2) return i2;
        const a2 = this.destinations[e2];
        if (a2) {
          warn(`Found "${e2}" at an incorrect position in the NameTree.`);
          return a2;
        }
      } else if (t2 instanceof Dict) {
        const i2 = fetchDest(t2.get(e2));
        if (i2) return i2;
      }
      return null;
    }
    _readDests() {
      const e2 = this._catDict.get("Names");
      return (e2 == null ? void 0 : e2.has("Dests")) ? new NameTree(e2.getRaw("Dests"), this.xref) : this._catDict.has("Dests") ? this._catDict.get("Dests") : void 0;
    }
    get pageLabels() {
      let e2 = null;
      try {
        e2 = this._readPageLabels();
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn("Unable to read page labels.");
      }
      return shadow(this, "pageLabels", e2);
    }
    _readPageLabels() {
      const e2 = this._catDict.getRaw("PageLabels");
      if (!e2) return null;
      const t2 = new Array(this.numPages);
      let i2 = null, a2 = "";
      const r2 = new NumberTree(e2, this.xref).getAll();
      let s2 = "", n2 = 1;
      for (let e3 = 0, o2 = this.numPages; e3 < o2; e3++) {
        const o3 = r2.get(e3);
        if (void 0 !== o3) {
          if (!(o3 instanceof Dict)) throw new FormatError("PageLabel is not a dictionary.");
          if (o3.has("Type") && !isName(o3.get("Type"), "PageLabel")) throw new FormatError("Invalid type in PageLabel dictionary.");
          if (o3.has("S")) {
            const e4 = o3.get("S");
            if (!(e4 instanceof Name)) throw new FormatError("Invalid style in PageLabel dictionary.");
            i2 = e4.name;
          } else i2 = null;
          if (o3.has("P")) {
            const e4 = o3.get("P");
            if ("string" != typeof e4) throw new FormatError("Invalid prefix in PageLabel dictionary.");
            a2 = stringToPDFString(e4);
          } else a2 = "";
          if (o3.has("St")) {
            const e4 = o3.get("St");
            if (!(Number.isInteger(e4) && e4 >= 1)) throw new FormatError("Invalid start in PageLabel dictionary.");
            n2 = e4;
          } else n2 = 1;
        }
        switch (i2) {
          case "D":
            s2 = n2;
            break;
          case "R":
          case "r":
            s2 = toRomanNumerals(n2, "r" === i2);
            break;
          case "A":
          case "a":
            const e4 = 26, t3 = "a" === i2 ? 97 : 65, a3 = n2 - 1;
            s2 = String.fromCharCode(t3 + a3 % e4).repeat(Math.floor(a3 / e4) + 1);
            break;
          default:
            if (i2) throw new FormatError(`Invalid style "${i2}" in PageLabel dictionary.`);
            s2 = "";
        }
        t2[e3] = a2 + s2;
        n2++;
      }
      return t2;
    }
    get pageLayout() {
      const e2 = this._catDict.get("PageLayout");
      let t2 = "";
      if (e2 instanceof Name) switch (e2.name) {
        case "SinglePage":
        case "OneColumn":
        case "TwoColumnLeft":
        case "TwoColumnRight":
        case "TwoPageLeft":
        case "TwoPageRight":
          t2 = e2.name;
      }
      return shadow(this, "pageLayout", t2);
    }
    get pageMode() {
      const e2 = this._catDict.get("PageMode");
      let t2 = "UseNone";
      if (e2 instanceof Name) switch (e2.name) {
        case "UseNone":
        case "UseOutlines":
        case "UseThumbs":
        case "FullScreen":
        case "UseOC":
        case "UseAttachments":
          t2 = e2.name;
      }
      return shadow(this, "pageMode", t2);
    }
    get viewerPreferences() {
      const e2 = this._catDict.get("ViewerPreferences");
      if (!(e2 instanceof Dict)) return shadow(this, "viewerPreferences", null);
      let t2 = null;
      for (const i2 of e2.getKeys()) {
        const a2 = e2.get(i2);
        let r2;
        switch (i2) {
          case "HideToolbar":
          case "HideMenubar":
          case "HideWindowUI":
          case "FitWindow":
          case "CenterWindow":
          case "DisplayDocTitle":
          case "PickTrayByPDFSize":
            "boolean" == typeof a2 && (r2 = a2);
            break;
          case "NonFullScreenPageMode":
            if (a2 instanceof Name) switch (a2.name) {
              case "UseNone":
              case "UseOutlines":
              case "UseThumbs":
              case "UseOC":
                r2 = a2.name;
                break;
              default:
                r2 = "UseNone";
            }
            break;
          case "Direction":
            if (a2 instanceof Name) switch (a2.name) {
              case "L2R":
              case "R2L":
                r2 = a2.name;
                break;
              default:
                r2 = "L2R";
            }
            break;
          case "ViewArea":
          case "ViewClip":
          case "PrintArea":
          case "PrintClip":
            if (a2 instanceof Name) switch (a2.name) {
              case "MediaBox":
              case "CropBox":
              case "BleedBox":
              case "TrimBox":
              case "ArtBox":
                r2 = a2.name;
                break;
              default:
                r2 = "CropBox";
            }
            break;
          case "PrintScaling":
            if (a2 instanceof Name) switch (a2.name) {
              case "None":
              case "AppDefault":
                r2 = a2.name;
                break;
              default:
                r2 = "AppDefault";
            }
            break;
          case "Duplex":
            if (a2 instanceof Name) switch (a2.name) {
              case "Simplex":
              case "DuplexFlipShortEdge":
              case "DuplexFlipLongEdge":
                r2 = a2.name;
                break;
              default:
                r2 = "None";
            }
            break;
          case "PrintPageRange":
            if (Array.isArray(a2) && a2.length % 2 == 0) {
              a2.every((e3, t3, i3) => Number.isInteger(e3) && e3 > 0 && (0 === t3 || e3 >= i3[t3 - 1]) && e3 <= this.numPages) && (r2 = a2);
            }
            break;
          case "NumCopies":
            Number.isInteger(a2) && a2 > 0 && (r2 = a2);
            break;
          default:
            warn(`Ignoring non-standard key in ViewerPreferences: ${i2}.`);
            continue;
        }
        if (void 0 !== r2) {
          t2 || (t2 = /* @__PURE__ */ Object.create(null));
          t2[i2] = r2;
        } else warn(`Bad value, for key "${i2}", in ViewerPreferences: ${a2}.`);
      }
      return shadow(this, "viewerPreferences", t2);
    }
    get openAction() {
      const e2 = this._catDict.get("OpenAction"), t2 = /* @__PURE__ */ Object.create(null);
      if (e2 instanceof Dict) {
        const i2 = new Dict(this.xref);
        i2.set("A", e2);
        const a2 = {
          url: null,
          dest: null,
          action: null
        };
        _Catalog.parseDestDictionary({
          destDict: i2,
          resultObj: a2
        });
        Array.isArray(a2.dest) ? t2.dest = a2.dest : a2.action && (t2.action = a2.action);
      } else Array.isArray(e2) && (t2.dest = e2);
      return shadow(this, "openAction", objectSize(t2) > 0 ? t2 : null);
    }
    get attachments() {
      const e2 = this._catDict.get("Names");
      let t2 = null;
      if (e2 instanceof Dict && e2.has("EmbeddedFiles")) {
        const i2 = new NameTree(e2.getRaw("EmbeddedFiles"), this.xref);
        for (const [e3, a2] of i2.getAll()) {
          const i3 = new FileSpec(a2, this.xref);
          t2 || (t2 = /* @__PURE__ */ Object.create(null));
          t2[stringToPDFString(e3)] = i3.serializable;
        }
      }
      return shadow(this, "attachments", t2);
    }
    get xfaImages() {
      const e2 = this._catDict.get("Names");
      let t2 = null;
      if (e2 instanceof Dict && e2.has("XFAImages")) {
        const i2 = new NameTree(e2.getRaw("XFAImages"), this.xref);
        for (const [e3, a2] of i2.getAll()) {
          t2 || (t2 = new Dict(this.xref));
          t2.set(stringToPDFString(e3), a2);
        }
      }
      return shadow(this, "xfaImages", t2);
    }
    _collectJavaScript() {
      const e2 = this._catDict.get("Names");
      let t2 = null;
      function appendIfJavaScriptDict(e3, i3) {
        if (!(i3 instanceof Dict)) return;
        if (!isName(i3.get("S"), "JavaScript")) return;
        let a2 = i3.get("JS");
        if (a2 instanceof BaseStream) a2 = a2.getString();
        else if ("string" != typeof a2) return;
        a2 = stringToPDFString(a2).replaceAll("\0", "");
        a2 && (t2 || (t2 = /* @__PURE__ */ new Map())).set(e3, a2);
      }
      if (e2 instanceof Dict && e2.has("JavaScript")) {
        const t3 = new NameTree(e2.getRaw("JavaScript"), this.xref);
        for (const [e3, i3] of t3.getAll()) appendIfJavaScriptDict(stringToPDFString(e3), i3);
      }
      const i2 = this._catDict.get("OpenAction");
      i2 && appendIfJavaScriptDict("OpenAction", i2);
      return t2;
    }
    get jsActions() {
      const e2 = this._collectJavaScript();
      let t2 = collectActions(this.xref, this._catDict, mA);
      if (e2) {
        t2 || (t2 = /* @__PURE__ */ Object.create(null));
        for (const [i2, a2] of e2) i2 in t2 ? t2[i2].push(a2) : t2[i2] = [
          a2
        ];
      }
      return shadow(this, "jsActions", t2);
    }
    async fontFallback(e2, t2) {
      const i2 = await Promise.all(this.fontCache);
      for (const a2 of i2) if (a2.loadedName === e2) {
        a2.fallback(t2);
        return;
      }
    }
    async cleanup(e2 = false) {
      clearGlobalCaches();
      this.globalImageCache.clear(e2);
      this.pageKidsCountCache.clear();
      this.pageIndexCache.clear();
      this.pageDictCache.clear();
      this.nonBlendModesSet.clear();
      const t2 = await Promise.all(this.fontCache);
      for (const { dict: e3 } of t2) delete e3.cacheKey;
      this.fontCache.clear();
      this.builtInCMapCache.clear();
      this.standardFontDataCache.clear();
      this.systemFontCache.clear();
    }
    async getPageDict(e2) {
      const t2 = [
        this.toplevelPagesDict
      ], i2 = new RefSet(), a2 = this._catDict.getRaw("Pages");
      a2 instanceof Ref && i2.put(a2);
      const r2 = this.xref, s2 = this.pageKidsCountCache, n2 = this.pageIndexCache, o2 = this.pageDictCache;
      let g2 = 0;
      for (; t2.length; ) {
        const a3 = t2.pop();
        if (a3 instanceof Ref) {
          const c3 = s2.get(a3);
          if (c3 >= 0 && g2 + c3 <= e2) {
            g2 += c3;
            continue;
          }
          if (i2.has(a3)) throw new FormatError("Pages tree contains circular reference.");
          i2.put(a3);
          const C3 = await (o2.get(a3) || r2.fetchAsync(a3));
          if (C3 instanceof Dict) {
            let t3 = C3.getRaw("Type");
            t3 instanceof Ref && (t3 = await r2.fetchAsync(t3));
            if (isName(t3, "Page") || !C3.has("Kids")) {
              s2.has(a3) || s2.put(a3, 1);
              n2.has(a3) || n2.put(a3, g2);
              if (g2 === e2) return [
                C3,
                a3
              ];
              g2++;
              continue;
            }
          }
          t2.push(C3);
          continue;
        }
        if (!(a3 instanceof Dict)) throw new FormatError("Page dictionary kid reference points to wrong type of object.");
        const { objId: c2 } = a3;
        let C2 = a3.getRaw("Count");
        C2 instanceof Ref && (C2 = await r2.fetchAsync(C2));
        if (Number.isInteger(C2) && C2 >= 0) {
          c2 && !s2.has(c2) && s2.put(c2, C2);
          if (g2 + C2 <= e2) {
            g2 += C2;
            continue;
          }
        }
        let h2 = a3.getRaw("Kids");
        h2 instanceof Ref && (h2 = await r2.fetchAsync(h2));
        if (!Array.isArray(h2)) {
          let t3 = a3.getRaw("Type");
          t3 instanceof Ref && (t3 = await r2.fetchAsync(t3));
          if (isName(t3, "Page") || !a3.has("Kids")) {
            if (g2 === e2) return [
              a3,
              null
            ];
            g2++;
            continue;
          }
          throw new FormatError("Page dictionary kids object is not an array.");
        }
        for (let e3 = h2.length - 1; e3 >= 0; e3--) {
          const i3 = h2[e3];
          t2.push(i3);
          a3 === this.toplevelPagesDict && i3 instanceof Ref && !o2.has(i3) && o2.put(i3, r2.fetchAsync(i3));
        }
      }
      throw new Error(`Page index ${e2} not found.`);
    }
    async getAllPageDicts(e2 = false) {
      const { ignoreErrors: t2 } = this.pdfManager.evaluatorOptions, i2 = [
        {
          currentNode: this.toplevelPagesDict,
          posInKids: 0
        }
      ], a2 = new RefSet(), r2 = this._catDict.getRaw("Pages");
      r2 instanceof Ref && a2.put(r2);
      const s2 = /* @__PURE__ */ new Map(), n2 = this.xref, o2 = this.pageIndexCache;
      let g2 = 0;
      function addPageDict(e3, t3) {
        t3 && !o2.has(t3) && o2.put(t3, g2);
        s2.set(g2++, [
          e3,
          t3
        ]);
      }
      function addPageError(i3) {
        if (i3 instanceof XRefEntryException && !e2) throw i3;
        if (e2 && t2 && 0 === g2) {
          warn(`getAllPageDicts - Skipping invalid first page: "${i3}".`);
          i3 = Dict.empty;
        }
        s2.set(g2++, [
          i3,
          null
        ]);
      }
      for (; i2.length > 0; ) {
        const e3 = i2.at(-1), { currentNode: t3, posInKids: r3 } = e3;
        let s3 = t3.getRaw("Kids");
        if (s3 instanceof Ref) try {
          s3 = await n2.fetchAsync(s3);
        } catch (e4) {
          addPageError(e4);
          break;
        }
        if (!Array.isArray(s3)) {
          addPageError(new FormatError("Page dictionary kids object is not an array."));
          break;
        }
        if (r3 >= s3.length) {
          i2.pop();
          continue;
        }
        const o3 = s3[r3];
        let g3;
        if (o3 instanceof Ref) {
          if (a2.has(o3)) {
            addPageError(new FormatError("Pages tree contains circular reference."));
            break;
          }
          a2.put(o3);
          try {
            g3 = await n2.fetchAsync(o3);
          } catch (e4) {
            addPageError(e4);
            break;
          }
        } else g3 = o3;
        if (!(g3 instanceof Dict)) {
          addPageError(new FormatError("Page dictionary kid reference points to wrong type of object."));
          break;
        }
        let c2 = g3.getRaw("Type");
        if (c2 instanceof Ref) try {
          c2 = await n2.fetchAsync(c2);
        } catch (e4) {
          addPageError(e4);
          break;
        }
        isName(c2, "Page") || !g3.has("Kids") ? addPageDict(g3, o3 instanceof Ref ? o3 : null) : i2.push({
          currentNode: g3,
          posInKids: 0
        });
        e3.posInKids++;
      }
      return s2;
    }
    getPageIndex(e2) {
      const t2 = this.pageIndexCache.get(e2);
      if (void 0 !== t2) return Promise.resolve(t2);
      const i2 = this.xref;
      let a2 = 0;
      const next = (t3) => function pagesBeforeRef(t4) {
        let a3, r2 = 0;
        return i2.fetchAsync(t4).then(function(i3) {
          if (isRefsEqual(t4, e2) && !isDict(i3, "Page") && !(i3 instanceof Dict && !i3.has("Type") && i3.has("Contents"))) throw new FormatError("The reference does not point to a /Page dictionary.");
          if (!i3) return null;
          if (!(i3 instanceof Dict)) throw new FormatError("Node must be a dictionary.");
          a3 = i3.getRaw("Parent");
          return i3.getAsync("Parent");
        }).then(function(e3) {
          if (!e3) return null;
          if (!(e3 instanceof Dict)) throw new FormatError("Parent must be a dictionary.");
          return e3.getAsync("Kids");
        }).then(function(e3) {
          if (!e3) return null;
          const s2 = [];
          let n2 = false;
          for (const a4 of e3) {
            if (!(a4 instanceof Ref)) throw new FormatError("Kid must be a reference.");
            if (isRefsEqual(a4, t4)) {
              n2 = true;
              break;
            }
            s2.push(i2.fetchAsync(a4).then(function(e4) {
              if (!(e4 instanceof Dict)) throw new FormatError("Kid node must be a dictionary.");
              e4.has("Count") ? r2 += e4.get("Count") : r2++;
            }));
          }
          if (!n2) throw new FormatError("Kid reference not found in parent's kids.");
          return Promise.all(s2).then(function() {
            return [
              r2,
              a3
            ];
          });
        });
      }(t3).then((t4) => {
        if (!t4) {
          this.pageIndexCache.put(e2, a2);
          return a2;
        }
        const [i3, r2] = t4;
        a2 += i3;
        return next(r2);
      });
      return next(e2);
    }
    get baseUrl() {
      const e2 = this._catDict.get("URI");
      if (e2 instanceof Dict) {
        const t2 = e2.get("Base");
        if ("string" == typeof t2) {
          const e3 = createValidAbsoluteUrl(t2, null, {
            tryConvertEncoding: true
          });
          if (e3) return shadow(this, "baseUrl", e3.href);
        }
      }
      return shadow(this, "baseUrl", this.pdfManager.docBaseUrl);
    }
    static parseDestDictionary({ destDict: e2, resultObj: t2, docBaseUrl: i2 = null, docAttachments: a2 = null }) {
      if (!(e2 instanceof Dict)) {
        warn("parseDestDictionary: `destDict` must be a dictionary.");
        return;
      }
      let r2, s2, n2 = e2.get("A");
      if (!(n2 instanceof Dict)) if (e2.has("Dest")) n2 = e2.get("Dest");
      else {
        n2 = e2.get("AA");
        n2 instanceof Dict && (n2.has("D") ? n2 = n2.get("D") : n2.has("U") && (n2 = n2.get("U")));
      }
      if (n2 instanceof Dict) {
        const e3 = n2.get("S");
        if (!(e3 instanceof Name)) {
          warn("parseDestDictionary: Invalid type in Action dictionary.");
          return;
        }
        const i3 = e3.name;
        switch (i3) {
          case "ResetForm":
            const e4 = n2.get("Flags"), o2 = 0 == (1 & ("number" == typeof e4 ? e4 : 0)), g2 = [], c2 = [];
            for (const e5 of n2.get("Fields") || []) e5 instanceof Ref ? c2.push(e5.toString()) : "string" == typeof e5 && g2.push(stringToPDFString(e5));
            t2.resetForm = {
              fields: g2,
              refs: c2,
              include: o2
            };
            break;
          case "URI":
            r2 = n2.get("URI");
            r2 instanceof Name && (r2 = "/" + r2.name);
            break;
          case "GoTo":
            s2 = n2.get("D");
            break;
          case "Launch":
          case "GoToR":
            const C2 = n2.get("F");
            if (C2 instanceof Dict) {
              const e5 = new FileSpec(C2, null, true), { rawFilename: t3 } = e5.serializable;
              r2 = t3;
            } else "string" == typeof C2 && (r2 = C2);
            const h2 = fetchRemoteDest(n2);
            h2 && "string" == typeof r2 && (r2 = r2.split("#", 1)[0] + "#" + h2);
            const l2 = n2.get("NewWindow");
            "boolean" == typeof l2 && (t2.newWindow = l2);
            break;
          case "GoToE":
            const Q2 = n2.get("T");
            let E2;
            if (a2 && Q2 instanceof Dict) {
              const e5 = Q2.get("R"), t3 = Q2.get("N");
              isName(e5, "C") && "string" == typeof t3 && (E2 = a2[stringToPDFString(t3)]);
            }
            if (E2) {
              t2.attachment = E2;
              const e5 = fetchRemoteDest(n2);
              e5 && (t2.attachmentDest = e5);
            } else warn('parseDestDictionary - unimplemented "GoToE" action.');
            break;
          case "Named":
            const u2 = n2.get("N");
            u2 instanceof Name && (t2.action = u2.name);
            break;
          case "SetOCGState":
            const d2 = n2.get("State"), f2 = n2.get("PreserveRB");
            if (!Array.isArray(d2) || 0 === d2.length) break;
            const p2 = [];
            for (const e5 of d2) if (e5 instanceof Name) switch (e5.name) {
              case "ON":
              case "OFF":
              case "Toggle":
                p2.push(e5.name);
            }
            else e5 instanceof Ref && p2.push(e5.toString());
            if (p2.length !== d2.length) break;
            t2.setOCGState = {
              state: p2,
              preserveRB: "boolean" != typeof f2 || f2
            };
            break;
          case "JavaScript":
            const m2 = n2.get("JS");
            let y2;
            m2 instanceof BaseStream ? y2 = m2.getString() : "string" == typeof m2 && (y2 = m2);
            const w2 = y2 && recoverJsURL(stringToPDFString(y2));
            if (w2) {
              r2 = w2.url;
              t2.newWindow = w2.newWindow;
              break;
            }
          default:
            if ("JavaScript" === i3 || "SubmitForm" === i3) break;
            warn(`parseDestDictionary - unsupported action: "${i3}".`);
        }
      } else e2.has("Dest") && (s2 = e2.get("Dest"));
      if ("string" == typeof r2) {
        const e3 = createValidAbsoluteUrl(r2, i2, {
          addDefaultProtocol: true,
          tryConvertEncoding: true
        });
        e3 && (t2.url = e3.href);
        t2.unsafeUrl = r2;
      }
      if (s2) {
        s2 instanceof Name && (s2 = s2.name);
        "string" == typeof s2 ? t2.dest = stringToPDFString(s2) : isValidExplicitDest(s2) && (t2.dest = s2);
      }
    }
  };
  _Catalog_instances = new WeakSet();
  O_fn = function(e2) {
    const t2 = this.xref.fetch(e2), i2 = {
      id: e2.toString(),
      name: null,
      intent: null,
      usage: {
        print: null,
        view: null
      },
      rbGroups: []
    }, a2 = t2.get("Name");
    "string" == typeof a2 && (i2.name = stringToPDFString(a2));
    let r2 = t2.getArray("Intent");
    Array.isArray(r2) || (r2 = [
      r2
    ]);
    r2.every((e3) => e3 instanceof Name) && (i2.intent = r2.map((e3) => e3.name));
    const s2 = t2.get("Usage");
    if (!(s2 instanceof Dict)) return i2;
    const n2 = i2.usage, o2 = s2.get("Print");
    if (o2 instanceof Dict) {
      const e3 = o2.get("PrintState");
      if (e3 instanceof Name) switch (e3.name) {
        case "ON":
        case "OFF":
          n2.print = {
            printState: e3.name
          };
      }
    }
    const g2 = s2.get("View");
    if (g2 instanceof Dict) {
      const e3 = g2.get("ViewState");
      if (e3 instanceof Name) switch (e3.name) {
        case "ON":
        case "OFF":
          n2.view = {
            viewState: e3.name
          };
      }
    }
    return i2;
  };
  P_fn = function(e2, t2) {
    function parseOnOff(e3) {
      const i3 = [];
      if (Array.isArray(e3)) for (const a3 of e3) a3 instanceof Ref && t2.has(a3) && i3.push(a3.toString());
      return i3;
    }
    function parseOrder(e3, i3 = 0) {
      if (!Array.isArray(e3)) return null;
      const r3 = [];
      for (const s3 of e3) {
        if (s3 instanceof Ref && t2.has(s3)) {
          a2.put(s3);
          r3.push(s3.toString());
          continue;
        }
        const e4 = parseNestedOrder(s3, i3);
        e4 && r3.push(e4);
      }
      if (i3 > 0) return r3;
      const s2 = [];
      for (const [e4] of t2.items()) a2.has(e4) || s2.push(e4.toString());
      s2.length && r3.push({
        name: null,
        order: s2
      });
      return r3;
    }
    function parseNestedOrder(e3, t3) {
      if (++t3 > r2) {
        warn("parseNestedOrder - reached MAX_NESTED_LEVELS.");
        return null;
      }
      const a3 = i2.fetchIfRef(e3);
      if (!Array.isArray(a3)) return null;
      const s2 = i2.fetchIfRef(a3[0]);
      if ("string" != typeof s2) return null;
      const n2 = parseOrder(a3.slice(1), t3);
      return n2 && n2.length ? {
        name: stringToPDFString(s2),
        order: n2
      } : null;
    }
    const i2 = this.xref, a2 = new RefSet(), r2 = 10;
    !function parseRBGroups(e3) {
      if (Array.isArray(e3)) for (const a3 of e3) {
        const e4 = i2.fetchIfRef(a3);
        if (!Array.isArray(e4) || !e4.length) continue;
        const r3 = /* @__PURE__ */ new Set();
        for (const i3 of e4) if (i3 instanceof Ref && t2.has(i3) && !r3.has(i3.toString())) {
          r3.add(i3.toString());
          t2.get(i3).rbGroups.push(r3);
        }
      }
    }(e2.get("RBGroups"));
    return {
      name: "string" == typeof e2.get("Name") ? stringToPDFString(e2.get("Name")) : null,
      creator: "string" == typeof e2.get("Creator") ? stringToPDFString(e2.get("Creator")) : null,
      baseState: e2.get("BaseState") instanceof Name ? e2.get("BaseState").name : null,
      on: parseOnOff(e2.get("ON")),
      off: parseOnOff(e2.get("OFF")),
      order: parseOrder(e2.get("Order")),
      groups: [
        ...t2
      ]
    };
  };
  let Catalog = _Catalog;
  function addChildren(e2, t2) {
    if (e2 instanceof Dict) e2 = e2.getRawValues();
    else if (e2 instanceof BaseStream) e2 = e2.dict.getRawValues();
    else if (!Array.isArray(e2)) return;
    for (const a2 of e2) ((i2 = a2) instanceof Ref || i2 instanceof Dict || i2 instanceof BaseStream || Array.isArray(i2)) && t2.push(a2);
    var i2;
  }
  class ObjectLoader {
    constructor(e2, t2, i2) {
      this.dict = e2;
      this.keys = t2;
      this.xref = i2;
      this.refSet = null;
    }
    async load() {
      if (this.xref.stream.isDataLoaded) return;
      const { keys: e2, dict: t2 } = this;
      this.refSet = new RefSet();
      const i2 = [];
      for (const a2 of e2) {
        const e3 = t2.getRaw(a2);
        void 0 !== e3 && i2.push(e3);
      }
      return this._walk(i2);
    }
    async _walk(e2) {
      const t2 = [], i2 = [];
      for (; e2.length; ) {
        let a2 = e2.pop();
        if (a2 instanceof Ref) {
          if (this.refSet.has(a2)) continue;
          try {
            this.refSet.put(a2);
            a2 = this.xref.fetch(a2);
          } catch (e3) {
            if (!(e3 instanceof MissingDataException)) {
              warn(`ObjectLoader._walk - requesting all data: "${e3}".`);
              this.refSet = null;
              const { manager: t3 } = this.xref.stream;
              return t3.requestAllChunks();
            }
            t2.push(a2);
            i2.push({
              begin: e3.begin,
              end: e3.end
            });
          }
        }
        if (a2 instanceof BaseStream) {
          const e3 = a2.getBaseStreams();
          if (e3) {
            let r2 = false;
            for (const t3 of e3) if (!t3.isDataLoaded) {
              r2 = true;
              i2.push({
                begin: t3.start,
                end: t3.end
              });
            }
            r2 && t2.push(a2);
          }
        }
        addChildren(a2, e2);
      }
      if (i2.length) {
        await this.xref.stream.manager.requestRanges(i2);
        for (const e3 of t2) e3 instanceof Ref && this.refSet.remove(e3);
        return this._walk(t2);
      }
      this.refSet = null;
    }
  }
  const _r = Symbol(), zr = Symbol(), $r = Symbol(), As = Symbol(), es = Symbol(), ts = Symbol(), is = Symbol(), as = Symbol(), rs = Symbol(), ss = Symbol("content"), ns = Symbol("data"), os = Symbol(), gs = Symbol("extra"), Is = Symbol(), cs = Symbol(), Cs = Symbol(), hs = Symbol(), ls = Symbol(), Bs = Symbol(), Qs = Symbol(), Es = Symbol(), us = Symbol(), ds = Symbol(), fs = Symbol(), ps = Symbol(), ms = Symbol(), ys = Symbol(), ws = Symbol(), bs = Symbol(), Ds = Symbol(), Fs = Symbol(), Ss = Symbol(), ks = Symbol(), Rs = Symbol(), Ns = Symbol(), Gs = Symbol(), xs = Symbol(), Us = Symbol(), Ms = Symbol(), Ls = Symbol(), Hs = Symbol(), Js = Symbol(), vs = Symbol(), Ys = Symbol(), Ts = Symbol(), Ks = Symbol("namespaceId"), qs = Symbol("nodeName"), Os = Symbol(), Ws = Symbol(), js = Symbol(), Xs = Symbol(), Zs = Symbol(), Vs = Symbol(), _s = Symbol(), zs = Symbol(), $s = Symbol("root"), An = Symbol(), en = Symbol(), tn = Symbol(), an = Symbol(), rn = Symbol(), sn = Symbol(), nn = Symbol(), on = Symbol(), gn = Symbol(), In = Symbol(), cn = Symbol(), Cn = Symbol("uid"), hn = Symbol(), ln = {
    config: {
      id: 0,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xci/")
    },
    connectionSet: {
      id: 1,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-connection-set/")
    },
    datasets: {
      id: 2,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-data/")
    },
    form: {
      id: 3,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-form/")
    },
    localeSet: {
      id: 4,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-locale-set/")
    },
    pdf: {
      id: 5,
      check: (e2) => "http://ns.adobe.com/xdp/pdf/" === e2
    },
    signature: {
      id: 6,
      check: (e2) => "http://www.w3.org/2000/09/xmldsig#" === e2
    },
    sourceSet: {
      id: 7,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-source-set/")
    },
    stylesheet: {
      id: 8,
      check: (e2) => "http://www.w3.org/1999/XSL/Transform" === e2
    },
    template: {
      id: 9,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xfa-template/")
    },
    xdc: {
      id: 10,
      check: (e2) => e2.startsWith("http://www.xfa.org/schema/xdc/")
    },
    xdp: {
      id: 11,
      check: (e2) => "http://ns.adobe.com/xdp/" === e2
    },
    xfdf: {
      id: 12,
      check: (e2) => "http://ns.adobe.com/xfdf/" === e2
    },
    xhtml: {
      id: 13,
      check: (e2) => "http://www.w3.org/1999/xhtml" === e2
    },
    xmpmeta: {
      id: 14,
      check: (e2) => "http://ns.adobe.com/xmpmeta/" === e2
    }
  }, Bn = {
    pt: (e2) => e2,
    cm: (e2) => e2 / 2.54 * 72,
    mm: (e2) => e2 / 25.4 * 72,
    in: (e2) => 72 * e2,
    px: (e2) => e2
  }, Qn = /([+-]?\d+\.?\d*)(.*)/;
  function stripQuotes(e2) {
    return e2.startsWith("'") || e2.startsWith('"') ? e2.slice(1, -1) : e2;
  }
  function getInteger({ data: e2, defaultValue: t2, validate: i2 }) {
    if (!e2) return t2;
    e2 = e2.trim();
    const a2 = parseInt(e2, 10);
    return !isNaN(a2) && i2(a2) ? a2 : t2;
  }
  function getFloat({ data: e2, defaultValue: t2, validate: i2 }) {
    if (!e2) return t2;
    e2 = e2.trim();
    const a2 = parseFloat(e2);
    return !isNaN(a2) && i2(a2) ? a2 : t2;
  }
  function getKeyword({ data: e2, defaultValue: t2, validate: i2 }) {
    return e2 && i2(e2 = e2.trim()) ? e2 : t2;
  }
  function getStringOption(e2, t2) {
    return getKeyword({
      data: e2,
      defaultValue: t2[0],
      validate: (e3) => t2.includes(e3)
    });
  }
  function getMeasurement(e2, t2 = "0") {
    t2 || (t2 = "0");
    if (!e2) return getMeasurement(t2);
    const i2 = e2.trim().match(Qn);
    if (!i2) return getMeasurement(t2);
    const [, a2, r2] = i2, s2 = parseFloat(a2);
    if (isNaN(s2)) return getMeasurement(t2);
    if (0 === s2) return 0;
    const n2 = Bn[r2];
    return n2 ? n2(s2) : s2;
  }
  function getRatio(e2) {
    if (!e2) return {
      num: 1,
      den: 1
    };
    const t2 = e2.trim().split(/\s*:\s*/).map((e3) => parseFloat(e3)).filter((e3) => !isNaN(e3));
    1 === t2.length && t2.push(1);
    if (0 === t2.length) return {
      num: 1,
      den: 1
    };
    const [i2, a2] = t2;
    return {
      num: i2,
      den: a2
    };
  }
  function getRelevant(e2) {
    return e2 ? e2.trim().split(/\s+/).map((e3) => ({
      excluded: "-" === e3[0],
      viewname: e3.substring(1)
    })) : [];
  }
  class HTMLResult {
    static get FAILURE() {
      return shadow(this, "FAILURE", new HTMLResult(false, null, null, null));
    }
    static get EMPTY() {
      return shadow(this, "EMPTY", new HTMLResult(true, null, null, null));
    }
    constructor(e2, t2, i2, a2) {
      this.success = e2;
      this.html = t2;
      this.bbox = i2;
      this.breakNode = a2;
    }
    isBreak() {
      return !!this.breakNode;
    }
    static breakNode(e2) {
      return new HTMLResult(false, null, null, e2);
    }
    static success(e2, t2 = null) {
      return new HTMLResult(true, e2, t2, null);
    }
  }
  class FontFinder {
    constructor(e2) {
      this.fonts = /* @__PURE__ */ new Map();
      this.cache = /* @__PURE__ */ new Map();
      this.warned = /* @__PURE__ */ new Set();
      this.defaultFont = null;
      this.add(e2);
    }
    add(e2, t2 = null) {
      for (const t3 of e2) this.addPdfFont(t3);
      for (const e3 of this.fonts.values()) e3.regular || (e3.regular = e3.italic || e3.bold || e3.bolditalic);
      if (!t2 || 0 === t2.size) return;
      const i2 = this.fonts.get("PdfJS-Fallback-PdfJS-XFA");
      for (const e3 of t2) this.fonts.set(e3, i2);
    }
    addPdfFont(e2) {
      var _a4, _b, _c;
      const t2 = e2.cssFontInfo, i2 = t2.fontFamily;
      let a2 = this.fonts.get(i2);
      if (!a2) {
        a2 = /* @__PURE__ */ Object.create(null);
        this.fonts.set(i2, a2);
        this.defaultFont || (this.defaultFont = a2);
      }
      let r2 = "";
      const s2 = parseFloat(t2.fontWeight);
      0 !== parseFloat(t2.italicAngle) ? r2 = s2 >= 700 ? "bolditalic" : "italic" : s2 >= 700 && (r2 = "bold");
      if (!r2) {
        (e2.name.includes("Bold") || ((_a4 = e2.psName) == null ? void 0 : _a4.includes("Bold"))) && (r2 = "bold");
        (e2.name.includes("Italic") || e2.name.endsWith("It") || ((_b = e2.psName) == null ? void 0 : _b.includes("Italic")) || ((_c = e2.psName) == null ? void 0 : _c.endsWith("It"))) && (r2 += "italic");
      }
      r2 || (r2 = "regular");
      a2[r2] = e2;
    }
    getDefault() {
      return this.defaultFont;
    }
    find(e2, t2 = true) {
      var _a4, _b;
      let i2 = this.fonts.get(e2) || this.cache.get(e2);
      if (i2) return i2;
      const a2 = /,|-|_| |bolditalic|bold|italic|regular|it/gi;
      let r2 = e2.replaceAll(a2, "");
      i2 = this.fonts.get(r2);
      if (i2) {
        this.cache.set(e2, i2);
        return i2;
      }
      r2 = r2.toLowerCase();
      const s2 = [];
      for (const [e3, t3] of this.fonts.entries()) e3.replaceAll(a2, "").toLowerCase().startsWith(r2) && s2.push(t3);
      if (0 === s2.length) for (const [, e3] of this.fonts.entries()) ((_a4 = e3.regular.name) == null ? void 0 : _a4.replaceAll(a2, "").toLowerCase().startsWith(r2)) && s2.push(e3);
      if (0 === s2.length) {
        r2 = r2.replaceAll(/psmt|mt/gi, "");
        for (const [e3, t3] of this.fonts.entries()) e3.replaceAll(a2, "").toLowerCase().startsWith(r2) && s2.push(t3);
      }
      if (0 === s2.length) for (const e3 of this.fonts.values()) ((_b = e3.regular.name) == null ? void 0 : _b.replaceAll(a2, "").toLowerCase().startsWith(r2)) && s2.push(e3);
      if (s2.length >= 1) {
        1 !== s2.length && t2 && warn(`XFA - Too many choices to guess the correct font: ${e2}`);
        this.cache.set(e2, s2[0]);
        return s2[0];
      }
      if (t2 && !this.warned.has(e2)) {
        this.warned.add(e2);
        warn(`XFA - Cannot find the font: ${e2}`);
      }
      return null;
    }
  }
  function selectFont(e2, t2) {
    return "italic" === e2.posture ? "bold" === e2.weight ? t2.bolditalic : t2.italic : "bold" === e2.weight ? t2.bold : t2.regular;
  }
  class FontInfo {
    constructor(e2, t2, i2, a2) {
      this.lineHeight = i2;
      this.paraMargin = t2 || {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!e2) {
        [this.pdfFont, this.xfaFont] = this.defaultFont(a2);
        return;
      }
      this.xfaFont = {
        typeface: e2.typeface,
        posture: e2.posture,
        weight: e2.weight,
        size: e2.size,
        letterSpacing: e2.letterSpacing
      };
      const r2 = a2.find(e2.typeface);
      if (r2) {
        this.pdfFont = selectFont(e2, r2);
        this.pdfFont || ([this.pdfFont, this.xfaFont] = this.defaultFont(a2));
      } else [this.pdfFont, this.xfaFont] = this.defaultFont(a2);
    }
    defaultFont(e2) {
      const t2 = e2.find("Helvetica", false) || e2.find("Myriad Pro", false) || e2.find("Arial", false) || e2.getDefault();
      if (t2 == null ? void 0 : t2.regular) {
        const e3 = t2.regular;
        return [
          e3,
          {
            typeface: e3.cssFontInfo.fontFamily,
            posture: "normal",
            weight: "normal",
            size: 10,
            letterSpacing: 0
          }
        ];
      }
      return [
        null,
        {
          typeface: "Courier",
          posture: "normal",
          weight: "normal",
          size: 10,
          letterSpacing: 0
        }
      ];
    }
  }
  class FontSelector {
    constructor(e2, t2, i2, a2) {
      this.fontFinder = a2;
      this.stack = [
        new FontInfo(e2, t2, i2, a2)
      ];
    }
    pushData(e2, t2, i2) {
      const a2 = this.stack.at(-1);
      for (const t3 of [
        "typeface",
        "posture",
        "weight",
        "size",
        "letterSpacing"
      ]) e2[t3] || (e2[t3] = a2.xfaFont[t3]);
      for (const e3 of [
        "top",
        "bottom",
        "left",
        "right"
      ]) isNaN(t2[e3]) && (t2[e3] = a2.paraMargin[e3]);
      const r2 = new FontInfo(e2, t2, i2 || a2.lineHeight, this.fontFinder);
      r2.pdfFont || (r2.pdfFont = a2.pdfFont);
      this.stack.push(r2);
    }
    popFont() {
      this.stack.pop();
    }
    topFont() {
      return this.stack.at(-1);
    }
  }
  class TextMeasure {
    constructor(e2, t2, i2, a2) {
      this.glyphs = [];
      this.fontSelector = new FontSelector(e2, t2, i2, a2);
      this.extraHeight = 0;
    }
    pushData(e2, t2, i2) {
      this.fontSelector.pushData(e2, t2, i2);
    }
    popFont(e2) {
      return this.fontSelector.popFont();
    }
    addPara() {
      const e2 = this.fontSelector.topFont();
      this.extraHeight += e2.paraMargin.top + e2.paraMargin.bottom;
    }
    addString(e2) {
      if (!e2) return;
      const t2 = this.fontSelector.topFont(), i2 = t2.xfaFont.size;
      if (t2.pdfFont) {
        const a2 = t2.xfaFont.letterSpacing, r2 = t2.pdfFont, s2 = r2.lineHeight || 1.2, n2 = t2.lineHeight || Math.max(1.2, s2) * i2, o2 = s2 - (void 0 === r2.lineGap ? 0.2 : r2.lineGap), g2 = Math.max(1, o2) * i2, c2 = i2 / 1e3, C2 = r2.defaultWidth || r2.charsToGlyphs(" ")[0].width;
        for (const t3 of e2.split(/[\u2029\n]/)) {
          const e3 = r2.encodeString(t3).join(""), i3 = r2.charsToGlyphs(e3);
          for (const e4 of i3) {
            const t4 = e4.width || C2;
            this.glyphs.push([
              t4 * c2 + a2,
              n2,
              g2,
              e4.unicode,
              false
            ]);
          }
          this.glyphs.push([
            0,
            0,
            0,
            "\n",
            true
          ]);
        }
        this.glyphs.pop();
      } else {
        for (const t3 of e2.split(/[\u2029\n]/)) {
          for (const e3 of t3.split("")) this.glyphs.push([
            i2,
            1.2 * i2,
            i2,
            e3,
            false
          ]);
          this.glyphs.push([
            0,
            0,
            0,
            "\n",
            true
          ]);
        }
        this.glyphs.pop();
      }
    }
    compute(e2) {
      let t2 = -1, i2 = 0, a2 = 0, r2 = 0, s2 = 0, n2 = 0, o2 = false, g2 = true;
      for (let c2 = 0, C2 = this.glyphs.length; c2 < C2; c2++) {
        const [C3, h2, l2, Q2, E2] = this.glyphs[c2], u2 = " " === Q2, d2 = g2 ? l2 : h2;
        if (E2) {
          a2 = Math.max(a2, s2);
          s2 = 0;
          r2 += n2;
          n2 = d2;
          t2 = -1;
          i2 = 0;
          g2 = false;
        } else if (u2) if (s2 + C3 > e2) {
          a2 = Math.max(a2, s2);
          s2 = 0;
          r2 += n2;
          n2 = d2;
          t2 = -1;
          i2 = 0;
          o2 = true;
          g2 = false;
        } else {
          n2 = Math.max(d2, n2);
          i2 = s2;
          s2 += C3;
          t2 = c2;
        }
        else if (s2 + C3 > e2) {
          r2 += n2;
          n2 = d2;
          if (-1 !== t2) {
            c2 = t2;
            a2 = Math.max(a2, i2);
            s2 = 0;
            t2 = -1;
            i2 = 0;
          } else {
            a2 = Math.max(a2, s2);
            s2 = C3;
          }
          o2 = true;
          g2 = false;
        } else {
          s2 += C3;
          n2 = Math.max(d2, n2);
        }
      }
      a2 = Math.max(a2, s2);
      r2 += n2 + this.extraHeight;
      return {
        width: 1.02 * a2,
        height: r2,
        isBroken: o2
      };
    }
  }
  const En = /^[^.[]+/, un = /^[^\]]+/, dn = {
    dot: 0,
    dotDot: 1,
    dotHash: 2,
    dotBracket: 3,
    dotParen: 4
  }, fn = /* @__PURE__ */ new Map([
    [
      "$data",
      (e2, t2) => e2.datasets ? e2.datasets.data : e2
    ],
    [
      "$record",
      (e2, t2) => (e2.datasets ? e2.datasets.data : e2)[ps]()[0]
    ],
    [
      "$template",
      (e2, t2) => e2.template
    ],
    [
      "$connectionSet",
      (e2, t2) => e2.connectionSet
    ],
    [
      "$form",
      (e2, t2) => e2.form
    ],
    [
      "$layout",
      (e2, t2) => e2.layout
    ],
    [
      "$host",
      (e2, t2) => e2.host
    ],
    [
      "$dataWindow",
      (e2, t2) => e2.dataWindow
    ],
    [
      "$event",
      (e2, t2) => e2.event
    ],
    [
      "!",
      (e2, t2) => e2.datasets
    ],
    [
      "$xfa",
      (e2, t2) => e2
    ],
    [
      "xfa",
      (e2, t2) => e2
    ],
    [
      "$",
      (e2, t2) => t2
    ]
  ]), pn = /* @__PURE__ */ new WeakMap();
  function parseExpression(e2, t2, i2 = true) {
    let a2 = e2.match(En);
    if (!a2) return null;
    let [r2] = a2;
    const s2 = [
      {
        name: r2,
        cacheName: "." + r2,
        index: 0,
        js: null,
        formCalc: null,
        operator: dn.dot
      }
    ];
    let n2 = r2.length;
    for (; n2 < e2.length; ) {
      const g2 = n2;
      if ("[" === e2.charAt(n2++)) {
        a2 = e2.slice(n2).match(un);
        if (!a2) {
          warn("XFA - Invalid index in SOM expression");
          return null;
        }
        s2.at(-1).index = "*" === (o2 = (o2 = a2[0]).trim()) ? 1 / 0 : parseInt(o2, 10) || 0;
        n2 += a2[0].length + 1;
        continue;
      }
      let c2;
      switch (e2.charAt(n2)) {
        case ".":
          if (!t2) return null;
          n2++;
          c2 = dn.dotDot;
          break;
        case "#":
          n2++;
          c2 = dn.dotHash;
          break;
        case "[":
          if (i2) {
            warn("XFA - SOM expression contains a FormCalc subexpression which is not supported for now.");
            return null;
          }
          c2 = dn.dotBracket;
          break;
        case "(":
          if (i2) {
            warn("XFA - SOM expression contains a JavaScript subexpression which is not supported for now.");
            return null;
          }
          c2 = dn.dotParen;
          break;
        default:
          c2 = dn.dot;
      }
      a2 = e2.slice(n2).match(En);
      if (!a2) break;
      [r2] = a2;
      n2 += r2.length;
      s2.push({
        name: r2,
        cacheName: e2.slice(g2, n2),
        operator: c2,
        index: 0,
        js: null,
        formCalc: null
      });
    }
    var o2;
    return s2;
  }
  function searchNode(e2, t2, i2, a2 = true, r2 = true) {
    const s2 = parseExpression(i2, a2);
    if (!s2) return null;
    const n2 = fn.get(s2[0].name);
    let o2, g2 = 0;
    if (n2) {
      o2 = true;
      e2 = [
        n2(e2, t2)
      ];
      g2 = 1;
    } else {
      o2 = null === t2;
      e2 = [
        t2 || e2
      ];
    }
    for (let i3 = s2.length; g2 < i3; g2++) {
      const { name: i4, cacheName: a3, operator: n3, index: c2 } = s2[g2], C2 = [];
      for (const t3 of e2) {
        if (!t3.isXFAObject) continue;
        let e3, s3;
        if (r2) {
          s3 = pn.get(t3);
          if (!s3) {
            s3 = /* @__PURE__ */ new Map();
            pn.set(t3, s3);
          }
          e3 = s3.get(a3);
        }
        if (!e3) {
          switch (n3) {
            case dn.dot:
              e3 = t3[Qs](i4, false);
              break;
            case dn.dotDot:
              e3 = t3[Qs](i4, true);
              break;
            case dn.dotHash:
              e3 = t3[Bs](i4);
              e3 = e3.isXFAObjectArray ? e3.children : [
                e3
              ];
          }
          r2 && s3.set(a3, e3);
        }
        e3.length > 0 && C2.push(e3);
      }
      if (0 !== C2.length || o2 || 0 !== g2) e2 = isFinite(c2) ? C2.filter((e3) => c2 < e3.length).map((e3) => e3[c2]) : C2.flat();
      else {
        const i5 = t2[bs]();
        if (!(t2 = i5)) return null;
        g2 = -1;
        e2 = [
          t2
        ];
      }
    }
    return 0 === e2.length ? null : e2;
  }
  function createDataNode(e2, t2, i2) {
    const a2 = parseExpression(i2);
    if (!a2) return null;
    if (a2.some((e3) => e3.operator === dn.dotDot)) return null;
    const r2 = fn.get(a2[0].name);
    let s2 = 0;
    if (r2) {
      e2 = r2(e2, t2);
      s2 = 1;
    } else e2 = t2 || e2;
    for (let t3 = a2.length; s2 < t3; s2++) {
      const { name: t4, operator: i3, index: r3 } = a2[s2];
      if (!isFinite(r3)) {
        a2[s2].index = 0;
        return e2.createNodes(a2.slice(s2));
      }
      let n2;
      switch (i3) {
        case dn.dot:
          n2 = e2[Qs](t4, false);
          break;
        case dn.dotDot:
          n2 = e2[Qs](t4, true);
          break;
        case dn.dotHash:
          n2 = e2[Bs](t4);
          n2 = n2.isXFAObjectArray ? n2.children : [
            n2
          ];
      }
      if (0 === n2.length) return e2.createNodes(a2.slice(s2));
      if (!(r3 < n2.length)) {
        a2[s2].index = r3 - n2.length;
        return e2.createNodes(a2.slice(s2));
      }
      {
        const t5 = n2[r3];
        if (!t5.isXFAObject) {
          warn("XFA - Cannot create a node.");
          return null;
        }
        e2 = t5;
      }
    }
    return null;
  }
  const mn = Symbol(), yn = Symbol(), wn = Symbol(), bn = Symbol("_children"), Dn = Symbol(), Fn = Symbol(), Sn = Symbol(), kn = Symbol(), Rn = Symbol(), Nn = Symbol(), Gn = Symbol(), xn = Symbol(), Un = Symbol(), Mn = Symbol("parent"), Ln = Symbol(), Hn = Symbol(), Jn = Symbol();
  let vn = 0;
  const Yn = ln.datasets.id;
  class XFAObject {
    constructor(e2, t2, i2 = false) {
      this[Ks] = e2;
      this[qs] = t2;
      this[Gn] = i2;
      this[Mn] = null;
      this[bn] = [];
      this[Cn] = `${t2}${vn++}`;
      this[Fs] = null;
    }
    get isXFAObject() {
      return true;
    }
    get isXFAObjectArray() {
      return false;
    }
    createNodes(e2) {
      let t2 = this, i2 = null;
      for (const { name: a2, index: r2 } of e2) {
        for (let e3 = 0, s2 = isFinite(r2) ? r2 : 0; e3 <= s2; e3++) {
          const e4 = t2[Ks] === Yn ? -1 : t2[Ks];
          i2 = new XmlObject(e4, a2);
          t2[$r](i2);
        }
        t2 = i2;
      }
      return i2;
    }
    [Ws](e2) {
      if (!this[Gn] || !this[js](e2)) return false;
      const t2 = e2[qs], i2 = this[t2];
      if (!(i2 instanceof XFAObjectArray)) {
        null !== i2 && this[zs](i2);
        this[t2] = e2;
        this[$r](e2);
        return true;
      }
      if (i2.push(e2)) {
        this[$r](e2);
        return true;
      }
      let a2 = "";
      this.id ? a2 = ` (id: ${this.id})` : this.name && (a2 = ` (name: ${this.name} ${this.h.value})`);
      warn(`XFA - node "${this[qs]}"${a2} has already enough "${t2}"!`);
      return false;
    }
    [js](e2) {
      return this.hasOwnProperty(e2[qs]) && e2[Ks] === this[Ks];
    }
    [Ls]() {
      return false;
    }
    [_r]() {
      return false;
    }
    [Gs]() {
      return false;
    }
    [xs]() {
      return false;
    }
    [Vs]() {
      this.para && this[Ds]()[gs].paraStack.pop();
    }
    [_s]() {
      this[Ds]()[gs].paraStack.push(this.para);
    }
    [tn](e2) {
      this.id && this[Ks] === ln.template.id && e2.set(this.id, this);
    }
    [Ds]() {
      return this[Fs].template;
    }
    [Hs]() {
      return false;
    }
    [Js]() {
      return false;
    }
    [$r](e2) {
      e2[Mn] = this;
      this[bn].push(e2);
      !e2[Fs] && this[Fs] && (e2[Fs] = this[Fs]);
    }
    [zs](e2) {
      const t2 = this[bn].indexOf(e2);
      this[bn].splice(t2, 1);
    }
    [Ss]() {
      return this.hasOwnProperty("value");
    }
    [rn](e2) {
    }
    [Xs](e2) {
    }
    [Is]() {
    }
    [es](e2) {
      delete this[Gn];
      if (this[is]) {
        e2.clean(this[is]);
        delete this[is];
      }
    }
    [Rs](e2) {
      return this[bn].indexOf(e2);
    }
    [Ns](e2, t2) {
      t2[Mn] = this;
      this[bn].splice(e2, 0, t2);
      !t2[Fs] && this[Fs] && (t2[Fs] = this[Fs]);
    }
    [vs]() {
      return !this.name;
    }
    [Ts]() {
      return "";
    }
    [nn]() {
      return 0 === this[bn].length ? this[ss] : this[bn].map((e2) => e2[nn]()).join("");
    }
    get [wn]() {
      const e2 = Object.getPrototypeOf(this);
      if (!e2._attributes) {
        const t2 = e2._attributes = /* @__PURE__ */ new Set();
        for (const e3 of Object.getOwnPropertyNames(this)) {
          if (null === this[e3] || this[e3] instanceof XFAObject || this[e3] instanceof XFAObjectArray) break;
          t2.add(e3);
        }
      }
      return shadow(this, wn, e2._attributes);
    }
    [Ms](e2) {
      let t2 = this;
      for (; t2; ) {
        if (t2 === e2) return true;
        t2 = t2[bs]();
      }
      return false;
    }
    [bs]() {
      return this[Mn];
    }
    [ws]() {
      return this[bs]();
    }
    [ps](e2 = null) {
      return e2 ? this[e2] : this[bn];
    }
    [os]() {
      const e2 = /* @__PURE__ */ Object.create(null);
      this[ss] && (e2.$content = this[ss]);
      for (const t2 of Object.getOwnPropertyNames(this)) {
        const i2 = this[t2];
        null !== i2 && (i2 instanceof XFAObject ? e2[t2] = i2[os]() : i2 instanceof XFAObjectArray ? i2.isEmpty() || (e2[t2] = i2.dump()) : e2[t2] = i2);
      }
      return e2;
    }
    [cn]() {
      return null;
    }
    [gn]() {
      return HTMLResult.EMPTY;
    }
    *[ms]() {
      for (const e2 of this[ps]()) yield e2;
    }
    *[kn](e2, t2) {
      for (const i2 of this[ms]()) if (!e2 || t2 === e2.has(i2[qs])) {
        const e3 = this[ls](), t3 = i2[gn](e3);
        t3.success || (this[gs].failingNode = i2);
        yield t3;
      }
    }
    [cs]() {
      return null;
    }
    [zr](e2, t2) {
      this[gs].children.push(e2);
    }
    [ls]() {
    }
    [As]({ filter: e2 = null, include: t2 = true }) {
      if (this[gs].generator) {
        const e3 = this[ls](), t3 = this[gs].failingNode[gn](e3);
        if (!t3.success) return t3;
        t3.html && this[zr](t3.html, t3.bbox);
        delete this[gs].failingNode;
      } else this[gs].generator = this[kn](e2, t2);
      for (; ; ) {
        const e3 = this[gs].generator.next();
        if (e3.done) break;
        const t3 = e3.value;
        if (!t3.success) return t3;
        t3.html && this[zr](t3.html, t3.bbox);
      }
      this[gs].generator = null;
      return HTMLResult.EMPTY;
    }
    [an](e2) {
      this[Hn] = new Set(Object.keys(e2));
    }
    [Nn](e2) {
      const t2 = this[wn], i2 = this[Hn];
      return [
        ...e2
      ].filter((e3) => t2.has(e3) && !i2.has(e3));
    }
    [An](e2, t2 = /* @__PURE__ */ new Set()) {
      for (const i2 of this[bn]) i2[Ln](e2, t2);
    }
    [Ln](e2, t2) {
      const i2 = this[Rn](e2, t2);
      i2 ? this[mn](i2, e2, t2) : this[An](e2, t2);
    }
    [Rn](e2, t2) {
      const { use: i2, usehref: a2 } = this;
      if (!i2 && !a2) return null;
      let r2 = null, s2 = null, n2 = null, o2 = i2;
      if (a2) {
        o2 = a2;
        a2.startsWith("#som(") && a2.endsWith(")") ? s2 = a2.slice(5, -1) : a2.startsWith(".#som(") && a2.endsWith(")") ? s2 = a2.slice(6, -1) : a2.startsWith("#") ? n2 = a2.slice(1) : a2.startsWith(".#") && (n2 = a2.slice(2));
      } else i2.startsWith("#") ? n2 = i2.slice(1) : s2 = i2;
      this.use = this.usehref = "";
      if (n2) r2 = e2.get(n2);
      else {
        r2 = searchNode(e2.get($s), this, s2, true, false);
        r2 && (r2 = r2[0]);
      }
      if (!r2) {
        warn(`XFA - Invalid prototype reference: ${o2}.`);
        return null;
      }
      if (r2[qs] !== this[qs]) {
        warn(`XFA - Incompatible prototype: ${r2[qs]} !== ${this[qs]}.`);
        return null;
      }
      if (t2.has(r2)) {
        warn("XFA - Cycle detected in prototypes use.");
        return null;
      }
      t2.add(r2);
      const g2 = r2[Rn](e2, t2);
      g2 && r2[mn](g2, e2, t2);
      r2[An](e2, t2);
      t2.delete(r2);
      return r2;
    }
    [mn](e2, t2, i2) {
      if (i2.has(e2)) {
        warn("XFA - Cycle detected in prototypes use.");
        return;
      }
      !this[ss] && e2[ss] && (this[ss] = e2[ss]);
      new Set(i2).add(e2);
      for (const t3 of this[Nn](e2[Hn])) {
        this[t3] = e2[t3];
        this[Hn] && this[Hn].add(t3);
      }
      for (const a2 of Object.getOwnPropertyNames(this)) {
        if (this[wn].has(a2)) continue;
        const r2 = this[a2], s2 = e2[a2];
        if (r2 instanceof XFAObjectArray) {
          for (const e3 of r2[bn]) e3[Ln](t2, i2);
          for (let a3 = r2[bn].length, n2 = s2[bn].length; a3 < n2; a3++) {
            const s3 = e2[bn][a3][as]();
            if (!r2.push(s3)) break;
            s3[Mn] = this;
            this[bn].push(s3);
            s3[Ln](t2, i2);
          }
        } else if (null === r2) {
          if (null !== s2) {
            const e3 = s2[as]();
            e3[Mn] = this;
            this[a2] = e3;
            this[bn].push(e3);
            e3[Ln](t2, i2);
          }
        } else {
          r2[An](t2, i2);
          s2 && r2[mn](s2, t2, i2);
        }
      }
    }
    static [Dn](e2) {
      return Array.isArray(e2) ? e2.map((e3) => XFAObject[Dn](e3)) : "object" == typeof e2 && null !== e2 ? Object.assign({}, e2) : e2;
    }
    [as]() {
      const e2 = Object.create(Object.getPrototypeOf(this));
      for (const t2 of Object.getOwnPropertySymbols(this)) try {
        e2[t2] = this[t2];
      } catch {
        shadow(e2, t2, this[t2]);
      }
      e2[Cn] = `${e2[qs]}${vn++}`;
      e2[bn] = [];
      for (const t2 of Object.getOwnPropertyNames(this)) {
        if (this[wn].has(t2)) {
          e2[t2] = XFAObject[Dn](this[t2]);
          continue;
        }
        const i2 = this[t2];
        e2[t2] = i2 instanceof XFAObjectArray ? new XFAObjectArray(i2[xn]) : null;
      }
      for (const t2 of this[bn]) {
        const i2 = t2[qs], a2 = t2[as]();
        e2[bn].push(a2);
        a2[Mn] = e2;
        null === e2[i2] ? e2[i2] = a2 : e2[i2][bn].push(a2);
      }
      return e2;
    }
    [ps](e2 = null) {
      return e2 ? this[bn].filter((t2) => t2[qs] === e2) : this[bn];
    }
    [Bs](e2) {
      return this[e2];
    }
    [Qs](e2, t2, i2 = true) {
      return Array.from(this[Es](e2, t2, i2));
    }
    *[Es](e2, t2, i2 = true) {
      if ("parent" !== e2) {
        for (const i3 of this[bn]) {
          i3[qs] === e2 && (yield i3);
          i3.name === e2 && (yield i3);
          (t2 || i3[vs]()) && (yield* i3[Es](e2, t2, false));
        }
        i2 && this[wn].has(e2) && (yield new XFAAttribute(this, e2, this[e2]));
      } else yield this[Mn];
    }
  }
  class XFAObjectArray {
    constructor(e2 = 1 / 0) {
      this[xn] = e2;
      this[bn] = [];
    }
    get isXFAObject() {
      return false;
    }
    get isXFAObjectArray() {
      return true;
    }
    push(e2) {
      if (this[bn].length <= this[xn]) {
        this[bn].push(e2);
        return true;
      }
      warn(`XFA - node "${e2[qs]}" accepts no more than ${this[xn]} children`);
      return false;
    }
    isEmpty() {
      return 0 === this[bn].length;
    }
    dump() {
      return 1 === this[bn].length ? this[bn][0][os]() : this[bn].map((e2) => e2[os]());
    }
    [as]() {
      const e2 = new XFAObjectArray(this[xn]);
      e2[bn] = this[bn].map((e3) => e3[as]());
      return e2;
    }
    get children() {
      return this[bn];
    }
    clear() {
      this[bn].length = 0;
    }
  }
  class XFAAttribute {
    constructor(e2, t2, i2) {
      this[Mn] = e2;
      this[qs] = t2;
      this[ss] = i2;
      this[rs] = false;
      this[Cn] = "attribute" + vn++;
    }
    [bs]() {
      return this[Mn];
    }
    [Us]() {
      return true;
    }
    [us]() {
      return this[ss].trim();
    }
    [rn](e2) {
      e2 = e2.value || "";
      this[ss] = e2.toString();
    }
    [nn]() {
      return this[ss];
    }
    [Ms](e2) {
      return this[Mn] === e2 || this[Mn][Ms](e2);
    }
  }
  class XmlObject extends XFAObject {
    constructor(e2, t2, i2 = {}) {
      super(e2, t2);
      this[ss] = "";
      this[Fn] = null;
      if ("#text" !== t2) {
        const e3 = /* @__PURE__ */ new Map();
        this[yn] = e3;
        for (const [t3, a2] of Object.entries(i2)) e3.set(t3, new XFAAttribute(this, t3, a2));
        if (i2.hasOwnProperty(Os)) {
          const e4 = i2[Os].xfa.dataNode;
          void 0 !== e4 && ("dataGroup" === e4 ? this[Fn] = false : "dataValue" === e4 && (this[Fn] = true));
        }
      }
      this[rs] = false;
    }
    [In](e2) {
      const t2 = this[qs];
      if ("#text" === t2) {
        e2.push(encodeToXmlString(this[ss]));
        return;
      }
      const i2 = utf8StringToString(t2), a2 = this[Ks] === Yn ? "xfa:" : "";
      e2.push(`<${a2}${i2}`);
      for (const [t3, i3] of this[yn].entries()) {
        const a3 = utf8StringToString(t3);
        e2.push(` ${a3}="${encodeToXmlString(i3[ss])}"`);
      }
      null !== this[Fn] && (this[Fn] ? e2.push(' xfa:dataNode="dataValue"') : e2.push(' xfa:dataNode="dataGroup"'));
      if (this[ss] || 0 !== this[bn].length) {
        e2.push(">");
        if (this[ss]) "string" == typeof this[ss] ? e2.push(encodeToXmlString(this[ss])) : this[ss][In](e2);
        else for (const t3 of this[bn]) t3[In](e2);
        e2.push(`</${a2}${i2}>`);
      } else e2.push("/>");
    }
    [Ws](e2) {
      if (this[ss]) {
        const e3 = new XmlObject(this[Ks], "#text");
        this[$r](e3);
        e3[ss] = this[ss];
        this[ss] = "";
      }
      this[$r](e2);
      return true;
    }
    [Xs](e2) {
      this[ss] += e2;
    }
    [Is]() {
      if (this[ss] && this[bn].length > 0) {
        const e2 = new XmlObject(this[Ks], "#text");
        this[$r](e2);
        e2[ss] = this[ss];
        delete this[ss];
      }
    }
    [gn]() {
      return "#text" === this[qs] ? HTMLResult.success({
        name: "#text",
        value: this[ss]
      }) : HTMLResult.EMPTY;
    }
    [ps](e2 = null) {
      return e2 ? this[bn].filter((t2) => t2[qs] === e2) : this[bn];
    }
    [hs]() {
      return this[yn];
    }
    [Bs](e2) {
      const t2 = this[yn].get(e2);
      return void 0 !== t2 ? t2 : this[ps](e2);
    }
    *[Es](e2, t2) {
      const i2 = this[yn].get(e2);
      i2 && (yield i2);
      for (const i3 of this[bn]) {
        i3[qs] === e2 && (yield i3);
        t2 && (yield* i3[Es](e2, t2));
      }
    }
    *[Cs](e2, t2) {
      const i2 = this[yn].get(e2);
      !i2 || t2 && i2[rs] || (yield i2);
      for (const i3 of this[bn]) yield* i3[Cs](e2, t2);
    }
    *[fs](e2, t2, i2) {
      for (const a2 of this[bn]) {
        a2[qs] !== e2 || i2 && a2[rs] || (yield a2);
        t2 && (yield* a2[fs](e2, t2, i2));
      }
    }
    [Us]() {
      return null === this[Fn] ? 0 === this[bn].length || this[bn][0][Ks] === ln.xhtml.id : this[Fn];
    }
    [us]() {
      return null === this[Fn] ? 0 === this[bn].length ? this[ss].trim() : this[bn][0][Ks] === ln.xhtml.id ? this[bn][0][nn]().trim() : null : this[ss].trim();
    }
    [rn](e2) {
      e2 = e2.value || "";
      this[ss] = e2.toString();
    }
    [os](e2 = false) {
      const t2 = /* @__PURE__ */ Object.create(null);
      e2 && (t2.$ns = this[Ks]);
      this[ss] && (t2.$content = this[ss]);
      t2.$name = this[qs];
      t2.children = [];
      for (const i2 of this[bn]) t2.children.push(i2[os](e2));
      t2.attributes = /* @__PURE__ */ Object.create(null);
      for (const [e3, i2] of this[yn]) t2.attributes[e3] = i2[ss];
      return t2;
    }
  }
  class ContentObject extends XFAObject {
    constructor(e2, t2) {
      super(e2, t2);
      this[ss] = "";
    }
    [Xs](e2) {
      this[ss] += e2;
    }
    [Is]() {
    }
  }
  class OptionObject extends ContentObject {
    constructor(e2, t2, i2) {
      super(e2, t2);
      this[Un] = i2;
    }
    [Is]() {
      this[ss] = getKeyword({
        data: this[ss],
        defaultValue: this[Un][0],
        validate: (e2) => this[Un].includes(e2)
      });
    }
    [es](e2) {
      super[es](e2);
      delete this[Un];
    }
  }
  class StringObject extends ContentObject {
    [Is]() {
      this[ss] = this[ss].trim();
    }
  }
  class IntegerObject extends ContentObject {
    constructor(e2, t2, i2, a2) {
      super(e2, t2);
      this[Sn] = i2;
      this[Jn] = a2;
    }
    [Is]() {
      this[ss] = getInteger({
        data: this[ss],
        defaultValue: this[Sn],
        validate: this[Jn]
      });
    }
    [es](e2) {
      super[es](e2);
      delete this[Sn];
      delete this[Jn];
    }
  }
  class Option01 extends IntegerObject {
    constructor(e2, t2) {
      super(e2, t2, 0, (e3) => 1 === e3);
    }
  }
  class Option10 extends IntegerObject {
    constructor(e2, t2) {
      super(e2, t2, 1, (e3) => 0 === e3);
    }
  }
  function measureToString(e2) {
    return "string" == typeof e2 ? "0px" : Number.isInteger(e2) ? `${e2}px` : `${e2.toFixed(2)}px`;
  }
  const Tn = {
    anchorType(e2, t2) {
      const i2 = e2[ws]();
      if (i2 && (!i2.layout || "position" === i2.layout)) {
        "transform" in t2 || (t2.transform = "");
        switch (e2.anchorType) {
          case "bottomCenter":
            t2.transform += "translate(-50%, -100%)";
            break;
          case "bottomLeft":
            t2.transform += "translate(0,-100%)";
            break;
          case "bottomRight":
            t2.transform += "translate(-100%,-100%)";
            break;
          case "middleCenter":
            t2.transform += "translate(-50%,-50%)";
            break;
          case "middleLeft":
            t2.transform += "translate(0,-50%)";
            break;
          case "middleRight":
            t2.transform += "translate(-100%,-50%)";
            break;
          case "topCenter":
            t2.transform += "translate(-50%,0)";
            break;
          case "topRight":
            t2.transform += "translate(-100%,0)";
        }
      }
    },
    dimensions(e2, t2) {
      var _a4;
      const i2 = e2[ws]();
      let a2 = e2.w;
      const r2 = e2.h;
      if ((_a4 = i2.layout) == null ? void 0 : _a4.includes("row")) {
        const t3 = i2[gs], r3 = e2.colSpan;
        let s2;
        if (-1 === r3) {
          s2 = t3.columnWidths.slice(t3.currentColumn).reduce((e3, t4) => e3 + t4, 0);
          t3.currentColumn = 0;
        } else {
          s2 = t3.columnWidths.slice(t3.currentColumn, t3.currentColumn + r3).reduce((e3, t4) => e3 + t4, 0);
          t3.currentColumn = (t3.currentColumn + e2.colSpan) % t3.columnWidths.length;
        }
        isNaN(s2) || (a2 = e2.w = s2);
      }
      t2.width = "" !== a2 ? measureToString(a2) : "auto";
      t2.height = "" !== r2 ? measureToString(r2) : "auto";
    },
    position(e2, t2) {
      const i2 = e2[ws]();
      if (!(i2 == null ? void 0 : i2.layout) || "position" === i2.layout) {
        t2.position = "absolute";
        t2.left = measureToString(e2.x);
        t2.top = measureToString(e2.y);
      }
    },
    rotate(e2, t2) {
      if (e2.rotate) {
        "transform" in t2 || (t2.transform = "");
        t2.transform += `rotate(-${e2.rotate}deg)`;
        t2.transformOrigin = "top left";
      }
    },
    presence(e2, t2) {
      switch (e2.presence) {
        case "invisible":
          t2.visibility = "hidden";
          break;
        case "hidden":
        case "inactive":
          t2.display = "none";
      }
    },
    hAlign(e2, t2) {
      if ("para" === e2[qs]) switch (e2.hAlign) {
        case "justifyAll":
          t2.textAlign = "justify-all";
          break;
        case "radix":
          t2.textAlign = "left";
          break;
        default:
          t2.textAlign = e2.hAlign;
      }
      else switch (e2.hAlign) {
        case "left":
          t2.alignSelf = "start";
          break;
        case "center":
          t2.alignSelf = "center";
          break;
        case "right":
          t2.alignSelf = "end";
      }
    },
    margin(e2, t2) {
      e2.margin && (t2.margin = e2.margin[cn]().margin);
    }
  };
  function setMinMaxDimensions(e2, t2) {
    if ("position" === e2[ws]().layout) {
      e2.minW > 0 && (t2.minWidth = measureToString(e2.minW));
      e2.maxW > 0 && (t2.maxWidth = measureToString(e2.maxW));
      e2.minH > 0 && (t2.minHeight = measureToString(e2.minH));
      e2.maxH > 0 && (t2.maxHeight = measureToString(e2.maxH));
    }
  }
  function layoutText(e2, t2, i2, a2, r2, s2) {
    const n2 = new TextMeasure(t2, i2, a2, r2);
    "string" == typeof e2 ? n2.addString(e2) : e2[Zs](n2);
    return n2.compute(s2);
  }
  function layoutNode(e2, t2) {
    let i2 = null, a2 = null, r2 = false;
    if ((!e2.w || !e2.h) && e2.value) {
      let s2 = 0, n2 = 0;
      if (e2.margin) {
        s2 = e2.margin.leftInset + e2.margin.rightInset;
        n2 = e2.margin.topInset + e2.margin.bottomInset;
      }
      let o2 = null, g2 = null;
      if (e2.para) {
        g2 = /* @__PURE__ */ Object.create(null);
        o2 = "" === e2.para.lineHeight ? null : e2.para.lineHeight;
        g2.top = "" === e2.para.spaceAbove ? 0 : e2.para.spaceAbove;
        g2.bottom = "" === e2.para.spaceBelow ? 0 : e2.para.spaceBelow;
        g2.left = "" === e2.para.marginLeft ? 0 : e2.para.marginLeft;
        g2.right = "" === e2.para.marginRight ? 0 : e2.para.marginRight;
      }
      let c2 = e2.font;
      if (!c2) {
        const t3 = e2[Ds]();
        let i3 = e2[bs]();
        for (; i3 && i3 !== t3; ) {
          if (i3.font) {
            c2 = i3.font;
            break;
          }
          i3 = i3[bs]();
        }
      }
      const C2 = (e2.w || t2.width) - s2, h2 = e2[Fs].fontFinder;
      if (e2.value.exData && e2.value.exData[ss] && "text/html" === e2.value.exData.contentType) {
        const t3 = layoutText(e2.value.exData[ss], c2, g2, o2, h2, C2);
        a2 = t3.width;
        i2 = t3.height;
        r2 = t3.isBroken;
      } else {
        const t3 = e2.value[nn]();
        if (t3) {
          const e3 = layoutText(t3, c2, g2, o2, h2, C2);
          a2 = e3.width;
          i2 = e3.height;
          r2 = e3.isBroken;
        }
      }
      null === a2 || e2.w || (a2 += s2);
      null === i2 || e2.h || (i2 += n2);
    }
    return {
      w: a2,
      h: i2,
      isBroken: r2
    };
  }
  function computeBbox(e2, t2, i2) {
    let a2;
    if ("" !== e2.w && "" !== e2.h) a2 = [
      e2.x,
      e2.y,
      e2.w,
      e2.h
    ];
    else {
      if (!i2) return null;
      let r2 = e2.w;
      if ("" === r2) {
        if (0 === e2.maxW) {
          const t3 = e2[ws]();
          r2 = "position" === t3.layout && "" !== t3.w ? 0 : e2.minW;
        } else r2 = Math.min(e2.maxW, i2.width);
        t2.attributes.style.width = measureToString(r2);
      }
      let s2 = e2.h;
      if ("" === s2) {
        if (0 === e2.maxH) {
          const t3 = e2[ws]();
          s2 = "position" === t3.layout && "" !== t3.h ? 0 : e2.minH;
        } else s2 = Math.min(e2.maxH, i2.height);
        t2.attributes.style.height = measureToString(s2);
      }
      a2 = [
        e2.x,
        e2.y,
        r2,
        s2
      ];
    }
    return a2;
  }
  function fixDimensions(e2) {
    var _a4;
    const t2 = e2[ws]();
    if ((_a4 = t2.layout) == null ? void 0 : _a4.includes("row")) {
      const i2 = t2[gs], a2 = e2.colSpan;
      let r2;
      r2 = -1 === a2 ? i2.columnWidths.slice(i2.currentColumn).reduce((e3, t3) => e3 + t3, 0) : i2.columnWidths.slice(i2.currentColumn, i2.currentColumn + a2).reduce((e3, t3) => e3 + t3, 0);
      isNaN(r2) || (e2.w = r2);
    }
    t2.layout && "position" !== t2.layout && (e2.x = e2.y = 0);
    "table" === e2.layout && "" === e2.w && Array.isArray(e2.columnWidths) && (e2.w = e2.columnWidths.reduce((e3, t3) => e3 + t3, 0));
  }
  function layoutClass(e2) {
    switch (e2.layout) {
      case "position":
      default:
        return "xfaPosition";
      case "lr-tb":
        return "xfaLrTb";
      case "rl-row":
        return "xfaRlRow";
      case "rl-tb":
        return "xfaRlTb";
      case "row":
        return "xfaRow";
      case "table":
        return "xfaTable";
      case "tb":
        return "xfaTb";
    }
  }
  function toStyle(e2, ...t2) {
    const i2 = /* @__PURE__ */ Object.create(null);
    for (const a2 of t2) {
      const t3 = e2[a2];
      if (null !== t3) {
        if (Tn.hasOwnProperty(a2)) Tn[a2](e2, i2);
        else if (t3 instanceof XFAObject) {
          const e3 = t3[cn]();
          e3 ? Object.assign(i2, e3) : warn(`(DEBUG) - XFA - style for ${a2} not implemented yet`);
        }
      }
    }
    return i2;
  }
  function createWrapper(e2, t2) {
    const { attributes: i2 } = t2, { style: a2 } = i2, r2 = {
      name: "div",
      attributes: {
        class: [
          "xfaWrapper"
        ],
        style: /* @__PURE__ */ Object.create(null)
      },
      children: []
    };
    i2.class.push("xfaWrapped");
    if (e2.border) {
      const { widths: i3, insets: s2 } = e2.border[gs];
      let n2, o2, g2 = s2[0], c2 = s2[3];
      const C2 = s2[0] + s2[2], h2 = s2[1] + s2[3];
      switch (e2.border.hand) {
        case "even":
          g2 -= i3[0] / 2;
          c2 -= i3[3] / 2;
          n2 = `calc(100% + ${(i3[1] + i3[3]) / 2 - h2}px)`;
          o2 = `calc(100% + ${(i3[0] + i3[2]) / 2 - C2}px)`;
          break;
        case "left":
          g2 -= i3[0];
          c2 -= i3[3];
          n2 = `calc(100% + ${i3[1] + i3[3] - h2}px)`;
          o2 = `calc(100% + ${i3[0] + i3[2] - C2}px)`;
          break;
        case "right":
          n2 = h2 ? `calc(100% - ${h2}px)` : "100%";
          o2 = C2 ? `calc(100% - ${C2}px)` : "100%";
      }
      const l2 = [
        "xfaBorder"
      ];
      isPrintOnly(e2.border) && l2.push("xfaPrintOnly");
      const Q2 = {
        name: "div",
        attributes: {
          class: l2,
          style: {
            top: `${g2}px`,
            left: `${c2}px`,
            width: n2,
            height: o2
          }
        },
        children: []
      };
      for (const e3 of [
        "border",
        "borderWidth",
        "borderColor",
        "borderRadius",
        "borderStyle"
      ]) if (void 0 !== a2[e3]) {
        Q2.attributes.style[e3] = a2[e3];
        delete a2[e3];
      }
      r2.children.push(Q2, t2);
    } else r2.children.push(t2);
    for (const e3 of [
      "background",
      "backgroundClip",
      "top",
      "left",
      "width",
      "height",
      "minWidth",
      "minHeight",
      "maxWidth",
      "maxHeight",
      "transform",
      "transformOrigin",
      "visibility"
    ]) if (void 0 !== a2[e3]) {
      r2.attributes.style[e3] = a2[e3];
      delete a2[e3];
    }
    r2.attributes.style.position = "absolute" === a2.position ? "absolute" : "relative";
    delete a2.position;
    if (a2.alignSelf) {
      r2.attributes.style.alignSelf = a2.alignSelf;
      delete a2.alignSelf;
    }
    return r2;
  }
  function fixTextIndent(e2) {
    const t2 = getMeasurement(e2.textIndent, "0px");
    if (t2 >= 0) return;
    const i2 = "padding" + ("left" === ("right" === e2.textAlign ? "right" : "left") ? "Left" : "Right"), a2 = getMeasurement(e2[i2], "0px");
    e2[i2] = a2 - t2 + "px";
  }
  function setAccess(e2, t2) {
    switch (e2.access) {
      case "nonInteractive":
        t2.push("xfaNonInteractive");
        break;
      case "readOnly":
        t2.push("xfaReadOnly");
        break;
      case "protected":
        t2.push("xfaDisabled");
    }
  }
  function isPrintOnly(e2) {
    return e2.relevant.length > 0 && !e2.relevant[0].excluded && "print" === e2.relevant[0].viewname;
  }
  function getCurrentPara(e2) {
    const t2 = e2[Ds]()[gs].paraStack;
    return t2.length ? t2.at(-1) : null;
  }
  function setPara(e2, t2, i2) {
    var _a4;
    if ((_a4 = i2.attributes.class) == null ? void 0 : _a4.includes("xfaRich")) {
      if (t2) {
        "" === e2.h && (t2.height = "auto");
        "" === e2.w && (t2.width = "auto");
      }
      const a2 = getCurrentPara(e2);
      if (a2) {
        const e3 = i2.attributes.style;
        e3.display = "flex";
        e3.flexDirection = "column";
        switch (a2.vAlign) {
          case "top":
            e3.justifyContent = "start";
            break;
          case "bottom":
            e3.justifyContent = "end";
            break;
          case "middle":
            e3.justifyContent = "center";
        }
        const t3 = a2[cn]();
        for (const [i3, a3] of Object.entries(t3)) i3 in e3 || (e3[i3] = a3);
      }
    }
  }
  function setFontFamily(e2, t2, i2, a2) {
    if (!i2) {
      delete a2.fontFamily;
      return;
    }
    const r2 = stripQuotes(e2.typeface);
    a2.fontFamily = `"${r2}"`;
    const s2 = i2.find(r2);
    if (s2) {
      const { fontFamily: i3 } = s2.regular.cssFontInfo;
      i3 !== r2 && (a2.fontFamily = `"${i3}"`);
      const n2 = getCurrentPara(t2);
      if (n2 && "" !== n2.lineHeight) return;
      if (a2.lineHeight) return;
      const o2 = selectFont(e2, s2);
      o2 && (a2.lineHeight = Math.max(1.2, o2.lineHeight));
    }
  }
  function fixURL(e2) {
    const t2 = createValidAbsoluteUrl(e2, null, {
      addDefaultProtocol: true,
      tryConvertEncoding: true
    });
    return t2 ? t2.href : null;
  }
  function createLine(e2, t2) {
    return {
      name: "div",
      attributes: {
        class: [
          "lr-tb" === e2.layout ? "xfaLr" : "xfaRl"
        ]
      },
      children: t2
    };
  }
  function flushHTML(e2) {
    if (!e2[gs]) return null;
    const t2 = {
      name: "div",
      attributes: e2[gs].attributes,
      children: e2[gs].children
    };
    if (e2[gs].failingNode) {
      const i2 = e2[gs].failingNode[cs]();
      i2 && (e2.layout.endsWith("-tb") ? t2.children.push(createLine(e2, [
        i2
      ])) : t2.children.push(i2));
    }
    return 0 === t2.children.length ? null : t2;
  }
  function addHTML(e2, t2, i2) {
    const a2 = e2[gs], r2 = a2.availableSpace, [s2, n2, o2, g2] = i2;
    switch (e2.layout) {
      case "position":
        a2.width = Math.max(a2.width, s2 + o2);
        a2.height = Math.max(a2.height, n2 + g2);
        a2.children.push(t2);
        break;
      case "lr-tb":
      case "rl-tb":
        if (!a2.line || 1 === a2.attempt) {
          a2.line = createLine(e2, []);
          a2.children.push(a2.line);
          a2.numberInLine = 0;
        }
        a2.numberInLine += 1;
        a2.line.children.push(t2);
        if (0 === a2.attempt) {
          a2.currentWidth += o2;
          a2.height = Math.max(a2.height, a2.prevHeight + g2);
        } else {
          a2.currentWidth = o2;
          a2.prevHeight = a2.height;
          a2.height += g2;
          a2.attempt = 0;
        }
        a2.width = Math.max(a2.width, a2.currentWidth);
        break;
      case "rl-row":
      case "row": {
        a2.children.push(t2);
        a2.width += o2;
        a2.height = Math.max(a2.height, g2);
        const e3 = measureToString(a2.height);
        for (const t3 of a2.children) t3.attributes.style.height = e3;
        break;
      }
      case "table":
      case "tb":
        a2.width = Math.min(r2.width, Math.max(a2.width, o2));
        a2.height += g2;
        a2.children.push(t2);
    }
  }
  function getAvailableSpace(e2) {
    const t2 = e2[gs].availableSpace, i2 = e2.margin ? e2.margin.topInset + e2.margin.bottomInset : 0, a2 = e2.margin ? e2.margin.leftInset + e2.margin.rightInset : 0;
    switch (e2.layout) {
      case "lr-tb":
      case "rl-tb":
        return 0 === e2[gs].attempt ? {
          width: t2.width - a2 - e2[gs].currentWidth,
          height: t2.height - i2 - e2[gs].prevHeight
        } : {
          width: t2.width - a2,
          height: t2.height - i2 - e2[gs].height
        };
      case "rl-row":
      case "row":
        return {
          width: e2[gs].columnWidths.slice(e2[gs].currentColumn).reduce((e3, t3) => e3 + t3),
          height: t2.height - a2
        };
      case "table":
      case "tb":
        return {
          width: t2.width - a2,
          height: t2.height - i2 - e2[gs].height
        };
      default:
        return t2;
    }
  }
  function checkDimensions(e2, t2) {
    var _a4;
    if (null === e2[Ds]()[gs].firstUnsplittable) return true;
    if (0 === e2.w || 0 === e2.h) return true;
    const i2 = e2[ws](), a2 = ((_a4 = i2[gs]) == null ? void 0 : _a4.attempt) || 0, [, r2, s2, n2] = function getTransformedBBox(e3) {
      let t3, i3, a3 = "" === e3.w ? NaN : e3.w, r3 = "" === e3.h ? NaN : e3.h, [s3, n3] = [
        0,
        0
      ];
      switch (e3.anchorType || "") {
        case "bottomCenter":
          [s3, n3] = [
            a3 / 2,
            r3
          ];
          break;
        case "bottomLeft":
          [s3, n3] = [
            0,
            r3
          ];
          break;
        case "bottomRight":
          [s3, n3] = [
            a3,
            r3
          ];
          break;
        case "middleCenter":
          [s3, n3] = [
            a3 / 2,
            r3 / 2
          ];
          break;
        case "middleLeft":
          [s3, n3] = [
            0,
            r3 / 2
          ];
          break;
        case "middleRight":
          [s3, n3] = [
            a3,
            r3 / 2
          ];
          break;
        case "topCenter":
          [s3, n3] = [
            a3 / 2,
            0
          ];
          break;
        case "topRight":
          [s3, n3] = [
            a3,
            0
          ];
      }
      switch (e3.rotate || 0) {
        case 0:
          [t3, i3] = [
            -s3,
            -n3
          ];
          break;
        case 90:
          [t3, i3] = [
            -n3,
            s3
          ];
          [a3, r3] = [
            r3,
            -a3
          ];
          break;
        case 180:
          [t3, i3] = [
            s3,
            n3
          ];
          [a3, r3] = [
            -a3,
            -r3
          ];
          break;
        case 270:
          [t3, i3] = [
            n3,
            -s3
          ];
          [a3, r3] = [
            -r3,
            a3
          ];
      }
      return [
        e3.x + t3 + Math.min(0, a3),
        e3.y + i3 + Math.min(0, r3),
        Math.abs(a3),
        Math.abs(r3)
      ];
    }(e2);
    switch (i2.layout) {
      case "lr-tb":
      case "rl-tb":
        return 0 === a2 ? e2[Ds]()[gs].noLayoutFailure ? "" !== e2.w ? Math.round(s2 - t2.width) <= 2 : t2.width > 2 : !("" !== e2.h && Math.round(n2 - t2.height) > 2) && ("" !== e2.w ? Math.round(s2 - t2.width) <= 2 || 0 === i2[gs].numberInLine && t2.height > 2 : t2.width > 2) : !!e2[Ds]()[gs].noLayoutFailure || !("" !== e2.h && Math.round(n2 - t2.height) > 2) && (("" === e2.w || Math.round(s2 - t2.width) <= 2 || !i2[Js]()) && t2.height > 2);
      case "table":
      case "tb":
        return !!e2[Ds]()[gs].noLayoutFailure || ("" === e2.h || e2[Hs]() ? ("" === e2.w || Math.round(s2 - t2.width) <= 2 || !i2[Js]()) && t2.height > 2 : Math.round(n2 - t2.height) <= 2);
      case "position":
        if (e2[Ds]()[gs].noLayoutFailure) return true;
        if ("" === e2.h || Math.round(n2 + r2 - t2.height) <= 2) return true;
        return n2 + r2 > e2[Ds]()[gs].currentContentArea.h;
      case "rl-row":
      case "row":
        return !!e2[Ds]()[gs].noLayoutFailure || ("" === e2.h || Math.round(n2 - t2.height) <= 2);
      default:
        return true;
    }
  }
  const Kn = ln.template.id, qn = "http://www.w3.org/2000/svg", On = /^H(\d+)$/, Pn = /* @__PURE__ */ new Set([
    "image/gif",
    "image/jpeg",
    "image/jpg",
    "image/pjpeg",
    "image/png",
    "image/apng",
    "image/x-png",
    "image/bmp",
    "image/x-ms-bmp",
    "image/tiff",
    "image/tif",
    "application/octet-stream"
  ]), Wn = [
    [
      [
        66,
        77
      ],
      "image/bmp"
    ],
    [
      [
        255,
        216,
        255
      ],
      "image/jpeg"
    ],
    [
      [
        73,
        73,
        42,
        0
      ],
      "image/tiff"
    ],
    [
      [
        77,
        77,
        0,
        42
      ],
      "image/tiff"
    ],
    [
      [
        71,
        73,
        70,
        56,
        57,
        97
      ],
      "image/gif"
    ],
    [
      [
        137,
        80,
        78,
        71,
        13,
        10,
        26,
        10
      ],
      "image/png"
    ]
  ];
  function getBorderDims(e2) {
    if (!e2 || !e2.border) return {
      w: 0,
      h: 0
    };
    const t2 = e2.border[ds]();
    return t2 ? {
      w: t2.widths[0] + t2.widths[2] + t2.insets[0] + t2.insets[2],
      h: t2.widths[1] + t2.widths[3] + t2.insets[1] + t2.insets[3]
    } : {
      w: 0,
      h: 0
    };
  }
  function hasMargin(e2) {
    return e2.margin && (e2.margin.topInset || e2.margin.rightInset || e2.margin.bottomInset || e2.margin.leftInset);
  }
  function _setValue(e2, t2) {
    if (!e2.value) {
      const t3 = new Value({});
      e2[$r](t3);
      e2.value = t3;
    }
    e2.value[rn](t2);
  }
  function* getContainedChildren(e2) {
    for (const t2 of e2[ps]()) t2 instanceof SubformSet ? yield* t2[ms]() : yield t2;
  }
  function isRequired(e2) {
    var _a4;
    return "error" === ((_a4 = e2.validate) == null ? void 0 : _a4.nullTest);
  }
  function setTabIndex(e2) {
    for (; e2; ) {
      if (!e2.traversal) {
        e2[sn] = e2[bs]()[sn];
        return;
      }
      if (e2[sn]) return;
      let t2 = null;
      for (const i3 of e2.traversal[ps]()) if ("next" === i3.operation) {
        t2 = i3;
        break;
      }
      if (!t2 || !t2.ref) {
        e2[sn] = e2[bs]()[sn];
        return;
      }
      const i2 = e2[Ds]();
      e2[sn] = ++i2[sn];
      const a2 = i2[en](t2.ref, e2);
      if (!a2) return;
      e2 = a2[0];
    }
  }
  function applyAssist(e2, t2) {
    var _a4;
    const i2 = e2.assist;
    if (i2) {
      const e3 = i2[gn]();
      e3 && (t2.title = e3);
      const a2 = i2.role.match(On);
      if (a2) {
        const e4 = "heading", i3 = a2[1];
        t2.role = e4;
        t2["aria-level"] = i3;
      }
    }
    if ("table" === e2.layout) t2.role = "table";
    else if ("row" === e2.layout) t2.role = "row";
    else {
      const i3 = e2[bs]();
      "row" === i3.layout && (t2.role = "TH" === ((_a4 = i3.assist) == null ? void 0 : _a4.role) ? "columnheader" : "cell");
    }
  }
  function ariaLabel(e2) {
    if (!e2.assist) return null;
    const t2 = e2.assist;
    return t2.speak && "" !== t2.speak[ss] ? t2.speak[ss] : t2.toolTip ? t2.toolTip[ss] : null;
  }
  function valueToHtml(e2) {
    return HTMLResult.success({
      name: "div",
      attributes: {
        class: [
          "xfaRich"
        ],
        style: /* @__PURE__ */ Object.create(null)
      },
      children: [
        {
          name: "span",
          attributes: {
            style: /* @__PURE__ */ Object.create(null)
          },
          value: e2
        }
      ]
    });
  }
  function setFirstUnsplittable(e2) {
    const t2 = e2[Ds]();
    if (null === t2[gs].firstUnsplittable) {
      t2[gs].firstUnsplittable = e2;
      t2[gs].noLayoutFailure = true;
    }
  }
  function unsetFirstUnsplittable(e2) {
    const t2 = e2[Ds]();
    t2[gs].firstUnsplittable === e2 && (t2[gs].noLayoutFailure = false);
  }
  function handleBreak(e2) {
    if (e2[gs]) return false;
    e2[gs] = /* @__PURE__ */ Object.create(null);
    if ("auto" === e2.targetType) return false;
    const t2 = e2[Ds]();
    let i2 = null;
    if (e2.target) {
      i2 = t2[en](e2.target, e2[bs]());
      if (!i2) return false;
      i2 = i2[0];
    }
    const { currentPageArea: a2, currentContentArea: r2 } = t2[gs];
    if ("pageArea" === e2.targetType) {
      i2 instanceof PageArea || (i2 = null);
      if (e2.startNew) {
        e2[gs].target = i2 || a2;
        return true;
      }
      if (i2 && i2 !== a2) {
        e2[gs].target = i2;
        return true;
      }
      return false;
    }
    i2 instanceof ContentArea || (i2 = null);
    const s2 = i2 && i2[bs]();
    let n2, o2 = s2;
    if (e2.startNew) if (i2) {
      const e3 = s2.contentArea.children, t3 = e3.indexOf(r2), a3 = e3.indexOf(i2);
      -1 !== t3 && t3 < a3 && (o2 = null);
      n2 = a3 - 1;
    } else n2 = a2.contentArea.children.indexOf(r2);
    else {
      if (!i2 || i2 === r2) return false;
      n2 = s2.contentArea.children.indexOf(i2) - 1;
      o2 = s2 === a2 ? null : s2;
    }
    e2[gs].target = o2;
    e2[gs].index = n2;
    return true;
  }
  function handleOverflow(e2, t2, i2) {
    const a2 = e2[Ds](), r2 = a2[gs].noLayoutFailure, s2 = t2[ws];
    t2[ws] = () => e2;
    a2[gs].noLayoutFailure = true;
    const n2 = t2[gn](i2);
    e2[zr](n2.html, n2.bbox);
    a2[gs].noLayoutFailure = r2;
    t2[ws] = s2;
  }
  class AppearanceFilter extends StringObject {
    constructor(e2) {
      super(Kn, "appearanceFilter");
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Arc extends XFAObject {
    constructor(e2) {
      super(Kn, "arc", true);
      this.circular = getInteger({
        data: e2.circular,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.hand = getStringOption(e2.hand, [
        "even",
        "left",
        "right"
      ]);
      this.id = e2.id || "";
      this.startAngle = getFloat({
        data: e2.startAngle,
        defaultValue: 0,
        validate: (e3) => true
      });
      this.sweepAngle = getFloat({
        data: e2.sweepAngle,
        defaultValue: 360,
        validate: (e3) => true
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.edge = null;
      this.fill = null;
    }
    [gn]() {
      var _a4;
      const e2 = this.edge || new Edge({}), t2 = e2[cn](), i2 = /* @__PURE__ */ Object.create(null);
      "visible" === ((_a4 = this.fill) == null ? void 0 : _a4.presence) ? Object.assign(i2, this.fill[cn]()) : i2.fill = "transparent";
      i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0);
      i2.stroke = t2.color;
      let a2;
      const r2 = {
        xmlns: qn,
        style: {
          width: "100%",
          height: "100%",
          overflow: "visible"
        }
      };
      if (360 === this.sweepAngle) a2 = {
        name: "ellipse",
        attributes: {
          xmlns: qn,
          cx: "50%",
          cy: "50%",
          rx: "50%",
          ry: "50%",
          style: i2
        }
      };
      else {
        const e3 = this.startAngle * Math.PI / 180, t3 = this.sweepAngle * Math.PI / 180, s3 = this.sweepAngle > 180 ? 1 : 0, [n2, o2, g2, c2] = [
          50 * (1 + Math.cos(e3)),
          50 * (1 - Math.sin(e3)),
          50 * (1 + Math.cos(e3 + t3)),
          50 * (1 - Math.sin(e3 + t3))
        ];
        a2 = {
          name: "path",
          attributes: {
            xmlns: qn,
            d: `M ${n2} ${o2} A 50 50 0 ${s3} 0 ${g2} ${c2}`,
            vectorEffect: "non-scaling-stroke",
            style: i2
          }
        };
        Object.assign(r2, {
          viewBox: "0 0 100 100",
          preserveAspectRatio: "none"
        });
      }
      const s2 = {
        name: "svg",
        children: [
          a2
        ],
        attributes: r2
      };
      if (hasMargin(this[bs]()[bs]())) return HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [
          s2
        ]
      });
      s2.attributes.style.position = "absolute";
      return HTMLResult.success(s2);
    }
  }
  class Area extends XFAObject {
    constructor(e2) {
      super(Kn, "area", true);
      this.colSpan = getInteger({
        data: e2.colSpan,
        defaultValue: 1,
        validate: (e3) => e3 >= 1 || -1 === e3
      });
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.x = getMeasurement(e2.x, "0pt");
      this.y = getMeasurement(e2.y, "0pt");
      this.desc = null;
      this.extras = null;
      this.area = new XFAObjectArray();
      this.draw = new XFAObjectArray();
      this.exObject = new XFAObjectArray();
      this.exclGroup = new XFAObjectArray();
      this.field = new XFAObjectArray();
      this.subform = new XFAObjectArray();
      this.subformSet = new XFAObjectArray();
    }
    *[ms]() {
      yield* getContainedChildren(this);
    }
    [vs]() {
      return true;
    }
    [xs]() {
      return true;
    }
    [zr](e2, t2) {
      const [i2, a2, r2, s2] = t2;
      this[gs].width = Math.max(this[gs].width, i2 + r2);
      this[gs].height = Math.max(this[gs].height, a2 + s2);
      this[gs].children.push(e2);
    }
    [ls]() {
      return this[gs].availableSpace;
    }
    [gn](e2) {
      const t2 = toStyle(this, "position"), i2 = {
        style: t2,
        id: this[Cn],
        class: [
          "xfaArea"
        ]
      };
      isPrintOnly(this) && i2.class.push("xfaPrintOnly");
      this.name && (i2.xfaName = this.name);
      const a2 = [];
      this[gs] = {
        children: a2,
        width: 0,
        height: 0,
        availableSpace: e2
      };
      const r2 = this[As]({
        filter: /* @__PURE__ */ new Set([
          "area",
          "draw",
          "field",
          "exclGroup",
          "subform",
          "subformSet"
        ]),
        include: true
      });
      if (!r2.success) {
        if (r2.isBreak()) return r2;
        delete this[gs];
        return HTMLResult.FAILURE;
      }
      t2.width = measureToString(this[gs].width);
      t2.height = measureToString(this[gs].height);
      const s2 = {
        name: "div",
        attributes: i2,
        children: a2
      }, n2 = [
        this.x,
        this.y,
        this[gs].width,
        this[gs].height
      ];
      delete this[gs];
      return HTMLResult.success(s2, n2);
    }
  }
  class Assist extends XFAObject {
    constructor(e2) {
      super(Kn, "assist", true);
      this.id = e2.id || "";
      this.role = e2.role || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.speak = null;
      this.toolTip = null;
    }
    [gn]() {
      var _a4;
      return ((_a4 = this.toolTip) == null ? void 0 : _a4[ss]) || null;
    }
  }
  class Barcode extends XFAObject {
    constructor(e2) {
      super(Kn, "barcode", true);
      this.charEncoding = getKeyword({
        data: e2.charEncoding ? e2.charEncoding.toLowerCase() : "",
        defaultValue: "",
        validate: (e3) => [
          "utf-8",
          "big-five",
          "fontspecific",
          "gbk",
          "gb-18030",
          "gb-2312",
          "ksc-5601",
          "none",
          "shift-jis",
          "ucs-2",
          "utf-16"
        ].includes(e3) || e3.match(/iso-8859-\d{2}/)
      });
      this.checksum = getStringOption(e2.checksum, [
        "none",
        "1mod10",
        "1mod10_1mod11",
        "2mod10",
        "auto"
      ]);
      this.dataColumnCount = getInteger({
        data: e2.dataColumnCount,
        defaultValue: -1,
        validate: (e3) => e3 >= 0
      });
      this.dataLength = getInteger({
        data: e2.dataLength,
        defaultValue: -1,
        validate: (e3) => e3 >= 0
      });
      this.dataPrep = getStringOption(e2.dataPrep, [
        "none",
        "flateCompress"
      ]);
      this.dataRowCount = getInteger({
        data: e2.dataRowCount,
        defaultValue: -1,
        validate: (e3) => e3 >= 0
      });
      this.endChar = e2.endChar || "";
      this.errorCorrectionLevel = getInteger({
        data: e2.errorCorrectionLevel,
        defaultValue: -1,
        validate: (e3) => e3 >= 0 && e3 <= 8
      });
      this.id = e2.id || "";
      this.moduleHeight = getMeasurement(e2.moduleHeight, "5mm");
      this.moduleWidth = getMeasurement(e2.moduleWidth, "0.25mm");
      this.printCheckDigit = getInteger({
        data: e2.printCheckDigit,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.rowColumnRatio = getRatio(e2.rowColumnRatio);
      this.startChar = e2.startChar || "";
      this.textLocation = getStringOption(e2.textLocation, [
        "below",
        "above",
        "aboveEmbedded",
        "belowEmbedded",
        "none"
      ]);
      this.truncate = getInteger({
        data: e2.truncate,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.type = getStringOption(e2.type ? e2.type.toLowerCase() : "", [
        "aztec",
        "codabar",
        "code2of5industrial",
        "code2of5interleaved",
        "code2of5matrix",
        "code2of5standard",
        "code3of9",
        "code3of9extended",
        "code11",
        "code49",
        "code93",
        "code128",
        "code128a",
        "code128b",
        "code128c",
        "code128sscc",
        "datamatrix",
        "ean8",
        "ean8add2",
        "ean8add5",
        "ean13",
        "ean13add2",
        "ean13add5",
        "ean13pwcd",
        "fim",
        "logmars",
        "maxicode",
        "msi",
        "pdf417",
        "pdf417macro",
        "plessey",
        "postauscust2",
        "postauscust3",
        "postausreplypaid",
        "postausstandard",
        "postukrm4scc",
        "postusdpbc",
        "postusimb",
        "postusstandard",
        "postus5zip",
        "qrcode",
        "rfid",
        "rss14",
        "rss14expanded",
        "rss14limited",
        "rss14stacked",
        "rss14stackedomni",
        "rss14truncated",
        "telepen",
        "ucc128",
        "ucc128random",
        "ucc128sscc",
        "upca",
        "upcaadd2",
        "upcaadd5",
        "upcapwcd",
        "upce",
        "upceadd2",
        "upceadd5",
        "upcean2",
        "upcean5",
        "upsmaxicode"
      ]);
      this.upsMode = getStringOption(e2.upsMode, [
        "usCarrier",
        "internationalCarrier",
        "secureSymbol",
        "standardSymbol"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.wideNarrowRatio = getRatio(e2.wideNarrowRatio);
      this.encrypt = null;
      this.extras = null;
    }
  }
  class Bind extends XFAObject {
    constructor(e2) {
      super(Kn, "bind", true);
      this.match = getStringOption(e2.match, [
        "once",
        "dataRef",
        "global",
        "none"
      ]);
      this.ref = e2.ref || "";
      this.picture = null;
    }
  }
  class BindItems extends XFAObject {
    constructor(e2) {
      super(Kn, "bindItems");
      this.connection = e2.connection || "";
      this.labelRef = e2.labelRef || "";
      this.ref = e2.ref || "";
      this.valueRef = e2.valueRef || "";
    }
  }
  class Bookend extends XFAObject {
    constructor(e2) {
      super(Kn, "bookend");
      this.id = e2.id || "";
      this.leader = e2.leader || "";
      this.trailer = e2.trailer || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class BooleanElement extends Option01 {
    constructor(e2) {
      super(Kn, "boolean");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [gn](e2) {
      return valueToHtml(1 === this[ss] ? "1" : "0");
    }
  }
  class Border extends XFAObject {
    constructor(e2) {
      super(Kn, "border", true);
      this.break = getStringOption(e2.break, [
        "close",
        "open"
      ]);
      this.hand = getStringOption(e2.hand, [
        "even",
        "left",
        "right"
      ]);
      this.id = e2.id || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.corner = new XFAObjectArray(4);
      this.edge = new XFAObjectArray(4);
      this.extras = null;
      this.fill = null;
      this.margin = null;
    }
    [ds]() {
      if (!this[gs]) {
        const e2 = this.edge.children.slice();
        if (e2.length < 4) {
          const t3 = e2.at(-1) || new Edge({});
          for (let i3 = e2.length; i3 < 4; i3++) e2.push(t3);
        }
        const t2 = e2.map((e3) => e3.thickness), i2 = [
          0,
          0,
          0,
          0
        ];
        if (this.margin) {
          i2[0] = this.margin.topInset;
          i2[1] = this.margin.rightInset;
          i2[2] = this.margin.bottomInset;
          i2[3] = this.margin.leftInset;
        }
        this[gs] = {
          widths: t2,
          insets: i2,
          edges: e2
        };
      }
      return this[gs];
    }
    [cn]() {
      var _a4;
      const { edges: e2 } = this[ds](), t2 = e2.map((e3) => {
        const t3 = e3[cn]();
        t3.color || (t3.color = "#000000");
        return t3;
      }), i2 = /* @__PURE__ */ Object.create(null);
      this.margin && Object.assign(i2, this.margin[cn]());
      "visible" === ((_a4 = this.fill) == null ? void 0 : _a4.presence) && Object.assign(i2, this.fill[cn]());
      if (this.corner.children.some((e3) => 0 !== e3.radius)) {
        const e3 = this.corner.children.map((e4) => e4[cn]());
        if (2 === e3.length || 3 === e3.length) {
          const t3 = e3.at(-1);
          for (let i3 = e3.length; i3 < 4; i3++) e3.push(t3);
        }
        i2.borderRadius = e3.map((e4) => e4.radius).join(" ");
      }
      switch (this.presence) {
        case "invisible":
        case "hidden":
          i2.borderStyle = "";
          break;
        case "inactive":
          i2.borderStyle = "none";
          break;
        default:
          i2.borderStyle = t2.map((e3) => e3.style).join(" ");
      }
      i2.borderWidth = t2.map((e3) => e3.width).join(" ");
      i2.borderColor = t2.map((e3) => e3.color).join(" ");
      return i2;
    }
  }
  class Break extends XFAObject {
    constructor(e2) {
      super(Kn, "break", true);
      this.after = getStringOption(e2.after, [
        "auto",
        "contentArea",
        "pageArea",
        "pageEven",
        "pageOdd"
      ]);
      this.afterTarget = e2.afterTarget || "";
      this.before = getStringOption(e2.before, [
        "auto",
        "contentArea",
        "pageArea",
        "pageEven",
        "pageOdd"
      ]);
      this.beforeTarget = e2.beforeTarget || "";
      this.bookendLeader = e2.bookendLeader || "";
      this.bookendTrailer = e2.bookendTrailer || "";
      this.id = e2.id || "";
      this.overflowLeader = e2.overflowLeader || "";
      this.overflowTarget = e2.overflowTarget || "";
      this.overflowTrailer = e2.overflowTrailer || "";
      this.startNew = getInteger({
        data: e2.startNew,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
  }
  class BreakAfter extends XFAObject {
    constructor(e2) {
      super(Kn, "breakAfter", true);
      this.id = e2.id || "";
      this.leader = e2.leader || "";
      this.startNew = getInteger({
        data: e2.startNew,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.target = e2.target || "";
      this.targetType = getStringOption(e2.targetType, [
        "auto",
        "contentArea",
        "pageArea"
      ]);
      this.trailer = e2.trailer || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.script = null;
    }
  }
  class BreakBefore extends XFAObject {
    constructor(e2) {
      super(Kn, "breakBefore", true);
      this.id = e2.id || "";
      this.leader = e2.leader || "";
      this.startNew = getInteger({
        data: e2.startNew,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.target = e2.target || "";
      this.targetType = getStringOption(e2.targetType, [
        "auto",
        "contentArea",
        "pageArea"
      ]);
      this.trailer = e2.trailer || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.script = null;
    }
    [gn](e2) {
      this[gs] = {};
      return HTMLResult.FAILURE;
    }
  }
  class Button extends XFAObject {
    constructor(e2) {
      super(Kn, "button", true);
      this.highlight = getStringOption(e2.highlight, [
        "inverted",
        "none",
        "outline",
        "push"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
    [gn](e2) {
      const t2 = this[bs]()[bs](), i2 = {
        name: "button",
        attributes: {
          id: this[Cn],
          class: [
            "xfaButton"
          ],
          style: {}
        },
        children: []
      };
      for (const e3 of t2.event.children) {
        if ("click" !== e3.activity || !e3.script) continue;
        const t3 = recoverJsURL(e3.script[ss]);
        if (!t3) continue;
        const a2 = fixURL(t3.url);
        a2 && i2.children.push({
          name: "a",
          attributes: {
            id: "link" + this[Cn],
            href: a2,
            newWindow: t3.newWindow,
            class: [
              "xfaLink"
            ],
            style: {}
          },
          children: []
        });
      }
      return HTMLResult.success(i2);
    }
  }
  class Calculate extends XFAObject {
    constructor(e2) {
      super(Kn, "calculate", true);
      this.id = e2.id || "";
      this.override = getStringOption(e2.override, [
        "disabled",
        "error",
        "ignore",
        "warning"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.message = null;
      this.script = null;
    }
  }
  class Caption extends XFAObject {
    constructor(e2) {
      super(Kn, "caption", true);
      this.id = e2.id || "";
      this.placement = getStringOption(e2.placement, [
        "left",
        "bottom",
        "inline",
        "right",
        "top"
      ]);
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.reserve = Math.ceil(getMeasurement(e2.reserve));
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.font = null;
      this.margin = null;
      this.para = null;
      this.value = null;
    }
    [rn](e2) {
      _setValue(this, e2);
    }
    [ds](e2) {
      if (!this[gs]) {
        let { width: t2, height: i2 } = e2;
        switch (this.placement) {
          case "left":
          case "right":
          case "inline":
            t2 = this.reserve <= 0 ? t2 : this.reserve;
            break;
          case "top":
          case "bottom":
            i2 = this.reserve <= 0 ? i2 : this.reserve;
        }
        this[gs] = layoutNode(this, {
          width: t2,
          height: i2
        });
      }
      return this[gs];
    }
    [gn](e2) {
      if (!this.value) return HTMLResult.EMPTY;
      this[_s]();
      const t2 = this.value[gn](e2).html;
      if (!t2) {
        this[Vs]();
        return HTMLResult.EMPTY;
      }
      const i2 = this.reserve;
      if (this.reserve <= 0) {
        const { w: t3, h: i3 } = this[ds](e2);
        switch (this.placement) {
          case "left":
          case "right":
          case "inline":
            this.reserve = t3;
            break;
          case "top":
          case "bottom":
            this.reserve = i3;
        }
      }
      const a2 = [];
      "string" == typeof t2 ? a2.push({
        name: "#text",
        value: t2
      }) : a2.push(t2);
      const r2 = toStyle(this, "font", "margin", "visibility");
      switch (this.placement) {
        case "left":
        case "right":
          this.reserve > 0 && (r2.width = measureToString(this.reserve));
          break;
        case "top":
        case "bottom":
          this.reserve > 0 && (r2.height = measureToString(this.reserve));
      }
      setPara(this, null, t2);
      this[Vs]();
      this.reserve = i2;
      return HTMLResult.success({
        name: "div",
        attributes: {
          style: r2,
          class: [
            "xfaCaption"
          ]
        },
        children: a2
      });
    }
  }
  class Certificate extends StringObject {
    constructor(e2) {
      super(Kn, "certificate");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Certificates extends XFAObject {
    constructor(e2) {
      super(Kn, "certificates", true);
      this.credentialServerPolicy = getStringOption(e2.credentialServerPolicy, [
        "optional",
        "required"
      ]);
      this.id = e2.id || "";
      this.url = e2.url || "";
      this.urlPolicy = e2.urlPolicy || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.encryption = null;
      this.issuers = null;
      this.keyUsage = null;
      this.oids = null;
      this.signing = null;
      this.subjectDNs = null;
    }
  }
  class CheckButton extends XFAObject {
    constructor(e2) {
      super(Kn, "checkButton", true);
      this.id = e2.id || "";
      this.mark = getStringOption(e2.mark, [
        "default",
        "check",
        "circle",
        "cross",
        "diamond",
        "square",
        "star"
      ]);
      this.shape = getStringOption(e2.shape, [
        "square",
        "round"
      ]);
      this.size = getMeasurement(e2.size, "10pt");
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.extras = null;
      this.margin = null;
    }
    [gn](e2) {
      var _a4, _b, _c;
      const t2 = toStyle("margin"), i2 = measureToString(this.size);
      t2.width = t2.height = i2;
      let a2, r2, s2;
      const n2 = this[bs]()[bs](), o2 = n2.items.children.length && n2.items.children[0][gn]().html || [], g2 = {
        on: (void 0 !== o2[0] ? o2[0] : "on").toString(),
        off: (void 0 !== o2[1] ? o2[1] : "off").toString()
      }, c2 = (((_a4 = n2.value) == null ? void 0 : _a4[nn]()) || "off") === g2.on || void 0, C2 = n2[ws](), h2 = n2[Cn];
      let l2;
      if (C2 instanceof ExclGroup) {
        s2 = C2[Cn];
        a2 = "radio";
        r2 = "xfaRadio";
        l2 = ((_b = C2[ns]) == null ? void 0 : _b[Cn]) || C2[Cn];
      } else {
        a2 = "checkbox";
        r2 = "xfaCheckbox";
        l2 = ((_c = n2[ns]) == null ? void 0 : _c[Cn]) || n2[Cn];
      }
      const Q2 = {
        name: "input",
        attributes: {
          class: [
            r2
          ],
          style: t2,
          fieldId: h2,
          dataId: l2,
          type: a2,
          checked: c2,
          xfaOn: g2.on,
          xfaOff: g2.off,
          "aria-label": ariaLabel(n2),
          "aria-required": false
        }
      };
      s2 && (Q2.attributes.name = s2);
      if (isRequired(n2)) {
        Q2.attributes["aria-required"] = true;
        Q2.attributes.required = true;
      }
      return HTMLResult.success({
        name: "label",
        attributes: {
          class: [
            "xfaLabel"
          ]
        },
        children: [
          Q2
        ]
      });
    }
  }
  class ChoiceList extends XFAObject {
    constructor(e2) {
      super(Kn, "choiceList", true);
      this.commitOn = getStringOption(e2.commitOn, [
        "select",
        "exit"
      ]);
      this.id = e2.id || "";
      this.open = getStringOption(e2.open, [
        "userControl",
        "always",
        "multiSelect",
        "onEntry"
      ]);
      this.textEntry = getInteger({
        data: e2.textEntry,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.extras = null;
      this.margin = null;
    }
    [gn](e2) {
      var _a4, _b, _c;
      const t2 = toStyle(this, "border", "margin"), i2 = this[bs]()[bs](), a2 = {
        fontSize: `calc(${((_a4 = i2.font) == null ? void 0 : _a4.size) || 10}px * var(--scale-factor))`
      }, r2 = [];
      if (i2.items.children.length > 0) {
        const e3 = i2.items;
        let t3 = 0, s3 = 0;
        if (2 === e3.children.length) {
          t3 = e3.children[0].save;
          s3 = 1 - t3;
        }
        const n2 = e3.children[t3][gn]().html, o2 = e3.children[s3][gn]().html;
        let g2 = false;
        const c2 = ((_b = i2.value) == null ? void 0 : _b[nn]()) || "";
        for (let e4 = 0, t4 = n2.length; e4 < t4; e4++) {
          const t5 = {
            name: "option",
            attributes: {
              value: o2[e4] || n2[e4],
              style: a2
            },
            value: n2[e4]
          };
          o2[e4] === c2 && (t5.attributes.selected = g2 = true);
          r2.push(t5);
        }
        g2 || r2.splice(0, 0, {
          name: "option",
          attributes: {
            hidden: true,
            selected: true
          },
          value: " "
        });
      }
      const s2 = {
        class: [
          "xfaSelect"
        ],
        fieldId: i2[Cn],
        dataId: ((_c = i2[ns]) == null ? void 0 : _c[Cn]) || i2[Cn],
        style: t2,
        "aria-label": ariaLabel(i2),
        "aria-required": false
      };
      if (isRequired(i2)) {
        s2["aria-required"] = true;
        s2.required = true;
      }
      "multiSelect" === this.open && (s2.multiple = true);
      return HTMLResult.success({
        name: "label",
        attributes: {
          class: [
            "xfaLabel"
          ]
        },
        children: [
          {
            name: "select",
            children: r2,
            attributes: s2
          }
        ]
      });
    }
  }
  class Color extends XFAObject {
    constructor(e2) {
      super(Kn, "color", true);
      this.cSpace = getStringOption(e2.cSpace, [
        "SRGB"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.value = e2.value ? function getColor(e3, t2 = [
        0,
        0,
        0
      ]) {
        let [i2, a2, r2] = t2;
        if (!e3) return {
          r: i2,
          g: a2,
          b: r2
        };
        const s2 = e3.trim().split(/\s*,\s*/).map((e4) => Math.min(Math.max(0, parseInt(e4.trim(), 10)), 255)).map((e4) => isNaN(e4) ? 0 : e4);
        if (s2.length < 3) return {
          r: i2,
          g: a2,
          b: r2
        };
        [i2, a2, r2] = s2;
        return {
          r: i2,
          g: a2,
          b: r2
        };
      }(e2.value) : "";
      this.extras = null;
    }
    [Ss]() {
      return false;
    }
    [cn]() {
      return this.value ? Util.makeHexColor(this.value.r, this.value.g, this.value.b) : null;
    }
  }
  class Comb extends XFAObject {
    constructor(e2) {
      super(Kn, "comb");
      this.id = e2.id || "";
      this.numberOfCells = getInteger({
        data: e2.numberOfCells,
        defaultValue: 0,
        validate: (e3) => e3 >= 0
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Connect extends XFAObject {
    constructor(e2) {
      super(Kn, "connect", true);
      this.connection = e2.connection || "";
      this.id = e2.id || "";
      this.ref = e2.ref || "";
      this.usage = getStringOption(e2.usage, [
        "exportAndImport",
        "exportOnly",
        "importOnly"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.picture = null;
    }
  }
  class ContentArea extends XFAObject {
    constructor(e2) {
      super(Kn, "contentArea", true);
      this.h = getMeasurement(e2.h);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.w = getMeasurement(e2.w);
      this.x = getMeasurement(e2.x, "0pt");
      this.y = getMeasurement(e2.y, "0pt");
      this.desc = null;
      this.extras = null;
    }
    [gn](e2) {
      const t2 = {
        left: measureToString(this.x),
        top: measureToString(this.y),
        width: measureToString(this.w),
        height: measureToString(this.h)
      }, i2 = [
        "xfaContentarea"
      ];
      isPrintOnly(this) && i2.push("xfaPrintOnly");
      return HTMLResult.success({
        name: "div",
        children: [],
        attributes: {
          style: t2,
          class: i2,
          id: this[Cn]
        }
      });
    }
  }
  class Corner extends XFAObject {
    constructor(e2) {
      super(Kn, "corner", true);
      this.id = e2.id || "";
      this.inverted = getInteger({
        data: e2.inverted,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.join = getStringOption(e2.join, [
        "square",
        "round"
      ]);
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.radius = getMeasurement(e2.radius);
      this.stroke = getStringOption(e2.stroke, [
        "solid",
        "dashDot",
        "dashDotDot",
        "dashed",
        "dotted",
        "embossed",
        "etched",
        "lowered",
        "raised"
      ]);
      this.thickness = getMeasurement(e2.thickness, "0.5pt");
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
    }
    [cn]() {
      const e2 = toStyle(this, "visibility");
      e2.radius = measureToString("square" === this.join ? 0 : this.radius);
      return e2;
    }
  }
  class DateElement extends ContentObject {
    constructor(e2) {
      super(Kn, "date");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      const e2 = this[ss].trim();
      this[ss] = e2 ? new Date(e2) : null;
    }
    [gn](e2) {
      return valueToHtml(this[ss] ? this[ss].toString() : "");
    }
  }
  class DateTime extends ContentObject {
    constructor(e2) {
      super(Kn, "dateTime");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      const e2 = this[ss].trim();
      this[ss] = e2 ? new Date(e2) : null;
    }
    [gn](e2) {
      return valueToHtml(this[ss] ? this[ss].toString() : "");
    }
  }
  class DateTimeEdit extends XFAObject {
    constructor(e2) {
      super(Kn, "dateTimeEdit", true);
      this.hScrollPolicy = getStringOption(e2.hScrollPolicy, [
        "auto",
        "off",
        "on"
      ]);
      this.id = e2.id || "";
      this.picker = getStringOption(e2.picker, [
        "host",
        "none"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.comb = null;
      this.extras = null;
      this.margin = null;
    }
    [gn](e2) {
      var _a4;
      const t2 = toStyle(this, "border", "font", "margin"), i2 = this[bs]()[bs](), a2 = {
        name: "input",
        attributes: {
          type: "text",
          fieldId: i2[Cn],
          dataId: ((_a4 = i2[ns]) == null ? void 0 : _a4[Cn]) || i2[Cn],
          class: [
            "xfaTextfield"
          ],
          style: t2,
          "aria-label": ariaLabel(i2),
          "aria-required": false
        }
      };
      if (isRequired(i2)) {
        a2.attributes["aria-required"] = true;
        a2.attributes.required = true;
      }
      return HTMLResult.success({
        name: "label",
        attributes: {
          class: [
            "xfaLabel"
          ]
        },
        children: [
          a2
        ]
      });
    }
  }
  class Decimal extends ContentObject {
    constructor(e2) {
      super(Kn, "decimal");
      this.fracDigits = getInteger({
        data: e2.fracDigits,
        defaultValue: 2,
        validate: (e3) => true
      });
      this.id = e2.id || "";
      this.leadDigits = getInteger({
        data: e2.leadDigits,
        defaultValue: -1,
        validate: (e3) => true
      });
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      const e2 = parseFloat(this[ss].trim());
      this[ss] = isNaN(e2) ? null : e2;
    }
    [gn](e2) {
      return valueToHtml(null !== this[ss] ? this[ss].toString() : "");
    }
  }
  class DefaultUi extends XFAObject {
    constructor(e2) {
      super(Kn, "defaultUi", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
  }
  class Desc extends XFAObject {
    constructor(e2) {
      super(Kn, "desc", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.boolean = new XFAObjectArray();
      this.date = new XFAObjectArray();
      this.dateTime = new XFAObjectArray();
      this.decimal = new XFAObjectArray();
      this.exData = new XFAObjectArray();
      this.float = new XFAObjectArray();
      this.image = new XFAObjectArray();
      this.integer = new XFAObjectArray();
      this.text = new XFAObjectArray();
      this.time = new XFAObjectArray();
    }
  }
  class DigestMethod extends OptionObject {
    constructor(e2) {
      super(Kn, "digestMethod", [
        "",
        "SHA1",
        "SHA256",
        "SHA512",
        "RIPEMD160"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class DigestMethods extends XFAObject {
    constructor(e2) {
      super(Kn, "digestMethods", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.digestMethod = new XFAObjectArray();
    }
  }
  class Draw extends XFAObject {
    constructor(e2) {
      super(Kn, "draw", true);
      this.anchorType = getStringOption(e2.anchorType, [
        "topLeft",
        "bottomCenter",
        "bottomLeft",
        "bottomRight",
        "middleCenter",
        "middleLeft",
        "middleRight",
        "topCenter",
        "topRight"
      ]);
      this.colSpan = getInteger({
        data: e2.colSpan,
        defaultValue: 1,
        validate: (e3) => e3 >= 1 || -1 === e3
      });
      this.h = e2.h ? getMeasurement(e2.h) : "";
      this.hAlign = getStringOption(e2.hAlign, [
        "left",
        "center",
        "justify",
        "justifyAll",
        "radix",
        "right"
      ]);
      this.id = e2.id || "";
      this.locale = e2.locale || "";
      this.maxH = getMeasurement(e2.maxH, "0pt");
      this.maxW = getMeasurement(e2.maxW, "0pt");
      this.minH = getMeasurement(e2.minH, "0pt");
      this.minW = getMeasurement(e2.minW, "0pt");
      this.name = e2.name || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.rotate = getInteger({
        data: e2.rotate,
        defaultValue: 0,
        validate: (e3) => e3 % 90 == 0
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.w = e2.w ? getMeasurement(e2.w) : "";
      this.x = getMeasurement(e2.x, "0pt");
      this.y = getMeasurement(e2.y, "0pt");
      this.assist = null;
      this.border = null;
      this.caption = null;
      this.desc = null;
      this.extras = null;
      this.font = null;
      this.keep = null;
      this.margin = null;
      this.para = null;
      this.traversal = null;
      this.ui = null;
      this.value = null;
      this.setProperty = new XFAObjectArray();
    }
    [rn](e2) {
      _setValue(this, e2);
    }
    [gn](e2) {
      setTabIndex(this);
      if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
      fixDimensions(this);
      this[_s]();
      const t2 = this.w, i2 = this.h, { w: a2, h: r2, isBroken: s2 } = layoutNode(this, e2);
      if (a2 && "" === this.w) {
        if (s2 && this[ws]()[Js]()) {
          this[Vs]();
          return HTMLResult.FAILURE;
        }
        this.w = a2;
      }
      r2 && "" === this.h && (this.h = r2);
      setFirstUnsplittable(this);
      if (!checkDimensions(this, e2)) {
        this.w = t2;
        this.h = i2;
        this[Vs]();
        return HTMLResult.FAILURE;
      }
      unsetFirstUnsplittable(this);
      const n2 = toStyle(this, "font", "hAlign", "dimensions", "position", "presence", "rotate", "anchorType", "border", "margin");
      setMinMaxDimensions(this, n2);
      if (n2.margin) {
        n2.padding = n2.margin;
        delete n2.margin;
      }
      const o2 = [
        "xfaDraw"
      ];
      this.font && o2.push("xfaFont");
      isPrintOnly(this) && o2.push("xfaPrintOnly");
      const g2 = {
        style: n2,
        id: this[Cn],
        class: o2
      };
      this.name && (g2.xfaName = this.name);
      const c2 = {
        name: "div",
        attributes: g2,
        children: []
      };
      applyAssist(this, g2);
      const C2 = computeBbox(this, c2, e2), h2 = this.value ? this.value[gn](e2).html : null;
      if (null === h2) {
        this.w = t2;
        this.h = i2;
        this[Vs]();
        return HTMLResult.success(createWrapper(this, c2), C2);
      }
      c2.children.push(h2);
      setPara(this, n2, h2);
      this.w = t2;
      this.h = i2;
      this[Vs]();
      return HTMLResult.success(createWrapper(this, c2), C2);
    }
  }
  class Edge extends XFAObject {
    constructor(e2) {
      super(Kn, "edge", true);
      this.cap = getStringOption(e2.cap, [
        "square",
        "butt",
        "round"
      ]);
      this.id = e2.id || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.stroke = getStringOption(e2.stroke, [
        "solid",
        "dashDot",
        "dashDotDot",
        "dashed",
        "dotted",
        "embossed",
        "etched",
        "lowered",
        "raised"
      ]);
      this.thickness = getMeasurement(e2.thickness, "0.5pt");
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
    }
    [cn]() {
      const e2 = toStyle(this, "visibility");
      Object.assign(e2, {
        linecap: this.cap,
        width: measureToString(this.thickness),
        color: this.color ? this.color[cn]() : "#000000",
        style: ""
      });
      if ("visible" !== this.presence) e2.style = "none";
      else switch (this.stroke) {
        case "solid":
          e2.style = "solid";
          break;
        case "dashDot":
        case "dashDotDot":
        case "dashed":
          e2.style = "dashed";
          break;
        case "dotted":
          e2.style = "dotted";
          break;
        case "embossed":
          e2.style = "ridge";
          break;
        case "etched":
          e2.style = "groove";
          break;
        case "lowered":
          e2.style = "inset";
          break;
        case "raised":
          e2.style = "outset";
      }
      return e2;
    }
  }
  class Encoding extends OptionObject {
    constructor(e2) {
      super(Kn, "encoding", [
        "adbe.x509.rsa_sha1",
        "adbe.pkcs7.detached",
        "adbe.pkcs7.sha1"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Encodings extends XFAObject {
    constructor(e2) {
      super(Kn, "encodings", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.encoding = new XFAObjectArray();
    }
  }
  class Encrypt extends XFAObject {
    constructor(e2) {
      super(Kn, "encrypt", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.certificate = null;
    }
  }
  class EncryptData extends XFAObject {
    constructor(e2) {
      super(Kn, "encryptData", true);
      this.id = e2.id || "";
      this.operation = getStringOption(e2.operation, [
        "encrypt",
        "decrypt"
      ]);
      this.target = e2.target || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.filter = null;
      this.manifest = null;
    }
  }
  class Encryption extends XFAObject {
    constructor(e2) {
      super(Kn, "encryption", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.certificate = new XFAObjectArray();
    }
  }
  class EncryptionMethod extends OptionObject {
    constructor(e2) {
      super(Kn, "encryptionMethod", [
        "",
        "AES256-CBC",
        "TRIPLEDES-CBC",
        "AES128-CBC",
        "AES192-CBC"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class EncryptionMethods extends XFAObject {
    constructor(e2) {
      super(Kn, "encryptionMethods", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.encryptionMethod = new XFAObjectArray();
    }
  }
  class Event extends XFAObject {
    constructor(e2) {
      super(Kn, "event", true);
      this.activity = getStringOption(e2.activity, [
        "click",
        "change",
        "docClose",
        "docReady",
        "enter",
        "exit",
        "full",
        "indexChange",
        "initialize",
        "mouseDown",
        "mouseEnter",
        "mouseExit",
        "mouseUp",
        "postExecute",
        "postOpen",
        "postPrint",
        "postSave",
        "postSign",
        "postSubmit",
        "preExecute",
        "preOpen",
        "prePrint",
        "preSave",
        "preSign",
        "preSubmit",
        "ready",
        "validationState"
      ]);
      this.id = e2.id || "";
      this.listen = getStringOption(e2.listen, [
        "refOnly",
        "refAndDescendents"
      ]);
      this.name = e2.name || "";
      this.ref = e2.ref || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.encryptData = null;
      this.execute = null;
      this.script = null;
      this.signData = null;
      this.submit = null;
    }
  }
  class ExData extends ContentObject {
    constructor(e2) {
      super(Kn, "exData");
      this.contentType = e2.contentType || "";
      this.href = e2.href || "";
      this.id = e2.id || "";
      this.maxLength = getInteger({
        data: e2.maxLength,
        defaultValue: -1,
        validate: (e3) => e3 >= -1
      });
      this.name = e2.name || "";
      this.rid = e2.rid || "";
      this.transferEncoding = getStringOption(e2.transferEncoding, [
        "none",
        "base64",
        "package"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Gs]() {
      return "text/html" === this.contentType;
    }
    [Ws](e2) {
      if ("text/html" === this.contentType && e2[Ks] === ln.xhtml.id) {
        this[ss] = e2;
        return true;
      }
      if ("text/xml" === this.contentType) {
        this[ss] = e2;
        return true;
      }
      return false;
    }
    [gn](e2) {
      return "text/html" === this.contentType && this[ss] ? this[ss][gn](e2) : HTMLResult.EMPTY;
    }
  }
  class ExObject extends XFAObject {
    constructor(e2) {
      super(Kn, "exObject", true);
      this.archive = e2.archive || "";
      this.classId = e2.classId || "";
      this.codeBase = e2.codeBase || "";
      this.codeType = e2.codeType || "";
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.boolean = new XFAObjectArray();
      this.date = new XFAObjectArray();
      this.dateTime = new XFAObjectArray();
      this.decimal = new XFAObjectArray();
      this.exData = new XFAObjectArray();
      this.exObject = new XFAObjectArray();
      this.float = new XFAObjectArray();
      this.image = new XFAObjectArray();
      this.integer = new XFAObjectArray();
      this.text = new XFAObjectArray();
      this.time = new XFAObjectArray();
    }
  }
  class ExclGroup extends XFAObject {
    constructor(e2) {
      super(Kn, "exclGroup", true);
      this.access = getStringOption(e2.access, [
        "open",
        "nonInteractive",
        "protected",
        "readOnly"
      ]);
      this.accessKey = e2.accessKey || "";
      this.anchorType = getStringOption(e2.anchorType, [
        "topLeft",
        "bottomCenter",
        "bottomLeft",
        "bottomRight",
        "middleCenter",
        "middleLeft",
        "middleRight",
        "topCenter",
        "topRight"
      ]);
      this.colSpan = getInteger({
        data: e2.colSpan,
        defaultValue: 1,
        validate: (e3) => e3 >= 1 || -1 === e3
      });
      this.h = e2.h ? getMeasurement(e2.h) : "";
      this.hAlign = getStringOption(e2.hAlign, [
        "left",
        "center",
        "justify",
        "justifyAll",
        "radix",
        "right"
      ]);
      this.id = e2.id || "";
      this.layout = getStringOption(e2.layout, [
        "position",
        "lr-tb",
        "rl-row",
        "rl-tb",
        "row",
        "table",
        "tb"
      ]);
      this.maxH = getMeasurement(e2.maxH, "0pt");
      this.maxW = getMeasurement(e2.maxW, "0pt");
      this.minH = getMeasurement(e2.minH, "0pt");
      this.minW = getMeasurement(e2.minW, "0pt");
      this.name = e2.name || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.w = e2.w ? getMeasurement(e2.w) : "";
      this.x = getMeasurement(e2.x, "0pt");
      this.y = getMeasurement(e2.y, "0pt");
      this.assist = null;
      this.bind = null;
      this.border = null;
      this.calculate = null;
      this.caption = null;
      this.desc = null;
      this.extras = null;
      this.margin = null;
      this.para = null;
      this.traversal = null;
      this.validate = null;
      this.connect = new XFAObjectArray();
      this.event = new XFAObjectArray();
      this.field = new XFAObjectArray();
      this.setProperty = new XFAObjectArray();
    }
    [xs]() {
      return true;
    }
    [Ss]() {
      return true;
    }
    [rn](e2) {
      for (const t2 of this.field.children) {
        if (!t2.value) {
          const e3 = new Value({});
          t2[$r](e3);
          t2.value = e3;
        }
        t2.value[rn](e2);
      }
    }
    [Js]() {
      return this.layout.endsWith("-tb") && 0 === this[gs].attempt && this[gs].numberInLine > 0 || this[bs]()[Js]();
    }
    [Hs]() {
      var _a4;
      const e2 = this[ws]();
      if (!e2[Hs]()) return false;
      if (void 0 !== this[gs]._isSplittable) return this[gs]._isSplittable;
      if ("position" === this.layout || this.layout.includes("row")) {
        this[gs]._isSplittable = false;
        return false;
      }
      if (((_a4 = e2.layout) == null ? void 0 : _a4.endsWith("-tb")) && 0 !== e2[gs].numberInLine) return false;
      this[gs]._isSplittable = true;
      return true;
    }
    [cs]() {
      return flushHTML(this);
    }
    [zr](e2, t2) {
      addHTML(this, e2, t2);
    }
    [ls]() {
      return getAvailableSpace(this);
    }
    [gn](e2) {
      setTabIndex(this);
      if ("hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
      fixDimensions(this);
      const t2 = [], i2 = {
        id: this[Cn],
        class: []
      };
      setAccess(this, i2.class);
      this[gs] || (this[gs] = /* @__PURE__ */ Object.create(null));
      Object.assign(this[gs], {
        children: t2,
        attributes: i2,
        attempt: 0,
        line: null,
        numberInLine: 0,
        availableSpace: {
          width: Math.min(this.w || 1 / 0, e2.width),
          height: Math.min(this.h || 1 / 0, e2.height)
        },
        width: 0,
        height: 0,
        prevHeight: 0,
        currentWidth: 0
      });
      const a2 = this[Hs]();
      a2 || setFirstUnsplittable(this);
      if (!checkDimensions(this, e2)) return HTMLResult.FAILURE;
      const r2 = /* @__PURE__ */ new Set([
        "field"
      ]);
      if (this.layout.includes("row")) {
        const e3 = this[ws]().columnWidths;
        if (Array.isArray(e3) && e3.length > 0) {
          this[gs].columnWidths = e3;
          this[gs].currentColumn = 0;
        }
      }
      const s2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), n2 = [
        "xfaExclgroup"
      ], o2 = layoutClass(this);
      o2 && n2.push(o2);
      isPrintOnly(this) && n2.push("xfaPrintOnly");
      i2.style = s2;
      i2.class = n2;
      this.name && (i2.xfaName = this.name);
      this[_s]();
      const g2 = "lr-tb" === this.layout || "rl-tb" === this.layout, c2 = g2 ? 2 : 1;
      for (; this[gs].attempt < c2; this[gs].attempt++) {
        g2 && 1 === this[gs].attempt && (this[gs].numberInLine = 0);
        const e3 = this[As]({
          filter: r2,
          include: true
        });
        if (e3.success) break;
        if (e3.isBreak()) {
          this[Vs]();
          return e3;
        }
        if (g2 && 0 === this[gs].attempt && 0 === this[gs].numberInLine && !this[Ds]()[gs].noLayoutFailure) {
          this[gs].attempt = c2;
          break;
        }
      }
      this[Vs]();
      a2 || unsetFirstUnsplittable(this);
      if (this[gs].attempt === c2) {
        a2 || delete this[gs];
        return HTMLResult.FAILURE;
      }
      let C2 = 0, h2 = 0;
      if (this.margin) {
        C2 = this.margin.leftInset + this.margin.rightInset;
        h2 = this.margin.topInset + this.margin.bottomInset;
      }
      const l2 = Math.max(this[gs].width + C2, this.w || 0), Q2 = Math.max(this[gs].height + h2, this.h || 0), E2 = [
        this.x,
        this.y,
        l2,
        Q2
      ];
      "" === this.w && (s2.width = measureToString(l2));
      "" === this.h && (s2.height = measureToString(Q2));
      const u2 = {
        name: "div",
        attributes: i2,
        children: t2
      };
      applyAssist(this, i2);
      delete this[gs];
      return HTMLResult.success(createWrapper(this, u2), E2);
    }
  }
  class Execute extends XFAObject {
    constructor(e2) {
      super(Kn, "execute");
      this.connection = e2.connection || "";
      this.executeType = getStringOption(e2.executeType, [
        "import",
        "remerge"
      ]);
      this.id = e2.id || "";
      this.runAt = getStringOption(e2.runAt, [
        "client",
        "both",
        "server"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Extras extends XFAObject {
    constructor(e2) {
      super(Kn, "extras", true);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.boolean = new XFAObjectArray();
      this.date = new XFAObjectArray();
      this.dateTime = new XFAObjectArray();
      this.decimal = new XFAObjectArray();
      this.exData = new XFAObjectArray();
      this.extras = new XFAObjectArray();
      this.float = new XFAObjectArray();
      this.image = new XFAObjectArray();
      this.integer = new XFAObjectArray();
      this.text = new XFAObjectArray();
      this.time = new XFAObjectArray();
    }
  }
  class Field extends XFAObject {
    constructor(e2) {
      super(Kn, "field", true);
      this.access = getStringOption(e2.access, [
        "open",
        "nonInteractive",
        "protected",
        "readOnly"
      ]);
      this.accessKey = e2.accessKey || "";
      this.anchorType = getStringOption(e2.anchorType, [
        "topLeft",
        "bottomCenter",
        "bottomLeft",
        "bottomRight",
        "middleCenter",
        "middleLeft",
        "middleRight",
        "topCenter",
        "topRight"
      ]);
      this.colSpan = getInteger({
        data: e2.colSpan,
        defaultValue: 1,
        validate: (e3) => e3 >= 1 || -1 === e3
      });
      this.h = e2.h ? getMeasurement(e2.h) : "";
      this.hAlign = getStringOption(e2.hAlign, [
        "left",
        "center",
        "justify",
        "justifyAll",
        "radix",
        "right"
      ]);
      this.id = e2.id || "";
      this.locale = e2.locale || "";
      this.maxH = getMeasurement(e2.maxH, "0pt");
      this.maxW = getMeasurement(e2.maxW, "0pt");
      this.minH = getMeasurement(e2.minH, "0pt");
      this.minW = getMeasurement(e2.minW, "0pt");
      this.name = e2.name || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.rotate = getInteger({
        data: e2.rotate,
        defaultValue: 0,
        validate: (e3) => e3 % 90 == 0
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.w = e2.w ? getMeasurement(e2.w) : "";
      this.x = getMeasurement(e2.x, "0pt");
      this.y = getMeasurement(e2.y, "0pt");
      this.assist = null;
      this.bind = null;
      this.border = null;
      this.calculate = null;
      this.caption = null;
      this.desc = null;
      this.extras = null;
      this.font = null;
      this.format = null;
      this.items = new XFAObjectArray(2);
      this.keep = null;
      this.margin = null;
      this.para = null;
      this.traversal = null;
      this.ui = null;
      this.validate = null;
      this.value = null;
      this.bindItems = new XFAObjectArray();
      this.connect = new XFAObjectArray();
      this.event = new XFAObjectArray();
      this.setProperty = new XFAObjectArray();
    }
    [xs]() {
      return true;
    }
    [rn](e2) {
      _setValue(this, e2);
    }
    [gn](e2) {
      var _a4, _b, _c;
      setTabIndex(this);
      if (!this.ui) {
        this.ui = new Ui({});
        this.ui[Fs] = this[Fs];
        this[$r](this.ui);
        let e3;
        switch (this.items.children.length) {
          case 0:
            e3 = new TextEdit({});
            this.ui.textEdit = e3;
            break;
          case 1:
            e3 = new CheckButton({});
            this.ui.checkButton = e3;
            break;
          case 2:
            e3 = new ChoiceList({});
            this.ui.choiceList = e3;
        }
        this.ui[$r](e3);
      }
      if (!this.ui || "hidden" === this.presence || "inactive" === this.presence || 0 === this.h || 0 === this.w) return HTMLResult.EMPTY;
      this.caption && delete this.caption[gs];
      this[_s]();
      const t2 = this.caption ? this.caption[gn](e2).html : null, i2 = this.w, a2 = this.h;
      let r2 = 0, s2 = 0;
      if (this.margin) {
        r2 = this.margin.leftInset + this.margin.rightInset;
        s2 = this.margin.topInset + this.margin.bottomInset;
      }
      let n2 = null;
      if ("" === this.w || "" === this.h) {
        let t3 = null, i3 = null, a3 = 0, o3 = 0;
        if (this.ui.checkButton) a3 = o3 = this.ui.checkButton.size;
        else {
          const { w: t4, h: i4 } = layoutNode(this, e2);
          if (null !== t4) {
            a3 = t4;
            o3 = i4;
          } else o3 = function fonts_getMetrics(e3, t5 = false) {
            let i5 = null;
            if (e3) {
              const t6 = stripQuotes(e3.typeface), a5 = e3[Fs].fontFinder.find(t6);
              i5 = selectFont(e3, a5);
            }
            if (!i5) return {
              lineHeight: 12,
              lineGap: 2,
              lineNoGap: 10
            };
            const a4 = e3.size || 10, r3 = i5.lineHeight ? Math.max(t5 ? 0 : 1.2, i5.lineHeight) : 1.2, s3 = void 0 === i5.lineGap ? 0.2 : i5.lineGap;
            return {
              lineHeight: r3 * a4,
              lineGap: s3 * a4,
              lineNoGap: Math.max(1, r3 - s3) * a4
            };
          }(this.font, true).lineNoGap;
        }
        n2 = getBorderDims(this.ui[ds]());
        a3 += n2.w;
        o3 += n2.h;
        if (this.caption) {
          const { w: r3, h: s3, isBroken: n3 } = this.caption[ds](e2);
          if (n3 && this[ws]()[Js]()) {
            this[Vs]();
            return HTMLResult.FAILURE;
          }
          t3 = r3;
          i3 = s3;
          switch (this.caption.placement) {
            case "left":
            case "right":
            case "inline":
              t3 += a3;
              break;
            case "top":
            case "bottom":
              i3 += o3;
          }
        } else {
          t3 = a3;
          i3 = o3;
        }
        if (t3 && "" === this.w) {
          t3 += r2;
          this.w = Math.min(this.maxW <= 0 ? 1 / 0 : this.maxW, this.minW + 1 < t3 ? t3 : this.minW);
        }
        if (i3 && "" === this.h) {
          i3 += s2;
          this.h = Math.min(this.maxH <= 0 ? 1 / 0 : this.maxH, this.minH + 1 < i3 ? i3 : this.minH);
        }
      }
      this[Vs]();
      fixDimensions(this);
      setFirstUnsplittable(this);
      if (!checkDimensions(this, e2)) {
        this.w = i2;
        this.h = a2;
        this[Vs]();
        return HTMLResult.FAILURE;
      }
      unsetFirstUnsplittable(this);
      const o2 = toStyle(this, "font", "dimensions", "position", "rotate", "anchorType", "presence", "margin", "hAlign");
      setMinMaxDimensions(this, o2);
      const g2 = [
        "xfaField"
      ];
      this.font && g2.push("xfaFont");
      isPrintOnly(this) && g2.push("xfaPrintOnly");
      const c2 = {
        style: o2,
        id: this[Cn],
        class: g2
      };
      if (o2.margin) {
        o2.padding = o2.margin;
        delete o2.margin;
      }
      setAccess(this, g2);
      this.name && (c2.xfaName = this.name);
      const C2 = [], h2 = {
        name: "div",
        attributes: c2,
        children: C2
      };
      applyAssist(this, c2);
      const l2 = this.border ? this.border[cn]() : null, Q2 = computeBbox(this, h2, e2), E2 = this.ui[gn]().html;
      if (!E2) {
        Object.assign(o2, l2);
        return HTMLResult.success(createWrapper(this, h2), Q2);
      }
      this[sn] && (((_a4 = E2.children) == null ? void 0 : _a4[0]) ? E2.children[0].attributes.tabindex = this[sn] : E2.attributes.tabindex = this[sn]);
      E2.attributes.style || (E2.attributes.style = /* @__PURE__ */ Object.create(null));
      let u2 = null;
      if (this.ui.button) {
        1 === E2.children.length && ([u2] = E2.children.splice(0, 1));
        Object.assign(E2.attributes.style, l2);
      } else Object.assign(o2, l2);
      C2.push(E2);
      if (this.value) {
        if (this.ui.imageEdit) E2.children.push(this.value[gn]().html);
        else if (!this.ui.button) {
          let e3 = "";
          if (this.value.exData) e3 = this.value.exData[nn]();
          else if (this.value.text) e3 = this.value.text[ds]();
          else {
            const t3 = this.value[gn]().html;
            null !== t3 && (e3 = t3.children[0].value);
          }
          this.ui.textEdit && ((_b = this.value.text) == null ? void 0 : _b.maxChars) && (E2.children[0].attributes.maxLength = this.value.text.maxChars);
          if (e3) {
            if (this.ui.numericEdit) {
              e3 = parseFloat(e3);
              e3 = isNaN(e3) ? "" : e3.toString();
            }
            "textarea" === E2.children[0].name ? E2.children[0].attributes.textContent = e3 : E2.children[0].attributes.value = e3;
          }
        }
      }
      if (!this.ui.imageEdit && ((_c = E2.children) == null ? void 0 : _c[0]) && this.h) {
        n2 = n2 || getBorderDims(this.ui[ds]());
        let t3 = 0;
        if (this.caption && [
          "top",
          "bottom"
        ].includes(this.caption.placement)) {
          t3 = this.caption.reserve;
          t3 <= 0 && (t3 = this.caption[ds](e2).h);
          const i3 = this.h - t3 - s2 - n2.h;
          E2.children[0].attributes.style.height = measureToString(i3);
        } else E2.children[0].attributes.style.height = "100%";
      }
      u2 && E2.children.push(u2);
      if (!t2) {
        E2.attributes.class && E2.attributes.class.push("xfaLeft");
        this.w = i2;
        this.h = a2;
        return HTMLResult.success(createWrapper(this, h2), Q2);
      }
      if (this.ui.button) {
        o2.padding && delete o2.padding;
        "div" === t2.name && (t2.name = "span");
        E2.children.push(t2);
        return HTMLResult.success(h2, Q2);
      }
      this.ui.checkButton && (t2.attributes.class[0] = "xfaCaptionForCheckButton");
      E2.attributes.class || (E2.attributes.class = []);
      E2.children.splice(0, 0, t2);
      switch (this.caption.placement) {
        case "left":
        case "inline":
          E2.attributes.class.push("xfaLeft");
          break;
        case "right":
          E2.attributes.class.push("xfaRight");
          break;
        case "top":
          E2.attributes.class.push("xfaTop");
          break;
        case "bottom":
          E2.attributes.class.push("xfaBottom");
      }
      this.w = i2;
      this.h = a2;
      return HTMLResult.success(createWrapper(this, h2), Q2);
    }
  }
  class Fill extends XFAObject {
    constructor(e2) {
      super(Kn, "fill", true);
      this.id = e2.id || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
      this.linear = null;
      this.pattern = null;
      this.radial = null;
      this.solid = null;
      this.stipple = null;
    }
    [cn]() {
      var _a4;
      const e2 = this[bs](), t2 = e2[bs]()[bs](), i2 = /* @__PURE__ */ Object.create(null);
      let a2 = "color", r2 = a2;
      if (e2 instanceof Border) {
        a2 = "background-color";
        r2 = "background";
        t2 instanceof Ui && (i2.backgroundColor = "white");
      }
      if (e2 instanceof Rectangle || e2 instanceof Arc) {
        a2 = r2 = "fill";
        i2.fill = "white";
      }
      for (const e3 of Object.getOwnPropertyNames(this)) {
        if ("extras" === e3 || "color" === e3) continue;
        const t3 = this[e3];
        if (!(t3 instanceof XFAObject)) continue;
        const s2 = t3[cn](this.color);
        s2 && (i2[s2.startsWith("#") ? a2 : r2] = s2);
        return i2;
      }
      if ((_a4 = this.color) == null ? void 0 : _a4.value) {
        const e3 = this.color[cn]();
        i2[e3.startsWith("#") ? a2 : r2] = e3;
      }
      return i2;
    }
  }
  class Filter extends XFAObject {
    constructor(e2) {
      super(Kn, "filter", true);
      this.addRevocationInfo = getStringOption(e2.addRevocationInfo, [
        "",
        "required",
        "optional",
        "none"
      ]);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.version = getInteger({
        data: this.version,
        defaultValue: 5,
        validate: (e3) => e3 >= 1 && e3 <= 5
      });
      this.appearanceFilter = null;
      this.certificates = null;
      this.digestMethods = null;
      this.encodings = null;
      this.encryptionMethods = null;
      this.handler = null;
      this.lockDocument = null;
      this.mdp = null;
      this.reasons = null;
      this.timeStamp = null;
    }
  }
  class Float extends ContentObject {
    constructor(e2) {
      super(Kn, "float");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      const e2 = parseFloat(this[ss].trim());
      this[ss] = isNaN(e2) ? null : e2;
    }
    [gn](e2) {
      return valueToHtml(null !== this[ss] ? this[ss].toString() : "");
    }
  }
  class template_Font extends XFAObject {
    constructor(e2) {
      super(Kn, "font", true);
      this.baselineShift = getMeasurement(e2.baselineShift);
      this.fontHorizontalScale = getFloat({
        data: e2.fontHorizontalScale,
        defaultValue: 100,
        validate: (e3) => e3 >= 0
      });
      this.fontVerticalScale = getFloat({
        data: e2.fontVerticalScale,
        defaultValue: 100,
        validate: (e3) => e3 >= 0
      });
      this.id = e2.id || "";
      this.kerningMode = getStringOption(e2.kerningMode, [
        "none",
        "pair"
      ]);
      this.letterSpacing = getMeasurement(e2.letterSpacing, "0");
      this.lineThrough = getInteger({
        data: e2.lineThrough,
        defaultValue: 0,
        validate: (e3) => 1 === e3 || 2 === e3
      });
      this.lineThroughPeriod = getStringOption(e2.lineThroughPeriod, [
        "all",
        "word"
      ]);
      this.overline = getInteger({
        data: e2.overline,
        defaultValue: 0,
        validate: (e3) => 1 === e3 || 2 === e3
      });
      this.overlinePeriod = getStringOption(e2.overlinePeriod, [
        "all",
        "word"
      ]);
      this.posture = getStringOption(e2.posture, [
        "normal",
        "italic"
      ]);
      this.size = getMeasurement(e2.size, "10pt");
      this.typeface = e2.typeface || "Courier";
      this.underline = getInteger({
        data: e2.underline,
        defaultValue: 0,
        validate: (e3) => 1 === e3 || 2 === e3
      });
      this.underlinePeriod = getStringOption(e2.underlinePeriod, [
        "all",
        "word"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.weight = getStringOption(e2.weight, [
        "normal",
        "bold"
      ]);
      this.extras = null;
      this.fill = null;
    }
    [es](e2) {
      super[es](e2);
      this[Fs].usedTypefaces.add(this.typeface);
    }
    [cn]() {
      const e2 = toStyle(this, "fill"), t2 = e2.color;
      if (t2) {
        if ("#000000" === t2) delete e2.color;
        else if (!t2.startsWith("#")) {
          e2.background = t2;
          e2.backgroundClip = "text";
          e2.color = "transparent";
        }
      }
      this.baselineShift && (e2.verticalAlign = measureToString(this.baselineShift));
      e2.fontKerning = "none" === this.kerningMode ? "none" : "normal";
      e2.letterSpacing = measureToString(this.letterSpacing);
      if (0 !== this.lineThrough) {
        e2.textDecoration = "line-through";
        2 === this.lineThrough && (e2.textDecorationStyle = "double");
      }
      if (0 !== this.overline) {
        e2.textDecoration = "overline";
        2 === this.overline && (e2.textDecorationStyle = "double");
      }
      e2.fontStyle = this.posture;
      e2.fontSize = measureToString(0.99 * this.size);
      setFontFamily(this, this, this[Fs].fontFinder, e2);
      if (0 !== this.underline) {
        e2.textDecoration = "underline";
        2 === this.underline && (e2.textDecorationStyle = "double");
      }
      e2.fontWeight = this.weight;
      return e2;
    }
  }
  class Format extends XFAObject {
    constructor(e2) {
      super(Kn, "format", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.picture = null;
    }
  }
  class Handler extends StringObject {
    constructor(e2) {
      super(Kn, "handler");
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Hyphenation extends XFAObject {
    constructor(e2) {
      super(Kn, "hyphenation");
      this.excludeAllCaps = getInteger({
        data: e2.excludeAllCaps,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.excludeInitialCap = getInteger({
        data: e2.excludeInitialCap,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.hyphenate = getInteger({
        data: e2.hyphenate,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.id = e2.id || "";
      this.pushCharacterCount = getInteger({
        data: e2.pushCharacterCount,
        defaultValue: 3,
        validate: (e3) => e3 >= 0
      });
      this.remainCharacterCount = getInteger({
        data: e2.remainCharacterCount,
        defaultValue: 3,
        validate: (e3) => e3 >= 0
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.wordCharacterCount = getInteger({
        data: e2.wordCharacterCount,
        defaultValue: 7,
        validate: (e3) => e3 >= 0
      });
    }
  }
  class Image extends StringObject {
    constructor(e2) {
      super(Kn, "image");
      this.aspect = getStringOption(e2.aspect, [
        "fit",
        "actual",
        "height",
        "none",
        "width"
      ]);
      this.contentType = e2.contentType || "";
      this.href = e2.href || "";
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.transferEncoding = getStringOption(e2.transferEncoding, [
        "base64",
        "none",
        "package"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [gn]() {
      if (this.contentType && !Pn.has(this.contentType.toLowerCase())) return HTMLResult.EMPTY;
      let e2 = this[Fs].images && this[Fs].images.get(this.href);
      if (!e2 && (this.href || !this[ss])) return HTMLResult.EMPTY;
      e2 || "base64" !== this.transferEncoding || (e2 = function fromBase64Util(e3) {
        return Uint8Array.fromBase64 ? Uint8Array.fromBase64(e3) : stringToBytes(atob(e3));
      }(this[ss]));
      if (!e2) return HTMLResult.EMPTY;
      if (!this.contentType) {
        for (const [t3, i3] of Wn) if (e2.length > t3.length && t3.every((t4, i4) => t4 === e2[i4])) {
          this.contentType = i3;
          break;
        }
        if (!this.contentType) return HTMLResult.EMPTY;
      }
      const t2 = new Blob([
        e2
      ], {
        type: this.contentType
      });
      let i2;
      switch (this.aspect) {
        case "fit":
        case "actual":
          break;
        case "height":
          i2 = {
            height: "100%",
            objectFit: "fill"
          };
          break;
        case "none":
          i2 = {
            width: "100%",
            height: "100%",
            objectFit: "fill"
          };
          break;
        case "width":
          i2 = {
            width: "100%",
            objectFit: "fill"
          };
      }
      const a2 = this[bs]();
      return HTMLResult.success({
        name: "img",
        attributes: {
          class: [
            "xfaImage"
          ],
          style: i2,
          src: URL.createObjectURL(t2),
          alt: a2 ? ariaLabel(a2[bs]()) : null
        }
      });
    }
  }
  class ImageEdit extends XFAObject {
    constructor(e2) {
      super(Kn, "imageEdit", true);
      this.data = getStringOption(e2.data, [
        "link",
        "embed"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.extras = null;
      this.margin = null;
    }
    [gn](e2) {
      return "embed" === this.data ? HTMLResult.success({
        name: "div",
        children: [],
        attributes: {}
      }) : HTMLResult.EMPTY;
    }
  }
  class Integer extends ContentObject {
    constructor(e2) {
      super(Kn, "integer");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      const e2 = parseInt(this[ss].trim(), 10);
      this[ss] = isNaN(e2) ? null : e2;
    }
    [gn](e2) {
      return valueToHtml(null !== this[ss] ? this[ss].toString() : "");
    }
  }
  class Issuers extends XFAObject {
    constructor(e2) {
      super(Kn, "issuers", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.certificate = new XFAObjectArray();
    }
  }
  class Items extends XFAObject {
    constructor(e2) {
      super(Kn, "items", true);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.ref = e2.ref || "";
      this.save = getInteger({
        data: e2.save,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.boolean = new XFAObjectArray();
      this.date = new XFAObjectArray();
      this.dateTime = new XFAObjectArray();
      this.decimal = new XFAObjectArray();
      this.exData = new XFAObjectArray();
      this.float = new XFAObjectArray();
      this.image = new XFAObjectArray();
      this.integer = new XFAObjectArray();
      this.text = new XFAObjectArray();
      this.time = new XFAObjectArray();
    }
    [gn]() {
      const e2 = [];
      for (const t2 of this[ps]()) e2.push(t2[nn]());
      return HTMLResult.success(e2);
    }
  }
  class Keep extends XFAObject {
    constructor(e2) {
      super(Kn, "keep", true);
      this.id = e2.id || "";
      const t2 = [
        "none",
        "contentArea",
        "pageArea"
      ];
      this.intact = getStringOption(e2.intact, t2);
      this.next = getStringOption(e2.next, t2);
      this.previous = getStringOption(e2.previous, t2);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
  }
  class KeyUsage extends XFAObject {
    constructor(e2) {
      super(Kn, "keyUsage");
      const t2 = [
        "",
        "yes",
        "no"
      ];
      this.crlSign = getStringOption(e2.crlSign, t2);
      this.dataEncipherment = getStringOption(e2.dataEncipherment, t2);
      this.decipherOnly = getStringOption(e2.decipherOnly, t2);
      this.digitalSignature = getStringOption(e2.digitalSignature, t2);
      this.encipherOnly = getStringOption(e2.encipherOnly, t2);
      this.id = e2.id || "";
      this.keyAgreement = getStringOption(e2.keyAgreement, t2);
      this.keyCertSign = getStringOption(e2.keyCertSign, t2);
      this.keyEncipherment = getStringOption(e2.keyEncipherment, t2);
      this.nonRepudiation = getStringOption(e2.nonRepudiation, t2);
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Line extends XFAObject {
    constructor(e2) {
      super(Kn, "line", true);
      this.hand = getStringOption(e2.hand, [
        "even",
        "left",
        "right"
      ]);
      this.id = e2.id || "";
      this.slope = getStringOption(e2.slope, [
        "\\",
        "/"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.edge = null;
    }
    [gn]() {
      const e2 = this[bs]()[bs](), t2 = this.edge || new Edge({}), i2 = t2[cn](), a2 = /* @__PURE__ */ Object.create(null), r2 = "visible" === t2.presence ? t2.thickness : 0;
      a2.strokeWidth = measureToString(r2);
      a2.stroke = i2.color;
      let s2, n2, o2, g2, c2 = "100%", C2 = "100%";
      if (e2.w <= r2) {
        [s2, n2, o2, g2] = [
          "50%",
          0,
          "50%",
          "100%"
        ];
        c2 = a2.strokeWidth;
      } else if (e2.h <= r2) {
        [s2, n2, o2, g2] = [
          0,
          "50%",
          "100%",
          "50%"
        ];
        C2 = a2.strokeWidth;
      } else "\\" === this.slope ? [s2, n2, o2, g2] = [
        0,
        0,
        "100%",
        "100%"
      ] : [s2, n2, o2, g2] = [
        0,
        "100%",
        "100%",
        0
      ];
      const h2 = {
        name: "svg",
        children: [
          {
            name: "line",
            attributes: {
              xmlns: qn,
              x1: s2,
              y1: n2,
              x2: o2,
              y2: g2,
              style: a2
            }
          }
        ],
        attributes: {
          xmlns: qn,
          width: c2,
          height: C2,
          style: {
            overflow: "visible"
          }
        }
      };
      if (hasMargin(e2)) return HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [
          h2
        ]
      });
      h2.attributes.style.position = "absolute";
      return HTMLResult.success(h2);
    }
  }
  class Linear extends XFAObject {
    constructor(e2) {
      super(Kn, "linear", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "toRight",
        "toBottom",
        "toLeft",
        "toTop"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
    }
    [cn](e2) {
      e2 = e2 ? e2[cn]() : "#FFFFFF";
      return `linear-gradient(${this.type.replace(/([RBLT])/, " $1").toLowerCase()}, ${e2}, ${this.color ? this.color[cn]() : "#000000"})`;
    }
  }
  class LockDocument extends ContentObject {
    constructor(e2) {
      super(Kn, "lockDocument");
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      this[ss] = getStringOption(this[ss], [
        "auto",
        "0",
        "1"
      ]);
    }
  }
  class Manifest extends XFAObject {
    constructor(e2) {
      super(Kn, "manifest", true);
      this.action = getStringOption(e2.action, [
        "include",
        "all",
        "exclude"
      ]);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.ref = new XFAObjectArray();
    }
  }
  class Margin extends XFAObject {
    constructor(e2) {
      super(Kn, "margin", true);
      this.bottomInset = getMeasurement(e2.bottomInset, "0");
      this.id = e2.id || "";
      this.leftInset = getMeasurement(e2.leftInset, "0");
      this.rightInset = getMeasurement(e2.rightInset, "0");
      this.topInset = getMeasurement(e2.topInset, "0");
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
    [cn]() {
      return {
        margin: measureToString(this.topInset) + " " + measureToString(this.rightInset) + " " + measureToString(this.bottomInset) + " " + measureToString(this.leftInset)
      };
    }
  }
  class Mdp extends XFAObject {
    constructor(e2) {
      super(Kn, "mdp");
      this.id = e2.id || "";
      this.permissions = getInteger({
        data: e2.permissions,
        defaultValue: 2,
        validate: (e3) => 1 === e3 || 3 === e3
      });
      this.signatureType = getStringOption(e2.signatureType, [
        "filler",
        "author"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Medium extends XFAObject {
    constructor(e2) {
      super(Kn, "medium");
      this.id = e2.id || "";
      this.imagingBBox = function getBBox(e3) {
        const t2 = -1;
        if (!e3) return {
          x: t2,
          y: t2,
          width: t2,
          height: t2
        };
        const i2 = e3.trim().split(/\s*,\s*/).map((e4) => getMeasurement(e4, "-1"));
        if (i2.length < 4 || i2[2] < 0 || i2[3] < 0) return {
          x: t2,
          y: t2,
          width: t2,
          height: t2
        };
        const [a2, r2, s2, n2] = i2;
        return {
          x: a2,
          y: r2,
          width: s2,
          height: n2
        };
      }(e2.imagingBBox);
      this.long = getMeasurement(e2.long);
      this.orientation = getStringOption(e2.orientation, [
        "portrait",
        "landscape"
      ]);
      this.short = getMeasurement(e2.short);
      this.stock = e2.stock || "";
      this.trayIn = getStringOption(e2.trayIn, [
        "auto",
        "delegate",
        "pageFront"
      ]);
      this.trayOut = getStringOption(e2.trayOut, [
        "auto",
        "delegate"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Message extends XFAObject {
    constructor(e2) {
      super(Kn, "message", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.text = new XFAObjectArray();
    }
  }
  class NumericEdit extends XFAObject {
    constructor(e2) {
      super(Kn, "numericEdit", true);
      this.hScrollPolicy = getStringOption(e2.hScrollPolicy, [
        "auto",
        "off",
        "on"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.comb = null;
      this.extras = null;
      this.margin = null;
    }
    [gn](e2) {
      var _a4;
      const t2 = toStyle(this, "border", "font", "margin"), i2 = this[bs]()[bs](), a2 = {
        name: "input",
        attributes: {
          type: "text",
          fieldId: i2[Cn],
          dataId: ((_a4 = i2[ns]) == null ? void 0 : _a4[Cn]) || i2[Cn],
          class: [
            "xfaTextfield"
          ],
          style: t2,
          "aria-label": ariaLabel(i2),
          "aria-required": false
        }
      };
      if (isRequired(i2)) {
        a2.attributes["aria-required"] = true;
        a2.attributes.required = true;
      }
      return HTMLResult.success({
        name: "label",
        attributes: {
          class: [
            "xfaLabel"
          ]
        },
        children: [
          a2
        ]
      });
    }
  }
  class Occur extends XFAObject {
    constructor(e2) {
      super(Kn, "occur", true);
      this.id = e2.id || "";
      this.initial = "" !== e2.initial ? getInteger({
        data: e2.initial,
        defaultValue: "",
        validate: (e3) => true
      }) : "";
      this.max = "" !== e2.max ? getInteger({
        data: e2.max,
        defaultValue: 1,
        validate: (e3) => true
      }) : "";
      this.min = "" !== e2.min ? getInteger({
        data: e2.min,
        defaultValue: 1,
        validate: (e3) => true
      }) : "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
    [es]() {
      const e2 = this[bs](), t2 = this.min;
      "" === this.min && (this.min = e2 instanceof PageArea || e2 instanceof PageSet ? 0 : 1);
      "" === this.max && (this.max = "" === t2 ? e2 instanceof PageArea || e2 instanceof PageSet ? -1 : 1 : this.min);
      -1 !== this.max && this.max < this.min && (this.max = this.min);
      "" === this.initial && (this.initial = e2 instanceof Template ? 1 : this.min);
    }
  }
  class Oid extends StringObject {
    constructor(e2) {
      super(Kn, "oid");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Oids extends XFAObject {
    constructor(e2) {
      super(Kn, "oids", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.oid = new XFAObjectArray();
    }
  }
  class Overflow extends XFAObject {
    constructor(e2) {
      super(Kn, "overflow");
      this.id = e2.id || "";
      this.leader = e2.leader || "";
      this.target = e2.target || "";
      this.trailer = e2.trailer || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [ds]() {
      if (!this[gs]) {
        const e2 = this[bs](), t2 = this[Ds](), i2 = t2[en](this.target, e2), a2 = t2[en](this.leader, e2), r2 = t2[en](this.trailer, e2);
        this[gs] = {
          target: (i2 == null ? void 0 : i2[0]) || null,
          leader: (a2 == null ? void 0 : a2[0]) || null,
          trailer: (r2 == null ? void 0 : r2[0]) || null,
          addLeader: false,
          addTrailer: false
        };
      }
      return this[gs];
    }
  }
  class PageArea extends XFAObject {
    constructor(e2) {
      super(Kn, "pageArea", true);
      this.blankOrNotBlank = getStringOption(e2.blankOrNotBlank, [
        "any",
        "blank",
        "notBlank"
      ]);
      this.id = e2.id || "";
      this.initialNumber = getInteger({
        data: e2.initialNumber,
        defaultValue: 1,
        validate: (e3) => true
      });
      this.name = e2.name || "";
      this.numbered = getInteger({
        data: e2.numbered,
        defaultValue: 1,
        validate: (e3) => true
      });
      this.oddOrEven = getStringOption(e2.oddOrEven, [
        "any",
        "even",
        "odd"
      ]);
      this.pagePosition = getStringOption(e2.pagePosition, [
        "any",
        "first",
        "last",
        "only",
        "rest"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.desc = null;
      this.extras = null;
      this.medium = null;
      this.occur = null;
      this.area = new XFAObjectArray();
      this.contentArea = new XFAObjectArray();
      this.draw = new XFAObjectArray();
      this.exclGroup = new XFAObjectArray();
      this.field = new XFAObjectArray();
      this.subform = new XFAObjectArray();
    }
    [Ys]() {
      if (!this[gs]) {
        this[gs] = {
          numberOfUse: 0
        };
        return true;
      }
      return !this.occur || -1 === this.occur.max || this[gs].numberOfUse < this.occur.max;
    }
    [ts]() {
      delete this[gs];
    }
    [ys]() {
      this[gs] || (this[gs] = {
        numberOfUse: 0
      });
      const e2 = this[bs]();
      if ("orderedOccurrence" === e2.relation && this[Ys]()) {
        this[gs].numberOfUse += 1;
        return this;
      }
      return e2[ys]();
    }
    [ls]() {
      return this[gs].space || {
        width: 0,
        height: 0
      };
    }
    [gn]() {
      this[gs] || (this[gs] = {
        numberOfUse: 1
      });
      const e2 = [];
      this[gs].children = e2;
      const t2 = /* @__PURE__ */ Object.create(null);
      if (this.medium && this.medium.short && this.medium.long) {
        t2.width = measureToString(this.medium.short);
        t2.height = measureToString(this.medium.long);
        this[gs].space = {
          width: this.medium.short,
          height: this.medium.long
        };
        if ("landscape" === this.medium.orientation) {
          const e3 = t2.width;
          t2.width = t2.height;
          t2.height = e3;
          this[gs].space = {
            width: this.medium.long,
            height: this.medium.short
          };
        }
      } else warn("XFA - No medium specified in pageArea: please file a bug.");
      this[As]({
        filter: /* @__PURE__ */ new Set([
          "area",
          "draw",
          "field",
          "subform"
        ]),
        include: true
      });
      this[As]({
        filter: /* @__PURE__ */ new Set([
          "contentArea"
        ]),
        include: true
      });
      return HTMLResult.success({
        name: "div",
        children: e2,
        attributes: {
          class: [
            "xfaPage"
          ],
          id: this[Cn],
          style: t2,
          xfaName: this.name
        }
      });
    }
  }
  class PageSet extends XFAObject {
    constructor(e2) {
      super(Kn, "pageSet", true);
      this.duplexImposition = getStringOption(e2.duplexImposition, [
        "longEdge",
        "shortEdge"
      ]);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.relation = getStringOption(e2.relation, [
        "orderedOccurrence",
        "duplexPaginated",
        "simplexPaginated"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.occur = null;
      this.pageArea = new XFAObjectArray();
      this.pageSet = new XFAObjectArray();
    }
    [ts]() {
      for (const e2 of this.pageArea.children) e2[ts]();
      for (const e2 of this.pageSet.children) e2[ts]();
    }
    [Ys]() {
      return !this.occur || -1 === this.occur.max || this[gs].numberOfUse < this.occur.max;
    }
    [ys]() {
      this[gs] || (this[gs] = {
        numberOfUse: 1,
        pageIndex: -1,
        pageSetIndex: -1
      });
      if ("orderedOccurrence" === this.relation) {
        if (this[gs].pageIndex + 1 < this.pageArea.children.length) {
          this[gs].pageIndex += 1;
          return this.pageArea.children[this[gs].pageIndex][ys]();
        }
        if (this[gs].pageSetIndex + 1 < this.pageSet.children.length) {
          this[gs].pageSetIndex += 1;
          return this.pageSet.children[this[gs].pageSetIndex][ys]();
        }
        if (this[Ys]()) {
          this[gs].numberOfUse += 1;
          this[gs].pageIndex = -1;
          this[gs].pageSetIndex = -1;
          return this[ys]();
        }
        const e3 = this[bs]();
        if (e3 instanceof PageSet) return e3[ys]();
        this[ts]();
        return this[ys]();
      }
      const e2 = this[Ds]()[gs].pageNumber, t2 = e2 % 2 == 0 ? "even" : "odd", i2 = 0 === e2 ? "first" : "rest";
      let a2 = this.pageArea.children.find((e3) => e3.oddOrEven === t2 && e3.pagePosition === i2);
      if (a2) return a2;
      a2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && e3.pagePosition === i2);
      if (a2) return a2;
      a2 = this.pageArea.children.find((e3) => "any" === e3.oddOrEven && "any" === e3.pagePosition);
      return a2 || this.pageArea.children[0];
    }
  }
  class Para extends XFAObject {
    constructor(e2) {
      super(Kn, "para", true);
      this.hAlign = getStringOption(e2.hAlign, [
        "left",
        "center",
        "justify",
        "justifyAll",
        "radix",
        "right"
      ]);
      this.id = e2.id || "";
      this.lineHeight = e2.lineHeight ? getMeasurement(e2.lineHeight, "0pt") : "";
      this.marginLeft = e2.marginLeft ? getMeasurement(e2.marginLeft, "0pt") : "";
      this.marginRight = e2.marginRight ? getMeasurement(e2.marginRight, "0pt") : "";
      this.orphans = getInteger({
        data: e2.orphans,
        defaultValue: 0,
        validate: (e3) => e3 >= 0
      });
      this.preserve = e2.preserve || "";
      this.radixOffset = e2.radixOffset ? getMeasurement(e2.radixOffset, "0pt") : "";
      this.spaceAbove = e2.spaceAbove ? getMeasurement(e2.spaceAbove, "0pt") : "";
      this.spaceBelow = e2.spaceBelow ? getMeasurement(e2.spaceBelow, "0pt") : "";
      this.tabDefault = e2.tabDefault ? getMeasurement(this.tabDefault) : "";
      this.tabStops = (e2.tabStops || "").trim().split(/\s+/).map((e3, t2) => t2 % 2 == 1 ? getMeasurement(e3) : e3);
      this.textIndent = e2.textIndent ? getMeasurement(e2.textIndent, "0pt") : "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.vAlign = getStringOption(e2.vAlign, [
        "top",
        "bottom",
        "middle"
      ]);
      this.widows = getInteger({
        data: e2.widows,
        defaultValue: 0,
        validate: (e3) => e3 >= 0
      });
      this.hyphenation = null;
    }
    [cn]() {
      const e2 = toStyle(this, "hAlign");
      "" !== this.marginLeft && (e2.paddingLeft = measureToString(this.marginLeft));
      "" !== this.marginRight && (e2.paddingight = measureToString(this.marginRight));
      "" !== this.spaceAbove && (e2.paddingTop = measureToString(this.spaceAbove));
      "" !== this.spaceBelow && (e2.paddingBottom = measureToString(this.spaceBelow));
      if ("" !== this.textIndent) {
        e2.textIndent = measureToString(this.textIndent);
        fixTextIndent(e2);
      }
      this.lineHeight > 0 && (e2.lineHeight = measureToString(this.lineHeight));
      "" !== this.tabDefault && (e2.tabSize = measureToString(this.tabDefault));
      this.tabStops.length;
      this.hyphenatation && Object.assign(e2, this.hyphenatation[cn]());
      return e2;
    }
  }
  class PasswordEdit extends XFAObject {
    constructor(e2) {
      super(Kn, "passwordEdit", true);
      this.hScrollPolicy = getStringOption(e2.hScrollPolicy, [
        "auto",
        "off",
        "on"
      ]);
      this.id = e2.id || "";
      this.passwordChar = e2.passwordChar || "*";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.extras = null;
      this.margin = null;
    }
  }
  class template_Pattern extends XFAObject {
    constructor(e2) {
      super(Kn, "pattern", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "crossHatch",
        "crossDiagonal",
        "diagonalLeft",
        "diagonalRight",
        "horizontal",
        "vertical"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
    }
    [cn](e2) {
      e2 = e2 ? e2[cn]() : "#FFFFFF";
      const t2 = this.color ? this.color[cn]() : "#000000", i2 = "repeating-linear-gradient", a2 = `${e2},${e2} 5px,${t2} 5px,${t2} 10px`;
      switch (this.type) {
        case "crossHatch":
          return `${i2}(to top,${a2}) ${i2}(to right,${a2})`;
        case "crossDiagonal":
          return `${i2}(45deg,${a2}) ${i2}(-45deg,${a2})`;
        case "diagonalLeft":
          return `${i2}(45deg,${a2})`;
        case "diagonalRight":
          return `${i2}(-45deg,${a2})`;
        case "horizontal":
          return `${i2}(to top,${a2})`;
        case "vertical":
          return `${i2}(to right,${a2})`;
      }
      return "";
    }
  }
  class Picture extends StringObject {
    constructor(e2) {
      super(Kn, "picture");
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Proto extends XFAObject {
    constructor(e2) {
      super(Kn, "proto", true);
      this.appearanceFilter = new XFAObjectArray();
      this.arc = new XFAObjectArray();
      this.area = new XFAObjectArray();
      this.assist = new XFAObjectArray();
      this.barcode = new XFAObjectArray();
      this.bindItems = new XFAObjectArray();
      this.bookend = new XFAObjectArray();
      this.boolean = new XFAObjectArray();
      this.border = new XFAObjectArray();
      this.break = new XFAObjectArray();
      this.breakAfter = new XFAObjectArray();
      this.breakBefore = new XFAObjectArray();
      this.button = new XFAObjectArray();
      this.calculate = new XFAObjectArray();
      this.caption = new XFAObjectArray();
      this.certificate = new XFAObjectArray();
      this.certificates = new XFAObjectArray();
      this.checkButton = new XFAObjectArray();
      this.choiceList = new XFAObjectArray();
      this.color = new XFAObjectArray();
      this.comb = new XFAObjectArray();
      this.connect = new XFAObjectArray();
      this.contentArea = new XFAObjectArray();
      this.corner = new XFAObjectArray();
      this.date = new XFAObjectArray();
      this.dateTime = new XFAObjectArray();
      this.dateTimeEdit = new XFAObjectArray();
      this.decimal = new XFAObjectArray();
      this.defaultUi = new XFAObjectArray();
      this.desc = new XFAObjectArray();
      this.digestMethod = new XFAObjectArray();
      this.digestMethods = new XFAObjectArray();
      this.draw = new XFAObjectArray();
      this.edge = new XFAObjectArray();
      this.encoding = new XFAObjectArray();
      this.encodings = new XFAObjectArray();
      this.encrypt = new XFAObjectArray();
      this.encryptData = new XFAObjectArray();
      this.encryption = new XFAObjectArray();
      this.encryptionMethod = new XFAObjectArray();
      this.encryptionMethods = new XFAObjectArray();
      this.event = new XFAObjectArray();
      this.exData = new XFAObjectArray();
      this.exObject = new XFAObjectArray();
      this.exclGroup = new XFAObjectArray();
      this.execute = new XFAObjectArray();
      this.extras = new XFAObjectArray();
      this.field = new XFAObjectArray();
      this.fill = new XFAObjectArray();
      this.filter = new XFAObjectArray();
      this.float = new XFAObjectArray();
      this.font = new XFAObjectArray();
      this.format = new XFAObjectArray();
      this.handler = new XFAObjectArray();
      this.hyphenation = new XFAObjectArray();
      this.image = new XFAObjectArray();
      this.imageEdit = new XFAObjectArray();
      this.integer = new XFAObjectArray();
      this.issuers = new XFAObjectArray();
      this.items = new XFAObjectArray();
      this.keep = new XFAObjectArray();
      this.keyUsage = new XFAObjectArray();
      this.line = new XFAObjectArray();
      this.linear = new XFAObjectArray();
      this.lockDocument = new XFAObjectArray();
      this.manifest = new XFAObjectArray();
      this.margin = new XFAObjectArray();
      this.mdp = new XFAObjectArray();
      this.medium = new XFAObjectArray();
      this.message = new XFAObjectArray();
      this.numericEdit = new XFAObjectArray();
      this.occur = new XFAObjectArray();
      this.oid = new XFAObjectArray();
      this.oids = new XFAObjectArray();
      this.overflow = new XFAObjectArray();
      this.pageArea = new XFAObjectArray();
      this.pageSet = new XFAObjectArray();
      this.para = new XFAObjectArray();
      this.passwordEdit = new XFAObjectArray();
      this.pattern = new XFAObjectArray();
      this.picture = new XFAObjectArray();
      this.radial = new XFAObjectArray();
      this.reason = new XFAObjectArray();
      this.reasons = new XFAObjectArray();
      this.rectangle = new XFAObjectArray();
      this.ref = new XFAObjectArray();
      this.script = new XFAObjectArray();
      this.setProperty = new XFAObjectArray();
      this.signData = new XFAObjectArray();
      this.signature = new XFAObjectArray();
      this.signing = new XFAObjectArray();
      this.solid = new XFAObjectArray();
      this.speak = new XFAObjectArray();
      this.stipple = new XFAObjectArray();
      this.subform = new XFAObjectArray();
      this.subformSet = new XFAObjectArray();
      this.subjectDN = new XFAObjectArray();
      this.subjectDNs = new XFAObjectArray();
      this.submit = new XFAObjectArray();
      this.text = new XFAObjectArray();
      this.textEdit = new XFAObjectArray();
      this.time = new XFAObjectArray();
      this.timeStamp = new XFAObjectArray();
      this.toolTip = new XFAObjectArray();
      this.traversal = new XFAObjectArray();
      this.traverse = new XFAObjectArray();
      this.ui = new XFAObjectArray();
      this.validate = new XFAObjectArray();
      this.value = new XFAObjectArray();
      this.variables = new XFAObjectArray();
    }
  }
  class Radial extends XFAObject {
    constructor(e2) {
      super(Kn, "radial", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "toEdge",
        "toCenter"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
    }
    [cn](e2) {
      e2 = e2 ? e2[cn]() : "#FFFFFF";
      const t2 = this.color ? this.color[cn]() : "#000000";
      return `radial-gradient(circle at center, ${"toEdge" === this.type ? `${e2},${t2}` : `${t2},${e2}`})`;
    }
  }
  class Reason extends StringObject {
    constructor(e2) {
      super(Kn, "reason");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Reasons extends XFAObject {
    constructor(e2) {
      super(Kn, "reasons", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.reason = new XFAObjectArray();
    }
  }
  class Rectangle extends XFAObject {
    constructor(e2) {
      super(Kn, "rectangle", true);
      this.hand = getStringOption(e2.hand, [
        "even",
        "left",
        "right"
      ]);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.corner = new XFAObjectArray(4);
      this.edge = new XFAObjectArray(4);
      this.fill = null;
    }
    [gn]() {
      var _a4;
      const e2 = this.edge.children.length ? this.edge.children[0] : new Edge({}), t2 = e2[cn](), i2 = /* @__PURE__ */ Object.create(null);
      "visible" === ((_a4 = this.fill) == null ? void 0 : _a4.presence) ? Object.assign(i2, this.fill[cn]()) : i2.fill = "transparent";
      i2.strokeWidth = measureToString("visible" === e2.presence ? e2.thickness : 0);
      i2.stroke = t2.color;
      const a2 = (this.corner.children.length ? this.corner.children[0] : new Corner({}))[cn](), r2 = {
        name: "svg",
        children: [
          {
            name: "rect",
            attributes: {
              xmlns: qn,
              width: "100%",
              height: "100%",
              x: 0,
              y: 0,
              rx: a2.radius,
              ry: a2.radius,
              style: i2
            }
          }
        ],
        attributes: {
          xmlns: qn,
          style: {
            overflow: "visible"
          },
          width: "100%",
          height: "100%"
        }
      };
      if (hasMargin(this[bs]()[bs]())) return HTMLResult.success({
        name: "div",
        attributes: {
          style: {
            display: "inline",
            width: "100%",
            height: "100%"
          }
        },
        children: [
          r2
        ]
      });
      r2.attributes.style.position = "absolute";
      return HTMLResult.success(r2);
    }
  }
  class RefElement extends StringObject {
    constructor(e2) {
      super(Kn, "ref");
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Script extends StringObject {
    constructor(e2) {
      super(Kn, "script");
      this.binding = e2.binding || "";
      this.contentType = e2.contentType || "";
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.runAt = getStringOption(e2.runAt, [
        "client",
        "both",
        "server"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class SetProperty extends XFAObject {
    constructor(e2) {
      super(Kn, "setProperty");
      this.connection = e2.connection || "";
      this.ref = e2.ref || "";
      this.target = e2.target || "";
    }
  }
  class SignData extends XFAObject {
    constructor(e2) {
      super(Kn, "signData", true);
      this.id = e2.id || "";
      this.operation = getStringOption(e2.operation, [
        "sign",
        "clear",
        "verify"
      ]);
      this.ref = e2.ref || "";
      this.target = e2.target || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.filter = null;
      this.manifest = null;
    }
  }
  class Signature extends XFAObject {
    constructor(e2) {
      super(Kn, "signature", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "PDF1.3",
        "PDF1.6"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.border = null;
      this.extras = null;
      this.filter = null;
      this.manifest = null;
      this.margin = null;
    }
  }
  class Signing extends XFAObject {
    constructor(e2) {
      super(Kn, "signing", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.certificate = new XFAObjectArray();
    }
  }
  class Solid extends XFAObject {
    constructor(e2) {
      super(Kn, "solid", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
    }
    [cn](e2) {
      return e2 ? e2[cn]() : "#FFFFFF";
    }
  }
  class Speak extends StringObject {
    constructor(e2) {
      super(Kn, "speak");
      this.disable = getInteger({
        data: e2.disable,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.id = e2.id || "";
      this.priority = getStringOption(e2.priority, [
        "custom",
        "caption",
        "name",
        "toolTip"
      ]);
      this.rid = e2.rid || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Stipple extends XFAObject {
    constructor(e2) {
      super(Kn, "stipple", true);
      this.id = e2.id || "";
      this.rate = getInteger({
        data: e2.rate,
        defaultValue: 50,
        validate: (e3) => e3 >= 0 && e3 <= 100
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.color = null;
      this.extras = null;
    }
    [cn](e2) {
      const t2 = this.rate / 100;
      return Util.makeHexColor(Math.round(e2.value.r * (1 - t2) + this.value.r * t2), Math.round(e2.value.g * (1 - t2) + this.value.g * t2), Math.round(e2.value.b * (1 - t2) + this.value.b * t2));
    }
  }
  class Subform extends XFAObject {
    constructor(e2) {
      super(Kn, "subform", true);
      this.access = getStringOption(e2.access, [
        "open",
        "nonInteractive",
        "protected",
        "readOnly"
      ]);
      this.allowMacro = getInteger({
        data: e2.allowMacro,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.anchorType = getStringOption(e2.anchorType, [
        "topLeft",
        "bottomCenter",
        "bottomLeft",
        "bottomRight",
        "middleCenter",
        "middleLeft",
        "middleRight",
        "topCenter",
        "topRight"
      ]);
      this.colSpan = getInteger({
        data: e2.colSpan,
        defaultValue: 1,
        validate: (e3) => e3 >= 1 || -1 === e3
      });
      this.columnWidths = (e2.columnWidths || "").trim().split(/\s+/).map((e3) => "-1" === e3 ? -1 : getMeasurement(e3));
      this.h = e2.h ? getMeasurement(e2.h) : "";
      this.hAlign = getStringOption(e2.hAlign, [
        "left",
        "center",
        "justify",
        "justifyAll",
        "radix",
        "right"
      ]);
      this.id = e2.id || "";
      this.layout = getStringOption(e2.layout, [
        "position",
        "lr-tb",
        "rl-row",
        "rl-tb",
        "row",
        "table",
        "tb"
      ]);
      this.locale = e2.locale || "";
      this.maxH = getMeasurement(e2.maxH, "0pt");
      this.maxW = getMeasurement(e2.maxW, "0pt");
      this.mergeMode = getStringOption(e2.mergeMode, [
        "consumeData",
        "matchTemplate"
      ]);
      this.minH = getMeasurement(e2.minH, "0pt");
      this.minW = getMeasurement(e2.minW, "0pt");
      this.name = e2.name || "";
      this.presence = getStringOption(e2.presence, [
        "visible",
        "hidden",
        "inactive",
        "invisible"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.restoreState = getStringOption(e2.restoreState, [
        "manual",
        "auto"
      ]);
      this.scope = getStringOption(e2.scope, [
        "name",
        "none"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.w = e2.w ? getMeasurement(e2.w) : "";
      this.x = getMeasurement(e2.x, "0pt");
      this.y = getMeasurement(e2.y, "0pt");
      this.assist = null;
      this.bind = null;
      this.bookend = null;
      this.border = null;
      this.break = null;
      this.calculate = null;
      this.desc = null;
      this.extras = null;
      this.keep = null;
      this.margin = null;
      this.occur = null;
      this.overflow = null;
      this.pageSet = null;
      this.para = null;
      this.traversal = null;
      this.validate = null;
      this.variables = null;
      this.area = new XFAObjectArray();
      this.breakAfter = new XFAObjectArray();
      this.breakBefore = new XFAObjectArray();
      this.connect = new XFAObjectArray();
      this.draw = new XFAObjectArray();
      this.event = new XFAObjectArray();
      this.exObject = new XFAObjectArray();
      this.exclGroup = new XFAObjectArray();
      this.field = new XFAObjectArray();
      this.proto = new XFAObjectArray();
      this.setProperty = new XFAObjectArray();
      this.subform = new XFAObjectArray();
      this.subformSet = new XFAObjectArray();
    }
    [ws]() {
      const e2 = this[bs]();
      return e2 instanceof SubformSet ? e2[ws]() : e2;
    }
    [xs]() {
      return true;
    }
    [Js]() {
      return this.layout.endsWith("-tb") && 0 === this[gs].attempt && this[gs].numberInLine > 0 || this[bs]()[Js]();
    }
    *[ms]() {
      yield* getContainedChildren(this);
    }
    [cs]() {
      return flushHTML(this);
    }
    [zr](e2, t2) {
      addHTML(this, e2, t2);
    }
    [ls]() {
      return getAvailableSpace(this);
    }
    [Hs]() {
      var _a4;
      const e2 = this[ws]();
      if (!e2[Hs]()) return false;
      if (void 0 !== this[gs]._isSplittable) return this[gs]._isSplittable;
      if ("position" === this.layout || this.layout.includes("row")) {
        this[gs]._isSplittable = false;
        return false;
      }
      if (this.keep && "none" !== this.keep.intact) {
        this[gs]._isSplittable = false;
        return false;
      }
      if (((_a4 = e2.layout) == null ? void 0 : _a4.endsWith("-tb")) && 0 !== e2[gs].numberInLine) return false;
      this[gs]._isSplittable = true;
      return true;
    }
    [gn](e2) {
      var _a4;
      setTabIndex(this);
      if (this.break) {
        if ("auto" !== this.break.after || "" !== this.break.afterTarget) {
          const e3 = new BreakAfter({
            targetType: this.break.after,
            target: this.break.afterTarget,
            startNew: this.break.startNew.toString()
          });
          e3[Fs] = this[Fs];
          this[$r](e3);
          this.breakAfter.push(e3);
        }
        if ("auto" !== this.break.before || "" !== this.break.beforeTarget) {
          const e3 = new BreakBefore({
            targetType: this.break.before,
            target: this.break.beforeTarget,
            startNew: this.break.startNew.toString()
          });
          e3[Fs] = this[Fs];
          this[$r](e3);
          this.breakBefore.push(e3);
        }
        if ("" !== this.break.overflowTarget) {
          const e3 = new Overflow({
            target: this.break.overflowTarget,
            leader: this.break.overflowLeader,
            trailer: this.break.overflowTrailer
          });
          e3[Fs] = this[Fs];
          this[$r](e3);
          this.overflow.push(e3);
        }
        this[zs](this.break);
        this.break = null;
      }
      if ("hidden" === this.presence || "inactive" === this.presence) return HTMLResult.EMPTY;
      (this.breakBefore.children.length > 1 || this.breakAfter.children.length > 1) && warn("XFA - Several breakBefore or breakAfter in subforms: please file a bug.");
      if (this.breakBefore.children.length >= 1) {
        const e3 = this.breakBefore.children[0];
        if (handleBreak(e3)) return HTMLResult.breakNode(e3);
      }
      if ((_a4 = this[gs]) == null ? void 0 : _a4.afterBreakAfter) return HTMLResult.EMPTY;
      fixDimensions(this);
      const t2 = [], i2 = {
        id: this[Cn],
        class: []
      };
      setAccess(this, i2.class);
      this[gs] || (this[gs] = /* @__PURE__ */ Object.create(null));
      Object.assign(this[gs], {
        children: t2,
        line: null,
        attributes: i2,
        attempt: 0,
        numberInLine: 0,
        availableSpace: {
          width: Math.min(this.w || 1 / 0, e2.width),
          height: Math.min(this.h || 1 / 0, e2.height)
        },
        width: 0,
        height: 0,
        prevHeight: 0,
        currentWidth: 0
      });
      const a2 = this[Ds](), r2 = a2[gs].noLayoutFailure, s2 = this[Hs]();
      s2 || setFirstUnsplittable(this);
      if (!checkDimensions(this, e2)) return HTMLResult.FAILURE;
      const n2 = /* @__PURE__ */ new Set([
        "area",
        "draw",
        "exclGroup",
        "field",
        "subform",
        "subformSet"
      ]);
      if (this.layout.includes("row")) {
        const e3 = this[ws]().columnWidths;
        if (Array.isArray(e3) && e3.length > 0) {
          this[gs].columnWidths = e3;
          this[gs].currentColumn = 0;
        }
      }
      const o2 = toStyle(this, "anchorType", "dimensions", "position", "presence", "border", "margin", "hAlign"), g2 = [
        "xfaSubform"
      ], c2 = layoutClass(this);
      c2 && g2.push(c2);
      i2.style = o2;
      i2.class = g2;
      this.name && (i2.xfaName = this.name);
      if (this.overflow) {
        const t3 = this.overflow[ds]();
        if (t3.addLeader) {
          t3.addLeader = false;
          handleOverflow(this, t3.leader, e2);
        }
      }
      this[_s]();
      const C2 = "lr-tb" === this.layout || "rl-tb" === this.layout, h2 = C2 ? 2 : 1;
      for (; this[gs].attempt < h2; this[gs].attempt++) {
        C2 && 1 === this[gs].attempt && (this[gs].numberInLine = 0);
        const e3 = this[As]({
          filter: n2,
          include: true
        });
        if (e3.success) break;
        if (e3.isBreak()) {
          this[Vs]();
          return e3;
        }
        if (C2 && 0 === this[gs].attempt && 0 === this[gs].numberInLine && !a2[gs].noLayoutFailure) {
          this[gs].attempt = h2;
          break;
        }
      }
      this[Vs]();
      s2 || unsetFirstUnsplittable(this);
      a2[gs].noLayoutFailure = r2;
      if (this[gs].attempt === h2) {
        this.overflow && (this[Ds]()[gs].overflowNode = this.overflow);
        s2 || delete this[gs];
        return HTMLResult.FAILURE;
      }
      if (this.overflow) {
        const t3 = this.overflow[ds]();
        if (t3.addTrailer) {
          t3.addTrailer = false;
          handleOverflow(this, t3.trailer, e2);
        }
      }
      let l2 = 0, Q2 = 0;
      if (this.margin) {
        l2 = this.margin.leftInset + this.margin.rightInset;
        Q2 = this.margin.topInset + this.margin.bottomInset;
      }
      const E2 = Math.max(this[gs].width + l2, this.w || 0), u2 = Math.max(this[gs].height + Q2, this.h || 0), d2 = [
        this.x,
        this.y,
        E2,
        u2
      ];
      "" === this.w && (o2.width = measureToString(E2));
      "" === this.h && (o2.height = measureToString(u2));
      if (("0px" === o2.width || "0px" === o2.height) && 0 === t2.length) return HTMLResult.EMPTY;
      const f2 = {
        name: "div",
        attributes: i2,
        children: t2
      };
      applyAssist(this, i2);
      const p2 = HTMLResult.success(createWrapper(this, f2), d2);
      if (this.breakAfter.children.length >= 1) {
        const e3 = this.breakAfter.children[0];
        if (handleBreak(e3)) {
          this[gs].afterBreakAfter = p2;
          return HTMLResult.breakNode(e3);
        }
      }
      delete this[gs];
      return p2;
    }
  }
  class SubformSet extends XFAObject {
    constructor(e2) {
      super(Kn, "subformSet", true);
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.relation = getStringOption(e2.relation, [
        "ordered",
        "choice",
        "unordered"
      ]);
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.bookend = null;
      this.break = null;
      this.desc = null;
      this.extras = null;
      this.occur = null;
      this.overflow = null;
      this.breakAfter = new XFAObjectArray();
      this.breakBefore = new XFAObjectArray();
      this.subform = new XFAObjectArray();
      this.subformSet = new XFAObjectArray();
    }
    *[ms]() {
      yield* getContainedChildren(this);
    }
    [ws]() {
      let e2 = this[bs]();
      for (; !(e2 instanceof Subform); ) e2 = e2[bs]();
      return e2;
    }
    [xs]() {
      return true;
    }
  }
  class SubjectDN extends ContentObject {
    constructor(e2) {
      super(Kn, "subjectDN");
      this.delimiter = e2.delimiter || ",";
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      this[ss] = new Map(this[ss].split(this.delimiter).map((e2) => {
        (e2 = e2.split("=", 2))[0] = e2[0].trim();
        return e2;
      }));
    }
  }
  class SubjectDNs extends XFAObject {
    constructor(e2) {
      super(Kn, "subjectDNs", true);
      this.id = e2.id || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.subjectDN = new XFAObjectArray();
    }
  }
  class Submit extends XFAObject {
    constructor(e2) {
      super(Kn, "submit", true);
      this.embedPDF = getInteger({
        data: e2.embedPDF,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.format = getStringOption(e2.format, [
        "xdp",
        "formdata",
        "pdf",
        "urlencoded",
        "xfd",
        "xml"
      ]);
      this.id = e2.id || "";
      this.target = e2.target || "";
      this.textEncoding = getKeyword({
        data: e2.textEncoding ? e2.textEncoding.toLowerCase() : "",
        defaultValue: "",
        validate: (e3) => [
          "utf-8",
          "big-five",
          "fontspecific",
          "gbk",
          "gb-18030",
          "gb-2312",
          "ksc-5601",
          "none",
          "shift-jis",
          "ucs-2",
          "utf-16"
        ].includes(e3) || e3.match(/iso-8859-\d{2}/)
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.xdpContent = e2.xdpContent || "";
      this.encrypt = null;
      this.encryptData = new XFAObjectArray();
      this.signData = new XFAObjectArray();
    }
  }
  class Template extends XFAObject {
    constructor(e2) {
      super(Kn, "template", true);
      this.baseProfile = getStringOption(e2.baseProfile, [
        "full",
        "interactiveForms"
      ]);
      this.extras = null;
      this.subform = new XFAObjectArray();
    }
    [Is]() {
      0 === this.subform.children.length && warn("XFA - No subforms in template node.");
      this.subform.children.length >= 2 && warn("XFA - Several subforms in template node: please file a bug.");
      this[sn] = 5e3;
    }
    [Hs]() {
      return true;
    }
    [en](e2, t2) {
      return e2.startsWith("#") ? [
        this[ks].get(e2.slice(1))
      ] : searchNode(this, t2, e2, true, true);
    }
    *[on]() {
      var _a4, _b, _c;
      if (!this.subform.children.length) return HTMLResult.success({
        name: "div",
        children: []
      });
      this[gs] = {
        overflowNode: null,
        firstUnsplittable: null,
        currentContentArea: null,
        currentPageArea: null,
        noLayoutFailure: false,
        pageNumber: 1,
        pagePosition: "first",
        oddOrEven: "odd",
        blankOrNotBlank: "nonBlank",
        paraStack: []
      };
      const e2 = this.subform.children[0];
      e2.pageSet[ts]();
      const t2 = e2.pageSet.pageArea.children, i2 = {
        name: "div",
        children: []
      };
      let a2 = null, r2 = null, s2 = null;
      if (e2.breakBefore.children.length >= 1) {
        r2 = e2.breakBefore.children[0];
        s2 = r2.target;
      } else if (e2.subform.children.length >= 1 && e2.subform.children[0].breakBefore.children.length >= 1) {
        r2 = e2.subform.children[0].breakBefore.children[0];
        s2 = r2.target;
      } else if ((_a4 = e2.break) == null ? void 0 : _a4.beforeTarget) {
        r2 = e2.break;
        s2 = r2.beforeTarget;
      } else if (e2.subform.children.length >= 1 && ((_b = e2.subform.children[0].break) == null ? void 0 : _b.beforeTarget)) {
        r2 = e2.subform.children[0].break;
        s2 = r2.beforeTarget;
      }
      if (r2) {
        const e3 = this[en](s2, r2[bs]());
        if (e3 instanceof PageArea) {
          a2 = e3;
          r2[gs] = {};
        }
      }
      a2 || (a2 = t2[0]);
      a2[gs] = {
        numberOfUse: 1
      };
      const n2 = a2[bs]();
      n2[gs] = {
        numberOfUse: 1,
        pageIndex: n2.pageArea.children.indexOf(a2),
        pageSetIndex: 0
      };
      let o2, g2 = null, c2 = null, C2 = true, h2 = 0, l2 = 0;
      for (; ; ) {
        if (C2) h2 = 0;
        else {
          i2.children.pop();
          if (3 == ++h2) {
            warn("XFA - Something goes wrong: please file a bug.");
            return i2;
          }
        }
        o2 = null;
        this[gs].currentPageArea = a2;
        const t3 = a2[gn]().html;
        i2.children.push(t3);
        if (g2) {
          this[gs].noLayoutFailure = true;
          t3.children.push(g2[gn](a2[gs].space).html);
          g2 = null;
        }
        if (c2) {
          this[gs].noLayoutFailure = true;
          t3.children.push(c2[gn](a2[gs].space).html);
          c2 = null;
        }
        const r3 = a2.contentArea.children, s3 = t3.children.filter((e3) => e3.attributes.class.includes("xfaContentarea"));
        C2 = false;
        this[gs].firstUnsplittable = null;
        this[gs].noLayoutFailure = false;
        const flush = (t4) => {
          var _a5;
          const i3 = e2[cs]();
          if (i3) {
            C2 || (C2 = ((_a5 = i3.children) == null ? void 0 : _a5.length) > 0);
            s3[t4].children.push(i3);
          }
        };
        for (let t4 = l2, a3 = r3.length; t4 < a3; t4++) {
          const a4 = this[gs].currentContentArea = r3[t4], n3 = {
            width: a4.w,
            height: a4.h
          };
          l2 = 0;
          if (g2) {
            s3[t4].children.push(g2[gn](n3).html);
            g2 = null;
          }
          if (c2) {
            s3[t4].children.push(c2[gn](n3).html);
            c2 = null;
          }
          const h3 = e2[gn](n3);
          if (h3.success) {
            if (h3.html) {
              C2 || (C2 = ((_c = h3.html.children) == null ? void 0 : _c.length) > 0);
              s3[t4].children.push(h3.html);
            } else !C2 && i2.children.length > 1 && i2.children.pop();
            return i2;
          }
          if (h3.isBreak()) {
            const e3 = h3.breakNode;
            flush(t4);
            if ("auto" === e3.targetType) continue;
            if (e3.leader) {
              g2 = this[en](e3.leader, e3[bs]());
              g2 = g2 ? g2[0] : null;
            }
            if (e3.trailer) {
              c2 = this[en](e3.trailer, e3[bs]());
              c2 = c2 ? c2[0] : null;
            }
            if ("pageArea" === e3.targetType) {
              o2 = e3[gs].target;
              t4 = 1 / 0;
            } else if (e3[gs].target) {
              o2 = e3[gs].target;
              l2 = e3[gs].index + 1;
              t4 = 1 / 0;
            } else t4 = e3[gs].index;
          } else if (this[gs].overflowNode) {
            const e3 = this[gs].overflowNode;
            this[gs].overflowNode = null;
            const i3 = e3[ds](), a5 = i3.target;
            i3.addLeader = null !== i3.leader;
            i3.addTrailer = null !== i3.trailer;
            flush(t4);
            const s4 = t4;
            t4 = 1 / 0;
            if (a5 instanceof PageArea) o2 = a5;
            else if (a5 instanceof ContentArea) {
              const e4 = r3.indexOf(a5);
              if (-1 !== e4) e4 > s4 ? t4 = e4 - 1 : l2 = e4;
              else {
                o2 = a5[bs]();
                l2 = o2.contentArea.children.indexOf(a5);
              }
            }
          } else flush(t4);
        }
        this[gs].pageNumber += 1;
        o2 && (o2[Ys]() ? o2[gs].numberOfUse += 1 : o2 = null);
        a2 = o2 || a2[ys]();
        yield null;
      }
    }
  }
  class Text extends ContentObject {
    constructor(e2) {
      super(Kn, "text");
      this.id = e2.id || "";
      this.maxChars = getInteger({
        data: e2.maxChars,
        defaultValue: 0,
        validate: (e3) => e3 >= 0
      });
      this.name = e2.name || "";
      this.rid = e2.rid || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [_r]() {
      return true;
    }
    [Ws](e2) {
      if (e2[Ks] === ln.xhtml.id) {
        this[ss] = e2;
        return true;
      }
      warn(`XFA - Invalid content in Text: ${e2[qs]}.`);
      return false;
    }
    [Xs](e2) {
      this[ss] instanceof XFAObject || super[Xs](e2);
    }
    [Is]() {
      "string" == typeof this[ss] && (this[ss] = this[ss].replaceAll("\r\n", "\n"));
    }
    [ds]() {
      return "string" == typeof this[ss] ? this[ss].split(/[\u2029\u2028\n]/).reduce((e2, t2) => {
        t2 && e2.push(t2);
        return e2;
      }, []).join("\n") : this[ss][nn]();
    }
    [gn](e2) {
      if ("string" == typeof this[ss]) {
        const e3 = valueToHtml(this[ss]).html;
        if (this[ss].includes("\u2029")) {
          e3.name = "div";
          e3.children = [];
          this[ss].split("\u2029").map((e4) => e4.split(/[\u2028\n]/).reduce((e5, t2) => {
            e5.push({
              name: "span",
              value: t2
            }, {
              name: "br"
            });
            return e5;
          }, [])).forEach((t2) => {
            e3.children.push({
              name: "p",
              children: t2
            });
          });
        } else if (/[\u2028\n]/.test(this[ss])) {
          e3.name = "div";
          e3.children = [];
          this[ss].split(/[\u2028\n]/).forEach((t2) => {
            e3.children.push({
              name: "span",
              value: t2
            }, {
              name: "br"
            });
          });
        }
        return HTMLResult.success(e3);
      }
      return this[ss][gn](e2);
    }
  }
  class TextEdit extends XFAObject {
    constructor(e2) {
      super(Kn, "textEdit", true);
      this.allowRichText = getInteger({
        data: e2.allowRichText,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.hScrollPolicy = getStringOption(e2.hScrollPolicy, [
        "auto",
        "off",
        "on"
      ]);
      this.id = e2.id || "";
      this.multiLine = getInteger({
        data: e2.multiLine,
        defaultValue: "",
        validate: (e3) => 0 === e3 || 1 === e3
      });
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.vScrollPolicy = getStringOption(e2.vScrollPolicy, [
        "auto",
        "off",
        "on"
      ]);
      this.border = null;
      this.comb = null;
      this.extras = null;
      this.margin = null;
    }
    [gn](e2) {
      var _a4, _b;
      const t2 = toStyle(this, "border", "font", "margin");
      let i2;
      const a2 = this[bs]()[bs]();
      "" === this.multiLine && (this.multiLine = a2 instanceof Draw ? 1 : 0);
      i2 = 1 === this.multiLine ? {
        name: "textarea",
        attributes: {
          dataId: ((_a4 = a2[ns]) == null ? void 0 : _a4[Cn]) || a2[Cn],
          fieldId: a2[Cn],
          class: [
            "xfaTextfield"
          ],
          style: t2,
          "aria-label": ariaLabel(a2),
          "aria-required": false
        }
      } : {
        name: "input",
        attributes: {
          type: "text",
          dataId: ((_b = a2[ns]) == null ? void 0 : _b[Cn]) || a2[Cn],
          fieldId: a2[Cn],
          class: [
            "xfaTextfield"
          ],
          style: t2,
          "aria-label": ariaLabel(a2),
          "aria-required": false
        }
      };
      if (isRequired(a2)) {
        i2.attributes["aria-required"] = true;
        i2.attributes.required = true;
      }
      return HTMLResult.success({
        name: "label",
        attributes: {
          class: [
            "xfaLabel"
          ]
        },
        children: [
          i2
        ]
      });
    }
  }
  class Time extends StringObject {
    constructor(e2) {
      super(Kn, "time");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
    [Is]() {
      const e2 = this[ss].trim();
      this[ss] = e2 ? new Date(e2) : null;
    }
    [gn](e2) {
      return valueToHtml(this[ss] ? this[ss].toString() : "");
    }
  }
  class TimeStamp extends XFAObject {
    constructor(e2) {
      super(Kn, "timeStamp");
      this.id = e2.id || "";
      this.server = e2.server || "";
      this.type = getStringOption(e2.type, [
        "optional",
        "required"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class ToolTip extends StringObject {
    constructor(e2) {
      super(Kn, "toolTip");
      this.id = e2.id || "";
      this.rid = e2.rid || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Traversal extends XFAObject {
    constructor(e2) {
      super(Kn, "traversal", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.traverse = new XFAObjectArray();
    }
  }
  class Traverse extends XFAObject {
    constructor(e2) {
      super(Kn, "traverse", true);
      this.id = e2.id || "";
      this.operation = getStringOption(e2.operation, [
        "next",
        "back",
        "down",
        "first",
        "left",
        "right",
        "up"
      ]);
      this.ref = e2.ref || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.script = null;
    }
    get name() {
      return this.operation;
    }
    [vs]() {
      return false;
    }
  }
  class Ui extends XFAObject {
    constructor(e2) {
      super(Kn, "ui", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.picture = null;
      this.barcode = null;
      this.button = null;
      this.checkButton = null;
      this.choiceList = null;
      this.dateTimeEdit = null;
      this.defaultUi = null;
      this.imageEdit = null;
      this.numericEdit = null;
      this.passwordEdit = null;
      this.signature = null;
      this.textEdit = null;
    }
    [ds]() {
      if (void 0 === this[gs]) {
        for (const e2 of Object.getOwnPropertyNames(this)) {
          if ("extras" === e2 || "picture" === e2) continue;
          const t2 = this[e2];
          if (t2 instanceof XFAObject) {
            this[gs] = t2;
            return t2;
          }
        }
        this[gs] = null;
      }
      return this[gs];
    }
    [gn](e2) {
      const t2 = this[ds]();
      return t2 ? t2[gn](e2) : HTMLResult.EMPTY;
    }
  }
  class Validate extends XFAObject {
    constructor(e2) {
      super(Kn, "validate", true);
      this.formatTest = getStringOption(e2.formatTest, [
        "warning",
        "disabled",
        "error"
      ]);
      this.id = e2.id || "";
      this.nullTest = getStringOption(e2.nullTest, [
        "disabled",
        "error",
        "warning"
      ]);
      this.scriptTest = getStringOption(e2.scriptTest, [
        "error",
        "disabled",
        "warning"
      ]);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.extras = null;
      this.message = null;
      this.picture = null;
      this.script = null;
    }
  }
  class Value extends XFAObject {
    constructor(e2) {
      super(Kn, "value", true);
      this.id = e2.id || "";
      this.override = getInteger({
        data: e2.override,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.relevant = getRelevant(e2.relevant);
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.arc = null;
      this.boolean = null;
      this.date = null;
      this.dateTime = null;
      this.decimal = null;
      this.exData = null;
      this.float = null;
      this.image = null;
      this.integer = null;
      this.line = null;
      this.rectangle = null;
      this.text = null;
      this.time = null;
    }
    [rn](e2) {
      var _a4;
      const t2 = this[bs]();
      if (t2 instanceof Field && ((_a4 = t2.ui) == null ? void 0 : _a4.imageEdit)) {
        if (!this.image) {
          this.image = new Image({});
          this[$r](this.image);
        }
        this.image[ss] = e2[ss];
        return;
      }
      const i2 = e2[qs];
      if (null === this[i2]) {
        for (const e3 of Object.getOwnPropertyNames(this)) {
          const t3 = this[e3];
          if (t3 instanceof XFAObject) {
            this[e3] = null;
            this[zs](t3);
          }
        }
        this[e2[qs]] = e2;
        this[$r](e2);
      } else this[i2][ss] = e2[ss];
    }
    [nn]() {
      if (this.exData) return "string" == typeof this.exData[ss] ? this.exData[ss].trim() : this.exData[ss][nn]().trim();
      for (const e2 of Object.getOwnPropertyNames(this)) {
        if ("image" === e2) continue;
        const t2 = this[e2];
        if (t2 instanceof XFAObject) return (t2[ss] || "").toString().trim();
      }
      return null;
    }
    [gn](e2) {
      for (const t2 of Object.getOwnPropertyNames(this)) {
        const i2 = this[t2];
        if (i2 instanceof XFAObject) return i2[gn](e2);
      }
      return HTMLResult.EMPTY;
    }
  }
  class Variables extends XFAObject {
    constructor(e2) {
      super(Kn, "variables", true);
      this.id = e2.id || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
      this.boolean = new XFAObjectArray();
      this.date = new XFAObjectArray();
      this.dateTime = new XFAObjectArray();
      this.decimal = new XFAObjectArray();
      this.exData = new XFAObjectArray();
      this.float = new XFAObjectArray();
      this.image = new XFAObjectArray();
      this.integer = new XFAObjectArray();
      this.manifest = new XFAObjectArray();
      this.script = new XFAObjectArray();
      this.text = new XFAObjectArray();
      this.time = new XFAObjectArray();
    }
    [vs]() {
      return true;
    }
  }
  class TemplateNamespace {
    static [hn](e2, t2) {
      if (TemplateNamespace.hasOwnProperty(e2)) {
        const i2 = TemplateNamespace[e2](t2);
        i2[an](t2);
        return i2;
      }
    }
    static appearanceFilter(e2) {
      return new AppearanceFilter(e2);
    }
    static arc(e2) {
      return new Arc(e2);
    }
    static area(e2) {
      return new Area(e2);
    }
    static assist(e2) {
      return new Assist(e2);
    }
    static barcode(e2) {
      return new Barcode(e2);
    }
    static bind(e2) {
      return new Bind(e2);
    }
    static bindItems(e2) {
      return new BindItems(e2);
    }
    static bookend(e2) {
      return new Bookend(e2);
    }
    static boolean(e2) {
      return new BooleanElement(e2);
    }
    static border(e2) {
      return new Border(e2);
    }
    static break(e2) {
      return new Break(e2);
    }
    static breakAfter(e2) {
      return new BreakAfter(e2);
    }
    static breakBefore(e2) {
      return new BreakBefore(e2);
    }
    static button(e2) {
      return new Button(e2);
    }
    static calculate(e2) {
      return new Calculate(e2);
    }
    static caption(e2) {
      return new Caption(e2);
    }
    static certificate(e2) {
      return new Certificate(e2);
    }
    static certificates(e2) {
      return new Certificates(e2);
    }
    static checkButton(e2) {
      return new CheckButton(e2);
    }
    static choiceList(e2) {
      return new ChoiceList(e2);
    }
    static color(e2) {
      return new Color(e2);
    }
    static comb(e2) {
      return new Comb(e2);
    }
    static connect(e2) {
      return new Connect(e2);
    }
    static contentArea(e2) {
      return new ContentArea(e2);
    }
    static corner(e2) {
      return new Corner(e2);
    }
    static date(e2) {
      return new DateElement(e2);
    }
    static dateTime(e2) {
      return new DateTime(e2);
    }
    static dateTimeEdit(e2) {
      return new DateTimeEdit(e2);
    }
    static decimal(e2) {
      return new Decimal(e2);
    }
    static defaultUi(e2) {
      return new DefaultUi(e2);
    }
    static desc(e2) {
      return new Desc(e2);
    }
    static digestMethod(e2) {
      return new DigestMethod(e2);
    }
    static digestMethods(e2) {
      return new DigestMethods(e2);
    }
    static draw(e2) {
      return new Draw(e2);
    }
    static edge(e2) {
      return new Edge(e2);
    }
    static encoding(e2) {
      return new Encoding(e2);
    }
    static encodings(e2) {
      return new Encodings(e2);
    }
    static encrypt(e2) {
      return new Encrypt(e2);
    }
    static encryptData(e2) {
      return new EncryptData(e2);
    }
    static encryption(e2) {
      return new Encryption(e2);
    }
    static encryptionMethod(e2) {
      return new EncryptionMethod(e2);
    }
    static encryptionMethods(e2) {
      return new EncryptionMethods(e2);
    }
    static event(e2) {
      return new Event(e2);
    }
    static exData(e2) {
      return new ExData(e2);
    }
    static exObject(e2) {
      return new ExObject(e2);
    }
    static exclGroup(e2) {
      return new ExclGroup(e2);
    }
    static execute(e2) {
      return new Execute(e2);
    }
    static extras(e2) {
      return new Extras(e2);
    }
    static field(e2) {
      return new Field(e2);
    }
    static fill(e2) {
      return new Fill(e2);
    }
    static filter(e2) {
      return new Filter(e2);
    }
    static float(e2) {
      return new Float(e2);
    }
    static font(e2) {
      return new template_Font(e2);
    }
    static format(e2) {
      return new Format(e2);
    }
    static handler(e2) {
      return new Handler(e2);
    }
    static hyphenation(e2) {
      return new Hyphenation(e2);
    }
    static image(e2) {
      return new Image(e2);
    }
    static imageEdit(e2) {
      return new ImageEdit(e2);
    }
    static integer(e2) {
      return new Integer(e2);
    }
    static issuers(e2) {
      return new Issuers(e2);
    }
    static items(e2) {
      return new Items(e2);
    }
    static keep(e2) {
      return new Keep(e2);
    }
    static keyUsage(e2) {
      return new KeyUsage(e2);
    }
    static line(e2) {
      return new Line(e2);
    }
    static linear(e2) {
      return new Linear(e2);
    }
    static lockDocument(e2) {
      return new LockDocument(e2);
    }
    static manifest(e2) {
      return new Manifest(e2);
    }
    static margin(e2) {
      return new Margin(e2);
    }
    static mdp(e2) {
      return new Mdp(e2);
    }
    static medium(e2) {
      return new Medium(e2);
    }
    static message(e2) {
      return new Message(e2);
    }
    static numericEdit(e2) {
      return new NumericEdit(e2);
    }
    static occur(e2) {
      return new Occur(e2);
    }
    static oid(e2) {
      return new Oid(e2);
    }
    static oids(e2) {
      return new Oids(e2);
    }
    static overflow(e2) {
      return new Overflow(e2);
    }
    static pageArea(e2) {
      return new PageArea(e2);
    }
    static pageSet(e2) {
      return new PageSet(e2);
    }
    static para(e2) {
      return new Para(e2);
    }
    static passwordEdit(e2) {
      return new PasswordEdit(e2);
    }
    static pattern(e2) {
      return new template_Pattern(e2);
    }
    static picture(e2) {
      return new Picture(e2);
    }
    static proto(e2) {
      return new Proto(e2);
    }
    static radial(e2) {
      return new Radial(e2);
    }
    static reason(e2) {
      return new Reason(e2);
    }
    static reasons(e2) {
      return new Reasons(e2);
    }
    static rectangle(e2) {
      return new Rectangle(e2);
    }
    static ref(e2) {
      return new RefElement(e2);
    }
    static script(e2) {
      return new Script(e2);
    }
    static setProperty(e2) {
      return new SetProperty(e2);
    }
    static signData(e2) {
      return new SignData(e2);
    }
    static signature(e2) {
      return new Signature(e2);
    }
    static signing(e2) {
      return new Signing(e2);
    }
    static solid(e2) {
      return new Solid(e2);
    }
    static speak(e2) {
      return new Speak(e2);
    }
    static stipple(e2) {
      return new Stipple(e2);
    }
    static subform(e2) {
      return new Subform(e2);
    }
    static subformSet(e2) {
      return new SubformSet(e2);
    }
    static subjectDN(e2) {
      return new SubjectDN(e2);
    }
    static subjectDNs(e2) {
      return new SubjectDNs(e2);
    }
    static submit(e2) {
      return new Submit(e2);
    }
    static template(e2) {
      return new Template(e2);
    }
    static text(e2) {
      return new Text(e2);
    }
    static textEdit(e2) {
      return new TextEdit(e2);
    }
    static time(e2) {
      return new Time(e2);
    }
    static timeStamp(e2) {
      return new TimeStamp(e2);
    }
    static toolTip(e2) {
      return new ToolTip(e2);
    }
    static traversal(e2) {
      return new Traversal(e2);
    }
    static traverse(e2) {
      return new Traverse(e2);
    }
    static ui(e2) {
      return new Ui(e2);
    }
    static validate(e2) {
      return new Validate(e2);
    }
    static value(e2) {
      return new Value(e2);
    }
    static variables(e2) {
      return new Variables(e2);
    }
  }
  const jn = ln.datasets.id;
  function createText(e2) {
    const t2 = new Text({});
    t2[ss] = e2;
    return t2;
  }
  class Binder {
    constructor(e2) {
      var _a4;
      this.root = e2;
      this.datasets = e2.datasets;
      this.data = ((_a4 = e2.datasets) == null ? void 0 : _a4.data) || new XmlObject(ln.datasets.id, "data");
      this.emptyMerge = 0 === this.data[ps]().length;
      this.root.form = this.form = e2.template[as]();
    }
    _isConsumeData() {
      return !this.emptyMerge && this._mergeMode;
    }
    _isMatchTemplate() {
      return !this._isConsumeData();
    }
    bind() {
      this._bindElement(this.form, this.data);
      return this.form;
    }
    getData() {
      return this.data;
    }
    _bindValue(e2, t2, i2) {
      var _a4, _b;
      e2[ns] = t2;
      if (e2[Ss]()) if (t2[Us]()) {
        const i3 = t2[us]();
        e2[rn](createText(i3));
      } else if (e2 instanceof Field && "multiSelect" === ((_b = (_a4 = e2.ui) == null ? void 0 : _a4.choiceList) == null ? void 0 : _b.open)) {
        const i3 = t2[ps]().map((e3) => e3[ss].trim()).join("\n");
        e2[rn](createText(i3));
      } else this._isConsumeData() && warn("XFA - Nodes haven't the same type.");
      else !t2[Us]() || this._isMatchTemplate() ? this._bindElement(e2, t2) : warn("XFA - Nodes haven't the same type.");
    }
    _findDataByNameToConsume(e2, t2, i2, a2) {
      if (!e2) return null;
      let r2, s2;
      for (let a3 = 0; a3 < 3; a3++) {
        r2 = i2[fs](e2, false, true);
        for (; ; ) {
          s2 = r2.next().value;
          if (!s2) break;
          if (t2 === s2[Us]()) return s2;
        }
        if (i2[Ks] === ln.datasets.id && "data" === i2[qs]) break;
        i2 = i2[bs]();
      }
      if (!a2) return null;
      r2 = this.data[fs](e2, true, false);
      s2 = r2.next().value;
      if (s2) return s2;
      r2 = this.data[Cs](e2, true);
      s2 = r2.next().value;
      return (s2 == null ? void 0 : s2[Us]()) ? s2 : null;
    }
    _setProperties(e2, t2) {
      if (e2.hasOwnProperty("setProperty")) for (const { ref: i2, target: a2, connection: r2 } of e2.setProperty.children) {
        if (r2) continue;
        if (!i2) continue;
        const s2 = searchNode(this.root, t2, i2, false, false);
        if (!s2) {
          warn(`XFA - Invalid reference: ${i2}.`);
          continue;
        }
        const [n2] = s2;
        if (!n2[Ms](this.data)) {
          warn("XFA - Invalid node: must be a data node.");
          continue;
        }
        const o2 = searchNode(this.root, e2, a2, false, false);
        if (!o2) {
          warn(`XFA - Invalid target: ${a2}.`);
          continue;
        }
        const [g2] = o2;
        if (!g2[Ms](e2)) {
          warn("XFA - Invalid target: must be a property or subproperty.");
          continue;
        }
        const c2 = g2[bs]();
        if (g2 instanceof SetProperty || c2 instanceof SetProperty) {
          warn("XFA - Invalid target: cannot be a setProperty or one of its properties.");
          continue;
        }
        if (g2 instanceof BindItems || c2 instanceof BindItems) {
          warn("XFA - Invalid target: cannot be a bindItems or one of its properties.");
          continue;
        }
        const C2 = n2[nn](), h2 = g2[qs];
        if (g2 instanceof XFAAttribute) {
          const e3 = /* @__PURE__ */ Object.create(null);
          e3[h2] = C2;
          const t3 = Reflect.construct(Object.getPrototypeOf(c2).constructor, [
            e3
          ]);
          c2[h2] = t3[h2];
        } else if (g2.hasOwnProperty(ss)) {
          g2[ns] = n2;
          g2[ss] = C2;
          g2[Is]();
        } else warn("XFA - Invalid node to use in setProperty");
      }
    }
    _bindItems(e2, t2) {
      if (!e2.hasOwnProperty("items") || !e2.hasOwnProperty("bindItems") || e2.bindItems.isEmpty()) return;
      for (const t3 of e2.items.children) e2[zs](t3);
      e2.items.clear();
      const i2 = new Items({}), a2 = new Items({});
      e2[$r](i2);
      e2.items.push(i2);
      e2[$r](a2);
      e2.items.push(a2);
      for (const { ref: r2, labelRef: s2, valueRef: n2, connection: o2 } of e2.bindItems.children) {
        if (o2) continue;
        if (!r2) continue;
        const e3 = searchNode(this.root, t2, r2, false, false);
        if (e3) for (const t3 of e3) {
          if (!t3[Ms](this.datasets)) {
            warn(`XFA - Invalid ref (${r2}): must be a datasets child.`);
            continue;
          }
          const e4 = searchNode(this.root, t3, s2, true, false);
          if (!e4) {
            warn(`XFA - Invalid label: ${s2}.`);
            continue;
          }
          const [o3] = e4;
          if (!o3[Ms](this.datasets)) {
            warn("XFA - Invalid label: must be a datasets child.");
            continue;
          }
          const g2 = searchNode(this.root, t3, n2, true, false);
          if (!g2) {
            warn(`XFA - Invalid value: ${n2}.`);
            continue;
          }
          const [c2] = g2;
          if (!c2[Ms](this.datasets)) {
            warn("XFA - Invalid value: must be a datasets child.");
            continue;
          }
          const C2 = createText(o3[nn]()), h2 = createText(c2[nn]());
          i2[$r](C2);
          i2.text.push(C2);
          a2[$r](h2);
          a2.text.push(h2);
        }
        else warn(`XFA - Invalid reference: ${r2}.`);
      }
    }
    _bindOccurrences(e2, t2, i2) {
      let a2;
      if (t2.length > 1) {
        a2 = e2[as]();
        a2[zs](a2.occur);
        a2.occur = null;
      }
      this._bindValue(e2, t2[0], i2);
      this._setProperties(e2, t2[0]);
      this._bindItems(e2, t2[0]);
      if (1 === t2.length) return;
      const r2 = e2[bs](), s2 = e2[qs], n2 = r2[Rs](e2);
      for (let e3 = 1, o2 = t2.length; e3 < o2; e3++) {
        const o3 = t2[e3], g2 = a2[as]();
        r2[s2].push(g2);
        r2[Ns](n2 + e3, g2);
        this._bindValue(g2, o3, i2);
        this._setProperties(g2, o3);
        this._bindItems(g2, o3);
      }
    }
    _createOccurrences(e2) {
      if (!this.emptyMerge) return;
      const { occur: t2 } = e2;
      if (!t2 || t2.initial <= 1) return;
      const i2 = e2[bs](), a2 = e2[qs];
      if (!(i2[a2] instanceof XFAObjectArray)) return;
      let r2;
      r2 = e2.name ? i2[a2].children.filter((t3) => t3.name === e2.name).length : i2[a2].children.length;
      const s2 = i2[Rs](e2) + 1, n2 = t2.initial - r2;
      if (n2) {
        const t3 = e2[as]();
        t3[zs](t3.occur);
        t3.occur = null;
        i2[a2].push(t3);
        i2[Ns](s2, t3);
        for (let e3 = 1; e3 < n2; e3++) {
          const r3 = t3[as]();
          i2[a2].push(r3);
          i2[Ns](s2 + e3, r3);
        }
      }
    }
    _getOccurInfo(e2) {
      const { name: t2, occur: i2 } = e2;
      if (!i2 || !t2) return [
        1,
        1
      ];
      const a2 = -1 === i2.max ? 1 / 0 : i2.max;
      return [
        i2.min,
        a2
      ];
    }
    _setAndBind(e2, t2) {
      this._setProperties(e2, t2);
      this._bindItems(e2, t2);
      this._bindElement(e2, t2);
    }
    _bindElement(e2, t2) {
      const i2 = [];
      this._createOccurrences(e2);
      for (const a2 of e2[ps]()) {
        if (a2[ns]) continue;
        if (void 0 === this._mergeMode && "subform" === a2[qs]) {
          this._mergeMode = "consumeData" === a2.mergeMode;
          const e4 = t2[ps]();
          if (e4.length > 0) this._bindOccurrences(a2, [
            e4[0]
          ], null);
          else if (this.emptyMerge) {
            const e5 = t2[Ks] === jn ? -1 : t2[Ks], i3 = a2[ns] = new XmlObject(e5, a2.name || "root");
            t2[$r](i3);
            this._bindElement(a2, i3);
          }
          continue;
        }
        if (!a2[xs]()) continue;
        let e3 = false, r2 = null, s2 = null, n2 = null;
        if (a2.bind) {
          switch (a2.bind.match) {
            case "none":
              this._setAndBind(a2, t2);
              continue;
            case "global":
              e3 = true;
              break;
            case "dataRef":
              if (!a2.bind.ref) {
                warn(`XFA - ref is empty in node ${a2[qs]}.`);
                this._setAndBind(a2, t2);
                continue;
              }
              s2 = a2.bind.ref;
          }
          a2.bind.picture && (r2 = a2.bind.picture[ss]);
        }
        const [o2, g2] = this._getOccurInfo(a2);
        if (s2) {
          n2 = searchNode(this.root, t2, s2, true, false);
          if (null === n2) {
            n2 = createDataNode(this.data, t2, s2);
            if (!n2) continue;
            this._isConsumeData() && (n2[rs] = true);
            this._setAndBind(a2, n2);
            continue;
          }
          this._isConsumeData() && (n2 = n2.filter((e4) => !e4[rs]));
          n2.length > g2 ? n2 = n2.slice(0, g2) : 0 === n2.length && (n2 = null);
          n2 && this._isConsumeData() && n2.forEach((e4) => {
            e4[rs] = true;
          });
        } else {
          if (!a2.name) {
            this._setAndBind(a2, t2);
            continue;
          }
          if (this._isConsumeData()) {
            const i3 = [];
            for (; i3.length < g2; ) {
              const r3 = this._findDataByNameToConsume(a2.name, a2[Ss](), t2, e3);
              if (!r3) break;
              r3[rs] = true;
              i3.push(r3);
            }
            n2 = i3.length > 0 ? i3 : null;
          } else {
            n2 = t2[fs](a2.name, false, this.emptyMerge).next().value;
            if (!n2) {
              if (0 === o2) {
                i2.push(a2);
                continue;
              }
              const e4 = t2[Ks] === jn ? -1 : t2[Ks];
              n2 = a2[ns] = new XmlObject(e4, a2.name);
              this.emptyMerge && (n2[rs] = true);
              t2[$r](n2);
              this._setAndBind(a2, n2);
              continue;
            }
            this.emptyMerge && (n2[rs] = true);
            n2 = [
              n2
            ];
          }
        }
        n2 ? this._bindOccurrences(a2, n2, r2) : o2 > 0 ? this._setAndBind(a2, t2) : i2.push(a2);
      }
      i2.forEach((e3) => e3[bs]()[zs](e3));
    }
  }
  class DataHandler {
    constructor(e2, t2) {
      this.data = t2;
      this.dataset = e2.datasets || null;
    }
    serialize(e2) {
      const t2 = [
        [
          -1,
          this.data[ps]()
        ]
      ];
      for (; t2.length > 0; ) {
        const i3 = t2.at(-1), [a2, r2] = i3;
        if (a2 + 1 === r2.length) {
          t2.pop();
          continue;
        }
        const s2 = r2[++i3[0]], n2 = e2.get(s2[Cn]);
        if (n2) s2[rn](n2);
        else {
          const t3 = s2[hs]();
          for (const i4 of t3.values()) {
            const t4 = e2.get(i4[Cn]);
            if (t4) {
              i4[rn](t4);
              break;
            }
          }
        }
        const o2 = s2[ps]();
        o2.length > 0 && t2.push([
          -1,
          o2
        ]);
      }
      const i2 = [
        '<xfa:datasets xmlns:xfa="http://www.xfa.org/schema/xfa-data/1.0/">'
      ];
      if (this.dataset) for (const e3 of this.dataset[ps]()) "data" !== e3[qs] && e3[In](i2);
      this.data[In](i2);
      i2.push("</xfa:datasets>");
      return i2.join("");
    }
  }
  const Xn = ln.config.id;
  class Acrobat extends XFAObject {
    constructor(e2) {
      super(Xn, "acrobat", true);
      this.acrobat7 = null;
      this.autoSave = null;
      this.common = null;
      this.validate = null;
      this.validateApprovalSignatures = null;
      this.submitUrl = new XFAObjectArray();
    }
  }
  class Acrobat7 extends XFAObject {
    constructor(e2) {
      super(Xn, "acrobat7", true);
      this.dynamicRender = null;
    }
  }
  class ADBE_JSConsole extends OptionObject {
    constructor(e2) {
      super(Xn, "ADBE_JSConsole", [
        "delegate",
        "Enable",
        "Disable"
      ]);
    }
  }
  class ADBE_JSDebugger extends OptionObject {
    constructor(e2) {
      super(Xn, "ADBE_JSDebugger", [
        "delegate",
        "Enable",
        "Disable"
      ]);
    }
  }
  class AddSilentPrint extends Option01 {
    constructor(e2) {
      super(Xn, "addSilentPrint");
    }
  }
  class AddViewerPreferences extends Option01 {
    constructor(e2) {
      super(Xn, "addViewerPreferences");
    }
  }
  class AdjustData extends Option10 {
    constructor(e2) {
      super(Xn, "adjustData");
    }
  }
  class AdobeExtensionLevel extends IntegerObject {
    constructor(e2) {
      super(Xn, "adobeExtensionLevel", 0, (e3) => e3 >= 1 && e3 <= 8);
    }
  }
  class Agent extends XFAObject {
    constructor(e2) {
      super(Xn, "agent", true);
      this.name = e2.name ? e2.name.trim() : "";
      this.common = new XFAObjectArray();
    }
  }
  class AlwaysEmbed extends ContentObject {
    constructor(e2) {
      super(Xn, "alwaysEmbed");
    }
  }
  class Amd extends StringObject {
    constructor(e2) {
      super(Xn, "amd");
    }
  }
  class config_Area extends XFAObject {
    constructor(e2) {
      super(Xn, "area");
      this.level = getInteger({
        data: e2.level,
        defaultValue: 0,
        validate: (e3) => e3 >= 1 && e3 <= 3
      });
      this.name = getStringOption(e2.name, [
        "",
        "barcode",
        "coreinit",
        "deviceDriver",
        "font",
        "general",
        "layout",
        "merge",
        "script",
        "signature",
        "sourceSet",
        "templateCache"
      ]);
    }
  }
  class Attributes extends OptionObject {
    constructor(e2) {
      super(Xn, "attributes", [
        "preserve",
        "delegate",
        "ignore"
      ]);
    }
  }
  class AutoSave extends OptionObject {
    constructor(e2) {
      super(Xn, "autoSave", [
        "disabled",
        "enabled"
      ]);
    }
  }
  class Base extends StringObject {
    constructor(e2) {
      super(Xn, "base");
    }
  }
  class BatchOutput extends XFAObject {
    constructor(e2) {
      super(Xn, "batchOutput");
      this.format = getStringOption(e2.format, [
        "none",
        "concat",
        "zip",
        "zipCompress"
      ]);
    }
  }
  class BehaviorOverride extends ContentObject {
    constructor(e2) {
      super(Xn, "behaviorOverride");
    }
    [Is]() {
      this[ss] = new Map(this[ss].trim().split(/\s+/).filter((e2) => e2.includes(":")).map((e2) => e2.split(":", 2)));
    }
  }
  class Cache extends XFAObject {
    constructor(e2) {
      super(Xn, "cache", true);
      this.templateCache = null;
    }
  }
  class Change extends Option01 {
    constructor(e2) {
      super(Xn, "change");
    }
  }
  class Common extends XFAObject {
    constructor(e2) {
      super(Xn, "common", true);
      this.data = null;
      this.locale = null;
      this.localeSet = null;
      this.messaging = null;
      this.suppressBanner = null;
      this.template = null;
      this.validationMessaging = null;
      this.versionControl = null;
      this.log = new XFAObjectArray();
    }
  }
  class Compress extends XFAObject {
    constructor(e2) {
      super(Xn, "compress");
      this.scope = getStringOption(e2.scope, [
        "imageOnly",
        "document"
      ]);
    }
  }
  class CompressLogicalStructure extends Option01 {
    constructor(e2) {
      super(Xn, "compressLogicalStructure");
    }
  }
  class CompressObjectStream extends Option10 {
    constructor(e2) {
      super(Xn, "compressObjectStream");
    }
  }
  class Compression extends XFAObject {
    constructor(e2) {
      super(Xn, "compression", true);
      this.compressLogicalStructure = null;
      this.compressObjectStream = null;
      this.level = null;
      this.type = null;
    }
  }
  class Config extends XFAObject {
    constructor(e2) {
      super(Xn, "config", true);
      this.acrobat = null;
      this.present = null;
      this.trace = null;
      this.agent = new XFAObjectArray();
    }
  }
  class Conformance extends OptionObject {
    constructor(e2) {
      super(Xn, "conformance", [
        "A",
        "B"
      ]);
    }
  }
  class ContentCopy extends Option01 {
    constructor(e2) {
      super(Xn, "contentCopy");
    }
  }
  class Copies extends IntegerObject {
    constructor(e2) {
      super(Xn, "copies", 1, (e3) => e3 >= 1);
    }
  }
  class Creator extends StringObject {
    constructor(e2) {
      super(Xn, "creator");
    }
  }
  class CurrentPage extends IntegerObject {
    constructor(e2) {
      super(Xn, "currentPage", 0, (e3) => e3 >= 0);
    }
  }
  class Data extends XFAObject {
    constructor(e2) {
      super(Xn, "data", true);
      this.adjustData = null;
      this.attributes = null;
      this.incrementalLoad = null;
      this.outputXSL = null;
      this.range = null;
      this.record = null;
      this.startNode = null;
      this.uri = null;
      this.window = null;
      this.xsl = null;
      this.excludeNS = new XFAObjectArray();
      this.transform = new XFAObjectArray();
    }
  }
  class Debug extends XFAObject {
    constructor(e2) {
      super(Xn, "debug", true);
      this.uri = null;
    }
  }
  class DefaultTypeface extends ContentObject {
    constructor(e2) {
      super(Xn, "defaultTypeface");
      this.writingScript = getStringOption(e2.writingScript, [
        "*",
        "Arabic",
        "Cyrillic",
        "EastEuropeanRoman",
        "Greek",
        "Hebrew",
        "Japanese",
        "Korean",
        "Roman",
        "SimplifiedChinese",
        "Thai",
        "TraditionalChinese",
        "Vietnamese"
      ]);
    }
  }
  class Destination extends OptionObject {
    constructor(e2) {
      super(Xn, "destination", [
        "pdf",
        "pcl",
        "ps",
        "webClient",
        "zpl"
      ]);
    }
  }
  class DocumentAssembly extends Option01 {
    constructor(e2) {
      super(Xn, "documentAssembly");
    }
  }
  class Driver extends XFAObject {
    constructor(e2) {
      super(Xn, "driver", true);
      this.name = e2.name ? e2.name.trim() : "";
      this.fontInfo = null;
      this.xdc = null;
    }
  }
  class DuplexOption extends OptionObject {
    constructor(e2) {
      super(Xn, "duplexOption", [
        "simplex",
        "duplexFlipLongEdge",
        "duplexFlipShortEdge"
      ]);
    }
  }
  class DynamicRender extends OptionObject {
    constructor(e2) {
      super(Xn, "dynamicRender", [
        "forbidden",
        "required"
      ]);
    }
  }
  class Embed extends Option01 {
    constructor(e2) {
      super(Xn, "embed");
    }
  }
  class config_Encrypt extends Option01 {
    constructor(e2) {
      super(Xn, "encrypt");
    }
  }
  class config_Encryption extends XFAObject {
    constructor(e2) {
      super(Xn, "encryption", true);
      this.encrypt = null;
      this.encryptionLevel = null;
      this.permissions = null;
    }
  }
  class EncryptionLevel extends OptionObject {
    constructor(e2) {
      super(Xn, "encryptionLevel", [
        "40bit",
        "128bit"
      ]);
    }
  }
  class Enforce extends StringObject {
    constructor(e2) {
      super(Xn, "enforce");
    }
  }
  class Equate extends XFAObject {
    constructor(e2) {
      super(Xn, "equate");
      this.force = getInteger({
        data: e2.force,
        defaultValue: 1,
        validate: (e3) => 0 === e3
      });
      this.from = e2.from || "";
      this.to = e2.to || "";
    }
  }
  class EquateRange extends XFAObject {
    constructor(e2) {
      super(Xn, "equateRange");
      this.from = e2.from || "";
      this.to = e2.to || "";
      this._unicodeRange = e2.unicodeRange || "";
    }
    get unicodeRange() {
      const e2 = [], t2 = /U\+([0-9a-fA-F]+)/, i2 = this._unicodeRange;
      for (let a2 of i2.split(",").map((e3) => e3.trim()).filter((e3) => !!e3)) {
        a2 = a2.split("-", 2).map((e3) => {
          const i3 = e3.match(t2);
          return i3 ? parseInt(i3[1], 16) : 0;
        });
        1 === a2.length && a2.push(a2[0]);
        e2.push(a2);
      }
      return shadow(this, "unicodeRange", e2);
    }
  }
  class Exclude extends ContentObject {
    constructor(e2) {
      super(Xn, "exclude");
    }
    [Is]() {
      this[ss] = this[ss].trim().split(/\s+/).filter((e2) => e2 && [
        "calculate",
        "close",
        "enter",
        "exit",
        "initialize",
        "ready",
        "validate"
      ].includes(e2));
    }
  }
  class ExcludeNS extends StringObject {
    constructor(e2) {
      super(Xn, "excludeNS");
    }
  }
  class FlipLabel extends OptionObject {
    constructor(e2) {
      super(Xn, "flipLabel", [
        "usePrinterSetting",
        "on",
        "off"
      ]);
    }
  }
  class config_FontInfo extends XFAObject {
    constructor(e2) {
      super(Xn, "fontInfo", true);
      this.embed = null;
      this.map = null;
      this.subsetBelow = null;
      this.alwaysEmbed = new XFAObjectArray();
      this.defaultTypeface = new XFAObjectArray();
      this.neverEmbed = new XFAObjectArray();
    }
  }
  class FormFieldFilling extends Option01 {
    constructor(e2) {
      super(Xn, "formFieldFilling");
    }
  }
  class GroupParent extends StringObject {
    constructor(e2) {
      super(Xn, "groupParent");
    }
  }
  class IfEmpty extends OptionObject {
    constructor(e2) {
      super(Xn, "ifEmpty", [
        "dataValue",
        "dataGroup",
        "ignore",
        "remove"
      ]);
    }
  }
  class IncludeXDPContent extends StringObject {
    constructor(e2) {
      super(Xn, "includeXDPContent");
    }
  }
  class IncrementalLoad extends OptionObject {
    constructor(e2) {
      super(Xn, "incrementalLoad", [
        "none",
        "forwardOnly"
      ]);
    }
  }
  class IncrementalMerge extends Option01 {
    constructor(e2) {
      super(Xn, "incrementalMerge");
    }
  }
  class Interactive extends Option01 {
    constructor(e2) {
      super(Xn, "interactive");
    }
  }
  class Jog extends OptionObject {
    constructor(e2) {
      super(Xn, "jog", [
        "usePrinterSetting",
        "none",
        "pageSet"
      ]);
    }
  }
  class LabelPrinter extends XFAObject {
    constructor(e2) {
      super(Xn, "labelPrinter", true);
      this.name = getStringOption(e2.name, [
        "zpl",
        "dpl",
        "ipl",
        "tcpl"
      ]);
      this.batchOutput = null;
      this.flipLabel = null;
      this.fontInfo = null;
      this.xdc = null;
    }
  }
  class Layout extends OptionObject {
    constructor(e2) {
      super(Xn, "layout", [
        "paginate",
        "panel"
      ]);
    }
  }
  class Level extends IntegerObject {
    constructor(e2) {
      super(Xn, "level", 0, (e3) => e3 > 0);
    }
  }
  class Linearized extends Option01 {
    constructor(e2) {
      super(Xn, "linearized");
    }
  }
  class Locale extends StringObject {
    constructor(e2) {
      super(Xn, "locale");
    }
  }
  class LocaleSet extends StringObject {
    constructor(e2) {
      super(Xn, "localeSet");
    }
  }
  class Log extends XFAObject {
    constructor(e2) {
      super(Xn, "log", true);
      this.mode = null;
      this.threshold = null;
      this.to = null;
      this.uri = null;
    }
  }
  class MapElement extends XFAObject {
    constructor(e2) {
      super(Xn, "map", true);
      this.equate = new XFAObjectArray();
      this.equateRange = new XFAObjectArray();
    }
  }
  class MediumInfo extends XFAObject {
    constructor(e2) {
      super(Xn, "mediumInfo", true);
      this.map = null;
    }
  }
  class config_Message extends XFAObject {
    constructor(e2) {
      super(Xn, "message", true);
      this.msgId = null;
      this.severity = null;
    }
  }
  class Messaging extends XFAObject {
    constructor(e2) {
      super(Xn, "messaging", true);
      this.message = new XFAObjectArray();
    }
  }
  class Mode extends OptionObject {
    constructor(e2) {
      super(Xn, "mode", [
        "append",
        "overwrite"
      ]);
    }
  }
  class ModifyAnnots extends Option01 {
    constructor(e2) {
      super(Xn, "modifyAnnots");
    }
  }
  class MsgId extends IntegerObject {
    constructor(e2) {
      super(Xn, "msgId", 1, (e3) => e3 >= 1);
    }
  }
  class NameAttr extends StringObject {
    constructor(e2) {
      super(Xn, "nameAttr");
    }
  }
  class NeverEmbed extends ContentObject {
    constructor(e2) {
      super(Xn, "neverEmbed");
    }
  }
  class NumberOfCopies extends IntegerObject {
    constructor(e2) {
      super(Xn, "numberOfCopies", null, (e3) => e3 >= 2 && e3 <= 5);
    }
  }
  class OpenAction extends XFAObject {
    constructor(e2) {
      super(Xn, "openAction", true);
      this.destination = null;
    }
  }
  class Output extends XFAObject {
    constructor(e2) {
      super(Xn, "output", true);
      this.to = null;
      this.type = null;
      this.uri = null;
    }
  }
  class OutputBin extends StringObject {
    constructor(e2) {
      super(Xn, "outputBin");
    }
  }
  class OutputXSL extends XFAObject {
    constructor(e2) {
      super(Xn, "outputXSL", true);
      this.uri = null;
    }
  }
  class Overprint extends OptionObject {
    constructor(e2) {
      super(Xn, "overprint", [
        "none",
        "both",
        "draw",
        "field"
      ]);
    }
  }
  class Packets extends StringObject {
    constructor(e2) {
      super(Xn, "packets");
    }
    [Is]() {
      "*" !== this[ss] && (this[ss] = this[ss].trim().split(/\s+/).filter((e2) => [
        "config",
        "datasets",
        "template",
        "xfdf",
        "xslt"
      ].includes(e2)));
    }
  }
  class PageOffset extends XFAObject {
    constructor(e2) {
      super(Xn, "pageOffset");
      this.x = getInteger({
        data: e2.x,
        defaultValue: "useXDCSetting",
        validate: (e3) => true
      });
      this.y = getInteger({
        data: e2.y,
        defaultValue: "useXDCSetting",
        validate: (e3) => true
      });
    }
  }
  class PageRange extends StringObject {
    constructor(e2) {
      super(Xn, "pageRange");
    }
    [Is]() {
      const e2 = this[ss].trim().split(/\s+/).map((e3) => parseInt(e3, 10)), t2 = [];
      for (let i2 = 0, a2 = e2.length; i2 < a2; i2 += 2) t2.push(e2.slice(i2, i2 + 2));
      this[ss] = t2;
    }
  }
  class Pagination extends OptionObject {
    constructor(e2) {
      super(Xn, "pagination", [
        "simplex",
        "duplexShortEdge",
        "duplexLongEdge"
      ]);
    }
  }
  class PaginationOverride extends OptionObject {
    constructor(e2) {
      super(Xn, "paginationOverride", [
        "none",
        "forceDuplex",
        "forceDuplexLongEdge",
        "forceDuplexShortEdge",
        "forceSimplex"
      ]);
    }
  }
  class Part extends IntegerObject {
    constructor(e2) {
      super(Xn, "part", 1, (e3) => false);
    }
  }
  class Pcl extends XFAObject {
    constructor(e2) {
      super(Xn, "pcl", true);
      this.name = e2.name || "";
      this.batchOutput = null;
      this.fontInfo = null;
      this.jog = null;
      this.mediumInfo = null;
      this.outputBin = null;
      this.pageOffset = null;
      this.staple = null;
      this.xdc = null;
    }
  }
  class Pdf extends XFAObject {
    constructor(e2) {
      super(Xn, "pdf", true);
      this.name = e2.name || "";
      this.adobeExtensionLevel = null;
      this.batchOutput = null;
      this.compression = null;
      this.creator = null;
      this.encryption = null;
      this.fontInfo = null;
      this.interactive = null;
      this.linearized = null;
      this.openAction = null;
      this.pdfa = null;
      this.producer = null;
      this.renderPolicy = null;
      this.scriptModel = null;
      this.silentPrint = null;
      this.submitFormat = null;
      this.tagged = null;
      this.version = null;
      this.viewerPreferences = null;
      this.xdc = null;
    }
  }
  class Pdfa extends XFAObject {
    constructor(e2) {
      super(Xn, "pdfa", true);
      this.amd = null;
      this.conformance = null;
      this.includeXDPContent = null;
      this.part = null;
    }
  }
  class Permissions extends XFAObject {
    constructor(e2) {
      super(Xn, "permissions", true);
      this.accessibleContent = null;
      this.change = null;
      this.contentCopy = null;
      this.documentAssembly = null;
      this.formFieldFilling = null;
      this.modifyAnnots = null;
      this.plaintextMetadata = null;
      this.print = null;
      this.printHighQuality = null;
    }
  }
  class PickTrayByPDFSize extends Option01 {
    constructor(e2) {
      super(Xn, "pickTrayByPDFSize");
    }
  }
  class config_Picture extends StringObject {
    constructor(e2) {
      super(Xn, "picture");
    }
  }
  class PlaintextMetadata extends Option01 {
    constructor(e2) {
      super(Xn, "plaintextMetadata");
    }
  }
  class Presence extends OptionObject {
    constructor(e2) {
      super(Xn, "presence", [
        "preserve",
        "dissolve",
        "dissolveStructure",
        "ignore",
        "remove"
      ]);
    }
  }
  class Present extends XFAObject {
    constructor(e2) {
      super(Xn, "present", true);
      this.behaviorOverride = null;
      this.cache = null;
      this.common = null;
      this.copies = null;
      this.destination = null;
      this.incrementalMerge = null;
      this.layout = null;
      this.output = null;
      this.overprint = null;
      this.pagination = null;
      this.paginationOverride = null;
      this.script = null;
      this.validate = null;
      this.xdp = null;
      this.driver = new XFAObjectArray();
      this.labelPrinter = new XFAObjectArray();
      this.pcl = new XFAObjectArray();
      this.pdf = new XFAObjectArray();
      this.ps = new XFAObjectArray();
      this.submitUrl = new XFAObjectArray();
      this.webClient = new XFAObjectArray();
      this.zpl = new XFAObjectArray();
    }
  }
  class Print extends Option01 {
    constructor(e2) {
      super(Xn, "print");
    }
  }
  class PrintHighQuality extends Option01 {
    constructor(e2) {
      super(Xn, "printHighQuality");
    }
  }
  class PrintScaling extends OptionObject {
    constructor(e2) {
      super(Xn, "printScaling", [
        "appdefault",
        "noScaling"
      ]);
    }
  }
  class PrinterName extends StringObject {
    constructor(e2) {
      super(Xn, "printerName");
    }
  }
  class Producer extends StringObject {
    constructor(e2) {
      super(Xn, "producer");
    }
  }
  class Ps extends XFAObject {
    constructor(e2) {
      super(Xn, "ps", true);
      this.name = e2.name || "";
      this.batchOutput = null;
      this.fontInfo = null;
      this.jog = null;
      this.mediumInfo = null;
      this.outputBin = null;
      this.staple = null;
      this.xdc = null;
    }
  }
  class Range extends ContentObject {
    constructor(e2) {
      super(Xn, "range");
    }
    [Is]() {
      this[ss] = this[ss].trim().split(/\s*,\s*/, 2).map((e2) => e2.split("-").map((e3) => parseInt(e3.trim(), 10))).filter((e2) => e2.every((e3) => !isNaN(e3))).map((e2) => {
        1 === e2.length && e2.push(e2[0]);
        return e2;
      });
    }
  }
  class Record extends ContentObject {
    constructor(e2) {
      super(Xn, "record");
    }
    [Is]() {
      this[ss] = this[ss].trim();
      const e2 = parseInt(this[ss], 10);
      !isNaN(e2) && e2 >= 0 && (this[ss] = e2);
    }
  }
  class Relevant extends ContentObject {
    constructor(e2) {
      super(Xn, "relevant");
    }
    [Is]() {
      this[ss] = this[ss].trim().split(/\s+/);
    }
  }
  class Rename extends ContentObject {
    constructor(e2) {
      super(Xn, "rename");
    }
    [Is]() {
      this[ss] = this[ss].trim();
      (this[ss].toLowerCase().startsWith("xml") || new RegExp("[\\p{L}_][\\p{L}\\d._\\p{M}-]*", "u").test(this[ss])) && warn("XFA - Rename: invalid XFA name");
    }
  }
  class RenderPolicy extends OptionObject {
    constructor(e2) {
      super(Xn, "renderPolicy", [
        "server",
        "client"
      ]);
    }
  }
  class RunScripts extends OptionObject {
    constructor(e2) {
      super(Xn, "runScripts", [
        "both",
        "client",
        "none",
        "server"
      ]);
    }
  }
  class config_Script extends XFAObject {
    constructor(e2) {
      super(Xn, "script", true);
      this.currentPage = null;
      this.exclude = null;
      this.runScripts = null;
    }
  }
  class ScriptModel extends OptionObject {
    constructor(e2) {
      super(Xn, "scriptModel", [
        "XFA",
        "none"
      ]);
    }
  }
  class Severity extends OptionObject {
    constructor(e2) {
      super(Xn, "severity", [
        "ignore",
        "error",
        "information",
        "trace",
        "warning"
      ]);
    }
  }
  class SilentPrint extends XFAObject {
    constructor(e2) {
      super(Xn, "silentPrint", true);
      this.addSilentPrint = null;
      this.printerName = null;
    }
  }
  class Staple extends XFAObject {
    constructor(e2) {
      super(Xn, "staple");
      this.mode = getStringOption(e2.mode, [
        "usePrinterSetting",
        "on",
        "off"
      ]);
    }
  }
  class StartNode extends StringObject {
    constructor(e2) {
      super(Xn, "startNode");
    }
  }
  class StartPage extends IntegerObject {
    constructor(e2) {
      super(Xn, "startPage", 0, (e3) => true);
    }
  }
  class SubmitFormat extends OptionObject {
    constructor(e2) {
      super(Xn, "submitFormat", [
        "html",
        "delegate",
        "fdf",
        "xml",
        "pdf"
      ]);
    }
  }
  class SubmitUrl extends StringObject {
    constructor(e2) {
      super(Xn, "submitUrl");
    }
  }
  class SubsetBelow extends IntegerObject {
    constructor(e2) {
      super(Xn, "subsetBelow", 100, (e3) => e3 >= 0 && e3 <= 100);
    }
  }
  class SuppressBanner extends Option01 {
    constructor(e2) {
      super(Xn, "suppressBanner");
    }
  }
  class Tagged extends Option01 {
    constructor(e2) {
      super(Xn, "tagged");
    }
  }
  class config_Template extends XFAObject {
    constructor(e2) {
      super(Xn, "template", true);
      this.base = null;
      this.relevant = null;
      this.startPage = null;
      this.uri = null;
      this.xsl = null;
    }
  }
  class Threshold extends OptionObject {
    constructor(e2) {
      super(Xn, "threshold", [
        "trace",
        "error",
        "information",
        "warning"
      ]);
    }
  }
  class To extends OptionObject {
    constructor(e2) {
      super(Xn, "to", [
        "null",
        "memory",
        "stderr",
        "stdout",
        "system",
        "uri"
      ]);
    }
  }
  class TemplateCache extends XFAObject {
    constructor(e2) {
      super(Xn, "templateCache");
      this.maxEntries = getInteger({
        data: e2.maxEntries,
        defaultValue: 5,
        validate: (e3) => e3 >= 0
      });
    }
  }
  class Trace extends XFAObject {
    constructor(e2) {
      super(Xn, "trace", true);
      this.area = new XFAObjectArray();
    }
  }
  class Transform extends XFAObject {
    constructor(e2) {
      super(Xn, "transform", true);
      this.groupParent = null;
      this.ifEmpty = null;
      this.nameAttr = null;
      this.picture = null;
      this.presence = null;
      this.rename = null;
      this.whitespace = null;
    }
  }
  class Type extends OptionObject {
    constructor(e2) {
      super(Xn, "type", [
        "none",
        "ascii85",
        "asciiHex",
        "ccittfax",
        "flate",
        "lzw",
        "runLength",
        "native",
        "xdp",
        "mergedXDP"
      ]);
    }
  }
  class Uri extends StringObject {
    constructor(e2) {
      super(Xn, "uri");
    }
  }
  class config_Validate extends OptionObject {
    constructor(e2) {
      super(Xn, "validate", [
        "preSubmit",
        "prePrint",
        "preExecute",
        "preSave"
      ]);
    }
  }
  class ValidateApprovalSignatures extends ContentObject {
    constructor(e2) {
      super(Xn, "validateApprovalSignatures");
    }
    [Is]() {
      this[ss] = this[ss].trim().split(/\s+/).filter((e2) => [
        "docReady",
        "postSign"
      ].includes(e2));
    }
  }
  class ValidationMessaging extends OptionObject {
    constructor(e2) {
      super(Xn, "validationMessaging", [
        "allMessagesIndividually",
        "allMessagesTogether",
        "firstMessageOnly",
        "noMessages"
      ]);
    }
  }
  class Version extends OptionObject {
    constructor(e2) {
      super(Xn, "version", [
        "1.7",
        "1.6",
        "1.5",
        "1.4",
        "1.3",
        "1.2"
      ]);
    }
  }
  class VersionControl extends XFAObject {
    constructor(e2) {
      super(Xn, "VersionControl");
      this.outputBelow = getStringOption(e2.outputBelow, [
        "warn",
        "error",
        "update"
      ]);
      this.sourceAbove = getStringOption(e2.sourceAbove, [
        "warn",
        "error"
      ]);
      this.sourceBelow = getStringOption(e2.sourceBelow, [
        "update",
        "maintain"
      ]);
    }
  }
  class ViewerPreferences extends XFAObject {
    constructor(e2) {
      super(Xn, "viewerPreferences", true);
      this.ADBE_JSConsole = null;
      this.ADBE_JSDebugger = null;
      this.addViewerPreferences = null;
      this.duplexOption = null;
      this.enforce = null;
      this.numberOfCopies = null;
      this.pageRange = null;
      this.pickTrayByPDFSize = null;
      this.printScaling = null;
    }
  }
  class WebClient extends XFAObject {
    constructor(e2) {
      super(Xn, "webClient", true);
      this.name = e2.name ? e2.name.trim() : "";
      this.fontInfo = null;
      this.xdc = null;
    }
  }
  class Whitespace extends OptionObject {
    constructor(e2) {
      super(Xn, "whitespace", [
        "preserve",
        "ltrim",
        "normalize",
        "rtrim",
        "trim"
      ]);
    }
  }
  class Window extends ContentObject {
    constructor(e2) {
      super(Xn, "window");
    }
    [Is]() {
      const e2 = this[ss].trim().split(/\s*,\s*/, 2).map((e3) => parseInt(e3, 10));
      if (e2.some((e3) => isNaN(e3))) this[ss] = [
        0,
        0
      ];
      else {
        1 === e2.length && e2.push(e2[0]);
        this[ss] = e2;
      }
    }
  }
  class Xdc extends XFAObject {
    constructor(e2) {
      super(Xn, "xdc", true);
      this.uri = new XFAObjectArray();
      this.xsl = new XFAObjectArray();
    }
  }
  class Xdp extends XFAObject {
    constructor(e2) {
      super(Xn, "xdp", true);
      this.packets = null;
    }
  }
  class Xsl extends XFAObject {
    constructor(e2) {
      super(Xn, "xsl", true);
      this.debug = null;
      this.uri = null;
    }
  }
  class Zpl extends XFAObject {
    constructor(e2) {
      super(Xn, "zpl", true);
      this.name = e2.name ? e2.name.trim() : "";
      this.batchOutput = null;
      this.flipLabel = null;
      this.fontInfo = null;
      this.xdc = null;
    }
  }
  class ConfigNamespace {
    static [hn](e2, t2) {
      if (ConfigNamespace.hasOwnProperty(e2)) return ConfigNamespace[e2](t2);
    }
    static acrobat(e2) {
      return new Acrobat(e2);
    }
    static acrobat7(e2) {
      return new Acrobat7(e2);
    }
    static ADBE_JSConsole(e2) {
      return new ADBE_JSConsole(e2);
    }
    static ADBE_JSDebugger(e2) {
      return new ADBE_JSDebugger(e2);
    }
    static addSilentPrint(e2) {
      return new AddSilentPrint(e2);
    }
    static addViewerPreferences(e2) {
      return new AddViewerPreferences(e2);
    }
    static adjustData(e2) {
      return new AdjustData(e2);
    }
    static adobeExtensionLevel(e2) {
      return new AdobeExtensionLevel(e2);
    }
    static agent(e2) {
      return new Agent(e2);
    }
    static alwaysEmbed(e2) {
      return new AlwaysEmbed(e2);
    }
    static amd(e2) {
      return new Amd(e2);
    }
    static area(e2) {
      return new config_Area(e2);
    }
    static attributes(e2) {
      return new Attributes(e2);
    }
    static autoSave(e2) {
      return new AutoSave(e2);
    }
    static base(e2) {
      return new Base(e2);
    }
    static batchOutput(e2) {
      return new BatchOutput(e2);
    }
    static behaviorOverride(e2) {
      return new BehaviorOverride(e2);
    }
    static cache(e2) {
      return new Cache(e2);
    }
    static change(e2) {
      return new Change(e2);
    }
    static common(e2) {
      return new Common(e2);
    }
    static compress(e2) {
      return new Compress(e2);
    }
    static compressLogicalStructure(e2) {
      return new CompressLogicalStructure(e2);
    }
    static compressObjectStream(e2) {
      return new CompressObjectStream(e2);
    }
    static compression(e2) {
      return new Compression(e2);
    }
    static config(e2) {
      return new Config(e2);
    }
    static conformance(e2) {
      return new Conformance(e2);
    }
    static contentCopy(e2) {
      return new ContentCopy(e2);
    }
    static copies(e2) {
      return new Copies(e2);
    }
    static creator(e2) {
      return new Creator(e2);
    }
    static currentPage(e2) {
      return new CurrentPage(e2);
    }
    static data(e2) {
      return new Data(e2);
    }
    static debug(e2) {
      return new Debug(e2);
    }
    static defaultTypeface(e2) {
      return new DefaultTypeface(e2);
    }
    static destination(e2) {
      return new Destination(e2);
    }
    static documentAssembly(e2) {
      return new DocumentAssembly(e2);
    }
    static driver(e2) {
      return new Driver(e2);
    }
    static duplexOption(e2) {
      return new DuplexOption(e2);
    }
    static dynamicRender(e2) {
      return new DynamicRender(e2);
    }
    static embed(e2) {
      return new Embed(e2);
    }
    static encrypt(e2) {
      return new config_Encrypt(e2);
    }
    static encryption(e2) {
      return new config_Encryption(e2);
    }
    static encryptionLevel(e2) {
      return new EncryptionLevel(e2);
    }
    static enforce(e2) {
      return new Enforce(e2);
    }
    static equate(e2) {
      return new Equate(e2);
    }
    static equateRange(e2) {
      return new EquateRange(e2);
    }
    static exclude(e2) {
      return new Exclude(e2);
    }
    static excludeNS(e2) {
      return new ExcludeNS(e2);
    }
    static flipLabel(e2) {
      return new FlipLabel(e2);
    }
    static fontInfo(e2) {
      return new config_FontInfo(e2);
    }
    static formFieldFilling(e2) {
      return new FormFieldFilling(e2);
    }
    static groupParent(e2) {
      return new GroupParent(e2);
    }
    static ifEmpty(e2) {
      return new IfEmpty(e2);
    }
    static includeXDPContent(e2) {
      return new IncludeXDPContent(e2);
    }
    static incrementalLoad(e2) {
      return new IncrementalLoad(e2);
    }
    static incrementalMerge(e2) {
      return new IncrementalMerge(e2);
    }
    static interactive(e2) {
      return new Interactive(e2);
    }
    static jog(e2) {
      return new Jog(e2);
    }
    static labelPrinter(e2) {
      return new LabelPrinter(e2);
    }
    static layout(e2) {
      return new Layout(e2);
    }
    static level(e2) {
      return new Level(e2);
    }
    static linearized(e2) {
      return new Linearized(e2);
    }
    static locale(e2) {
      return new Locale(e2);
    }
    static localeSet(e2) {
      return new LocaleSet(e2);
    }
    static log(e2) {
      return new Log(e2);
    }
    static map(e2) {
      return new MapElement(e2);
    }
    static mediumInfo(e2) {
      return new MediumInfo(e2);
    }
    static message(e2) {
      return new config_Message(e2);
    }
    static messaging(e2) {
      return new Messaging(e2);
    }
    static mode(e2) {
      return new Mode(e2);
    }
    static modifyAnnots(e2) {
      return new ModifyAnnots(e2);
    }
    static msgId(e2) {
      return new MsgId(e2);
    }
    static nameAttr(e2) {
      return new NameAttr(e2);
    }
    static neverEmbed(e2) {
      return new NeverEmbed(e2);
    }
    static numberOfCopies(e2) {
      return new NumberOfCopies(e2);
    }
    static openAction(e2) {
      return new OpenAction(e2);
    }
    static output(e2) {
      return new Output(e2);
    }
    static outputBin(e2) {
      return new OutputBin(e2);
    }
    static outputXSL(e2) {
      return new OutputXSL(e2);
    }
    static overprint(e2) {
      return new Overprint(e2);
    }
    static packets(e2) {
      return new Packets(e2);
    }
    static pageOffset(e2) {
      return new PageOffset(e2);
    }
    static pageRange(e2) {
      return new PageRange(e2);
    }
    static pagination(e2) {
      return new Pagination(e2);
    }
    static paginationOverride(e2) {
      return new PaginationOverride(e2);
    }
    static part(e2) {
      return new Part(e2);
    }
    static pcl(e2) {
      return new Pcl(e2);
    }
    static pdf(e2) {
      return new Pdf(e2);
    }
    static pdfa(e2) {
      return new Pdfa(e2);
    }
    static permissions(e2) {
      return new Permissions(e2);
    }
    static pickTrayByPDFSize(e2) {
      return new PickTrayByPDFSize(e2);
    }
    static picture(e2) {
      return new config_Picture(e2);
    }
    static plaintextMetadata(e2) {
      return new PlaintextMetadata(e2);
    }
    static presence(e2) {
      return new Presence(e2);
    }
    static present(e2) {
      return new Present(e2);
    }
    static print(e2) {
      return new Print(e2);
    }
    static printHighQuality(e2) {
      return new PrintHighQuality(e2);
    }
    static printScaling(e2) {
      return new PrintScaling(e2);
    }
    static printerName(e2) {
      return new PrinterName(e2);
    }
    static producer(e2) {
      return new Producer(e2);
    }
    static ps(e2) {
      return new Ps(e2);
    }
    static range(e2) {
      return new Range(e2);
    }
    static record(e2) {
      return new Record(e2);
    }
    static relevant(e2) {
      return new Relevant(e2);
    }
    static rename(e2) {
      return new Rename(e2);
    }
    static renderPolicy(e2) {
      return new RenderPolicy(e2);
    }
    static runScripts(e2) {
      return new RunScripts(e2);
    }
    static script(e2) {
      return new config_Script(e2);
    }
    static scriptModel(e2) {
      return new ScriptModel(e2);
    }
    static severity(e2) {
      return new Severity(e2);
    }
    static silentPrint(e2) {
      return new SilentPrint(e2);
    }
    static staple(e2) {
      return new Staple(e2);
    }
    static startNode(e2) {
      return new StartNode(e2);
    }
    static startPage(e2) {
      return new StartPage(e2);
    }
    static submitFormat(e2) {
      return new SubmitFormat(e2);
    }
    static submitUrl(e2) {
      return new SubmitUrl(e2);
    }
    static subsetBelow(e2) {
      return new SubsetBelow(e2);
    }
    static suppressBanner(e2) {
      return new SuppressBanner(e2);
    }
    static tagged(e2) {
      return new Tagged(e2);
    }
    static template(e2) {
      return new config_Template(e2);
    }
    static templateCache(e2) {
      return new TemplateCache(e2);
    }
    static threshold(e2) {
      return new Threshold(e2);
    }
    static to(e2) {
      return new To(e2);
    }
    static trace(e2) {
      return new Trace(e2);
    }
    static transform(e2) {
      return new Transform(e2);
    }
    static type(e2) {
      return new Type(e2);
    }
    static uri(e2) {
      return new Uri(e2);
    }
    static validate(e2) {
      return new config_Validate(e2);
    }
    static validateApprovalSignatures(e2) {
      return new ValidateApprovalSignatures(e2);
    }
    static validationMessaging(e2) {
      return new ValidationMessaging(e2);
    }
    static version(e2) {
      return new Version(e2);
    }
    static versionControl(e2) {
      return new VersionControl(e2);
    }
    static viewerPreferences(e2) {
      return new ViewerPreferences(e2);
    }
    static webClient(e2) {
      return new WebClient(e2);
    }
    static whitespace(e2) {
      return new Whitespace(e2);
    }
    static window(e2) {
      return new Window(e2);
    }
    static xdc(e2) {
      return new Xdc(e2);
    }
    static xdp(e2) {
      return new Xdp(e2);
    }
    static xsl(e2) {
      return new Xsl(e2);
    }
    static zpl(e2) {
      return new Zpl(e2);
    }
  }
  const Zn = ln.connectionSet.id;
  class ConnectionSet extends XFAObject {
    constructor(e2) {
      super(Zn, "connectionSet", true);
      this.wsdlConnection = new XFAObjectArray();
      this.xmlConnection = new XFAObjectArray();
      this.xsdConnection = new XFAObjectArray();
    }
  }
  class EffectiveInputPolicy extends XFAObject {
    constructor(e2) {
      super(Zn, "effectiveInputPolicy");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class EffectiveOutputPolicy extends XFAObject {
    constructor(e2) {
      super(Zn, "effectiveOutputPolicy");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class Operation extends StringObject {
    constructor(e2) {
      super(Zn, "operation");
      this.id = e2.id || "";
      this.input = e2.input || "";
      this.name = e2.name || "";
      this.output = e2.output || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class RootElement extends StringObject {
    constructor(e2) {
      super(Zn, "rootElement");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class SoapAction extends StringObject {
    constructor(e2) {
      super(Zn, "soapAction");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class SoapAddress extends StringObject {
    constructor(e2) {
      super(Zn, "soapAddress");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class connection_set_Uri extends StringObject {
    constructor(e2) {
      super(Zn, "uri");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class WsdlAddress extends StringObject {
    constructor(e2) {
      super(Zn, "wsdlAddress");
      this.id = e2.id || "";
      this.name = e2.name || "";
      this.use = e2.use || "";
      this.usehref = e2.usehref || "";
    }
  }
  class WsdlConnection extends XFAObject {
    constructor(e2) {
      super(Zn, "wsdlConnection", true);
      this.dataDescription = e2.dataDescription || "";
      this.name = e2.name || "";
      this.effectiveInputPolicy = null;
      this.effectiveOutputPolicy = null;
      this.operation = null;
      this.soapAction = null;
      this.soapAddress = null;
      this.wsdlAddress = null;
    }
  }
  class XmlConnection extends XFAObject {
    constructor(e2) {
      super(Zn, "xmlConnection", true);
      this.dataDescription = e2.dataDescription || "";
      this.name = e2.name || "";
      this.uri = null;
    }
  }
  class XsdConnection extends XFAObject {
    constructor(e2) {
      super(Zn, "xsdConnection", true);
      this.dataDescription = e2.dataDescription || "";
      this.name = e2.name || "";
      this.rootElement = null;
      this.uri = null;
    }
  }
  class ConnectionSetNamespace {
    static [hn](e2, t2) {
      if (ConnectionSetNamespace.hasOwnProperty(e2)) return ConnectionSetNamespace[e2](t2);
    }
    static connectionSet(e2) {
      return new ConnectionSet(e2);
    }
    static effectiveInputPolicy(e2) {
      return new EffectiveInputPolicy(e2);
    }
    static effectiveOutputPolicy(e2) {
      return new EffectiveOutputPolicy(e2);
    }
    static operation(e2) {
      return new Operation(e2);
    }
    static rootElement(e2) {
      return new RootElement(e2);
    }
    static soapAction(e2) {
      return new SoapAction(e2);
    }
    static soapAddress(e2) {
      return new SoapAddress(e2);
    }
    static uri(e2) {
      return new connection_set_Uri(e2);
    }
    static wsdlAddress(e2) {
      return new WsdlAddress(e2);
    }
    static wsdlConnection(e2) {
      return new WsdlConnection(e2);
    }
    static xmlConnection(e2) {
      return new XmlConnection(e2);
    }
    static xsdConnection(e2) {
      return new XsdConnection(e2);
    }
  }
  const Vn = ln.datasets.id;
  class datasets_Data extends XmlObject {
    constructor(e2) {
      super(Vn, "data", e2);
    }
    [Ls]() {
      return true;
    }
  }
  class Datasets extends XFAObject {
    constructor(e2) {
      super(Vn, "datasets", true);
      this.data = null;
      this.Signature = null;
    }
    [Ws](e2) {
      const t2 = e2[qs];
      ("data" === t2 && e2[Ks] === Vn || "Signature" === t2 && e2[Ks] === ln.signature.id) && (this[t2] = e2);
      this[$r](e2);
    }
  }
  class DatasetsNamespace {
    static [hn](e2, t2) {
      if (DatasetsNamespace.hasOwnProperty(e2)) return DatasetsNamespace[e2](t2);
    }
    static datasets(e2) {
      return new Datasets(e2);
    }
    static data(e2) {
      return new datasets_Data(e2);
    }
  }
  const _n = ln.localeSet.id;
  class CalendarSymbols extends XFAObject {
    constructor(e2) {
      super(_n, "calendarSymbols", true);
      this.name = "gregorian";
      this.dayNames = new XFAObjectArray(2);
      this.eraNames = null;
      this.meridiemNames = null;
      this.monthNames = new XFAObjectArray(2);
    }
  }
  class CurrencySymbol extends StringObject {
    constructor(e2) {
      super(_n, "currencySymbol");
      this.name = getStringOption(e2.name, [
        "symbol",
        "isoname",
        "decimal"
      ]);
    }
  }
  class CurrencySymbols extends XFAObject {
    constructor(e2) {
      super(_n, "currencySymbols", true);
      this.currencySymbol = new XFAObjectArray(3);
    }
  }
  class DatePattern extends StringObject {
    constructor(e2) {
      super(_n, "datePattern");
      this.name = getStringOption(e2.name, [
        "full",
        "long",
        "med",
        "short"
      ]);
    }
  }
  class DatePatterns extends XFAObject {
    constructor(e2) {
      super(_n, "datePatterns", true);
      this.datePattern = new XFAObjectArray(4);
    }
  }
  class DateTimeSymbols extends ContentObject {
    constructor(e2) {
      super(_n, "dateTimeSymbols");
    }
  }
  class Day extends StringObject {
    constructor(e2) {
      super(_n, "day");
    }
  }
  class DayNames extends XFAObject {
    constructor(e2) {
      super(_n, "dayNames", true);
      this.abbr = getInteger({
        data: e2.abbr,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.day = new XFAObjectArray(7);
    }
  }
  class Era extends StringObject {
    constructor(e2) {
      super(_n, "era");
    }
  }
  class EraNames extends XFAObject {
    constructor(e2) {
      super(_n, "eraNames", true);
      this.era = new XFAObjectArray(2);
    }
  }
  class locale_set_Locale extends XFAObject {
    constructor(e2) {
      super(_n, "locale", true);
      this.desc = e2.desc || "";
      this.name = "isoname";
      this.calendarSymbols = null;
      this.currencySymbols = null;
      this.datePatterns = null;
      this.dateTimeSymbols = null;
      this.numberPatterns = null;
      this.numberSymbols = null;
      this.timePatterns = null;
      this.typeFaces = null;
    }
  }
  class locale_set_LocaleSet extends XFAObject {
    constructor(e2) {
      super(_n, "localeSet", true);
      this.locale = new XFAObjectArray();
    }
  }
  class Meridiem extends StringObject {
    constructor(e2) {
      super(_n, "meridiem");
    }
  }
  class MeridiemNames extends XFAObject {
    constructor(e2) {
      super(_n, "meridiemNames", true);
      this.meridiem = new XFAObjectArray(2);
    }
  }
  class Month extends StringObject {
    constructor(e2) {
      super(_n, "month");
    }
  }
  class MonthNames extends XFAObject {
    constructor(e2) {
      super(_n, "monthNames", true);
      this.abbr = getInteger({
        data: e2.abbr,
        defaultValue: 0,
        validate: (e3) => 1 === e3
      });
      this.month = new XFAObjectArray(12);
    }
  }
  class NumberPattern extends StringObject {
    constructor(e2) {
      super(_n, "numberPattern");
      this.name = getStringOption(e2.name, [
        "full",
        "long",
        "med",
        "short"
      ]);
    }
  }
  class NumberPatterns extends XFAObject {
    constructor(e2) {
      super(_n, "numberPatterns", true);
      this.numberPattern = new XFAObjectArray(4);
    }
  }
  class NumberSymbol extends StringObject {
    constructor(e2) {
      super(_n, "numberSymbol");
      this.name = getStringOption(e2.name, [
        "decimal",
        "grouping",
        "percent",
        "minus",
        "zero"
      ]);
    }
  }
  class NumberSymbols extends XFAObject {
    constructor(e2) {
      super(_n, "numberSymbols", true);
      this.numberSymbol = new XFAObjectArray(5);
    }
  }
  class TimePattern extends StringObject {
    constructor(e2) {
      super(_n, "timePattern");
      this.name = getStringOption(e2.name, [
        "full",
        "long",
        "med",
        "short"
      ]);
    }
  }
  class TimePatterns extends XFAObject {
    constructor(e2) {
      super(_n, "timePatterns", true);
      this.timePattern = new XFAObjectArray(4);
    }
  }
  class TypeFace extends XFAObject {
    constructor(e2) {
      super(_n, "typeFace", true);
      this.name = "" | e2.name;
    }
  }
  class TypeFaces extends XFAObject {
    constructor(e2) {
      super(_n, "typeFaces", true);
      this.typeFace = new XFAObjectArray();
    }
  }
  class LocaleSetNamespace {
    static [hn](e2, t2) {
      if (LocaleSetNamespace.hasOwnProperty(e2)) return LocaleSetNamespace[e2](t2);
    }
    static calendarSymbols(e2) {
      return new CalendarSymbols(e2);
    }
    static currencySymbol(e2) {
      return new CurrencySymbol(e2);
    }
    static currencySymbols(e2) {
      return new CurrencySymbols(e2);
    }
    static datePattern(e2) {
      return new DatePattern(e2);
    }
    static datePatterns(e2) {
      return new DatePatterns(e2);
    }
    static dateTimeSymbols(e2) {
      return new DateTimeSymbols(e2);
    }
    static day(e2) {
      return new Day(e2);
    }
    static dayNames(e2) {
      return new DayNames(e2);
    }
    static era(e2) {
      return new Era(e2);
    }
    static eraNames(e2) {
      return new EraNames(e2);
    }
    static locale(e2) {
      return new locale_set_Locale(e2);
    }
    static localeSet(e2) {
      return new locale_set_LocaleSet(e2);
    }
    static meridiem(e2) {
      return new Meridiem(e2);
    }
    static meridiemNames(e2) {
      return new MeridiemNames(e2);
    }
    static month(e2) {
      return new Month(e2);
    }
    static monthNames(e2) {
      return new MonthNames(e2);
    }
    static numberPattern(e2) {
      return new NumberPattern(e2);
    }
    static numberPatterns(e2) {
      return new NumberPatterns(e2);
    }
    static numberSymbol(e2) {
      return new NumberSymbol(e2);
    }
    static numberSymbols(e2) {
      return new NumberSymbols(e2);
    }
    static timePattern(e2) {
      return new TimePattern(e2);
    }
    static timePatterns(e2) {
      return new TimePatterns(e2);
    }
    static typeFace(e2) {
      return new TypeFace(e2);
    }
    static typeFaces(e2) {
      return new TypeFaces(e2);
    }
  }
  const zn = ln.signature.id;
  class signature_Signature extends XFAObject {
    constructor(e2) {
      super(zn, "signature", true);
    }
  }
  class SignatureNamespace {
    static [hn](e2, t2) {
      if (SignatureNamespace.hasOwnProperty(e2)) return SignatureNamespace[e2](t2);
    }
    static signature(e2) {
      return new signature_Signature(e2);
    }
  }
  const $n = ln.stylesheet.id;
  class Stylesheet extends XFAObject {
    constructor(e2) {
      super($n, "stylesheet", true);
    }
  }
  class StylesheetNamespace {
    static [hn](e2, t2) {
      if (StylesheetNamespace.hasOwnProperty(e2)) return StylesheetNamespace[e2](t2);
    }
    static stylesheet(e2) {
      return new Stylesheet(e2);
    }
  }
  const Ao = ln.xdp.id;
  class xdp_Xdp extends XFAObject {
    constructor(e2) {
      super(Ao, "xdp", true);
      this.uuid = e2.uuid || "";
      this.timeStamp = e2.timeStamp || "";
      this.config = null;
      this.connectionSet = null;
      this.datasets = null;
      this.localeSet = null;
      this.stylesheet = new XFAObjectArray();
      this.template = null;
    }
    [js](e2) {
      const t2 = ln[e2[qs]];
      return t2 && e2[Ks] === t2.id;
    }
  }
  class XdpNamespace {
    static [hn](e2, t2) {
      if (XdpNamespace.hasOwnProperty(e2)) return XdpNamespace[e2](t2);
    }
    static xdp(e2) {
      return new xdp_Xdp(e2);
    }
  }
  const eo = ln.xhtml.id, to = Symbol(), io = /* @__PURE__ */ new Set([
    "color",
    "font",
    "font-family",
    "font-size",
    "font-stretch",
    "font-style",
    "font-weight",
    "margin",
    "margin-bottom",
    "margin-left",
    "margin-right",
    "margin-top",
    "letter-spacing",
    "line-height",
    "orphans",
    "page-break-after",
    "page-break-before",
    "page-break-inside",
    "tab-interval",
    "tab-stop",
    "text-align",
    "text-decoration",
    "text-indent",
    "vertical-align",
    "widows",
    "kerning-mode",
    "xfa-font-horizontal-scale",
    "xfa-font-vertical-scale",
    "xfa-spacerun",
    "xfa-tab-stops"
  ]), ao = /* @__PURE__ */ new Map([
    [
      "page-break-after",
      "breakAfter"
    ],
    [
      "page-break-before",
      "breakBefore"
    ],
    [
      "page-break-inside",
      "breakInside"
    ],
    [
      "kerning-mode",
      (e2) => "none" === e2 ? "none" : "normal"
    ],
    [
      "xfa-font-horizontal-scale",
      (e2) => `scaleX(${Math.max(0, Math.min(parseInt(e2) / 100)).toFixed(2)})`
    ],
    [
      "xfa-font-vertical-scale",
      (e2) => `scaleY(${Math.max(0, Math.min(parseInt(e2) / 100)).toFixed(2)})`
    ],
    [
      "xfa-spacerun",
      ""
    ],
    [
      "xfa-tab-stops",
      ""
    ],
    [
      "font-size",
      (e2, t2) => measureToString(0.99 * (e2 = t2.fontSize = getMeasurement(e2)))
    ],
    [
      "letter-spacing",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "line-height",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "margin",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "margin-bottom",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "margin-left",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "margin-right",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "margin-top",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "text-indent",
      (e2) => measureToString(getMeasurement(e2))
    ],
    [
      "font-family",
      (e2) => e2
    ],
    [
      "vertical-align",
      (e2) => measureToString(getMeasurement(e2))
    ]
  ]), ro = /\s+/g, so = /[\r\n]+/g, no = /\r\n?/g;
  function mapStyle(e2, t2, i2) {
    const a2 = /* @__PURE__ */ Object.create(null);
    if (!e2) return a2;
    const r2 = /* @__PURE__ */ Object.create(null);
    for (const [t3, i3] of e2.split(";").map((e3) => e3.split(":", 2))) {
      const e3 = ao.get(t3);
      if ("" === e3) continue;
      let s2 = i3;
      e3 && (s2 = "string" == typeof e3 ? e3 : e3(i3, r2));
      t3.endsWith("scale") ? a2.transform = a2.transform ? `${a2[t3]} ${s2}` : s2 : a2[t3.replaceAll(/-([a-zA-Z])/g, (e4, t4) => t4.toUpperCase())] = s2;
    }
    a2.fontFamily && setFontFamily({
      typeface: a2.fontFamily,
      weight: a2.fontWeight || "normal",
      posture: a2.fontStyle || "normal",
      size: r2.fontSize || 0
    }, t2, t2[Fs].fontFinder, a2);
    if (i2 && a2.verticalAlign && "0px" !== a2.verticalAlign && a2.fontSize) {
      const e3 = 0.583, t3 = 0.333, i3 = getMeasurement(a2.fontSize);
      a2.fontSize = measureToString(i3 * e3);
      a2.verticalAlign = measureToString(Math.sign(getMeasurement(a2.verticalAlign)) * i3 * t3);
    }
    i2 && a2.fontSize && (a2.fontSize = `calc(${a2.fontSize} * var(--scale-factor))`);
    fixTextIndent(a2);
    return a2;
  }
  const oo = /* @__PURE__ */ new Set([
    "body",
    "html"
  ]);
  class XhtmlObject extends XmlObject {
    constructor(e2, t2) {
      super(eo, t2);
      this[to] = false;
      this.style = e2.style || "";
    }
    [es](e2) {
      super[es](e2);
      this.style = function checkStyle(e3) {
        return e3.style ? e3.style.trim().split(/\s*;\s*/).filter((e4) => !!e4).map((e4) => e4.split(/\s*:\s*/, 2)).filter(([t2, i2]) => {
          "font-family" === t2 && e3[Fs].usedTypefaces.add(i2);
          return io.has(t2);
        }).map((e4) => e4.join(":")).join(";") : "";
      }(this);
    }
    [_r]() {
      return !oo.has(this[qs]);
    }
    [Xs](e2, t2 = false) {
      if (t2) this[to] = true;
      else {
        e2 = e2.replaceAll(so, "");
        this.style.includes("xfa-spacerun:yes") || (e2 = e2.replaceAll(ro, " "));
      }
      e2 && (this[ss] += e2);
    }
    [Zs](e2, t2 = true) {
      const i2 = /* @__PURE__ */ Object.create(null), a2 = {
        top: NaN,
        bottom: NaN,
        left: NaN,
        right: NaN
      };
      let r2 = null;
      for (const [e3, t3] of this.style.split(";").map((e4) => e4.split(":", 2))) switch (e3) {
        case "font-family":
          i2.typeface = stripQuotes(t3);
          break;
        case "font-size":
          i2.size = getMeasurement(t3);
          break;
        case "font-weight":
          i2.weight = t3;
          break;
        case "font-style":
          i2.posture = t3;
          break;
        case "letter-spacing":
          i2.letterSpacing = getMeasurement(t3);
          break;
        case "margin":
          const e4 = t3.split(/ \t/).map((e5) => getMeasurement(e5));
          switch (e4.length) {
            case 1:
              a2.top = a2.bottom = a2.left = a2.right = e4[0];
              break;
            case 2:
              a2.top = a2.bottom = e4[0];
              a2.left = a2.right = e4[1];
              break;
            case 3:
              a2.top = e4[0];
              a2.bottom = e4[2];
              a2.left = a2.right = e4[1];
              break;
            case 4:
              a2.top = e4[0];
              a2.left = e4[1];
              a2.bottom = e4[2];
              a2.right = e4[3];
          }
          break;
        case "margin-top":
          a2.top = getMeasurement(t3);
          break;
        case "margin-bottom":
          a2.bottom = getMeasurement(t3);
          break;
        case "margin-left":
          a2.left = getMeasurement(t3);
          break;
        case "margin-right":
          a2.right = getMeasurement(t3);
          break;
        case "line-height":
          r2 = getMeasurement(t3);
      }
      e2.pushData(i2, a2, r2);
      if (this[ss]) e2.addString(this[ss]);
      else for (const t3 of this[ps]()) "#text" !== t3[qs] ? t3[Zs](e2) : e2.addString(t3[ss]);
      t2 && e2.popFont();
    }
    [gn](e2) {
      const t2 = [];
      this[gs] = {
        children: t2
      };
      this[As]({});
      if (0 === t2.length && !this[ss]) return HTMLResult.EMPTY;
      let i2;
      i2 = this[to] ? this[ss] ? this[ss].replaceAll(no, "\n") : void 0 : this[ss] || void 0;
      return HTMLResult.success({
        name: this[qs],
        attributes: {
          href: this.href,
          style: mapStyle(this.style, this, this[to])
        },
        children: t2,
        value: i2
      });
    }
  }
  class A extends XhtmlObject {
    constructor(e2) {
      super(e2, "a");
      this.href = fixURL(e2.href) || "";
    }
  }
  class B extends XhtmlObject {
    constructor(e2) {
      super(e2, "b");
    }
    [Zs](e2) {
      e2.pushFont({
        weight: "bold"
      });
      super[Zs](e2);
      e2.popFont();
    }
  }
  class Body extends XhtmlObject {
    constructor(e2) {
      super(e2, "body");
    }
    [gn](e2) {
      const t2 = super[gn](e2), { html: i2 } = t2;
      if (!i2) return HTMLResult.EMPTY;
      i2.name = "div";
      i2.attributes.class = [
        "xfaRich"
      ];
      return t2;
    }
  }
  class Br extends XhtmlObject {
    constructor(e2) {
      super(e2, "br");
    }
    [nn]() {
      return "\n";
    }
    [Zs](e2) {
      e2.addString("\n");
    }
    [gn](e2) {
      return HTMLResult.success({
        name: "br"
      });
    }
  }
  class Html extends XhtmlObject {
    constructor(e2) {
      super(e2, "html");
    }
    [gn](e2) {
      var _a4;
      const t2 = [];
      this[gs] = {
        children: t2
      };
      this[As]({});
      if (0 === t2.length) return HTMLResult.success({
        name: "div",
        attributes: {
          class: [
            "xfaRich"
          ],
          style: {}
        },
        value: this[ss] || ""
      });
      if (1 === t2.length) {
        const e3 = t2[0];
        if ((_a4 = e3.attributes) == null ? void 0 : _a4.class.includes("xfaRich")) return HTMLResult.success(e3);
      }
      return HTMLResult.success({
        name: "div",
        attributes: {
          class: [
            "xfaRich"
          ],
          style: {}
        },
        children: t2
      });
    }
  }
  class I extends XhtmlObject {
    constructor(e2) {
      super(e2, "i");
    }
    [Zs](e2) {
      e2.pushFont({
        posture: "italic"
      });
      super[Zs](e2);
      e2.popFont();
    }
  }
  class Li extends XhtmlObject {
    constructor(e2) {
      super(e2, "li");
    }
  }
  class Ol extends XhtmlObject {
    constructor(e2) {
      super(e2, "ol");
    }
  }
  class P extends XhtmlObject {
    constructor(e2) {
      super(e2, "p");
    }
    [Zs](e2) {
      super[Zs](e2, false);
      e2.addString("\n");
      e2.addPara();
      e2.popFont();
    }
    [nn]() {
      return this[bs]()[ps]().at(-1) === this ? super[nn]() : super[nn]() + "\n";
    }
  }
  class Span extends XhtmlObject {
    constructor(e2) {
      super(e2, "span");
    }
  }
  class Sub extends XhtmlObject {
    constructor(e2) {
      super(e2, "sub");
    }
  }
  class Sup extends XhtmlObject {
    constructor(e2) {
      super(e2, "sup");
    }
  }
  class Ul extends XhtmlObject {
    constructor(e2) {
      super(e2, "ul");
    }
  }
  class XhtmlNamespace {
    static [hn](e2, t2) {
      if (XhtmlNamespace.hasOwnProperty(e2)) return XhtmlNamespace[e2](t2);
    }
    static a(e2) {
      return new A(e2);
    }
    static b(e2) {
      return new B(e2);
    }
    static body(e2) {
      return new Body(e2);
    }
    static br(e2) {
      return new Br(e2);
    }
    static html(e2) {
      return new Html(e2);
    }
    static i(e2) {
      return new I(e2);
    }
    static li(e2) {
      return new Li(e2);
    }
    static ol(e2) {
      return new Ol(e2);
    }
    static p(e2) {
      return new P(e2);
    }
    static span(e2) {
      return new Span(e2);
    }
    static sub(e2) {
      return new Sub(e2);
    }
    static sup(e2) {
      return new Sup(e2);
    }
    static ul(e2) {
      return new Ul(e2);
    }
  }
  const go = {
    config: ConfigNamespace,
    connection: ConnectionSetNamespace,
    datasets: DatasetsNamespace,
    localeSet: LocaleSetNamespace,
    signature: SignatureNamespace,
    stylesheet: StylesheetNamespace,
    template: TemplateNamespace,
    xdp: XdpNamespace,
    xhtml: XhtmlNamespace
  };
  class UnknownNamespace {
    constructor(e2) {
      this.namespaceId = e2;
    }
    [hn](e2, t2) {
      return new XmlObject(this.namespaceId, e2, t2);
    }
  }
  class Root extends XFAObject {
    constructor(e2) {
      super(-1, "root", /* @__PURE__ */ Object.create(null));
      this.element = null;
      this[ks] = e2;
    }
    [Ws](e2) {
      this.element = e2;
      return true;
    }
    [Is]() {
      super[Is]();
      if (this.element.template instanceof Template) {
        this[ks].set($s, this.element);
        this.element.template[An](this[ks]);
        this.element.template[ks] = this[ks];
      }
    }
  }
  class Empty extends XFAObject {
    constructor() {
      super(-1, "", /* @__PURE__ */ Object.create(null));
    }
    [Ws](e2) {
      return false;
    }
  }
  class Builder {
    constructor(e2 = null) {
      this._namespaceStack = [];
      this._nsAgnosticLevel = 0;
      this._namespacePrefixes = /* @__PURE__ */ new Map();
      this._namespaces = /* @__PURE__ */ new Map();
      this._nextNsId = Math.max(...Object.values(ln).map(({ id: e3 }) => e3));
      this._currentNamespace = e2 || new UnknownNamespace(++this._nextNsId);
    }
    buildRoot(e2) {
      return new Root(e2);
    }
    build({ nsPrefix: e2, name: t2, attributes: i2, namespace: a2, prefixes: r2 }) {
      const s2 = null !== a2;
      if (s2) {
        this._namespaceStack.push(this._currentNamespace);
        this._currentNamespace = this._searchNamespace(a2);
      }
      r2 && this._addNamespacePrefix(r2);
      if (i2.hasOwnProperty(Os)) {
        const e3 = go.datasets, t3 = i2[Os];
        let a3 = null;
        for (const [i3, r3] of Object.entries(t3)) {
          if (this._getNamespaceToUse(i3) === e3) {
            a3 = {
              xfa: r3
            };
            break;
          }
        }
        a3 ? i2[Os] = a3 : delete i2[Os];
      }
      const n2 = this._getNamespaceToUse(e2), o2 = (n2 == null ? void 0 : n2[hn](t2, i2)) || new Empty();
      o2[Ls]() && this._nsAgnosticLevel++;
      (s2 || r2 || o2[Ls]()) && (o2[is] = {
        hasNamespace: s2,
        prefixes: r2,
        nsAgnostic: o2[Ls]()
      });
      return o2;
    }
    isNsAgnostic() {
      return this._nsAgnosticLevel > 0;
    }
    _searchNamespace(e2) {
      let t2 = this._namespaces.get(e2);
      if (t2) return t2;
      for (const [i2, { check: a2 }] of Object.entries(ln)) if (a2(e2)) {
        t2 = go[i2];
        if (t2) {
          this._namespaces.set(e2, t2);
          return t2;
        }
        break;
      }
      t2 = new UnknownNamespace(++this._nextNsId);
      this._namespaces.set(e2, t2);
      return t2;
    }
    _addNamespacePrefix(e2) {
      for (const { prefix: t2, value: i2 } of e2) {
        const e3 = this._searchNamespace(i2);
        let a2 = this._namespacePrefixes.get(t2);
        if (!a2) {
          a2 = [];
          this._namespacePrefixes.set(t2, a2);
        }
        a2.push(e3);
      }
    }
    _getNamespaceToUse(e2) {
      if (!e2) return this._currentNamespace;
      const t2 = this._namespacePrefixes.get(e2);
      if ((t2 == null ? void 0 : t2.length) > 0) return t2.at(-1);
      warn(`Unknown namespace prefix: ${e2}.`);
      return null;
    }
    clean(e2) {
      const { hasNamespace: t2, prefixes: i2, nsAgnostic: a2 } = e2;
      t2 && (this._currentNamespace = this._namespaceStack.pop());
      i2 && i2.forEach(({ prefix: e3 }) => {
        this._namespacePrefixes.get(e3).pop();
      });
      a2 && this._nsAgnosticLevel--;
    }
  }
  class XFAParser extends XMLParserBase {
    constructor(e2 = null, t2 = false) {
      super();
      this._builder = new Builder(e2);
      this._stack = [];
      this._globalData = {
        usedTypefaces: /* @__PURE__ */ new Set()
      };
      this._ids = /* @__PURE__ */ new Map();
      this._current = this._builder.buildRoot(this._ids);
      this._errorCode = Lr;
      this._whiteRegex = /^\s+$/;
      this._nbsps = /\xa0+/g;
      this._richText = t2;
    }
    parse(e2) {
      this.parseXml(e2);
      if (this._errorCode === Lr) {
        this._current[Is]();
        return this._current.element;
      }
    }
    onText(e2) {
      e2 = e2.replace(this._nbsps, (e3) => e3.slice(1) + " ");
      this._richText || this._current[_r]() ? this._current[Xs](e2, this._richText) : this._whiteRegex.test(e2) || this._current[Xs](e2.trim());
    }
    onCdata(e2) {
      this._current[Xs](e2);
    }
    _mkAttributes(e2, t2) {
      let i2 = null, a2 = null;
      const r2 = /* @__PURE__ */ Object.create({});
      for (const { name: s2, value: n2 } of e2) if ("xmlns" === s2) i2 ? warn(`XFA - multiple namespace definition in <${t2}>`) : i2 = n2;
      else if (s2.startsWith("xmlns:")) {
        const e3 = s2.substring(6);
        a2 || (a2 = []);
        a2.push({
          prefix: e3,
          value: n2
        });
      } else {
        const e3 = s2.indexOf(":");
        if (-1 === e3) r2[s2] = n2;
        else {
          let t3 = r2[Os];
          t3 || (t3 = r2[Os] = /* @__PURE__ */ Object.create(null));
          const [i3, a3] = [
            s2.slice(0, e3),
            s2.slice(e3 + 1)
          ];
          (t3[i3] || (t3[i3] = /* @__PURE__ */ Object.create(null)))[a3] = n2;
        }
      }
      return [
        i2,
        a2,
        r2
      ];
    }
    _getNameAndPrefix(e2, t2) {
      const i2 = e2.indexOf(":");
      return -1 === i2 ? [
        e2,
        null
      ] : [
        e2.substring(i2 + 1),
        t2 ? "" : e2.substring(0, i2)
      ];
    }
    onBeginElement(e2, t2, i2) {
      const [a2, r2, s2] = this._mkAttributes(t2, e2), [n2, o2] = this._getNameAndPrefix(e2, this._builder.isNsAgnostic()), g2 = this._builder.build({
        nsPrefix: o2,
        name: n2,
        attributes: s2,
        namespace: a2,
        prefixes: r2
      });
      g2[Fs] = this._globalData;
      if (i2) {
        g2[Is]();
        this._current[Ws](g2) && g2[tn](this._ids);
        g2[es](this._builder);
      } else {
        this._stack.push(this._current);
        this._current = g2;
      }
    }
    onEndElement(e2) {
      const t2 = this._current;
      if (t2[Gs]() && "string" == typeof t2[ss]) {
        const e3 = new XFAParser();
        e3._globalData = this._globalData;
        const i2 = e3.parse(t2[ss]);
        t2[ss] = null;
        t2[Ws](i2);
      }
      t2[Is]();
      this._current = this._stack.pop();
      this._current[Ws](t2) && t2[tn](this._ids);
      t2[es](this._builder);
    }
    onError(e2) {
      this._errorCode = e2;
    }
  }
  class XFAFactory {
    constructor(e2) {
      try {
        this.root = new XFAParser().parse(XFAFactory._createDocument(e2));
        const t2 = new Binder(this.root);
        this.form = t2.bind();
        this.dataHandler = new DataHandler(this.root, t2.getData());
        this.form[Fs].template = this.form;
      } catch (e3) {
        warn(`XFA - an error occurred during parsing and binding: ${e3}`);
      }
    }
    isValid() {
      return this.root && this.form;
    }
    _createPagesHelper() {
      const e2 = this.form[on]();
      return new Promise((t2, i2) => {
        const nextIteration = () => {
          try {
            const i3 = e2.next();
            i3.done ? t2(i3.value) : setTimeout(nextIteration, 0);
          } catch (e3) {
            i2(e3);
          }
        };
        setTimeout(nextIteration, 0);
      });
    }
    async _createPages() {
      try {
        this.pages = await this._createPagesHelper();
        this.dims = this.pages.children.map((e2) => {
          const { width: t2, height: i2 } = e2.attributes.style;
          return [
            0,
            0,
            parseInt(t2),
            parseInt(i2)
          ];
        });
      } catch (e2) {
        warn(`XFA - an error occurred during layout: ${e2}`);
      }
    }
    getBoundingBox(e2) {
      return this.dims[e2];
    }
    async getNumPages() {
      this.pages || await this._createPages();
      return this.dims.length;
    }
    setImages(e2) {
      this.form[Fs].images = e2;
    }
    setFonts(e2) {
      this.form[Fs].fontFinder = new FontFinder(e2);
      const t2 = [];
      for (let e3 of this.form[Fs].usedTypefaces) {
        e3 = stripQuotes(e3);
        this.form[Fs].fontFinder.find(e3) || t2.push(e3);
      }
      return t2.length > 0 ? t2 : null;
    }
    appendFonts(e2, t2) {
      this.form[Fs].fontFinder.add(e2, t2);
    }
    async getPages() {
      this.pages || await this._createPages();
      const e2 = this.pages;
      this.pages = null;
      return e2;
    }
    serializeData(e2) {
      return this.dataHandler.serialize(e2);
    }
    static _createDocument(e2) {
      return e2["/xdp:xdp"] ? Object.values(e2).join("") : e2["xdp:xdp"];
    }
    static getRichTextAsHtml(e2) {
      if (!e2 || "string" != typeof e2) return null;
      try {
        let t2 = new XFAParser(XhtmlNamespace, true).parse(e2);
        if (![
          "body",
          "xhtml"
        ].includes(t2[qs])) {
          const e3 = XhtmlNamespace.body({});
          e3[$r](t2);
          t2 = e3;
        }
        const i2 = t2[gn]();
        if (!i2.success) return null;
        const { html: a2 } = i2, { attributes: r2 } = a2;
        if (r2) {
          r2.class && (r2.class = r2.class.filter((e3) => !e3.startsWith("xfa")));
          r2.dir = "auto";
        }
        return {
          html: a2,
          str: t2[nn]()
        };
      } catch (e3) {
        warn(`XFA - an error occurred during parsing of rich text: ${e3}`);
      }
      return null;
    }
  }
  class AnnotationFactory {
    static createGlobals(e2) {
      return Promise.all([
        e2.ensureCatalog("acroForm"),
        e2.ensureDoc("xfaDatasets"),
        e2.ensureCatalog("structTreeRoot"),
        e2.ensureCatalog("baseUrl"),
        e2.ensureCatalog("attachments")
      ]).then(([t2, i2, a2, r2, s2]) => ({
        pdfManager: e2,
        acroForm: t2 instanceof Dict ? t2 : Dict.empty,
        xfaDatasets: i2,
        structTreeRoot: a2,
        baseUrl: r2,
        attachments: s2
      }), (e3) => {
        warn(`createGlobals: "${e3}".`);
        return null;
      });
    }
    static async create(e2, t2, i2, a2, r2, s2, n2) {
      const o2 = r2 ? await this._getPageIndex(e2, t2, i2.pdfManager) : null;
      return i2.pdfManager.ensure(this, "_create", [
        e2,
        t2,
        i2,
        a2,
        r2,
        s2,
        o2,
        n2
      ]);
    }
    static _create(e2, t2, i2, a2, r2 = false, s2 = null, n2 = null, o2 = null) {
      const g2 = e2.fetchIfRef(t2);
      if (!(g2 instanceof Dict)) return;
      const { acroForm: c2, pdfManager: C2 } = i2, h2 = t2 instanceof Ref ? t2.toString() : `annot_${a2.createObjId()}`;
      let l2 = g2.get("Subtype");
      l2 = l2 instanceof Name ? l2.name : null;
      const Q2 = {
        xref: e2,
        ref: t2,
        dict: g2,
        subtype: l2,
        id: h2,
        annotationGlobals: i2,
        collectFields: r2,
        orphanFields: s2,
        needAppearances: !r2 && true === c2.get("NeedAppearances"),
        pageIndex: n2,
        evaluatorOptions: C2.evaluatorOptions,
        pageRef: o2
      };
      switch (l2) {
        case "Link":
          return new LinkAnnotation(Q2);
        case "Text":
          return new TextAnnotation(Q2);
        case "Widget":
          let e3 = getInheritableProperty({
            dict: g2,
            key: "FT"
          });
          e3 = e3 instanceof Name ? e3.name : null;
          switch (e3) {
            case "Tx":
              return new TextWidgetAnnotation(Q2);
            case "Btn":
              return new ButtonWidgetAnnotation(Q2);
            case "Ch":
              return new ChoiceWidgetAnnotation(Q2);
            case "Sig":
              return new SignatureWidgetAnnotation(Q2);
          }
          warn(`Unimplemented widget field type "${e3}", falling back to base field type.`);
          return new WidgetAnnotation(Q2);
        case "Popup":
          return new PopupAnnotation(Q2);
        case "FreeText":
          return new FreeTextAnnotation(Q2);
        case "Line":
          return new LineAnnotation(Q2);
        case "Square":
          return new SquareAnnotation(Q2);
        case "Circle":
          return new CircleAnnotation(Q2);
        case "PolyLine":
          return new PolylineAnnotation(Q2);
        case "Polygon":
          return new PolygonAnnotation(Q2);
        case "Caret":
          return new CaretAnnotation(Q2);
        case "Ink":
          return new InkAnnotation(Q2);
        case "Highlight":
          return new HighlightAnnotation(Q2);
        case "Underline":
          return new UnderlineAnnotation(Q2);
        case "Squiggly":
          return new SquigglyAnnotation(Q2);
        case "StrikeOut":
          return new StrikeOutAnnotation(Q2);
        case "Stamp":
          return new StampAnnotation(Q2);
        case "FileAttachment":
          return new FileAttachmentAnnotation(Q2);
        default:
          r2 || warn(l2 ? `Unimplemented annotation type "${l2}", falling back to base annotation.` : "Annotation is missing the required /Subtype.");
          return new Annotation(Q2);
      }
    }
    static async _getPageIndex(e2, t2, i2) {
      try {
        const a2 = await e2.fetchIfRefAsync(t2);
        if (!(a2 instanceof Dict)) return -1;
        const r2 = a2.getRaw("P");
        if (r2 instanceof Ref) try {
          return await i2.ensureCatalog("getPageIndex", [
            r2
          ]);
        } catch (e3) {
          info(`_getPageIndex -- not a valid page reference: "${e3}".`);
        }
        if (a2.has("Kids")) return -1;
        const s2 = await i2.ensureDoc("numPages");
        for (let e3 = 0; e3 < s2; e3++) {
          const a3 = await i2.getPage(e3), r3 = await i2.ensure(a3, "annotations");
          for (const i3 of r3) if (i3 instanceof Ref && isRefsEqual(i3, t2)) return e3;
        }
      } catch (e3) {
        warn(`_getPageIndex: "${e3}".`);
      }
      return -1;
    }
    static generateImages(e2, t2, i2) {
      if (!i2) {
        warn("generateImages: OffscreenCanvas is not supported, cannot save or print some annotations with images.");
        return null;
      }
      let a2;
      for (const { bitmapId: i3, bitmap: r2 } of e2) if (r2) {
        a2 || (a2 = /* @__PURE__ */ new Map());
        a2.set(i3, StampAnnotation.createImage(r2, t2));
      }
      return a2;
    }
    static async saveNewAnnotations(e2, t2, i2, a2) {
      const r2 = e2.xref;
      let s2;
      const n2 = [], o2 = [], { isOffscreenCanvasSupported: g2 } = e2.options;
      for (const c2 of i2) if (!c2.deleted) switch (c2.annotationType) {
        case f:
          if (!s2) {
            const e3 = new Dict(r2);
            e3.set("BaseFont", Name.get("Helvetica"));
            e3.set("Type", Name.get("Font"));
            e3.set("Subtype", Name.get("Type1"));
            e3.set("Encoding", Name.get("WinAnsiEncoding"));
            const t3 = [];
            s2 = r2.getNewTemporaryRef();
            await writeObject(s2, e3, t3, r2);
            n2.push({
              ref: s2,
              data: t3.join("")
            });
          }
          o2.push(FreeTextAnnotation.createNewAnnotation(r2, c2, n2, {
            evaluator: e2,
            task: t2,
            baseFontRef: s2
          }));
          break;
        case p:
          c2.quadPoints ? o2.push(HighlightAnnotation.createNewAnnotation(r2, c2, n2)) : o2.push(InkAnnotation.createNewAnnotation(r2, c2, n2));
          break;
        case y:
          o2.push(InkAnnotation.createNewAnnotation(r2, c2, n2));
          break;
        case m:
          const i3 = g2 ? await (a2 == null ? void 0 : a2.get(c2.bitmapId)) : null;
          if (i3 == null ? void 0 : i3.imageStream) {
            const { imageStream: e3, smaskStream: t3 } = i3, a3 = [];
            if (t3) {
              const i4 = r2.getNewTemporaryRef();
              await writeObject(i4, t3, a3, r2);
              n2.push({
                ref: i4,
                data: a3.join("")
              });
              e3.dict.set("SMask", i4);
              a3.length = 0;
            }
            const s3 = i3.imageRef = r2.getNewTemporaryRef();
            await writeObject(s3, e3, a3, r2);
            n2.push({
              ref: s3,
              data: a3.join("")
            });
            i3.imageStream = i3.smaskStream = null;
          }
          o2.push(StampAnnotation.createNewAnnotation(r2, c2, n2, {
            image: i3
          }));
      }
      return {
        annotations: await Promise.all(o2),
        dependencies: n2
      };
    }
    static async printNewAnnotations(e2, t2, i2, a2, r2) {
      if (!a2) return null;
      const { options: s2, xref: n2 } = t2, o2 = [];
      for (const g2 of a2) if (!g2.deleted) switch (g2.annotationType) {
        case f:
          o2.push(FreeTextAnnotation.createNewPrintAnnotation(e2, n2, g2, {
            evaluator: t2,
            task: i2,
            evaluatorOptions: s2
          }));
          break;
        case p:
          g2.quadPoints ? o2.push(HighlightAnnotation.createNewPrintAnnotation(e2, n2, g2, {
            evaluatorOptions: s2
          })) : o2.push(InkAnnotation.createNewPrintAnnotation(e2, n2, g2, {
            evaluatorOptions: s2
          }));
          break;
        case y:
          o2.push(InkAnnotation.createNewPrintAnnotation(e2, n2, g2, {
            evaluatorOptions: s2
          }));
          break;
        case m:
          const a3 = s2.isOffscreenCanvasSupported ? await (r2 == null ? void 0 : r2.get(g2.bitmapId)) : null;
          if (a3 == null ? void 0 : a3.imageStream) {
            const { imageStream: e3, smaskStream: t3 } = a3;
            t3 && e3.dict.set("SMask", t3);
            a3.imageRef = new JpegStream(e3, e3.length);
            a3.imageStream = a3.smaskStream = null;
          }
          o2.push(StampAnnotation.createNewPrintAnnotation(e2, n2, g2, {
            image: a3,
            evaluatorOptions: s2
          }));
      }
      return Promise.all(o2);
    }
  }
  function getRgbColor(e2, t2 = new Uint8ClampedArray(3)) {
    if (!Array.isArray(e2)) return t2;
    const i2 = t2 || new Uint8ClampedArray(3);
    switch (e2.length) {
      case 0:
        return null;
      case 1:
        ColorSpace.singletons.gray.getRgbItem(e2, 0, i2, 0);
        return i2;
      case 3:
        ColorSpace.singletons.rgb.getRgbItem(e2, 0, i2, 0);
        return i2;
      case 4:
        ColorSpace.singletons.cmyk.getRgbItem(e2, 0, i2, 0);
        return i2;
      default:
        return t2;
    }
  }
  function getPdfColorArray(e2) {
    return Array.from(e2, (e3) => e3 / 255);
  }
  function getQuadPoints(e2, t2) {
    const i2 = e2.getArray("QuadPoints");
    if (!isNumberArray(i2, null) || 0 === i2.length || i2.length % 8 > 0) return null;
    const a2 = new Float32Array(i2.length);
    for (let e3 = 0, r2 = i2.length; e3 < r2; e3 += 8) {
      const [r3, s2, n2, o2, g2, c2, C2, h2] = i2.slice(e3, e3 + 8), l2 = Math.min(r3, n2, g2, C2), Q2 = Math.max(r3, n2, g2, C2), E2 = Math.min(s2, o2, c2, h2), u2 = Math.max(s2, o2, c2, h2);
      if (null !== t2 && (l2 < t2[0] || Q2 > t2[2] || E2 < t2[1] || u2 > t2[3])) return null;
      a2.set([
        l2,
        u2,
        Q2,
        u2,
        l2,
        E2,
        Q2,
        E2
      ], e3);
    }
    return a2;
  }
  function getTransformMatrix(e2, t2, i2) {
    const [a2, r2, s2, n2] = Util.getAxialAlignedBoundingBox(t2, i2);
    if (a2 === s2 || r2 === n2) return [
      1,
      0,
      0,
      1,
      e2[0],
      e2[1]
    ];
    const o2 = (e2[2] - e2[0]) / (s2 - a2), g2 = (e2[3] - e2[1]) / (n2 - r2);
    return [
      o2,
      0,
      0,
      g2,
      e2[0] - a2 * o2,
      e2[1] - r2 * g2
    ];
  }
  class Annotation {
    constructor(e2) {
      const { dict: t2, xref: i2, annotationGlobals: a2, ref: r2, orphanFields: s2 } = e2, n2 = s2 == null ? void 0 : s2.get(r2);
      n2 && t2.set("Parent", n2);
      this.setTitle(t2.get("T"));
      this.setContents(t2.get("Contents"));
      this.setModificationDate(t2.get("M"));
      this.setFlags(t2.get("F"));
      this.setRectangle(t2.getArray("Rect"));
      this.setColor(t2.getArray("C"));
      this.setBorderStyle(t2);
      this.setAppearance(t2);
      this.setOptionalContent(t2);
      const o2 = t2.get("MK");
      this.setBorderAndBackgroundColors(o2);
      this.setRotation(o2, t2);
      this.ref = e2.ref instanceof Ref ? e2.ref : null;
      this._streams = [];
      this.appearance && this._streams.push(this.appearance);
      const g2 = !!(this.flags & iA), c2 = !!(this.flags & aA);
      this.data = {
        annotationFlags: this.flags,
        borderStyle: this.borderStyle,
        color: this.color,
        backgroundColor: this.backgroundColor,
        borderColor: this.borderColor,
        rotation: this.rotation,
        contentsObj: this._contents,
        hasAppearance: !!this.appearance,
        id: e2.id,
        modificationDate: this.modificationDate,
        rect: this.rectangle,
        subtype: e2.subtype,
        hasOwnCanvas: false,
        noRotate: !!(this.flags & eA),
        noHTML: g2 && c2,
        isEditable: false,
        structParent: -1
      };
      if (a2.structTreeRoot) {
        let i3 = t2.get("StructParent");
        this.data.structParent = i3 = Number.isInteger(i3) && i3 >= 0 ? i3 : -1;
        a2.structTreeRoot.addAnnotationIdToPage(e2.pageRef, i3);
      }
      if (e2.collectFields) {
        const a3 = t2.get("Kids");
        if (Array.isArray(a3)) {
          const e3 = [];
          for (const t3 of a3) t3 instanceof Ref && e3.push(t3.toString());
          0 !== e3.length && (this.data.kidIds = e3);
        }
        this.data.actions = collectActions(i2, t2, pA);
        this.data.fieldName = this._constructFieldName(t2);
        this.data.pageIndex = e2.pageIndex;
      }
      const C2 = t2.get("IT");
      C2 instanceof Name && (this.data.it = C2.name);
      this._isOffscreenCanvasSupported = e2.evaluatorOptions.isOffscreenCanvasSupported;
      this._fallbackFontDict = null;
      this._needAppearances = false;
    }
    _hasFlag(e2, t2) {
      return !!(e2 & t2);
    }
    _buildFlags(e2, t2) {
      let { flags: i2 } = this;
      if (void 0 === e2) {
        if (void 0 === t2) return;
        return t2 ? i2 & ~AA : i2 & ~$ | AA;
      }
      if (e2) {
        i2 |= AA;
        return t2 ? i2 & ~tA | $ : i2 & ~$ | tA;
      }
      i2 &= ~($ | tA);
      return t2 ? i2 & ~AA : i2 | AA;
    }
    _isViewable(e2) {
      return !this._hasFlag(e2, z) && !this._hasFlag(e2, tA);
    }
    _isPrintable(e2) {
      return this._hasFlag(e2, AA) && !this._hasFlag(e2, $) && !this._hasFlag(e2, z);
    }
    mustBeViewed(e2, t2) {
      var _a4;
      const i2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.noView;
      return void 0 !== i2 ? !i2 : this.viewable && !this._hasFlag(this.flags, $);
    }
    mustBePrinted(e2) {
      var _a4;
      const t2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.noPrint;
      return void 0 !== t2 ? !t2 : this.printable;
    }
    mustBeViewedWhenEditing(e2, t2 = null) {
      return e2 ? !this.data.isEditable : !(t2 == null ? void 0 : t2.has(this.data.id));
    }
    get viewable() {
      return null !== this.data.quadPoints && (0 === this.flags || this._isViewable(this.flags));
    }
    get printable() {
      return null !== this.data.quadPoints && (0 !== this.flags && this._isPrintable(this.flags));
    }
    _parseStringHelper(e2) {
      const t2 = "string" == typeof e2 ? stringToPDFString(e2) : "";
      return {
        str: t2,
        dir: t2 && "rtl" === bidi(t2).dir ? "rtl" : "ltr"
      };
    }
    setDefaultAppearance(e2) {
      const { dict: t2, annotationGlobals: i2 } = e2, a2 = getInheritableProperty({
        dict: t2,
        key: "DA"
      }) || i2.acroForm.get("DA");
      this._defaultAppearance = "string" == typeof a2 ? a2 : "";
      this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance);
    }
    setTitle(e2) {
      this._title = this._parseStringHelper(e2);
    }
    setContents(e2) {
      this._contents = this._parseStringHelper(e2);
    }
    setModificationDate(e2) {
      this.modificationDate = "string" == typeof e2 ? e2 : null;
    }
    setFlags(e2) {
      this.flags = Number.isInteger(e2) && e2 > 0 ? e2 : 0;
      this.flags & z && "Annotation" !== this.constructor.name && (this.flags ^= z);
    }
    hasFlag(e2) {
      return this._hasFlag(this.flags, e2);
    }
    setRectangle(e2) {
      this.rectangle = lookupNormalRect(e2, [
        0,
        0,
        0,
        0
      ]);
    }
    setColor(e2) {
      this.color = getRgbColor(e2);
    }
    setLineEndings(e2) {
      this.lineEndings = [
        "None",
        "None"
      ];
      if (Array.isArray(e2) && 2 === e2.length) for (let t2 = 0; t2 < 2; t2++) {
        const i2 = e2[t2];
        if (i2 instanceof Name) switch (i2.name) {
          case "None":
            continue;
          case "Square":
          case "Circle":
          case "Diamond":
          case "OpenArrow":
          case "ClosedArrow":
          case "Butt":
          case "ROpenArrow":
          case "RClosedArrow":
          case "Slash":
            this.lineEndings[t2] = i2.name;
            continue;
        }
        warn(`Ignoring invalid lineEnding: ${i2}`);
      }
    }
    setRotation(e2, t2) {
      this.rotation = 0;
      let i2 = e2 instanceof Dict ? e2.get("R") || 0 : t2.get("Rotate") || 0;
      if (Number.isInteger(i2) && 0 !== i2) {
        i2 %= 360;
        i2 < 0 && (i2 += 360);
        i2 % 90 == 0 && (this.rotation = i2);
      }
    }
    setBorderAndBackgroundColors(e2) {
      if (e2 instanceof Dict) {
        this.borderColor = getRgbColor(e2.getArray("BC"), null);
        this.backgroundColor = getRgbColor(e2.getArray("BG"), null);
      } else this.borderColor = this.backgroundColor = null;
    }
    setBorderStyle(e2) {
      this.borderStyle = new AnnotationBorderStyle();
      if (e2 instanceof Dict) if (e2.has("BS")) {
        const t2 = e2.get("BS");
        if (t2 instanceof Dict) {
          const e3 = t2.get("Type");
          if (!e3 || isName(e3, "Border")) {
            this.borderStyle.setWidth(t2.get("W"), this.rectangle);
            this.borderStyle.setStyle(t2.get("S"));
            this.borderStyle.setDashArray(t2.getArray("D"));
          }
        }
      } else if (e2.has("Border")) {
        const t2 = e2.getArray("Border");
        if (Array.isArray(t2) && t2.length >= 3) {
          this.borderStyle.setHorizontalCornerRadius(t2[0]);
          this.borderStyle.setVerticalCornerRadius(t2[1]);
          this.borderStyle.setWidth(t2[2], this.rectangle);
          4 === t2.length && this.borderStyle.setDashArray(t2[3], true);
        }
      } else this.borderStyle.setWidth(0);
    }
    setAppearance(e2) {
      this.appearance = null;
      const t2 = e2.get("AP");
      if (!(t2 instanceof Dict)) return;
      const i2 = t2.get("N");
      if (i2 instanceof BaseStream) {
        this.appearance = i2;
        return;
      }
      if (!(i2 instanceof Dict)) return;
      const a2 = e2.get("AS");
      if (!(a2 instanceof Name && i2.has(a2.name))) return;
      const r2 = i2.get(a2.name);
      r2 instanceof BaseStream && (this.appearance = r2);
    }
    setOptionalContent(e2) {
      this.oc = null;
      const t2 = e2.get("OC");
      t2 instanceof Name ? warn("setOptionalContent: Support for /Name-entry is not implemented.") : t2 instanceof Dict && (this.oc = t2);
    }
    loadResources(e2, t2) {
      return t2.dict.getAsync("Resources").then((t3) => {
        if (!t3) return;
        return new ObjectLoader(t3, e2, t3.xref).load().then(function() {
          return t3;
        });
      });
    }
    async getOperatorList(e2, t2, i2, r2) {
      const { hasOwnCanvas: s2, id: n2, rect: o2 } = this.data;
      let g2 = this.appearance;
      const C2 = !!(s2 && i2 & c);
      if (C2 && (o2[0] === o2[2] || o2[1] === o2[3])) {
        this.data.hasOwnCanvas = false;
        return {
          opList: new OperatorList(),
          separateForm: false,
          separateCanvas: false
        };
      }
      if (!g2) {
        if (!C2) return {
          opList: new OperatorList(),
          separateForm: false,
          separateCanvas: false
        };
        g2 = new StringStream("");
        g2.dict = new Dict();
      }
      const h2 = g2.dict, l2 = await this.loadResources([
        "ExtGState",
        "ColorSpace",
        "Pattern",
        "Shading",
        "XObject",
        "Font"
      ], g2), Q2 = lookupRect(h2.getArray("BBox"), [
        0,
        0,
        1,
        1
      ]), E2 = lookupMatrix(h2.getArray("Matrix"), a), u2 = getTransformMatrix(o2, Q2, E2), d2 = new OperatorList();
      let f2;
      this.oc && (f2 = await e2.parseMarkedContentProps(this.oc, null));
      void 0 !== f2 && d2.addOp(Ye, [
        "OC",
        f2
      ]);
      d2.addOp(Xe, [
        n2,
        o2,
        u2,
        E2,
        C2
      ]);
      await e2.getOperatorList({
        stream: g2,
        task: t2,
        resources: l2,
        operatorList: d2,
        fallbackFontDict: this._fallbackFontDict
      });
      d2.addOp(Ze, []);
      void 0 !== f2 && d2.addOp(Te, []);
      this.reset();
      return {
        opList: d2,
        separateForm: false,
        separateCanvas: C2
      };
    }
    async save(e2, t2, i2) {
      return null;
    }
    get hasTextContent() {
      return false;
    }
    async extractTextContent(e2, t2, i2) {
      if (!this.appearance) return;
      const a2 = await this.loadResources([
        "ExtGState",
        "Font",
        "Properties",
        "XObject"
      ], this.appearance), r2 = [], s2 = [];
      let n2 = null;
      const o2 = {
        desiredSize: Math.Infinity,
        ready: true,
        enqueue(e3, t3) {
          for (const t4 of e3.items) if (void 0 !== t4.str) {
            n2 || (n2 = t4.transform.slice(-2));
            s2.push(t4.str);
            if (t4.hasEOL) {
              r2.push(s2.join("").trimEnd());
              s2.length = 0;
            }
          }
        }
      };
      await e2.getTextContent({
        stream: this.appearance,
        task: t2,
        resources: a2,
        includeMarkedContent: true,
        keepWhiteSpace: true,
        sink: o2,
        viewBox: i2
      });
      this.reset();
      s2.length && r2.push(s2.join("").trimEnd());
      if (r2.length > 1 || r2[0]) {
        const e3 = this.appearance.dict, t3 = lookupRect(e3.getArray("BBox"), null), i3 = lookupMatrix(e3.getArray("Matrix"), null);
        this.data.textPosition = this._transformPoint(n2, t3, i3);
        this.data.textContent = r2;
      }
    }
    _transformPoint(e2, t2, i2) {
      const { rect: a2 } = this.data;
      t2 || (t2 = [
        0,
        0,
        1,
        1
      ]);
      i2 || (i2 = [
        1,
        0,
        0,
        1,
        0,
        0
      ]);
      const r2 = getTransformMatrix(a2, t2, i2);
      r2[4] -= a2[0];
      r2[5] -= a2[1];
      e2 = Util.applyTransform(e2, r2);
      return Util.applyTransform(e2, i2);
    }
    getFieldObject() {
      return this.data.kidIds ? {
        id: this.data.id,
        actions: this.data.actions,
        name: this.data.fieldName,
        strokeColor: this.data.borderColor,
        fillColor: this.data.backgroundColor,
        type: "",
        kidIds: this.data.kidIds,
        page: this.data.pageIndex,
        rotation: this.rotation
      } : null;
    }
    reset() {
      for (const e2 of this._streams) e2.reset();
    }
    _constructFieldName(e2) {
      if (!e2.has("T") && !e2.has("Parent")) {
        warn("Unknown field name, falling back to empty field name.");
        return "";
      }
      if (!e2.has("Parent")) return stringToPDFString(e2.get("T"));
      const t2 = [];
      e2.has("T") && t2.unshift(stringToPDFString(e2.get("T")));
      let i2 = e2;
      const a2 = new RefSet();
      e2.objId && a2.put(e2.objId);
      for (; i2.has("Parent"); ) {
        i2 = i2.get("Parent");
        if (!(i2 instanceof Dict) || i2.objId && a2.has(i2.objId)) break;
        i2.objId && a2.put(i2.objId);
        i2.has("T") && t2.unshift(stringToPDFString(i2.get("T")));
      }
      return t2.join(".");
    }
  }
  class AnnotationBorderStyle {
    constructor() {
      this.width = 1;
      this.rawWidth = 1;
      this.style = QA;
      this.dashArray = [
        3
      ];
      this.horizontalCornerRadius = 0;
      this.verticalCornerRadius = 0;
    }
    setWidth(e2, t2 = [
      0,
      0,
      0,
      0
    ]) {
      if (e2 instanceof Name) this.width = 0;
      else if ("number" == typeof e2) {
        if (e2 > 0) {
          this.rawWidth = e2;
          const i2 = (t2[2] - t2[0]) / 2, a2 = (t2[3] - t2[1]) / 2;
          if (i2 > 0 && a2 > 0 && (e2 > i2 || e2 > a2)) {
            warn(`AnnotationBorderStyle.setWidth - ignoring width: ${e2}`);
            e2 = 1;
          }
        }
        this.width = e2;
      }
    }
    setStyle(e2) {
      if (e2 instanceof Name) switch (e2.name) {
        case "S":
          this.style = QA;
          break;
        case "D":
          this.style = EA;
          break;
        case "B":
          this.style = uA;
          break;
        case "I":
          this.style = dA;
          break;
        case "U":
          this.style = fA;
      }
    }
    setDashArray(e2, t2 = false) {
      if (Array.isArray(e2)) {
        let i2 = true, a2 = true;
        for (const t3 of e2) {
          if (!(+t3 >= 0)) {
            i2 = false;
            break;
          }
          t3 > 0 && (a2 = false);
        }
        if (0 === e2.length || i2 && !a2) {
          this.dashArray = e2;
          t2 && this.setStyle(Name.get("D"));
        } else this.width = 0;
      } else e2 && (this.width = 0);
    }
    setHorizontalCornerRadius(e2) {
      Number.isInteger(e2) && (this.horizontalCornerRadius = e2);
    }
    setVerticalCornerRadius(e2) {
      Number.isInteger(e2) && (this.verticalCornerRadius = e2);
    }
  }
  class MarkupAnnotation extends Annotation {
    constructor(e2) {
      super(e2);
      const { dict: t2 } = e2;
      if (t2.has("IRT")) {
        const e3 = t2.getRaw("IRT");
        this.data.inReplyTo = e3 instanceof Ref ? e3.toString() : null;
        const i3 = t2.get("RT");
        this.data.replyType = i3 instanceof Name ? i3.name : _;
      }
      let i2 = null;
      if (this.data.replyType === V) {
        const e3 = t2.get("IRT");
        this.setTitle(e3.get("T"));
        this.data.titleObj = this._title;
        this.setContents(e3.get("Contents"));
        this.data.contentsObj = this._contents;
        if (e3.has("CreationDate")) {
          this.setCreationDate(e3.get("CreationDate"));
          this.data.creationDate = this.creationDate;
        } else this.data.creationDate = null;
        if (e3.has("M")) {
          this.setModificationDate(e3.get("M"));
          this.data.modificationDate = this.modificationDate;
        } else this.data.modificationDate = null;
        i2 = e3.getRaw("Popup");
        if (e3.has("C")) {
          this.setColor(e3.getArray("C"));
          this.data.color = this.color;
        } else this.data.color = null;
      } else {
        this.data.titleObj = this._title;
        this.setCreationDate(t2.get("CreationDate"));
        this.data.creationDate = this.creationDate;
        i2 = t2.getRaw("Popup");
        t2.has("C") || (this.data.color = null);
      }
      this.data.popupRef = i2 instanceof Ref ? i2.toString() : null;
      t2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(t2.get("RC")));
    }
    setCreationDate(e2) {
      this.creationDate = "string" == typeof e2 ? e2 : null;
    }
    _setDefaultAppearance({ xref: e2, extra: t2, strokeColor: i2, fillColor: a2, blendMode: r2, strokeAlpha: s2, fillAlpha: n2, pointsCallback: o2 }) {
      let g2 = Number.MAX_VALUE, c2 = Number.MAX_VALUE, C2 = Number.MIN_VALUE, h2 = Number.MIN_VALUE;
      const l2 = [
        "q"
      ];
      t2 && l2.push(t2);
      i2 && l2.push(`${i2[0]} ${i2[1]} ${i2[2]} RG`);
      a2 && l2.push(`${a2[0]} ${a2[1]} ${a2[2]} rg`);
      let Q2 = this.data.quadPoints;
      Q2 || (Q2 = Float32Array.from([
        this.rectangle[0],
        this.rectangle[3],
        this.rectangle[2],
        this.rectangle[3],
        this.rectangle[0],
        this.rectangle[1],
        this.rectangle[2],
        this.rectangle[1]
      ]));
      for (let e3 = 0, t3 = Q2.length; e3 < t3; e3 += 8) {
        const [t4, i3, a3, r3] = o2(l2, Q2.subarray(e3, e3 + 8));
        g2 = Math.min(g2, t4);
        C2 = Math.max(C2, i3);
        c2 = Math.min(c2, a3);
        h2 = Math.max(h2, r3);
      }
      l2.push("Q");
      const E2 = new Dict(e2), u2 = new Dict(e2);
      u2.set("Subtype", Name.get("Form"));
      const d2 = new StringStream(l2.join(" "));
      d2.dict = u2;
      E2.set("Fm0", d2);
      const f2 = new Dict(e2);
      r2 && f2.set("BM", Name.get(r2));
      "number" == typeof s2 && f2.set("CA", s2);
      "number" == typeof n2 && f2.set("ca", n2);
      const p2 = new Dict(e2);
      p2.set("GS0", f2);
      const m2 = new Dict(e2);
      m2.set("ExtGState", p2);
      m2.set("XObject", E2);
      const y2 = new Dict(e2);
      y2.set("Resources", m2);
      const w2 = this.data.rect = [
        g2,
        c2,
        C2,
        h2
      ];
      y2.set("BBox", w2);
      this.appearance = new StringStream("/GS0 gs /Fm0 Do");
      this.appearance.dict = y2;
      this._streams.push(this.appearance, d2);
    }
    static async createNewAnnotation(e2, t2, i2, a2) {
      t2.ref || (t2.ref = e2.getNewTemporaryRef());
      const r2 = t2.ref, s2 = await this.createNewAppearanceStream(t2, e2, a2), n2 = [];
      let o2;
      if (s2) {
        const a3 = e2.getNewTemporaryRef();
        o2 = this.createNewDict(t2, e2, {
          apRef: a3
        });
        await writeObject(a3, s2, n2, e2);
        i2.push({
          ref: a3,
          data: n2.join("")
        });
      } else o2 = this.createNewDict(t2, e2, {});
      Number.isInteger(t2.parentTreeId) && o2.set("StructParent", t2.parentTreeId);
      n2.length = 0;
      await writeObject(r2, o2, n2, e2);
      return {
        ref: r2,
        data: n2.join("")
      };
    }
    static async createNewPrintAnnotation(e2, t2, i2, a2) {
      const r2 = await this.createNewAppearanceStream(i2, t2, a2), s2 = this.createNewDict(i2, t2, r2 ? {
        ap: r2
      } : {}), n2 = new this.prototype.constructor({
        dict: s2,
        xref: t2,
        annotationGlobals: e2,
        evaluatorOptions: a2.evaluatorOptions
      });
      i2.ref && (n2.ref = n2.refToReplace = i2.ref);
      return n2;
    }
  }
  class WidgetAnnotation extends Annotation {
    constructor(e2) {
      var _a4;
      super(e2);
      const { dict: t2, xref: i2, annotationGlobals: a2 } = e2, r2 = this.data;
      this._needAppearances = e2.needAppearances;
      r2.annotationType = Z;
      void 0 === r2.fieldName && (r2.fieldName = this._constructFieldName(t2));
      void 0 === r2.actions && (r2.actions = collectActions(i2, t2, pA));
      let s2 = getInheritableProperty({
        dict: t2,
        key: "V",
        getArray: true
      });
      r2.fieldValue = this._decodeFormValue(s2);
      const n2 = getInheritableProperty({
        dict: t2,
        key: "DV",
        getArray: true
      });
      r2.defaultFieldValue = this._decodeFormValue(n2);
      if (void 0 === s2 && a2.xfaDatasets) {
        const e3 = this._title.str;
        if (e3) {
          this._hasValueFromXFA = true;
          r2.fieldValue = s2 = a2.xfaDatasets.getValue(e3);
        }
      }
      void 0 === s2 && null !== r2.defaultFieldValue && (r2.fieldValue = r2.defaultFieldValue);
      r2.alternativeText = stringToPDFString(t2.get("TU") || "");
      this.setDefaultAppearance(e2);
      r2.hasAppearance || (r2.hasAppearance = this._needAppearances && void 0 !== r2.fieldValue && null !== r2.fieldValue);
      const o2 = getInheritableProperty({
        dict: t2,
        key: "FT"
      });
      r2.fieldType = o2 instanceof Name ? o2.name : null;
      const g2 = getInheritableProperty({
        dict: t2,
        key: "DR"
      }), c2 = a2.acroForm.get("DR"), C2 = (_a4 = this.appearance) == null ? void 0 : _a4.dict.get("Resources");
      this._fieldResources = {
        localResources: g2,
        acroFormResources: c2,
        appearanceResources: C2,
        mergedResources: Dict.merge({
          xref: i2,
          dictArray: [
            g2,
            C2,
            c2
          ],
          mergeSubDicts: true
        })
      };
      r2.fieldFlags = getInheritableProperty({
        dict: t2,
        key: "Ff"
      });
      (!Number.isInteger(r2.fieldFlags) || r2.fieldFlags < 0) && (r2.fieldFlags = 0);
      r2.readOnly = this.hasFieldFlag(rA);
      r2.required = this.hasFieldFlag(sA);
      r2.hidden = this._hasFlag(r2.annotationFlags, $) || this._hasFlag(r2.annotationFlags, tA);
    }
    _decodeFormValue(e2) {
      return Array.isArray(e2) ? e2.filter((e3) => "string" == typeof e3).map((e3) => stringToPDFString(e3)) : e2 instanceof Name ? stringToPDFString(e2.name) : "string" == typeof e2 ? stringToPDFString(e2) : null;
    }
    hasFieldFlag(e2) {
      return !!(this.data.fieldFlags & e2);
    }
    _isViewable(e2) {
      return true;
    }
    mustBeViewed(e2, t2) {
      return t2 ? this.viewable : super.mustBeViewed(e2, t2) && !this._hasFlag(this.flags, tA);
    }
    getRotationMatrix(e2) {
      var _a4;
      let t2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.rotation;
      void 0 === t2 && (t2 = this.rotation);
      if (0 === t2) return a;
      return getRotationMatrix(t2, this.data.rect[2] - this.data.rect[0], this.data.rect[3] - this.data.rect[1]);
    }
    getBorderAndBackgroundAppearances(e2) {
      var _a4;
      let t2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.rotation;
      void 0 === t2 && (t2 = this.rotation);
      if (!this.backgroundColor && !this.borderColor) return "";
      const i2 = this.data.rect[2] - this.data.rect[0], a2 = this.data.rect[3] - this.data.rect[1], r2 = 0 === t2 || 180 === t2 ? `0 0 ${i2} ${a2} re` : `0 0 ${a2} ${i2} re`;
      let s2 = "";
      this.backgroundColor && (s2 = `${getPdfColor(this.backgroundColor, true)} ${r2} f `);
      if (this.borderColor) {
        s2 += `${this.borderStyle.width || 1} w ${getPdfColor(this.borderColor, false)} ${r2} S `;
      }
      return s2;
    }
    async getOperatorList(e2, t2, i2, a2) {
      if (i2 & l && !(this instanceof SignatureWidgetAnnotation) && !this.data.noHTML && !this.data.hasOwnCanvas) return {
        opList: new OperatorList(),
        separateForm: true,
        separateCanvas: false
      };
      if (!this._hasText) return super.getOperatorList(e2, t2, i2, a2);
      const r2 = await this._getAppearance(e2, t2, i2, a2);
      if (this.appearance && null === r2) return super.getOperatorList(e2, t2, i2, a2);
      const s2 = new OperatorList();
      if (!this._defaultAppearance || null === r2) return {
        opList: s2,
        separateForm: false,
        separateCanvas: false
      };
      const n2 = !!(this.data.hasOwnCanvas && i2 & c), o2 = [
        0,
        0,
        this.data.rect[2] - this.data.rect[0],
        this.data.rect[3] - this.data.rect[1]
      ], g2 = getTransformMatrix(this.data.rect, o2, [
        1,
        0,
        0,
        1,
        0,
        0
      ]);
      let C2;
      this.oc && (C2 = await e2.parseMarkedContentProps(this.oc, null));
      void 0 !== C2 && s2.addOp(Ye, [
        "OC",
        C2
      ]);
      s2.addOp(Xe, [
        this.data.id,
        this.data.rect,
        g2,
        this.getRotationMatrix(a2),
        n2
      ]);
      const h2 = new StringStream(r2);
      await e2.getOperatorList({
        stream: h2,
        task: t2,
        resources: this._fieldResources.mergedResources,
        operatorList: s2
      });
      s2.addOp(Ze, []);
      void 0 !== C2 && s2.addOp(Te, []);
      return {
        opList: s2,
        separateForm: false,
        separateCanvas: n2
      };
    }
    _getMKDict(e2) {
      const t2 = new Dict(null);
      e2 && t2.set("R", e2);
      this.borderColor && t2.set("BC", getPdfColorArray(this.borderColor));
      this.backgroundColor && t2.set("BG", getPdfColorArray(this.backgroundColor));
      return t2.size > 0 ? t2 : null;
    }
    amendSavedDict(e2, t2) {
    }
    async save(e2, t2, i2) {
      const r2 = i2 == null ? void 0 : i2.get(this.data.id), s2 = this._buildFlags(r2 == null ? void 0 : r2.noView, r2 == null ? void 0 : r2.noPrint);
      let n2 = r2 == null ? void 0 : r2.value, o2 = r2 == null ? void 0 : r2.rotation;
      if (n2 === this.data.fieldValue || void 0 === n2) {
        if (!this._hasValueFromXFA && void 0 === o2 && void 0 === s2) return null;
        n2 || (n2 = this.data.fieldValue);
      }
      if (void 0 === o2 && !this._hasValueFromXFA && Array.isArray(n2) && Array.isArray(this.data.fieldValue) && isArrayEqual(n2, this.data.fieldValue) && void 0 === s2) return null;
      void 0 === o2 && (o2 = this.rotation);
      let g2 = null;
      if (!this._needAppearances) {
        g2 = await this._getAppearance(e2, t2, h, i2);
        if (null === g2 && void 0 === s2) return null;
      }
      let c2 = false;
      if (g2 == null ? void 0 : g2.needAppearances) {
        c2 = true;
        g2 = null;
      }
      const { xref: C2 } = e2, l2 = C2.fetchIfRef(this.ref);
      if (!(l2 instanceof Dict)) return null;
      const Q2 = new Dict(C2);
      for (const e3 of l2.getKeys()) "AP" !== e3 && Q2.set(e3, l2.getRaw(e3));
      if (void 0 !== s2) {
        Q2.set("F", s2);
        if (null === g2 && !c2) {
          const e3 = l2.getRaw("AP");
          e3 && Q2.set("AP", e3);
        }
      }
      const E2 = {
        path: this.data.fieldName,
        value: n2
      };
      Q2.set("V", Array.isArray(n2) ? n2.map(stringToAsciiOrUTF16BE) : stringToAsciiOrUTF16BE(n2));
      this.amendSavedDict(i2, Q2);
      const u2 = this._getMKDict(o2);
      u2 && Q2.set("MK", u2);
      const d2 = [], f2 = [
        {
          ref: this.ref,
          data: "",
          xfa: E2,
          needAppearances: c2
        }
      ];
      if (null !== g2) {
        const e3 = C2.getNewTemporaryRef(), t3 = new Dict(C2);
        Q2.set("AP", t3);
        t3.set("N", e3);
        const r3 = this._getSaveFieldResources(C2), s3 = new StringStream(g2), n3 = s3.dict = new Dict(C2);
        n3.set("Subtype", Name.get("Form"));
        n3.set("Resources", r3);
        n3.set("BBox", [
          0,
          0,
          this.data.rect[2] - this.data.rect[0],
          this.data.rect[3] - this.data.rect[1]
        ]);
        const o3 = this.getRotationMatrix(i2);
        o3 !== a && n3.set("Matrix", o3);
        await writeObject(e3, s3, d2, C2);
        f2.push({
          ref: e3,
          data: d2.join(""),
          xfa: null,
          needAppearances: false
        });
        d2.length = 0;
      }
      Q2.set("M", `D:${getModificationDate()}`);
      await writeObject(this.ref, Q2, d2, C2);
      f2[0].data = d2.join("");
      return f2;
    }
    async _getAppearance(e2, t2, i2, a2) {
      if (this.hasFieldFlag(oA)) return null;
      const r2 = a2 == null ? void 0 : a2.get(this.data.id);
      let s2, n2;
      if (r2) {
        s2 = r2.formattedValue || r2.value;
        n2 = r2.rotation;
      }
      if (void 0 === n2 && void 0 === s2 && !this._needAppearances && (!this._hasValueFromXFA || this.appearance)) return null;
      const g2 = this.getBorderAndBackgroundAppearances(a2);
      if (void 0 === s2) {
        s2 = this.data.fieldValue;
        if (!s2) return `/Tx BMC q ${g2}Q EMC`;
      }
      Array.isArray(s2) && 1 === s2.length && (s2 = s2[0]);
      assert("string" == typeof s2, "Expected `value` to be a string.");
      s2 = s2.trimEnd();
      if (this.data.combo) {
        const e3 = this.data.options.find(({ exportValue: e4 }) => s2 === e4);
        s2 = (e3 == null ? void 0 : e3.displayValue) || s2;
      }
      if ("" === s2) return `/Tx BMC q ${g2}Q EMC`;
      void 0 === n2 && (n2 = this.rotation);
      let c2, C2 = -1;
      if (this.data.multiLine) {
        c2 = s2.split(/\r\n?|\n/).map((e3) => e3.normalize("NFC"));
        C2 = c2.length;
      } else c2 = [
        s2.replace(/\r\n?|\n/, "").normalize("NFC")
      ];
      let l2 = this.data.rect[3] - this.data.rect[1], Q2 = this.data.rect[2] - this.data.rect[0];
      90 !== n2 && 270 !== n2 || ([Q2, l2] = [
        l2,
        Q2
      ]);
      this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
      let E2, u2, d2, f2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
      const p2 = [];
      let m2 = false;
      for (const e3 of c2) {
        const t3 = f2.encodeString(e3);
        t3.length > 1 && (m2 = true);
        p2.push(t3.join(""));
      }
      if (m2 && i2 & h) return {
        needAppearances: true
      };
      if (m2 && this._isOffscreenCanvasSupported) {
        const i3 = this.data.comb ? "monospace" : "sans-serif", a3 = new FakeUnicodeFont(e2.xref, i3), r3 = a3.createFontResources(c2.join("")), n3 = r3.getRaw("Font");
        if (this._fieldResources.mergedResources.has("Font")) {
          const e3 = this._fieldResources.mergedResources.get("Font");
          for (const t3 of n3.getKeys()) e3.set(t3, n3.getRaw(t3));
        } else this._fieldResources.mergedResources.set("Font", n3);
        const o2 = a3.fontName.name;
        f2 = await WidgetAnnotation._getFontData(e2, t2, {
          fontName: o2,
          fontSize: 0
        }, r3);
        for (let e3 = 0, t3 = p2.length; e3 < t3; e3++) p2[e3] = stringToUTF16String(c2[e3]);
        const g3 = Object.assign(/* @__PURE__ */ Object.create(null), this.data.defaultAppearanceData);
        this.data.defaultAppearanceData.fontSize = 0;
        this.data.defaultAppearanceData.fontName = o2;
        [E2, u2, d2] = this._computeFontSize(l2 - 2, Q2 - 4, s2, f2, C2);
        this.data.defaultAppearanceData = g3;
      } else {
        this._isOffscreenCanvasSupported || warn("_getAppearance: OffscreenCanvas is not supported, annotation may not render correctly.");
        [E2, u2, d2] = this._computeFontSize(l2 - 2, Q2 - 4, s2, f2, C2);
      }
      let y2 = f2.descent;
      y2 = isNaN(y2) ? o * d2 : Math.max(o * d2, Math.abs(y2) * u2);
      const w2 = Math.min(Math.floor((l2 - u2) / 2), 1), b2 = this.data.textAlignment;
      if (this.data.multiLine) return this._getMultilineAppearance(E2, p2, f2, u2, Q2, l2, b2, 2, w2, y2, d2, a2);
      if (this.data.comb) return this._getCombAppearance(E2, f2, p2[0], u2, Q2, l2, 2, w2, y2, d2, a2);
      const D2 = w2 + y2;
      if (0 === b2 || b2 > 2) return `/Tx BMC q ${g2}BT ` + E2 + ` 1 0 0 1 ${numberToString(2)} ${numberToString(D2)} Tm (${escapeString(p2[0])}) Tj ET Q EMC`;
      return `/Tx BMC q ${g2}BT ` + E2 + ` 1 0 0 1 0 0 Tm ${this._renderText(p2[0], f2, u2, Q2, b2, {
        shift: 0
      }, 2, D2)} ET Q EMC`;
    }
    static async _getFontData(e2, t2, i2, a2) {
      const r2 = new OperatorList(), s2 = {
        font: null,
        clone() {
          return this;
        }
      }, { fontName: n2, fontSize: o2 } = i2;
      await e2.handleSetFont(a2, [
        n2 && Name.get(n2),
        o2
      ], null, r2, t2, s2, null);
      return s2.font;
    }
    _getTextWidth(e2, t2) {
      return t2.charsToGlyphs(e2).reduce((e3, t3) => e3 + t3.width, 0) / 1e3;
    }
    _computeFontSize(e2, t2, i2, a2, r2) {
      let { fontSize: n2 } = this.data.defaultAppearanceData, o2 = (n2 || 12) * s, g2 = Math.round(e2 / o2);
      if (!n2) {
        const roundWithTwoDigits = (e3) => Math.floor(100 * e3) / 100;
        if (-1 === r2) {
          const r3 = this._getTextWidth(i2, a2);
          n2 = roundWithTwoDigits(Math.min(e2 / s, t2 / r3));
          g2 = 1;
        } else {
          const c3 = i2.split(/\r\n?|\n/), C3 = [];
          for (const e3 of c3) {
            const t3 = a2.encodeString(e3).join(""), i3 = a2.charsToGlyphs(t3), r3 = a2.getCharPositions(t3);
            C3.push({
              line: t3,
              glyphs: i3,
              positions: r3
            });
          }
          const isTooBig = (i3) => {
            let r3 = 0;
            for (const s2 of C3) {
              r3 += this._splitLine(null, a2, i3, t2, s2).length * i3;
              if (r3 > e2) return true;
            }
            return false;
          };
          g2 = Math.max(g2, r2);
          for (; ; ) {
            o2 = e2 / g2;
            n2 = roundWithTwoDigits(o2 / s);
            if (!isTooBig(n2)) break;
            g2++;
          }
        }
        const { fontName: c2, fontColor: C2 } = this.data.defaultAppearanceData;
        this._defaultAppearance = function createDefaultAppearance({ fontSize: e3, fontName: t3, fontColor: i3 }) {
          return `/${escapePDFName(t3)} ${e3} Tf ${getPdfColor(i3, true)}`;
        }({
          fontSize: n2,
          fontName: c2,
          fontColor: C2
        });
      }
      return [
        this._defaultAppearance,
        n2,
        e2 / g2
      ];
    }
    _renderText(e2, t2, i2, a2, r2, s2, n2, o2) {
      let g2;
      if (1 === r2) {
        g2 = (a2 - this._getTextWidth(e2, t2) * i2) / 2;
      } else if (2 === r2) {
        g2 = a2 - this._getTextWidth(e2, t2) * i2 - n2;
      } else g2 = n2;
      const c2 = numberToString(g2 - s2.shift);
      s2.shift = g2;
      return `${c2} ${o2 = numberToString(o2)} Td (${escapeString(e2)}) Tj`;
    }
    _getSaveFieldResources(e2) {
      var _a4;
      const { localResources: t2, appearanceResources: i2, acroFormResources: a2 } = this._fieldResources, r2 = (_a4 = this.data.defaultAppearanceData) == null ? void 0 : _a4.fontName;
      if (!r2) return t2 || Dict.empty;
      for (const e3 of [
        t2,
        i2
      ]) if (e3 instanceof Dict) {
        const t3 = e3.get("Font");
        if (t3 instanceof Dict && t3.has(r2)) return e3;
      }
      if (a2 instanceof Dict) {
        const i3 = a2.get("Font");
        if (i3 instanceof Dict && i3.has(r2)) {
          const a3 = new Dict(e2);
          a3.set(r2, i3.getRaw(r2));
          const s2 = new Dict(e2);
          s2.set("Font", a3);
          return Dict.merge({
            xref: e2,
            dictArray: [
              s2,
              t2
            ],
            mergeSubDicts: true
          });
        }
      }
      return t2 || Dict.empty;
    }
    getFieldObject() {
      return null;
    }
  }
  class TextWidgetAnnotation extends WidgetAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2 } = e2;
      if (t2.has("PMD")) {
        this.flags |= $;
        this.data.hidden = true;
        warn("Barcodes are not supported");
      }
      this.data.hasOwnCanvas = this.data.readOnly && !this.data.noHTML;
      this._hasText = true;
      "string" != typeof this.data.fieldValue && (this.data.fieldValue = "");
      let i2 = getInheritableProperty({
        dict: t2,
        key: "Q"
      });
      (!Number.isInteger(i2) || i2 < 0 || i2 > 2) && (i2 = null);
      this.data.textAlignment = i2;
      let a2 = getInheritableProperty({
        dict: t2,
        key: "MaxLen"
      });
      (!Number.isInteger(a2) || a2 < 0) && (a2 = 0);
      this.data.maxLen = a2;
      this.data.multiLine = this.hasFieldFlag(nA);
      this.data.comb = this.hasFieldFlag(BA) && !this.hasFieldFlag(nA) && !this.hasFieldFlag(oA) && !this.hasFieldFlag(CA) && 0 !== this.data.maxLen;
      this.data.doNotScroll = this.hasFieldFlag(lA);
    }
    get hasTextContent() {
      return !!this.appearance && !this._needAppearances;
    }
    _getCombAppearance(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2, C2) {
      const h2 = r2 / this.data.maxLen, l2 = this.getBorderAndBackgroundAppearances(C2), Q2 = [], E2 = t2.getCharPositions(i2);
      for (const [e3, t3] of E2) Q2.push(`(${escapeString(i2.substring(e3, t3))}) Tj`);
      const u2 = Q2.join(` ${numberToString(h2)} 0 Td `);
      return `/Tx BMC q ${l2}BT ` + e2 + ` 1 0 0 1 ${numberToString(n2)} ${numberToString(o2 + g2)} Tm ${u2} ET Q EMC`;
    }
    _getMultilineAppearance(e2, t2, i2, a2, r2, s2, n2, o2, g2, c2, C2, h2) {
      const l2 = [], Q2 = r2 - 2 * o2, E2 = {
        shift: 0
      };
      for (let e3 = 0, s3 = t2.length; e3 < s3; e3++) {
        const s4 = t2[e3], h3 = this._splitLine(s4, i2, a2, Q2);
        for (let t3 = 0, s5 = h3.length; t3 < s5; t3++) {
          const s6 = h3[t3], Q3 = 0 === e3 && 0 === t3 ? -g2 - (C2 - c2) : -C2;
          l2.push(this._renderText(s6, i2, a2, r2, n2, E2, o2, Q3));
        }
      }
      const u2 = this.getBorderAndBackgroundAppearances(h2), d2 = l2.join("\n");
      return `/Tx BMC q ${u2}BT ` + e2 + ` 1 0 0 1 0 ${numberToString(s2)} Tm ${d2} ET Q EMC`;
    }
    _splitLine(e2, t2, i2, a2, r2 = {}) {
      e2 = r2.line || e2;
      const s2 = r2.glyphs || t2.charsToGlyphs(e2);
      if (s2.length <= 1) return [
        e2
      ];
      const n2 = r2.positions || t2.getCharPositions(e2), o2 = i2 / 1e3, g2 = [];
      let c2 = -1, C2 = -1, h2 = -1, l2 = 0, Q2 = 0;
      for (let t3 = 0, i3 = s2.length; t3 < i3; t3++) {
        const [i4, r3] = n2[t3], E2 = s2[t3], u2 = E2.width * o2;
        if (" " === E2.unicode) if (Q2 + u2 > a2) {
          g2.push(e2.substring(l2, i4));
          l2 = i4;
          Q2 = u2;
          c2 = -1;
          h2 = -1;
        } else {
          Q2 += u2;
          c2 = i4;
          C2 = r3;
          h2 = t3;
        }
        else if (Q2 + u2 > a2) if (-1 !== c2) {
          g2.push(e2.substring(l2, C2));
          l2 = C2;
          t3 = h2 + 1;
          c2 = -1;
          Q2 = 0;
        } else {
          g2.push(e2.substring(l2, i4));
          l2 = i4;
          Q2 = u2;
        }
        else Q2 += u2;
      }
      l2 < e2.length && g2.push(e2.substring(l2, e2.length));
      return g2;
    }
    async extractTextContent(e2, t2, i2) {
      await super.extractTextContent(e2, t2, i2);
      const a2 = this.data.textContent;
      if (!a2) return;
      const r2 = a2.join("\n");
      if (r2 === this.data.fieldValue) return;
      const s2 = r2.replaceAll(/([.*+?^${}()|[\]\\])|(\s+)/g, (e3, t3) => t3 ? `\\${t3}` : "\\s+");
      new RegExp(`^\\s*${s2}\\s*$`).test(this.data.fieldValue) && (this.data.textContent = this.data.fieldValue.split("\n"));
    }
    getFieldObject() {
      return {
        id: this.data.id,
        value: this.data.fieldValue,
        defaultValue: this.data.defaultFieldValue || "",
        multiline: this.data.multiLine,
        password: this.hasFieldFlag(oA),
        charLimit: this.data.maxLen,
        comb: this.data.comb,
        editable: !this.data.readOnly,
        hidden: this.data.hidden,
        name: this.data.fieldName,
        rect: this.data.rect,
        actions: this.data.actions,
        page: this.data.pageIndex,
        strokeColor: this.data.borderColor,
        fillColor: this.data.backgroundColor,
        rotation: this.rotation,
        type: "text"
      };
    }
  }
  class ButtonWidgetAnnotation extends WidgetAnnotation {
    constructor(e2) {
      super(e2);
      this.checkedAppearance = null;
      this.uncheckedAppearance = null;
      this.data.checkBox = !this.hasFieldFlag(gA) && !this.hasFieldFlag(IA);
      this.data.radioButton = this.hasFieldFlag(gA) && !this.hasFieldFlag(IA);
      this.data.pushButton = this.hasFieldFlag(IA);
      this.data.isTooltipOnly = false;
      if (this.data.checkBox) this._processCheckBox(e2);
      else if (this.data.radioButton) this._processRadioButton(e2);
      else if (this.data.pushButton) {
        this.data.hasOwnCanvas = true;
        this.data.noHTML = false;
        this._processPushButton(e2);
      } else warn("Invalid field flags for button widget annotation");
    }
    async getOperatorList(e2, t2, i2, r2) {
      if (this.data.pushButton) return super.getOperatorList(e2, t2, i2, false, r2);
      let s2 = null, n2 = null;
      if (r2) {
        const e3 = r2.get(this.data.id);
        s2 = e3 ? e3.value : null;
        n2 = e3 ? e3.rotation : null;
      }
      if (null === s2 && this.appearance) return super.getOperatorList(e2, t2, i2, r2);
      null == s2 && (s2 = this.data.checkBox ? this.data.fieldValue === this.data.exportValue : this.data.fieldValue === this.data.buttonValue);
      const o2 = s2 ? this.checkedAppearance : this.uncheckedAppearance;
      if (o2) {
        const s3 = this.appearance, g2 = lookupMatrix(o2.dict.getArray("Matrix"), a);
        n2 && o2.dict.set("Matrix", this.getRotationMatrix(r2));
        this.appearance = o2;
        const c2 = super.getOperatorList(e2, t2, i2, r2);
        this.appearance = s3;
        o2.dict.set("Matrix", g2);
        return c2;
      }
      return {
        opList: new OperatorList(),
        separateForm: false,
        separateCanvas: false
      };
    }
    async save(e2, t2, i2) {
      return this.data.checkBox ? this._saveCheckbox(e2, t2, i2) : this.data.radioButton ? this._saveRadioButton(e2, t2, i2) : null;
    }
    async _saveCheckbox(e2, t2, i2) {
      if (!i2) return null;
      const a2 = i2.get(this.data.id), r2 = this._buildFlags(a2 == null ? void 0 : a2.noView, a2 == null ? void 0 : a2.noPrint);
      let s2 = a2 == null ? void 0 : a2.rotation, n2 = a2 == null ? void 0 : a2.value;
      if (void 0 === s2 && void 0 === r2) {
        if (void 0 === n2) return null;
        if (this.data.fieldValue === this.data.exportValue === n2) return null;
      }
      let o2 = e2.xref.fetchIfRef(this.ref);
      if (!(o2 instanceof Dict)) return null;
      o2 = o2.clone();
      void 0 === s2 && (s2 = this.rotation);
      void 0 === n2 && (n2 = this.data.fieldValue === this.data.exportValue);
      const g2 = {
        path: this.data.fieldName,
        value: n2 ? this.data.exportValue : ""
      }, c2 = Name.get(n2 ? this.data.exportValue : "Off");
      o2.set("V", c2);
      o2.set("AS", c2);
      o2.set("M", `D:${getModificationDate()}`);
      void 0 !== r2 && o2.set("F", r2);
      const C2 = this._getMKDict(s2);
      C2 && o2.set("MK", C2);
      const h2 = [];
      await writeObject(this.ref, o2, h2, e2.xref);
      return [
        {
          ref: this.ref,
          data: h2.join(""),
          xfa: g2
        }
      ];
    }
    async _saveRadioButton(e2, t2, i2) {
      if (!i2) return null;
      const a2 = i2.get(this.data.id), r2 = this._buildFlags(a2 == null ? void 0 : a2.noView, a2 == null ? void 0 : a2.noPrint);
      let s2 = a2 == null ? void 0 : a2.rotation, n2 = a2 == null ? void 0 : a2.value;
      if (void 0 === s2 && void 0 === r2) {
        if (void 0 === n2) return null;
        if (this.data.fieldValue === this.data.buttonValue === n2) return null;
      }
      let o2 = e2.xref.fetchIfRef(this.ref);
      if (!(o2 instanceof Dict)) return null;
      o2 = o2.clone();
      void 0 === n2 && (n2 = this.data.fieldValue === this.data.buttonValue);
      void 0 === s2 && (s2 = this.rotation);
      const g2 = {
        path: this.data.fieldName,
        value: n2 ? this.data.buttonValue : ""
      }, c2 = Name.get(n2 ? this.data.buttonValue : "Off"), C2 = [];
      let h2 = null;
      if (n2) if (this.parent instanceof Ref) {
        const t3 = e2.xref.fetch(this.parent);
        t3.set("V", c2);
        await writeObject(this.parent, t3, C2, e2.xref);
        h2 = C2.join("");
        C2.length = 0;
      } else this.parent instanceof Dict && this.parent.set("V", c2);
      this.parent || o2.set("V", c2);
      o2.set("AS", c2);
      o2.set("M", `D:${getModificationDate()}`);
      void 0 !== r2 && o2.set("F", r2);
      const l2 = this._getMKDict(s2);
      l2 && o2.set("MK", l2);
      await writeObject(this.ref, o2, C2, e2.xref);
      const Q2 = [
        {
          ref: this.ref,
          data: C2.join(""),
          xfa: g2
        }
      ];
      h2 && Q2.push({
        ref: this.parent,
        data: h2,
        xfa: null
      });
      return Q2;
    }
    _getDefaultCheckedAppearance(e2, t2) {
      const i2 = this.data.rect[2] - this.data.rect[0], a2 = this.data.rect[3] - this.data.rect[1], r2 = [
        0,
        0,
        i2,
        a2
      ], s2 = 0.8 * Math.min(i2, a2);
      let n2, o2;
      if ("check" === t2) {
        n2 = {
          width: 0.755 * s2,
          height: 0.705 * s2
        };
        o2 = "3";
      } else if ("disc" === t2) {
        n2 = {
          width: 0.791 * s2,
          height: 0.705 * s2
        };
        o2 = "l";
      } else unreachable(`_getDefaultCheckedAppearance - unsupported type: ${t2}`);
      const g2 = `q BT /PdfJsZaDb ${s2} Tf 0 g ${numberToString((i2 - n2.width) / 2)} ${numberToString((a2 - n2.height) / 2)} Td (${o2}) Tj ET Q`, c2 = new Dict(e2.xref);
      c2.set("FormType", 1);
      c2.set("Subtype", Name.get("Form"));
      c2.set("Type", Name.get("XObject"));
      c2.set("BBox", r2);
      c2.set("Matrix", [
        1,
        0,
        0,
        1,
        0,
        0
      ]);
      c2.set("Length", g2.length);
      const C2 = new Dict(e2.xref), h2 = new Dict(e2.xref);
      h2.set("PdfJsZaDb", this.fallbackFontDict);
      C2.set("Font", h2);
      c2.set("Resources", C2);
      this.checkedAppearance = new StringStream(g2);
      this.checkedAppearance.dict = c2;
      this._streams.push(this.checkedAppearance);
    }
    _processCheckBox(e2) {
      const t2 = e2.dict.get("AP");
      if (!(t2 instanceof Dict)) return;
      const i2 = t2.get("N");
      if (!(i2 instanceof Dict)) return;
      const a2 = this._decodeFormValue(e2.dict.get("AS"));
      "string" == typeof a2 && (this.data.fieldValue = a2);
      const r2 = null !== this.data.fieldValue && "Off" !== this.data.fieldValue ? this.data.fieldValue : "Yes", s2 = i2.getKeys();
      if (0 === s2.length) s2.push("Off", r2);
      else if (1 === s2.length) "Off" === s2[0] ? s2.push(r2) : s2.unshift("Off");
      else if (s2.includes(r2)) {
        s2.length = 0;
        s2.push("Off", r2);
      } else {
        const e3 = s2.find((e4) => "Off" !== e4);
        s2.length = 0;
        s2.push("Off", e3);
      }
      s2.includes(this.data.fieldValue) || (this.data.fieldValue = "Off");
      this.data.exportValue = s2[1];
      const n2 = i2.get(this.data.exportValue);
      this.checkedAppearance = n2 instanceof BaseStream ? n2 : null;
      const o2 = i2.get("Off");
      this.uncheckedAppearance = o2 instanceof BaseStream ? o2 : null;
      this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "check");
      this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
      this._fallbackFontDict = this.fallbackFontDict;
      null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processRadioButton(e2) {
      this.data.buttonValue = null;
      const t2 = e2.dict.get("Parent");
      if (t2 instanceof Dict) {
        this.parent = e2.dict.getRaw("Parent");
        const i3 = t2.get("V");
        i3 instanceof Name && (this.data.fieldValue = this._decodeFormValue(i3));
      }
      const i2 = e2.dict.get("AP");
      if (!(i2 instanceof Dict)) return;
      const a2 = i2.get("N");
      if (!(a2 instanceof Dict)) return;
      for (const e3 of a2.getKeys()) if ("Off" !== e3) {
        this.data.buttonValue = this._decodeFormValue(e3);
        break;
      }
      const r2 = a2.get(this.data.buttonValue);
      this.checkedAppearance = r2 instanceof BaseStream ? r2 : null;
      const s2 = a2.get("Off");
      this.uncheckedAppearance = s2 instanceof BaseStream ? s2 : null;
      this.checkedAppearance ? this._streams.push(this.checkedAppearance) : this._getDefaultCheckedAppearance(e2, "disc");
      this.uncheckedAppearance && this._streams.push(this.uncheckedAppearance);
      this._fallbackFontDict = this.fallbackFontDict;
      null === this.data.defaultFieldValue && (this.data.defaultFieldValue = "Off");
    }
    _processPushButton(e2) {
      const { dict: t2, annotationGlobals: i2 } = e2;
      if (t2.has("A") || t2.has("AA") || this.data.alternativeText) {
        this.data.isTooltipOnly = !t2.has("A") && !t2.has("AA");
        Catalog.parseDestDictionary({
          destDict: t2,
          resultObj: this.data,
          docBaseUrl: i2.baseUrl,
          docAttachments: i2.attachments
        });
      } else warn("Push buttons without action dictionaries are not supported");
    }
    getFieldObject() {
      let e2, t2 = "button";
      if (this.data.checkBox) {
        t2 = "checkbox";
        e2 = this.data.exportValue;
      } else if (this.data.radioButton) {
        t2 = "radiobutton";
        e2 = this.data.buttonValue;
      }
      return {
        id: this.data.id,
        value: this.data.fieldValue || "Off",
        defaultValue: this.data.defaultFieldValue,
        exportValues: e2,
        editable: !this.data.readOnly,
        name: this.data.fieldName,
        rect: this.data.rect,
        hidden: this.data.hidden,
        actions: this.data.actions,
        page: this.data.pageIndex,
        strokeColor: this.data.borderColor,
        fillColor: this.data.backgroundColor,
        rotation: this.rotation,
        type: t2
      };
    }
    get fallbackFontDict() {
      const e2 = new Dict();
      e2.set("BaseFont", Name.get("ZapfDingbats"));
      e2.set("Type", Name.get("FallbackType"));
      e2.set("Subtype", Name.get("FallbackType"));
      e2.set("Encoding", Name.get("ZapfDingbatsEncoding"));
      return shadow(this, "fallbackFontDict", e2);
    }
  }
  class ChoiceWidgetAnnotation extends WidgetAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.indices = t2.getArray("I");
      this.hasIndices = Array.isArray(this.indices) && this.indices.length > 0;
      this.data.options = [];
      const a2 = getInheritableProperty({
        dict: t2,
        key: "Opt"
      });
      if (Array.isArray(a2)) for (let e3 = 0, t3 = a2.length; e3 < t3; e3++) {
        const t4 = i2.fetchIfRef(a2[e3]), r2 = Array.isArray(t4);
        this.data.options[e3] = {
          exportValue: this._decodeFormValue(r2 ? i2.fetchIfRef(t4[0]) : t4),
          displayValue: this._decodeFormValue(r2 ? i2.fetchIfRef(t4[1]) : t4)
        };
      }
      if (this.hasIndices) {
        this.data.fieldValue = [];
        const e3 = this.data.options.length;
        for (const t3 of this.indices) Number.isInteger(t3) && t3 >= 0 && t3 < e3 && this.data.fieldValue.push(this.data.options[t3].exportValue);
      } else "string" == typeof this.data.fieldValue ? this.data.fieldValue = [
        this.data.fieldValue
      ] : this.data.fieldValue || (this.data.fieldValue = []);
      this.data.combo = this.hasFieldFlag(cA);
      this.data.multiSelect = this.hasFieldFlag(hA);
      this._hasText = true;
    }
    getFieldObject() {
      const e2 = this.data.combo ? "combobox" : "listbox", t2 = this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null;
      return {
        id: this.data.id,
        value: t2,
        defaultValue: this.data.defaultFieldValue,
        editable: !this.data.readOnly,
        name: this.data.fieldName,
        rect: this.data.rect,
        numItems: this.data.fieldValue.length,
        multipleSelection: this.data.multiSelect,
        hidden: this.data.hidden,
        actions: this.data.actions,
        items: this.data.options,
        page: this.data.pageIndex,
        strokeColor: this.data.borderColor,
        fillColor: this.data.backgroundColor,
        rotation: this.rotation,
        type: e2
      };
    }
    amendSavedDict(e2, t2) {
      var _a4;
      if (!this.hasIndices) return;
      let i2 = (_a4 = e2 == null ? void 0 : e2.get(this.data.id)) == null ? void 0 : _a4.value;
      Array.isArray(i2) || (i2 = [
        i2
      ]);
      const a2 = [], { options: r2 } = this.data;
      for (let e3 = 0, t3 = 0, s2 = r2.length; e3 < s2; e3++) if (r2[e3].exportValue === i2[t3]) {
        a2.push(e3);
        t3 += 1;
      }
      t2.set("I", a2);
    }
    async _getAppearance(e2, t2, i2, a2) {
      if (this.data.combo) return super._getAppearance(e2, t2, i2, a2);
      let r2, n2;
      const o2 = a2 == null ? void 0 : a2.get(this.data.id);
      if (o2) {
        n2 = o2.rotation;
        r2 = o2.value;
      }
      if (void 0 === n2 && void 0 === r2 && !this._needAppearances) return null;
      void 0 === r2 ? r2 = this.data.fieldValue : Array.isArray(r2) || (r2 = [
        r2
      ]);
      let g2 = this.data.rect[3] - this.data.rect[1], c2 = this.data.rect[2] - this.data.rect[0];
      90 !== n2 && 270 !== n2 || ([c2, g2] = [
        g2,
        c2
      ]);
      const C2 = this.data.options.length, h2 = [];
      for (let e3 = 0; e3 < C2; e3++) {
        const { exportValue: t3 } = this.data.options[e3];
        r2.includes(t3) && h2.push(e3);
      }
      this._defaultAppearance || (this.data.defaultAppearanceData = parseDefaultAppearance(this._defaultAppearance = "/Helvetica 0 Tf 0 g"));
      const l2 = await WidgetAnnotation._getFontData(e2, t2, this.data.defaultAppearanceData, this._fieldResources.mergedResources);
      let Q2, { fontSize: E2 } = this.data.defaultAppearanceData;
      if (E2) Q2 = this._defaultAppearance;
      else {
        const e3 = (g2 - 1) / C2;
        let t3, i3 = -1;
        for (const { displayValue: e4 } of this.data.options) {
          const a3 = this._getTextWidth(e4, l2);
          if (a3 > i3) {
            i3 = a3;
            t3 = e4;
          }
        }
        [Q2, E2] = this._computeFontSize(e3, c2 - 4, t3, l2, -1);
      }
      const u2 = E2 * s, d2 = (u2 - E2) / 2, f2 = Math.floor(g2 / u2);
      let p2 = 0;
      if (h2.length > 0) {
        const e3 = Math.min(...h2), t3 = Math.max(...h2);
        p2 = Math.max(0, t3 - f2 + 1);
        p2 > e3 && (p2 = e3);
      }
      const m2 = Math.min(p2 + f2 + 1, C2), y2 = [
        "/Tx BMC q",
        `1 1 ${c2} ${g2} re W n`
      ];
      if (h2.length) {
        y2.push("0.600006 0.756866 0.854904 rg");
        for (const e3 of h2) p2 <= e3 && e3 < m2 && y2.push(`1 ${g2 - (e3 - p2 + 1) * u2} ${c2} ${u2} re f`);
      }
      y2.push("BT", Q2, `1 0 0 1 0 ${g2} Tm`);
      const w2 = {
        shift: 0
      };
      for (let e3 = p2; e3 < m2; e3++) {
        const { displayValue: t3 } = this.data.options[e3], i3 = e3 === p2 ? d2 : 0;
        y2.push(this._renderText(t3, l2, E2, c2, 0, w2, 2, -u2 + i3));
      }
      y2.push("ET Q EMC");
      return y2.join("\n");
    }
  }
  class SignatureWidgetAnnotation extends WidgetAnnotation {
    constructor(e2) {
      super(e2);
      this.data.fieldValue = null;
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = !this.data.hasOwnCanvas;
    }
    getFieldObject() {
      return {
        id: this.data.id,
        value: null,
        page: this.data.pageIndex,
        type: "signature"
      };
    }
  }
  class TextAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      this.data.noRotate = true;
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = false;
      const { dict: t2 } = e2;
      this.data.annotationType = N;
      if (this.data.hasAppearance) this.data.name = "NoIcon";
      else {
        this.data.rect[1] = this.data.rect[3] - 22;
        this.data.rect[2] = this.data.rect[0] + 22;
        this.data.name = t2.has("Name") ? t2.get("Name").name : "Note";
      }
      if (t2.has("State")) {
        this.data.state = t2.get("State") || null;
        this.data.stateModel = t2.get("StateModel") || null;
      } else {
        this.data.state = null;
        this.data.stateModel = null;
      }
    }
  }
  class LinkAnnotation extends Annotation {
    constructor(e2) {
      var _a4;
      super(e2);
      const { dict: t2, annotationGlobals: i2 } = e2;
      this.data.annotationType = G;
      this.data.noHTML = false;
      const a2 = getQuadPoints(t2, this.rectangle);
      a2 && (this.data.quadPoints = a2);
      (_a4 = this.data).borderColor || (_a4.borderColor = this.data.color);
      Catalog.parseDestDictionary({
        destDict: t2,
        resultObj: this.data,
        docBaseUrl: i2.baseUrl,
        docAttachments: i2.attachments
      });
    }
  }
  class PopupAnnotation extends Annotation {
    constructor(e2) {
      super(e2);
      const { dict: t2 } = e2;
      this.data.annotationType = j;
      this.data.noHTML = false;
      this.data.rect[0] !== this.data.rect[2] && this.data.rect[1] !== this.data.rect[3] || (this.data.rect = null);
      let i2 = t2.get("Parent");
      if (!i2) {
        warn("Popup annotation has a missing or invalid parent annotation.");
        return;
      }
      this.data.parentRect = lookupNormalRect(i2.getArray("Rect"), null);
      isName(i2.get("RT"), V) && (i2 = i2.get("IRT"));
      if (i2.has("M")) {
        this.setModificationDate(i2.get("M"));
        this.data.modificationDate = this.modificationDate;
      } else this.data.modificationDate = null;
      if (i2.has("C")) {
        this.setColor(i2.getArray("C"));
        this.data.color = this.color;
      } else this.data.color = null;
      if (!this.viewable) {
        const e3 = i2.get("F");
        this._isViewable(e3) && this.setFlags(e3);
      }
      this.setTitle(i2.get("T"));
      this.data.titleObj = this._title;
      this.setContents(i2.get("Contents"));
      this.data.contentsObj = this._contents;
      i2.has("RC") && (this.data.richText = XFAFactory.getRichTextAsHtml(i2.get("RC")));
      this.data.open = !!t2.get("Open");
    }
  }
  class FreeTextAnnotation extends MarkupAnnotation {
    constructor(e2) {
      var _a4;
      super(e2);
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.isEditable = !this.data.noHTML;
      this.data.noHTML = false;
      const { evaluatorOptions: t2, xref: i2 } = e2;
      this.data.annotationType = x;
      this.setDefaultAppearance(e2);
      this._hasAppearance = !!this.appearance;
      if (this._hasAppearance) {
        const { fontColor: e3, fontSize: a2 } = function parseAppearanceStream(e4, t3, i3) {
          return new AppearanceStreamEvaluator(e4, t3, i3).parse();
        }(this.appearance, t2, i2);
        this.data.defaultAppearanceData.fontColor = e3;
        this.data.defaultAppearanceData.fontSize = a2 || 10;
      } else {
        (_a4 = this.data.defaultAppearanceData).fontSize || (_a4.fontSize = 10);
        const { fontColor: t3, fontSize: a2 } = this.data.defaultAppearanceData;
        if (this._contents.str) {
          this.data.textContent = this._contents.str.split(/\r\n?|\n/).map((e4) => e4.trimEnd());
          const { coords: e3, bbox: t4, matrix: i3 } = FakeUnicodeFont.getFirstPositionInfo(this.rectangle, this.rotation, a2);
          this.data.textPosition = this._transformPoint(e3, t4, i3);
        }
        if (this._isOffscreenCanvasSupported) {
          const r2 = e2.dict.get("CA"), s2 = new FakeUnicodeFont(i2, "sans-serif");
          this.appearance = s2.createAppearance(this._contents.str, this.rectangle, this.rotation, a2, t3, r2);
          this._streams.push(this.appearance);
        } else warn("FreeTextAnnotation: OffscreenCanvas is not supported, annotation may not render correctly.");
      }
    }
    get hasTextContent() {
      return this._hasAppearance;
    }
    static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
      const { color: r2, fontSize: s2, oldAnnotation: n2, rect: o2, rotation: g2, user: c2, value: C2 } = e2, h2 = n2 || new Dict(t2);
      h2.set("Type", Name.get("Annot"));
      h2.set("Subtype", Name.get("FreeText"));
      if (n2) {
        h2.set("M", `D:${getModificationDate()}`);
        h2.delete("RC");
      } else h2.set("CreationDate", `D:${getModificationDate()}`);
      h2.set("Rect", o2);
      const l2 = `/Helv ${s2} Tf ${getPdfColor(r2, true)}`;
      h2.set("DA", l2);
      h2.set("Contents", stringToAsciiOrUTF16BE(C2));
      h2.set("F", 4);
      h2.set("Border", [
        0,
        0,
        0
      ]);
      h2.set("Rotate", g2);
      c2 && h2.set("T", stringToAsciiOrUTF16BE(c2));
      if (i2 || a2) {
        const e3 = new Dict(t2);
        h2.set("AP", e3);
        i2 ? e3.set("N", i2) : e3.set("N", a2);
      }
      return h2;
    }
    static async createNewAppearanceStream(e2, t2, i2) {
      const { baseFontRef: a2, evaluator: r2, task: n2 } = i2, { color: o2, fontSize: g2, rect: c2, rotation: C2, value: h2 } = e2, l2 = new Dict(t2), Q2 = new Dict(t2);
      if (a2) Q2.set("Helv", a2);
      else {
        const e3 = new Dict(t2);
        e3.set("BaseFont", Name.get("Helvetica"));
        e3.set("Type", Name.get("Font"));
        e3.set("Subtype", Name.get("Type1"));
        e3.set("Encoding", Name.get("WinAnsiEncoding"));
        Q2.set("Helv", e3);
      }
      l2.set("Font", Q2);
      const E2 = await WidgetAnnotation._getFontData(r2, n2, {
        fontName: "Helv",
        fontSize: g2
      }, l2), [u2, d2, f2, p2] = c2;
      let m2 = f2 - u2, y2 = p2 - d2;
      C2 % 180 != 0 && ([m2, y2] = [
        y2,
        m2
      ]);
      const w2 = h2.split("\n"), b2 = g2 / 1e3;
      let D2 = -1 / 0;
      const S2 = [];
      for (let e3 of w2) {
        const t3 = E2.encodeString(e3);
        if (t3.length > 1) return null;
        e3 = t3.join("");
        S2.push(e3);
        let i3 = 0;
        const a3 = E2.charsToGlyphs(e3);
        for (const e4 of a3) i3 += e4.width * b2;
        D2 = Math.max(D2, i3);
      }
      let k2 = 1;
      D2 > m2 && (k2 = m2 / D2);
      let R2 = 1;
      const N2 = s * g2, G2 = 1 * g2, x2 = N2 * w2.length;
      x2 > y2 && (R2 = y2 / x2);
      const U2 = g2 * Math.min(k2, R2);
      let M2, L2, H2;
      switch (C2) {
        case 0:
          H2 = [
            1,
            0,
            0,
            1
          ];
          L2 = [
            c2[0],
            c2[1],
            m2,
            y2
          ];
          M2 = [
            c2[0],
            c2[3] - G2
          ];
          break;
        case 90:
          H2 = [
            0,
            1,
            -1,
            0
          ];
          L2 = [
            c2[1],
            -c2[2],
            m2,
            y2
          ];
          M2 = [
            c2[1],
            -c2[0] - G2
          ];
          break;
        case 180:
          H2 = [
            -1,
            0,
            0,
            -1
          ];
          L2 = [
            -c2[2],
            -c2[3],
            m2,
            y2
          ];
          M2 = [
            -c2[2],
            -c2[1] - G2
          ];
          break;
        case 270:
          H2 = [
            0,
            -1,
            1,
            0
          ];
          L2 = [
            -c2[3],
            c2[0],
            m2,
            y2
          ];
          M2 = [
            -c2[3],
            c2[2] - G2
          ];
      }
      const J2 = [
        "q",
        `${H2.join(" ")} 0 0 cm`,
        `${L2.join(" ")} re W n`,
        "BT",
        `${getPdfColor(o2, true)}`,
        `0 Tc /Helv ${numberToString(U2)} Tf`
      ];
      J2.push(`${M2.join(" ")} Td (${escapeString(S2[0])}) Tj`);
      const v2 = numberToString(N2);
      for (let e3 = 1, t3 = S2.length; e3 < t3; e3++) {
        const t4 = S2[e3];
        J2.push(`0 -${v2} Td (${escapeString(t4)}) Tj`);
      }
      J2.push("ET", "Q");
      const Y2 = J2.join("\n"), T2 = new Dict(t2);
      T2.set("FormType", 1);
      T2.set("Subtype", Name.get("Form"));
      T2.set("Type", Name.get("XObject"));
      T2.set("BBox", c2);
      T2.set("Resources", l2);
      T2.set("Matrix", [
        1,
        0,
        0,
        1,
        -c2[0],
        -c2[1]
      ]);
      const K2 = new StringStream(Y2);
      K2.dict = T2;
      return K2;
    }
  }
  class LineAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = U;
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = false;
      const a2 = lookupRect(t2.getArray("L"), [
        0,
        0,
        0,
        0
      ]);
      this.data.lineCoordinates = Util.normalizeRect(a2);
      this.setLineEndings(t2.getArray("LE"));
      this.data.lineEndings = this.lineEndings;
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [
          0,
          0,
          0
        ], r2 = t2.get("CA"), s2 = getRgbColor(t2.getArray("IC"), null), n2 = s2 ? getPdfColorArray(s2) : null, o2 = n2 ? r2 : null, g2 = this.borderStyle.width || 1, c2 = 2 * g2, C2 = [
          this.data.lineCoordinates[0] - c2,
          this.data.lineCoordinates[1] - c2,
          this.data.lineCoordinates[2] + c2,
          this.data.lineCoordinates[3] + c2
        ];
        Util.intersect(this.rectangle, C2) || (this.rectangle = C2);
        this._setDefaultAppearance({
          xref: i2,
          extra: `${g2} w`,
          strokeColor: e3,
          fillColor: n2,
          strokeAlpha: r2,
          fillAlpha: o2,
          pointsCallback: (e4, t3) => {
            e4.push(`${a2[0]} ${a2[1]} m`, `${a2[2]} ${a2[3]} l`, "S");
            return [
              t3[0] - g2,
              t3[2] + g2,
              t3[7] - g2,
              t3[3] + g2
            ];
          }
        });
      }
    }
  }
  class SquareAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = M;
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = false;
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [
          0,
          0,
          0
        ], a2 = t2.get("CA"), r2 = getRgbColor(t2.getArray("IC"), null), s2 = r2 ? getPdfColorArray(r2) : null, n2 = s2 ? a2 : null;
        if (0 === this.borderStyle.width && !s2) return;
        this._setDefaultAppearance({
          xref: i2,
          extra: `${this.borderStyle.width} w`,
          strokeColor: e3,
          fillColor: s2,
          strokeAlpha: a2,
          fillAlpha: n2,
          pointsCallback: (e4, t3) => {
            const i3 = t3[4] + this.borderStyle.width / 2, a3 = t3[5] + this.borderStyle.width / 2, r3 = t3[6] - t3[4] - this.borderStyle.width, n3 = t3[3] - t3[7] - this.borderStyle.width;
            e4.push(`${i3} ${a3} ${r3} ${n3} re`);
            s2 ? e4.push("B") : e4.push("S");
            return [
              t3[0],
              t3[2],
              t3[7],
              t3[3]
            ];
          }
        });
      }
    }
  }
  class CircleAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = L;
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [
          0,
          0,
          0
        ], a2 = t2.get("CA"), r2 = getRgbColor(t2.getArray("IC"), null), s2 = r2 ? getPdfColorArray(r2) : null, n2 = s2 ? a2 : null;
        if (0 === this.borderStyle.width && !s2) return;
        const o2 = 4 / 3 * Math.tan(Math.PI / 8);
        this._setDefaultAppearance({
          xref: i2,
          extra: `${this.borderStyle.width} w`,
          strokeColor: e3,
          fillColor: s2,
          strokeAlpha: a2,
          fillAlpha: n2,
          pointsCallback: (e4, t3) => {
            const i3 = t3[0] + this.borderStyle.width / 2, a3 = t3[1] - this.borderStyle.width / 2, r3 = t3[6] - this.borderStyle.width / 2, n3 = t3[7] + this.borderStyle.width / 2, g2 = i3 + (r3 - i3) / 2, c2 = a3 + (n3 - a3) / 2, C2 = (r3 - i3) / 2 * o2, h2 = (n3 - a3) / 2 * o2;
            e4.push(`${g2} ${n3} m`, `${g2 + C2} ${n3} ${r3} ${c2 + h2} ${r3} ${c2} c`, `${r3} ${c2 - h2} ${g2 + C2} ${a3} ${g2} ${a3} c`, `${g2 - C2} ${a3} ${i3} ${c2 - h2} ${i3} ${c2} c`, `${i3} ${c2 + h2} ${g2 - C2} ${n3} ${g2} ${n3} c`, "h");
            s2 ? e4.push("B") : e4.push("S");
            return [
              t3[0],
              t3[2],
              t3[7],
              t3[3]
            ];
          }
        });
      }
    }
  }
  class PolylineAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = J;
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = false;
      this.data.vertices = null;
      if (!(this instanceof PolygonAnnotation)) {
        this.setLineEndings(t2.getArray("LE"));
        this.data.lineEndings = this.lineEndings;
      }
      const a2 = t2.getArray("Vertices");
      if (!isNumberArray(a2, null)) return;
      const r2 = this.data.vertices = Float32Array.from(a2);
      if (!this.appearance) {
        const e3 = this.color ? getPdfColorArray(this.color) : [
          0,
          0,
          0
        ], a3 = t2.get("CA"), s2 = this.borderStyle.width || 1, n2 = 2 * s2, o2 = [
          1 / 0,
          1 / 0,
          -1 / 0,
          -1 / 0
        ];
        for (let e4 = 0, t3 = r2.length; e4 < t3; e4 += 2) {
          o2[0] = Math.min(o2[0], r2[e4] - n2);
          o2[1] = Math.min(o2[1], r2[e4 + 1] - n2);
          o2[2] = Math.max(o2[2], r2[e4] + n2);
          o2[3] = Math.max(o2[3], r2[e4 + 1] + n2);
        }
        Util.intersect(this.rectangle, o2) || (this.rectangle = o2);
        this._setDefaultAppearance({
          xref: i2,
          extra: `${s2} w`,
          strokeColor: e3,
          strokeAlpha: a3,
          pointsCallback: (e4, t3) => {
            for (let t4 = 0, i3 = r2.length; t4 < i3; t4 += 2) e4.push(`${r2[t4]} ${r2[t4 + 1]} ${0 === t4 ? "m" : "l"}`);
            e4.push("S");
            return [
              t3[0],
              t3[2],
              t3[7],
              t3[3]
            ];
          }
        });
      }
    }
  }
  class PolygonAnnotation extends PolylineAnnotation {
    constructor(e2) {
      super(e2);
      this.data.annotationType = H;
    }
  }
  class CaretAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      this.data.annotationType = O;
    }
  }
  class InkAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = false;
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = W;
      this.data.inkLists = [];
      this.data.isEditable = !this.data.noHTML && "InkHighlight" === this.data.it;
      this.data.noHTML = false;
      this.data.opacity = t2.get("CA") || 1;
      const a2 = t2.getArray("InkList");
      if (Array.isArray(a2)) {
        for (let e3 = 0, t3 = a2.length; e3 < t3; ++e3) {
          if (!Array.isArray(a2[e3])) continue;
          const t4 = new Float32Array(a2[e3].length);
          this.data.inkLists.push(t4);
          for (let r2 = 0, s2 = a2[e3].length; r2 < s2; r2 += 2) {
            const s3 = i2.fetchIfRef(a2[e3][r2]), n2 = i2.fetchIfRef(a2[e3][r2 + 1]);
            if ("number" == typeof s3 && "number" == typeof n2) {
              t4[r2] = s3;
              t4[r2 + 1] = n2;
            }
          }
        }
        if (!this.appearance) {
          const e3 = this.color ? getPdfColorArray(this.color) : [
            0,
            0,
            0
          ], a3 = t2.get("CA"), r2 = this.borderStyle.width || 1, s2 = 2 * r2, n2 = [
            1 / 0,
            1 / 0,
            -1 / 0,
            -1 / 0
          ];
          for (const e4 of this.data.inkLists) for (let t3 = 0, i3 = e4.length; t3 < i3; t3 += 2) {
            n2[0] = Math.min(n2[0], e4[t3] - s2);
            n2[1] = Math.min(n2[1], e4[t3 + 1] - s2);
            n2[2] = Math.max(n2[2], e4[t3] + s2);
            n2[3] = Math.max(n2[3], e4[t3 + 1] + s2);
          }
          Util.intersect(this.rectangle, n2) || (this.rectangle = n2);
          this._setDefaultAppearance({
            xref: i2,
            extra: `${r2} w`,
            strokeColor: e3,
            strokeAlpha: a3,
            pointsCallback: (e4, t3) => {
              for (const t4 of this.data.inkLists) {
                for (let i3 = 0, a4 = t4.length; i3 < a4; i3 += 2) e4.push(`${t4[i3]} ${t4[i3 + 1]} ${0 === i3 ? "m" : "l"}`);
                e4.push("S");
              }
              return [
                t3[0],
                t3[2],
                t3[7],
                t3[3]
              ];
            }
          });
        }
      }
    }
    static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
      const { color: r2, opacity: s2, paths: n2, outlines: o2, rect: g2, rotation: c2, thickness: C2 } = e2, h2 = new Dict(t2);
      h2.set("Type", Name.get("Annot"));
      h2.set("Subtype", Name.get("Ink"));
      h2.set("CreationDate", `D:${getModificationDate()}`);
      h2.set("Rect", g2);
      h2.set("InkList", (o2 == null ? void 0 : o2.points) || n2.map((e3) => e3.points));
      h2.set("F", 4);
      h2.set("Rotate", c2);
      o2 && h2.set("IT", Name.get("InkHighlight"));
      const l2 = new Dict(t2);
      h2.set("BS", l2);
      l2.set("W", C2);
      h2.set("C", Array.from(r2, (e3) => e3 / 255));
      h2.set("CA", s2);
      const Q2 = new Dict(t2);
      h2.set("AP", Q2);
      i2 ? Q2.set("N", i2) : Q2.set("N", a2);
      return h2;
    }
    static async createNewAppearanceStream(e2, t2, i2) {
      if (e2.outlines) return this.createNewAppearanceStreamForHighlight(e2, t2, i2);
      const { color: a2, rect: r2, paths: s2, thickness: n2, opacity: o2 } = e2, g2 = [
        `${n2} w 1 J 1 j`,
        `${getPdfColor(a2, false)}`
      ];
      1 !== o2 && g2.push("/R0 gs");
      const c2 = [];
      for (const { bezier: e3 } of s2) {
        c2.length = 0;
        c2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
        if (2 === e3.length) c2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} l S`);
        else {
          for (let t3 = 2, i3 = e3.length; t3 < i3; t3 += 6) {
            const i4 = e3.slice(t3, t3 + 6).map(numberToString).join(" ");
            c2.push(`${i4} c`);
          }
          c2.push("S");
        }
        g2.push(c2.join("\n"));
      }
      const C2 = g2.join("\n"), h2 = new Dict(t2);
      h2.set("FormType", 1);
      h2.set("Subtype", Name.get("Form"));
      h2.set("Type", Name.get("XObject"));
      h2.set("BBox", r2);
      h2.set("Length", C2.length);
      if (1 !== o2) {
        const e3 = new Dict(t2), i3 = new Dict(t2), a3 = new Dict(t2);
        a3.set("CA", o2);
        a3.set("Type", Name.get("ExtGState"));
        i3.set("R0", a3);
        e3.set("ExtGState", i3);
        h2.set("Resources", e3);
      }
      const l2 = new StringStream(C2);
      l2.dict = h2;
      return l2;
    }
    static async createNewAppearanceStreamForHighlight(e2, t2, i2) {
      const { color: a2, rect: r2, outlines: { outline: s2 }, opacity: n2 } = e2, o2 = [
        `${getPdfColor(a2, true)}`,
        "/R0 gs"
      ];
      o2.push(`${numberToString(s2[4])} ${numberToString(s2[5])} m`);
      for (let e3 = 6, t3 = s2.length; e3 < t3; e3 += 6) if (isNaN(s2[e3]) || null === s2[e3]) o2.push(`${numberToString(s2[e3 + 4])} ${numberToString(s2[e3 + 5])} l`);
      else {
        const t4 = s2.slice(e3, e3 + 6).map(numberToString).join(" ");
        o2.push(`${t4} c`);
      }
      o2.push("h f");
      const g2 = o2.join("\n"), c2 = new Dict(t2);
      c2.set("FormType", 1);
      c2.set("Subtype", Name.get("Form"));
      c2.set("Type", Name.get("XObject"));
      c2.set("BBox", r2);
      c2.set("Length", g2.length);
      const C2 = new Dict(t2), h2 = new Dict(t2);
      C2.set("ExtGState", h2);
      c2.set("Resources", C2);
      const l2 = new Dict(t2);
      h2.set("R0", l2);
      l2.set("BM", Name.get("Multiply"));
      if (1 !== n2) {
        l2.set("ca", n2);
        l2.set("Type", Name.get("ExtGState"));
      }
      const Q2 = new StringStream(g2);
      Q2.dict = c2;
      return Q2;
    }
  }
  class HighlightAnnotation extends MarkupAnnotation {
    constructor(e2) {
      var _a4;
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = v;
      this.data.isEditable = !this.data.noHTML;
      this.data.noHTML = false;
      this.data.opacity = t2.get("CA") || 1;
      if (this.data.quadPoints = getQuadPoints(t2, null)) {
        const e3 = (_a4 = this.appearance) == null ? void 0 : _a4.dict.get("Resources");
        if (!this.appearance || !(e3 == null ? void 0 : e3.has("ExtGState"))) {
          this.appearance && warn("HighlightAnnotation - ignoring built-in appearance stream.");
          const e4 = this.color ? getPdfColorArray(this.color) : [
            1,
            1,
            0
          ], a2 = t2.get("CA");
          this._setDefaultAppearance({
            xref: i2,
            fillColor: e4,
            blendMode: "Multiply",
            fillAlpha: a2,
            pointsCallback: (e5, t3) => {
              e5.push(`${t3[0]} ${t3[1]} m`, `${t3[2]} ${t3[3]} l`, `${t3[6]} ${t3[7]} l`, `${t3[4]} ${t3[5]} l`, "f");
              return [
                t3[0],
                t3[2],
                t3[7],
                t3[3]
              ];
            }
          });
        }
      } else this.data.popupRef = null;
    }
    static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
      const { color: r2, oldAnnotation: s2, opacity: n2, rect: o2, rotation: g2, user: c2, quadPoints: C2 } = e2, h2 = s2 || new Dict(t2);
      h2.set("Type", Name.get("Annot"));
      h2.set("Subtype", Name.get("Highlight"));
      h2.set(s2 ? "M" : "CreationDate", `D:${getModificationDate()}`);
      h2.set("CreationDate", `D:${getModificationDate()}`);
      h2.set("Rect", o2);
      h2.set("F", 4);
      h2.set("Border", [
        0,
        0,
        0
      ]);
      h2.set("Rotate", g2);
      h2.set("QuadPoints", C2);
      h2.set("C", Array.from(r2, (e3) => e3 / 255));
      h2.set("CA", n2);
      c2 && h2.set("T", stringToAsciiOrUTF16BE(c2));
      if (i2 || a2) {
        const e3 = new Dict(t2);
        h2.set("AP", e3);
        e3.set("N", i2 || a2);
      }
      return h2;
    }
    static async createNewAppearanceStream(e2, t2, i2) {
      const { color: a2, rect: r2, outlines: s2, opacity: n2 } = e2, o2 = [
        `${getPdfColor(a2, true)}`,
        "/R0 gs"
      ], g2 = [];
      for (const e3 of s2) {
        g2.length = 0;
        g2.push(`${numberToString(e3[0])} ${numberToString(e3[1])} m`);
        for (let t3 = 2, i3 = e3.length; t3 < i3; t3 += 2) g2.push(`${numberToString(e3[t3])} ${numberToString(e3[t3 + 1])} l`);
        g2.push("h");
        o2.push(g2.join("\n"));
      }
      o2.push("f*");
      const c2 = o2.join("\n"), C2 = new Dict(t2);
      C2.set("FormType", 1);
      C2.set("Subtype", Name.get("Form"));
      C2.set("Type", Name.get("XObject"));
      C2.set("BBox", r2);
      C2.set("Length", c2.length);
      const h2 = new Dict(t2), l2 = new Dict(t2);
      h2.set("ExtGState", l2);
      C2.set("Resources", h2);
      const Q2 = new Dict(t2);
      l2.set("R0", Q2);
      Q2.set("BM", Name.get("Multiply"));
      if (1 !== n2) {
        Q2.set("ca", n2);
        Q2.set("Type", Name.get("ExtGState"));
      }
      const E2 = new StringStream(c2);
      E2.dict = C2;
      return E2;
    }
  }
  class UnderlineAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = Y;
      if (this.data.quadPoints = getQuadPoints(t2, null)) {
        if (!this.appearance) {
          const e3 = this.color ? getPdfColorArray(this.color) : [
            0,
            0,
            0
          ], a2 = t2.get("CA");
          this._setDefaultAppearance({
            xref: i2,
            extra: "[] 0 d 0.571 w",
            strokeColor: e3,
            strokeAlpha: a2,
            pointsCallback: (e4, t3) => {
              e4.push(`${t3[4]} ${t3[5] + 1.3} m`, `${t3[6]} ${t3[7] + 1.3} l`, "S");
              return [
                t3[0],
                t3[2],
                t3[7],
                t3[3]
              ];
            }
          });
        }
      } else this.data.popupRef = null;
    }
  }
  class SquigglyAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = T;
      if (this.data.quadPoints = getQuadPoints(t2, null)) {
        if (!this.appearance) {
          const e3 = this.color ? getPdfColorArray(this.color) : [
            0,
            0,
            0
          ], a2 = t2.get("CA");
          this._setDefaultAppearance({
            xref: i2,
            extra: "[] 0 d 1 w",
            strokeColor: e3,
            strokeAlpha: a2,
            pointsCallback: (e4, t3) => {
              const i3 = (t3[1] - t3[5]) / 6;
              let a3 = i3, r2 = t3[4];
              const s2 = t3[5], n2 = t3[6];
              e4.push(`${r2} ${s2 + a3} m`);
              do {
                r2 += 2;
                a3 = 0 === a3 ? i3 : 0;
                e4.push(`${r2} ${s2 + a3} l`);
              } while (r2 < n2);
              e4.push("S");
              return [
                t3[4],
                n2,
                s2 - 2 * i3,
                s2 + 2 * i3
              ];
            }
          });
        }
      } else this.data.popupRef = null;
    }
  }
  class StrikeOutAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2;
      this.data.annotationType = K;
      if (this.data.quadPoints = getQuadPoints(t2, null)) {
        if (!this.appearance) {
          const e3 = this.color ? getPdfColorArray(this.color) : [
            0,
            0,
            0
          ], a2 = t2.get("CA");
          this._setDefaultAppearance({
            xref: i2,
            extra: "[] 0 d 1 w",
            strokeColor: e3,
            strokeAlpha: a2,
            pointsCallback: (e4, t3) => {
              e4.push((t3[0] + t3[4]) / 2 + " " + (t3[1] + t3[5]) / 2 + " m", (t3[2] + t3[6]) / 2 + " " + (t3[3] + t3[7]) / 2 + " l", "S");
              return [
                t3[0],
                t3[2],
                t3[7],
                t3[3]
              ];
            }
          });
        }
      } else this.data.popupRef = null;
    }
  }
  class StampAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      __privateAdd(this, _W);
      this.data.annotationType = q;
      __privateSet(this, _W, this.data.hasOwnCanvas = this.data.noRotate);
      this.data.isEditable = !this.data.noHTML;
      this.data.noHTML = false;
    }
    mustBeViewedWhenEditing(e2, t2 = null) {
      if (e2) {
        if (!this.data.isEditable) return false;
        __privateSet(this, _W, this.data.hasOwnCanvas);
        this.data.hasOwnCanvas = true;
        return true;
      }
      this.data.hasOwnCanvas = __privateGet(this, _W);
      return !(t2 == null ? void 0 : t2.has(this.data.id));
    }
    static async createImage(e2, t2) {
      const { width: i2, height: a2 } = e2, r2 = new OffscreenCanvas(i2, a2), s2 = r2.getContext("2d", {
        alpha: true
      });
      s2.drawImage(e2, 0, 0);
      const n2 = s2.getImageData(0, 0, i2, a2).data, o2 = new Uint32Array(n2.buffer), g2 = o2.some(FeatureTest.isLittleEndian ? (e3) => e3 >>> 24 != 255 : (e3) => 255 != (255 & e3));
      if (g2) {
        s2.fillStyle = "white";
        s2.fillRect(0, 0, i2, a2);
        s2.drawImage(e2, 0, 0);
      }
      const c2 = r2.convertToBlob({
        type: "image/jpeg",
        quality: 1
      }).then((e3) => e3.arrayBuffer()), C2 = Name.get("XObject"), h2 = Name.get("Image"), l2 = new Dict(t2);
      l2.set("Type", C2);
      l2.set("Subtype", h2);
      l2.set("BitsPerComponent", 8);
      l2.set("ColorSpace", Name.get("DeviceRGB"));
      l2.set("Filter", Name.get("DCTDecode"));
      l2.set("BBox", [
        0,
        0,
        i2,
        a2
      ]);
      l2.set("Width", i2);
      l2.set("Height", a2);
      let Q2 = null;
      if (g2) {
        const e3 = new Uint8Array(o2.length);
        if (FeatureTest.isLittleEndian) for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) e3[t3] = o2[t3] >>> 24;
        else for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) e3[t3] = 255 & o2[t3];
        const r3 = new Dict(t2);
        r3.set("Type", C2);
        r3.set("Subtype", h2);
        r3.set("BitsPerComponent", 8);
        r3.set("ColorSpace", Name.get("DeviceGray"));
        r3.set("Width", i2);
        r3.set("Height", a2);
        Q2 = new Stream(e3, 0, 0, r3);
      }
      return {
        imageStream: new Stream(await c2, 0, 0, l2),
        smaskStream: Q2,
        width: i2,
        height: a2
      };
    }
    static createNewDict(e2, t2, { apRef: i2, ap: a2 }) {
      const { oldAnnotation: r2, rect: s2, rotation: n2, user: o2 } = e2, g2 = r2 || new Dict(t2);
      g2.set("Type", Name.get("Annot"));
      g2.set("Subtype", Name.get("Stamp"));
      g2.set(r2 ? "M" : "CreationDate", `D:${getModificationDate()}`);
      g2.set("CreationDate", `D:${getModificationDate()}`);
      g2.set("Rect", s2);
      g2.set("F", 4);
      g2.set("Border", [
        0,
        0,
        0
      ]);
      g2.set("Rotate", n2);
      o2 && g2.set("T", stringToAsciiOrUTF16BE(o2));
      if (i2 || a2) {
        const e3 = new Dict(t2);
        g2.set("AP", e3);
        i2 ? e3.set("N", i2) : e3.set("N", a2);
      }
      return g2;
    }
    static async createNewAppearanceStream(e2, t2, i2) {
      if (e2.oldAnnotation) return null;
      const { rotation: a2 } = e2, { imageRef: r2, width: s2, height: n2 } = i2.image, o2 = new Dict(t2), g2 = new Dict(t2);
      o2.set("XObject", g2);
      g2.set("Im0", r2);
      const c2 = `q ${s2} 0 0 ${n2} 0 0 cm /Im0 Do Q`, C2 = new Dict(t2);
      C2.set("FormType", 1);
      C2.set("Subtype", Name.get("Form"));
      C2.set("Type", Name.get("XObject"));
      C2.set("BBox", [
        0,
        0,
        s2,
        n2
      ]);
      C2.set("Resources", o2);
      if (a2) {
        const e3 = getRotationMatrix(a2, s2, n2);
        C2.set("Matrix", e3);
      }
      const h2 = new StringStream(c2);
      h2.dict = C2;
      return h2;
    }
  }
  _W = new WeakMap();
  class FileAttachmentAnnotation extends MarkupAnnotation {
    constructor(e2) {
      super(e2);
      const { dict: t2, xref: i2 } = e2, a2 = new FileSpec(t2.get("FS"), i2);
      this.data.annotationType = X;
      this.data.hasOwnCanvas = this.data.noRotate;
      this.data.noHTML = false;
      this.data.file = a2.serializable;
      const r2 = t2.get("Name");
      this.data.name = r2 instanceof Name ? stringToPDFString(r2.name) : "PushPin";
      const s2 = t2.get("ca");
      this.data.fillAlpha = "number" == typeof s2 && s2 >= 0 && s2 <= 1 ? s2 : null;
    }
  }
  function decodeString(e2) {
    try {
      return stringToUTF8String(e2);
    } catch (t2) {
      warn(`UTF-8 decoding failed: "${t2}".`);
      return e2;
    }
  }
  class DatasetXMLParser extends SimpleXMLParser {
    constructor(e2) {
      super(e2);
      this.node = null;
    }
    onEndElement(e2) {
      const t2 = super.onEndElement(e2);
      if (t2 && "xfa:datasets" === e2) {
        this.node = t2;
        throw new Error("Aborting DatasetXMLParser.");
      }
    }
  }
  class DatasetReader {
    constructor(e2) {
      if (e2.datasets) this.node = new SimpleXMLParser({
        hasAttributes: true
      }).parseFromString(e2.datasets).documentElement;
      else {
        const t2 = new DatasetXMLParser({
          hasAttributes: true
        });
        try {
          t2.parseFromString(e2["xdp:xdp"]);
        } catch {
        }
        this.node = t2.node;
      }
    }
    getValue(e2) {
      if (!this.node || !e2) return "";
      const t2 = this.node.searchNode(parseXFAPath(e2), 0);
      if (!t2) return "";
      const i2 = t2.firstChild;
      return "value" === (i2 == null ? void 0 : i2.nodeName) ? t2.children.map((e3) => decodeString(e3.textContent)) : decodeString(t2.textContent);
    }
  }
  class XRef {
    constructor(e2, t2) {
      __privateAdd(this, _j, null);
      this.stream = e2;
      this.pdfManager = t2;
      this.entries = [];
      this._xrefStms = /* @__PURE__ */ new Set();
      this._cacheMap = /* @__PURE__ */ new Map();
      this._pendingRefs = new RefSet();
      this._newPersistentRefNum = null;
      this._newTemporaryRefNum = null;
      this._persistentRefsCache = null;
    }
    getNewPersistentRef(e2) {
      null === this._newPersistentRefNum && (this._newPersistentRefNum = this.entries.length || 1);
      const t2 = this._newPersistentRefNum++;
      this._cacheMap.set(t2, e2);
      return Ref.get(t2, 0);
    }
    getNewTemporaryRef() {
      if (null === this._newTemporaryRefNum) {
        this._newTemporaryRefNum = this.entries.length || 1;
        if (this._newPersistentRefNum) {
          this._persistentRefsCache = /* @__PURE__ */ new Map();
          for (let e2 = this._newTemporaryRefNum; e2 < this._newPersistentRefNum; e2++) {
            this._persistentRefsCache.set(e2, this._cacheMap.get(e2));
            this._cacheMap.delete(e2);
          }
        }
      }
      return Ref.get(this._newTemporaryRefNum++, 0);
    }
    resetNewTemporaryRef() {
      this._newTemporaryRefNum = null;
      if (this._persistentRefsCache) for (const [e2, t2] of this._persistentRefsCache) this._cacheMap.set(e2, t2);
      this._persistentRefsCache = null;
    }
    setStartXRef(e2) {
      this.startXRefQueue = [
        e2
      ];
    }
    parse(e2 = false) {
      let t2, i2, a2;
      if (e2) {
        warn("Indexing all PDF objects");
        t2 = this.indexObjects();
      } else t2 = this.readXRef();
      t2.assignXref(this);
      this.trailer = t2;
      try {
        i2 = t2.get("Encrypt");
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(`XRef.parse - Invalid "Encrypt" reference: "${e3}".`);
      }
      if (i2 instanceof Dict) {
        const e3 = t2.get("ID"), a3 = (e3 == null ? void 0 : e3.length) ? e3[0] : "";
        i2.suppressEncryption = true;
        this.encrypt = new CipherTransformFactory(i2, a3, this.pdfManager.password);
      }
      try {
        a2 = t2.get("Root");
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(`XRef.parse - Invalid "Root" reference: "${e3}".`);
      }
      if (a2 instanceof Dict) try {
        if (a2.get("Pages") instanceof Dict) {
          this.root = a2;
          return;
        }
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(`XRef.parse - Invalid "Pages" reference: "${e3}".`);
      }
      if (!e2) throw new XRefParseException();
      throw new InvalidPDFException("Invalid Root reference.");
    }
    processXRefTable(e2) {
      "tableState" in this || (this.tableState = {
        entryNum: 0,
        streamPos: e2.lexer.stream.pos,
        parserBuf1: e2.buf1,
        parserBuf2: e2.buf2
      });
      if (!isCmd(this.readXRefTable(e2), "trailer")) throw new FormatError("Invalid XRef table: could not find trailer dictionary");
      let t2 = e2.getObj();
      t2 instanceof Dict || !t2.dict || (t2 = t2.dict);
      if (!(t2 instanceof Dict)) throw new FormatError("Invalid XRef table: could not parse trailer dictionary");
      delete this.tableState;
      return t2;
    }
    readXRefTable(e2) {
      const t2 = e2.lexer.stream, i2 = this.tableState;
      t2.pos = i2.streamPos;
      e2.buf1 = i2.parserBuf1;
      e2.buf2 = i2.parserBuf2;
      let a2;
      for (; ; ) {
        if (!("firstEntryNum" in i2) || !("entryCount" in i2)) {
          if (isCmd(a2 = e2.getObj(), "trailer")) break;
          i2.firstEntryNum = a2;
          i2.entryCount = e2.getObj();
        }
        let r2 = i2.firstEntryNum;
        const s2 = i2.entryCount;
        if (!Number.isInteger(r2) || !Number.isInteger(s2)) throw new FormatError("Invalid XRef table: wrong types in subsection header");
        for (let a3 = i2.entryNum; a3 < s2; a3++) {
          i2.streamPos = t2.pos;
          i2.entryNum = a3;
          i2.parserBuf1 = e2.buf1;
          i2.parserBuf2 = e2.buf2;
          const n2 = {};
          n2.offset = e2.getObj();
          n2.gen = e2.getObj();
          const o2 = e2.getObj();
          if (o2 instanceof Cmd) switch (o2.cmd) {
            case "f":
              n2.free = true;
              break;
            case "n":
              n2.uncompressed = true;
          }
          if (!Number.isInteger(n2.offset) || !Number.isInteger(n2.gen) || !n2.free && !n2.uncompressed) throw new FormatError(`Invalid entry in XRef subsection: ${r2}, ${s2}`);
          0 === a3 && n2.free && 1 === r2 && (r2 = 0);
          this.entries[a3 + r2] || (this.entries[a3 + r2] = n2);
        }
        i2.entryNum = 0;
        i2.streamPos = t2.pos;
        i2.parserBuf1 = e2.buf1;
        i2.parserBuf2 = e2.buf2;
        delete i2.firstEntryNum;
        delete i2.entryCount;
      }
      if (this.entries[0] && !this.entries[0].free) throw new FormatError("Invalid XRef table: unexpected first object");
      return a2;
    }
    processXRefStream(e2) {
      if (!("streamState" in this)) {
        const t2 = e2.dict, i2 = t2.get("W");
        let a2 = t2.get("Index");
        a2 || (a2 = [
          0,
          t2.get("Size")
        ]);
        this.streamState = {
          entryRanges: a2,
          byteWidths: i2,
          entryNum: 0,
          streamPos: e2.pos
        };
      }
      this.readXRefStream(e2);
      delete this.streamState;
      return e2.dict;
    }
    readXRefStream(e2) {
      const t2 = this.streamState;
      e2.pos = t2.streamPos;
      const [i2, a2, r2] = t2.byteWidths, s2 = t2.entryRanges;
      for (; s2.length > 0; ) {
        const [n2, o2] = s2;
        if (!Number.isInteger(n2) || !Number.isInteger(o2)) throw new FormatError(`Invalid XRef range fields: ${n2}, ${o2}`);
        if (!Number.isInteger(i2) || !Number.isInteger(a2) || !Number.isInteger(r2)) throw new FormatError(`Invalid XRef entry fields length: ${n2}, ${o2}`);
        for (let s3 = t2.entryNum; s3 < o2; ++s3) {
          t2.entryNum = s3;
          t2.streamPos = e2.pos;
          let o3 = 0, g2 = 0, c2 = 0;
          for (let t3 = 0; t3 < i2; ++t3) {
            const t4 = e2.getByte();
            if (-1 === t4) throw new FormatError("Invalid XRef byteWidths 'type'.");
            o3 = o3 << 8 | t4;
          }
          0 === i2 && (o3 = 1);
          for (let t3 = 0; t3 < a2; ++t3) {
            const t4 = e2.getByte();
            if (-1 === t4) throw new FormatError("Invalid XRef byteWidths 'offset'.");
            g2 = g2 << 8 | t4;
          }
          for (let t3 = 0; t3 < r2; ++t3) {
            const t4 = e2.getByte();
            if (-1 === t4) throw new FormatError("Invalid XRef byteWidths 'generation'.");
            c2 = c2 << 8 | t4;
          }
          const C2 = {};
          C2.offset = g2;
          C2.gen = c2;
          switch (o3) {
            case 0:
              C2.free = true;
              break;
            case 1:
              C2.uncompressed = true;
              break;
            case 2:
              break;
            default:
              throw new FormatError(`Invalid XRef entry type: ${o3}`);
          }
          this.entries[n2 + s3] || (this.entries[n2 + s3] = C2);
        }
        t2.entryNum = 0;
        t2.streamPos = e2.pos;
        s2.splice(0, 2);
      }
    }
    indexObjects() {
      function readToken(e3, t3) {
        let i3 = "", a3 = e3[t3];
        for (; 10 !== a3 && 13 !== a3 && 60 !== a3 && !(++t3 >= e3.length); ) {
          i3 += String.fromCharCode(a3);
          a3 = e3[t3];
        }
        return i3;
      }
      function skipUntil(e3, t3, i3) {
        const a3 = i3.length, r3 = e3.length;
        let s3 = 0;
        for (; t3 < r3; ) {
          let r4 = 0;
          for (; r4 < a3 && e3[t3 + r4] === i3[r4]; ) ++r4;
          if (r4 >= a3) break;
          t3++;
          s3++;
        }
        return s3;
      }
      const e2 = /\b(endobj|\d+\s+\d+\s+obj|xref|trailer\s*<<)\b/g, t2 = /\b(startxref|\d+\s+\d+\s+obj)\b/g, i2 = /^(\d+)\s+(\d+)\s+obj\b/, a2 = new Uint8Array([
        116,
        114,
        97,
        105,
        108,
        101,
        114
      ]), r2 = new Uint8Array([
        115,
        116,
        97,
        114,
        116,
        120,
        114,
        101,
        102
      ]), s2 = new Uint8Array([
        47,
        88,
        82,
        101,
        102
      ]);
      this.entries.length = 0;
      this._cacheMap.clear();
      const n2 = this.stream;
      n2.pos = 0;
      const o2 = n2.getBytes(), g2 = bytesToString(o2), c2 = o2.length;
      let C2 = n2.start;
      const h2 = [], l2 = [];
      for (; C2 < c2; ) {
        let Q3 = o2[C2];
        if (9 === Q3 || 10 === Q3 || 13 === Q3 || 32 === Q3) {
          ++C2;
          continue;
        }
        if (37 === Q3) {
          do {
            ++C2;
            if (C2 >= c2) break;
            Q3 = o2[C2];
          } while (10 !== Q3 && 13 !== Q3);
          continue;
        }
        const E3 = readToken(o2, C2);
        let u3;
        if (E3.startsWith("xref") && (4 === E3.length || /\s/.test(E3[4]))) {
          C2 += skipUntil(o2, C2, a2);
          h2.push(C2);
          C2 += skipUntil(o2, C2, r2);
        } else if (u3 = i2.exec(E3)) {
          const t3 = 0 | u3[1], i3 = 0 | u3[2], a3 = C2 + E3.length;
          let r3, h3 = false;
          if (this.entries[t3]) {
            if (this.entries[t3].gen === i3) try {
              new Parser({
                lexer: new Lexer(n2.makeSubStream(a3))
              }).getObj();
              h3 = true;
            } catch (e3) {
              e3 instanceof ParserEOFException ? warn(`indexObjects -- checking object (${E3}): "${e3}".`) : h3 = true;
            }
          } else h3 = true;
          h3 && (this.entries[t3] = {
            offset: C2 - n2.start,
            gen: i3,
            uncompressed: true
          });
          e2.lastIndex = a3;
          const Q4 = e2.exec(g2);
          if (Q4) {
            r3 = e2.lastIndex + 1 - C2;
            if ("endobj" !== Q4[1]) {
              warn(`indexObjects: Found "${Q4[1]}" inside of another "obj", caused by missing "endobj" -- trying to recover.`);
              r3 -= Q4[1].length + 1;
            }
          } else r3 = c2 - C2;
          const d3 = o2.subarray(C2, C2 + r3), f2 = skipUntil(d3, 0, s2);
          if (f2 < r3 && d3[f2 + 5] < 64) {
            l2.push(C2 - n2.start);
            this._xrefStms.add(C2 - n2.start);
          }
          C2 += r3;
        } else if (E3.startsWith("trailer") && (7 === E3.length || /\s/.test(E3[7]))) {
          h2.push(C2);
          const e3 = C2 + E3.length;
          let i3;
          t2.lastIndex = e3;
          const a3 = t2.exec(g2);
          if (a3) {
            i3 = t2.lastIndex + 1 - C2;
            if ("startxref" !== a3[1]) {
              warn(`indexObjects: Found "${a3[1]}" after "trailer", caused by missing "startxref" -- trying to recover.`);
              i3 -= a3[1].length + 1;
            }
          } else i3 = c2 - C2;
          C2 += i3;
        } else C2 += E3.length + 1;
      }
      for (const e3 of l2) {
        this.startXRefQueue.push(e3);
        this.readXRef(true);
      }
      const Q2 = [];
      let E2, u2, d2 = false;
      for (const e3 of h2) {
        n2.pos = e3;
        const t3 = new Parser({
          lexer: new Lexer(n2),
          xref: this,
          allowStreams: true,
          recoveryMode: true
        });
        if (!isCmd(t3.getObj(), "trailer")) continue;
        const i3 = t3.getObj();
        if (i3 instanceof Dict) {
          Q2.push(i3);
          i3.has("Encrypt") && (d2 = true);
        }
      }
      for (const e3 of [
        ...Q2,
        "genFallback",
        ...Q2
      ]) {
        if ("genFallback" === e3) {
          if (!u2) break;
          this._generationFallback = true;
          continue;
        }
        let t3 = false;
        try {
          const i3 = e3.get("Root");
          if (!(i3 instanceof Dict)) continue;
          const a3 = i3.get("Pages");
          if (!(a3 instanceof Dict)) continue;
          const r3 = a3.get("Count");
          Number.isInteger(r3) && (t3 = true);
        } catch (e4) {
          u2 = e4;
          continue;
        }
        if (t3 && (!d2 || e3.has("Encrypt")) && e3.has("ID")) return e3;
        E2 = e3;
      }
      if (E2) return E2;
      if (this.topDict) return this.topDict;
      throw new InvalidPDFException("Invalid PDF structure.");
    }
    readXRef(e2 = false) {
      const t2 = this.stream, i2 = /* @__PURE__ */ new Set();
      for (; this.startXRefQueue.length; ) {
        try {
          const e3 = this.startXRefQueue[0];
          if (i2.has(e3)) {
            warn("readXRef - skipping XRef table since it was already parsed.");
            this.startXRefQueue.shift();
            continue;
          }
          i2.add(e3);
          t2.pos = e3 + t2.start;
          const a2 = new Parser({
            lexer: new Lexer(t2),
            xref: this,
            allowStreams: true
          });
          let r2, s2 = a2.getObj();
          if (isCmd(s2, "xref")) {
            r2 = this.processXRefTable(a2);
            this.topDict || (this.topDict = r2);
            s2 = r2.get("XRefStm");
            if (Number.isInteger(s2) && !this._xrefStms.has(s2)) {
              this._xrefStms.add(s2);
              this.startXRefQueue.push(s2);
              __privateGet(this, _j) ?? __privateSet(this, _j, s2);
            }
          } else {
            if (!Number.isInteger(s2)) throw new FormatError("Invalid XRef stream header");
            if (!(Number.isInteger(a2.getObj()) && isCmd(a2.getObj(), "obj") && (s2 = a2.getObj()) instanceof BaseStream)) throw new FormatError("Invalid XRef stream");
            r2 = this.processXRefStream(s2);
            this.topDict || (this.topDict = r2);
            if (!r2) throw new FormatError("Failed to read XRef stream");
          }
          s2 = r2.get("Prev");
          Number.isInteger(s2) ? this.startXRefQueue.push(s2) : s2 instanceof Ref && this.startXRefQueue.push(s2.num);
        } catch (e3) {
          if (e3 instanceof MissingDataException) throw e3;
          info("(while reading XRef): " + e3);
        }
        this.startXRefQueue.shift();
      }
      if (this.topDict) return this.topDict;
      if (!e2) throw new XRefParseException();
    }
    get lastXRefStreamPos() {
      return __privateGet(this, _j) ?? (this._xrefStms.size > 0 ? Math.max(...this._xrefStms) : null);
    }
    getEntry(e2) {
      const t2 = this.entries[e2];
      return t2 && !t2.free && t2.offset ? t2 : null;
    }
    fetchIfRef(e2, t2 = false) {
      return e2 instanceof Ref ? this.fetch(e2, t2) : e2;
    }
    fetch(e2, t2 = false) {
      if (!(e2 instanceof Ref)) throw new Error("ref object is not a reference");
      const i2 = e2.num, a2 = this._cacheMap.get(i2);
      if (void 0 !== a2) {
        a2 instanceof Dict && !a2.objId && (a2.objId = e2.toString());
        return a2;
      }
      let r2 = this.getEntry(i2);
      if (null === r2) {
        this._cacheMap.set(i2, r2);
        return r2;
      }
      if (this._pendingRefs.has(e2)) {
        this._pendingRefs.remove(e2);
        warn(`Ignoring circular reference: ${e2}.`);
        return wt;
      }
      this._pendingRefs.put(e2);
      try {
        r2 = r2.uncompressed ? this.fetchUncompressed(e2, r2, t2) : this.fetchCompressed(e2, r2, t2);
        this._pendingRefs.remove(e2);
      } catch (t3) {
        this._pendingRefs.remove(e2);
        throw t3;
      }
      r2 instanceof Dict ? r2.objId = e2.toString() : r2 instanceof BaseStream && (r2.dict.objId = e2.toString());
      return r2;
    }
    fetchUncompressed(e2, t2, i2 = false) {
      const a2 = e2.gen;
      let r2 = e2.num;
      if (t2.gen !== a2) {
        const s3 = `Inconsistent generation in XRef: ${e2}`;
        if (this._generationFallback && t2.gen < a2) {
          warn(s3);
          return this.fetchUncompressed(Ref.get(r2, t2.gen), t2, i2);
        }
        throw new XRefEntryException(s3);
      }
      const s2 = this.stream.makeSubStream(t2.offset + this.stream.start), n2 = new Parser({
        lexer: new Lexer(s2),
        xref: this,
        allowStreams: true
      }), o2 = n2.getObj(), g2 = n2.getObj(), c2 = n2.getObj();
      if (o2 !== r2 || g2 !== a2 || !(c2 instanceof Cmd)) throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
      if ("obj" !== c2.cmd) {
        if (c2.cmd.startsWith("obj")) {
          r2 = parseInt(c2.cmd.substring(3), 10);
          if (!Number.isNaN(r2)) return r2;
        }
        throw new XRefEntryException(`Bad (uncompressed) XRef entry: ${e2}`);
      }
      (t2 = this.encrypt && !i2 ? n2.getObj(this.encrypt.createCipherTransform(r2, a2)) : n2.getObj()) instanceof BaseStream || this._cacheMap.set(r2, t2);
      return t2;
    }
    fetchCompressed(e2, t2, i2 = false) {
      const a2 = t2.offset, r2 = this.fetch(Ref.get(a2, 0));
      if (!(r2 instanceof BaseStream)) throw new FormatError("bad ObjStm stream");
      const s2 = r2.dict.get("First"), n2 = r2.dict.get("N");
      if (!Number.isInteger(s2) || !Number.isInteger(n2)) throw new FormatError("invalid first and n parameters for ObjStm stream");
      let o2 = new Parser({
        lexer: new Lexer(r2),
        xref: this,
        allowStreams: true
      });
      const g2 = new Array(n2), c2 = new Array(n2);
      for (let e3 = 0; e3 < n2; ++e3) {
        const t3 = o2.getObj();
        if (!Number.isInteger(t3)) throw new FormatError(`invalid object number in the ObjStm stream: ${t3}`);
        const i3 = o2.getObj();
        if (!Number.isInteger(i3)) throw new FormatError(`invalid object offset in the ObjStm stream: ${i3}`);
        g2[e3] = t3;
        c2[e3] = i3;
      }
      const C2 = (r2.start || 0) + s2, h2 = new Array(n2);
      for (let e3 = 0; e3 < n2; ++e3) {
        const t3 = e3 < n2 - 1 ? c2[e3 + 1] - c2[e3] : void 0;
        if (t3 < 0) throw new FormatError("Invalid offset in the ObjStm stream.");
        o2 = new Parser({
          lexer: new Lexer(r2.makeSubStream(C2 + c2[e3], t3, r2.dict)),
          xref: this,
          allowStreams: true
        });
        const i3 = o2.getObj();
        h2[e3] = i3;
        if (i3 instanceof BaseStream) continue;
        const s3 = g2[e3], l2 = this.entries[s3];
        l2 && l2.offset === a2 && l2.gen === e3 && this._cacheMap.set(s3, i3);
      }
      if (void 0 === (t2 = h2[t2.gen])) throw new XRefEntryException(`Bad (compressed) XRef entry: ${e2}`);
      return t2;
    }
    async fetchIfRefAsync(e2, t2) {
      return e2 instanceof Ref ? this.fetchAsync(e2, t2) : e2;
    }
    async fetchAsync(e2, t2) {
      try {
        return this.fetch(e2, t2);
      } catch (i2) {
        if (!(i2 instanceof MissingDataException)) throw i2;
        await this.pdfManager.requestRange(i2.begin, i2.end);
        return this.fetchAsync(e2, t2);
      }
    }
    getCatalogObj() {
      return this.root;
    }
  }
  _j = new WeakMap();
  const Io = [
    0,
    0,
    612,
    792
  ];
  class Page {
    constructor({ pdfManager: e2, xref: t2, pageIndex: i2, pageDict: a2, ref: r2, globalIdFactory: s2, fontCache: n2, builtInCMapCache: o2, standardFontDataCache: g2, globalImageCache: c2, systemFontCache: C2, nonBlendModesSet: h2, xfaFactory: l2 }) {
      __privateAdd(this, _Page_instances);
      this.pdfManager = e2;
      this.pageIndex = i2;
      this.pageDict = a2;
      this.xref = t2;
      this.ref = r2;
      this.fontCache = n2;
      this.builtInCMapCache = o2;
      this.standardFontDataCache = g2;
      this.globalImageCache = c2;
      this.systemFontCache = C2;
      this.nonBlendModesSet = h2;
      this.evaluatorOptions = e2.evaluatorOptions;
      this.resourcesPromise = null;
      this.xfaFactory = l2;
      const Q2 = {
        obj: 0
      };
      this._localIdFactory = class extends s2 {
        static createObjId() {
          return `p${i2}_${++Q2.obj}`;
        }
        static getPageObjId() {
          return `p${r2.toString()}`;
        }
      };
    }
    _getInheritableProperty(e2, t2 = false) {
      const i2 = getInheritableProperty({
        dict: this.pageDict,
        key: e2,
        getArray: t2,
        stopWhenFound: false
      });
      return Array.isArray(i2) ? 1 !== i2.length && i2[0] instanceof Dict ? Dict.merge({
        xref: this.xref,
        dictArray: i2
      }) : i2[0] : i2;
    }
    get content() {
      return this.pageDict.getArray("Contents");
    }
    get resources() {
      const e2 = this._getInheritableProperty("Resources");
      return shadow(this, "resources", e2 instanceof Dict ? e2 : Dict.empty);
    }
    _getBoundingBox(e2) {
      if (this.xfaData) return this.xfaData.bbox;
      const t2 = lookupNormalRect(this._getInheritableProperty(e2, true), null);
      if (t2) {
        if (t2[2] - t2[0] > 0 && t2[3] - t2[1] > 0) return t2;
        warn(`Empty, or invalid, /${e2} entry.`);
      }
      return null;
    }
    get mediaBox() {
      return shadow(this, "mediaBox", this._getBoundingBox("MediaBox") || Io);
    }
    get cropBox() {
      return shadow(this, "cropBox", this._getBoundingBox("CropBox") || this.mediaBox);
    }
    get userUnit() {
      let e2 = this.pageDict.get("UserUnit");
      ("number" != typeof e2 || e2 <= 0) && (e2 = 1);
      return shadow(this, "userUnit", e2);
    }
    get view() {
      const { cropBox: e2, mediaBox: t2 } = this;
      if (e2 !== t2 && !isArrayEqual(e2, t2)) {
        const i2 = Util.intersect(e2, t2);
        if (i2 && i2[2] - i2[0] > 0 && i2[3] - i2[1] > 0) return shadow(this, "view", i2);
        warn("Empty /CropBox and /MediaBox intersection.");
      }
      return shadow(this, "view", t2);
    }
    get rotate() {
      let e2 = this._getInheritableProperty("Rotate") || 0;
      e2 % 90 != 0 ? e2 = 0 : e2 >= 360 ? e2 %= 360 : e2 < 0 && (e2 = (e2 % 360 + 360) % 360);
      return shadow(this, "rotate", e2);
    }
    _onSubStreamError(e2, t2) {
      if (!this.evaluatorOptions.ignoreErrors) throw e2;
      warn(`getContentStream - ignoring sub-stream (${t2}): "${e2}".`);
    }
    getContentStream() {
      return this.pdfManager.ensure(this, "content").then((e2) => e2 instanceof BaseStream ? e2 : Array.isArray(e2) ? new StreamsSequenceStream(e2, this._onSubStreamError.bind(this)) : new NullStream());
    }
    get xfaData() {
      return shadow(this, "xfaData", this.xfaFactory ? {
        bbox: this.xfaFactory.getBoundingBox(this.pageIndex)
      } : null);
    }
    async saveNewAnnotations(e2, t2, i2, a2) {
      if (this.xfaFactory) throw new Error("XFA: Cannot save new annotations.");
      const r2 = new PartialEvaluator({
        xref: this.xref,
        handler: e2,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        options: this.evaluatorOptions
      }), s2 = new RefSetCache(), n2 = new RefSet();
      await __privateMethod(this, _Page_instances, X_fn).call(this, i2, s2, n2);
      const o2 = this.pageDict, g2 = this.annotations.filter((e3) => !(e3 instanceof Ref && s2.has(e3))), c2 = await AnnotationFactory.saveNewAnnotations(r2, t2, i2, a2);
      for (const { ref: e3 } of c2.annotations) e3 instanceof Ref && !n2.has(e3) && g2.push(e3);
      const C2 = o2.get("Annots");
      o2.set("Annots", g2);
      const h2 = [];
      await writeObject(this.ref, o2, h2, this.xref);
      C2 && o2.set("Annots", C2);
      const l2 = c2.dependencies;
      l2.push({
        ref: this.ref,
        data: h2.join("")
      }, ...c2.annotations);
      for (const e3 of s2) l2.push({
        ref: e3,
        data: null
      });
      return l2;
    }
    save(e2, t2, i2) {
      const a2 = new PartialEvaluator({
        xref: this.xref,
        handler: e2,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        options: this.evaluatorOptions
      });
      return this._parsedAnnotations.then(function(e3) {
        const r2 = [];
        for (const s2 of e3) r2.push(s2.save(a2, t2, i2).catch(function(e4) {
          warn(`save - ignoring annotation data during "${t2.name}" task: "${e4}".`);
          return null;
        }));
        return Promise.all(r2).then(function(e4) {
          return e4.filter((e5) => !!e5);
        });
      });
    }
    loadResources(e2) {
      this.resourcesPromise || (this.resourcesPromise = this.pdfManager.ensure(this, "resources"));
      return this.resourcesPromise.then(() => new ObjectLoader(this.resources, e2, this.xref).load());
    }
    getOperatorList({ handler: e2, sink: t2, task: i2, intent: a2, cacheKey: r2, annotationStorage: s2 = null, modifiedIds: n2 = null }) {
      const o2 = this.getContentStream(), h2 = this.loadResources([
        "ColorSpace",
        "ExtGState",
        "Font",
        "Pattern",
        "Properties",
        "Shading",
        "XObject"
      ]), u2 = new PartialEvaluator({
        xref: this.xref,
        handler: e2,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        options: this.evaluatorOptions
      }), f2 = this.xfaFactory ? null : getNewAnnotationsMap(s2), p2 = f2 == null ? void 0 : f2.get(this.pageIndex);
      let m2 = Promise.resolve(null), y2 = null;
      if (p2) {
        const e3 = this.pdfManager.ensureDoc("annotationGlobals");
        let t3;
        const a3 = /* @__PURE__ */ new Set();
        for (const { bitmapId: e4, bitmap: t4 } of p2) !e4 || t4 || a3.has(e4) || a3.add(e4);
        const { isOffscreenCanvasSupported: r3 } = this.evaluatorOptions;
        if (a3.size > 0) {
          const e4 = p2.slice();
          for (const [t4, i3] of s2) t4.startsWith(d) && i3.bitmap && a3.has(i3.bitmapId) && e4.push(i3);
          t3 = AnnotationFactory.generateImages(e4, this.xref, r3);
        } else t3 = AnnotationFactory.generateImages(p2, this.xref, r3);
        y2 = new RefSet();
        m2 = Promise.all([
          e3,
          __privateMethod(this, _Page_instances, X_fn).call(this, p2, y2, null)
        ]).then(([e4]) => e4 ? AnnotationFactory.printNewAnnotations(e4, u2, i2, p2, t3) : null);
      }
      const w2 = Promise.all([
        o2,
        h2
      ]).then(([s3]) => {
        const n3 = new OperatorList(a2, t2);
        e2.send("StartRenderPage", {
          transparency: u2.hasBlendModes(this.resources, this.nonBlendModesSet),
          pageIndex: this.pageIndex,
          cacheKey: r2
        });
        return u2.getOperatorList({
          stream: s3,
          task: i2,
          resources: this.resources,
          operatorList: n3
        }).then(function() {
          return n3;
        });
      });
      return Promise.all([
        w2,
        this._parsedAnnotations,
        m2
      ]).then(function([e3, t3, r3]) {
        if (r3) {
          t3 = t3.filter((e4) => !(e4.ref && y2.has(e4.ref)));
          for (let e4 = 0, i3 = r3.length; e4 < i3; e4++) {
            const a3 = r3[e4];
            if (a3.refToReplace) {
              const s3 = t3.findIndex((e5) => e5.ref && isRefsEqual(e5.ref, a3.refToReplace));
              if (s3 >= 0) {
                t3.splice(s3, 1, a3);
                r3.splice(e4--, 1);
                i3--;
              }
            }
          }
          t3 = t3.concat(r3);
        }
        if (0 === t3.length || a2 & Q) {
          e3.flush(true);
          return {
            length: e3.totalLength
          };
        }
        const o3 = !!(a2 & l), h3 = !!(a2 & E), d2 = !!(a2 & g), f3 = !!(a2 & c), p3 = !!(a2 & C), m3 = [];
        for (const e4 of t3) (d2 || f3 && e4.mustBeViewed(s2, o3) && e4.mustBeViewedWhenEditing(h3, n2) || p3 && e4.mustBePrinted(s2)) && m3.push(e4.getOperatorList(u2, i2, a2, s2).catch(function(e5) {
          warn(`getOperatorList - ignoring annotation data during "${i2.name}" task: "${e5}".`);
          return {
            opList: null,
            separateForm: false,
            separateCanvas: false
          };
        }));
        return Promise.all(m3).then(function(t4) {
          let i3 = false, a3 = false;
          for (const { opList: r4, separateForm: s3, separateCanvas: n3 } of t4) {
            e3.addOpList(r4);
            i3 || (i3 = s3);
            a3 || (a3 = n3);
          }
          e3.flush(true, {
            form: i3,
            canvas: a3
          });
          return {
            length: e3.totalLength
          };
        });
      });
    }
    async extractTextContent({ handler: e2, task: t2, includeMarkedContent: i2, disableNormalization: a2, sink: r2 }) {
      const s2 = this.getContentStream(), n2 = this.loadResources([
        "ExtGState",
        "Font",
        "Properties",
        "XObject"
      ]), o2 = this.pdfManager.ensureCatalog("lang"), [g2, , c2] = await Promise.all([
        s2,
        n2,
        o2
      ]);
      return new PartialEvaluator({
        xref: this.xref,
        handler: e2,
        pageIndex: this.pageIndex,
        idFactory: this._localIdFactory,
        fontCache: this.fontCache,
        builtInCMapCache: this.builtInCMapCache,
        standardFontDataCache: this.standardFontDataCache,
        globalImageCache: this.globalImageCache,
        systemFontCache: this.systemFontCache,
        options: this.evaluatorOptions
      }).getTextContent({
        stream: g2,
        task: t2,
        resources: this.resources,
        includeMarkedContent: i2,
        disableNormalization: a2,
        sink: r2,
        viewBox: this.view,
        lang: c2
      });
    }
    async getStructTree() {
      const e2 = await this.pdfManager.ensureCatalog("structTreeRoot");
      if (!e2) return null;
      await this._parsedAnnotations;
      const t2 = await this.pdfManager.ensure(this, "_parseStructTree", [
        e2
      ]);
      return this.pdfManager.ensure(t2, "serializable");
    }
    _parseStructTree(e2) {
      const t2 = new StructTreePage(e2, this.pageDict);
      t2.parse(this.ref);
      return t2;
    }
    async getAnnotationsData(e2, t2, i2) {
      const a2 = await this._parsedAnnotations;
      if (0 === a2.length) return a2;
      const r2 = [], s2 = [];
      let n2;
      const o2 = !!(i2 & g), h2 = !!(i2 & c), l2 = !!(i2 & C);
      for (const i3 of a2) {
        const a3 = o2 || h2 && i3.viewable;
        (a3 || l2 && i3.printable) && r2.push(i3.data);
        if (i3.hasTextContent && a3) {
          n2 || (n2 = new PartialEvaluator({
            xref: this.xref,
            handler: e2,
            pageIndex: this.pageIndex,
            idFactory: this._localIdFactory,
            fontCache: this.fontCache,
            builtInCMapCache: this.builtInCMapCache,
            standardFontDataCache: this.standardFontDataCache,
            globalImageCache: this.globalImageCache,
            systemFontCache: this.systemFontCache,
            options: this.evaluatorOptions
          }));
          s2.push(i3.extractTextContent(n2, t2, [
            -1 / 0,
            -1 / 0,
            1 / 0,
            1 / 0
          ]).catch(function(e3) {
            warn(`getAnnotationsData - ignoring textContent during "${t2.name}" task: "${e3}".`);
          }));
        }
      }
      await Promise.all(s2);
      return r2;
    }
    get annotations() {
      const e2 = this._getInheritableProperty("Annots");
      return shadow(this, "annotations", Array.isArray(e2) ? e2 : []);
    }
    get _parsedAnnotations() {
      return shadow(this, "_parsedAnnotations", this.pdfManager.ensure(this, "annotations").then(async (e2) => {
        if (0 === e2.length) return e2;
        const [t2, i2] = await Promise.all([
          this.pdfManager.ensureDoc("annotationGlobals"),
          this.pdfManager.ensureDoc("fieldObjects")
        ]);
        if (!t2) return [];
        const a2 = i2 == null ? void 0 : i2.orphanFields, r2 = [];
        for (const i3 of e2) r2.push(AnnotationFactory.create(this.xref, i3, t2, this._localIdFactory, false, a2, this.ref).catch(function(e3) {
          warn(`_parsedAnnotations: "${e3}".`);
          return null;
        }));
        const s2 = [];
        let n2, o2;
        for (const e3 of await Promise.all(r2)) e3 && (e3 instanceof WidgetAnnotation ? (o2 || (o2 = [])).push(e3) : e3 instanceof PopupAnnotation ? (n2 || (n2 = [])).push(e3) : s2.push(e3));
        o2 && s2.push(...o2);
        n2 && s2.push(...n2);
        return s2;
      }));
    }
    get jsActions() {
      return shadow(this, "jsActions", collectActions(this.xref, this.pageDict, yA));
    }
  }
  _Page_instances = new WeakSet();
  X_fn = async function(e2, t2, i2) {
    const a2 = [];
    for (const r2 of e2) if (r2.id) {
      const e3 = Ref.fromString(r2.id);
      if (!e3) {
        warn(`A non-linked annotation cannot be modified: ${r2.id}`);
        continue;
      }
      if (r2.deleted) {
        t2.put(e3, e3);
        if (r2.popupRef) {
          const e4 = Ref.fromString(r2.popupRef);
          e4 && t2.put(e4, e4);
        }
        continue;
      }
      i2 == null ? void 0 : i2.put(e3);
      r2.ref = e3;
      a2.push(this.xref.fetchAsync(e3).then((e4) => {
        e4 instanceof Dict && (r2.oldAnnotation = e4.clone());
      }, () => {
        warn(`Cannot fetch \`oldAnnotation\` for: ${e3}.`);
      }));
      delete r2.id;
    }
    await Promise.all(a2);
  };
  const co = new Uint8Array([
    37,
    80,
    68,
    70,
    45
  ]), Co = new Uint8Array([
    115,
    116,
    97,
    114,
    116,
    120,
    114,
    101,
    102
  ]), ho = new Uint8Array([
    101,
    110,
    100,
    111,
    98,
    106
  ]);
  function find(e2, t2, i2 = 1024, a2 = false) {
    const r2 = t2.length, s2 = e2.peekBytes(i2), n2 = s2.length - r2;
    if (n2 <= 0) return false;
    if (a2) {
      const i3 = r2 - 1;
      let a3 = s2.length - 1;
      for (; a3 >= i3; ) {
        let n3 = 0;
        for (; n3 < r2 && s2[a3 - n3] === t2[i3 - n3]; ) n3++;
        if (n3 >= r2) {
          e2.pos += a3 - i3;
          return true;
        }
        a3--;
      }
    } else {
      let i3 = 0;
      for (; i3 <= n2; ) {
        let a3 = 0;
        for (; a3 < r2 && s2[i3 + a3] === t2[a3]; ) a3++;
        if (a3 >= r2) {
          e2.pos += i3;
          return true;
        }
        i3++;
      }
    }
    return false;
  }
  class PDFDocument {
    constructor(e2, t2) {
      __privateAdd(this, _PDFDocument_instances);
      if (t2.length <= 0) throw new InvalidPDFException("The PDF file is empty, i.e. its size is zero bytes.");
      this.pdfManager = e2;
      this.stream = t2;
      this.xref = new XRef(t2, e2);
      this._pagePromises = /* @__PURE__ */ new Map();
      this._version = null;
      const i2 = {
        font: 0
      };
      this._globalIdFactory = class {
        static getDocId() {
          return `g_${e2.docId}`;
        }
        static createFontId() {
          return "f" + ++i2.font;
        }
        static createObjId() {
          unreachable("Abstract method `createObjId` called.");
        }
        static getPageObjId() {
          unreachable("Abstract method `getPageObjId` called.");
        }
      };
    }
    parse(e2) {
      this.xref.parse(e2);
      this.catalog = new Catalog(this.pdfManager, this.xref);
    }
    get linearization() {
      let e2 = null;
      try {
        e2 = Linearization.create(this.stream);
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info(e3);
      }
      return shadow(this, "linearization", e2);
    }
    get startXRef() {
      const e2 = this.stream;
      let t2 = 0;
      if (this.linearization) {
        e2.reset();
        if (find(e2, ho)) {
          e2.skip(6);
          let i2 = e2.peekByte();
          for (; isWhiteSpace(i2); ) {
            e2.pos++;
            i2 = e2.peekByte();
          }
          t2 = e2.pos - e2.start;
        }
      } else {
        const i2 = 1024, a2 = Co.length;
        let r2 = false, s2 = e2.end;
        for (; !r2 && s2 > 0; ) {
          s2 -= i2 - a2;
          s2 < 0 && (s2 = 0);
          e2.pos = s2;
          r2 = find(e2, Co, i2, true);
        }
        if (r2) {
          e2.skip(9);
          let i3;
          do {
            i3 = e2.getByte();
          } while (isWhiteSpace(i3));
          let a3 = "";
          for (; i3 >= 32 && i3 <= 57; ) {
            a3 += String.fromCharCode(i3);
            i3 = e2.getByte();
          }
          t2 = parseInt(a3, 10);
          isNaN(t2) && (t2 = 0);
        }
      }
      return shadow(this, "startXRef", t2);
    }
    checkHeader() {
      const e2 = this.stream;
      e2.reset();
      if (!find(e2, co)) return;
      e2.moveStart();
      e2.skip(co.length);
      let t2, i2 = "";
      for (; (t2 = e2.getByte()) > 32 && i2.length < 7; ) i2 += String.fromCharCode(t2);
      Rt.test(i2) ? this._version = i2 : warn(`Invalid PDF header version: ${i2}`);
    }
    parseStartXRef() {
      this.xref.setStartXRef(this.startXRef);
    }
    get numPages() {
      let e2 = 0;
      e2 = this.catalog.hasActualNumPages ? this.catalog.numPages : this.xfaFactory ? this.xfaFactory.getNumPages() : this.linearization ? this.linearization.numPages : this.catalog.numPages;
      return shadow(this, "numPages", e2);
    }
    _hasOnlyDocumentSignatures(e2, t2 = 0) {
      return !!Array.isArray(e2) && e2.every((e3) => {
        if (!((e3 = this.xref.fetchIfRef(e3)) instanceof Dict)) return false;
        if (e3.has("Kids")) {
          if (++t2 > 10) {
            warn("_hasOnlyDocumentSignatures: maximum recursion depth reached");
            return false;
          }
          return this._hasOnlyDocumentSignatures(e3.get("Kids"), t2);
        }
        const i2 = isName(e3.get("FT"), "Sig"), a2 = e3.get("Rect"), r2 = Array.isArray(a2) && a2.every((e4) => 0 === e4);
        return i2 && r2;
      });
    }
    get _xfaStreams() {
      const e2 = this.catalog.acroForm;
      if (!e2) return null;
      const t2 = e2.get("XFA"), i2 = {
        "xdp:xdp": "",
        template: "",
        datasets: "",
        config: "",
        connectionSet: "",
        localeSet: "",
        stylesheet: "",
        "/xdp:xdp": ""
      };
      if (t2 instanceof BaseStream && !t2.isEmpty) {
        i2["xdp:xdp"] = t2;
        return i2;
      }
      if (!Array.isArray(t2) || 0 === t2.length) return null;
      for (let e3 = 0, a2 = t2.length; e3 < a2; e3 += 2) {
        let r2;
        r2 = 0 === e3 ? "xdp:xdp" : e3 === a2 - 2 ? "/xdp:xdp" : t2[e3];
        if (!i2.hasOwnProperty(r2)) continue;
        const s2 = this.xref.fetchIfRef(t2[e3 + 1]);
        s2 instanceof BaseStream && !s2.isEmpty && (i2[r2] = s2);
      }
      return i2;
    }
    get xfaDatasets() {
      const e2 = this._xfaStreams;
      if (!e2) return shadow(this, "xfaDatasets", null);
      for (const t2 of [
        "datasets",
        "xdp:xdp"
      ]) {
        const i2 = e2[t2];
        if (i2) try {
          const e3 = stringToUTF8String(i2.getString());
          return shadow(this, "xfaDatasets", new DatasetReader({
            [t2]: e3
          }));
        } catch {
          warn("XFA - Invalid utf-8 string.");
          break;
        }
      }
      return shadow(this, "xfaDatasets", null);
    }
    get xfaData() {
      const e2 = this._xfaStreams;
      if (!e2) return null;
      const t2 = /* @__PURE__ */ Object.create(null);
      for (const [i2, a2] of Object.entries(e2)) if (a2) try {
        t2[i2] = stringToUTF8String(a2.getString());
      } catch {
        warn("XFA - Invalid utf-8 string.");
        return null;
      }
      return t2;
    }
    get xfaFactory() {
      let e2;
      this.pdfManager.enableXfa && this.catalog.needsRendering && this.formInfo.hasXfa && !this.formInfo.hasAcroForm && (e2 = this.xfaData);
      return shadow(this, "xfaFactory", e2 ? new XFAFactory(e2) : null);
    }
    get isPureXfa() {
      return !!this.xfaFactory && this.xfaFactory.isValid();
    }
    get htmlForXfa() {
      return this.xfaFactory ? this.xfaFactory.getPages() : null;
    }
    async loadXfaImages() {
      const e2 = await this.pdfManager.ensureCatalog("xfaImages");
      if (!e2) return;
      const t2 = e2.getKeys(), i2 = new ObjectLoader(e2, t2, this.xref);
      await i2.load();
      const a2 = /* @__PURE__ */ new Map();
      for (const i3 of t2) {
        const t3 = e2.get(i3);
        t3 instanceof BaseStream && a2.set(i3, t3.getBytes());
      }
      this.xfaFactory.setImages(a2);
    }
    async loadXfaFonts(e2, t2) {
      const i2 = await this.pdfManager.ensureCatalog("acroForm");
      if (!i2) return;
      const a2 = await i2.getAsync("DR");
      if (!(a2 instanceof Dict)) return;
      const r2 = new ObjectLoader(a2, [
        "Font"
      ], this.xref);
      await r2.load();
      const s2 = a2.get("Font");
      if (!(s2 instanceof Dict)) return;
      const n2 = Object.assign(/* @__PURE__ */ Object.create(null), this.pdfManager.evaluatorOptions);
      n2.useSystemFonts = false;
      const o2 = new PartialEvaluator({
        xref: this.xref,
        handler: e2,
        pageIndex: -1,
        idFactory: this._globalIdFactory,
        fontCache: this.catalog.fontCache,
        builtInCMapCache: this.catalog.builtInCMapCache,
        standardFontDataCache: this.catalog.standardFontDataCache,
        options: n2
      }), g2 = new OperatorList(), c2 = [], C2 = {
        get font() {
          return c2.at(-1);
        },
        set font(e3) {
          c2.push(e3);
        },
        clone() {
          return this;
        }
      }, h2 = /* @__PURE__ */ new Map();
      s2.forEach((e3, t3) => {
        h2.set(e3, t3);
      });
      const l2 = [];
      for (const [e3, i3] of h2) {
        const r3 = i3.get("FontDescriptor");
        if (!(r3 instanceof Dict)) continue;
        let s3 = r3.get("FontFamily");
        s3 = s3.replaceAll(/[ ]+(\d)/g, "$1");
        const n3 = {
          fontFamily: s3,
          fontWeight: r3.get("FontWeight"),
          italicAngle: -r3.get("ItalicAngle")
        };
        validateCSSFont(n3) && l2.push(o2.handleSetFont(a2, [
          Name.get(e3),
          1
        ], null, g2, t2, C2, null, n3).catch(function(e4) {
          warn(`loadXfaFonts: "${e4}".`);
          return null;
        }));
      }
      await Promise.all(l2);
      const Q2 = this.xfaFactory.setFonts(c2);
      if (!Q2) return;
      n2.ignoreErrors = true;
      l2.length = 0;
      c2.length = 0;
      const E2 = /* @__PURE__ */ new Set();
      for (const e3 of Q2) getXfaFontName(`${e3}-Regular`) || E2.add(e3);
      E2.size && Q2.push("PdfJS-Fallback");
      for (const e3 of Q2) if (!E2.has(e3)) for (const i3 of [
        {
          name: "Regular",
          fontWeight: 400,
          italicAngle: 0
        },
        {
          name: "Bold",
          fontWeight: 700,
          italicAngle: 0
        },
        {
          name: "Italic",
          fontWeight: 400,
          italicAngle: 12
        },
        {
          name: "BoldItalic",
          fontWeight: 700,
          italicAngle: 12
        }
      ]) {
        const r3 = `${e3}-${i3.name}`, s3 = getXfaFontDict(r3);
        l2.push(o2.handleSetFont(a2, [
          Name.get(r3),
          1
        ], null, g2, t2, C2, s3, {
          fontFamily: e3,
          fontWeight: i3.fontWeight,
          italicAngle: i3.italicAngle
        }).catch(function(e4) {
          warn(`loadXfaFonts: "${e4}".`);
          return null;
        }));
      }
      await Promise.all(l2);
      this.xfaFactory.appendFonts(c2, E2);
    }
    async serializeXfaData(e2) {
      return this.xfaFactory ? this.xfaFactory.serializeData(e2) : null;
    }
    get version() {
      return this.catalog.version || this._version;
    }
    get formInfo() {
      const e2 = {
        hasFields: false,
        hasAcroForm: false,
        hasXfa: false,
        hasSignatures: false
      }, t2 = this.catalog.acroForm;
      if (!t2) return shadow(this, "formInfo", e2);
      try {
        const i2 = t2.get("Fields"), a2 = Array.isArray(i2) && i2.length > 0;
        e2.hasFields = a2;
        const r2 = t2.get("XFA");
        e2.hasXfa = Array.isArray(r2) && r2.length > 0 || r2 instanceof BaseStream && !r2.isEmpty;
        const s2 = !!(1 & t2.get("SigFlags")), n2 = s2 && this._hasOnlyDocumentSignatures(i2);
        e2.hasAcroForm = a2 && !n2;
        e2.hasSignatures = s2;
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        warn(`Cannot fetch form information: "${e3}".`);
      }
      return shadow(this, "formInfo", e2);
    }
    get documentInfo() {
      const e2 = {
        PDFFormatVersion: this.version,
        Language: this.catalog.lang,
        EncryptFilterName: this.xref.encrypt ? this.xref.encrypt.filterName : null,
        IsLinearized: !!this.linearization,
        IsAcroFormPresent: this.formInfo.hasAcroForm,
        IsXFAPresent: this.formInfo.hasXfa,
        IsCollectionPresent: !!this.catalog.collection,
        IsSignaturesPresent: this.formInfo.hasSignatures
      };
      let t2;
      try {
        t2 = this.xref.trailer.get("Info");
      } catch (e3) {
        if (e3 instanceof MissingDataException) throw e3;
        info("The document information dictionary is invalid.");
      }
      if (!(t2 instanceof Dict)) return shadow(this, "documentInfo", e2);
      for (const i2 of t2.getKeys()) {
        const a2 = t2.get(i2);
        switch (i2) {
          case "Title":
          case "Author":
          case "Subject":
          case "Keywords":
          case "Creator":
          case "Producer":
          case "CreationDate":
          case "ModDate":
            if ("string" == typeof a2) {
              e2[i2] = stringToPDFString(a2);
              continue;
            }
            break;
          case "Trapped":
            if (a2 instanceof Name) {
              e2[i2] = a2;
              continue;
            }
            break;
          default:
            let t3;
            switch (typeof a2) {
              case "string":
                t3 = stringToPDFString(a2);
                break;
              case "number":
              case "boolean":
                t3 = a2;
                break;
              default:
                a2 instanceof Name && (t3 = a2);
            }
            if (void 0 === t3) {
              warn(`Bad value, for custom key "${i2}", in Info: ${a2}.`);
              continue;
            }
            e2.Custom || (e2.Custom = /* @__PURE__ */ Object.create(null));
            e2.Custom[i2] = t3;
            continue;
        }
        warn(`Bad value, for key "${i2}", in Info: ${a2}.`);
      }
      return shadow(this, "documentInfo", e2);
    }
    get fingerprints() {
      const e2 = "\0".repeat(16);
      function validate(t3) {
        return "string" == typeof t3 && 16 === t3.length && t3 !== e2;
      }
      const t2 = this.xref.trailer.get("ID");
      let i2, a2;
      if (Array.isArray(t2) && validate(t2[0])) {
        i2 = stringToBytes(t2[0]);
        t2[1] !== t2[0] && validate(t2[1]) && (a2 = stringToBytes(t2[1]));
      } else i2 = qr(this.stream.getByteRange(0, 1024), 0, 1024);
      return shadow(this, "fingerprints", [
        toHexUtil(i2),
        a2 ? toHexUtil(a2) : null
      ]);
    }
    async _getLinearizationPage(e2) {
      const { catalog: t2, linearization: i2, xref: a2 } = this, r2 = Ref.get(i2.objectNumberFirst, 0);
      try {
        const e3 = await a2.fetchAsync(r2);
        if (e3 instanceof Dict) {
          let i3 = e3.getRaw("Type");
          i3 instanceof Ref && (i3 = await a2.fetchAsync(i3));
          if (isName(i3, "Page") || !e3.has("Type") && !e3.has("Kids") && e3.has("Contents")) {
            t2.pageKidsCountCache.has(r2) || t2.pageKidsCountCache.put(r2, 1);
            t2.pageIndexCache.has(r2) || t2.pageIndexCache.put(r2, 0);
            return [
              e3,
              r2
            ];
          }
        }
        throw new FormatError("The Linearization dictionary doesn't point to a valid Page dictionary.");
      } catch (i3) {
        warn(`_getLinearizationPage: "${i3.message}".`);
        return t2.getPageDict(e2);
      }
    }
    getPage(e2) {
      const t2 = this._pagePromises.get(e2);
      if (t2) return t2;
      const { catalog: i2, linearization: a2, xfaFactory: r2 } = this;
      let s2;
      s2 = r2 ? Promise.resolve([
        Dict.empty,
        null
      ]) : (a2 == null ? void 0 : a2.pageFirst) === e2 ? this._getLinearizationPage(e2) : i2.getPageDict(e2);
      s2 = s2.then(([t3, a3]) => new Page({
        pdfManager: this.pdfManager,
        xref: this.xref,
        pageIndex: e2,
        pageDict: t3,
        ref: a3,
        globalIdFactory: this._globalIdFactory,
        fontCache: i2.fontCache,
        builtInCMapCache: i2.builtInCMapCache,
        standardFontDataCache: i2.standardFontDataCache,
        globalImageCache: i2.globalImageCache,
        systemFontCache: i2.systemFontCache,
        nonBlendModesSet: i2.nonBlendModesSet,
        xfaFactory: r2
      }));
      this._pagePromises.set(e2, s2);
      return s2;
    }
    async checkFirstPage(e2 = false) {
      if (!e2) try {
        await this.getPage(0);
      } catch (e3) {
        if (e3 instanceof XRefEntryException) {
          this._pagePromises.delete(0);
          await this.cleanup();
          throw new XRefParseException();
        }
      }
    }
    async checkLastPage(e2 = false) {
      const { catalog: t2, pdfManager: i2 } = this;
      t2.setActualNumPages();
      let a2;
      try {
        await Promise.all([
          i2.ensureDoc("xfaFactory"),
          i2.ensureDoc("linearization"),
          i2.ensureCatalog("numPages")
        ]);
        if (this.xfaFactory) return;
        a2 = this.linearization ? this.linearization.numPages : t2.numPages;
        if (!Number.isInteger(a2)) throw new FormatError("Page count is not an integer.");
        if (a2 <= 1) return;
        await this.getPage(a2 - 1);
      } catch (r2) {
        this._pagePromises.delete(a2 - 1);
        await this.cleanup();
        if (r2 instanceof XRefEntryException && !e2) throw new XRefParseException();
        warn(`checkLastPage - invalid /Pages tree /Count: ${a2}.`);
        let s2;
        try {
          s2 = await t2.getAllPageDicts(e2);
        } catch (i3) {
          if (i3 instanceof XRefEntryException && !e2) throw new XRefParseException();
          t2.setActualNumPages(1);
          return;
        }
        for (const [e3, [a3, r3]] of s2) {
          let s3;
          if (a3 instanceof Error) {
            s3 = Promise.reject(a3);
            s3.catch(() => {
            });
          } else s3 = Promise.resolve(new Page({
            pdfManager: i2,
            xref: this.xref,
            pageIndex: e3,
            pageDict: a3,
            ref: r3,
            globalIdFactory: this._globalIdFactory,
            fontCache: t2.fontCache,
            builtInCMapCache: t2.builtInCMapCache,
            standardFontDataCache: t2.standardFontDataCache,
            globalImageCache: t2.globalImageCache,
            systemFontCache: t2.systemFontCache,
            nonBlendModesSet: t2.nonBlendModesSet,
            xfaFactory: null
          }));
          this._pagePromises.set(e3, s3);
        }
        t2.setActualNumPages(s2.size);
      }
    }
    fontFallback(e2, t2) {
      return this.catalog.fontFallback(e2, t2);
    }
    async cleanup(e2 = false) {
      return this.catalog ? this.catalog.cleanup(e2) : clearGlobalCaches();
    }
    get fieldObjects() {
      return shadow(this, "fieldObjects", this.pdfManager.ensureDoc("formInfo").then(async (e2) => {
        if (!e2.hasFields) return null;
        const [t2, i2] = await Promise.all([
          this.pdfManager.ensureDoc("annotationGlobals"),
          this.pdfManager.ensureCatalog("acroForm")
        ]);
        if (!t2) return null;
        const a2 = new RefSet(), r2 = /* @__PURE__ */ Object.create(null), s2 = /* @__PURE__ */ new Map(), n2 = new RefSetCache();
        for (const e3 of await i2.getAsync("Fields")) await __privateMethod(this, _PDFDocument_instances, Z_fn).call(this, "", null, e3, s2, t2, a2, n2);
        const o2 = [];
        for (const [e3, t3] of s2) o2.push(Promise.all(t3).then((t4) => {
          (t4 = t4.filter((e4) => !!e4)).length > 0 && (r2[e3] = t4);
        }));
        await Promise.all(o2);
        return {
          allFields: r2,
          orphanFields: n2
        };
      }));
    }
    get hasJSActions() {
      return shadow(this, "hasJSActions", this.pdfManager.ensureDoc("_parseHasJSActions"));
    }
    async _parseHasJSActions() {
      const [e2, t2] = await Promise.all([
        this.pdfManager.ensureCatalog("jsActions"),
        this.pdfManager.ensureDoc("fieldObjects")
      ]);
      return !!e2 || !!t2 && Object.values(t2.allFields).some((e3) => e3.some((e4) => null !== e4.actions));
    }
    get calculationOrderIds() {
      var _a4;
      const e2 = (_a4 = this.catalog.acroForm) == null ? void 0 : _a4.get("CO");
      if (!Array.isArray(e2) || 0 === e2.length) return shadow(this, "calculationOrderIds", null);
      const t2 = [];
      for (const i2 of e2) i2 instanceof Ref && t2.push(i2.toString());
      return shadow(this, "calculationOrderIds", t2.length ? t2 : null);
    }
    get annotationGlobals() {
      return shadow(this, "annotationGlobals", AnnotationFactory.createGlobals(this.pdfManager));
    }
  }
  _PDFDocument_instances = new WeakSet();
  Z_fn = async function(e2, t2, i2, a2, r2, s2, n2) {
    const { xref: o2 } = this;
    if (!(i2 instanceof Ref) || s2.has(i2)) return;
    s2.put(i2);
    const g2 = await o2.fetchAsync(i2);
    if (!(g2 instanceof Dict)) return;
    if (g2.has("T")) {
      const t3 = stringToPDFString(await g2.getAsync("T"));
      e2 = "" === e2 ? t3 : `${e2}.${t3}`;
    } else {
      let i3 = g2;
      for (; ; ) {
        i3 = i3.getRaw("Parent") || t2;
        if (i3 instanceof Ref) {
          if (s2.has(i3)) break;
          i3 = await o2.fetchAsync(i3);
        }
        if (!(i3 instanceof Dict)) break;
        if (i3.has("T")) {
          const t3 = stringToPDFString(await i3.getAsync("T"));
          e2 = "" === e2 ? t3 : `${e2}.${t3}`;
          break;
        }
      }
    }
    t2 && !g2.has("Parent") && isName(g2.get("Subtype"), "Widget") && n2.put(i2, t2);
    a2.has(e2) || a2.set(e2, []);
    a2.get(e2).push(AnnotationFactory.create(o2, i2, r2, null, true, n2, null).then((e3) => e3 == null ? void 0 : e3.getFieldObject()).catch(function(e3) {
      warn(`#collectFieldObjects: "${e3}".`);
      return null;
    }));
    if (!g2.has("Kids")) return;
    const c2 = await g2.getAsync("Kids");
    if (Array.isArray(c2)) for (const t3 of c2) await __privateMethod(this, _PDFDocument_instances, Z_fn).call(this, e2, i2, t3, a2, r2, s2, n2);
  };
  class BasePdfManager {
    constructor(e2) {
      var _a4;
      this._docBaseUrl = function parseDocBaseUrl(e3) {
        if (e3) {
          const t2 = createValidAbsoluteUrl(e3);
          if (t2) return t2.href;
          warn(`Invalid absolute docBaseUrl: "${e3}".`);
        }
        return null;
      }(e2.docBaseUrl);
      this._docId = e2.docId;
      this._password = e2.password;
      this.enableXfa = e2.enableXfa;
      (_a4 = e2.evaluatorOptions).isOffscreenCanvasSupported && (_a4.isOffscreenCanvasSupported = FeatureTest.isOffscreenCanvasSupported);
      this.evaluatorOptions = Object.freeze(e2.evaluatorOptions);
    }
    get docId() {
      return this._docId;
    }
    get password() {
      return this._password;
    }
    get docBaseUrl() {
      return this._docBaseUrl;
    }
    get catalog() {
      return this.pdfDocument.catalog;
    }
    ensureDoc(e2, t2) {
      return this.ensure(this.pdfDocument, e2, t2);
    }
    ensureXRef(e2, t2) {
      return this.ensure(this.pdfDocument.xref, e2, t2);
    }
    ensureCatalog(e2, t2) {
      return this.ensure(this.pdfDocument.catalog, e2, t2);
    }
    getPage(e2) {
      return this.pdfDocument.getPage(e2);
    }
    fontFallback(e2, t2) {
      return this.pdfDocument.fontFallback(e2, t2);
    }
    loadXfaFonts(e2, t2) {
      return this.pdfDocument.loadXfaFonts(e2, t2);
    }
    loadXfaImages() {
      return this.pdfDocument.loadXfaImages();
    }
    serializeXfaData(e2) {
      return this.pdfDocument.serializeXfaData(e2);
    }
    cleanup(e2 = false) {
      return this.pdfDocument.cleanup(e2);
    }
    async ensure(e2, t2, i2) {
      unreachable("Abstract method `ensure` called");
    }
    requestRange(e2, t2) {
      unreachable("Abstract method `requestRange` called");
    }
    requestLoadedStream(e2 = false) {
      unreachable("Abstract method `requestLoadedStream` called");
    }
    sendProgressiveData(e2) {
      unreachable("Abstract method `sendProgressiveData` called");
    }
    updatePassword(e2) {
      this._password = e2;
    }
    terminate(e2) {
      unreachable("Abstract method `terminate` called");
    }
  }
  class LocalPdfManager extends BasePdfManager {
    constructor(e2) {
      super(e2);
      const t2 = new Stream(e2.source);
      this.pdfDocument = new PDFDocument(this, t2);
      this._loadedStreamPromise = Promise.resolve(t2);
    }
    async ensure(e2, t2, i2) {
      const a2 = e2[t2];
      return "function" == typeof a2 ? a2.apply(e2, i2) : a2;
    }
    requestRange(e2, t2) {
      return Promise.resolve();
    }
    requestLoadedStream(e2 = false) {
      return this._loadedStreamPromise;
    }
    terminate(e2) {
    }
  }
  class NetworkPdfManager extends BasePdfManager {
    constructor(e2) {
      super(e2);
      this.streamManager = new ChunkedStreamManager(e2.source, {
        msgHandler: e2.handler,
        length: e2.length,
        disableAutoFetch: e2.disableAutoFetch,
        rangeChunkSize: e2.rangeChunkSize
      });
      this.pdfDocument = new PDFDocument(this, this.streamManager.getStream());
    }
    async ensure(e2, t2, i2) {
      try {
        const a2 = e2[t2];
        return "function" == typeof a2 ? a2.apply(e2, i2) : a2;
      } catch (a2) {
        if (!(a2 instanceof MissingDataException)) throw a2;
        await this.requestRange(a2.begin, a2.end);
        return this.ensure(e2, t2, i2);
      }
    }
    requestRange(e2, t2) {
      return this.streamManager.requestRange(e2, t2);
    }
    requestLoadedStream(e2 = false) {
      return this.streamManager.requestAllChunks(e2);
    }
    sendProgressiveData(e2) {
      this.streamManager.onReceiveData({
        chunk: e2
      });
    }
    terminate(e2) {
      this.streamManager.abort(e2);
    }
  }
  const lo = 1, Bo = 2, Qo = 1, Eo = 2, uo = 3, fo = 4, po = 5, mo = 6, yo = 7, wo = 8;
  function wrapReason(e2) {
    e2 instanceof Error || "object" == typeof e2 && null !== e2 || unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
    switch (e2.name) {
      case "AbortException":
        return new AbortException(e2.message);
      case "MissingPDFException":
        return new MissingPDFException(e2.message);
      case "PasswordException":
        return new PasswordException(e2.message, e2.code);
      case "UnexpectedResponseException":
        return new UnexpectedResponseException(e2.message, e2.status);
      case "UnknownErrorException":
        return new UnknownErrorException(e2.message, e2.details);
      default:
        return new UnknownErrorException(e2.message, e2.toString());
    }
  }
  class MessageHandler {
    constructor(e2, t2, i2) {
      __privateAdd(this, _MessageHandler_instances);
      __privateAdd(this, _V, new AbortController());
      this.sourceName = e2;
      this.targetName = t2;
      this.comObj = i2;
      this.callbackId = 1;
      this.streamId = 1;
      this.streamSinks = /* @__PURE__ */ Object.create(null);
      this.streamControllers = /* @__PURE__ */ Object.create(null);
      this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
      this.actionHandler = /* @__PURE__ */ Object.create(null);
      i2.addEventListener("message", __privateMethod(this, _MessageHandler_instances, __fn).bind(this), {
        signal: __privateGet(this, _V).signal
      });
    }
    on(e2, t2) {
      const i2 = this.actionHandler;
      if (i2[e2]) throw new Error(`There is already an actionName called "${e2}"`);
      i2[e2] = t2;
    }
    send(e2, t2, i2) {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: e2,
        data: t2
      }, i2);
    }
    sendWithPromise(e2, t2, i2) {
      const a2 = this.callbackId++, r2 = Promise.withResolvers();
      this.callbackCapabilities[a2] = r2;
      try {
        this.comObj.postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: e2,
          callbackId: a2,
          data: t2
        }, i2);
      } catch (e3) {
        r2.reject(e3);
      }
      return r2.promise;
    }
    sendWithStream(e2, t2, i2, a2) {
      const r2 = this.streamId++, s2 = this.sourceName, n2 = this.targetName, o2 = this.comObj;
      return new ReadableStream({
        start: (i3) => {
          const g2 = Promise.withResolvers();
          this.streamControllers[r2] = {
            controller: i3,
            startCall: g2,
            pullCall: null,
            cancelCall: null,
            isClosed: false
          };
          o2.postMessage({
            sourceName: s2,
            targetName: n2,
            action: e2,
            streamId: r2,
            data: t2,
            desiredSize: i3.desiredSize
          }, a2);
          return g2.promise;
        },
        pull: (e3) => {
          const t3 = Promise.withResolvers();
          this.streamControllers[r2].pullCall = t3;
          o2.postMessage({
            sourceName: s2,
            targetName: n2,
            stream: mo,
            streamId: r2,
            desiredSize: e3.desiredSize
          });
          return t3.promise;
        },
        cancel: (e3) => {
          assert(e3 instanceof Error, "cancel must have a valid reason");
          const t3 = Promise.withResolvers();
          this.streamControllers[r2].cancelCall = t3;
          this.streamControllers[r2].isClosed = true;
          o2.postMessage({
            sourceName: s2,
            targetName: n2,
            stream: Qo,
            streamId: r2,
            reason: wrapReason(e3)
          });
          return t3.promise;
        }
      }, i2);
    }
    destroy() {
      var _a4;
      (_a4 = __privateGet(this, _V)) == null ? void 0 : _a4.abort();
      __privateSet(this, _V, null);
    }
  }
  _V = new WeakMap();
  _MessageHandler_instances = new WeakSet();
  __fn = function({ data: e2 }) {
    if (e2.targetName !== this.sourceName) return;
    if (e2.stream) {
      __privateMethod(this, _MessageHandler_instances, z_fn).call(this, e2);
      return;
    }
    if (e2.callback) {
      const t3 = e2.callbackId, i2 = this.callbackCapabilities[t3];
      if (!i2) throw new Error(`Cannot resolve callback ${t3}`);
      delete this.callbackCapabilities[t3];
      if (e2.callback === lo) i2.resolve(e2.data);
      else {
        if (e2.callback !== Bo) throw new Error("Unexpected callback case");
        i2.reject(wrapReason(e2.reason));
      }
      return;
    }
    const t2 = this.actionHandler[e2.action];
    if (!t2) throw new Error(`Unknown action from worker: ${e2.action}`);
    if (e2.callbackId) {
      const i2 = this.sourceName, a2 = e2.sourceName, r2 = this.comObj;
      new Promise(function(i3) {
        i3(t2(e2.data));
      }).then(function(t3) {
        r2.postMessage({
          sourceName: i2,
          targetName: a2,
          callback: lo,
          callbackId: e2.callbackId,
          data: t3
        });
      }, function(t3) {
        r2.postMessage({
          sourceName: i2,
          targetName: a2,
          callback: Bo,
          callbackId: e2.callbackId,
          reason: wrapReason(t3)
        });
      });
    } else e2.streamId ? __privateMethod(this, _MessageHandler_instances, $_fn).call(this, e2) : t2(e2.data);
  };
  $_fn = function(e2) {
    const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, r2 = this.comObj, s2 = this, n2 = this.actionHandler[e2.action], o2 = {
      enqueue(e3, s3 = 1, n3) {
        if (this.isCancelled) return;
        const o3 = this.desiredSize;
        this.desiredSize -= s3;
        if (o3 > 0 && this.desiredSize <= 0) {
          this.sinkCapability = Promise.withResolvers();
          this.ready = this.sinkCapability.promise;
        }
        r2.postMessage({
          sourceName: i2,
          targetName: a2,
          stream: fo,
          streamId: t2,
          chunk: e3
        }, n3);
      },
      close() {
        if (!this.isCancelled) {
          this.isCancelled = true;
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: uo,
            streamId: t2
          });
          delete s2.streamSinks[t2];
        }
      },
      error(e3) {
        assert(e3 instanceof Error, "error must have a valid reason");
        if (!this.isCancelled) {
          this.isCancelled = true;
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: po,
            streamId: t2,
            reason: wrapReason(e3)
          });
        }
      },
      sinkCapability: Promise.withResolvers(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: e2.desiredSize,
      ready: null
    };
    o2.sinkCapability.resolve();
    o2.ready = o2.sinkCapability.promise;
    this.streamSinks[t2] = o2;
    new Promise(function(t3) {
      t3(n2(e2.data, o2));
    }).then(function() {
      r2.postMessage({
        sourceName: i2,
        targetName: a2,
        stream: wo,
        streamId: t2,
        success: true
      });
    }, function(e3) {
      r2.postMessage({
        sourceName: i2,
        targetName: a2,
        stream: wo,
        streamId: t2,
        reason: wrapReason(e3)
      });
    });
  };
  z_fn = function(e2) {
    const t2 = e2.streamId, i2 = this.sourceName, a2 = e2.sourceName, r2 = this.comObj, s2 = this.streamControllers[t2], n2 = this.streamSinks[t2];
    switch (e2.stream) {
      case wo:
        e2.success ? s2.startCall.resolve() : s2.startCall.reject(wrapReason(e2.reason));
        break;
      case yo:
        e2.success ? s2.pullCall.resolve() : s2.pullCall.reject(wrapReason(e2.reason));
        break;
      case mo:
        if (!n2) {
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: yo,
            streamId: t2,
            success: true
          });
          break;
        }
        n2.desiredSize <= 0 && e2.desiredSize > 0 && n2.sinkCapability.resolve();
        n2.desiredSize = e2.desiredSize;
        new Promise(function(e3) {
          var _a4;
          e3((_a4 = n2.onPull) == null ? void 0 : _a4.call(n2));
        }).then(function() {
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: yo,
            streamId: t2,
            success: true
          });
        }, function(e3) {
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: yo,
            streamId: t2,
            reason: wrapReason(e3)
          });
        });
        break;
      case fo:
        assert(s2, "enqueue should have stream controller");
        if (s2.isClosed) break;
        s2.controller.enqueue(e2.chunk);
        break;
      case uo:
        assert(s2, "close should have stream controller");
        if (s2.isClosed) break;
        s2.isClosed = true;
        s2.controller.close();
        __privateMethod(this, _MessageHandler_instances, AA_fn).call(this, s2, t2);
        break;
      case po:
        assert(s2, "error should have stream controller");
        s2.controller.error(wrapReason(e2.reason));
        __privateMethod(this, _MessageHandler_instances, AA_fn).call(this, s2, t2);
        break;
      case Eo:
        e2.success ? s2.cancelCall.resolve() : s2.cancelCall.reject(wrapReason(e2.reason));
        __privateMethod(this, _MessageHandler_instances, AA_fn).call(this, s2, t2);
        break;
      case Qo:
        if (!n2) break;
        new Promise(function(t3) {
          var _a4;
          t3((_a4 = n2.onCancel) == null ? void 0 : _a4.call(n2, wrapReason(e2.reason)));
        }).then(function() {
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: Eo,
            streamId: t2,
            success: true
          });
        }, function(e3) {
          r2.postMessage({
            sourceName: i2,
            targetName: a2,
            stream: Eo,
            streamId: t2,
            reason: wrapReason(e3)
          });
        });
        n2.sinkCapability.reject(wrapReason(e2.reason));
        n2.isCancelled = true;
        delete this.streamSinks[t2];
        break;
      default:
        throw new Error("Unexpected stream case");
    }
  };
  AA_fn = async function(e2, t2) {
    var _a4, _b, _c;
    await Promise.allSettled([
      (_a4 = e2.startCall) == null ? void 0 : _a4.promise,
      (_b = e2.pullCall) == null ? void 0 : _b.promise,
      (_c = e2.cancelCall) == null ? void 0 : _c.promise
    ]);
    delete this.streamControllers[t2];
  };
  class PDFWorkerStream {
    constructor(e2) {
      this._msgHandler = e2;
      this._contentLength = null;
      this._fullRequestReader = null;
      this._rangeRequestReaders = [];
    }
    getFullReader() {
      assert(!this._fullRequestReader, "PDFWorkerStream.getFullReader can only be called once.");
      this._fullRequestReader = new PDFWorkerStreamReader(this._msgHandler);
      return this._fullRequestReader;
    }
    getRangeReader(e2, t2) {
      const i2 = new PDFWorkerStreamRangeReader(e2, t2, this._msgHandler);
      this._rangeRequestReaders.push(i2);
      return i2;
    }
    cancelAllRequests(e2) {
      var _a4;
      (_a4 = this._fullRequestReader) == null ? void 0 : _a4.cancel(e2);
      for (const t2 of this._rangeRequestReaders.slice(0)) t2.cancel(e2);
    }
  }
  class PDFWorkerStreamReader {
    constructor(e2) {
      this._msgHandler = e2;
      this.onProgress = null;
      this._contentLength = null;
      this._isRangeSupported = false;
      this._isStreamingSupported = false;
      const t2 = this._msgHandler.sendWithStream("GetReader");
      this._reader = t2.getReader();
      this._headersReady = this._msgHandler.sendWithPromise("ReaderHeadersReady").then((e3) => {
        this._isStreamingSupported = e3.isStreamingSupported;
        this._isRangeSupported = e3.isRangeSupported;
        this._contentLength = e3.contentLength;
      });
    }
    get headersReady() {
      return this._headersReady;
    }
    get contentLength() {
      return this._contentLength;
    }
    get isStreamingSupported() {
      return this._isStreamingSupported;
    }
    get isRangeSupported() {
      return this._isRangeSupported;
    }
    async read() {
      const { value: e2, done: t2 } = await this._reader.read();
      return t2 ? {
        value: void 0,
        done: true
      } : {
        value: e2.buffer,
        done: false
      };
    }
    cancel(e2) {
      this._reader.cancel(e2);
    }
  }
  class PDFWorkerStreamRangeReader {
    constructor(e2, t2, i2) {
      this._msgHandler = i2;
      this.onProgress = null;
      const a2 = this._msgHandler.sendWithStream("GetRangeReader", {
        begin: e2,
        end: t2
      });
      this._reader = a2.getReader();
    }
    get isStreamingSupported() {
      return false;
    }
    async read() {
      const { value: e2, done: t2 } = await this._reader.read();
      return t2 ? {
        value: void 0,
        done: true
      } : {
        value: e2.buffer,
        done: false
      };
    }
    cancel(e2) {
      this._reader.cancel(e2);
    }
  }
  class WorkerTask {
    constructor(e2) {
      this.name = e2;
      this.terminated = false;
      this._capability = Promise.withResolvers();
    }
    get finished() {
      return this._capability.promise;
    }
    finish() {
      this._capability.resolve();
    }
    terminate() {
      this.terminated = true;
    }
    ensureNotTerminated() {
      if (this.terminated) throw new Error("Worker task was terminated");
    }
  }
  class WorkerMessageHandler {
    static setup(e2, t2) {
      let i2 = false;
      e2.on("test", function(t3) {
        if (!i2) {
          i2 = true;
          e2.send("test", t3 instanceof Uint8Array);
        }
      });
      e2.on("configure", function(e3) {
        !function setVerbosityLevel(e4) {
          Number.isInteger(e4) && (gt = e4);
        }(e3.verbosity);
      });
      e2.on("GetDocRequest", function(e3) {
        return WorkerMessageHandler.createDocumentHandler(e3, t2);
      });
    }
    static createDocumentHandler(e2, t2) {
      let i2, a2 = false, r2 = null;
      const s2 = /* @__PURE__ */ new Set(), n2 = getVerbosityLevel(), { docId: o2, apiVersion: g2 } = e2, c2 = "4.8.69";
      if (g2 !== c2) throw new Error(`The API version "${g2}" does not match the Worker version "${c2}".`);
      const C2 = [];
      for (const e3 in []) C2.push(e3);
      if (C2.length) throw new Error("The `Array.prototype` contains unexpected enumerable properties: " + C2.join(", ") + "; thus breaking e.g. `for...in` iteration of `Array`s.");
      const h2 = o2 + "_worker";
      let l2 = new MessageHandler(h2, o2, t2);
      function ensureNotTerminated() {
        if (a2) throw new Error("Worker was terminated");
      }
      function startWorkerTask(e3) {
        s2.add(e3);
      }
      function finishWorkerTask(e3) {
        e3.finish();
        s2.delete(e3);
      }
      async function loadDocument(e3) {
        await i2.ensureDoc("checkHeader");
        await i2.ensureDoc("parseStartXRef");
        await i2.ensureDoc("parse", [
          e3
        ]);
        await i2.ensureDoc("checkFirstPage", [
          e3
        ]);
        await i2.ensureDoc("checkLastPage", [
          e3
        ]);
        const t3 = await i2.ensureDoc("isPureXfa");
        if (t3) {
          const e4 = new WorkerTask("loadXfaFonts");
          startWorkerTask(e4);
          await Promise.all([
            i2.loadXfaFonts(l2, e4).catch((e5) => {
            }).then(() => finishWorkerTask(e4)),
            i2.loadXfaImages()
          ]);
        }
        const [a3, r3] = await Promise.all([
          i2.ensureDoc("numPages"),
          i2.ensureDoc("fingerprints")
        ]);
        return {
          numPages: a3,
          fingerprints: r3,
          htmlForXfa: t3 ? await i2.ensureDoc("htmlForXfa") : null
        };
      }
      function setupDoc(e3) {
        function onSuccess(e4) {
          ensureNotTerminated();
          l2.send("GetDoc", {
            pdfInfo: e4
          });
        }
        function onFailure(e4) {
          ensureNotTerminated();
          if (e4 instanceof PasswordException) {
            const t3 = new WorkerTask(`PasswordException: response ${e4.code}`);
            startWorkerTask(t3);
            l2.sendWithPromise("PasswordRequest", e4).then(function({ password: e5 }) {
              finishWorkerTask(t3);
              i2.updatePassword(e5);
              pdfManagerReady();
            }).catch(function() {
              finishWorkerTask(t3);
              l2.send("DocException", e4);
            });
          } else e4 instanceof InvalidPDFException || e4 instanceof MissingPDFException || e4 instanceof UnexpectedResponseException || e4 instanceof UnknownErrorException ? l2.send("DocException", e4) : l2.send("DocException", new UnknownErrorException(e4.message, e4.toString()));
        }
        function pdfManagerReady() {
          ensureNotTerminated();
          loadDocument(false).then(onSuccess, function(e4) {
            ensureNotTerminated();
            e4 instanceof XRefParseException ? i2.requestLoadedStream().then(function() {
              ensureNotTerminated();
              loadDocument(true).then(onSuccess, onFailure);
            }) : onFailure(e4);
          });
        }
        ensureNotTerminated();
        (function getPdfManager({ data: e4, password: t3, disableAutoFetch: i3, rangeChunkSize: a3, length: s3, docBaseUrl: n3, enableXfa: g3, evaluatorOptions: c3 }) {
          const C3 = {
            source: null,
            disableAutoFetch: i3,
            docBaseUrl: n3,
            docId: o2,
            enableXfa: g3,
            evaluatorOptions: c3,
            handler: l2,
            length: s3,
            password: t3,
            rangeChunkSize: a3
          }, h3 = Promise.withResolvers();
          let Q2;
          if (e4) {
            try {
              C3.source = e4;
              Q2 = new LocalPdfManager(C3);
              h3.resolve(Q2);
            } catch (e5) {
              h3.reject(e5);
            }
            return h3.promise;
          }
          let E2, u2 = [], d2 = 0;
          try {
            E2 = new PDFWorkerStream(l2);
          } catch (e5) {
            h3.reject(e5);
            return h3.promise;
          }
          const f2 = E2.getFullReader();
          f2.headersReady.then(function() {
            if (f2.isRangeSupported) {
              C3.source = E2;
              C3.length = f2.contentLength;
              C3.disableAutoFetch || (C3.disableAutoFetch = f2.isStreamingSupported);
              Q2 = new NetworkPdfManager(C3);
              for (const e5 of u2) Q2.sendProgressiveData(e5);
              u2 = [];
              h3.resolve(Q2);
              r2 = null;
            }
          }).catch(function(e5) {
            h3.reject(e5);
            r2 = null;
          });
          new Promise(function(e5, t4) {
            const readChunk = function({ value: e6, done: i4 }) {
              try {
                ensureNotTerminated();
                if (i4) {
                  if (!Q2) {
                    const e7 = arrayBuffersToBytes(u2);
                    u2 = [];
                    s3 && e7.length !== s3 && warn("reported HTTP length is different from actual");
                    C3.source = e7;
                    Q2 = new LocalPdfManager(C3);
                    h3.resolve(Q2);
                  }
                  r2 = null;
                  return;
                }
                d2 += e6.byteLength;
                f2.isStreamingSupported || l2.send("DocProgress", {
                  loaded: d2,
                  total: Math.max(d2, f2.contentLength || 0)
                });
                Q2 ? Q2.sendProgressiveData(e6) : u2.push(e6);
                f2.read().then(readChunk, t4);
              } catch (e7) {
                t4(e7);
              }
            };
            f2.read().then(readChunk, t4);
          }).catch(function(e5) {
            h3.reject(e5);
            r2 = null;
          });
          r2 = function(e5) {
            E2.cancelAllRequests(e5);
          };
          return h3.promise;
        })(e3).then(function(e4) {
          if (a2) {
            e4.terminate(new AbortException("Worker was terminated."));
            throw new Error("Worker was terminated");
          }
          i2 = e4;
          i2.requestLoadedStream(true).then((e5) => {
            l2.send("DataLoaded", {
              length: e5.bytes.byteLength
            });
          });
        }).then(pdfManagerReady, onFailure);
      }
      l2.on("GetPage", function(e3) {
        return i2.getPage(e3.pageIndex).then(function(e4) {
          return Promise.all([
            i2.ensure(e4, "rotate"),
            i2.ensure(e4, "ref"),
            i2.ensure(e4, "userUnit"),
            i2.ensure(e4, "view")
          ]).then(function([e5, t3, i3, a3]) {
            return {
              rotate: e5,
              ref: t3,
              refStr: (t3 == null ? void 0 : t3.toString()) ?? null,
              userUnit: i3,
              view: a3
            };
          });
        });
      });
      l2.on("GetPageIndex", function(e3) {
        const t3 = Ref.get(e3.num, e3.gen);
        return i2.ensureCatalog("getPageIndex", [
          t3
        ]);
      });
      l2.on("GetDestinations", function(e3) {
        return i2.ensureCatalog("destinations");
      });
      l2.on("GetDestination", function(e3) {
        return i2.ensureCatalog("getDestination", [
          e3.id
        ]);
      });
      l2.on("GetPageLabels", function(e3) {
        return i2.ensureCatalog("pageLabels");
      });
      l2.on("GetPageLayout", function(e3) {
        return i2.ensureCatalog("pageLayout");
      });
      l2.on("GetPageMode", function(e3) {
        return i2.ensureCatalog("pageMode");
      });
      l2.on("GetViewerPreferences", function(e3) {
        return i2.ensureCatalog("viewerPreferences");
      });
      l2.on("GetOpenAction", function(e3) {
        return i2.ensureCatalog("openAction");
      });
      l2.on("GetAttachments", function(e3) {
        return i2.ensureCatalog("attachments");
      });
      l2.on("GetDocJSActions", function(e3) {
        return i2.ensureCatalog("jsActions");
      });
      l2.on("GetPageJSActions", function({ pageIndex: e3 }) {
        return i2.getPage(e3).then(function(e4) {
          return i2.ensure(e4, "jsActions");
        });
      });
      l2.on("GetOutline", function(e3) {
        return i2.ensureCatalog("documentOutline");
      });
      l2.on("GetOptionalContentConfig", function(e3) {
        return i2.ensureCatalog("optionalContentConfig");
      });
      l2.on("GetPermissions", function(e3) {
        return i2.ensureCatalog("permissions");
      });
      l2.on("GetMetadata", function(e3) {
        return Promise.all([
          i2.ensureDoc("documentInfo"),
          i2.ensureCatalog("metadata")
        ]);
      });
      l2.on("GetMarkInfo", function(e3) {
        return i2.ensureCatalog("markInfo");
      });
      l2.on("GetData", function(e3) {
        return i2.requestLoadedStream().then(function(e4) {
          return e4.bytes;
        });
      });
      l2.on("GetAnnotations", function({ pageIndex: e3, intent: t3 }) {
        return i2.getPage(e3).then(function(i3) {
          const a3 = new WorkerTask(`GetAnnotations: page ${e3}`);
          startWorkerTask(a3);
          return i3.getAnnotationsData(l2, a3, t3).then((e4) => {
            finishWorkerTask(a3);
            return e4;
          }, (e4) => {
            finishWorkerTask(a3);
            throw e4;
          });
        });
      });
      l2.on("GetFieldObjects", function(e3) {
        return i2.ensureDoc("fieldObjects").then((e4) => (e4 == null ? void 0 : e4.allFields) || null);
      });
      l2.on("HasJSActions", function(e3) {
        return i2.ensureDoc("hasJSActions");
      });
      l2.on("GetCalculationOrderIds", function(e3) {
        return i2.ensureDoc("calculationOrderIds");
      });
      l2.on("SaveDocument", async function({ isPureXfa: e3, numPages: t3, annotationStorage: a3, filename: r3 }) {
        const s3 = [
          i2.requestLoadedStream(),
          i2.ensureCatalog("acroForm"),
          i2.ensureCatalog("acroFormRef"),
          i2.ensureDoc("startXRef"),
          i2.ensureDoc("xref"),
          i2.ensureDoc("linearization"),
          i2.ensureCatalog("structTreeRoot")
        ], n3 = [], o3 = e3 ? null : getNewAnnotationsMap(a3), [g3, c3, C3, h3, Q2, E2, u2] = await Promise.all(s3), d2 = Q2.trailer.getRaw("Root") || null;
        let f2;
        if (o3) {
          u2 ? await u2.canUpdateStructTree({
            pdfManager: i2,
            xref: Q2,
            newAnnotationsByPage: o3
          }) && (f2 = u2) : await StructTreeRoot.canCreateStructureTree({
            catalogRef: d2,
            pdfManager: i2,
            newAnnotationsByPage: o3
          }) && (f2 = null);
          const e4 = AnnotationFactory.generateImages(a3.values(), Q2, i2.evaluatorOptions.isOffscreenCanvasSupported), t4 = void 0 === f2 ? n3 : [];
          for (const [a4, r4] of o3) t4.push(i2.getPage(a4).then((t5) => {
            const i3 = new WorkerTask(`Save (editor): page ${a4}`);
            return t5.saveNewAnnotations(l2, i3, r4, e4).finally(function() {
              finishWorkerTask(i3);
            });
          }));
          null === f2 ? n3.push(Promise.all(t4).then(async (e5) => {
            await StructTreeRoot.createStructureTree({
              newAnnotationsByPage: o3,
              xref: Q2,
              catalogRef: d2,
              pdfManager: i2,
              newRefs: e5
            });
            return e5;
          })) : f2 && n3.push(Promise.all(t4).then(async (e5) => {
            await f2.updateStructureTree({
              newAnnotationsByPage: o3,
              pdfManager: i2,
              newRefs: e5
            });
            return e5;
          }));
        }
        if (e3) n3.push(i2.serializeXfaData(a3));
        else for (let e4 = 0; e4 < t3; e4++) n3.push(i2.getPage(e4).then(function(t4) {
          const i3 = new WorkerTask(`Save: page ${e4}`);
          return t4.save(l2, i3, a3).finally(function() {
            finishWorkerTask(i3);
          });
        }));
        const p2 = await Promise.all(n3);
        let m2 = [], y2 = null;
        if (e3) {
          y2 = p2[0];
          if (!y2) return g3.bytes;
        } else {
          m2 = p2.flat(2);
          if (0 === m2.length) return g3.bytes;
        }
        const w2 = C3 && c3 instanceof Dict && m2.some((e4) => e4.needAppearances), b2 = c3 instanceof Dict && c3.get("XFA") || null;
        let D2 = null, S2 = false;
        if (Array.isArray(b2)) {
          for (let e4 = 0, t4 = b2.length; e4 < t4; e4 += 2) if ("datasets" === b2[e4]) {
            D2 = b2[e4 + 1];
            S2 = true;
          }
          null === D2 && (D2 = Q2.getNewTemporaryRef());
        } else b2 && warn("Unsupported XFA type.");
        let k2 = /* @__PURE__ */ Object.create(null);
        if (Q2.trailer) {
          const e4 = /* @__PURE__ */ Object.create(null), t4 = Q2.trailer.get("Info") || null;
          t4 instanceof Dict && t4.forEach((t5, i3) => {
            "string" == typeof i3 && (e4[t5] = stringToPDFString(i3));
          });
          k2 = {
            rootRef: d2,
            encryptRef: Q2.trailer.getRaw("Encrypt") || null,
            newRef: Q2.getNewTemporaryRef(),
            infoRef: Q2.trailer.getRaw("Info") || null,
            info: e4,
            fileIds: Q2.trailer.get("ID") || null,
            startXRef: E2 ? h3 : Q2.lastXRefStreamPos ?? h3,
            filename: r3
          };
        }
        return incrementalUpdate({
          originalData: g3.bytes,
          xrefInfo: k2,
          newRefs: m2,
          xref: Q2,
          hasXfa: !!b2,
          xfaDatasetsRef: D2,
          hasXfaDatasetsEntry: S2,
          needAppearances: w2,
          acroFormRef: C3,
          acroForm: c3,
          xfaData: y2,
          useXrefStream: isDict(Q2.topDict, "XRef")
        }).finally(() => {
          Q2.resetNewTemporaryRef();
        });
      });
      l2.on("GetOperatorList", function(e3, t3) {
        const a3 = e3.pageIndex;
        i2.getPage(a3).then(function(i3) {
          const r3 = new WorkerTask(`GetOperatorList: page ${a3}`);
          startWorkerTask(r3);
          const s3 = n2 >= wA.INFOS ? Date.now() : 0;
          i3.getOperatorList({
            handler: l2,
            sink: t3,
            task: r3,
            intent: e3.intent,
            cacheKey: e3.cacheKey,
            annotationStorage: e3.annotationStorage,
            modifiedIds: e3.modifiedIds
          }).then(function(e4) {
            finishWorkerTask(r3);
            s3 && info(`page=${a3 + 1} - getOperatorList: time=${Date.now() - s3}ms, len=${e4.length}`);
            t3.close();
          }, function(e4) {
            finishWorkerTask(r3);
            r3.terminated || t3.error(e4);
          });
        });
      });
      l2.on("GetTextContent", function(e3, t3) {
        const { pageIndex: a3, includeMarkedContent: r3, disableNormalization: s3 } = e3;
        i2.getPage(a3).then(function(e4) {
          const i3 = new WorkerTask("GetTextContent: page " + a3);
          startWorkerTask(i3);
          const o3 = n2 >= wA.INFOS ? Date.now() : 0;
          e4.extractTextContent({
            handler: l2,
            task: i3,
            sink: t3,
            includeMarkedContent: r3,
            disableNormalization: s3
          }).then(function() {
            finishWorkerTask(i3);
            o3 && info(`page=${a3 + 1} - getTextContent: time=` + (Date.now() - o3) + "ms");
            t3.close();
          }, function(e5) {
            finishWorkerTask(i3);
            i3.terminated || t3.error(e5);
          });
        });
      });
      l2.on("GetStructTree", function(e3) {
        return i2.getPage(e3.pageIndex).then(function(e4) {
          return i2.ensure(e4, "getStructTree");
        });
      });
      l2.on("FontFallback", function(e3) {
        return i2.fontFallback(e3.id, l2);
      });
      l2.on("Cleanup", function(e3) {
        return i2.cleanup(true);
      });
      l2.on("Terminate", function(e3) {
        a2 = true;
        const t3 = [];
        if (i2) {
          i2.terminate(new AbortException("Worker was terminated."));
          const e4 = i2.cleanup();
          t3.push(e4);
          i2 = null;
        } else clearGlobalCaches();
        r2 == null ? void 0 : r2(new AbortException("Worker was terminated."));
        for (const e4 of s2) {
          t3.push(e4.finished);
          e4.terminate();
        }
        return Promise.all(t3).then(function() {
          l2.destroy();
          l2 = null;
        });
      });
      l2.on("Ready", function(t3) {
        setupDoc(e2);
        e2 = null;
      });
      return h2;
    }
    static initializeFromPort(e2) {
      const t2 = new MessageHandler("worker", "main", e2);
      WorkerMessageHandler.setup(t2, e2);
      t2.send("ready", null);
    }
  }
  "undefined" == typeof window && !i && "undefined" != typeof self && function isMessagePort(e2) {
    return "function" == typeof e2.postMessage && "onmessage" in e2;
  }(self) && WorkerMessageHandler.initializeFromPort(self);
  bo = __webpack_exports__.WorkerMessageHandler;
});
export {
  bo as WorkerMessageHandler,
  __tla
};
